[{"content":"深度优先搜索 深度优先搜索算法基于栈数据结构实现 对于递归形式的深度优先搜索算法，函数调用栈充当栈数据结构 对于迭代形式的深度优先搜索算法，需要显式定义栈数据结构 深度优先搜索算法最大限度地探索每条路径，当遇到死胡同（dead end）时，将回溯到原出发点，并选择新的路径继续搜索 深度优先搜索算法的搜索顺序取决于邻居结点的被访问的顺序 递归实现 import java.util.LinkedList; class Graph { // Number of vertices private int vertices; // Adjacency list representation of the graph private LinkedList\u0026lt;Integer\u0026gt;[] adjList; public Graph(int vertices) { this.vertices = vertices; // Initialize adjacency list adjList = new LinkedList[vertices]; for (int i = 0; i \u003c vertices; i++) { adjList[i] = new LinkedList\u0026lt;\u0026gt;(); } } // Add edge to the undirected graph public void addEdge(int src, int dest) { adjList[src].add(dest); adjList[dest].add(src); } // Add edge to the graph (directed) public void addDirectedEdge(int src, int dest) { adjList[src].add(dest); } // Print the graph public void printGraph() { for (int i = 0; i \u003c vertices; i++) { System.out.print(\"Vertex \" + i + \":\"); for (Integer node : adjList[i]) { System.out.print(\" -\u003e \" + node); } System.out.println(); } } // Depth-First Search (DFS) public void dfs(int startVertex) { boolean[] visited = new boolean[vertices]; dfs(startVertex, visited); System.out.println(); } private void dfs(int vertex, boolean[] visited) { visited[vertex] = true; System.out.print(vertex + \" \"); // base case 隐藏在 for 循环中 for (int adjVertex : adjList[vertex]) { if (!visited[adjVertex]) { dfs(adjVertex, visited); } } } public static void main(String[] args) { Graph graph = new Graph(6); graph.addDirectedEdge(0,1); graph.addDirectedEdge(0,2); graph.addDirectedEdge(0,4); graph.addDirectedEdge(1,3); graph.addDirectedEdge(2,4); graph.addDirectedEdge(5,3); graph.addDirectedEdge(4,1); System.out.println(\"Graph:\"); graph.printGraph(); System.out.println(\"DFS starting from vertex 0:\"); graph.dfs(0); } } 图及其邻接表 递归深度优先搜索进出栈顺序图 迭代实现 import java.util.LinkedList; import java.util.Stack; class Graph { // Number of vertices private int vertices; // Adjacency list representation of the graph private LinkedList\u0026lt;Integer\u0026gt;[] adjList; public Graph(int vertices) { this.vertices = vertices; // Initialize adjacency list adjList = new LinkedList[vertices]; for (int i = 0; i \u003c vertices; i++) { adjList[i] = new LinkedList\u0026lt;\u0026gt;(); } } // Add edge to the undirected graph public void addEdge(int src, int dest) { adjList[src].add(dest); adjList[dest].add(src); } // Add edge to the graph (directed) public void addDirectedEdge(int src, int dest) { adjList[src].add(dest); } // Print the graph public void printGraph() { for (int i = 0; i \u003c vertices; i++) { System.out.print(\"Vertex \" + i + \":\"); for (Integer node : adjList[i]) { System.out.print(\" -\u003e \" + node); } System.out.println(); } } // Depth-First Search (DFS) public void dfs(int startVertex) { boolean[] visited = new boolean[vertices]; Stack stack = new Stack\u0026lt;\u0026gt;(); stack.push(startVertex); while (!stack.isEmpty()) { int vertex = stack.pop(); if (!visited[vertex]) { System.out.print(vertex + \" \"); visited[vertex] = true; } for (int adjVertex : adjList[vertex]) { if (!visited[adjVertex]) { stack.push(adjVertex); } } } System.out.println(); } public static void main(String[] args) { Graph graph = new Graph(6); graph.addDirectedEdge(0,1); graph.addDirectedEdge(0,2); graph.addDirectedEdge(0,4); graph.addDirectedEdge(1,3); graph.addDirectedEdge(2,4); graph.addDirectedEdge(5,3); graph.addDirectedEdge(4,1); System.out.println(\"Graph:\"); graph.printGraph(); System.out.println(\"DFS starting from vertex 0:\"); graph.dfs(0); } } 迭代深度优先搜索进出栈顺序图 广度优先搜索 广度优先搜索算法基于队列数据结构实现 广度优先搜索算法会先遍历当前深度层级的所有节点，然后再遍历下一个深度层级的节点 import java.util.LinkedList; class Graph { // Number of vertices private int vertices; // Adjacency list representation of the graph private LinkedList\u0026lt;Integer\u0026gt;[] adjList; public Graph(int vertices) { this.vertices = vertices; // Initialize adjacency list adjList = new LinkedList[vertices]; for (int i = 0; i \u003c vertices; i++) { adjList[i] = new LinkedList\u0026lt;\u0026gt;(); } } // Add edge to the undirected graph public void addEdge(int src, int dest) { adjList[src].add(dest); adjList[dest].add(src); } // Add edge to the graph (directed) public void addDirectedEdge(int src, int dest) { adjList[src].add(dest); } // Print the graph public void printGraph() { for (int i = 0; i \u003c vertices; i++) { System.out.print(\"Vertex \" + i + \":\"); for (Integer node : adjList[i]) { System.out.print(\" -\u003e \" + node); } System.out.println(); } } // Breadth-First Search (BFS) public void bfs(int startVertex) { boolean[] visited = new boolean[vertices]; LinkedList\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); visited[startVertex] = true; queue.add(startVertex); while (!queue.isEmpty()) { int vertex = queue.poll(); System.out.print(vertex + \" \"); for (int adjVertex : adjList[vertex]) { if (!visited[adjVertex]) { visited[adjVertex] = true; queue.add(adjVertex); } } } System.out.println(); } public static void main(String[] args) { Graph graph = new Graph(6); graph.addDirectedEdge(0, 1); graph.addDirectedEdge(0, 2); graph.addDirectedEdge(0, 4); graph.addDirectedEdge(1, 3); graph.addDirectedEdge(2, 4); graph.addDirectedEdge(5, 3); graph.addDirectedEdge(4, 1); System.out.println(\"Graph:\"); graph.printGraph(); System.out.println(\"BFS starting from vertex 0:\"); graph.bfs(0); } } 判断两点间路径是否存在 图及其邻接表 import java.util.LinkedList; class Graph { // Number of vertices private int vertices; // Adjacency list representation of the graph private LinkedList\u0026lt;Integer\u0026gt;[] adjList; public Graph(int vertices) { this.vertices = vertices; // Initialize adjacency list adjList = new LinkedList[vertices]; for (int i = 0; i \u003c vertices; i++) { adjList[i] = new LinkedList\u0026lt;\u0026gt;(); } } // Add edge to the undirected graph public void addEdge(int src, int dest) { adjList[src].add(dest); adjList[dest].add(src); } // Add edge to the graph (directed) public void addDirectedEdge(int src, int dest) { adjList[src].add(dest); } // Print the graph public void printGraph() { for (int i = 0; i \u003c vertices; i++) { System.out.print(\"Vertex \" + i + \":\"); for (Integer node : adjList[i]) { System.out.print(\" -\u003e \" + node); } System.out.println(); } } // Function to determine if there is a path between two vertices public boolean hasPath(int startVertex, int endVertex) { boolean[] visited = new boolean[vertices]; return hasPathDFS(startVertex, endVertex, visited); } private boolean hasPathDFS(int current, int endVertex, boolean[] visited) { if (current == endVertex) { return true; } visited[current] = true; for (int adjVertex : adjList[current]) { if (!visited[adjVertex]) { if (hasPathDFS(adjVertex, endVertex, visited)) { return true; } } } return false; } public static void main(String[] args) { Graph graph = new Graph(6); graph.addDirectedEdge(0, 1); graph.addDirectedEdge(0, 2); graph.addDirectedEdge(0, 4); graph.addDirectedEdge(1, 3); graph.addDirectedEdge(2, 4); graph.addDirectedEdge(5, 3); graph.addDirectedEdge(4, 1); System.out.println(\"Graph:\"); graph.printGraph(); System.out.println(\"Is there a path from \" + 0 + \" to \" + 3 + \"? \" + graph.hasPath(0, 3)); // true System.out.println(\"Is there a path from \" + 1 + \" to \" + 5 + \"? \" + graph.hasPath(1, 5)); // flase } } 无向路径 点击查看题目 连接点计算 最大结点 最短路径 岛的数量 最少岛屿 ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/algorithms/6-graph/","summary":"深度优先搜索 深度优先搜索算法基于栈数据结构实现 对于递归形式的深度优先搜索算法，函数调用栈充当栈数据结构 对于迭代形式的深度优先搜索算法，需要显式定义栈数据结构 深度优先搜索算法最大限度地探索每条路径，当遇到死胡同（dead end）时，将回溯到原出发点，并选择新的路径继续搜索 深度优先搜索算法的搜索顺序取决于邻居结点的被访问的顺序 递归实现 import java.util.LinkedList; class Graph { // Number of vertices private int vertices; // Adjacency list representation of the graph private LinkedList\u0026lt;Integer\u0026gt;[] adjList; public Graph(int vertices) { this.vertices = vertices; // Initialize adjacency list adjList = new LinkedList[vertices]; for (int i = 0; i \u003c vertices; i++) { adjList[i] = new LinkedList\u0026lt;\u0026gt;(); } } // Add edge to the undirected graph public void addEdge(int src, int dest) { adjList[src].","title":"数据结构与算法：图"},{"content":"递归定义 递归（Recursion）是指函数在执行过程中调用自身的过程，通常用于将问题划分为类似的子问题。递归函数通常由两部分组成：\n基本情况（Base Case(s)）：基本情况指的是函数用于避免无限递归、停止调用自身的条件。（寻找最小子问题） 递归情况（Recursive Case(s)）：递归情况是指函数使用不同参数调用自身，并逐渐向基本情况靠拢。（寻找每调用一次函数能缩小问题规模的最小单元） 例题 字符串反转 点击查看题目 字符串反转：\u0026ldquo;signal yu\u0026rdquo; 输出为 \u0026ldquo;uy langis\u0026rdquo; 基本情况：当字符串 s 为空串时返回 \u0026quot;\u0026quot;，当字符串 s 长度为 1 时，返回 s，即当字符串长度小于等于 1 时，返回 s。 递归情况：执行一次函数操作一个字符，因此每调用一次函数能缩小问题规模的最小单元为 1。 public class ReverseString { // 递归方法反转字符串 public static String reverseString(String s) { // 基本情况：如果字符串为空或只有一个字符，直接返回它 if (s.length() \u003c= 1) { return s; } // 递归情况：取出第一个字符，并将剩余字符串反转后再将第一个字符加到末尾 return reverseString(s.substring(1)) + s.charAt(0); } public static void main(String[] args) { String inputStr = \"signal yu\"; String reversedStr = reverseString(inputStr); System.out.println(reversedStr); // uy langis } } 反转字符串调用栈 回文字符串（Palindrom） 点击查看题目 如果一个序列是对称的，即从左往右读与从右往左读完全相同，那么它就被认为是一个回文字符串，例如 \u0026ldquo;radar\u0026rdquo;, \u0026ldquo;level\u0026rdquo;, \u0026ldquo;madam\u0026rdquo;。 基本情况：字符串长度为 0 或 1 递归情况：每调用一次函数能缩小问题规模的最小单元为 2（去掉首尾字符） public class Palindrome { public static boolean isPalindrome(String str) { // Base case: if the string is empty or has one character, it is a palindrome if (str.isEmpty() || str.length() == 1) { return true; } // Check if the first and last characters are the same if (str.charAt(0) == str.charAt(str.length() - 1)) { // Recur with the substring excluding the first and last characters return isPalindrome(str.substring(1, str.length() - 1)); } // If the first and last characters are not the same, it is not a palindrome return false; } public static void main(String[] args) { String[] testStrings = {\"racecar\", \"madam\", \"hello\", \"A\", \"\", \"level\"}; for (String str : testStrings) { if (isPalindrome(str)) { System.out.println(str + \" is a palindrome.\"); } else { System.out.println(str + \" is not a palindrome.\"); } } } } 回文字符串调用栈 I 回文字符串调用栈 II 十进制转二进制 点击查看题目 将指定的十进制数字，返回其二进制表示形式。例如 10 的二进制形式为 1010。 基本情况：当数字为 1 时，当数字为 0 时，返回 0. 递归情况：每调用一次函数能缩小问题规模的最小单元为原问题的一半。 public class DecimalToBinary { public static String decimalToBinary(int n) { // Base case: if the number is 0, return \"0\" if (n == 0) { return \"0\"; } // If the number is 1, return \"1\" if (n == 1) { return \"1\"; } // Recursive call: divide the number by 2 and concatenate the remainder return decimalToBinary(n / 2) + (n % 2); } public static void main(String[] args) { int[] testNumbers = {0, 1, 2, 3, 4, 5, 10, 255}; for (int number : testNumbers) { System.out.println(\"Decimal: \" + number + \" -\u003e Binary: \" + decimalToBinary(number)); } } } 十进制转二进制调用栈 分而治之（Divide and Conquer） 分治算法（Divide and Conquer）的核心思想为：\n分（Divide）：将原问题不断分解为更小的子问题 治（Conquer）：递归解决子问题，对于基本情况（Base Case）则直接求解 合（Combine）：将子问题的求解结果合并，以获得原问题的解 二分查找 归并排序 归并排序核心思想如下：\n递归地将数组划分为两部分，直至不能进一步划分（数组中的元素只有一个） 递归地将排序后的数组进行合并 归并排序——划分数组 归并排序——合并数组 需要注意的是，归并排序并不是将所有子数组都划分至最小子数组后才进行合并，而是先将某一分支上的数组划分至最小子数组，然后对该分支的元素进行合并。具体过程如下列视频所示： import java.util.Arrays; public class MergeSort { // Method to merge two halves public static void merge(int[] arr, int left, int mid, int right) { int n1 = mid - left + 1; int n2 = right - mid; // Create temporary arrays int[] leftArray = new int[n1]; int[] rightArray = new int[n2]; // Copy data to temp arrays for (int i = 0; i \u003c n1; i++) { leftArray[i] = arr[left + i]; } for (int j = 0; j \u003c n2; j++) { rightArray[j] = arr[mid + 1 + j]; } // Merge the temp arrays // Initial indexes of first and second subarrays int i = 0, j = 0; // Initial index of merged subarray int k = left; while (i \u003c n1 \u0026\u0026 j \u003c n2) { if (leftArray[i] \u003c= rightArray[j]) { arr[k++] = leftArray[i++]; } else { arr[k++] = rightArray[j++]; } } // Copy remaining elements of leftArray if any while (i \u003c n1) { arr[k++] = leftArray[i++]; } // Copy remaining elements of rightArray if any while (j \u003c n2) { arr[k++] = rightArray[j++]; } } // Main function that sorts arr[left...right] using merge() public static void mergeSort(int[] arr, int left, int right) { if (left \u003c right) { // Find the middle point int mid = left + (right - left) / 2; // Sort first and second halves mergeSort(arr, left, mid); mergeSort(arr, mid + 1, right); // Merge the sorted halves merge(arr, left, mid, right); } } public static void main(String[] args) { int[] arr1 = {3, 7, 8, 5, 4, 2, 6, 1}; System.out.println(\"arr1 = \" + Arrays.toString(arr1)); mergeSort(arr1, 0, arr1.length - 1); System.out.println(\"Sorted arr1 = \" + Arrays.toString(arr1)); } } 快速排序 快速排序（Quick Sort）的核心思想如下：\n选择基准（Pivot）：从数组中选择一个元素作为基准。 分区（Partition）：将数组重新排列，使得比中枢值小的元素都排在基准的左边，比基准值大的元素都排在基准的右边。 递归排序：对基准左边和右边的子数组分别递归地应用快速排序算法。 合并结果： 将左边子数组、基准和右边子数组合并起来，得到最终的排序结果。 快速排序的基准元素选择通常有三种：第一个元素、随机元素和最后一个元素。\n当选择随机元素为基准元素时，在排序之前将它与第一个元素或最后一个元素进行交换后再排序即可。\n点击查看代码 最后一个元素作为基准元素 第一个元素作为基准元素 随机元素作为基准元素 import java.util.Arrays; public class QuickSort { // Method to perform Quick Sort public static void quickSort(int[] array, int low, int high) { if (low \u003c high) { // Partition the array and get the pivot index int pivotIndex = partition(array, low, high); // Recursively sort elements before and after partition quickSort(array, low, pivotIndex - 1); quickSort(array, pivotIndex + 1, high); } } // Method to partition the array private static int partition(int[] array, int low, int high) { // Choose the pivot (here we are choosing the last element as pivot) int pivot = array[high]; int i = low - 1; for (int j = low; j \u003c high; j++) { if (array[j] \u003c pivot) { i++; // Swap array[i] and array[j] int temp = array[i]; array[i] = array[j]; array[j] = temp; } } i++; // Swap array[i] and pivot int temp = array[i]; array[i] = array[high]; array[high] = temp; return i; // return index of new pivot } // Main method to test the Quick Sort algorithm public static void main(String[] args) { int[] array = {8, 2, 4, 7, 1, 3, 9, 6, 5}; System.out.println(\"Unsorted array: \" + Arrays.toString(array)); quickSort(array, 0, array.length - 1); System.out.println(\"Sorted array: \" + Arrays.toString(array)); } } import java.util.Arrays; public class QuickSort { // Method to partition the array and return the pivot index private static int partition(int[] arr, int low, int high) { // Choose the pivot element (first element of the array) int pivot = arr[low]; // Index of the smaller element int i = low; for (int j = low + 1; j \u003c= high; j++) { // If current element is smaller than the pivot if (arr[j] \u003c= pivot) { // Comparison should include equality to maintain stability i++; // Swap arr[i] and arr[j] int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } // Swap arr[i] and pivot int temp = arr[low]; arr[low] = arr[i]; arr[i] = temp; // Return the pivot index return i; } // Recursive method to partition and sort subarrays private static void quickSort(int[] arr, int low, int high) { if (low \u003c high) { // Partition the array and get the pivot index int pivotIndex = partition(arr, low, high); // Recursively sort the left and right subarrays quickSort(arr, low, pivotIndex - 1); quickSort(arr, pivotIndex + 1, high); } } // Main method to test the quick sort algorithm public static void main(String[] args) { int[] array = {8, 2, 4, 7, 1, 3, 9, 6, 5}; System.out.println(\"Unsorted array: \" + Arrays.toString(array)); quickSort(array, 0, array.length - 1); System.out.println(\"Sorted array: \" + Arrays.toString(array)); } } import java.util.Arrays; import java.util.Random; public class QuickSort { // Method to perform Quick Sort public static void quickSort(int[] array, int low, int high) { if (low \u003c high) { // Randomize pivot and partition the array int pivotIndex = partition(array, low, high); // Recursively sort elements before and after partition quickSort(array, low, pivotIndex - 1); quickSort(array, pivotIndex + 1, high); } } // Method to partition the array private static int partition(int[] array, int low, int high) { // Choose the pivot (here it is the last element after randomization) int pivotIndex = low + new Random().nextInt(high - low + 1); swap(array, pivotIndex, high); // Move the pivot element to the end int pivot = array[high]; int i = low - 1; for (int j = low; j \u003c high; j++) { if (array[j] \u003c= pivot) { i++; // Swap array[i] and array[j] swap(array, i, j); } } i++; // Swap array[i] and pivot swap(array, i, high); return i; // return new pivot index } // Utility method to swap two elements in the array private static void swap(int[] array, int i, int j) { int temp = array[i]; array[i] = array[j]; array[j] = temp; } // Main method to test the quick sort algorithm public static void main(String[] args) { int[] array = {8, 2, 4, 7, 1, 3, 9, 6, 5}; System.out.println(\"Unsorted array: \" + Arrays.toString(array)); quickSort(array, 0, array.length - 1); System.out.println(\"Sorted array: \" + Arrays.toString(array)); } } 链表反转 基本情况：链表为空或者链表中仅有一个结点 递归情况：每调用一次函数能缩小问题规模的最小单元为 1 public class LinkedList { Node head; static class Node { int data; Node next; // Constructor to create a new node Node(int data) { this.data = data; next = null; } } Node reverse(Node head) { // if (head == null || head.next == null) { return head; } // Reverse the rest of the list Node p = reverse(head.next); // Set the next of the last node to the current head head.next.next = head; // Set the next of the current head to null head.next = null; // Return the new head of the reversed list return p; } // Utility function to print the linked list void printList(Node head) { Node temp = head; while (temp != null) { System.out.print(temp.data + \"-\u003e\"); temp = temp.next; } System.out.println(\"null\"); } public static void main(String[] args) { LinkedList list = new LinkedList(); list.head = new Node(1); list.head.next = new Node(2); list.head.next.next = new Node(3); list.head.next.next.next = new Node(4); list.head.next.next.next.next = new Node(5); list.head.next.next.next.next.next = new Node(6); System.out.println(\"Original Linked List:\"); list.printList(list.head); list.head = list.reverse(list.head); System.out.println(\"Reversed Linked List:\"); list.printList(list.head); } } 链表反转调用栈——入栈 链表反转调用栈——出栈 有序链表合并 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。\npublic class LinkedList { static class Node { int data; Node next; // Constructor to create a new node Node(int data) { this.data = data; next = null; } } // Utility function to print the linked list void printList(Node head) { Node temp = head; while (temp != null) { System.out.print(temp.data + \"-\u003e\"); temp = temp.next; } System.out.println(\"null\"); } public Node mergeTwoLists(Node A, Node B) { if (A == null) { return B; } if (B == null) { return A; } if (A.data \u003c= B.data) { A.next = mergeTwoLists(A.next, B); return A; } else { B.next = mergeTwoLists(A, B.next); return B; } } public static void main(String[] args) { // Create first sorted list: 1 -\u003e 8 -\u003e 22 Node l1 = new Node(1); l1.next = new Node(8); l1.next.next = new Node(22); // Create second sorted list: 4 -\u003e 11 -\u003e 16 Node l2 = new Node(4); l2.next = new Node(11); l2.next.next = new Node(16); // Merge the lists LinkedList solution = new LinkedList(); Node mergedList = solution.mergeTwoLists(l1, l2); // Print the merged list: 1 -\u003e 4 -\u003e 8 -\u003e 16 -\u003e 22 -\u003e null new LinkedList().printList(mergedList); } } 合并两个有序链表入栈与出栈 二叉搜索树插值 public class BinarySearchTree { static class Node { int data; Node left, right; public Node(int item) { data = item; left = right = null; } } Node root; public BinarySearchTree() { root = null; } // A recursive function to insert a new key in BST public Node insert(Node root, int key) { // If the tree is empty, return a new node if (root == null) { root = new Node(key); return root; } // Otherwise, recur down the tree if (key \u003c root.data) { root.left = insert(root.left, key); } else if (key \u003e root.data) { root.right = insert(root.right, key); } // return the (unchanged) node pointer return root; } public static void main(String[] args) { BinarySearchTree tree = new BinarySearchTree(); /* Create following BST 50 / \\ 30 70 / \\ / \\ 20 40 60 80 */ tree.root = tree.insert(tree.root, 50); tree.insert(tree.root, 30); tree.insert(tree.root, 20); tree.insert(tree.root, 40); tree.insert(tree.root, 70); tree.insert(tree.root, 60); tree.insert(tree.root, 80); } } 二叉搜索树插值调用栈 打印所有叶子结点 public class BinarySearchTree { static class Node { int data; Node left, right; public Node(int item) { data = item; left = right = null; } } Node root; public BinarySearchTree() { } // A recursive function to insert a new key in BST public Node insert(Node root, int key) { // If the tree is empty, return a new node if (root == null) { root = new Node(key); return root; } // Otherwise, recur down the tree if (key \u003c root.data) { root.left = insert(root.left, key); } else if (key \u003e root.data) { root.right = insert(root.right, key); } // return the (unchanged) node pointer return root; } // A recursive function to print all leaf nodes of the BST public void printAllLeafNodes(Node root) { if (root == null) return; // Check if this node is a leaf node if (root.left == null \u0026\u0026 root.right == null) { System.out.print(root.data + \" \"); return; } // Otherwise, recur for the left and right subtree if (root.left != null) printAllLeafNodes(root.left); if (root.right != null) printAllLeafNodes(root.right); } // Driver Program to test above functions public static void main(String[] args) { BinarySearchTree tree = new BinarySearchTree(); /* Create following BST 50 / \\ 30 70 / \\ / \\ 20 40 60 80 */ tree.root = tree.insert(tree.root, 50); tree.insert(tree.root, 30); tree.insert(tree.root, 20); tree.insert(tree.root, 40); tree.insert(tree.root, 70); tree.insert(tree.root, 60); tree.insert(tree.root, 80); // Print all leaf nodes System.out.println(\"Leaf nodes of the BST:\"); tree.printAllLeafNodes(tree.root); } } 深度优先搜索算法 深度优先搜索算法基于栈数据结构实现 对于递归形式的深度优先搜索算法，函数调用栈充当栈数据结构 对于迭代形式的深度优先搜索算法，需要显式定义栈数据结构 深度优先搜索算法最大限度地探索每条路径，当遇到死胡同（dead end）时，将回溯到原出发点，并选择新的路径继续搜索 深度优先搜索算法的搜索顺序取决于邻居结点的被访问的顺序 import java.util.LinkedList; class Graph { // Number of vertices private int vertices; // Adjacency list representation of the graph private LinkedList\u0026lt;Integer\u0026gt;[] adjList; public Graph(int vertices) { this.vertices = vertices; // Initialize adjacency list adjList = new LinkedList[vertices]; for (int i = 0; i \u003c vertices; i++) { adjList[i] = new LinkedList\u0026lt;\u0026gt;(); } } // Add edge to the undirected graph public void addEdge(int src, int dest) { adjList[src].add(dest); adjList[dest].add(src); } // Add edge to the graph (directed) public void addDirectedEdge(int src, int dest) { adjList[src].add(dest); } // Print the graph public void printGraph() { for (int i = 0; i \u003c vertices; i++) { System.out.print(\"Vertex \" + i + \":\"); for (Integer node : adjList[i]) { System.out.print(\" -\u003e \" + node); } System.out.println(); } } // Depth-First Search (DFS) public void dfs(int startVertex) { boolean[] visited = new boolean[vertices]; dfs(startVertex, visited); System.out.println(); } private void dfs(int vertex, boolean[] visited) { visited[vertex] = true; System.out.print(vertex + \" \"); // base case 隐藏在 for 循环中 for (int adjVertex : adjList[vertex]) { if (!visited[adjVertex]) { dfs(adjVertex, visited); } } } public static void main(String[] args) { Graph graph = new Graph(6); graph.addDirectedEdge(0,1); graph.addDirectedEdge(0,2); graph.addDirectedEdge(0,4); graph.addDirectedEdge(1,3); graph.addDirectedEdge(2,4); graph.addDirectedEdge(5,3); graph.addDirectedEdge(4,1); System.out.println(\"Graph:\"); graph.printGraph(); System.out.println(\"DFS starting from vertex 0:\"); graph.dfs(0); } } 递归深度优先搜索进出栈顺序图 递归优化 使用缓存：使用缓存存储重复计算的值，需要时直接使用即可 点击查看代码 不使用缓存 使用缓存 public static long fib(int n) { if (n == 1) { return 0; } if (n == 2) { return 1; } return fib(n - 1) + fib(n - 2); } import java.util.HashMap; import java.util.Map; public class Fibonacci { // 使用 HashMap 来存储已经计算过的斐波那契数 private Map\u0026lt;Integer, Long\u0026gt; cache = new HashMap\u0026lt;\u0026gt;(); public long fib(int n) { // 基本情况 if (n == 1) { return 0; } if (n == 2) { return 1; } // 检查缓存中是否已有结果 if (cache.containsKey(n)) { return cache.get(n); } // 递归计算斐波那契数，并存储结果到缓存中 long result = fib(n - 1) + fib(n - 2); cache.put(n, result); return result; } } --- title: 斐波那契：暴力递归（不使用缓存） --- flowchart TB f6((\"fib(6)\")) --\u003e f5((\"fib(5)\")) f6 --\u003e f4((\"fib(4)\")) f5 --\u003e f41((\"fib(4)\")) f5 --\u003e f3((\"fib(3)\")) f4 --\u003e f31((\"fib(3)\")) f4 --\u003e f2((\"fib(2)\")) f41 --\u003e f32((\"fib(3)\")) f41 --\u003e f21((\"fib(2)\")) f3 --\u003e f20((\"fib(2)\")) f3 --\u003e f10((\"fib(1)\")) f31 --\u003e f22((\"fib(2)\")) f31 --\u003e f1((\"fib(1)\")) f32 --\u003e f23((\"fib(2)\")) f32 --\u003e f11((\"fib(1)\")) style f5 fill:lightblue,color:black style f4 fill:orange,color:black style f41 fill:orange,color:black style f3 fill:red style f31 fill:red style f32 fill:red style f20 fill:purple style f2 fill:purple style f21 fill:purple style f22 fill:purple style f23 fill:purple style f1 fill:grey style f11 fill:grey style f10 fill:grey 斐波那契：递归 \u0026#43; 缓存 2. 尾调用递归（Tail-Call Recursion）优化：当函数调用是尾递归调用时，编译器可以优化递归调用以避免在调用栈中添加新的帧。换句话说，编译器可以重复使用当前函数的堆栈帧，从而有效地将递归转化为迭代。（Python、JVM 等并不支持尾递归调用优化）\n点击查看代码 递归 尾递归 public static long factorial(int n) { if (n == 1) { return 1; } return n * factorial(n - 1); } /* factorial(5) 5 * factorial(4) 5 * (4 * factorial(3)) 5 * (4 * (3 * factorial(2))) 5 * (4 * (3 * (2 * factorial(1)))) 5 * (4 * (3 * (2 * 1))) 5 * (4 * (3 * 2))) 5 * (4 * 6)) 5 * 24 120 */ public static long tailFactorial(int n) { return tailFactorial(n, 1); } public static long tailFactorial(int n, int acc) { if (n == 1) { return acc; } return tailFactorial(n - 1, n * acc); } ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/algorithms/3-recursion/","summary":"递归定义 递归（Recursion）是指函数在执行过程中调用自身的过程，通常用于将问题划分为类似的子问题。递归函数通常由两部分组成：\n基本情况（Base Case(s)）：基本情况指的是函数用于避免无限递归、停止调用自身的条件。（寻找最小子问题） 递归情况（Recursive Case(s)）：递归情况是指函数使用不同参数调用自身，并逐渐向基本情况靠拢。（寻找每调用一次函数能缩小问题规模的最小单元） 例题 字符串反转 点击查看题目 字符串反转：\u0026ldquo;signal yu\u0026rdquo; 输出为 \u0026ldquo;uy langis\u0026rdquo; 基本情况：当字符串 s 为空串时返回 \u0026quot;\u0026quot;，当字符串 s 长度为 1 时，返回 s，即当字符串长度小于等于 1 时，返回 s。 递归情况：执行一次函数操作一个字符，因此每调用一次函数能缩小问题规模的最小单元为 1。 public class ReverseString { // 递归方法反转字符串 public static String reverseString(String s) { // 基本情况：如果字符串为空或只有一个字符，直接返回它 if (s.length() \u003c= 1) { return s; } // 递归情况：取出第一个字符，并将剩余字符串反转后再将第一个字符加到末尾 return reverseString(s.substring(1)) + s.charAt(0); } public static void main(String[] args) { String inputStr = \"signal yu\"; String reversedStr = reverseString(inputStr); System.","title":"数据结构与算法：递归"},{"content":"动态规划相关概念 动态规划核心思想： 将原问题划分为更简单的子问题，通过子问题的解来构建问题的解。 Memoization（自上而下法）：将原问题递归地划分为更小的子问题，并在对子问题的结果进行缓存，以避免重复计算。 Tabulation（自下而上法）：从最小的子问题开始，迭代地构建原问题的解。 动态规划例题 斐波那契数列 点击查看题目 斐波那契数（通常用 $F(n)$ 表示）形成的序列称为斐波那契数列。该数列由 $0$ 和 $1$ 开始，后面的每一项数字都是前面两项数字的和。也就是：\n$F(1) = 0，F(2) = 1$\n$F(n) = F(n - 1) + F(n - 2)，其中\\; n \u0026gt; 2$\n给定 $n$ ，请计算 $F(n)$。\n示例 1：\n输入：$n = 2$\n输出：$1$\n解释：$F(2) = 1$\n示例 2：\n输入：$n = 3$\n输出：$2$\n解释：$F(3) = F(2) + F(1) = 1 + 0 = 1$\n示例 3：\n输入：$n = 4$\n输出：$3$\n解释：$F(4) = F(3) + F(2) = 1 + 1 = 2$\n提示：$1 \\le n \\le 30$ 解法一：暴力递归 --- title: 斐波那契：暴力递归 --- flowchart TB f6((\"fib(6)\")) --\u003e f5((\"fib(5)\")) f6 --\u003e f4((\"fib(4)\")) f5 --\u003e f41((\"fib(4)\")) f5 --\u003e f3((\"fib(3)\")) f4 --\u003e f31((\"fib(3)\")) f4 --\u003e f2((\"fib(2)\")) f41 --\u003e f32((\"fib(3)\")) f41 --\u003e f21((\"fib(2)\")) f3 --\u003e f20((\"fib(2)\")) f3 --\u003e f10((\"fib(1)\")) f31 --\u003e f22((\"fib(2)\")) f31 --\u003e f1((\"fib(1)\")) f32 --\u003e f23((\"fib(2)\")) f32 --\u003e f11((\"fib(1)\")) style f5 fill:lightblue,color:black style f4 fill:orange,color:black style f41 fill:orange,color:black style f3 fill:red style f31 fill:red style f32 fill:red style f20 fill:purple style f2 fill:purple style f21 fill:purple style f22 fill:purple style f23 fill:purple style f1 fill:grey style f11 fill:grey style f10 fill:grey public static long fib(int n) { if (n == 1) { return 0; } if (n == 2) { return 1; } return fib(n - 1) + fib(n - 2); } 如上图所示，暴力递归过程中，只有 $fib(6)$ 和 $fib(5)$ 计算了 1 次，$fib(4)$，$fib(3)$，$fib(2)$，$fib(1)$ 都进行了重复计算。\n解法二：递归 + 缓存 Memoization（自上而下法）：在递归求解子问题时，将子问题的结果缓存起来，之后计算相同的子问题时，直接从缓存中获取结果，以避免重复计算。\n斐波那契：递归 \u0026#43; 缓存 import java.util.HashMap; import java.util.Map; public class Fibonacci { // 使用 HashMap 来存储已经计算过的斐波那契数 private Map\u0026lt;Integer, Long\u0026gt; cache = new HashMap\u0026lt;\u0026gt;(); public long fib(int n) { // 基本情况 if (n == 1) { return 0; } if (n == 2) { return 1; } // 检查缓存中是否已有结果 if (cache.containsKey(n)) { return cache.get(n); } // 递归计算斐波那契数，并存储结果到缓存中 long result = fib(n - 1) + fib(n - 2); cache.put(n, result); return result; } } 上述方法缺陷：当 $n$ 比较大时会导致栈溢出（StackOverflow）。\n解法三：迭代 Tabulation（自下而上法）：从最小的子问题 $fib(1)$ 和 $fib(2)$ 入手，迭代地计算出更大子问题的结果。\n迭代（自下而上） import java.util.HashMap; import java.util.Map; public class Solution { private static Map\u0026lt;Integer, Long\u0026gt; cache = new HashMap\u0026lt;\u0026gt;(); public static void main(String[] args) { System.out.println(fib(1)); System.out.println(fib(2)); System.out.println(fib(2000)); } public static long fib(int n) { cache.put(1, 0L); cache.put(2, 1L); for (int i = 3; i $\\le$ n; i++) { cache.put(i, cache.get(i - 1) + cache.get(i - 2)); } return cache.get(n); } } 解法四：迭代 + 中间变量 解法三解决了栈溢出问题，其空间复杂度为 $O(n)$，可以进一步优化为 $O(1)$。\npublic class Solution { public static void main(String[] args) { System.out.println(fib(1)); System.out.println(fib(2)); System.out.println(fib(6)); } public static long fib(int n) { if (n == 1) { return 0; } if (n == 2){ return 1; } long prev1 = 0L; // F(1) long prev2 = 1L; // F(2) long current = 0L; for (int i = 3; i $\\le$ n; i++) { current = prev1 + prev2; prev1 = prev2; prev2 = current; } return current; } } 不同路径 点击查看题目 一个机器人位于一个 m x n 网格的左上角（如下图所示）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。\n问总共有多少条不同的路径？\n走格子示意图 示例 1\n输入：m = 3, n = 7\n输出：28\n示例 2：\n输入：m = 3, n = 2\n输出：3\n解释：\n从左上角开始，总共有 3 条路径可以到达右下角。\n向右 -\u0026gt; 向下 -\u0026gt; 向下 向下 -\u0026gt; 向下 -\u0026gt; 向右 向下 -\u0026gt; 向右 -\u0026gt; 向下 示例 3：\n输入：m = 7, n = 3\n输出：28\n示例 4：\n输入：m = 3, n = 3\n输出：6\n$1 \\le m, n \\le 100$\n题目数据保证答案小于等于 $2 * 10^9$\n--- title: 走格子：2 × 3 --- flowchart g23((\"2,3\")) --\u003e|down| g13((\"1,3\")) g23 --\u003e|right| g22((\"2,2\")) g13 --\u003e|down| g03((\"0,3\")) g13 --\u003e|right| g12((\"1,2\")) g22 --\u003e|down| g121((\"1,2\")) g22 --\u003e|right| g21((\"2,1\")) g12 --\u003e|down| g02((\"0,2\")) g12 --\u003e|right| g11((\"1,1\")) g121 --\u003e|down| g021((\"0,2\")) g121 --\u003e|right| g111((\"1,1\")) g21 --\u003e|down| g1111((\"1,1\")) g21 --\u003e|right| g20((\"2,0\")) style g23 fill:lightgreen,color:black style g13 fill:lightgreen,color:black style g22 fill:lightgreen,color:black style g12 fill:lightgreen,color:black style g22 fill:lightgreen,color:black style g121 fill:lightgreen,color:black style g21 fill:lightgreen,color:black style g11 fill:lightgreen,color:black style g111 fill:lightgreen,color:black style g1111 fill:lightgreen,color:black 走格子（$2\\times 3$）示意图 由上图可得出基本情况：当 $n$ 为 $0$ 或者 $m$ 为 $0$ 时，返回 $0$，当 $n = 1$ 并且 $m=1$ 时，返回 $1$.\n解法一：暴力递归 public static long gridTraveller(int m, int n) { if (m == 1 \u0026\u0026 n == 1) { return 1; } if (m == 0 || n == 0) { return 0; } return gridTraveller(m - 1, n) + gridTraveller(m, n - 1); } 解法二：递归 + 缓存 gridTraveller(m, n) = gridTraveller(n, m) 暴力递归解法的重复计算 import java.util.HashMap; import java.util.Map; public class GridTraveller { public static long gridTraveller(int m, int n) { return gridTraveller(m, n, new HashMap\u0026lt;\u0026gt;()); } private static long gridTraveller(int m, int n, Map\u0026lt;String, Long\u0026gt; memo) { String key = m + \",\" + n; if (memo.containsKey(key)) { return memo.get(key); } if (m == 1 \u0026\u0026 n == 1) { return 1; } if (m == 0 || n == 0) { return 0; } long result = gridTraveller(m - 1, n, memo) + gridTraveller(m, n - 1, memo); memo.put(key, result); return result; } public static void main(String[] args) { System.out.println(gridTraveller(3, 3)); // Output: 6 System.out.println(gridTraveller(18, 18)); // Output: 2333606220 } } 动态规划方法论（先递归再优化） 问题树化 寻找基本情况 暴力递归实现 使用缓存优化 题目 组合总和（canSum） 点击查看题目 给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target，判断 target 是否可以从 candidates 中的元素求和得到。\ncandidates 中的同一个数字可以无限制重复被选取 。\n示例 1:\n输入：candidates = [2,3,6,7], target = 7\n输出：true\n示例 2：\n输入: candidates = [2,3], target = 8\n输出：true\n示例 3：\n输入: candidates = [2], target = 1\n输出：false\n提示：\n1 $\\le$ candidates.length $\\le$ 30 2 $\\le$ candidates[i] $\\le$ 40 candidates 的所有元素互不相同 1 $\\le$ target $\\le$ 40 暴力递归 --- title: 组合总和（cansum）暴力递归 --- flowchart TB l1((8))--\u003e|-2| l21((6)) l1 --\u003e|-3| l22((5)) l21 --\u003e|-2| l31((4)) l21 --\u003e|-3| l32((3)) l22 --\u003e|-2| l33((3)) l22 --\u003e|-3| l34((2)) l31 --\u003e|-2| l41((2)) l31 --\u003e|-3| l42((1)) l32 --\u003e|-2| l43((1)) l32 --\u003e|-3| l44((0)) l33 --\u003e|-2| l45((1)) l33 --\u003e|-3| l46((0)) l34 --\u003e|-2| l47((0)) l34 --\u003e|-3| l48((\"-1\")) l41 --\u003e|-2| l51((0)) l41 --\u003e|-3| l52((\"-1\")) style l32 fill:lightblue,color:black style l33 fill:lightblue,color:black style l34 fill:red style l41 fill:red public class CanSum { public static void main(String[] args) { System.out.println(canSum(7, new int[]{2, 3})); // true System.out.println(canSum(7, new int[]{5, 3, 4, 7})); // true System.out.println(canSum(7, new int[]{2, 4})); // false System.out.println(canSum(8, new int[]{2, 3})); // true System.out.println(canSum(300, new int[]{7, 14})); // false } public static boolean canSum(int targetSum, int[] numbers) { if (targetSum == 0) { return true; } if (targetSum == 1 || targetSum \u003c 0) { // targetSum \u003c= 1 return false; } for (int number : numbers) { int remainder = targetSum - number; if (canSum(remainder, numbers)) { return true; } } return false; } } 使用缓存优化 --- title: 组合总和（cansum）使用缓存优化 --- flowchart subgraph tree[递归树] l1((8))--\u003e|-2| l21((6)) l1 --\u003e|-3| l22((5)) l21 --\u003e|-2| l31((4)) l21 --\u003e|-3| l32((3)) l22 --\u003e|-2| l33((3)) l22 --\u003e|-3| l34((2)) l31 --\u003e|-2| l41((2)) l31 --\u003e|-3| l42((1)) l32 --\u003e|-2| l43((1)) l32 --\u003e|-3| l44((0)) l41 --\u003e|-2| l51((0)) l41 --\u003e|-3| l52((\"-1\")) end subgraph cache[缓存] canSum2[\"canSum(2)\"] ~~~ canSum3[\"canSum(3)\"] end canSum2 -.-\u003e|使用缓存| l34 canSum3 -.-\u003e|使用缓存| l33 style l32 fill:lightblue,color:black style l33 fill:lightblue,color:black style l34 fill:red style l41 fill:red import java.util.HashMap; import java.util.Map; public class CanSum { public static void main(String[] args) { System.out.println(canSum(7, new int[]{2, 3})); // true System.out.println(canSum(7, new int[]{5, 3, 4, 7})); // true System.out.println(canSum(7, new int[]{2, 4})); // false System.out.println(canSum(8, new int[]{2, 3})); // true System.out.println(canSum(300, new int[]{7, 14})); // false } public static boolean canSum(int targetSum, int[] numbers) { return canSum(targetSum, numbers, new HashMap\u0026lt;\u0026gt;()); } private static boolean canSum(int targetSum, int[] numbers, Map\u0026lt;Integer, Boolean\u0026gt; memo) { if (memo.containsKey(targetSum)) { return memo.get(targetSum); } if (targetSum == 0) { return true; } if (targetSum == 1 || targetSum \u003c 0) { // targetSum \u003c= 1 return false; } for (int number : numbers) { int remainder = targetSum - number; if (canSum(remainder, numbers, memo)) { memo.put(targetSum, true); return true; } } memo.put(targetSum, false); return false; } } 组合总和（howSum） 组合总和（bestSum） ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/algorithms/2-dynamic-programming/","summary":"动态规划相关概念 动态规划核心思想： 将原问题划分为更简单的子问题，通过子问题的解来构建问题的解。 Memoization（自上而下法）：将原问题递归地划分为更小的子问题，并在对子问题的结果进行缓存，以避免重复计算。 Tabulation（自下而上法）：从最小的子问题开始，迭代地构建原问题的解。 动态规划例题 斐波那契数列 点击查看题目 斐波那契数（通常用 $F(n)$ 表示）形成的序列称为斐波那契数列。该数列由 $0$ 和 $1$ 开始，后面的每一项数字都是前面两项数字的和。也就是：\n$F(1) = 0，F(2) = 1$\n$F(n) = F(n - 1) + F(n - 2)，其中\\; n \u0026gt; 2$\n给定 $n$ ，请计算 $F(n)$。\n示例 1：\n输入：$n = 2$\n输出：$1$\n解释：$F(2) = 1$\n示例 2：\n输入：$n = 3$\n输出：$2$\n解释：$F(3) = F(2) + F(1) = 1 + 0 = 1$\n示例 3：\n输入：$n = 4$\n输出：$3$\n解释：$F(4) = F(3) + F(2) = 1 + 1 = 2$","title":"数据结构与算法：动态规划"},{"content":"导数 导数的定义 设函数 y = f(x) 在 x_0 的某邻域内有定义，如果极限 $$ \\displaystyle\\lim_{\\Delta x\\rightarrow 0}\\frac{\\Delta y}{\\Delta x} = \\lim_{\\Delta x \\rightarrow 0}\\frac{f(x_0 + \\Delta x) - f(x_0)}{\\Delta x} $$ 存在，则称 $f(x)$ 在点 $x_0$ 处可导，并称此极限值为 $f(x)$ 在点 $x_0$ 处的导数，记为 $f^\\prime(x_0)$。如果上述极限不存在，则称 $f(x)$ 在点 $x_0$ 处不可导。 记 $x = x_0 + \\Delta x$，则 $\\Delta x = x - x_0$，所以 $f^\\prime(x_0)$ 可表示为 $\\displaystyle\\lim_{x\\rightarrow 0}\\frac{f(x) - f(x_0)}{x - x_0}$。 $f^\\prime(x_0)$ 与 $f(x_0)$ 有关。 导数的本质是函数的变化率。 微分 微分的定义 微分是函数变化量的近似值。 设函数 $y = f(x)$ 在点 $x_0$ 的某一邻域内有定义，如果函数的增量 $\\Delta y = f(x_0 + \\Delta x) - f(x_0)$ 可以表示为 $$ \\Delta y = A\\Delta x + o(\\Delta x)，(\\Delta x \\rightarrow 0) $$ 其中 $A$ 为不依赖于 $\\Delta x$ 的常数，$o(\\Delta x)$ 是 $\\Delta x$ 的高阶无穷小，则称函数 $y = f(x)$ 在点 $x_0$ 处可微，并称 $\\Delta y$ 的线性主部 $A\\Delta x$ 为函数 $y = f(x)$ 在点 $x_0$ 处的微分，记作 $\\mathrm{d}y$，即 $\\mathrm{d}y = A\\Delta x$ 微分本质是函数变化量的线性主部（$\\Delta y = A\\Delta x, A\\;为常数$） 导数与微分的几何意义 导数是切线的斜率，微分是切线上的增量。 导数与微分的几何意义 导数 $f^\\prime(x_0)$ 在几何上表示曲线 $y = f(x)$ 在点 $(x_0, f(x_0))$ 处切线的斜率。 如果函数 $f(x)$ 在点 $x_0$ 处可导，则曲线 $y = f(x)$ 在点 $(x_0, f(x_0))$ 处的切线方程为 $$ y - f(x_0) = f\u0026rsquo;(x_0)(x - x_0) $$ 如果 $f\u0026rsquo;(x_0) \\ne 0$，则此曲线 $y = f(x)$ 在点 $(x_0, f(x_0))$ 处的法线方程为 $$ y - f(x_0) = -\\frac{1}{f\u0026rsquo;(x_0)}(x - x_0) $$ 微积分思想 在微小的局部，用线性变化代替非线性变化。 在微小的局部，用切线上的增量代替曲线上的增量。 ","permalink":"https://signalyu.github.io/posts/1-natural-science/math/calculus/4-derivative-and-differential/","summary":"导数 导数的定义 设函数 y = f(x) 在 x_0 的某邻域内有定义，如果极限 $$ \\displaystyle\\lim_{\\Delta x\\rightarrow 0}\\frac{\\Delta y}{\\Delta x} = \\lim_{\\Delta x \\rightarrow 0}\\frac{f(x_0 + \\Delta x) - f(x_0)}{\\Delta x} $$ 存在，则称 $f(x)$ 在点 $x_0$ 处可导，并称此极限值为 $f(x)$ 在点 $x_0$ 处的导数，记为 $f^\\prime(x_0)$。如果上述极限不存在，则称 $f(x)$ 在点 $x_0$ 处不可导。 记 $x = x_0 + \\Delta x$，则 $\\Delta x = x - x_0$，所以 $f^\\prime(x_0)$ 可表示为 $\\displaystyle\\lim_{x\\rightarrow 0}\\frac{f(x) - f(x_0)}{x - x_0}$。 $f^\\prime(x_0)$ 与 $f(x_0)$ 有关。 导数的本质是函数的变化率。 微分 微分的定义 微分是函数变化量的近似值。 设函数 $y = f(x)$ 在点 $x_0$ 的某一邻域内有定义，如果函数的增量 $\\Delta y = f(x_0 + \\Delta x) - f(x_0)$ 可以表示为 $$ \\Delta y = A\\Delta x + o(\\Delta x)，(\\Delta x \\rightarrow 0) $$ 其中 $A$ 为不依赖于 $\\Delta x$ 的常数，$o(\\Delta x)$ 是 $\\Delta x$ 的高阶无穷小，则称函数 $y = f(x)$ 在点 $x_0$ 处可微，并称 $\\Delta y$ 的线性主部 $A\\Delta x$ 为函数 $y = f(x)$ 在点 $x_0$ 处的微分，记作 $\\mathrm{d}y$，即 $\\mathrm{d}y = A\\Delta x$ 微分本质是函数变化量的线性主部（$\\Delta y = A\\Delta x, A\\;为常数$） 导数与微分的几何意义 导数是切线的斜率，微分是切线上的增量。 导数与微分的几何意义 导数 $f^\\prime(x_0)$ 在几何上表示曲线 $y = f(x)$ 在点 $(x_0, f(x_0))$ 处切线的斜率。 如果函数 $f(x)$ 在点 $x_0$ 处可导，则曲线 $y = f(x)$ 在点 $(x_0, f(x_0))$ 处的切线方程为 $$ y - f(x_0) = f\u0026rsquo;(x_0)(x - x_0) $$ 如果 $f\u0026rsquo;(x_0) \\ne 0$，则此曲线 $y = f(x)$ 在点 $(x_0, f(x_0))$ 处的法线方程为 $$ y - f(x_0) = -\\frac{1}{f\u0026rsquo;(x_0)}(x - x_0) $$ 微积分思想 在微小的局部，用线性变化代替非线性变化。 在微小的局部，用切线上的增量代替曲线上的增量。 ","title":"导数与微分"},{"content":"数组 数组基本概念 在 C 语言中，越界访问数组编译器并不会报错； 一维数组的长度计算：int length = sizeof(arr) / sizeof(arr[0]); sizeof 返回值的数据类型是 size_t ，所以 sizeof(a) / sizeof(a[0]) 的数据类型也是 size_t。在 printf() 里面的占位符，要用 %zd 或 %zu 。 一维数组的内存分析： 一维数组的内存分析 C 语言规定，数组变量一旦声明，数组名指向的地址就不可更改。因此，使用大括号赋值时，必须在数组声明时赋值，否则编译时会报错。 int nums[5]; nums = {1, 2, 3, 4, 5}; // 报错 int nums[5] = {1, 2, 3, 4, 5}; // 正确写法 数组的复制 使用循环复制数组： void copyArray(int src[], int dest[], int size) { for (int i = 0; i \u003c size; i++) { dest[i] = src[i]; } } 使用 memcopy() 函数复制数组： #include \u0026lt;string.h\u0026gt; int main() { // ... memcpy(dest, src, sizeof(src)); return 0; } 使用指针对数组进行赋值和遍历 使用指针变量对数组进行赋值和遍历的效率比下标法高。\n#include \u0026lt;stdio.h\u0026gt; #define N 5 int main() { int a[N]; int *p = a; printf(\"请输入%d个整数：\\n\", N); for (int i = 0; i \u003c N; i++) { scanf(\"%d\", p + i); } for (int i = 0; i \u003c N; i++) { printf(\"%d \", *(p + i)); } printf(\"\\n\"); return 0; } 点击查看题目 下列 C 语言代码是否正确？ #include \u0026lt;stdio.h\u0026gt; #define N 5 int main() { int a[N]; int *p = a; printf(\"请输入%d个整数：\\n\", N); for (int i = 0; i \u003c N; i++) { scanf(\"%d\", \u0026a[i]); } for (p = a; a \u003c (p + N); a++) { printf(\"%d\", *a); } printf(\"\\n\"); return 0; } 点击查看答案 下列代码不正确： for (p = a; a \u003c (p + N); a++) { printf(\"%d\", *a); } 数组名 a 代表数组的首地址（或数组首元素的地址），它是一个指针型常量 ，它的值在程序运行期间是固定不变的。所以 a++ 是无法实现的。必须将 a 的地址赋值给指针变量 p ，然后对 p 进行自增。正确写法为： for (p = a; p \u003c (a + N); p++) { printf(\"%d \", *p); } 指针 指针的基本概念 变量：命名的内存空间，用于存放各种类型的数据； 变量名：为标记某块内存空间而采用的便于记忆的名字； 变量值：在变量单元中存放的数据值； 指针：指针是指变量所使用的内存空间的地址； 变量名 内存地址 内容 i 0x00000001 1 0x00000002 0x00000003 0x00000004 j 0x00000005 2 0x00000006 0x00000007 0x00000008 指针变量：指针变量是一个专门用来存放另一变量在内存中数据的地址的变量。通过访问指针变量，可以访问内存中另一个变量数据。 指针变量 指针的本质及其运算 指针本质上是一个代表内存地址的无符号整数。因此它可以进行整数加减，自增自减、同类指针相减等操作，但运算规则并不是整数运算规则。 指针与整数值的加减运算：表示指针所指向内存地址的移动。指针移动的单位，与指针指向的数据类型有关。数据类型占据多少个字节，每单位就移动多少个字节。 注意：只有指向连续的同类型数据区域，指针加、减整数才有实际意义。 指针的自增与自减：指针的增加或减少是指内存地址的向前或向后移动。 int arr[] = {1, 2, 3}; int *p = \u0026amp;arr; printf(\"arr[0] = %d\\n\", *p); // arr[0] = 1 printf(\"arr[1] = %d\\n\", *(++p)); // arr[1] = 2 同类指针相减运算：相同类型的指针允许进行减法运算，返回它们之间的距离，即相隔多少个数据单位（非字节数）。返回的值属于头文件 stddef.h 里面的 ptrdiff_t 类型，这是一个带符号的整数类型别名，具体类型根据系统不同而不同。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stddef.h\u0026gt; int main() { short *ps1; short *ps2; ps1 = (short *) 0x1234; ps2 = (short *) 0x1236; ptrdiff_t dist = ps2 - ps1; printf(\"%d\\n\", dist); // 1（相差2个字节正好存放1个short类型的值） int *pi1; int *pi2; pi1 = (int *) 0x1234; pi2 = (int *) 0x1244; ptrdiff_t dist1 = pi2 - pi1; printf(\"%d\\n\",dist1); // 4（相差16个字节正好存放4个int类型的值） return 0; } 指针间的比较运算：比较各自的内存地址的大小，返回值是整数 1（true）或 0（false）。 取址运算符（\u0026amp;）：取之运算符用于取出指定变量在内存中的地址。 int num = 10; int *p; // p 为整型指针变量，建议写成 int *p = NULL; p = \u0026amp;num; // 必须为整型指针 printf(\"\u0026num = %p\", \u0026num); // 格式输出符为 %p 取值运算符（*）：取值运算符用于获取给定内存地址的数据值，它与取址运算符（\u0026amp;）互为逆运算。 int num = 10; int *p; // p 为整型指针变量，建议写成 int *p = NULL; p = \u0026amp;num; // 必须为整型指针 printf(\"\u0026num = %p\\n\", \u0026num); // 格式输出符为 %p printf(\"num = %d\", *p); // 取出指针 p 的值 野指针 野指针：野指针指的是指向未知知内存的一类指针； 野指针的成因主要有如下三种： 指针使用前未初始化：指针变量在定义时如果未初始化，其值是随机的，此时操作指针就是去访问一个不确定的地址，所以结果是不可知的。此时 p 为野指针。 int *p; // 建议写成 int *p = NULL; printf(\"%d\\n\", *p); // 输出的值每次都不一样 指针越界访问： int arr[10] = {0}; int *p = arr; for (int i = 0; i \u003c= 10; i++, p++) { *p = i; // i = 10 时越界 } 指针指向已释放的空间： test.c 输出结果 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int *test() { int a = 10; return \u0026amp;a; } int main() { int *p = test(); printf(\"*p = %d\", *p); printf(\"\\n暂停两秒...\\n\"); sleep(2); // 暂停两秒 printf(\"*p = %d\\n\", *p); return 0; } $ gcc -Wall -o test test.c test.c:6:13: warning: address of stack memory associated with local variable 'a' returned [-Wreturn-stack-address] return \u0026amp;a; ^ 1 warning generated. $ ./test *p = 10 暂停两秒... *p = 1 调用 test 函数将返回值赋给 p，test 函数的返回值是局部变量 a 的地址。由于 a 只在 test 函数内有效，出了 test 函数其内存空间就被释放，也就意味着 a 的地址编号不存在，若将其赋值给 p，导致 p 获取到的地址是无效的。如果短时间内再次利用这块地址，它的值还未被改变，此时 p 的值为 a 的地址值，*p 返回 10。如果在打印之前有其他函数调用了这块地址，这块地址的名称就会发生变化，*p 不再返回 10。 野指针的避免： 定义指针时，如果没有确切的地址赋值，应该为指针变量赋一个NULL值。即： int *p = NULL; 赋为NULL值的指针被称为空指针，NULL指针是一个定义在标准库中的值为零的常量#define NULL 0。 访问数组元素时，避免越界(0 ≤ i \u0026lt; arr.length)访问。 避免将函数返回的局部变量的地址值赋值给指针。 指针指向的空间被释放时，应该及时将指针置为NULL。 int *ptr = (int *) malloc(sizeof(int)); free(ptr); // 释放内存 ptr = NULL; // 将指针设置为 NULL 指针使用之前应进行有效性检查： if (ptr != NULL) { // ... } 二级指针 二级指针是指一个指针变量的值是另一个指针变量的地址。 int a = 20; int *pa = \u0026a; // pa是一级指针 int **ppa = \u0026pa; // ppa是二级指针，类型为int ** 二级指针 数组指针与指针数组 数组指针是指存放数组首地址的指针变量；指针数组是指存放指针的数组。 ###添加案例 数组指针与指针数组 字符数组和字符指针变量 字符数组由若干个元素组成，每个元素存放一个字符。 char str[] = \"signal\"; // 使用字符数组 字符数组 字符指针变量中存放的是地址（字符串或字符数组的首地址）。 char *pStr = \"signal\"; // 使用字符指针 字符指针 对已声明好的字符数组，只能一一对各个元素赋值，而不能对整个字符数组赋值： char str[14]; str[0] = 'i'; // 正确 str = \"signal\"; // 错误，不能对整个字符数组赋值 对已声明好的字符指针变量，可以采用如下方式赋值： char *pStr = \"\"; pStr = \"signal\"; // 正确 字符指针重新赋值 一个字符数组，因为它有确定的内存地址，所以字符数组名是一个常量 。而定义一个字符指针变量时，它在指向某个确定的字符串数据的情况下，可以多次重新赋值 。 字符串字面量存储在只读内存区域，是不可变的，不能修改其值。 char arr[] = \"hello\"; arr[1] = \"m\"; // 运行时错误 char *pStr = \"hello\"; pStr = \"hello tom\"; // 正确 pStr[1] = 'm'; // 运行时错误 ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/tech/c/1-array-and-pointer-in-c/","summary":"数组 数组基本概念 在 C 语言中，越界访问数组编译器并不会报错； 一维数组的长度计算：int length = sizeof(arr) / sizeof(arr[0]); sizeof 返回值的数据类型是 size_t ，所以 sizeof(a) / sizeof(a[0]) 的数据类型也是 size_t。在 printf() 里面的占位符，要用 %zd 或 %zu 。 一维数组的内存分析： 一维数组的内存分析 C 语言规定，数组变量一旦声明，数组名指向的地址就不可更改。因此，使用大括号赋值时，必须在数组声明时赋值，否则编译时会报错。 int nums[5]; nums = {1, 2, 3, 4, 5}; // 报错 int nums[5] = {1, 2, 3, 4, 5}; // 正确写法 数组的复制 使用循环复制数组： void copyArray(int src[], int dest[], int size) { for (int i = 0; i \u003c size; i++) { dest[i] = src[i]; } } 使用 memcopy() 函数复制数组： #include \u0026lt;string.","title":"C 语言中的数组与指针"},{"content":"Boyer Moore 投票算法逻辑步骤 初始化候选人（candidate）和计票器（counter）； 遍历数组寻找可能为最大元素的候选人： count == 0 --\u0026gt; candidate = current element; count = 0 (current element == candidate) ? count++ : count-- 遍历数组验证候选人是否为多数元素（majority element）： count = 0 (current element == candidate) ? count++ 判断 count 是否过半 Boyer Moore 投票算法核心：只要数组中某元素出现次数过半，则遍历完毕后 candidate 变量必然指向该元素。 点击查看代码 majorityElement.c 测试代码 输出结果 int majorityElement(int const nums[], int size) { // 初始化候选人和计票器 int candidate = 0; int count = 0; // 遍历数组确定候选人 for (int i = 0; i \u003c size; i++) { if (count == 0) { candidate = nums[i]; count++; } else if (nums[i] == candidate) { count++; } else { count--; } } // 遍历数组判断候选人是否为多数元素 count = 0; for (int i = 0; i \u003c size; i++) { if (nums[i] == candidate) { count++; } } // 存在多数元素 if (count \u003e size / 2) { return candidate; } // 不存在多数元素 return -1; } #include \u0026lt;stdio.h\u0026gt; int main() { int nums1[] = {3, 2, 3}; int numsSize1 = sizeof(nums1) / sizeof(nums1[0]); printf(\"Majority element in nums1: %d\\n\", majorityElement(nums1, numsSize1)); int nums2[] = {2, 2, 1, 1, 1, 2, 2}; int numsSize2 = sizeof(nums2) / sizeof(nums2[0]); printf(\"Majority element in nums2: %d\\n\", majorityElement(nums2, numsSize2)); } Majority element in nums1: 3 Majority element in nums2: 2 ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/algorithms/1-boyer-moore-voting-algorithm/","summary":"Boyer Moore 投票算法逻辑步骤 初始化候选人（candidate）和计票器（counter）； 遍历数组寻找可能为最大元素的候选人： count == 0 --\u0026gt; candidate = current element; count = 0 (current element == candidate) ? count++ : count-- 遍历数组验证候选人是否为多数元素（majority element）： count = 0 (current element == candidate) ? count++ 判断 count 是否过半 Boyer Moore 投票算法核心：只要数组中某元素出现次数过半，则遍历完毕后 candidate 变量必然指向该元素。 点击查看代码 majorityElement.c 测试代码 输出结果 int majorityElement(int const nums[], int size) { // 初始化候选人和计票器 int candidate = 0; int count = 0; // 遍历数组确定候选人 for (int i = 0; i \u003c size; i++) { if (count == 0) { candidate = nums[i]; count++; } else if (nums[i] == candidate) { count++; } else { count--; } } // 遍历数组判断候选人是否为多数元素 count = 0; for (int i = 0; i \u003c size; i++) { if (nums[i] == candidate) { count++; } } // 存在多数元素 if (count \u003e size / 2) { return candidate; } // 不存在多数元素 return -1; } #include \u0026lt;stdio.","title":"数据结构与算法：投票算法"},{"content":"基本等价无穷小 $\\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\sin x}{x} = 1$ 点击查看证明过程 $ 如下图可知：S_{三角形ABC} \u0026lt; S_{扇形ABC} \u0026lt; S_{三角形 ABD}\\\\ 即：\\frac{1}{2}\\sin x \u0026lt; \\frac{1}{2}x\u0026lt;\\frac{1}{2}\\tan x\\\\ 即：\\sin x \u0026lt; x \u0026lt; \\tan x\\\\ 即：1 \u0026lt; \\frac{x}{\\sin x} \u0026lt; \\frac{1}{\\cos x}\\\\ 即：\\cos x \u0026lt; \\frac{\\sin x}{x} \u0026lt; 1\\\\ 因为 \\lim_{x\\rightarrow 0}\\cos x = \\lim_{x\\rightarrow 0} 1 = 1\\\\ 由夹逼准则可知 \\lim_{x\\rightarrow 0}\\frac{\\sin x}{x} = 1 $ 图：$\\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\sin x}{x}$ $\\displaystyle\\lim_{x\\rightarrow 0}(1+x)^{\\frac{1}{x}} = e$ 点击查看证明过程 $ 令\\;L = \\displaystyle\\lim_{x\\rightarrow 0}(1+x)^{\\frac{1}{x}}\\\\ 则\\;\\ln L = \\displaystyle\\lim_{x\\rightarrow 0}\\ln (1+x)^{\\frac{1}{x}}\\\\ 即：\\ln L = \\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\ln (1+x)}{x} \\xlongequal{ 洛必达法则 }\\lim_{x\\rightarrow 0}\\frac{1}{1+x} = 1\\\\ 所以\\;L = e $ 点击查看证明过程 $ $ $\\displaystyle\\lim_{x\\rightarrow \\infty}(1+\\frac{1}{x})^x = e$ 点击查看证明过程 $ 令\\;L = \\displaystyle\\lim_{x\\rightarrow 0}(1+\\frac{1}{x})^x\\\\ 则\\;ln L = \\lim_{x\\rightarrow 0}x\\ln(1+\\frac{1}{x}) = \\lim_{x\\rightarrow 0}\\frac{\\ln(1 + \\frac{1}{x})}{\\frac{1}{x}} \\xlongequal{洛必达法则} \\lim_{x\\rightarrow 0}\\frac{\\frac{-\\frac{1}{x^2}}{1+\\frac{1}{x}}}{-\\frac{1}{x^2}} = \\lim_{x\\rightarrow 0}\\frac{1}{1+\\frac{1}{x}} = 1\\\\ 所以 \\;L = e $ 常用等价无穷小证明 $x \\sim \\tan x$ 点击查看证明过程 $ \\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\tan x}{x} = \\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\sin x}{\\cos x\\cdot x} = \\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\sin x}{x} = 1 $ $\\arcsin x \\sim x$ 点击查看证明过程 $ 令 \\;t = \\arcsin x，则\\;x = \\sin t\\\\ 所以\\;\\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\arcsin x}{x} = \\displaystyle\\lim_{t\\rightarrow 0} = \\frac{t}{\\sin t} = 1 $ $\\arctan x \\sim x$ 点击查看证明过程 $ 令 \\;t = \\arctan x，则\\;x = \\tan t\\\\ 所以\\;\\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\arctan x}{x} = \\displaystyle\\lim_{t\\rightarrow 0} = \\frac{t}{\\tan t} = 1 $ $\\log_a(1+x) \\sim \\frac{x}{\\ln a}$ 点击查看证明过程 $\n$\n$\\ln (1+x) \\sim x$ 点击查看证明过程 $ \\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\ln (1+x)}{x} = \\frac{1}{x}\\cdot \\lim_{x\\rightarrow 0} \\ln(1+x) = \\lim_{x\\rightarrow 0} (1+x)^{\\frac{1}{x}} = \\ln e = 1 $ $\\log_a(1+x) \\sim \\frac{x}{\\ln a}$ 点击查看证明过程 $ \\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\log_a(1+x)}{\\frac{x}{\\ln a}} \\xlongequal{ 对数换底公式 } \\frac{\\frac{\\ln (1+x)}{\\ln a}}{\\frac{x}{\\ln a}} = \\frac{\\ln(1+x)}{x} = 1 $ $对数换底公式证明\\;(\\log_a M = \\frac{\\log_b M}{\\log_b a})：\\\\ \\;\\\\ 令\\begin{cases} x = \\log_a M \\\\ y = \\log_b M \\\\ z = \\log_b a \\end{cases} \\implies \\begin{cases} M = a^x \u0026amp;\\\\ M = b^y \u0026amp;\\\\ a = b^z \\end{cases}\\\\ \\therefore b^y = M = a^x = (b^z)^x = b^{xz}\\\\ \\therefore y = xz，即：\\log_b M = \\log_a \\cdot \\log_b a\\\\ 即：\\log_a M = \\frac{\\log_b M}{\\log_b a} = \\frac{\\ln M}{\\ln a} \\;(b = e)\\\\ 原命题得证。 $ $e^x - 1 \\sim x$ 点击查看证明过程 $ 令 \\;t = e^x - 1，则\\;x = \\ln(1+t)\\\\ 所以 \\displaystyle\\lim_{x\\rightarrow 0}\\frac{e^x - 1}{x} = \\lim_{t\\rightarrow 0}\\frac{t}{\\ln(1+t)} = 1 $ $a^x - 1 \\sim x\\ln a$ 点击查看证明过程 $ 令 \\;t = a^x - 1，则\\;x\\ln a = \\ln(1+t)\\\\ 所以 \\displaystyle\\lim_{x\\rightarrow 0}\\frac{a^x - 1}{x\\ln a} = \\lim_{t\\rightarrow 0}\\frac{t}{\\ln(1+t)} = 1 $ $(1+x)^{\\alpha} - 1 \\sim \\alpha x$ 点击查看证明过程 $ \\displaystyle\\lim_{x\\rightarrow 0}\\frac{(1+x)^{\\alpha} - 1}{\\alpha x} = \\lim_{x\\rightarrow 0}\\frac{e^{\\alpha\\ln(1+x)} - 1}{\\alpha x} = \\lim_{x\\rightarrow 0}\\frac{\\alpha \\ln(1+x)}{\\alpha x} = \\lim_{x\\rightarrow 0}\\frac{\\alpha x}{\\alpha x} = 1 $ $1 - \\cos x \\sim \\frac{1}{2}x^2$ 点击查看证明过程 $ \\displaystyle\\lim_{x\\rightarrow 0}\\frac{1-\\cos x}{\\frac{1}{2}x^2} = \\lim_{x\\rightarrow 0}\\frac{2\\sin^2\\left(\\frac{x}{2}\\right)}{\\frac{1}{2}x^2} = \\lim_{x\\rightarrow 0}\\frac{2\\left(\\frac{x}{2}\\right)^2}{\\frac{1}{2}x^2} = \\lim_{x\\rightarrow 0}\\frac{\\frac{1}{2}x^2}{\\frac{1}{2}x^2} = 1 $ $ 证明\\;1 - \\cos x = 2\\sin^2 \\left(\\frac{x}{2}\\right)\\\\ \\;\\\\ \\because\\cos(\\alpha + \\beta) = \\cos \\alpha \\cos\\beta - \\sin\\alpha\\sin\\beta\\\\ \\therefore \\cos 2x = \\cos(x+x) = \\cos^2 x - \\sin^2 x\\\\ \\because \\cos^2 x = 1 - \\sin^2 x\\\\ \\therefore \\cos 2x = 1 - 2\\sin^2 x\\\\ \\therefore 1 - \\cos 2x = 2\\sin^2x $ $\\tan x - \\sin x \\sim \\frac{1}{2}x^3$ 点击查看证明过程 $ \\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\tan x - \\sin x}{\\frac{1}{2}x^3} = \\lim_{x\\rightarrow 0}\\frac{\\frac{\\sin x}{\\cos x} - \\sin x}{\\frac{1}{2}x^3} = \\lim_{x\\rightarrow 0}\\frac{\\sin x\\left(\\frac{1-\\cos x}{\\cos x}\\right)}{\\frac{1}{2}x^3} = \\lim_{x\\rightarrow 0}\\frac{1-\\cos x}{\\frac{x^2}{2}\\cos x} = \\lim_{x\\rightarrow 0}\\frac{\\frac{x^2}{2}}{\\frac{x^2}{2}} = 1 $ $x - \\sin x \\sim \\frac{1}{6}x^3$ 点击查看证明过程 $ \\displaystyle\\lim_{x\\rightarrow 0}\\frac{x-\\sin x}{\\frac{1}{6}x^3} = \\lim_{x\\rightarrow 0}\\frac{1-\\cos x}{\\frac{1}{2}x^2} = 1 $ $\\arcsin x - x \\sim \\frac{1}{6}x^3$ 点击查看证明过程 $\n$\n$\\tan x - x \\sim \\frac{1}{3}x^3$ 点击查看证明过程 $ \\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\tan x - x}{\\frac{1}{3}x^3} \\xlongequal{洛必达法则} \\lim_{x\\rightarrow 0}\\frac{\\frac{1}{\\cos^2}-1}{x^2}\\lim_{x\\rightarrow 0}\\frac{1-\\cos^2 x}{x^2\\cos^2 x} \\xlongequal{等价无穷小}\\lim_{x\\rightarrow 0}\\frac{x^2}{x^2} = 1 $ $x - \\arctan x \\sim \\frac{1}{3}x^3$ 点击查看证明过程 $\n$\n$1 - \\cos^{\\alpha} x \\sim \\frac{\\alpha}{2}x^2$ 点击查看证明过程 $ \\displaystyle\\lim_{x\\rightarrow 0} \\frac{1-\\cos^{\\alpha}x}{\\frac{\\alpha}{2}x^2} = -\\lim_{x\\rightarrow 0}\\frac{\\cos^{\\alpha}-1}{\\frac{\\alpha}{2}x^2} = -\\lim_{x\\rightarrow 0}\\frac{\\ln(1+\\cos^{\\alpha}x-1)}{\\frac{\\alpha}{2}x^2} = -\\lim_{x\\rightarrow 0}\\frac{\\alpha\\ln\\cos x}{\\frac{\\alpha}{2}x^2} = -\\lim_{x\\rightarrow 0}\\frac{\\ln[1 + (\\cos x - 1)]}{\\frac{1}{2}x^2} = -\\lim_{x\\rightarrow 0}\\frac{-\\frac{1}{2}x^2}{\\frac{1}{2}x^2} = 1 $ ","permalink":"https://signalyu.github.io/posts/1-natural-science/math/calculus/3-proof-of-common-equivalent-infinitesimals/","summary":"基本等价无穷小 $\\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\sin x}{x} = 1$ 点击查看证明过程 $ 如下图可知：S_{三角形ABC} \u0026lt; S_{扇形ABC} \u0026lt; S_{三角形 ABD}\\\\ 即：\\frac{1}{2}\\sin x \u0026lt; \\frac{1}{2}x\u0026lt;\\frac{1}{2}\\tan x\\\\ 即：\\sin x \u0026lt; x \u0026lt; \\tan x\\\\ 即：1 \u0026lt; \\frac{x}{\\sin x} \u0026lt; \\frac{1}{\\cos x}\\\\ 即：\\cos x \u0026lt; \\frac{\\sin x}{x} \u0026lt; 1\\\\ 因为 \\lim_{x\\rightarrow 0}\\cos x = \\lim_{x\\rightarrow 0} 1 = 1\\\\ 由夹逼准则可知 \\lim_{x\\rightarrow 0}\\frac{\\sin x}{x} = 1 $ 图：$\\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\sin x}{x}$ $\\displaystyle\\lim_{x\\rightarrow 0}(1+x)^{\\frac{1}{x}} = e$ 点击查看证明过程 $ 令\\;L = \\displaystyle\\lim_{x\\rightarrow 0}(1+x)^{\\frac{1}{x}}\\\\ 则\\;\\ln L = \\displaystyle\\lim_{x\\rightarrow 0}\\ln (1+x)^{\\frac{1}{x}}\\\\ 即：\\ln L = \\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\ln (1+x)}{x} \\xlongequal{ 洛必达法则 }\\lim_{x\\rightarrow 0}\\frac{1}{1+x} = 1\\\\ 所以\\;L = e $ 点击查看证明过程 $ $ $\\displaystyle\\lim_{x\\rightarrow \\infty}(1+\\frac{1}{x})^x = e$ 点击查看证明过程 $ 令\\;L = \\displaystyle\\lim_{x\\rightarrow 0}(1+\\frac{1}{x})^x\\\\ 则\\;ln L = \\lim_{x\\rightarrow 0}x\\ln(1+\\frac{1}{x}) = \\lim_{x\\rightarrow 0}\\frac{\\ln(1 + \\frac{1}{x})}{\\frac{1}{x}} \\xlongequal{洛必达法则} \\lim_{x\\rightarrow 0}\\frac{\\frac{-\\frac{1}{x^2}}{1+\\frac{1}{x}}}{-\\frac{1}{x^2}} = \\lim_{x\\rightarrow 0}\\frac{1}{1+\\frac{1}{x}} = 1\\\\ 所以 \\;L = e $ 常用等价无穷小证明 $x \\sim \\tan x$ 点击查看证明过程 $ \\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\tan x}{x} = \\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\sin x}{\\cos x\\cdot x} = \\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\sin x}{x} = 1 $ $\\arcsin x \\sim x$ 点击查看证明过程 $ 令 \\;t = \\arcsin x，则\\;x = \\sin t\\\\ 所以\\;\\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\arcsin x}{x} = \\displaystyle\\lim_{t\\rightarrow 0} = \\frac{t}{\\sin t} = 1 $ $\\arctan x \\sim x$ 点击查看证明过程 $ 令 \\;t = \\arctan x，则\\;x = \\tan t\\\\ 所以\\;\\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\arctan x}{x} = \\displaystyle\\lim_{t\\rightarrow 0} = \\frac{t}{\\tan t} = 1 $ $\\log_a(1+x) \\sim \\frac{x}{\\ln a}$ 点击查看证明过程 $","title":"常用等价无穷小的证明"},{"content":"函数 设 $x$ 和 $y$ 是两个变量，$\\mathcal{D}$ 是一个给定的非空集合数集。如果对于每个数 $x \\in \\mathcal{D}$，变量 $x$ 按照一定的对应法则 $f$ 总有一个确定的数值 $y$ 和它对应，则称 $y$ 是 $x$ 的函数，记为 $$y = f(x), x \\in \\mathcal{D}$$\n其中 $x$ 称为自变量，$y$ 称为因变量，$\\mathcal{D}$ 称为函数的定义域，记作 $\\mathcal{D}_f$，即 $\\mathcal{D}_f = \\mathcal{D}$。函数值 $f(x)$ 的全体所构成的集合称为函数 $f$ 的值域，记作 $\\mathcal{R}_f$ 或 $f(\\mathcal{D})$，即 $$\\mathcal{R}_f = f(\\mathcal{D}) = \\{y|y=f(x), x\\in \\mathcal{D}\\}$$\n函数定义 定义域和对应法则是函数定义的两个基本要素，若两个函数的定义域和对应法则相同，则这两个函数为同一函数。 复合函数 设函数 $y = f(u)$ 的定义域为 $\\mathcal{D}_f$，函数 $u = g(x)$ 的定义域为 $\\mathcal{D}_g$，值域为 $\\mathcal{R}_g$，若 $\\mathcal{D}_f \\cap \\mathcal{R}_g \\ne \\varnothing$，则称函数 $y = f[g(x)]$ 为函数 $y = f(u)$ 与 $u = g(x)$ 的复合函数。它的定义域为 $\\{x | x \\in \\mathcal{D}_g，g(x) \\in \\mathcal{D}_f\\}$。\n函数的定义域必须是非空数集。如果两个函数 $f$，$g$ 能够复合为 $f(g)$，则必须满足 $\\mathcal{D}_{f(g)} \\ne \\varnothing$，即 $\\mathcal{D}_f \\cap \\mathcal{R}_g \\ne \\varnothing$。例如，$f(x) = ln x$ 与 $g(x) = \\sin x - 1$ 不能复合为 $f(g)$，因为 $\\mathcal{D}_f = (0,+\\infty] \\cap \\mathcal{R}_g = [-2, 0] = \\varnothing$。 题目 题目 1 已知 $f(x+1)$ 的定义域为 $[0, a]（a \u0026gt; 0）$，求 $f(x)$ 的定义域。\n点击查看答案 $令\\; g(x) = x + 1，由题意得：\\\\ D_{f\\cdot g} = [0,a]，即：0 \\le x \\le a\\\\ 所以 \\; 1 \\le x+1 \\le a+1\\\\ 如下图所示，f(x)\\;的定义域为\\;[1,a+1]$ $题目一：f(x)$ 定义域 函数的两个基本要素是定义域和映射关系，两者与自变量的符号没有关系。 题目 2 设函数 $f(x) = \\begin{cases}1，\u0026amp;|x| \\le 1\\\\ 0，\u0026amp; |x| \u0026gt; 1\\end{cases}$，则函数 $f[f(x)] = $\n点击查看答案 如下图易得 $f[f(x)] = 1$ 题目二：$f[f(x)] = 1$ 题目 3 设 $g(x) = \\begin{cases}2 - x, \u0026amp; x \\le 0\\\\ x + 2, \u0026amp; x \u0026gt; 0\\end{cases}，f(x) = \\begin{cases}x^2, \u0026amp; x \u0026lt; 0\\\\ -x, \u0026amp; x \\ge 0\\end{cases}$，求 $g[f(x)]$。\n点击查看答案 如下图易得 $g[f(x)] = \\begin{cases}x^2 + 2, \u0026amp; x \u0026lt; 0\\\\ x + 2, \u0026amp; x \\ge 0 \\end{cases}$ $题目三：g[f(x)] = \\begin{cases}x^2 \u0026#43; 2, \u0026amp; x \u0026lt; 0\\\\\\\\ x \u0026#43; 2, \u0026amp; x \\ge 0 \\end{cases}$ 题目 4 下列各题中，函数 $f(x)$ 和 $g(x)$ 是否相同？为什么？\n$f(x) = \\ln x^2，g(x) = 2\\ln x$ 点击查看答案 $ 两个函数相同的条件：定义域和映射关系相同。\\\\ f(x) = \\ln x^2 的定义域为\\; x \\ne 0\\\\ g(x) = 2\\ln x 的定义域为 \\; x\u0026gt;0\\\\ 故\\;f(x) \\;与\\;g(x)\\;不为同一函数 $ $f(x) = \\sqrt[3]{x^4 - x^3}，g(x) = x \\sqrt[3]{x - 1}$ 点击查看答案 $ 两个函数相同的条件：定义域和映射关系相同。\\\\ f(x) \\;与\\; g(x) \\;的定义域均为\\; x\\ge 1\\;且映射关系相同\\\\ 所以\\; f(x) \\;与\\; g(x) \\;为同一函数。 $ 题目 5 设 $f(x)$ 的定义域 $D = [0,1]$，则函数 $f(\\sin x)$ 的定义域为：\n点击查看答案 $$ 已知\\;D_f\\;求D_{f\\cdot g}$$ $ 令\\;g(x) \\; = x^2，根据下图可得：\\\\ R_g = D_f，即\\; 0 \\le \\sin x \\le 1\\\\ 所以\\;D_{f\\cdot g} = D_{g} = [2n\\pi, \\frac{\\pi}{2}+2n\\pi]，n \\in Z $ 图：题目 5 ","permalink":"https://signalyu.github.io/posts/1-natural-science/math/calculus/2-function-definition/","summary":"函数 设 $x$ 和 $y$ 是两个变量，$\\mathcal{D}$ 是一个给定的非空集合数集。如果对于每个数 $x \\in \\mathcal{D}$，变量 $x$ 按照一定的对应法则 $f$ 总有一个确定的数值 $y$ 和它对应，则称 $y$ 是 $x$ 的函数，记为 $$y = f(x), x \\in \\mathcal{D}$$\n其中 $x$ 称为自变量，$y$ 称为因变量，$\\mathcal{D}$ 称为函数的定义域，记作 $\\mathcal{D}_f$，即 $\\mathcal{D}_f = \\mathcal{D}$。函数值 $f(x)$ 的全体所构成的集合称为函数 $f$ 的值域，记作 $\\mathcal{R}_f$ 或 $f(\\mathcal{D})$，即 $$\\mathcal{R}_f = f(\\mathcal{D}) = \\{y|y=f(x), x\\in \\mathcal{D}\\}$$\n函数定义 定义域和对应法则是函数定义的两个基本要素，若两个函数的定义域和对应法则相同，则这两个函数为同一函数。 复合函数 设函数 $y = f(u)$ 的定义域为 $\\mathcal{D}_f$，函数 $u = g(x)$ 的定义域为 $\\mathcal{D}_g$，值域为 $\\mathcal{R}_g$，若 $\\mathcal{D}_f \\cap \\mathcal{R}_g \\ne \\varnothing$，则称函数 $y = f[g(x)]$ 为函数 $y = f(u)$ 与 $u = g(x)$ 的复合函数。它的定义域为 $\\{x | x \\in \\mathcal{D}_g，g(x) \\in \\mathcal{D}_f\\}$。","title":"函数与复合函数"},{"content":"Ɛ-N 定义 数列的极限 如果 $\\forall \\varepsilon \u0026gt; 0$，总存在正数 $N$，当 $n \u0026gt; N$ 时，恒有 $$|x_n - a| \u0026lt; \\varepsilon$$ 成立，则称常数 $a$ 为 数列 $\\{x_n\\}$ 当 $n$ 趋于无穷时的极限，记为 $\\displaystyle \\lim_{n\\rightarrow \\infty} x_n = a$\n$\\varepsilon$ 用于刻画数列的项与常数 $a$ 的接近程度，即 $|x_n - a|$ 的大小。$\\forall \\varepsilon \u0026gt; 0$ 表示数列的项与常数 $a$ “要多近有多近”，即 $|x_n - a|$ 要多小有多小。 $N$ 用于刻画 $n \\rightarrow \\infty$ 这个动态过程。“当 $n \u0026gt; N$ 时，恒有 $|x_n - a| \u0026lt; \\varepsilon$” 表示“在 $N$ 之后的无穷多个项 $x_n$ 与常数 $a$ 的距离小于 $\\varepsilon$ 恒成立。 Ɛ-N 定义的几何意义 数列极限的几何意义 $\\varepsilon-N$ 的几何意义：在极限值点 $a$ 任意作一个 $\\varepsilon$-领域，不论该领域的半径有多么小（$\\forall \\varepsilon \u0026gt; 0$），对数列 $a_n$ 而言，必有一个下标 $N$，使得第 $N$ 项以后的无穷多个项对应的那些点全部落入 $a$ 点的 $\\varepsilon$-邻域内，而不落入 $a$ 点的 $\\varepsilon$-邻域内的点，最多是下标 $N$ 前面的有限项。 根据 $\\varepsilon-N$ 的几何意义，可得出如下两个基本结论： 若 $b \u0026lt; a，\\exists N$，当 $n \u0026gt; N$ 时，$a_n \u0026gt; b$（把 $b$ 当成 $a - \\varepsilon$ 即可） 若 $c \u0026gt; a，\\exists N$，当 $n \u0026gt; N$ 时，$a_n \u0026lt; c$（把 $c$ 当成 $a + \\varepsilon$ 即可） 常用结论及其证明 $若 \\displaystyle\\lim_{n \\rightarrow \\infty} x_n = a，则 \\lim_{n \\rightarrow \\infty} |x_n| = |a|$，但反之不成立。 点击查看证明过程 $\\forall \\varepsilon \u0026gt; 0，\\;\\exists N \u0026gt; 0，当\\; n \u0026gt; N\\;时，|x_n - a| \u0026lt; \\varepsilon，又\\;||x_n - |a|| \\le |x_n - a|，则 \\;\\forall \\varepsilon \u0026gt; 0，\\exists N \u0026gt; 0，当 \\; n \u0026gt; N\\;时，||x_n| - |a|| \u0026lt; \\varepsilon，故 \\;\\displaystyle\\lim_{n \\rightarrow \\infty}|x_n| = a.\\\\ \\;\\\\ 反之不成立。例如\\; x_n = (-1)^n，则\\;\\lim_{n \\rightarrow \\infty} |x_n| = 1 = |1|，但\\;\\lim_{n \\rightarrow \\infty}x_n = \\lim_{n \\rightarrow \\infty}(-1)^n\\;不存在。$ 点击查看 $||a| - |b|| \\le |a - b|$ 证明过程 $\\because |a - b| + |b| \\ge |a|\\\\ \\therefore |a - b| \\ge |a| - |b|\\dots\\textcircled{1}\\\\ \\;\\\\ \\because |b - a| \\ge |b| - |a| = -(|a| - |b|)\\\\ \\therefore -|b - a| \\le |a| - |b|\\\\ \\because |a - b| = |b - a|\\\\ \\therefore -|b - a| = -|a - b | \\le |a| - |b|\\dots\\textcircled{2} \\;\\\\ 联立\\;\\textcircled{1}\\;\\textcircled{2}\\;得：-|a - b | \\le |a| - |b| \\le |a - b|\\\\ 即：||a| - |b|| \\le |a - b|$ 题目 题目一 对任意给定的 $\\varepsilon \\in (0,1)$，总存在正整数 $N$，当 $n \u0026gt; N$ 时，恒有 $|x_n - a| \\le 2\\varepsilon$ 是数列 $\\{x_n\\}$ 收敛于 $a$ 的\nA. 充分条件但非必要条件 B. 必要条件但非充分条件 C. 充分必要条件 D. 既非充分条件又非必要条件 点击查看答案 $充分性：对\\;\\forall \\varepsilon \u0026gt; 0，当 \\;n \\;大于正整数 \\;N\\;时，恒有\\;|x_n - a| \\le 2\\varepsilon，由 \\; \\varepsilon\\; 的任意性可设\\;\\forall\\varepsilon_1\u0026gt;0，取 \\;|x_n - a| \u0026lt; 2\\varepsilon \\;中的 \\;\\varepsilon = \\frac{\\varepsilon_1}{3}，则有\\; |x_n - a| = 2\\varepsilon = \\frac{2\\varepsilon_1}{3}\u0026lt;\\varepsilon_1\\\\ \\;\\\\ 必要性：数列 \\;x_n\\; 收敛于\\; n，则\\; |x_n - a| \u0026lt; \\varepsilon \u0026lt; 2\\varepsilon $ 题目二 设 $\\displaystyle\\lim_{n\\rightarrow \\infty} a_n = a$，且 $a \\ne 0$，则当 $n$ 充分大时有：\nA. $|a_n| \u0026gt; \\frac{|a|}{2}$ B. $|a_n| \u0026lt; \\frac{|a|}{2}$ C. $a_n \u0026gt; a - \\frac{1}{n}$ D. $a_n \u0026lt; a + \\frac{1}{n}$ 点击查看答案 $ 由 \\displaystyle\\lim_{n \\rightarrow \\infty} a_n = a，且 \\; a \\ne 0\\; 知，\\lim_{n \\rightarrow \\infty} |a_n| = |a| \u0026gt; 0，则当\\;n \\;充分大时有\\;|a_n| \u0026gt; \\frac{|a|}{2}。 $ ","permalink":"https://signalyu.github.io/posts/1-natural-science/math/calculus/1-epsilon-n-definition-of-limit/","summary":"Ɛ-N 定义 数列的极限 如果 $\\forall \\varepsilon \u0026gt; 0$，总存在正数 $N$，当 $n \u0026gt; N$ 时，恒有 $$|x_n - a| \u0026lt; \\varepsilon$$ 成立，则称常数 $a$ 为 数列 $\\{x_n\\}$ 当 $n$ 趋于无穷时的极限，记为 $\\displaystyle \\lim_{n\\rightarrow \\infty} x_n = a$\n$\\varepsilon$ 用于刻画数列的项与常数 $a$ 的接近程度，即 $|x_n - a|$ 的大小。$\\forall \\varepsilon \u0026gt; 0$ 表示数列的项与常数 $a$ “要多近有多近”，即 $|x_n - a|$ 要多小有多小。 $N$ 用于刻画 $n \\rightarrow \\infty$ 这个动态过程。“当 $n \u0026gt; N$ 时，恒有 $|x_n - a| \u0026lt; \\varepsilon$” 表示“在 $N$ 之后的无穷多个项 $x_n$ 与常数 $a$ 的距离小于 $\\varepsilon$ 恒成立。 Ɛ-N 定义的几何意义 数列极限的几何意义 $\\varepsilon-N$ 的几何意义：在极限值点 $a$ 任意作一个 $\\varepsilon$-领域，不论该领域的半径有多么小（$\\forall \\varepsilon \u0026gt; 0$），对数列 $a_n$ 而言，必有一个下标 $N$，使得第 $N$ 项以后的无穷多个项对应的那些点全部落入 $a$ 点的 $\\varepsilon$-邻域内，而不落入 $a$ 点的 $\\varepsilon$-邻域内的点，最多是下标 $N$ 前面的有限项。 根据 $\\varepsilon-N$ 的几何意义，可得出如下两个基本结论： 若 $b \u0026lt; a，\\exists N$，当 $n \u0026gt; N$ 时，$a_n \u0026gt; b$（把 $b$ 当成 $a - \\varepsilon$ 即可） 若 $c \u0026gt; a，\\exists N$，当 $n \u0026gt; N$ 时，$a_n \u0026lt; c$（把 $c$ 当成 $a + \\varepsilon$ 即可） 常用结论及其证明 $若 \\displaystyle\\lim_{n \\rightarrow \\infty} x_n = a，则 \\lim_{n \\rightarrow \\infty} |x_n| = |a|$，但反之不成立。 点击查看证明过程 $\\forall \\varepsilon \u0026gt; 0，\\;\\exists N \u0026gt; 0，当\\; n \u0026gt; N\\;时，|x_n - a| \u0026lt; \\varepsilon，又\\;||x_n - |a|| \\le |x_n - a|，则 \\;\\forall \\varepsilon \u0026gt; 0，\\exists N \u0026gt; 0，当 \\; n \u0026gt; N\\;时，||x_n| - |a|| \u0026lt; \\varepsilon，故 \\;\\displaystyle\\lim_{n \\rightarrow \\infty}|x_n| = a.","title":"极限的 Ɛ-N 定义"},{"content":"静态代理 静态代理模式类图 在静态代理模式下，可以在不修改目标对象代码的前提下对其进行功能扩展； 在静态代理模式下，代理对象和目标对象都需要实现父接口或者继承父类； 由于代理对象和目标对象需要实现相同的接口或者继承相同的父类，因此容易导致很多代理类的存在； 当父接口或父类增加方法时，目标对象和代理对象都需要维护。 代码示例 代码示例类图 点击查看代码 BankAccount ConcreteBankAccount StaticBankAccountProxy StaticProxyTest 输出结果 package org.signalyu.patterns.proxy; public interface BankAccount { boolean deposit(double amount); boolean withdraw(double amount); double getBalance(); } package org.signalyu.patterns.proxy; public class ConcreteBankAccount implements BankAccount { private double balance; public ConcreteBankAccount(double balance) { this.balance = balance; } @Override public boolean deposit(double amount) { if (amount \u003e 0) { this.balance += amount; return true; } return false; } @Override public boolean withdraw(double amount) { if (balance \u003e= amount) { balance -= amount; return true; } else { return false; } } @Override public double getBalance() { return balance; } } package org.signalyu.patterns.proxy; import java.time.LocalDateTime; public class StaticBankAccountProxy implements BankAccount { private final ConcreteBankAccount target; public StaticBankAccountProxy(double initialBalance) { this.target = new ConcreteBankAccount(initialBalance); } @Override public boolean withdraw(double amount) { System.out.println(LocalDateTime.now() + \": 取款中...\"); boolean withdraw = target.withdraw(amount); if (withdraw) { System.out.println(LocalDateTime.now() + \": 取款成功！\"); return true; } else { System.out.println(LocalDateTime.now() + \": 取款失败！\"); return false; } } @Override public boolean deposit(double amount) { boolean deposited = target.deposit(amount); System.out.println(LocalDateTime.now() + \": 存款中...\"); if (deposited) { System.out.println(LocalDateTime.now() + \": 存款完毕！\"); return true; } } @Override public double getBalance() { System.out.println(LocalDateTime.now() + \": 正在查询...\"); double balance = target.getBalance(); System.out.println(\"您的账户余额为：\" + target.getBalance()); return balance; } } import org.junit.jupiter.api.Test; import org.signalyu.patterns.proxy.BankAccount; import org.signalyu.patterns.proxy.StaticBankAccountProxy; public class StaticProxyTest { @Test public void testBankAccountProxy() { BankAccount proxy = new StaticBankAccountProxy(0); proxy.deposit(999); System.out.println(\"==================\"); proxy.withdraw(666); System.out.println(\"==================\"); proxy.getBalance(); System.out.println(\"==================\"); proxy.withdraw(400); } } 2024-05-22T13:11:10.480679: 存款中... 2024-05-22T13:11:10.481097: 存款完毕！ ================== 2024-05-22T13:11:10.481258: 取款中... 2024-05-22T13:11:10.481394: 取款成功！ ================== 2024-05-22T13:11:10.481567: 正在查询... 您的账户余额为：333.0 ================== 2024-05-22T13:11:10.486958: 取款中... 2024-05-22T13:11:10.487005: 取款失败！ 动态代理（JDK） 动态代理模式类图 在动态代理模式中，代理对象不需要实现父接口（或继承父接口），但目标对象需要实现接口； 在动态代理模式下，通过 JDK 的 API 动态地在内存中创建代理对象。 代码示例 示例代码类图 点击查看代码 BankAccount ConcreteBankAccount JDkBankAccountProxy Client 输出结果 package org.signalyu.patterns.proxy; public interface BankAccount { boolean deposit(double amount); boolean withdraw(double amount); double getBalance(); } package org.signalyu.patterns.proxy; public class ConcreteBankAccount implements BankAccount { private double balance; public ConcreteBankAccount(double balance) { this.balance = balance; } @Override public boolean deposit(double amount) { if (amount \u003e 0) { this.balance += amount; return true; } return false; } @Override public boolean withdraw(double amount) { if (balance \u003e= amount) { balance -= amount; return true; } else { return false; } } @Override public double getBalance() { return balance; } } package org.signalyu.patterns.proxy; import java.lang.reflect.Proxy; import java.time.LocalDateTime; public class JDKBankAccountProxy { private final Object target; public JDKBankAccountProxy(Object target) { this.target = target; } public Object getProxyInstance() { return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), (proxy, method, args) -\u003e { String methodName = method.getName(); if (\"deposit\".equals(methodName)) { System.out.println(LocalDateTime.now() + \": 存款中...\"); boolean invoked = (boolean) method.invoke(target, args); if (invoked) { System.out.println(LocalDateTime.now() + \": 存款完毕！\"); } return invoked; } else if (\"withdraw\".equals(methodName)) { boolean invoked = (boolean)method.invoke(target, args); if (invoked){ System.out.println(LocalDateTime.now() + \": 取款中...\"); System.out.println(LocalDateTime.now() + \": 取款成功！\"); } else { System.out.println(LocalDateTime.now() + \": 取款失败！\"); } return invoked; } else { System.out.println(LocalDateTime.now() + \": 正在查询余额...\"); Object invoked = method.invoke(target, args); System.out.println(\"您的余额为：\"+ method.invoke(target, args)); return invoked; } }); } } package org.signalyu.patterns.proxy; public class Client { public static void main(String[] args) { ConcreteBankAccount target = new ConcreteBankAccount(0); BankAccount proxyInstance = (BankAccount) new JDKBankAccountProxy(target).getProxyInstance(); proxyInstance.deposit(999); System.out.println(\"==================\"); proxyInstance.withdraw(666); System.out.println(\"==================\"); proxyInstance.getBalance(); System.out.println(\"==================\"); proxyInstance.withdraw(400); } } 2024-05-22T13:02:27.648927: 存款中... 2024-05-22T13:02:27.649245: 存款完毕！ ================== 2024-05-22T13:02:27.649376: 取款中... 2024-05-22T13:02:27.649448: 取款成功！ ================== 2024-05-22T13:02:27.649523: 正在查询余额... 您的余额为：333.0 ================== 2024-05-22T13:02:27.650227: 取款失败！ ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/tech/design-patterns/2-proxy-pattern/","summary":"静态代理 静态代理模式类图 在静态代理模式下，可以在不修改目标对象代码的前提下对其进行功能扩展； 在静态代理模式下，代理对象和目标对象都需要实现父接口或者继承父类； 由于代理对象和目标对象需要实现相同的接口或者继承相同的父类，因此容易导致很多代理类的存在； 当父接口或父类增加方法时，目标对象和代理对象都需要维护。 代码示例 代码示例类图 点击查看代码 BankAccount ConcreteBankAccount StaticBankAccountProxy StaticProxyTest 输出结果 package org.signalyu.patterns.proxy; public interface BankAccount { boolean deposit(double amount); boolean withdraw(double amount); double getBalance(); } package org.signalyu.patterns.proxy; public class ConcreteBankAccount implements BankAccount { private double balance; public ConcreteBankAccount(double balance) { this.balance = balance; } @Override public boolean deposit(double amount) { if (amount \u003e 0) { this.balance += amount; return true; } return false; } @Override public boolean withdraw(double amount) { if (balance \u003e= amount) { balance -= amount; return true; } else { return false; } } @Override public double getBalance() { return balance; } } package org.","title":"设计模式——代理模式"},{"content":"简单工厂（Simple Factory） 简单工厂模式通过一个专门的工厂类基于特定的参数来创建产品类的实例； 简单工厂模式违反了开闭原则，即在需要添加新的产品类型时需要修改工厂类。 代码示例 简单工厂示例类图 点击查看代码 Pizza MargheritaPizza PepperoniPizza BeefPizza PizzaFactory SimpleFactoryTest 输出结果 package org.signalyu.patterns.factory; public interface Pizza { void prepare(); void bake(); void cut(); void box(); } package org.signalyu.patterns.factory; public class MargheritaPizza implements Pizza { @Override public void prepare() { System.out.println(\"玛格丽特比萨：1. 准备材料\"); } @Override public void bake() { System.out.println(\"玛格丽特比萨：2. 烘烤比萨 \"); } @Override public void cut() { System.out.println(\"玛格丽特比萨：3. 切比萨\"); } @Override public void box() { System.out.println(\"玛格丽特比萨：4. 披萨打包\"); } } package org.signalyu.patterns.factory; public class PepperoniPizza implements Pizza { @Override public void prepare() { System.out.println(\"意大利辣式披萨：1. 准备原料\"); } @Override public void bake() { System.out.println(\"意大利辣式披萨：2. 烘烤披萨\"); } @Override public void cut() { System.out.println(\"意大利辣式披萨：3. 切披萨\"); } @Override public void box() { System.out.println(\"意大利辣式披萨：4. 披萨打包\"); } } package org.signalyu.patterns.factory; public class BeefPizza implements Pizza { @Override public void prepare() { System.out.println(\"牛肉披萨：1. 准备原料\"); } @Override public void bake() { System.out.println(\"牛肉披萨：2. 烘烤披萨\"); } @Override public void cut() { System.out.println(\"牛肉披萨：3. 切披萨\"); } @Override public void box() { System.out.println(\"牛肉披萨：4. 披萨打包\"); } } package org.signalyu.patterns.factory; public class PizzaFactory { public Pizza createPizza(String type) { // 当需要生产新品种披萨时，需要修改下面的代码，违背开闭原则 return switch (type) { case \"Margherita\" -\u003e new MargheritaPizza(); case \"Pepperoni\" -\u003e new PepperoniPizza(); case \"Beef\" -\u003e new BeefPizza(); default -\u003e throw new IllegalArgumentException(\"请选择正确的披萨类型: \" + type); }; } } import org.junit.jupiter.api.Test; import org.signalyu.patterns.factory.Pizza; import org.signalyu.patterns.factory.PizzaFactory; public class SimpleFactoryTest { @Test public void testPizzaFactory() { PizzaFactory pizzaFactory = new PizzaFactory(); Pizza margheritaPizza = pizzaFactory.createPizza(\"Margherita\"); margheritaPizza.prepare(); margheritaPizza.bake(); margheritaPizza.cut(); margheritaPizza.box(); System.out.println(\"----------------------\"); Pizza pepperoniPizza = pizzaFactory.createPizza(\"Pepperoni\"); pepperoniPizza.prepare(); pepperoniPizza.bake(); pepperoniPizza.cut(); pepperoniPizza.box(); System.out.println(\"----------------------\"); Pizza veggiePizza = pizzaFactory.createPizza(\"Beef\"); veggiePizza.prepare(); veggiePizza.bake(); veggiePizza.cut(); veggiePizza.box(); } } 玛格丽特比萨：1. 准备材料 玛格丽特比萨：2. 烘烤比萨 玛格丽特比萨：3. 切比萨 玛格丽特比萨：4. 披萨打包 ---------------------- 意大利辣式披萨：1. 准备原料 意大利辣式披萨：2. 烘烤披萨 意大利辣式披萨：3. 切披萨 意大利辣式披萨：4. 披萨打包 ---------------------- 牛肉披萨：1. 准备原料 牛肉披萨：2. 烘烤披萨 牛肉披萨：3. 切披萨 牛肉披萨：4. 披萨打包 工厂方法（Factory Method） 工厂方法模式提供一个抽象工厂接口，具体工厂类实现该接，并为创建对象提供具体实现； 工厂方法模式使用单个工厂方法创建单个产品类型； 工厂方法模式遵循开闭原则。 代码示例 工厂方法示例类图 点击查看代码 Car BruBus Porsche Lamborghini CarFactory BruBusFactory PorscheFactory LamborghiniFactory FactoryMethodTest 输出结果 package org.signalyu.patterns.factory; public interface Car { void assemble(); void paint(); void polish(); void testDrive(); } package org.signalyu.patterns.factory; public class BruBus implements Car { @Override public void assemble() { System.out.println(\"博速：1. 组装\"); } @Override public void paint() { System.out.println(\"博速：2. 刷漆\"); } @Override public void polish() { System.out.println(\"博速：3. 抛光\"); } @Override public void testDrive() { System.out.println(\"博速：4. 驾驶测试\"); } } package org.signalyu.patterns.factory; public class Porsche implements Car { @Override public void assemble() { System.out.println(\"保时捷：1. 组装\"); } @Override public void paint() { System.out.println(\"保时捷：2. 刷漆\"); } @Override public void polish() { System.out.println(\"保时捷：3. 抛光\"); } @Override public void testDrive() { System.out.println(\"保时捷：4. 驾驶测试\"); } } package org.signalyu.patterns.factory; public class Lamborghini implements Car { @Override public void assemble() { System.out.println(\"兰博基尼：1. 组装\"); } @Override public void paint() { System.out.println(\"兰博基尼：2. 刷漆\"); } @Override public void polish() { System.out.println(\"兰博基尼：3. 抛光\"); } @Override public void testDrive() { System.out.println(\"兰博基尼：4. 驾驶测试\"); } } package org.signalyu.patterns.factory; public interface CarFactory { Car createCar(); } package org.signalyu.patterns.factory; public class BruBusFactory implements CarFactory{ @Override public Car createCar() { return new BruBus(); } } package org.signalyu.patterns.factory; public class PorscheFactory implements CarFactory{ @Override public Car createCar() { return new Porsche(); } } package org.signalyu.patterns.factory; public class LamborghiniFactory implements CarFactory{ @Override public Car createCar() { return new Lamborghini(); } } import org.junit.jupiter.api.Test; import org.signalyu.patterns.factory.*; public class FactoryMethodTest { @Test public void testCarFactory() { CarFactory bruBusFactory = new BruBusFactory(); Car bruBus = bruBusFactory.createCar(); bruBus.assemble(); bruBus.paint(); bruBus.polish(); bruBus.testDrive(); System.out.println(\"-------------------\"); CarFactory porscheFactory = new PorscheFactory(); Car porsche = porscheFactory.createCar(); porsche.assemble(); porsche.paint(); porsche.polish(); porsche.testDrive(); System.out.println(\"-------------------\"); CarFactory lamborghiniFactory = new LamborghiniFactory(); Car lamborghini = lamborghiniFactory.createCar(); lamborghini.assemble(); lamborghini.paint(); lamborghini.polish(); lamborghini.testDrive(); } } 博速：1. 组装 博速：2. 刷漆 博速：3. 抛光 博速：4. 驾驶测试 ------------------- 保时捷：1. 组装 保时捷：2. 刷漆 保时捷：3. 抛光 保时捷：4. 驾驶测试 ------------------- 兰博基尼：1. 组装 兰博基尼：2. 刷漆 兰博基尼：3. 抛光 兰博基尼：4. 驾驶测试 抽象工厂（Abstract Factory） 抽象工厂模式提供一个接口，并提供多个工厂方法用于创建相关产品系列； 具体工厂类实现抽象工厂接口，并为创建对象提供具体实现； 抽象工厂模式遵循开闭原则。 代码示例 抽象工厂示例类图 点击查看代码 AbstractChair AbstractSofa ModernChair ModernSofa VictorianChair VictorianSofa FurnitureFactory ModernFurnitureFactory VictorianFurnitureFactory AbstractFactoryTest 输出结果 package org.signalyu.patterns.factory; public abstract class AbstractChair { public abstract void sitOn(); } package org.signalyu.patterns.factory; public abstract class AbstractSofa { public abstract void lieOn(); } package org.signalyu.patterns.factory; public class ModernChair extends AbstractChair { @Override public void sitOn() { System.out.println(\"坐在现代风格椅子...\"); } } package org.signalyu.patterns.factory; public class ModernSofa extends AbstractSofa{ @Override public void lieOn() { System.out.println(\"躺在现代风格沙发...\"); } } package org.signalyu.patterns.factory; public class VictorianChair extends AbstractChair { @Override public void sitOn() { System.out.println(\"坐在维多利亚风格椅子...\"); } } package org.signalyu.patterns.factory; public class VictorianSofa extends AbstractSofa { @Override public void lieOn() { System.out.println(\"躺在维多利亚风格沙发上...\"); } } package org.signalyu.patterns.factory; public interface FurnitureFactory { AbstractChair createChair(); AbstractSofa createSofa(); } package org.signalyu.patterns.factory; public class ModernFurnitureFactory implements FurnitureFactory { @Override public AbstractChair createChair() { return new ModernChair(); } @Override public AbstractSofa createSofa() { return new ModernSofa(); } } package org.signalyu.patterns.factory; public class VictorianFurnitureFactory implements FurnitureFactory { @Override public AbstractChair createChair() { return new VictorianChair(); } @Override public AbstractSofa createSofa() { return new VictorianSofa(); } } import org.junit.jupiter.api.Test; import org.signalyu.patterns.factory.*; public class AbstractFactoryTest { @Test public void testFurnitureFactory() { FurnitureFactory modernFactory = new ModernFurnitureFactory(); AbstractChair modernChair = modernFactory.createChair(); AbstractSofa modernSofa = modernFactory.createSofa(); modernChair.sitOn(); modernSofa.lieOn(); FurnitureFactory victorianFactory = new VictorianFurnitureFactory(); AbstractChair victorianChair = victorianFactory.createChair(); AbstractSofa victorianSofa = victorianFactory.createSofa(); System.out.println(\"----------------------\"); victorianChair.sitOn(); victorianSofa.lieOn(); } } 坐在现代风格椅子... 躺在现代风格沙发... ---------------------- 坐在维多利亚风格椅子... 躺在维多利亚风格沙发上... 总结 简单工厂模式、工厂方法模式和抽象工厂模式的主要区别在于创建对象的方法和抽象程度不同。简单工厂模式为创建对象提供了一个基本的集中式工厂，违背开闭原则；工厂方法模式将创建对象的工作委托给子类，不违背开闭原则；抽象工厂模式则通过一系列工厂方法创建相关对象簇，不违背开闭原则。 ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/tech/design-patterns/1-factory-pattern/","summary":"简单工厂（Simple Factory） 简单工厂模式通过一个专门的工厂类基于特定的参数来创建产品类的实例； 简单工厂模式违反了开闭原则，即在需要添加新的产品类型时需要修改工厂类。 代码示例 简单工厂示例类图 点击查看代码 Pizza MargheritaPizza PepperoniPizza BeefPizza PizzaFactory SimpleFactoryTest 输出结果 package org.signalyu.patterns.factory; public interface Pizza { void prepare(); void bake(); void cut(); void box(); } package org.signalyu.patterns.factory; public class MargheritaPizza implements Pizza { @Override public void prepare() { System.out.println(\"玛格丽特比萨：1. 准备材料\"); } @Override public void bake() { System.out.println(\"玛格丽特比萨：2. 烘烤比萨 \"); } @Override public void cut() { System.out.println(\"玛格丽特比萨：3. 切比萨\"); } @Override public void box() { System.out.println(\"玛格丽特比萨：4. 披萨打包\"); } } package org.","title":"设计模式——工厂模式"},{"content":" 子类对象拥有父类的私有成员，但子类不继承父类的私有属性。 子类对象包含父类私有属性 首先验证子类对象包含父类的私有属性，代码如下：\n点击查看代码 class Parent { private int privateField; public Parent() { System.out.println(\"this in Parent() =\u003e \" + this); this.privateField = 666; } public Parent(int privateField) { System.out.println(\"this in Parent(int) =\u003e \" + this); this.privateField = privateField; } private void printPrivateField() { System.out.println(this.privateField); } public void accessPrivateMembers() { System.out.println(\"this in accessPrivateMembers() =\u003e \" + this); System.out.print(\"调用 this.printPrivateField() 方法 =\u003e \"); this.printPrivateField(); } } class Child extends Parent { public Child() { System.out.println(\"this in Child() =\u003e \" + this); } } public class Main { public static void main(String[] args) { Child child = new Child(); child.accessPrivateMembers(); } } 上述代码输出结果为：\nthis in Parent() =\u003e Child@372f7a8d this in Child() =\u003e Child@372f7a8d this in accessPrivateMembers() =\u003e Child@372f7a8d 调用 this.printPrivateField() 方法 =\u003e 666 上述代码的输出结果表明，执行 new Child() 后，会调用子类 Child 的无参构造器，而在子类构造器中默认会调用父类的无参构造器。而从输出结果可知，父类无参构造中的 this 指向子类 Child。并且 this.privateField = 666; 也成功执行。同样地，在调用公有（public）方法 accessPrivateMembers() 时，此时的 this 为 Child，并且通过 this 也可以访问父类的私有方法 printPrivateFields()。显然，this 中包含父类的私有属性 privateField 和私有方法 printPrivateField()。事实上，可以通过 org.openjdk.jol 工具中的 ClassLayout 来查看 child 对象在内存中的布局。代码如下：\n点击查看代码 import org.openjdk.jol.info.ClassLayout; class Parent { private int privateField; public Parent() { System.out.println(\"this in Parent() =\u003e \" + this); this.privateField = 666; } public Parent(int privateField) { System.out.println(\"this in Parent(int) =\u003e \" + this); this.privateField = privateField; } private void printPrivateField() { System.out.println(this.privateField); } public void accessPrivateMembers() { System.out.println(\"this in accessPrivateMembers() =\u003e \" + this); System.out.print(\"调用 this.printPrivateField() 方法 =\u003e \"); this.printPrivateField(); } } class Child extends Parent { public Child() { System.out.println(\"this in Child() =\u003e \" + this); } } public static void main(String[] args) { Child child = new Child(); String childLayout = ClassLayout.parseInstance(child).toPrintable(); System.out.println(childLayout); } 上述代码输出结果为：\nChild object internals: OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x000000372f7a8d01 (hash: 0x372f7a8d; age: 0) 8 4 (object header: class) 0x01001418 12 4 int Parent.privateField 666 Instance size: 16 bytes Space losses: 0 bytes internal + 0 bytes external = 0 bytes total 根据上述输出结果可以看出，child 对象中确实包含父类的私有属性。\nJava 语言规范中关于类成员的规定 Java 类成员 Java 语言规范中关于类成的部分陈述如下：\n类的成员包括以下所有成员（The members of a class type are all of the following）：\n从除 Object 类之外的直接父类继承的成员（Members inherited from its direct superclass, except in class Object, which has no direct superclass） 从任何直接父接口继承的成员（Members inherited from any direct superinterfaces） 类中声明的成员（Members declared in the body of the class） 类中声明为私有的成员不会被该类的子类继承。（Members of a class that are declared private are not inherited by subclasses of that class.）\n只有声明为受保护（protected）或公共（public）的类成员才会被本包外的子类继承。（Only members of a class that are declared protected or public are inherited by subclasses declared in a package other than the one in which the class is declared.）\n构造器（constructors）、静态初始化器（static initializers）和实例初始化器（instance initializers）不是类成员，因此不会被继承。（Constructors, static initializers, and instance initializers are not members and therefore are not inherited.）\n超类的私有成员 Oracle 官方 Java 教程中关于超类的私有成员的说明：\n子类不继承父类的私有成员。不过，如果超类有访问其私有字段的公共或保护方法，子类也可以使用这些方法（间接访问父类的私有属性）。（A subclass does not inherit the private members of its parent class. However, if the superclass has public or protected methods for accessing its private fields, these can also be used by the subclass.）\n官方已明确说明子类不继承父类的私有成员，那为什么子类对象可以访问父类的私有成员呢？博主认为，继承是发生在类之间行为，而非对象之间的行为。子类 Child 不继承父类 Parent 的私有成员，并不代表子类对象 child 不可以拥有父类的私有成员。 参考资料 知乎：java中子类有没有继承父类的私有变量？ Java Language Specification : 8.2. Class Members Oracle Java Tutorial: Private Members in a Superclass Do subclasses inherit private fields? ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/tech/java/1-java-private-inheritance/","summary":"子类对象拥有父类的私有成员，但子类不继承父类的私有属性。 子类对象包含父类私有属性 首先验证子类对象包含父类的私有属性，代码如下：\n点击查看代码 class Parent { private int privateField; public Parent() { System.out.println(\"this in Parent() =\u003e \" + this); this.privateField = 666; } public Parent(int privateField) { System.out.println(\"this in Parent(int) =\u003e \" + this); this.privateField = privateField; } private void printPrivateField() { System.out.println(this.privateField); } public void accessPrivateMembers() { System.out.println(\"this in accessPrivateMembers() =\u003e \" + this); System.out.print(\"调用 this.printPrivateField() 方法 =\u003e \"); this.printPrivateField(); } } class Child extends Parent { public Child() { System.","title":"Java 私有成员继承"}]