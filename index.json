[{"content":"Core Concepts Loose Coupling Loose Coupling is a design principle that aims to reduce the dependencies between components within a system.\nInversion of Control (IoC) Inversion of Control is a design principle where the control of object creation and lifecycle management is transferred from the application code to an external container or framework.\nDependency Injection (DI) Dependency Injection is a design pattern commonly used in object-oriented programming, where the dependecies of a class are provided externally rather than being created within the class itself.\nBeans Beans are objects that are managed by the Spring framework.\nContainer A Spring Container is responsible for managing the life cycle, configuration, and dependencies injection of the beans in a Spring Application.\nLife Cycle of Beans Beans are objects that are managed by the Spring framework. Bean Definition includes configuration meta data required by the Spring container to create and manage the bean. Bean Configurations can be provided in various way, including XML configuration files, annotations, and Java-based configuration. Bean Instantiation $\\rightarrow$ Population of Properties $\\rightarrow$ Initialization $\\rightarrow$ Ready for Use $\\rightarrow$ Destruction The Difference between instantiation and initiation?\nInstantiation occurs when a new keyword is used to create an object. It focus on constructing the object\u0026rsquo;s structure and allocating memory. In contrast, initialization focus on assigning values to the object\u0026rsquo;s fields and setting up its initial state after instantiation.\nConstructor Injection \u0026amp; Setter Injection \u0026amp; Field Injection Constructor Injection Constructor Injection in Spring is a type of dependency injection where the Spring framework provides the required dependency to a class by invoking its constructor. Since dependencies are supplied via the constructor, they cannot be changed after object creation \u0026ndash; promoting immutability. However, this approach may cause circular dependency issues if two or more beans depend on each other in a circular manner.\nSHOW CODE Java @Component public class ServiceA { private final RepositoryA repositoryA; // Constructor injection @Autowired public ServiceA(RepositoryA repositoryA) { this.repositoryA = repositoryA; } } Setter Injection Setter Injection in Spring is a form of dependency injection where the Spring framework injects dependencies into a bean by calling the bean\u0026rsquo;s setter method. This approach is flexible and commonly used to inject optional dependencies or when the dependency might change after the object is initialized.\nSHOW CODE Java @Component public class ServiceB { private RepositoryB repositoryB; // Setter injection @Autowired public void setRepositoryB(RepositoryB repositoryB) { this.repositoryB = repositoryB; } } Field Injection Field Injection in Spring is a form of dependency injection where the Spring framework directly injects dependencies into a class\u0026rsquo;s fields. Like constructor injection, the dependencies remain immutable after being injected. Under the hood. Spring uses reflection to assign values to private fields.\nSHOW CODE Java @Component public class ServiceC { @Autowired private RepositoryC repositoryC; public void performAction() { repositoryC.doSomething(); } } @Component \u0026amp; @ComponentScan The @Component annotation in Spring is used to mark a class as spring-managed bean, allowing Spring to detect and register it as a bean in the application context. The @ComponentScan annotation is used to specify base packages that Spring should scan for @Component-annotated during configuration.\nSHOW CODE Java package com.example.myapp @Component public class MyService { public void performTask() { System.out.println(\"Task performed!\"); } } @Configuration @ComponentScan(basePackages = \"com.example.myapp\") public class AppConfig { } @Value \u0026amp; @Autowired \u0026amp; @Qualifier @Value The @Value annotation is used to inject values into fields, mathod parameters, and constructor arguments.\nSHOW CODE Java // Injects literal values @Value(\"Hello, World!\") private String message; // Injects from a properties file app.name=MySpringApp @Value(\"${app.name}\") private String appName; // Injects default values @Value(\"${app.version:1.0.0}\") private String appVersion; // Injects expression @Value(\"#{T(java.lang.Math).random() * 100}\") private double randomValue; @Autowired The @Autowired annotation is used for automatic dependency injection. It allows Spring resolve and inject the required bean into a class automatically by type.\nSHOW CODE Java // Field Injection @Component public class ServiceA { @Autowired private RepositoryA repositoryA; public void performTask() { repositoryA.doSomething(); } } // Setter Injection @Component public class ServiceB { private RepositoryB repositoryB; @Autowired public void setRepositoryB(RepositoryB repositoryB) { this.repositoryB = repositoryB; } } // Constructor Injection @Component public class ServiceB { private RepositoryB repositoryB; @Autowired public void setRepositoryB(RepositoryB repositoryB) { this.repositoryB = repositoryB; } } @Qualifier The @Qualifier annotation in Spring is used for resolve ambiguities when multiple beans of the same type are available in the application context.\nSHOW CODE Java @Component(\"repositoryImpl1\") public class RepositoryImpl1 implements Repository {} @Component(\"repositoryImpl2\") public class RepositoryImpl2 implements Repository {} @Component public class Service { @Autowired @Qualifier(\"repositoryImpl2\") private Repository repository; } Components of Spring Boot Spring Boot Starter: Simplifies dependency management by building commonly used dependencies, reducing the need for manual configuration.\nAuto Configuration: Automatically configures Spring Boot application beans and settings based on the libraries on the classpath, eliminating the need for extensive configuration in application.properties or XML files.\nSpring Boot Atuator: Provides production-ready features like monitoring, metrics, and health checks to ensure better application insights and management.\nEmbedded Server: Includes servers like Tomcat and Jetty, allowing applications to run as standalone programs, simplifying development and deployment.\nSpring Boot DevTools: A collection of tools that enhance the development experience by enabling features like hot reload and live reload for faster feedback.\nSpring Boot Auto Configuration Spring Boot looks for classes annotated with @Configuration and examines the dependencies in the classpath. The @Configuration annotation triggers the logic that looks for @Bean declarations within the class and registers those beans to be managed by the Spring container.\nIn a Spring Boot application, the main method typically calls the SpringApplication.run() method. This method takes the main application class (e.g., XXXApplication.class) as a parameter. The XXXAplication class is annotated with @SpringBootApplication which includes three key annotations: @SpringBootConfiguration, @EnableAutoConfiguration, and @ComponentScan.\n@SpringBootConfiguration is an alias for @Configurition. It indicates that the class contains Spring bean definitions, and Spring Boot will scan it for @Bean declarations.\n@EnableAutoConfiguration annotation tells Spring Boot to enable its auto-configuration mechanism. It looks for the file AutoConfiguration.imports inside the spring-boot-autoconfigure.jar dependency, which lists auto-configuration classes. Spring Boot automatically imports and executes every class that has the AutoConfiguration name at the end of the class name.\n# META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration org.springframework.boot.autoconfigure.aop.AopAutoConfiguration org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration ... @ComponentScan annotation tells Spring Boot to scan for Spring components (such as @Component, @Service, @Repository, etc.) in the specified packages or the entire classpath. By default, it scans from the package of the class that contains the annotation. To specify a different base package, the basePackages parameter can be set, like this:\n@ComponentScan(basePackages = {\u0026#34;com.mycompany\u0026#34;}) Common Annotations @Component vs. @Bean The @Component annotation is applied to a class to mark it as a bean managed by the Spring container. There are several specialized variants of this annotation: @Controller (for web controllers), @Service (for service layer components), and @Repository (for DAO layer components). In contrast, the @Bean annotation is used to mark a method within a class annotated with @Configuration, indicating that the method should return an object to be managed by the Spring container. This apporpach provides more control over bean creation and configuration, allowing for more explicit customization of the bean.\nSHOW CODE Java // Spring will detect UserService during classpath // scanning and manage it as a bean. @Component public class UserService { public String getUser() { return \"User\"; } } @Configuration public class AppConfig { @Bean public UserService userService() { // Explicitly creating and returning the bean return new UserService(); } } @ResposeBody The @ResponseBody annotation in Spring is used to indicate that a method\u0026rsquo;s return value should be written directly to the HTTP response body, rather than being treated as a view name, which is the default behavior in traditional Spring MVC controllers. The return value is automatically serialized into a format like JSON or XML, typically using Jackson, depending on the request\u0026rsquo;s Accept header.\nSHOW CODE Java @Controller public class MyRestController { @RequestMapping(\"/user\") @ResponseBody public User getUser() { return new User(\"John\", \"Doe\"); } } public class User { private String firstName; private String lastName; // Constructor, getters, and setters } In the above code, the User object will be automatically serialized into JSON format by Jackson when returned from the getUser() method. The @ResponseBody annotation ensures that the method\u0026rsquo;s return value is written directly to the HTTP response body, and Jackson handles the conversion to JSON.\n@Controller vs. @RestController The @Controller annotation is used to declare a class as a controller in Spring MVC. By default, methods within a @Controller-annotated class return a view name (e.g., home.jsp). If a method needs to return a value directly (such as JSON or XML), it should be annotated with @ResponseBody. In contrast, the @RestController annotation is a specialized version of @Controller used to define a controller for RESTful web services. It combines @Controller and @ResponseBody, meaning that the methods in a RestController-annotated class automatically return values written directly to the HTTP response body. This response is typically serialized into JSON or XML format by Jackson.\nSHOW CODE Java @Controller public class WebController { @RequestMapping(\"/home\") public String home() { return \"home\"; // returns home.jsp } } @Controller public class MyController { @RequestMapping(\"/greeting\") @ResponseBody public String greeting() { return \"Hello, World!\"; // The return value is written directly to the response body } } @RestController public class UserController { @RequestMapping(\"/api/user\") public User getUser() { return new User(\"Alice\", \"Smith\"); } } public class User { private String firstName; private String lastName; // Constructor, getters, and setters } @RequestBody, @RequestParam, @PathVariable The @RequestBody annotation is used to bind the body of an HTTP request to a method parameter. It is typically used with HTTP methods like POST, PUT, or PATCH to send data in formats such as JSON or XML. Spring automatically deserializes the request body into an obejct using a message converter, liek Jakson.\nSHOW CODE Java @RestController public class UserController { @PostMapping(\"/user\") public ResponseEntity\u0026lt;String\u0026gt; createUser(@RequestBody User user) { // User is automatically deserialized from the JSON request body return ResponseEntity.ok(\"User created: \" + user.getName()); } } The @RequestParam annotation binds a query parameter or form data to a method parameter. It is commonly used in GET or POST requests to retrive single query parameters. The annotation has optional attributes such as required (to specify if the parameter is mandatory) and defaultValue (to provide a default value when the parameter is absent).\nSHOW CODE Java @RestController public class SearchController { @GetMapping(\"/search\") public ResponseEntity\u0026lt;String\u0026gt; search(@RequestParam String query, @RequestParam(defaultValue = \"10\") int limit) { // query: the search term from the query string // limit: the number of results (defaults to 10 if not provided) return ResponseEntity.ok(\"Searching for: \" + query + \", Limit: \" + limit); } } The @PathVariable annotation binds a URL path variable to a method parameter, commonly used in RESTful web service to capture dynamic segments in the URL. For example, int the URL /user/{id}, the {id} part is dynamic, and the value of {id} will be extracted and passed to the method parameter.\nSHOW CODE Java @RestController public class UserController { // Regular expression to match both with and without the path variable @GetMapping(\"/user/{id:[a-zA-Z0-9]*}\") public ResponseEntity\u0026lt;String\u0026gt; getUser(@PathVariable(required = false) String id) { if (id == null) { return ResponseEntity.ok(\"Default User\"); } return ResponseEntity.ok(\"User ID: \" + id); } } Transformation between Object and Spring In Spring Boot, the transformation between objects and JSON is handled by the Jackson library which allows for easy serialization (converting an object to JSON) and deserialization (converting JSON to an object).\nSHOW CODE Java // When a controller returns an object, Spring Boot automatically // converts it to JSON @RestController public class UserController { @GetMapping(\"/user\") public User getUser() { return new User(1, \"John Doe\", \"john.doe@example.com\"); } } // When accessed via /user, the response is: { \"id\": 1, \"name\": \"John Doe\", \"email\": \"john.doe@example.com\" } // Spring Boot automatically converts the incoming JSON data into // an object when the object is a parameter in the controller method. @RestController public class UserController { @PostMapping(\"/user\") public String createUser(@RequestBody User user) { return \"User \" + user.getName() + \" created!\"; } } // Input JOSN: { \"id\": 2, \"name\": \"Jane Doe\", \"email\": \"jane.doe@example.com\" } ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/framework/backend/spring/1-spring-notes/","summary":"Core Concepts Loose Coupling Loose Coupling is a design principle that aims to reduce the dependencies between components within a system.\nInversion of Control (IoC) Inversion of Control is a design principle where the control of object creation and lifecycle management is transferred from the application code to an external container or framework.\nDependency Injection (DI) Dependency Injection is a design pattern commonly used in object-oriented programming, where the dependecies of a class are provided externally rather than being created within the class itself.","title":"Spring Notes"},{"content":"Introduction to Databases A database is a collection of data that is stored, managed, and accessed electronically. It typically contains one or more tables, which resemble Excel or Google sheets, with data organized into rows and columns. As the number of tables grows, managing the database can become complex, making it essential to design a scalable and maintainable strucutre.\nDatabases can be broadly categorized into two types: Relational database, primarily used for real-time data updates and transactions, and data warehouse, optimized for data analysis and reporting purposes.\nData Modeling Data modeling is the process of creating a conceptual representation of data structures, relationships, and rule to meet business requirements. It serves as a blueprint for designing and managing a database.\nThere are three types of data models: conceptual, logical, and physical. The conceptual data model provides a high-level overview, specifying relationships between objects without technical details. The logical data model refine the conceptual data model by adding more detail, such as fields for each object. The physical data model describe the internal schema of the database, including table structures, storage details, and implementation specifics.\n--- title: Conceptual Data Model --- erDiagram Customer ||--o{ Order : places Order ||--|{ Product : contains --- title: Logical Data Model --- erDiagram Customer { int customerId string name string email } Order { int orderId date orderDate float totalAmount } Product { int productId string productName float price } Customer ||--o{ Order : places Order ||--|{ Product : contains --- title: Physical Data Model --- erDiagram Customer { int customerId PK varchar name varchar email } Order { int orderId PK date orderDate float totalAmount int customerId FK } Product { int productId PK varchar productName decimal price } OrderItem { int orderItemId PK int orderId FK int productId FK int quantity } Customer ||--o{ Order : places Order ||--|{ OrderItem : includes OrderItem ||--|{ Product : contains Example: University Enrollment Management System Entities In database design, an entity is a distinct object that typically represents real-world objects, events, or concepts. Entities are represented as tables in a relational database, and they are similar to classes in object-oriented design. Each row in the table represents an instance of the entity. Each entity has attributes that describe its characteristics. For example, a Student entity may have attributes like student_id, first_name, last_name, and date_of_birth, among others. Entities can be related to one another, and these relationships are often captured using foreign keys or relationship tables, which link entities together based on logical associations. For example, a Student might be linked to a Course through an enrollment relationship.\nIdentifying Entities Identifying entities in database design is a crucial step, as entities form the foundation of a database. A useful approach for identifying entities is to clarify the design objectives and look for nouns in the objective statement. For example, consider the University Enrollment Management System. The objective statement might be:\n\u0026ldquo;The University Enrollment Management System\u0026rdquo; is designed to help a university track enrolled students, the subjects they are taking, and the teachers assigned to those subjects\u0026quot;.\nIn this sentence, the nouns university, student, subject, and teacher are potential entities, as they represent key objects or concepts that the system needs to track.\n--- title: Identifying Entities --- erDiagram UNIVERSITY STUDENT erDiagram TEACHER SUBJECT Defining Attributes In database design, an attribute describes the characteristics of an entity. In a relational database, attributes are typically represented as columns in a table. Defining entity attributes is a crucial step in database design, as it ensures that the entity captures all the necessary details required by the system. When defining attributes, it\u0026rsquo;s important to consider what properties or characteristics the entity possesses.\nFor example, in a University Enrollment Management System, the Student entity might have attributes like first_name, last_name, date_of_birth, and address. After identifying the necessary attributes, the next step is to specify the approapriate data type for each attribute. For instance, attributes like first_name, last_name, and address would typically use the TEXT data type, while the date_of_birth attribute would be defined with the DATE data type.\n--- title: Defining Attributes --- erDiagram UNIVERSITY { string name string address } STUDENT { string first_name string last_name date date_of_birth string address } erDiagram SUBJECT { string subject_name string category string students_enrolled } TEACHER { string first_name string last_name date date_of_birth string address string subject_taught } Normalization Normalization in database design is the process of organizing the attributes of entities and their relationships to reduce data redundency, avoid operational anomalies, and improve data integrity. Normalization involves decomposing a large, complex database into smaller, simpler tables while preserving the relationships between entities. This decomposition follows a set of rules called normal forms. In real-world database design, the three most commonly used normal normal forms are First Normal Form (1NF), Second Normal Form (2NF), and Third Normal Form (3NF).\nFirst Normal Form First Normal Form (1NF) is a property of a relational database table that ensures the table is structured properly. It follows the following conditions:\nEach column must contain atomic values, meaning that the value in a field should be indivisible and not contain sets or lists of values. Each row must be unique, which can be achieved by using a primary key to uniquely identify each record. All values in single column should be of the same data type. A Primary Key is a column (or a set of columns) in a relational database table that uniquely identifies each row in that table. It satisfies the following conditions:\nThe value in the primary key must be unique for each row. The value in the primary key must not be null for any record. The value in the primary key should generally be immutable, meaning it should not change once assigned. When designing tables, assess if any combination of columns can be used to uniquely identify a record. If such a combination exists, those columns can form the primary key. If no suitable combination is found, create a new column to serve as the primary key.\nA primary key can be a set of columns when a single column is not sufficient to uniquely identify a row. For example, in the following table, neither the StudentID nor the CourseID alone can uniquely identify a row, because a student might enroll mutiple courses, and a course can have multiple students. However, the combination of both columns can uniquely identify each enrollment record.\nStudentID CourseID EnrollmentDate 1 CS101 2024-01-01 1 MATH101 2024-01-02 2 CS101 2024-01-03 1NF: Student In the following Student table, there is no single field that can uniquely identify a row. Therefore, it is necessary to add a new field. such as StudentID, to ensure each row has a unique identifier. Additionally, the Address field may contain multiple values, such as unit number, street number, street name, suburb, city, state, country, and postcode. To comply with the First Normal Form (1NF), the Address firld must be divided into multiple separate columns, ensuring that each column contains only atomic values.\n--- title: Violation of 1NF - Student --- erDiagram STUDENT { string first_name string last_name date date_of_birth string address } --- title: Comply with 1NF - Student --- erDiagram STUDENT { number student_id PK string first_name string last_name date date_of_birth number unit_number number street_number string street_name string suburb string city string state string country string postcode } 1NF: Subject --- title: Violation of 1NF - Subject --- erDiagram SUBJECT { string subject_name string category string students_enrolled } --- title: Comply with 1NF - Subject --- erDiagram SUBJECT { number subject_id PK string subject_name string category string students_enrolled } 1NF: Teacher --- title: Violation of 1NF - Teacher --- erDiagram TEACHER { string first_name string last_name date date_of_birth string address string subject_taught } --- title: Comply with 1NF - Teacher --- erDiagram TEACHER { number teacher_id PK string first_name string last_name date date_of_birth number unit_number number street_number string street_name string suburb string city string state string country string postcode string subject_taught } 1NF: University --- title: Violation of 1NF - University --- erDiagram UNIVERSITY { string name string address } --- title: Comply with 1NF - University --- erDiagram UNIVERSITY { number university_id PK string name number unit_number number street_number string street_name string suburb string city string state string country string postcode } Second Normal Form The Second Normal Form (2NF) in database design is a level of normalization that builds upon the First Normal Form (1NF). A table is in 2NF if every non-key attribute is fully functionally dependent on the entire primary key, not just part of it, particularly in tables with composite primary keys (a key made up of two or more columns).\nRelationships Relationship in database design refers to the association between different entities (tables) in a database. It defines how data in one table is related to data in another table, enabling efficient organization and retrival of data. Relationships are established through a foreign key, which is a column in one table that references the primary key of another table. There are four main types of relationships: One-to-One (1:1), One-to-Many (1:N), Many-to-Many (N:M), and Self-Reference.\nIn a One to One relationship, each record in one table is related to exactly one record in another table. For example, consider a Person table and a Passport table, where each person has one unique passport, and each passport is associated with only one person. This type of relationship is relatively rare in real-world database design.\nThe One to Many relationship is the most common type in real-world database design. In a 1:N relationship, one record in a table can be linked to multiple records in another table. For example, in a Department table and an Employee table, one department can have many employees, but each employee blongs to exactly one department. This is a typical relational model for most business applications.\nThe Many-to-Many relationship is common but often requires an intermediary table to properly represent the association. In an N:M relationship, multiple records in one table can be asoociated with multiple records in another table. For instance, in a Student table and a Course table, a student can enroll in many courses, and each course can have many students enrolled. This relationship is typically handled by a joining table, such as Student_Course.\nIn a Self-Referencing relationship, a table is related to itself. In other words, a record in the table is associated with another record in the same table. For example, in an Employee table, each employee has a Manager, and that manager may also have a manager. This type of relationship is useful for representing hierarchical structures, such as organizational charts.\nIn database design, a foreign key is a column that references the primary key of another table. It is used to establish a relationship between two tables, ensuring referential integrity and maintaining consistent data across the database.\n2NF: Subject \u0026amp; Category In the following Subject table, the subject_name is dependent on the primary key subject_id, but the category is not fully dependent on the primary key, which violates 2NF. To resolve this issue, a new Category table should be created with two fields: category_id as the primary key and subject_id as a foreign key. The two tables have a One-to-Many relationship, where each category can have many subjects, while each subject bleongs to exactly one category.\n--- title: Violation of 2NF - Subject --- erDiagram SUBJECT { number subject_id PK string subject_name string category } --- title: Comply with 2NF - Subject --- erDiagram SUBJECT { number subject_id PK string subject_name number category_id FK } CATEGORY { number category_id PK string category_name } CATEGORY ||--|{ SUBJECT : \"\" 2NF: Student \u0026amp; Subject In the following Subject table, the subject_id and students_enrolled create a Many-to-Many relationship. However, relational databases should not represent Many-to-Many relationships directly in s single table. This is because a single table cannot handle multiple instances of related data (such as multiple students enrolled in multiple subjects) within a single field. To resolve this issue, a junction table is introduced. It breaks down the Many-to-Many relationship into two One-to-Many relationships, ensuring data integrity and normalization.\n--- title: Violation of 2NF - Subject --- erDiagram SUBJECT { number subject_id PK string subject_name string students_enrolled } subject_id subject_name students_name 1 Math Alice, Bob, Charlie 2 History David, Emily, Frank, Grace 3 Science Helen, Ian In the above table, the students_enrolled field violates First Normal Form (1NF), which requires each column to contain only atomic values. Additionally, this design leads to data redundancy. For example, if the student Alice enrolls in multiple courses such as Math, History, and Science. her name will be repeated in each row, causing unnecessary duplication of data.\nFurthermore, this design makes data manipulation more complex. For instance, when a student drops a course or a new student enrolls in a course, the list of students in the students_enrolled column must be manually updated, which is error-prone and inefficient.\n--- title: Comply with 2NF - Subject --- erDiagram SUBJECT { number subject_id PK string subject_name } STUDENT { number student_id PK string students_enrolled } ENROLLMENT { number subject_id FK number student_id FK } SUBJECT ||--|{ ENROLLMENT : \"has\" STUDENT ||--|{ ENROLLMENT : \"enrolled in\" Comply with 2NF: Real-World Example 2NF: Teacher --- title: Violation of 2NF - Teacher (subject_taught) --- erDiagram TEACHER { number teacher_id string first_name string last_name date date_of_birth string subject_taught } --- title: Comply with 2NF - Teacher --- erDiagram TEACHER { number teacher_id string first_name string last_name date date_of_birth } SUBJECT { number subject_id PK string subject_name number category_id FK number teacher_id FK } TEACHER ||--|{ SUBJECT : \"teaches\" 2NF: University --- title: Comply with 2NF - UNIVERSITY --- erDiagram UNIVERSITY { number university_id PK string name } SUBJECT { number subject_id PK string subject_name number category_id FK number teacher_id FK number university_id FK } UNIVERSITY ||--|{ SUBJECT : \"\" Third Normal From Third Normal Form (3NF) is a level of normalization that satisfies Second Normal Form (2NF) and eliminates transitive dependencies. In simpler terms, a non-key attribute in a table should not depend on another non-key attrubute. For example, if A $\\rightarrow$ B and B $\\rightarrow$ C, then A $\\rightarrow$ C, which means C should be moved to a separate table to avoid redundency. This process helps reduce data redundency and improves the efficiency of relational databases.\n3NF: Student In the following Student table, the non-key attributes (unit_number, street_number, street_name, suburb, city, state, country, and postcode) are not directly dependent on the primary key student_id; instead, they depend on the student\u0026rsquo;s address. This results in a transitive dependency, which violates 3NF. Furthermore, since multiple students may share the same address, these address attributes will be repeated for each student, leading to data redundency.\n--- title: Violation of 3NF - Student --- erDiagram STUDENT { number student_id PK string first_name string last_name date date_of_birth number unit_number number street_number string street_name string suburb string city string state string country string postcode } --- title: Comply with 3NF - Student --- erDiagram STUDENT { number student_id PK string first_name string last_name date date_of_birth number address_id FK } ADDRESS { number address_id PK number unit_number number street_number string street_name string suburb string city string state string country string postcode } STUDENT ||--|{ ADDRESS : \"\" 3NF: Teacher --- title: Comply with 3NF - Teacher --- erDiagram TEACHER { number teacher_id PK string first_name string last_name date date_of_birth number address_id FK } ADDRESS { number address_id PK number unit_number number street_number string street_name string suburb string city string state string country string postcode } TEACHER ||--|{ ADDRESS : \"\" 3NF: University --- title: Comply with 3NF - University --- erDiagram UNIVERSITY { number university_id PK string name number address_id FK } ADDRESS { number address_id PK number unit_number number street_number string street_name string suburb string city string state string country string postcode } UNIVERSITY ||--|{ ADDRESS : \"\" Design Considerations Determine Data Types \u0026amp; Precision Determining data types and precision in database design is crucial for ensuring optimal storage, performance, and accuracy of data. There are typically three steps to determine the apprpriate data type and precision for a field:\nIdentifying the nature of the field: Determine the type of data the field will store—whether it\u0026rsquo;s numeric, string, or data/time. For example, the student_id field might be of type INT, while the first_time field might of type CHAR or VARCHAR. Choose the smallest sufficient data type: Select the samllest data type that can accommodate the required values. For example, if a field\u0026rsquo;s values range from -128 to 127, use TINYINT instead of INT to optimize performance and storage efficiency. Set precision and scale for numeric values: For numeric fields, it\u0026rsquo;s important to define the precision (total number of digits) and scale (number of digits after the decimal point). For example, a price field should be set to DECIMAL(10,2), which allows for 10 digits in total, with 2 digits after the decimal point. Integrity Constraints Integrity Constraints in database design are rules that ensure the accuracy, consistency, and validity of data. There are several types of integrity constraints, each serving a specific purpose:\nEntity Integrity Entity Integrity ensures that each record in a table is unique and identifiable. This is achieved by setting a column in a table as a primary key. For example, the student_id field must be unique for each record in the Student table.\nCREATE TABLE Student ( student_id INT PRIMARY KEY, first_name VARCHAR(100), last_name VARCHAR(100) ); Referencial Integrity Referencial Integrity ensures that relationships between tables are maintained consistently. Foreign keys enforce this constraint by ensuring that a value in one table corresbonds to a valid value in another table. For example, the student_id field in the Enrollment table serves as a foreign key referencing the primary key student_id in the Student table.\nCREATE TABLE Enrollment ( enrollment_id INT PRIMARY KEY, student_id INT, course_id INT, FOREIGN KEY (student_id) REFERENCES Students(student_id) ); Domain Integrity Domain Integrity ensures that the data entered in a column matches the defined data type, format, and range. This is enforced using data types. default values. and check constraints. For example, the price field should only store positive values.\nCREATE TABLE Product ( product_id INT PRIMARY KEY, product_name VARCHAR(100), price DECIMAL(10, 2) CHECK (price \u0026gt; 0) ); User-Defined Integrity User-defined integrity enforces business rules specific to the application or domain. For instance, in the Enrollment table, the combination of student_id and course_id should be unique to prevent a student from enrolling in the same course more than once.\nCREATE TABLE Enrollment ( enrollment_id INT PRIMARY KEY, student_id INT, course_id INT, UNIQUE (student_id, course_id) ); Null Integrity Null integrity ensures that certain fields cannot store NULL values. This is enforced by defining the column with the NOT NULL constraint. For example, the student_id field in the Student table must not be NULL because it is used to identify each record.\nCREATE TABLE Student ( student_id INT PRIMARY KEY NOT NULL, first_name VARCHAR(100) NOT NULL, last_name VARCHAR(100) NOT NULL ); ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/database/database-design/1-database-design-notes/","summary":"Introduction to Databases A database is a collection of data that is stored, managed, and accessed electronically. It typically contains one or more tables, which resemble Excel or Google sheets, with data organized into rows and columns. As the number of tables grows, managing the database can become complex, making it essential to design a scalable and maintainable strucutre.\nDatabases can be broadly categorized into two types: Relational database, primarily used for real-time data updates and transactions, and data warehouse, optimized for data analysis and reporting purposes.","title":"Database Design Notes"},{"content":"1. Solid Principle 1.1 Single Responsibility Principle A class should have only one reason to change, meaning each class should focus on a single functionality or responsibility.\nSHOW CODE Single Responsibility Principle import java.io.IOException; import java.util.*; import java.util.regex.*; import com.fasterxml.jackson.databind.ObjectMapper; /** * 1. User class is only used to represent entity. * 2. UserValidator class is solely responsible for validating user objects. * 3. Store class is only used to manage user objects storage. * 4. UserPersistenceService class is dedicated to save the user data. * 5. UserController is solely used to handle incoming requests (in this case, creating users form JSON input). */ /* \u0026lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.18.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; */ /** * Represents a user with basic details. * User class is only used to represent entity. */ class User { private String name; private String email; private String address; public User() {} public User(String name, String email, String address) { this.name = name; this.email = email; this.address = address; } // Getters and setters public String getName() { return name; } public void setName(String name) { this.name = name; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } @Override public String toString() { return \"User [name=\" + name + \", email=\" + email + \", address=\" + address + \"]\"; } } /** * Handles incoming JSON requests that work on User. * UserController is solely used to handle incoming requests (in this case, creating users form JSON input). */ class UserController { private final UserPersistenceService persistenceService = new UserPersistenceService(); public String createUser(String userJson) throws IOException { ObjectMapper mapper = new ObjectMapper(); User user = mapper.readValue(userJson, User.class); UserValidator validator = new UserValidator(); if (!validator.validateUser(user)) { return \"ERROR\"; } persistenceService.saveUser(user); return \"SUCCESS\"; } } /** * Handles persistence of User objects. * UserPersistenceService class is dedicated to save the user data. */ class UserPersistenceService { private final Store store = new Store(); public void saveUser(User user) { store.store(user); } } /** * Validates User data. * UserValidator class is solely responsible for validating user objects. */ class UserValidator { public boolean validateUser(User user) { if (!isPresent(user.getName()) || !isValidAlphaNumeric(user.getName())) { return false; } user.setName(user.getName().trim()); user.setEmail(user.getEmail().trim()); return isValidEmail(user.getEmail()); } private boolean isPresent(String value) { return value != null \u0026\u0026 value.trim().length() \u003e 0; } private boolean isValidAlphaNumeric(String value) { Pattern pattern = Pattern.compile(\"[^A-Za-z0-9]\"); Matcher matcher = pattern.matcher(value); return !matcher.find(); } private boolean isValidEmail(String value) { Pattern pattern = Pattern.compile(\"^[\\\\w-\\\\.]+@[\\\\w-]+(\\\\.[\\\\w-]+)+$\"); Matcher matcher = pattern.matcher(value); return matcher.find(); } } /** * Stores User data in memory. * Store class is only used to manage user objects storage. */ class Store { private static final Map\u0026lt;String, User\u0026gt; STORAGE = new HashMap\u0026lt;\u0026gt;(); public void store(User user) { synchronized (STORAGE) { STORAGE.put(user.getName(), user); } } public User getUser(String name) { synchronized (STORAGE) { return STORAGE.get(name); } } } /** * Main class for demonstrating the Single Responsibility Principle. */ public class Main { private static final String VALID_USER_JSON = \"{\\\"name\\\": \\\"Signal\\\", \\\"email\\\": \\\"signalyu999@gmail.com\\\", \\\"address\\\":\\\"999 Sugar lane\\\"}\"; private static final String INVALID_USER_JSON = \"{\\\"name\\\": \\\"Sam\\\", \\\"email\\\": \\\"sam@email\\\", \\\"address\\\":\\\"111 Sugar lane\\\"}\"; public static void main(String[] args) throws IOException { UserController controller = new UserController(); String response = controller.createUser(VALID_USER_JSON); System.out.println(\"Valid JSON response: \" + response); response = controller.createUser(INVALID_USER_JSON); System.out.println(\"Invalid JSON response: \" + response); } } Each class in the above code strictly adheres to the Single Responsibility Principle by focusing on a specific responsibility:\nUser for representing the user entity UserController for request handling UserPersistenceService for data persistence UserValidator for user data validation Store for managing in-memory data storage --- title: Single Responsibility Principle - Class Diagram --- classDiagram class User { - String name - String email - String address + String toString() } class Store { + void store(User user) + User getUser(String name) } class UserPersistenceService { + void saveUser(User user) } class UserValidator { - boolean isPresent(String value) - boolean isValidAlphaNumeric(String value) - boolean isValidEmail(String value) + boolean validateUser(User user) } class UserController { + String createUser(String userJson) } class Main { + void main(String[] args) } User --* Store Store --* UserPersistenceService UserPersistenceService --* UserController UserController --\u003e UserValidator : create Main --\u003e UserController : create 1.2 Open-Closed Principle A software entity (class, module, function, etc.) should be open for extension but closed for modification.\n点击查看代码 Java import java.time.LocalDateTime; import java.util.*; // Abstract base class, closed for modification but open for extension abstract class Subscriber { protected Long subscriberId; protected String address; protected Long phoneNumber; protected int baseRate; // Getter and Setter methods public Long getSubscriberId() { return subscriberId; } public void setSubscriberId(Long subscriberId) { this.subscriberId = subscriberId; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } public Long getPhoneNumber() { return phoneNumber; } public void setPhoneNumber(Long phoneNumber) { this.phoneNumber = phoneNumber; } public int getBaseRate() { return baseRate; } public void setBaseRate(int baseRate) { this.baseRate = baseRate; } // Abstract method to calculate the bill; implementation is defined in subclasses public abstract double calculateBill(); } // PhoneSubscriber class extends Subscriber, calculates the phone bill class PhoneSubscriber extends Subscriber { @Override public double calculateBill() { List\u0026lt;CallHistory.Call\u0026gt; calls = CallHistory.getCurrentCalls(subscriberId); long totalDuration = calls.stream().mapToLong(CallHistory.Call::getDuration).sum(); return (totalDuration * baseRate) / 100.0; } } // ISPSubscriber class extends Subscriber, calculates the internet bill class ISPSubscriber extends Subscriber { private long freeUsage; // Free usage limit in data units @Override public double calculateBill() { List\u0026lt;InternetSessionHistory.InternetSession\u0026gt; sessions = InternetSessionHistory.getCurrentSessions(subscriberId); long totalData = sessions.stream().mapToLong(InternetSessionHistory.InternetSession::getDataUsed).sum(); long chargeableData = totalData - freeUsage; return chargeableData \u003c= 0 ? 0 : (chargeableData * baseRate) / 100.0; } public long getFreeUsage() { return freeUsage; } public void setFreeUsage(long freeUsage) { this.freeUsage = freeUsage; } } // InternetSessionHistory class to manage internet usage records class InternetSessionHistory { public static class InternetSession { private final LocalDateTime begin; private final Long subscriberId; private final Long dataUsed; public InternetSession(Long subscriberId, LocalDateTime begin, long dataUsed) { this.subscriberId = subscriberId; this.begin = begin; this.dataUsed = dataUsed; } public LocalDateTime getBegin() { return begin; } public long getDataUsed() { return dataUsed; } public Long getSubscriberId() { return subscriberId; } } private static final Map\u0026lt;Long, List\u0026lt;InternetSession\u0026gt;\u0026gt; SESSIONS = new HashMap\u0026lt;\u0026gt;(); // Retrieves the current sessions for a subscriber, returns an empty list if none found public static synchronized List\u0026lt;InternetSession\u0026gt; getCurrentSessions(Long subscriberId) { return SESSIONS.getOrDefault(subscriberId, Collections.emptyList()); } // Adds a new internet session record for a subscriber public static synchronized void addSession(Long subscriberId, LocalDateTime begin, long dataUsed) { SESSIONS.computeIfAbsent(subscriberId, k -\u003e new LinkedList\u0026lt;\u0026gt;()).add(new InternetSession(subscriberId, begin, dataUsed)); } } // CallHistory class to manage call records class CallHistory { public static class Call { private final LocalDateTime begin; private final long duration; private final Long subscriberId; public Call(Long subscriberId, LocalDateTime begin, long duration) { this.subscriberId = subscriberId; this.begin = begin; this.duration = duration; } public LocalDateTime getBegin() { return begin; } public long getDuration() { return duration; } public Long getSubscriberId() { return subscriberId; } } private static final Map\u0026lt;Long, List\u0026lt;Call\u0026gt; CALLS = new HashMap\u0026lt;\u0026gt;(); // Retrieves the current calls for a subscriber, returns an empty list if none found public static synchronized List\u0026lt;Call\u0026gt; getCurrentCalls(Long subscriberId) { return CALLS.getOrDefault(subscriberId, Collections.emptyList()); } // Adds a new call record for a subscriber public static synchronized void addSession(Long subscriberId, LocalDateTime begin, long duration) { CALLS.computeIfAbsent(subscriberId, k -\u003e new LinkedList\u0026lt;\u0026gt;()).add(new Call(subscriberId, begin, duration)); } } public class Main { public static void main(String[] args) { // Initialize PhoneSubscriber and ISPSubscriber with sample data PhoneSubscriber phoneSubscriber = new PhoneSubscriber(); phoneSubscriber.setSubscriberId(1L); phoneSubscriber.setBaseRate(10); ISPSubscriber ispSubscriber = new ISPSubscriber(); ispSubscriber.setSubscriberId(2L); ispSubscriber.setBaseRate(5); ispSubscriber.setFreeUsage(1000); // Add call records for PhoneSubscriber CallHistory.addSession(1L, LocalDateTime.now().minusMinutes(5), 300); // 300 seconds call CallHistory.addSession(1L, LocalDateTime.now().minusMinutes(10), 600); // 600 seconds call // Calculate and print the phone subscriber's bill double phoneBill = phoneSubscriber.calculateBill(); System.out.println(\"Phone Subscriber's Bill: \" + phoneBill); // Add internet session records for ISPSubscriber InternetSessionHistory.addSession(2L, LocalDateTime.now().minusHours(1), 500); // 500 data units InternetSessionHistory.addSession(2L, LocalDateTime.now().minusHours(2), 800); // 800 data units // Calculate and print the ISP subscriber's bill double ispBill = ispSubscriber.calculateBill(); System.out.println(\"ISP Subscriber's Bill: \" + ispBill); } } The above code demonstrates the Open/Closed Principle (OCP) by separating the base Subscriber class from its specific implementations, PhoneSubscriber and ISPSubscriber, allowing for new functionalities to be added without modifying the existing code structure.\nClosed for Modification: The Subscriber base class is closed for modification. It defines common properties (like subscriberId, address, and baseRate) and an abstract calculateBill method that acts as a placeholder for billing logic. This base class remains unchanged even as new types of subscribers or billing strategies are introduced.\nOpen for Extension: The calculateBill method in Subscriber can be extended by subclasses, like PhoneSubscriber and ISPSubscriber, to implement custom billing calculations. Each subclass overrides calculateBill according to its unique billing requirements (e.g., PhoneSubscriber calculates based on call duration, while ISPSubscriber uses data usage with free data allowances). This enables additional subscriber types to be created without altering the base class or existing subclasses.\nFlexible to New Requirements: By following OCP, any new type of subscriber can be added—such as PremiumSubscriber or CorporateSubscriber—with its own billing logic without affecting the existing structure. This ensures that the core system remains stable, extensible, and easily maintainable as new features or subscriber types are introduced.\n--- title: Open Closed Principle - Class Diagram --- classDiagram class Subscriber { +Long subscriberId +String address +Long phoneNumber +int baseRate +double calculateBill() } class PhoneSubscriber { +double calculateBill() } class ISPSubscriber { +double calculateBill() +long freeUsage +void setFreeUsage(long freeUsage) +long getFreeUsage() } Subscriber \u003c|-- PhoneSubscriber Subscriber \u003c|-- ISPSubscriber 1.3 Liskov Substitution Principle Objects of a superclass should be replaceable with objects of a subclass without altering the correctness of the program.\nSHOW CODE: Violation of LSP Violation of LSP package dev.signalyu.solid.lsp; class Rectangle { private int width; private int height; public Rectangle(int width, int height) { this.width = width; this.height = height; } public int getWidth() { return width; } public void setWidth(int width) { this.width = width; } public int getHeight() { return height; } public void setHeight(int height) { this.height = height; } public int computeArea() { return width * height; } } class Square extends Rectangle { public Square(int side) { super(side, side); } @Override public void setWidth(int width) { setSide(width); } @Override public void setHeight(int height) { setSide(height); } public void setSide(int side) { super.setWidth(side); super.setHeight(side); } } public class Main { public static void main(String[] args) { Rectangle rectangle = new Rectangle(10, 20); System.out.println(rectangle.computeArea()); // 200 = 10 * 20 Square square = new Square(10); System.out.println(square.computeArea()); // 100 = 10 * 10 useRectangle(rectangle); System.out.println(rectangle.computeArea()); // 600 = 20 * 30 useRectangle(square); // Violates Liskov Substitution Principle System.out.println(square.computeArea()); // 900 = 30 * 30 } private static void useRectangle(Rectangle rectangle) { rectangle.setHeight(20); rectangle.setWidth(30); assert rectangle.getHeight() == 20 : \"Height Not equal to 20\"; assert rectangle.getWidth() == 30 : \"Width Not equal to 30\"; } } In the above code, the useRectangle method assumes that it can independently set the width and height of a Rectangle. However, when a Square (a subclass of Rectangle) object is passed to it, unexpected behavior will occur.\nSHOW CODE: After Refactoring After Refactoring package dev.signalyu.solid.lsp; interface Shape { int computeArea(); } class Rectangle implements Shape { private int width; private int height; public Rectangle(int width, int height) { this.width = width; this.height = height; } public int getWidth() { return width; } public void setWidth(int width) { this.width = width; } public int getHeight() { return height; } public void setHeight(int height) { this.height = height; } @Override public int computeArea() { return width * height; } } class Square implements Shape { private int side; public Square(int side) { this.side = side; } public void setSide(int side) { this.side = side; } public int getSide() { return side; } @Override public int computeArea() { return side * side; } } public class Main { public static void main(String[] args) { Rectangle rectangle = new Rectangle(10, 20); System.out.println(rectangle.computeArea()); Square square = new Square(10); System.out.println(square.computeArea()); useRectangle(rectangle); } private static void useRectangle(Rectangle rectangle) { rectangle.setHeight(20); rectangle.setWidth(30); assert rectangle.getHeight() == 20 : \"Height Not equal to 20\"; assert rectangle.getWidth() == 30 : \"Width Not equal to 30\"; } } After refactoring, the useRectangle method is now dedicated exclusively to the Rectangle class.\n1.4 Interface Segregation Principle No client should be forced to depend on methods it does not use.\nSHOW CODE: Violation of ISP Violation of ISP package dev.signalyu.solid.isp; import java.time.LocalDateTime; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.stream.Collectors; // Abstract Entity Class abstract class Entity { private Long id; public Long getId() { return id; } public void setId(Long id) { this.id = id; } } // Order Entity class Order extends Entity { private LocalDateTime orderPlacedOn; private double totalValue; public LocalDateTime getOrderPlacedOn() { return orderPlacedOn; } public void setOrderPlacedOn(LocalDateTime orderPlacedOn) { this.orderPlacedOn = orderPlacedOn; } public double getTotalValue() { return totalValue; } public void setTotalValue(double totalValue) { this.totalValue = totalValue; } } // User Entity class User extends Entity { private String name; private LocalDateTime lastLogin; public String getName() { return name; } public void setName(String name) { this.name = name; } public LocalDateTime getLastLogin() { return lastLogin; } public void setLastLogin(LocalDateTime lastLogin) { this.lastLogin = lastLogin; } } // Persistence Service Interface interface PersistenceService\u0026lt;T extends Entity\u0026gt; { void save(T entity); void delete(T entity); T findById(Long id); /** * ISP VIOLATION!!! * * Order entity doesn't have a name property and hence doesn't * need to implement the findByName method */ List findByName(String name); } // User Persistence Service class UserPersistenceService implements PersistenceService\u0026lt;User\u0026gt; { private static final Map\u0026lt;Long, User\u0026gt; USERS = new HashMap\u0026lt;\u0026gt;(); @Override public void save(User entity) { synchronized (USERS) { USERS.put(entity.getId(), entity); } } @Override public void delete(User entity) { synchronized (USERS) { USERS.remove(entity.getId()); } } @Override public User findById(Long id) { synchronized (USERS) { return USERS.get(id); } } @Override public List findByName(String name) { synchronized (USERS) { return USERS.values().stream() .filter(u -\u003e u.getName().equalsIgnoreCase(name)) .collect(Collectors.toList()); } } } The above code violates the Interface Segregation Principle because the PersistenceService interface defines methods that are not applicable to all entities. For instance, the Order entity does not have a name property and therefore does not require the findByName method.\nSHOW CODE: After Refactoring After Refactoring import java.time.LocalDateTime; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.stream.Collectors; // Abstract Entity Class abstract class Entity { private Long id; public Long getId() { return id; } public void setId(Long id) { this.id = id; } } // User Entity class User extends Entity { private String name; private LocalDateTime lastLogin; public String getName() { return name; } public void setName(String name) { this.name = name; } public LocalDateTime getLastLogin() { return lastLogin; } public void setLastLogin(LocalDateTime lastLogin) { this.lastLogin = lastLogin; } } // Order Entity class Order extends Entity { private LocalDateTime orderPlacedOn; private double totalValue; public LocalDateTime getOrderPlacedOn() { return orderPlacedOn; } public void setOrderPlacedOn(LocalDateTime orderPlacedOn) { this.orderPlacedOn = orderPlacedOn; } public double getTotalValue() { return totalValue; } public void setTotalValue(double totalValue) { this.totalValue = totalValue; } } // Persistence Service Interface interface PersistenceService\u0026lt;T extends Entity\u0026gt; { void save(T entity); void delete(T entity); T findById(Long id); } // Order Persistence Service class OrderPersistenceService implements PersistenceService\u0026lt;Order\u0026gt; { private static final Map\u0026lt;Long, Order\u0026gt; ORDERS = new HashMap\u0026lt;\u0026gt;(); @Override public void save(Order entity) { synchronized (ORDERS) { ORDERS.put(entity.getId(), entity); } } @Override public void delete(Order entity) { synchronized (ORDERS) { ORDERS.remove(entity.getId()); } } @Override public Order findById(Long id) { synchronized (ORDERS) { return ORDERS.get(id); } } } // User Persistence Service class UserPersistenceService implements PersistenceService\u0026lt;User\u0026gt; { private static final Map\u0026lt;Long, User\u0026gt; USERS = new HashMap\u0026lt;\u0026gt;(); @Override public void save(User entity) { synchronized (USERS) { USERS.put(entity.getId(), entity); } } @Override public void delete(User entity) { synchronized (USERS) { USERS.remove(entity.getId()); } } @Override public User findById(Long id) { synchronized (USERS) { return USERS.get(id); } } public List findByName(String name) { synchronized (USERS) { return USERS.values().stream() .filter(u -\u003e u.getName().equalsIgnoreCase(name)) .collect(Collectors.toList()); } } } After refactoring, the PersistenceService interface includes only the generic methods (save, findById, and delete) that are applicable to all entities.\n1.5 Dependency Inversion Principle High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions\nSHOW CODE: Violation of DIP Violation of DIP package dev.signalyu.solid.dip; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.ObjectMapper; import java.io.FileWriter; import java.io.IOException; import java.io.PrintWriter; import java.time.LocalDateTime; import java.time.ZoneId; // Common interface for classes formatting Message object interface Formatter { String format(Message message) throws FormatException; } // Thrown by formatter class FormatException extends IOException { public FormatException(Exception cause) { super(cause); } } // Formats message to JSON format class JSONFormatter implements Formatter { public String format(Message message) throws FormatException { ObjectMapper mapper = new ObjectMapper(); try { return mapper.writeValueAsString(message); } catch (JsonProcessingException e) { e.printStackTrace(); throw new FormatException(e); } } } // Message class with content and timestamp class Message { private String msg; private LocalDateTime timestamp; public Message(String msg) { this.msg = msg; this.timestamp = LocalDateTime.now(ZoneId.of(\"UTC\")); } public String getMsg() { return msg; } public LocalDateTime getTimestamp() { return timestamp; } } // Writes message to a file class MessagePrinter { /** * MessagePrinter directly instantiates the JSONFormatter object inside the * writeMessage method, which violates the Dependency Inversion Principle. */ public void writeMessage(Message msg, String fileName) throws IOException { Formatter formatter = new JSONFormatter(); // creates formatter try (PrintWriter writer = new PrintWriter(new FileWriter(fileName))) { // creates print writer writer.println(formatter.format(msg)); // formats and writes message writer.flush(); } } } // Main class public class Main { public static void main(String[] args) throws IOException { Message msg = new Message(\"This is a message again\"); MessagePrinter printer = new MessagePrinter(); printer.writeMessage(msg, \"test_msg.txt\"); } } In the above code, the MessagePrinter class directly instanitiates the JSONFormatter object inside the writeMessage method, which violates the Dependency Inversion Principle. This tight coupling means that if a new formatter, such as TextFormatter, needs to be added, the writeMessage method must be modified. This violates the Open-Closed Principle, which states that classes should be open for extension but closed for modification. According to the Dependency Inversion Principle, the high-level module (MessagePrinter) should not depend on the low-level module (JSONFormatter). Instead, both should depend on abstractions, such as the Formatter interface.\nSHOW CODE: After Refactoring After Refactoring import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule; import java.io.IOException; import java.io.PrintWriter; import java.time.LocalDateTime; import java.time.ZoneId; // Common interface for classes formatting Message objects interface Formatter { String format(Message message) throws FormatException; } // Custom exception thrown by Formatter class FormatException extends IOException { public FormatException(Exception cause) { super(cause); } } // Formats a Message object to JSON format class JSONFormatter implements Formatter { public String format(Message message) throws FormatException { ObjectMapper mapper = new ObjectMapper(); mapper.registerModule(new JavaTimeModule()); try { return mapper.writeValueAsString(message); } catch (JsonProcessingException e) { e.printStackTrace(); throw new FormatException(e); } } } // Represents a message with content and a timestamp class Message { private String msg; private LocalDateTime timestamp; public Message(String msg) { this.msg = msg; this.timestamp = LocalDateTime.now(ZoneId.of(\"UTC\")); } public String getMsg() { return msg; } public LocalDateTime getTimestamp() { return timestamp; } } // Responsible for writing a formatted Message to a file or output stream class MessagePrinter { public void writeMessage(Message msg, Formatter formatter, PrintWriter writer) throws IOException { writer.println(formatter.format(msg)); // Formats and writes the message writer.flush(); } } // Main class demonstrating functionality public class Main { public static void main(String[] args) throws IOException { Message msg = new Message(\"This is a message again\"); MessagePrinter printer = new MessagePrinter(); try (PrintWriter writer = new PrintWriter(System.out)) { // Writing to console output printer.writeMessage(msg, new JSONFormatter(), writer); } } } After refactoring, the MessagePrinter class now depends on the Formatter abstraction rather than its concrete implementations. This makes it easier to replace JSONFormatter with any other implementation of Formatter without modifying the existing code, adhering to the Open-Closed Principle.\n2. Creational Design Patterns Creational Design Patterns focus on the process of object creation, ensuring flexibility and promoting code reuse.\n2.1 Builder The Builder Design Pattern is a creational design pattern that enables the step-by-step construction of complex objects. It separates the construction process form the object\u0026rsquo;s representation, allowing the same process to produce different representations. This pattern is often used to build complex or immutable obejcts.\n❔❔❔ Same Construction Process Creates Different Representations:\nConsider building a meal in a fast-food restaurant, where the construction steps include:\nAdd a main dish (e.g., burger, sandwich, or pizza). Add a side dish (e.g., fries, salad, or breadsticks). Add a drink (e.g., soda, coffee, or juice). The construction process remains consistent: (main dish + side dish + drink). However, the final representation varies based on the choices:\nVeggie Meal: Sandwich + Salad + Juice. Classic Meal: Burger + Fries + Soda. Kids\u0026rsquo; Meal: Mini Pizza + Fries + Milk. --- title: URL Diagram of Builder Pattern --- classDiagram class Builder { +buildPartA() +buildPartB() +getResult() } class ConcreteBuilder1 { +buildPartA() +buildPartB() +getResult() } class ConcreteBuilder2 { +buildPartA() +buildPartB() +getResult() } class Director { +construct(builder: Builder) } class Product { +PartA +PartB } Builder \u003c|-- ConcreteBuilder1 Builder \u003c|-- ConcreteBuilder2 Director --\u003e Builder : uses ConcreteBuilder1 --\u003e Product : creates ConcreteBuilder2 --\u003e Product : creates ℹ️ In a context of design patterns, UML (Unified Modeling Language) is commonly used to represent the structure and behavior of the patterns in a clear and simple manner.\nSHOW CODE: Director Java import java.time.LocalDate; import java.time.Period; import java.util.Objects; // Address class class Address { private String houseNumber; private String street; private String city; private String zipcode; private String state; public Address(String houseNumber, String street, String city, String state, String zipcode) { this.houseNumber = houseNumber; this.street = street; this.city = city; this.state = state; this.zipcode = zipcode; } public String getFullAddress() { return houseNumber + \", \" + street + \"\\n\" + city + \"\\n\" + state + \" \" + zipcode; } } // User class class User { private String firstName; private String lastName; private LocalDate birthday; private Address address; public User(String firstName, String lastName, LocalDate birthday, Address address) { this.firstName = firstName; this.lastName = lastName; this.birthday = birthday; this.address = address; } public String getFirstName() { return firstName; } public String getLastName() { return lastName; } public LocalDate getBirthday() { return birthday; } public Address getAddress() { return address; } } // UserDTO interface interface UserDTO { String getName(); String getAddress(); String getAge(); } // UserWebDTO implementation class UserWebDTO implements UserDTO { private final String name; private final String address; private final String age; public UserWebDTO(String name, String address, String age) { this.name = name; this.address = address; this.age = age; } @Override public String getName() { return name; } @Override public String getAddress() { return address; } @Override public String getAge() { return age; } @Override public String toString() { return \"Name: \" + name + \"\\nAge: \" + age + \"\\nAddress:\\n\" + address; } } // UserDTOBuilder interface interface UserDTOBuilder { UserDTOBuilder withFirstName(String firstName); UserDTOBuilder withLastName(String lastName); UserDTOBuilder withBirthday(LocalDate birthday); UserDTOBuilder withAddress(Address address); UserDTO build(); } // Concrete builder class UserWebDTOBuilder implements UserDTOBuilder { private String firstName; private String lastName; private String age; private String address; @Override public UserDTOBuilder withFirstName(String firstName) { this.firstName = firstName; return this; } @Override public UserDTOBuilder withLastName(String lastName) { this.lastName = lastName; return this; } @Override public UserDTOBuilder withBirthday(LocalDate birthday) { if (Objects.nonNull(birthday)) { this.age = String.valueOf(Period.between(birthday, LocalDate.now()).getYears()); } return this; } @Override public UserDTOBuilder withAddress(Address address) { if (Objects.nonNull(address)) { this.address = address.getFullAddress(); } return this; } @Override public UserDTO build() { return new UserWebDTO(firstName + \" \" + lastName, address, age); } } // Client code (Director) public class Client { public static void main(String[] args) { User user = createUser(); UserDTOBuilder builder = new UserWebDTOBuilder(); UserDTO userDTO = buildUserDTO(builder, user); System.out.println(userDTO); } private static UserDTO buildUserDTO(UserDTOBuilder builder, User user) { return builder.withFirstName(user.getFirstName()) .withLastName(user.getLastName()) .withBirthday(user.getBirthday()) .withAddress(user.getAddress()) .build(); } private static User createUser() { Address address = new Address(\"100\", \"State Street\", \"Pawnee\", \"Indiana\", \"47998\"); return new User(\"Ron\", \"Swanson\", LocalDate.of(1960, 5, 6), address); } } SHOW CODE: Inner Builder Java import java.time.LocalDate; import java.time.Period; // Address class with Builder class Address { private final String houseNumber; private final String street; private final String city; private final String zipcode; private final String state; private Address(Builder builder) { this.houseNumber = builder.houseNumber; this.street = builder.street; this.city = builder.city; this.zipcode = builder.zipcode; this.state = builder.state; } public String getFullAddress() { return houseNumber + \", \" + street + \"\\n\" + city + \"\\n\" + state + \" \" + zipcode; } public static class Builder { private String houseNumber; private String street; private String city; private String zipcode; private String state; public Builder setHouseNumber(String houseNumber) { this.houseNumber = houseNumber; return this; } public Builder setStreet(String street) { this.street = street; return this; } public Builder setCity(String city) { this.city = city; return this; } public Builder setZipcode(String zipcode) { this.zipcode = zipcode; return this; } public Builder setState(String state) { this.state = state; return this; } public Address build() { return new Address(this); } } } // User class with Builder class User { private final String firstName; private final String lastName; private final LocalDate birthday; private final Address address; private User(Builder builder) { this.firstName = builder.firstName; this.lastName = builder.lastName; this.birthday = builder.birthday; this.address = builder.address; } public String getFirstName() { return firstName; } public String getLastName() { return lastName; } public LocalDate getBirthday() { return birthday; } public Address getAddress() { return address; } public static class Builder { private String firstName; private String lastName; private LocalDate birthday; private Address address; public Builder setFirstName(String firstName) { this.firstName = firstName; return this; } public Builder setLastName(String lastName) { this.lastName = lastName; return this; } public Builder setBirthday(LocalDate birthday) { this.birthday = birthday; return this; } public Builder setAddress(Address address) { this.address = address; return this; } public User build() { return new User(this); } } } // UserDTO interface interface UserDTO { String getName(); String getAddress(); String getAge(); } // UserWebDTO implementation class UserWebDTO implements UserDTO { private final String name; private final String address; private final String age; private UserWebDTO(Builder builder) { this.name = builder.name; this.address = builder.address; this.age = builder.age; } @Override public String getName() { return name; } @Override public String getAddress() { return address; } @Override public String getAge() { return age; } @Override public String toString() { return \"Name: \" + name + \"\\nAge: \" + age + \"\\nAddress:\\n\" + address; } public static class Builder { private String name; private String address; private String age; public Builder setName(String name) { this.name = name; return this; } public Builder setAddress(String address) { this.address = address; return this; } public Builder setAge(String age) { this.age = age; return this; } public UserWebDTO build() { return new UserWebDTO(this); } } } // Client code public class Client { public static void main(String[] args) { Address address = new Address.Builder() .setHouseNumber(\"100\") .setStreet(\"State Street\") .setCity(\"Pawnee\") .setState(\"Indiana\") .setZipcode(\"47998\") .build(); User user = new User.Builder() .setFirstName(\"Ron\") .setLastName(\"Swanson\") .setBirthday(LocalDate.of(1960, 5, 6)) .setAddress(address) .build(); UserWebDTO userDTO = new UserWebDTO.Builder() .setName(user.getFirstName() + \" \" + user.getLastName()) .setAddress(user.getAddress().getFullAddress()) .setAge(String.valueOf(Period.between(user.getBirthday(), LocalDate.now()).getYears())) .build(); System.out.println(userDTO); } } Summary Why builder pattern is capable of creating immutable objects?\nImplementing the builder as a static inner class facilitates the creation of immutable objects. The builder class has provileged access to the enclosing class\u0026rsquo;s internal state during the construction process. However, once the final object is built, it does not expose any setters or methods that modify its state, ensuring immutability.\nThe Director in the Builder Design Pattern is responsible for the construction process but is often not implemented as a standalone class. Instead, its responsibilities are typically handled by the client code or the consumer that requires the constructed object. This approach avoids the need for a separate director class, especially when the construction logic is simple or tailored to the client\u0026rsquo;s specific requirements.\nSHOW CODE: Without a Director Java UserDTO userDTO = new UserWebDTOBuilder() .withFirstName(\"John\") .withLastName(\"Doe\") .withBirthday(LocalDate.of(1990, 1, 1)) .withAddress(new Address(\"123\", \"Main St\", \"City\", \"State\", \"12345\")) .build(); SHOW CODE: With a Director Java public class Director { public UserDTO constructUser(UserDTOBuilder builder) { return builder.withFirstName(\"John\") .withLastName(\"Doe\") .withBirthday(LocalDate.of(1990, 1, 1)) .withAddress(new Address(\"123\", \"Main St\", \"City\", \"State\", \"12345\")) .build(); } } If a Product in the Builder Design Pattern is not part of an inheritance hierarchy, creating an abstract builder is unnecessary. The abstract builder is typically used to define method for mutiple types of builders. When there is only one type of product to construct, a concrete builder alone is sufficient to meet the requirements.\n2.2 Simple Factory The Simple Factory design pattern is a creational design pattern that delegates the responsibility of creating instances of different classes to a factory class, typically using a static method based on input parameters. This pattern centralizes object creation, simplifying the client code. However, it can violate the Open-Closed Principle (OCP), because adding a new product type requires modifying the factory class itself. This makes the code less flexible and harder to extend without altering existing source code.\nSHOW CODE Java import java.time.LocalDateTime; import java.time.LocalDate; // Abstract Post class public abstract class Post { private Long id; private String title; private String content; private LocalDateTime createdOn; private LocalDateTime publishedOn; public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } public LocalDateTime getCreatedOn() { return createdOn; } public void setCreatedOn(LocalDateTime createdOn) { this.createdOn = createdOn; } public LocalDateTime getPublishedOn() { return publishedOn; } public void setPublishedOn(LocalDateTime publishedOn) { this.publishedOn = publishedOn; } } // BlogPost class extends Post public class BlogPost extends Post { private String author; private String[] tags; public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } public String[] getTags() { return tags; } public void setTags(String[] tags) { this.tags = tags; } } // NewsPost class extends Post public class NewsPost extends Post { private String headline; private LocalDate newsTime; public String getHeadline() { return headline; } public void setHeadline(String headline) { this.headline = headline; } public LocalDate getNewsTime() { return newsTime; } public void setNewsTime(LocalDate newsTime) { this.newsTime = newsTime; } } // ProductPost class extends Post public class ProductPost extends Post { private String imageUrl; private String name; public String getImageUrl() { return imageUrl; } public void setImageUrl(String imageUrl) { this.imageUrl = imageUrl; } public String getName() { return name; } public void setName(String name) { this.name = name; } } // PostFactory class to create different types of posts public class PostFactory { public static Post createPost(String type) { switch (type) { case \"blog\": return new BlogPost(); case \"news\": return new NewsPost(); case \"product\": return new ProductPost(); default: throw new IllegalArgumentException(\"Post type is unknown\"); } } } // Client class to demonstrate the usage of Simple Factory public class Client { public static void main(String[] args) { Post post = PostFactory.createPost(\"news\"); System.out.println(post.getClass().getSimpleName()); // Prints the type of the created post (NewsPost) } } classDiagram direction RL class Post { - Long id - String title - String content - LocalDateTime createdOn - LocalDateTime publishedOn + getId() + setId(Long) + getTitle() + setTitle(String) + getContent() + setContent(String) + getCreatedOn() + setCreatedOn(LocalDateTime) + getPublishedOn() + setPublishedOn(LocalDateTime) } class BlogPost { - String author - String[] tags + getAuthor() + setAuthor(String) + getTags() + setTags(String[]) } class NewsPost { - String headline - LocalDate newsTime + getHeadline() + setHeadline(String) + getNewsTime() + setNewsTime(LocalDate) } class ProductPost { - String imageUrl - String name + getImageUrl() + setImageUrl(String) + getName() + setName(String) } class PostFactory { + createPost(String) } Post \u003c|-- BlogPost Post \u003c|-- NewsPost Post \u003c|-- ProductPost PostFactory --|\u003e BlogPost : creates PostFactory --|\u003e NewsPost : creates PostFactory --|\u003e ProductPost : creates The above code violates the Open-Closed Principle because when adding a new post type, such as EventPost, to the factory, the code must be modified by adding a new case statement, like the following:\ncase \u0026#34;event\u0026#34;: return new EventPost(); This approach breaks the OCP, which dictates that entities should be open for extension but closed for modification.\n2.3 Factory Method The Factory Method design pattern is a creational pattern that provides a method for creating objects in a superclass, while allowing subclasses to determine the type of object that will be created. This approach delegates the object creation process to the subclasses, enabling them to instantiate specific classes without the superclass needing to know the exact class being instantiated.\nSHOW CODE Java import java.util.*; /** * Abstract class representing a message, which is the \"product\". * Subclasses will provide specific content types. */ abstract class Message { public abstract String getContent(); public void addDefaultHeaders() { // Adds some default headers } public void encrypt() { // Has some code to encrypt the content } } /** * Concrete implementation of the Message class for Text messages. */ class TextMessage extends Message { @Override public String getContent() { return \"Text\"; } } /** * Concrete implementation of the Message class for JSON messages. */ class JSONMessage extends Message { @Override public String getContent() { return \"{\\\"JSON\\\":[]}\"; } } /** * Abstract creator class. The factory method createMessage() must be implemented * by subclasses to instantiate the specific message type. */ abstract class MessageCreator { public Message getMessage() { Message msg = createMessage(); msg.addDefaultHeaders(); msg.encrypt(); return msg; } // Factory method to create a message protected abstract Message createMessage(); } /** * Concrete creator for creating JSON messages. */ class JSONMessageCreator extends MessageCreator { @Override public Message createMessage() { return new JSONMessage(); } } /** * Concrete creator for creating Text messages. */ class TextMessageCreator extends MessageCreator { @Override public Message createMessage() { return new TextMessage(); } } /** * Client class demonstrating the use of the Factory Method pattern. */ public class Client { public static void main(String[] args) { printMessage(new JSONMessageCreator()); printMessage(new TextMessageCreator()); } public static void printMessage(MessageCreator creator) { Message msg = creator.getMessage(); System.out.println(msg.getContent()); } } --- title: URL Diagram of Factory Method Pattern --- classDiagram Message \u003c|-- TextMessage Message \u003c|-- JSONMessage MessageCreator \u003c|-- JSONMessageCreator MessageCreator \u003c|-- TextMessageCreator JSONMessageCreator \"1\" --\u003e \"1\" JSONMessage : creates TextMessageCreator \"1\" --\u003e \"1\" TextMessage : creates MessageCreator : +getMessage() MessageCreator : +createMessage() JSONMessageCreator : +createMessage() TextMessageCreator : +createMessage() Message : +getContent() Message : +addDefaultHeaders() Message : +encrypt() 2.4 Prototype The Prototype design pattern is a creational pattern that enables the creation of new objects by copying an existing object, known as the prototype. It is particularly useful when object creation is resource-intensive or when there is a need to dynamically create mana similar objects.\nSHOW CODE Java // Point3D class representing a 3D point class Point3D { private float x, y, z; public static final Point3D ZERO = new Point3D(0, 0, 0); public Point3D(float x, float y, float z) { this.x = x; this.y = y; this.z = z; } public Point3D normalize() { float mag = magnitude(); return new Point3D(x / mag, y / mag, z / mag); } private float magnitude() { return (float) Math.sqrt(x * x + y * y + z * z); } public Point3D multiply(float scale) { return new Point3D(x * scale, y * scale, z * scale); } public Point3D add(Point3D vector) { return new Point3D(x + vector.x, y + vector.y, z + vector.z); } @Override public String toString() { return \"(\" + x + \", \" + y + \", \" + z + \")\"; } } // Abstract GameUnit class defining the clone method abstract class GameUnit implements Cloneable { private Point3D position; public GameUnit() { position = Point3D.ZERO; } @Override public GameUnit clone() throws CloneNotSupportedException { GameUnit unit = (GameUnit) super.clone(); unit.initialize(); return unit; } protected void initialize() { this.position = Point3D.ZERO; reset(); } protected abstract void reset(); public GameUnit(float x, float y, float z) { position = new Point3D(x, y, z); } public void move(Point3D direction, float distance) { Point3D finalMove = direction.normalize(); finalMove = finalMove.multiply(distance); position = position.add(finalMove); } public Point3D getPosition() { return position; } } // Swordsman class extends GameUnit and implements specific behavior class Swordsman extends GameUnit { private String state = \"idle\"; public void attack() { this.state = \"attacking\"; } @Override public String toString() { return \"Swordsman \" + state + \" @ \" + getPosition(); } @Override protected void reset() { state = \"idle\"; } } // General class extends GameUnit but does not support cloning class General extends GameUnit { private String state = \"idle\"; public void boostMorale() { this.state = \"MoralBoost\"; } @Override public String toString() { return \"General \" + state + \" @ \" + getPosition(); } @Override public GameUnit clone() throws CloneNotSupportedException { throw new CloneNotSupportedException(\"Generals are unique\"); } @Override protected void reset() { throw new UnsupportedOperationException(\"Reset not supported\"); } } public class Main { // Client code to demonstrate the Prototype Pattern public static void main(String[] args) throws CloneNotSupportedException { // Creating and moving a Swordsman Swordsman s1 = new Swordsman(); s1.move(new Point3D(-10, 0, 0), 20); s1.attack(); System.out.println(s1); // Cloning the Swordsman Swordsman s2 = (Swordsman) s1.clone(); System.out.println(\"Cloned swordsman: \" + s2); } } Shallow Copy vs. Deep Copy: A shallow copy creates a new object but only copies the references of the original object\u0026rsquo;s fields. As a result, both the original and the copied object share references to the same inner objects. Any changes made to the inner mutable objects of the copied object will affect the original object as well. In Java, the clone method performs a shallow copy. On the other hand, a deep copy involves recursively copying the original object and all the objects it references. As a result, the copied object is entirely independent of the original, and changes made to the copied object do not affect the original one.\nSHOW CODE: Shallow Copy Java import java.util.ArrayList; import java.util.List; /** * @author Signal Yu * @since 2024-12-2 */ class Person { String name; int age; public Person(String name, int age) { this.name = name; this.age = age; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"Person{name='\" + name + \"', age=\" + age + '}'; } } public class Solution { public static void main(String[] args) { // Original list with mutable objects (Person) List\u0026lt;Person\u0026gt; originalList = new ArrayList\u0026lt;\u0026gt;(); originalList.add(new Person(\"Alice\", 30)); originalList.add(new Person(\"Bob\", 25)); // Shallow copy of the list List\u0026lt;Person\u0026gt; shallowCopyList = new ArrayList\u0026lt;\u0026gt;(originalList); // Modify the object in the shallow copy shallowCopyList.get(1).setName(\"Signal\"); // Print both lists System.out.println(\"Original List: \" + originalList); System.out.println(\"Shallow Copy List: \" + shallowCopyList); } } SHOW OUTPUT: Shallow Copy Output Original List: [Person{name='Alice', age=30}, Person{name='Signal', age=25}] Shallow Copy List: [Person{name='Alice', age=30}, Person{name='Signal', age=25}] SHOW CODE: Deep Copy Java import java.util.ArrayList; import java.util.List; class Person { String name; int age; public Person(String name, int age) { this.name = name; this.age = age; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"Person{name='\" + name + \"', age=\" + age + '}'; } // Deep copy method for Person class public Person deepCopy() { return new Person(this.name, this.age); } } public class Solution { public static void main(String[] args) { // Original list with mutable objects (Person) List\u0026lt;Person\u0026gt; originalList = new ArrayList\u0026lt;\u0026gt;(); originalList.add(new Person(\"Alice\", 30)); originalList.add(new Person(\"Bob\", 25)); // Deep copy of the list (creating new Person objects) List\u0026lt;Person\u0026gt; deepCopyList = new ArrayList\u0026lt;\u0026gt;(); for (Person person : originalList) { deepCopyList.add(person.deepCopy()); // Add a deep copy of each person } // Modify the object in the deep copy deepCopyList.get(1).setName(\"Signal\"); // Print both lists System.out.println(\"Original List: \" + originalList); System.out.println(\"Deep Copy List: \" + deepCopyList); } } SHOW OUTPUT: Deep Copy Output Original List: [Person{name='Alice', age=30}, Person{name='Bob', age=25}] Deep Copy List: [Person{name='Alice', age=30}, Person{name='Signal', age=25}] It is important to note that changes made to immutable objects in a shallow copied object will not affect the original object. For example, when performing a shallow copy of an ArrayList that contains Integer values, changes made to the Integer of the copied object will not affect the original object because Integer is immutable (since it is marked as final and its value cannot be changed).\nSHOW CODE Java import java.util.ArrayList; import java.util.List; /** * @author Signal Yu * @since 2024-12-2 */ public class Solution { public static void main(String[] args) { // Integer is an immutable class List\u0026lt;Integer\u0026gt; original = new ArrayList\u0026lt;\u0026gt;(); original.add(1); original.add(2); List shallowCopy = new ArrayList\u0026lt;\u0026gt;(original); // Shallow copy shallowCopy.set(0, 99); // Modify the shallow copy System.out.println(original); // Output: [1, 2] System.out.println(shallowCopy); // Output: [99, 2] } } Prototype v.s. Builder\n2.5 Abstract Factory The Abstract Factory design pattern is a creational pattern that creates families of related objects without specifying their concrete classes. It allows the client to instantiate objects from a group of related products while ensuring that these objects are compatible with each other. This pattern is particularly useful when a system needs to be independent of how objects are created, composed, and represented. However, a limitation of this pattern is that when a new product type is added, the base factory typically needs to be modified, which can increase the maintainence overhead.\nSHOW CODE Java // Represents an abstract product interface Storage { String getId(); } // Represents a concrete product in a family \"Amazon Web Services\" class S3Storage implements Storage { public S3Storage(int capacityInMib) { System.out.println(\"Allocated \" + capacityInMib + \" on S3\"); } @Override public String getId() { return \"S31\"; } @Override public String toString() { return \"S3 Storage\"; } } // Represents a concrete product in a family \"Google Cloud Platform\" class GoogleCloudStorage implements Storage { public GoogleCloudStorage(int capacityInMib) { System.out.println(\"Allocated \" + capacityInMib + \" on Google Cloud Storage\"); } @Override public String getId() { return \"gcpcs1\"; } @Override public String toString() { return \"Google cloud storage\"; } } // Represents an abstract product interface Instance { enum Capacity {micro, small, large} void start(); void attachStorage(Storage storage); void stop(); } // Represents a concrete product in a family \"Amazon Web Services\" class Ec2Instance implements Instance { public Ec2Instance(Capacity capacity) { System.out.println(\"Created Ec2Instance\"); } @Override public void start() { System.out.println(\"Ec2Instance started\"); } @Override public void attachStorage(Storage storage) { System.out.println(\"Attached \" + storage + \" to Ec2Instance\"); } @Override public void stop() { System.out.println(\"Ec2Instance stopped\"); } @Override public String toString() { return \"EC2Instance\"; } } // Represents a concrete product in a family \"Google Cloud Platform\" class GoogleComputeEngineInstance implements Instance { public GoogleComputeEngineInstance(Capacity capacity) { System.out.println(\"Created Google Compute Engine instance\"); } @Override public void start() { System.out.println(\"Compute engine instance started\"); } @Override public void attachStorage(Storage storage) { System.out.println(\"Attached \" + storage + \" to Compute engine instance\"); } @Override public void stop() { System.out.println(\"Compute engine instance stopped\"); } } // Abstract factory with methods defined for each object type. interface ResourceFactory { Instance createInstance(Instance.Capacity capacity); Storage createStorage(int capMib); } // Factory implementation for Amazon Web Services resources class AwsResourceFactory implements ResourceFactory { @Override public Instance createInstance(Instance.Capacity capacity) { return new Ec2Instance(capacity); } @Override public Storage createStorage(int capMib) { return new S3Storage(capMib); } } // Factory implementation for Google Cloud Platform resources class GoogleResourceFactory implements ResourceFactory { @Override public Instance createInstance(Instance.Capacity capacity) { return new GoogleComputeEngineInstance(capacity); } @Override public Storage createStorage(int capMib) { return new GoogleCloudStorage(capMib); } } // Client class public class Client { private ResourceFactory factory; public Client(ResourceFactory factory) { this.factory = factory; } public Instance createServer(Instance.Capacity cap, int storageMib) { Instance instance = factory.createInstance(cap); Storage storage = factory.createStorage(storageMib); instance.attachStorage(storage); return instance; } public static void main(String[] args) { Client aws = new Client(new AwsResourceFactory()); Instance i1 = aws.createServer(Instance.Capacity.micro, 20480); i1.start(); i1.stop(); System.out.println(\"***************************************\"); Client gcp = new Client(new GoogleResourceFactory()); i1 = gcp.createServer(Instance.Capacity.micro, 20480); i1.start(); i1.stop(); } } SHOW OUTPUT Output Created Ec2Instance Allocated 20480 on S3 Attached S3 Storage to Ec2Instance Ec2Instance started Ec2Instance stopped *************************************** Created Google Compute Engine instance Allocated 20480 on Google Cloud Storage Attached Google cloud storage to Compute engine instance Compute engine instance started Compute engine instance stopped Adding a new product type, such as Engine, may require modifications to the base factory. This is because the new Engine product froms a new combination with Storage and Instance, and the base factory is responsible for creating all the products (i.e., Storage, Instance, and Engine). As a result, the base factory needs to include a new method, createEngine. This modification violates the Open/Closed Principle (OCP), which states that classes should be open for extension but closed for modification.\nSHOW CODE Java // Represents an abstract product for Storage interface Storage { String getId(); } // Represents a concrete product in a family \"Amazon Web Services\" for Storage class S3Storage implements Storage { public S3Storage(int capacityInMib) { System.out.println(\"Allocated \" + capacityInMib + \" on S3\"); } @Override public String getId() { return \"S31\"; } @Override public String toString() { return \"S3 Storage\"; } } // Represents a concrete product in a family \"Google Cloud Platform\" for Storage class GoogleCloudStorage implements Storage { public GoogleCloudStorage(int capacityInMib) { System.out.println(\"Allocated \" + capacityInMib + \" on Google Cloud Storage\"); } @Override public String getId() { return \"gcpcs1\"; } @Override public String toString() { return \"Google Cloud Storage\"; } } // Represents an abstract product for Engine interface Engine { String getName(); } // Represents a concrete product in a family \"Amazon Web Services\" for Engine class Ec2Engine implements Engine { String name; public Ec2Engine(String name) { this.name = name; System.out.println(name + \" engine selected.\"); } @Override public String getName() { return name; } } // Represents a concrete product in a family \"Google Cloud Platform\" for Engine class GoogleComputeEngine implements Engine { String name; public GoogleComputeEngine(String name) { this.name = name; System.out.println(name + \" engine selected.\"); } @Override public String getName() { return name; } } // Represents an abstract product for Instance interface Instance { enum Capacity {micro, small, large} void start(); void attachStorage(Storage storage); void stop(); void useEngine(Engine engine); } // Represents a concrete product in a family \"Amazon Web Services\" for Instance class Ec2Instance implements Instance { public Ec2Instance(Instance.Capacity capacity) { System.out.println(\"Created Ec2Instance\"); } @Override public void start() { System.out.println(\"Ec2Instance started\"); } @Override public void attachStorage(Storage storage) { System.out.println(\"Attached \" + storage + \" to Ec2Instance\"); } @Override public void stop() { System.out.println(\"Ec2Instance stopped\"); } @Override public void useEngine(Engine engine) { System.out.println(\"Ec2Instance uses \" + engine.getName() + \" engine.\"); } @Override public String toString() { return \"EC2Instance\"; } } // Represents a concrete product in a family \"Google Cloud Platform\" for Instance class GoogleComputeEngineInstance implements Instance { public GoogleComputeEngineInstance(Instance.Capacity capacity) { System.out.println(\"Created Google Compute Engine instance\"); } @Override public void start() { System.out.println(\"Compute engine instance started\"); } @Override public void attachStorage(Storage storage) { System.out.println(\"Attached \" + storage + \" to Compute engine instance\"); } @Override public void stop() { System.out.println(\"Compute engine instance stopped\"); } @Override public void useEngine(Engine engine) { System.out.println(\"Google compute engine instance uses \" + engine.getName() + \" engine.\"); } } // Abstract factory with methods defined for each object type interface ResourceFactory { Instance createInstance(Instance.Capacity capacity); Storage createStorage(int capMib); Engine createEngine(String name); } // Factory implementation for Amazon Web Services resources class AwsResourceFactory implements ResourceFactory { @Override public Instance createInstance(Instance.Capacity capacity) { return new Ec2Instance(capacity); // Pass engine to the Ec2Instance } @Override public Storage createStorage(int capMib) { return new S3Storage(capMib); } @Override public Engine createEngine(String name) { return new Ec2Engine(name); } } // Factory implementation for Google Cloud Platform resources class GoogleResourceFactory implements ResourceFactory { @Override public Instance createInstance(Instance.Capacity capacity) { return new GoogleComputeEngineInstance(capacity); } @Override public Storage createStorage(int capMib) { return new GoogleCloudStorage(capMib); } @Override public Engine createEngine(String name) { return new GoogleComputeEngine(name); } } // Client class to test the code public class Client { private ResourceFactory factory; public Client(ResourceFactory factory) { this.factory = factory; } public Instance createServer(Instance.Capacity cap, int storageMib, String name) { Instance instance = factory.createInstance(cap); // Pass engine to instance creation Storage storage = factory.createStorage(storageMib); Engine engine = factory.createEngine(name); instance.attachStorage(storage); instance.useEngine(engine); // Call useEngine() on instance, which delegates to engine's getName() return instance; } public static void main(String[] args) { Client aws = new Client(new AwsResourceFactory()); Instance i1 = aws.createServer(Instance.Capacity.micro, 20480, \"Ec2\"); i1.start(); i1.stop(); System.out.println(\"***************************************\"); Client gcp = new Client(new GoogleResourceFactory()); i1 = gcp.createServer(Instance.Capacity.micro, 20480, \"GCE\"); i1.start(); i1.stop(); } } 2.6 Singleton 2.7 Object Pool 3. Structural Design Patterns 3.1 Adapter 3.2 Bridge 3.3 Decorator 3.4 Composite 3.5 Facade 3.6 Flyweight 3.7 Proxy 4. Behavioral Design Patterns 4.1 Chain of Responsibility 4.2 Command 4.3 Interpreter 4.4 Mediator 4.5 Iterator 4.6 Momento 4.7 Observer 4.8 State 4.9 Strategy 4.10 Template Method 4.11 Visitor 4.12 Null Object ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/design-patterns/1-design-patterns/","summary":"1. Solid Principle 1.1 Single Responsibility Principle A class should have only one reason to change, meaning each class should focus on a single functionality or responsibility.\nSHOW CODE Single Responsibility Principle import java.io.IOException; import java.util.*; import java.util.regex.*; import com.fasterxml.jackson.databind.ObjectMapper; /** * 1. User class is only used to represent entity. * 2. UserValidator class is solely responsible for validating user objects. * 3. Store class is only used to manage user objects storage.","title":"Design Patterns"},{"content":"Simple Two Pointers The Simple Two Pointers technique is commonly used to solve problems involving sorted array, where a set of elements needs to be found that satisfy certain constrains. This approach is efficient in scenarios such as finding a pair that sums to a target or reversing an array or string. In the two simple two pointers technique, two pointers \u0026ndash; typically labeled \u0026ldquo;left\u0026rdquo; and \u0026ldquo;right\u0026rdquo; \u0026ndash; are initialized and move in a specific direction based on the problem\u0026rsquo;s requirements.\nTwo Sum II - Input Array Is Sorted SHOW PROBLEM Problem Statement\nGiven a 1-indexed array of integers, numbers, sorted in non-decreasing order, find two numbers that add up to a specific target. Let these two numbers be numbers[index1] and numbers[index2], where 1 \u0026lt;= index1 \u0026lt; index2 \u0026lt;= numbers.length.\nReturn the indices of the two numbers, index1 and index2, incremented by one, as an integer array [index1, index2] of length 2.\nThe problem guarantees that there is exactly one solution. You may not use the same element twice. Your solution must use only constant extra space. Example 1:\nInput: numbers = [2,7,11,15], target = 9 Output: [1, 2] Explanation: The sum of 2 and 7 is 9, so index1 = 1, index2 = 2. We return [1, 2]. Example 2:\nInput: numbers = [2,3,4], target = 6 Output: [1, 3] Explanation: The sum of 2 and 4 is 6, so index1 = 1, index2 = 3. We return [1, 3]. Example 3:\nInput: numbers = [-1,0], target = -1 Output: [1, 2] Explanation: The sum of -1 and 0 is -1, so index1 = 1, index2 = 2. We return [1, 2]. Constraints:\n2 \u0026lt;= numbers.length \u0026lt;= 30,000 -1000 \u0026lt;= numbers[i] \u0026lt;= 1000 numbers is sorted in non-decreasing order. -1000 \u0026lt;= target \u0026lt;= 1000 There is exactly one solution for each test case. Go to Leetcode 🔗 SHOW CODE Java class Solution { public int[] twoSum(int[] numbers, int target) { int left = 0, right = numbers.length - 1; // Iterate while left pointer is before right pointer while (left \u003c right) { int currentSum = numbers[left] + numbers[right]; // Check if the current sum matches the target if (currentSum == target) { break; } // Adjust the pointers to move towards the target sum if (currentSum \u003c target) { left++; // Increase sum by moving left pointer right } else { right--; // Decrease sum by moving right pointer left } } // Reture 1-indexed result return new int[] { left + 1, right + 1 }; } } SHOW NOTES Algorithm Walkthrough\nnums = [1, 2, 3, 4, 5, 8] target = 7 Initialize pointers: left = 0, right = 5 First iteration: currentSum = 1 + 8 = 9 (greater than the target) Decrease the right pointer to 4 Second iteration: currentSum = 1 + 5 = 6 (less than the target) Increase the left pointer to 1 Third iteration: currentSum = 2 + 4 = 6 (equals the target) Return the indices [1, 3]. Visualization\n3Sum SHOW PROBLEM Problem Statement\nGiven an integer array nums, return all unique triplets [nums[i], nums[j], nums[k]] such that:\ni != j, i != k, and j != k nums[i] + nums[j] + nums[k] == 0 The solution set must not contain duplicate triplets.\nExample 1:\nInput: nums = [-1, 0, 1, 2, -1, -4] Output: [[-1, -1, 2], [-1, 0, 1]] Explanation: nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 The distinct triplets are [-1, 0, 1] and [-1, -1, 2].\nNote: The order of the output and the order of the triplets does not matter.\nExample 2:\nInput: nums = [0, 1, 1] Output: [] Explanation: The only possible triplet does not sum up to 0. Example 3:\nInput: nums = [0, 0, 0] Output: [[0, 0, 0]] Explanation: The only possible triplet sums up to 0. Constraints:\n3 \u0026lt;= nums.length \u0026lt;= 3000 10^5 \u0026lt;= nums[i] \u0026lt;= 10^5 Go to Leetcode 🔗 SHOW CODE Java class Solution { public List","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/patterns/1-coding-patterns-for-interview-questions/","summary":"Simple Two Pointers The Simple Two Pointers technique is commonly used to solve problems involving sorted array, where a set of elements needs to be found that satisfy certain constrains. This approach is efficient in scenarios such as finding a pair that sums to a target or reversing an array or string. In the two simple two pointers technique, two pointers \u0026ndash; typically labeled \u0026ldquo;left\u0026rdquo; and \u0026ldquo;right\u0026rdquo; \u0026ndash; are initialized and move in a specific direction based on the problem\u0026rsquo;s requirements.","title":"Coding Patterns for Interview Questions"},{"content":"Recursion Recursion is a programming technique where a function repeatedly calls itself until it reaches a base case, whcih stops the recursion and allows it to return a result. It is a way of breaking down complex problems into smaller, simpler subproblems that are eaiser to solve.\nHead Recursion Head Recursion is a type of recursion where a function makes its recursive call first, immediately after checking the base case, and performs all other operations only after the recursive call returns.\nSHOW CODE: Head Recursion Head Recursion void printNumbers(int n) { if (n == 0) { return; // Base case } printNumbers(n - 1); // Recursive call printf(\"%d\\n\", n); // Processing after recursion } Call Stack Operation Current Value of n headRecursion(3) Call function 3 headRecursion(2) Call function 2 headRecursion(1) Call function 1 headRecursion(0) Base case, exit 0 Unwinding begins: printf(1) Print 1 1 printf(2) Print 2 2 printf(3) Print 3 3 Tail Recursion Tail Recursion is a type of recursion where a function makes its recursive call as the last operation in its body. with no further operations after the call. This type of recursion can be optimized by the compiler into an iterative loop through tail call optimization (TCO), which help reduce memory consumption by the reusing the stack frame.\nSHOW CODE: Tail Recursion Tail Recursion void tailRecursion(int n) { if (n \u003e 0) { printf(\"%d \", n); // Operation first tailRecursion(n - 1); // Recursive call at the end } } Call Stack Operation Current Value of n tailRecursion(3) Print 3 3 tailRecursion(2) Print 2 2 tailRecursion(1) Print 1 1 tailRecursion(0) Base case, exit 0 Tail recursion is generally perfered for performance when recursion depth is large because it can be optimized into an iterative process.\nSHOW CODE: Tail Recursion Optimization Tail Recursion Optimization void tailRecursionOptimized(int n) { while (n \u003e 0) { printf(\"%d \", n); // Operation first n--; // Decrement n, same as `tailRecursion(n - 1)` } } In the above code, optimized Loop replaces recursion with a loop, ensuring only a single stack frame is used.\nConditions for Tail Recursion: The recursive call must be the last operation in the function, and its result must be immediately returned without any further computation after the call.\nSHOW CODE: Tail Recursive Function Tail Recursive Function // Tail recursive function to calculate factorial int factorialTailRecursion(int n, int accumulator) { if (n == 0) { return accumulator; // Base case: return accumulated result } return factorialTailRecursion(n - 1, accumulator * n); // Recursive call is the last operation } SHOW CODE: Non-tail Recursive Function Non-tail recursive // Non-tail recursive function to calculate factorial int factorialNonTailRecursion(int n) { if (n == 0) { return 1; // Base case } return n * factorialNonTailRecursion(n - 1); // Recursive call is not the last operation } Tree Recursion Tree recursion is a type of recursion in which a function makes multiple recursive calls to itself in its body, it creates a tree-like data structure, as each call can branch into multiple additional calls.\nSHOW CODE C public int fib(int n) { if (n \u003c= 1) { return n; } return fib(n - 1) + fib(n - 2); } Recursion Tree Analysis:\n--- title: Recursion Tree Analysis - fibonacci sequence --- graph TD L0((\"fib\\(5\\)\")) --\u003e L1((\"fib\\(4\\)\")) L0 --\u003e L2((\"fib\\(3\\)\")) L1 --\u003e L3((\"fib\\(3\\)\")) L1 --\u003e L4((\"fib\\(2\\)\")) L2 --\u003e L5((\"fib\\(2\\)\")) L2 --\u003e L6((\"fib\\(1\\)\")) L3 --\u003e L7((\"fib\\(2\\)\")) L3 --\u003e L8((\"fib\\(1\\)\")) L4 --\u003e L9((\"fib\\(1\\)\")) L4 --\u003e L10((\"fib\\(0\\)\")) L5 --\u003e L11((\"fib\\(1\\)\")) L5 --\u003e L12((\"fib\\(0\\)\")) L7 --\u003e L13((\"fib\\(1\\)\")) L7 --\u003e L14((\"fib\\(0\\)\")) Array An array is a data structure that stores a collection of elements of the same type in a fixed-size, continguous block of memory. Arrays can be categorized into two types: static arrays and dynamic arrays.\nA static array has a fixed size that cannot be changed after its declaration. Memory for a static array is allocated at compile time, and its size must be explicitly specified.\nIn contrast, a dynamic array allows its size to be adjusted during runtime, enabling it to grow or shrink as needed. Unlike static arrays, the size of a dynamic array does not need to be specified at the time of declaration, and memory is allocated dynamically from the heap.\nImplementation of Static Arrays Implementation of Dynamic Arrays Compiler\u0026rsquo;s Memory Layout for Arrays The address of an array element is determined at runtime. Array elements are stored in a continguous block of memory, and the compiler calculates each element\u0026rsquo;s address using its index and the size of each element.\n1-Dimentional Array Element Access Formula (0-based index): $\\text{Addr}_{A[i]} = B + i \\times W$\nB: Base Address i: Zero-based Index of Each Element W: Size of Each Element SHOW CODE C #include \u0026lt;stdio.h\u0026gt; int main() { int arr[5] = {10, 20, 30, 40, 50}; for (int i = 0; i \u003c 5; i++) { void *addr_i = (void *) arr + (i * sizeof(int)); printf(\"Element at index %d: %d \\t Address: %p\\n\", i, arr[i], addr_i); } return 0; } SHOW OUTPUT Output Element at index 0: 10 Address: 0x7ff7bb0b7170 Element at index 1: 20 Address: 0x7ff7bb0b7174 Element at index 2: 30 Address: 0x7ff7bb0b7178 Element at index 3: 40 Address: 0x7ff7bb0b717c Element at index 4: 50 Address: 0x7ff7bb0b7180 2-Dimentional Array Element Access Formula (Row Major Order): $\\text{Addr}_{A[i][j]} = \\text{B} + [(i \\times \\text{C}) + j] \\times \\text{W}$\nB: Base Address i: Zero-based Row Index of Each Element j: Zero-based Column Index of Each ELement C: Number of Columns W: Size of Each Element SHOW CODE C #include \u0026lt;stdio.h\u0026gt; int main() { int arr[2][3] = {{1, 2, 3}, {4, 5, 6}}; for (int i = 0; i \u003c 2; i++) { for (int j = 0; j \u003c 3; j++) { void *addr_ij = (void *) \u0026arr + (i * 3 + j) * sizeof(int); printf(\"Element at [%d][%d]: %d, Address: %p\\n\", i, j, arr[i][j], addr_ij); } } return 0; } SHOW OUTPUT Output Element at [0][0]: 1, Address: 0x7ff7b2c64170 Element at [0][1]: 2, Address: 0x7ff7b2c64174 Element at [0][2]: 3, Address: 0x7ff7b2c64178 Element at [1][0]: 4, Address: 0x7ff7b2c6417c Element at [1][1]: 5, Address: 0x7ff7b2c64180 Element at [1][2]: 6, Address: 0x7ff7b2c64184 Why do most compilers use 0-based indexing? Take a 1-dimentional array as an example, the element access formula for a 0-based index is $\\text{Addr}_{A[i]} = B + i \\times W$. This formula requires two operations (multiplication and addition) to access each element in the array.\nIn contract, the formula for 1-based indexing is $\\text{Addr}_{A[i]} = B + (i - 1) \\times W$. This requires three operations (multiplication. subtraction, and addition). Compared to 0-based indexing, 1-based indexing introduces one additional operation, which becomes a significant overhead when dealing with large size arrays.\nString Matrix Linked List Stack Queue A Queue is a linear data structure that follows the First In, First Out (FIFO) principle, meaning elements are added to the back and removed from the front. There are four main types of queues: Simple Queue, Circular Queue, Double-Ended Queue (Deque), and Priority Queue.\nSimple Queue A Simple Queue is a basic type of queue data structure in which elements are added to the back and removed from the front, following the First In, First Out (FIFO) principle.\nImplementation of Simple Queue Array with a single pointer SHOW CODE Java class SimpleQueue { private final int[] queue; private final int capacity; private int rear; public SimpleQueue(int capacity) { this.queue = new int[capacity]; this.capacity = capacity; this.rear = -1; } public boolean isEmpty() { return rear == -1; } private boolean isFull() { return rear == capacity - 1; } public int size() { return rear + 1; } public void enqueue(int element) { if (this.isFull()) { System.out.println(\"Queue is full.\"); } else { rear++; queue[rear] = element; } } public int dequeue() { if (this.isEmpty()) { System.out.println(\"Queue is empty.\"); return -1; } int frontElement = queue[0]; // Shift all elements to the left for (int i = 0; i \u003c rear; i++) { queue[i] = queue[i + 1]; } rear--; return frontElement; } public int peek() { if (this.isEmpty()) { System.out.println(\"Queue is empty.\"); return -1; } return queue[0]; } } public class Main { public static void main(String[] args) { SimpleQueue queue = new SimpleQueue(5); queue.enqueue(10); queue.enqueue(20); queue.enqueue(30); System.out.println(\"Front element: \" + queue.peek()); // Expected: 10 System.out.println(\"Dequeued: \" + queue.dequeue()); // Expected: 10 queue.enqueue(40); queue.enqueue(50); System.out.println(\"Queue size: \" + queue.size()); // Expected: 4 System.out.println(\"Dequeued: \" + queue.dequeue()); // Expected: 20 } } The implementation of a queue using an array with a single pointer (rear) is inefficient for deletion because the remaining elements need to be shifted left after every dequeue operation.\nArray with two pointers SHOW CODE Java class SimpleQueue { private final int[] queue; private final int capacity; private int front; private int rear; public SimpleQueue(int capacity) { this.capacity = capacity; queue = new int[capacity]; this.front = -1; this.rear = -1; } public boolean isEmpty() { return front == -1; } private boolean isFull() { return rear + 1 == capacity; } public int size() { if (this.isEmpty()) { return 0; } return rear - front + 1; } public void enqueue(int element) { if (this.isFull()) { System.out.println(\"Queue is full.\"); } else { // Set front to 0 when the first element is added if (front == -1) { front = 0; } rear++; queue[rear] = element; } } public int dequeue() { if (this.isEmpty()) { System.out.println(\"Queue is empty.\"); return -1; } else { int frontElement = queue[front]; // Reset both pointers to -1 when the queue has only one element if (front == rear) { front = -1; rear = -1; } else { // Move front to the next element front++; } return frontElement; } } public int peek() { if (this.isEmpty()) { System.out.println(\"Queue is empty.\"); return -1; } else { return queue[front]; } } } public class Main { public static void main(String[] args) { SimpleQueue queue = new SimpleQueue(5); queue.enqueue(10); queue.enqueue(20); queue.enqueue(30); System.out.println(\"Front element: \" + queue.peek()); // Expected: 10 System.out.println(\"Dequeued: \" + queue.dequeue()); // Expected: 10 queue.enqueue(40); queue.enqueue(50); System.out.println(\"Queue size: \" + queue.size()); // Expected: 3 System.out.println(\"Dequeued: \" + queue.dequeue()); // Expected: 20 } } Implementing a queue using an array with two pointers (front and rear) is more efficient for deletion compared to using a single pointer (rear), as it eliminates the need to shift elements to the left after each dequeue operation. However, this approach has drawback: the space in front of the front pointer cannot be reused until the array is empty, leading to potential wasted memory.\nLinked List with a pointer SHOW CODE Java class Node { int data; Node next; public Node(int data) { this.data = data; this.next = null; } } class SimpleQueue { private Node front; private int size; public SimpleQueue() { front = null; size = 0; } // Check if the queue is empty public boolean isEmpty() { return size == 0; } // Get the current size of the queue public int size() { return size; } // Display the elements of the queue public void display() { if (isEmpty()) { System.out.println(\"Queue is empty.\"); return; } // Traverse through the queue and print its elements Node temp = front; // Use StringBuilder to efficiently build the string StringBuilder builder = new StringBuilder(); while (temp != null) { builder.append(temp.data).append(\"\u003c-\"); temp = temp.next; } // Remove the last \"\u003c-\" (extra arrow at the end) builder.setLength(builder.length() - 2); System.out.println(builder); } // Add an element to the rear (end) of the queue public void enqueue(int data) { Node node = new Node(data); // If the queue is empty, the new node becomes the front of the queue if (isEmpty()) { front = node; } else { Node temp = front; // Traverse the list to find the last node (rear of the queue) while (temp.next != null) { temp = temp.next; } temp.next = node; // Link the new node at the end of the queue } size++; // Increment the size of the queue } // Remove and return the element from the front of the queue public int dequeue() { if (isEmpty()) { throw new IllegalStateException(\"Queue is empty.\"); } int dequeued = front.data; front = front.next; size--; return dequeued; } // Return the element from the front of the queue without removing it public int peek() { if (isEmpty()) { throw new IllegalStateException(\"Queue is empty.\"); } return front.data; } } public class Main { public static void main(String[] args) { SimpleQueue queue = new SimpleQueue(); // Enqueue some elements into the queue queue.enqueue(10); queue.enqueue(20); queue.enqueue(30); queue.enqueue(40); System.out.println(\"Queue after enqueuing elements:\"); queue.display(); // Display the current state of the queue // Dequeue two elements and print them System.out.println(\"Dequeued: \" + queue.dequeue()); System.out.println(\"Dequeued: \" + queue.dequeue()); System.out.println(\"Queue after dequeuing elements:\"); queue.display(); // Display the queue after dequeuing elements // Peek at the front element without removing it System.out.println(\"Peek front: \" + queue.peek()); // Print the current size of the queue System.out.println(\"Queue size: \" + queue.size()); } } Linked List with two pointers SHOW CODE Java // Node class representing each element in the queue class Node { int data; Node next; public Node(int data) { this.data = data; this.next = null; } } // SimpleQueue class implementing queue operations using a linked list class SimpleQueue { private Node front; private Node rear; private int size; // Constructor to initialize the queue public SimpleQueue() { front = rear = null; size = 0; } // Check if the queue is empty public boolean isEmpty() { return size == 0; } // Get the size of the queue public int size() { return size; } // Display the elements in the queue public void display() { if (isEmpty()) { System.out.println(\"Queue is empty.\"); return; } // Build a string representation of the queue StringBuilder builder = new StringBuilder(); Node temp = front; while (temp != null) { builder.append(temp.data).append(\"\u003c-\"); temp = temp.next; } // Remove the trailing \" \u003c- \" builder.setLength(builder.length() - 2); System.out.println(builder); } // Enqueue: Add an element to the rear of the queue public void enqueue(int data) { Node newNode = new Node(data); // If the queue is empty, both front and rear point to the new node if (isEmpty()) { front = rear = newNode; } else { // Add new node at the end and update the rear pointer rear.next = newNode; rear = newNode; } size++; } // Dequeue: Remove and return the element from the front of the queue public int dequeue() { if (isEmpty()) { throw new IllegalStateException(\"Queue is empty.\"); } // Get the front element and update the front pointer int dequeuedData = front.data; front = front.next; // If the queue becomes empty, reset the rear to null if (front == null) { rear = null; } size--; return dequeuedData; } // Peek: Get the front element without removing it public int peek() { if (isEmpty()) { throw new IllegalStateException(\"Queue is empty.\"); } return front.data; } } // Main class to test the queue implementation public class Main { public static void main(String[] args) { SimpleQueue queue = new SimpleQueue(); // Enqueue elements into the queue queue.enqueue(10); queue.enqueue(20); queue.enqueue(30); queue.enqueue(40); // Display the queue after enqueuing elements System.out.println(\"Queue after enqueuing elements:\"); queue.display(); // Dequeue elements from the queue System.out.println(\"Dequeued: \" + queue.dequeue()); System.out.println(\"Dequeued: \" + queue.dequeue()); // Display the queue after dequeuing elements System.out.println(\"Queue after dequeuing elements:\"); queue.display(); // Peek the front element and show the queue size System.out.println(\"Peek front: \" + queue.peek()); System.out.println(\"Queue size: \" + queue.size()); } } Circular Queue A Circular Queue is a variation of the standard queue data structure that reuses the space freed by dequeue operations by connecting the last position back to the front position. It overcomes the limitation of a simple fixed-size queue, where the space at the front of the queue cannot be reused after dequeueing elements.\nArray Implementation SHOW CODE Java class CircularQueue { private final int[] queue; private int front; private int rear; private final int capacity; private int size; public CircularQueue(int capacity) { this.capacity = capacity; queue = new int[capacity]; front = rear = -1; // Initialize both front and rear as -1 to indicate the queue is empty size = 0; } // Check if the queue is empty public boolean isEmpty() { return size == 0; } // Check is the queue is full public boolean isFull() { return size == capacity; } // Get the current size of the queue public int size() { return size; } // Display the elements of the queue public void display() { if (isEmpty()) { System.out.println(\"Queue is empty.\"); return; } StringBuilder builder = new StringBuilder(); for (int i = 0; i \u003c size; i++) { builder.append(queue[(front + i) % capacity]); if (i != size - 1) { builder.append(\"\u003c-\"); } } System.out.println(builder); } public void enqueue(int data) { if (isFull()) { throw new IllegalStateException(\"Queue is full.\"); } if (isEmpty()) { front = 0; } // Move the rear pointer in a circular manner rear = (rear + 1) % capacity; // Add the data to the rear of the queue queue[rear] = data; // Increase the size size++; } public int dequeue() { if (isEmpty()) { throw new IllegalStateException(\"Queue is empty.\"); } int dequeued = queue[front]; if (front == rear) { // If the queue become empty, reset both front and rear to -1 front = rear = -1; } else { // Move the front pointer in a circular manner front = (front + 1) % capacity; } size--; // Decrease the size return dequeued; } public int peek() { if (isEmpty()) { throw new IllegalStateException(\"Queue is empty.\"); } return queue[front]; } } public class Main { public static void main(String[] args) { CircularQueue queue = new CircularQueue(5); queue.enqueue(10); queue.enqueue(20); queue.enqueue(30); queue.enqueue(40); queue.enqueue(50); System.out.println(\"Queue after enqueuing 5 elements:\"); queue.display(); // Attempt to enqueue an element to a full queue (throws exception) try { queue.enqueue(60); } catch (IllegalStateException e) { System.out.println(e.getMessage()); } // Dequeue two elements System.out.println(\"Dequeued: \" + queue.dequeue()); System.out.println(\"Dequeued: \" + queue.dequeue()); System.out.println(\"Queue after dequeuing 2 elements:\"); queue.display(); // Enqueue two more elements queue.enqueue(60); queue.enqueue(70); System.out.println(\"Queue after enqueuing 2 more elements:\"); queue.display(); // Peek at the front element System.out.println(\"Front element: \" + queue.peek()); // Display the current size of the queue System.out.println(\"Queue size: \" + queue.size()); } } Linked List Implementation SHOW CODE Java class Node { int data; Node next; public Node(int data) { this.data = data; this.next = null; } } class CircularQueue { private Node front; private Node rear; private int size; public CircularQueue() { front = rear = null; size = 0; } // Check if the queue is empty public boolean isEmpty() { return size == 0; } // Get the size of the queue public int size() { return size; } // Display the elements of the queue public void display() { if (isEmpty()) { System.out.println(\"Queue is empty.\"); return; } Node temp = front; StringBuilder builder = new StringBuilder(); do { builder.append(temp.data).append(\"\u003c-\"); temp = temp.next; } while (temp != front); // Loop until reach the front newNode again builder.setLength(builder.length() - 2); System.out.println(builder); } // Add an element to the queue public void enqueue(int data) { Node newNode = new Node(data); // Both front and rear will point to the new node if queue is empty if (isEmpty()) { front = rear = newNode; } else { rear.next = newNode; // Connect the current rear to the new node rear = newNode; // Move the rear to the new node } rear.next = front; // Connect the rear's next to the front size++; } // Remove the front element in the queue public int dequeue() { if (isEmpty()) { throw new IllegalStateException(\"Queue is empty\"); } int dequeued = front.data; // Set both front and rear to null if there is only one element if (front == rear) { front = rear = null; } else { front = front.next; // Move the front node to the next rear.next = front; // Maintain the circular link } size--; return dequeued; } // Get the front element without removing it public int peek() { if (isEmpty()) { throw new IllegalStateException(\"Queue is empty.\"); } return front.data; } } public class Main { public static void main(String[] args) { CircularQueue queue = new CircularQueue(); // Enqueue elements queue.enqueue(10); queue.enqueue(20); queue.enqueue(30); queue.enqueue(40); // Display queue elements System.out.println(\"Queue after enqueuing elements:\"); queue.display(); // Dequeue elements System.out.println(\"Dequeued: \" + queue.dequeue()); System.out.println(\"Dequeued: \" + queue.dequeue()); // Display queue elements after dequeueing System.out.println(\"Queue after dequeuing elements:\"); queue.display(); // Peek front element System.out.println(\"Peek front: \" + queue.peek()); // Display the size of the queue System.out.println(\"Queue size: \" + queue.size()); } } Double Ended Queue Priority Queue Tree Graph A graph is a fundamental data structure used to represent the connections or relationships between entities. It consists of vertices (also called node) and edges (also called arcs). A vertex represents a single entity in the graph, while an edge represents a connection or relationship between two vertices. Edges may have additional properties, such as weight (to indicate the cost or distance of the connection) or direction (to indicate the direction of the relationship).\nTypes of Graph Undirected Graph vs. Directed Graph In an undirected graph, the connection between two vertices is bidrectional. For example, if there is an edge between vertex A and vertex B, traversal is possible from A to B and from B to A. In contrast, in a directed graph, the relationships are one-way. For instance, if there is an edge from vertex A to vertex B, traversal is possible from A to B, but not from B to A unless there is a separate edge in the opposite direction.\nUnweighted Graph vs. Weighted Graph In an unweighted graph, the relationships between vertices have no additional properties, and all edges are treated equally. In contrast, a weighted graph assigns a weight to each node, which can represent attributes such as distance, time, cost, eetc. The weight provides more information about the connection between vertices and is often used in problems like shortest path or network flow.\nCyclic Graph vs. Acyclic Graph A cyclic graph contains at least one cycle, which is a path that starts and ends at the same vertex. In contrast, an acyclic graph doest not contain any cycles. A special case of an acyclic graph is the directed acyclic graph (DAG), which has directed edges and no cycles.\nConnected Graph vs. Disconnected Graph A connected graph is a graph in which there is a path between every pair of vertices. In contrast, a disconnected graph is a graph where at least one pair of vertices is not connected by any path.\nGraph Terminology The degree of a vertex is the number of edges incident to that vertex. In an undirected graph, the degree is simply the number of edges connected to the vertex. In a directed graph, the degree is the sum of the in-degree (number of incoming edges) and the out-degree (number of outgoing edges) of the vertex.\nA path is a sequence of vertices where each consecutive pair of vertices is connected by an edge.\nA cycle is a path that starts and ends at the same vertex, with no repeated vertices except for the starting or ending vertex. For example, in a cycle with $A \\rightarrow B \\rightarrow C \\rightarrow D \\rightarrow A$, the path starts and ends at the same vertex $A$, but each of the other vertices $(B, C, and D)$ is visited exactly once.\nConnectivity refers to whether there exists a path between any pair of vertices in the graph.\nA subgraph is a graph formd by a subset of the vertices and edges of the original graph.\nA component is a subgraph where there is a path between every pair of vertices in that subgraph.\nGraph Representation Adjacency Matrix An Adjacency Matrix ia a 2-dimentional array where each element at position [i][j] represents an edge between vertex i and j. In a weighted graph, the value at position [i][j] stores the weight of the edge between the two vertices. In an unweight graph, the value at position [i][j] typically stores 1 to indicate an edge exists between the vertices, and 0 to indicate no edge exists. The space complexity of an adjacency matrix is $O(V^2)$, where $V$ is the number of vertices, as it requires a matrix of size $V \\times V$ to represent the graph.\nAdjacency List An Adjacency List is a collection of lists, where each position i stores a list of nerighbors of vertex i. In a weighted graph. each element in the list typically represents a pair (neighbor, weight), where neighbor is a vertex connected to i, and weight is the weight of the edge between i and neighbor. The space complexity of an adjacency list is $O(V + E)$, where $V$ is the number of vertices and $E$ is the number of edges. This is because each vertex has a list of neighbors, and the total number of entries in all lists is proportional to the number of edges.\nEdge List An Edge List is a collection of pairs, where each pair (i, j) represents an edge between vertex i and vertex j. In a weighted graph. each element may also include the weight of the edge. typically represented as (i, j, weight). The space complexity of an edge list is $O(E)$, where $E$ is the number of edges, as each edge is stored as a separate entry in the list.\nGraph Traversal Breadth First Search Breadth-First Search (BFS) explores all the neighbors of a vertex before moving on to their neighbors. It proceeds level by level, ensuring that all vertices at a given distance from the starting vertex are visited before moving on to vertices at a greater distance. BFS is commonly used to find the shortest path in an unweighted graph.\nDepth First Search Depth-First Search (DFS) explores as far as possible alone a branch of the graph before backtracking to explore other branches. It follows a path from the starting vertex to a dead end, then retrace its steps and explores alternative paths. DFS is useful for finding all paths between vertices, detecting cycles, or performing topological sorting in directed acyclic graphs (DAGs).\nSpanning Tree A spanning tree is a subset of a graph that includes all the vertices and contains exactly $V - 1$ edges, where $V$ is the number of vertices in the graph. A connected graph can have multiple spanning trees, whereas a disconnected graph does not have a spanning tree because there is at least one pair of vertices that are not connected, making it impossible to form a tree that spans all the vertices.\nMinimum Spanning Tree (MST) A minimum spanning tree is a type of spanning tree that connects all the vertices of a graph with the smallest possible total edge weight, compared to all other possible spanning trees.\nPrim\u0026rsquo;s Algorithm Prim\u0026rsquo;s Algorithm is used to find the minimum spanning tree (MST) that connects all the vertices of a graph without forming a cycle, while minimizing the total edge weight. This algorithm is efficient for solving problems related to undirected, weighted graphs. The algorithm steps are as follows:\nInitialize an inMST array to track the vertices included in the MST, and a priority queue (min-heap) to process the edges with the smallest weight. Select an arbitrary starting vertex. Add all edges connected to this vertex into the priority queue and mark the vertex as included in the inMST array. Extract the edge with the minimum weight from the priority queue. If the destination vertex of this edge is not yet in the inMST array, include it, and add all edges connected to this newly included vertex (whose destination is not in the MST) to the priority queue. Repeat step 3 until all vertices are included in the MST. SHOW CODE Java import java.util.*; /** * @author Signal Yu * @since 2024-12-1 */ class Edge implements Comparable\u0026lt;Edge\u0026gt; { int src; int dest; int weight; public Edge(int src, int dest, int weight) { this.src = src; this.dest = dest; this.weight = weight; } @Override public int compareTo(Edge other) { // Sort edges based on weight return this.weight - other.weight; } } class Graph { int vertices; int edges; List\u0026lt;List\u0026gt;Edge\u0026gt;\u0026gt; adjacencyList; public Graph(int vertices) { this.vertices = vertices; adjacencyList = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c vertices; i++) { adjacencyList.add(new ArrayList\u0026lt;\u0026gt;()); } } void addEdge(int src, int dest, int weight) { // Add edge for undirected graph Edge edge1 = new Edge(src, dest, weight); Edge edge2 = new Edge(dest, src, weight); adjacencyList.get(src).add(edge1); adjacencyList.get(dest).add(edge2); } void primMST() { // Step 1: Initialize an `inMST` array to track the vertices // included in the MST, and a priority queue (min-heap) to // process the edges with the smallest weight. boolean[] inMST = new boolean[vertices]; Queue priorityQ = new PriorityQueue\u003c\u003e(); // Step 2: Select an arbitrary starting vertex. Add all edges // connected to this vertex into the priority queue and mark // the vertex as included in the `inMST` array. int start = 0; for (Edge edge : adjacencyList.get(start)) { priorityQ.offer(edge); } inMST[start] = true; // Step 4: Repeat step 3 until all vertices are included in the MST. while (!priorityQ.isEmpty()) { // Step 3: Extract the edge with the minimum weight from the // priority queue. If the destination vertex of this edge is // not yet in the `inMST` array, include it, and add all edges // connected to this newly included vertex (whose destination // is not in the MST) to the priority queue. Edge edge = priorityQ.poll(); int u = edge.src, v = edge.dest; if (!inMST[v]) { System.out.println(u + \"---[\" + edge.weight + \"]---\" + v); inMST[v] = true; // Add all edges from the newly included vertex (whose destination // is not included in `inMST`) to the priority queue for (Edge nextEdge : adjacencyList.get(v)) { if (!inMST[nextEdge.dest]) { priorityQ.offer(nextEdge); } } } } } } public class Solution { public static void main(String[] args) { int vertices = 4; // Number of vertices in the graph Graph graph = new Graph(vertices); // Create a graph with specified vertices // Add edges to the graph graph.addEdge(0, 1, 10); graph.addEdge(0, 2, 6); graph.addEdge(0, 3, 5); graph.addEdge(1, 3, 15); graph.addEdge(2, 3, 4); // Run Prim's algorithm to construct MST graph.primMST(); } } ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/algorithms/1-data-structure-and-algorithms/","summary":"Recursion Recursion is a programming technique where a function repeatedly calls itself until it reaches a base case, whcih stops the recursion and allows it to return a result. It is a way of breaking down complex problems into smaller, simpler subproblems that are eaiser to solve.\nHead Recursion Head Recursion is a type of recursion where a function makes its recursive call first, immediately after checking the base case, and performs all other operations only after the recursive call returns.","title":"Data Structure \u0026 Algorithms"},{"content":"JUnit assertEquals In JUnit, assertEquals is a method used to check if the expected value and the actual value are equal in unit tests.\nSHOW CODE Java import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class UnitTest { @Test void addition() { Calculator calculator = new Calculator(); int result = calculator.add(1, 1); assertEquals(2, result, \"The result of 1 + 1 should be 2\"); } } assertTure \u0026amp; assertFalse In JUnit, the assertTrue and the assertFalse methods are used to validate boolean expressions in unit tests.\nSHOW CODE Java import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertTrue; public class UnitTest { @Test void testIsOdd() { int n = 5; assertTrue(n % 2 == 1, \"Number should be an odd\"); assertFalse(n % 2 == 0, \"Number should not be an even\"); } } @BeforeEach \u0026amp; @AfterEach In JUnit, the @BeforeEach and @AfterEach annotations are used to specify methods that should run before or after each test method, respectively. These annotations are useful for setting up resources before each test and cleaning up resources after each test.\nSHOW CODE Java import org.junit.jupiter.api.AfterEach; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class UnitTest { private Calculator calculator; @BeforeEach void setup() { calculator = new Calculator(); } @Test void testAddition() { assertEquals(2, calculator.add(1, 1), \"The result of 1 + 1 should be 2.\"); } @AfterEach void teardown() { calculator = null; } } @BeforeAll \u0026amp; @AfterAll In JUnit, the @BeforeAll and @AfterAll annotations are used to specify methods that run once before and after all the test methods in a test class, respectively. These methods are commonly used for expensive setup and cleanup.\nSHOW CODE Java import org.junit.jupiter.api.AfterAll; import org.junit.jupiter.api.BeforeAll; import org.junit.jupiter.api.Test; public class UnitTest { @BeforeAll public static void setUpBeforeClass() { System.out.println(\"Executed before all tests are run.\"); } @AfterAll public static void tearDownAfterClass() { System.out.println(\"Executed after all tests are run.\"); } @Test public void testMethod1() { System.out.println(\"Test 1 executed.\"); } @Test public void testMethod2() { System.out.println(\"Test 2 executed.\"); } } SHOW OUTPUT Output Executed before all tests are run. Test 1 executed. Test 2 executed. Executed after all tests are run. assertArrayEquals \u0026amp; assertNotEquals In JUnit, the assertArrayEquals and assertNotEquals methods are used to check if both arrays are equal in sizeand whether each corresponding element is equal or not. For arrays containing objects, JUnit will use the equals method of the objects for the comparison.\nSHOW CODE Java import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertArrayEquals; import static org.junit.jupiter.api.Assertions.assertNotEquals; public class UnitTest { @Test void testArrayEquality() { int[] expected = {1, 2, 3}; int[] actual = {1, 2, 3}; assertArrayEquals(expected, actual, \"Arrays should be equal\"); String[] expected2 = {\"apple\", \"banana\", \"cherry\"}; String[] actual2 = {\"apple\", \"banana\", \"cherry\"}; // Compare arrays of objects (Strings in this case) assertArrayEquals(expected2, actual2); } @Test void testArrayNotEquality() { int[] expected = {1, 2, 3}; int[] actual = {1, 2, 4}; assertNotEquals(expected, actual, \"Arrays should not be equal\"); } } assertThrows In Junit, the assertThrows is a method used to assert that a specific exception is throwing during the execution of a piece of code.\nSHOW CODE Java import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertThrows; public class UnitTest { @Test void testDivision() { Calculator calculator = new Calculator(); ArithmeticException exception = assertThrows(ArithmeticException.class, () -\u003e { calculator.divide(1, 0); }); assertEquals(\"/ by zero\", exception.getMessage()); } } assertTimeout \u0026amp; assertTimeoutPreemptively In JUnit, the assertTimeout and assertTimeoutPreemptively methods are used to ensure that a unit test finishes within a specified time limit. The key difference between them is that the assertTimeoutPreemptively method will terminate the test as soon as the excution time exceeds the specified limit. In contrast, the assertTimeout method allows the test to complete before checking if the time limit was exceeded.\nSHOW CODE Java import org.junit.jupiter.api.Test; import java.time.Duration; import static org.junit.jupiter.api.Assertions.*; public class UnitTest { @Test void testExecutionWithinTimeoutPreemptively() { assertTimeoutPreemptively(Duration.ofMillis(1000), () -\u003e { // Simulate a task that takes more time than allowed Thread.sleep(1500); // Task that takes more than 1000ms }); } @Test void testExecutionWithinTimeout() { assertTimeout(Duration.ofMillis(1000), () -\u003e { // Simulate a task that takes some time Thread.sleep(500); // Task that takes less than 1000ms }); } } Parameterized Tests In JUnit, Parameterized Tests allow a test to be run with different parameters and expected results, which reduces repetitive code and increases test coverage. Common parameter sources include @ValueSource, which passes a group of values to the test; @CsvSource, which allows passing multiple values separated by commmas; @MethodSource, which generates values dynamically from a method; and @EnumSource, which passes enum constants from an enum class.\nSHOW CODE Java import org.junit.jupiter.params.ParameterizedTest; import org.junit.jupiter.params.provider.CsvSource; import org.junit.jupiter.params.provider.EnumSource; import org.junit.jupiter.params.provider.MethodSource; import org.junit.jupiter.params.provider.ValueSource; import java.util.stream.Stream; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertTrue; public class UnitTest { @ParameterizedTest @ValueSource(strings = {\"apple\", \"banana\", \"cherry\"}) void testWithStringParameter(String fruit) { assertTrue(fruit.length() \u003e 3); } @ParameterizedTest @CsvSource({ \"apple, 5\", \"banana, 6\", \"cherry, 6\" }) void testWithCsvSource(String fruit, int length) { assertEquals(fruit.length(), length); } static Stream\u0026lt;String\u0026gt; stringProvider() { return Stream.of(\"apple\", \"banana\", \"cherry\"); } @ParameterizedTest @MethodSource(\"stringProvider\") void testWithMethodSource(String fruit) { assertTrue(fruit.length() \u003e 3); } enum FRUIT {APPLE, BANANA, CHERRY} @ParameterizedTest @EnumSource(FRUIT.class) void testWithEnumSource(FRUIT fruit) { assertTrue(fruit.name().length() \u003e 3); } } Mockito System Under Test The System Under Test (SUT) refers to the specific part of the software being tested in a given test case. It can range from a single method in unit testing to larger components in integration or system testing based on different context. The SUT is typically isolated using mocking and stubbing to test its behavior independently.\nSHOW CODE Java public class Calculator { public int add(int a, int b) { return a + b; } } public class CalculatorTest { @Test void testAdd() { Calculator calculator = new Calculator(); // SUT int result = calculator.add(2, 3); // The add method is the System Under Test assertEquals(5, result); } } Mocking vs. Stubbing In unit testing, Mocking and Stubbing are used to simulate and control the behavior of external dependencies. Mocking is commonly used for behavior verification, where objects are created to simulate the behavior of real-world components in a controlled manner. On the other hand, Stubbing is typically used to isolate the SUT by controlling the return values or responses from dependencies.\nSHOW CODE: Mocking Java public class Calculator { private Logger logger; public Calculator(Logger logger) { this.logger = logger; } public int add(int a, int b) { int result = a + b; logger.log(\"Addition performed: \" + result); return result; } } @Test void testAdd() { Logger mockLogger = mock(Logger.class); Calculator calculator = new Calculator(mockLogger); calculator.add(2, 3); // Verifying the interaction with the mock: was log method called? verify(mockLogger).log(\"Addition performed: 5\"); } SHOW CODE: Stubbing Java public class Calculator { private DatabaseService databaseService; public Calculator(DatabaseService databaseService) { this.databaseService = databaseService; } public int getProductPrice(int productId) { Product product = databaseService.getProduct(productId); return product.getPrice(); } } @Test void testGetProductPrice() { // Stub the DatabaseService to return a fixed product DatabaseService stubbedService = mock(DatabaseService.class); Product stubProduct = new Product(1, \"Laptop\", 1000); when(stubbedService.getProduct(1)).thenReturn(stubProduct); Calculator calculator = new Calculator(stubbedService); int price = calculator.getProductPrice(1); assertEquals(1000, price); } mock(), when().thenReturn(), verify() In Mockito, the mock() method is used to create a mock object, which allows simulating the behavior of an object without invoking its real methods. The when() method is used to define the behavior of a mock object\u0026rsquo;s method when it is called with specific arguments. The thenReturn() method specifies the return value of a mocked method. The verify() method is used to check whether a specified method on a mock object was called during the test execution.\nSHOW CODE Java import org.junit.jupiter.api.Test; import java.util.List; import static org.junit.jupiter.api.Assertions.assertTrue; import static org.mockito.Mockito.*; public class UnitTest { @Test public void testMockingBehavior() { // Create a mock List object List\u0026lt;String\u0026gt; mockList = mock(List.class); // Specify behavior for when add() is called when(mockList.add(\"Hello\")).thenReturn(true); // Return true when \"Hello\" is added // Call the mock method boolean result = mockList.add(\"Hello\"); // Verify the behavior assertTrue(result); // The add method should return true verify(mockList).add(\"Hello\"); // Verify that add(\"Hello\") was called // Verify that add(\"World\") was never called verify(mockList, never()).add(\"World\"); } } Argument Matchers In Mockito, argument matchers are used to specify conditions for method arguments when stubbing methods. They are commonly used in the when() and thenReturn() methods when the exact method argument is not critical. Some commonly used argument marchers include:\nany(): Matches any argument of the specified type. eq(): Matches a specified argument. anyString(): Matches any argument of type String. anyInt(): Matches any argument of type Integer. isA(): Matches an argument of a specified class type. argThat(): Allows for custom argument matching logic. SHOW CODE Java import org.junit.jupiter.api.Test; import java.util.List; import static org.junit.jupiter.api.Assertions.*; import static org.mockito.ArgumentMatchers.anyInt; import static org.mockito.Mockito.*; public class UnitTest { @Test public void testAnyMatcher() { List mockList = mock(List.class); // Stub behavior using argument matcher when(mockList.get(anyInt())).thenReturn(\"Signal\"); // Verify that any argument passed to get will return \"Signal\" assertEquals(\"Signal\", mockList.get(9)); assertEquals(\"Signal\", mockList.get(999)); } @Test public void testEqMatcher() { Calculator calculator = mock(Calculator.class); when(calculator.add(eq(1), eq(1))).thenReturn(2); assertEquals(2, calculator.add(1, 1)); assertNotEquals(3, calculator.add(1, 1)); } @Test public void testAnyStringMatcher() { // Create a mock List List\u0026lt;String\u0026gt; mockList = mock(List.class); // Stub the method to return \"Hello\" for any string argument when(mockList.contains(anyString())).thenReturn(true); // Verify that the mock returns true for any string passed as an argument assertTrue(mockList.contains(\"Test\")); // Matches any string assertTrue(mockList.contains(\"Hello\")); // Matches any string assertTrue(mockList.contains(\"World\")); // Matches any string } @Test public void testAnyIntMatcher() { // Create a mock List List mockList = mock(List.class); // Stub the method to return \"Found\" for any integer argument when(mockList.get(anyInt())).thenReturn(\"Found\"); // Verify that the mock returns \"Found\" regardless of the argument assertEquals(\"Found\", mockList.get(1)); // Matches any integer assertEquals(\"Found\", mockList.get(999)); // Matches any integer } @Test public void testArgThatMatcher() { // Create a mock List List\u0026lt;String\u0026gt; mockList = mock(List.class); // Use argThat to match arguments that are not null and have length greater than 3 when(mockList.add(argThat(argument -\u003e argument != null \u0026\u0026 argument.length() \u003e 3))) .thenReturn(true); // Verify that the mock behaves correctly assertTrue(mockList.add(\"Hello\")); // Matches: length \u003e 3 assertFalse(mockList.add(\"\")); // Does not match: empty string } } Essential Mockito Annotaitons ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/framework/backend/unit-testing/1-junit-and-mockito-notes/","summary":"JUnit assertEquals In JUnit, assertEquals is a method used to check if the expected value and the actual value are equal in unit tests.\nSHOW CODE Java import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class UnitTest { @Test void addition() { Calculator calculator = new Calculator(); int result = calculator.add(1, 1); assertEquals(2, result, \"The result of 1 + 1 should be 2\"); } } assertTure \u0026amp; assertFalse In JUnit, the assertTrue and the assertFalse methods are used to validate boolean expressions in unit tests.","title":"Junit \u0026 Mockito Notes"},{"content":"JSX JSX (JavaScript XML) is a syntax extension for JavaScript commonly used in React to describe what the UI should look like.\nSHOW CODE React import './App.css' const welcome = { greeting: 'Hey', title: 'React' }; function getName(name) { return name; } function App() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{welcome.greeting} {welcome.title}!\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;I am {getName('Signal')}!\u0026lt;/h1\u0026gt; \u0026lt;label htmlFor=\u0026quot;search\u0026quot;\u0026gt;Search: \u0026lt;/label\u0026gt; \u0026lt;input id=\u0026quot;search\u0026quot; type=\u0026quot;text\u0026quot;\u0026gt;\u0026lt;/input\u0026gt; \u0026lt;/div\u0026gt; ) } export default App List Rendering Rendering a List in React is a common task when dealing with dynamic or repeated data. This typically involves using the map() function. Providing a unique key prop for each rendered item is crucial to avoid unexpected behavior. For static content, the item\u0026rsquo;s index can be used as a key. To enhance redability, it is recommended to move complex inline logic to a seperate function.\nSHOW CODE React import React from \u0026quot;react\u0026quot;; const App = () =\u0026gt; { const users = [ { id: 1, name: \u0026quot;Alice\u0026quot;, age: 25 }, { id: 2, name: \u0026quot;Bob\u0026quot;, age: 30 }, { id: 3, name: \u0026quot;Charlie\u0026quot;, age: 35 }, ]; return ( \u0026lt;ul\u0026gt; {users.map((user) =\u0026gt; ( \u0026lt;li key={user.id}\u0026gt; {user.name} - Age: {user.age} \u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; ); }; export default App; Event Handlers In React, event handlers are used to manage user interactions, such as clicks, input changes, or form submissions.\nSHOW CODE React const Example = () =\u0026gt; { const handleClick = () =\u0026gt; { console.log('Clicked'); }; return \u0026lt;button onClick={handleClick}\u0026gt;Click Me\u0026lt;/button\u0026gt;; }; const handleClick = (id) =\u0026gt; { console.log(`Button ${id} clicked`); }; \u0026lt;button onClick={() =\u0026gt; handleClick(1)}\u0026gt;Click Me\u0026lt;/button\u0026gt;; const handleSubmit = (e) =\u0026gt; { e.preventDefault(); console.log('Form submitted'); }; \u0026lt;form onSubmit={handleSubmit}\u0026gt; \u0026lt;button type=\u0026quot;submit\u0026quot;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt;; Props In React, props (short for properties) are used to pass data from a parent component to a child component. Props are immutable, meaning they cannot be modified by child components. The data flow in React is unidirectional, meaning a praent component can pass data down to its child component, but data cannot flow in the reverse direction.\nSHOW CODE React function ParentComponent() { return \u0026lt;ChildComponent message=\u0026quot;Hello, World!\u0026quot; /\u0026gt;; } function ChildComponent(props) { return \u0026lt;h1\u0026gt;{props.message}\u0026lt;/h1\u0026gt;; } function ChildComponent({ message }) { return \u0026lt;h1\u0026gt;{message}\u0026lt;/h1\u0026gt;; } State In React, state is a built-in object that enables a component to manage its own data. Unlike props, which are immutable, state is mutable, meaning it can be modified by the component itself. State is local to the component, allowing each component to have its own state. When the state changes, React triggers a re-render of the component to update the UI. In functional compoennts, state is typically managed using the useState hook, which takes an initial state value as a parameter and returns an array containing the current state and a function to update the state.\nSHOW CODE React import React, { useState } from 'react'; function Counter() { // Declare a state variable named \u0026quot;count\u0026quot; with an initial value of 0 const [count, setCount] = useState(0); // Function to increment the count const increment = () =\u0026gt; { setCount(count + 1); }; return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count: {count}\u0026lt;/p\u0026gt; \u0026lt;button onClick={increment}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default Counter; ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/framework/front-end/react/1-react-notes/","summary":"JSX JSX (JavaScript XML) is a syntax extension for JavaScript commonly used in React to describe what the UI should look like.\nSHOW CODE React import './App.css' const welcome = { greeting: 'Hey', title: 'React' }; function getName(name) { return name; } function App() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{welcome.greeting} {welcome.title}!\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;I am {getName('Signal')}!\u0026lt;/h1\u0026gt; \u0026lt;label htmlFor=\u0026quot;search\u0026quot;\u0026gt;Search: \u0026lt;/label\u0026gt; \u0026lt;input id=\u0026quot;search\u0026quot; type=\u0026quot;text\u0026quot;\u0026gt;\u0026lt;/input\u0026gt; \u0026lt;/div\u0026gt; ) } export default App List Rendering Rendering a List in React is a common task when dealing with dynamic or repeated data.","title":"React Notes"},{"content":"Virtual DOM A Virtual DOM is a lightweight, in-memory representation of the real DOM. Each Node in the Virtual DOM is represented as a plain JavaScript object with properties describing the element, its attributes, and its children. The Virtual DOM will be updated whenever an application\u0026rsquo;s state changes. It minimizes real DOM updates by batching changes and applying them through an optimized process. --- title: Virtual DOM --- graph TD B[\"\\{tag: 'div'\\}\"] B --\u003e C[\"\\{tag: 'div'\\}\"] B --\u003e D[\"\\{tag: 'div'\\}\"] B --\u003e E[\"\\{tag: 'div'\\}\"] C --\u003e F[\"\\{tag: 'ul'\\}\"] D --\u003e G[\"\\{tag: 'button'\\}\"] E --\u003e H[\"\\{tag: 'text'\\}\"] E --\u003e I[\"\\{tag: 'p'\\}\"] SHOW CODE Virtual DOM Node const vnode = { tag: 'div', // The HTML tag data: { id: 'container', class: 'main' }, // Attributes and properties children: [ { tag: 'p', data: { class: 'text' }, children: ['Hello, Virtual DOM!'], // Text content as a child }, { tag: 'button', data: { onClick: handleClick }, children: ['Click Me'], // Text content inside the button }, ], }; Data Binding The v-bind directive in Vue provides one-way data binding, allows dynamically binding an element\u0026rsquo;s attribute or property to a JavaScript expression. The shorthand for v-bind is a single colon (:).\nSHOW CODE Vue \u0026lt;!-- Full Syntax --\u0026gt; \u0026lt;div v-bind:attribute=\u0026quot;expression\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- Shorthand Syntax --\u0026gt; \u0026lt;div :attribute=\u0026quot;expression\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;img v-bind=\u0026quot;image\u0026quot; /\u0026gt; const app = Vue.createApp({ data() { return { image: { src: \u0026quot;image.jpg\u0026quot;, alt: \u0026quot;A beautiful image\u0026quot;, class: { cat: isVisible, image: !isVisible, } }, isVisible: true }; } }); app.mount('#app'); The v-model directive in Vue is used to create two-way data binding between input form elements and the component\u0026rsquo;s data. Modifiers such as trim and number can be applied to enhance its functionality. When the input data changes, the corresponding component data updates automatically.\nSHOW CODE Vue \u0026lt;input v-model.number=\u0026quot;age\u0026quot; /\u0026gt; \u0026lt;input v-model.trim=\u0026quot;username\u0026quot; /\u0026gt; \u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt; \u0026lt;input v-model=\u0026quot;name\u0026quot; placeholder=\u0026quot;Enter your name\u0026quot; /\u0026gt; \u0026lt;p\u0026gt;Hello, {{ name }}!\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const app = Vue.createApp({ data() { return { name: \u0026quot;\u0026quot; }; } }); app.mount('#app'); \u0026lt;/script\u0026gt; Iterate over Collections The v-for directive in Vue is used to iterate over collections such as arrays or objects in JavaScript. It is crucial that the value assigned to the key attribute is both unique and type of string or number. The key attribute allows Vue to efficently update the DOM by tracking each item, ensuring predictable behavior when the underlying data changes.\nSHOW CODE Vue \u0026lt;li v-for=\u0026quot;(item, index) in items\u0026quot; :key=\u0026quot;index\u0026quot;\u0026gt; {{ index + 1 }}. {{ item }} \u0026lt;/li\u0026gt; data() { return { items: [\u0026quot;Apple\u0026quot;, \u0026quot;Banana\u0026quot;, \u0026quot;Cherry\u0026quot;] }; } \u0026lt;li v-for=\u0026quot;(value, key) in user\u0026quot; :key=\u0026quot;key\u0026quot;\u0026gt; {{ key }}: {{ value }} \u0026lt;/li\u0026gt; data() { return { user: { name: \u0026quot;John\u0026quot;, age: 30, location: \u0026quot;USA\u0026quot; } }; } A common approach to ensure uniqueness is to assign a UUID value to the key attribute.\nAdding Event Listeners to Elements The v-on directive in Vue is used to add event listeners to elements. It listens for DOM events and executes the specified JavaScript function. The shorthand syntax for v-on is @. Vue also provides modifiers like .stop and .prevent to simplify handling common event-related tasks.\nSHOW CODE Vue \u0026lt;!-- Full syntax --\u0026gt; \u0026lt;button v-on:click=\u0026quot;handleClick\u0026quot;\u0026gt;Click Me\u0026lt;/button\u0026gt; \u0026lt;!-- Shorthand syntax --\u0026gt; \u0026lt;button @click=\u0026quot;handleClick\u0026quot;\u0026gt;Click Me\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026quot;handleClick('Hello')\u0026quot;\u0026gt;Click Me\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; export default { methods: { handleClick(message) { console.log(message); // Outputs: Hello } } } \u0026lt;/script\u0026gt; \u0026lt;button @click=\u0026quot;handleClick($event)\u0026quot;\u0026gt;Click Me\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; export default { methods: { handleClick(event) { console.log(event.target); // Logs the clicked element } } } \u0026lt;/script\u0026gt; \u0026lt;!-- Prevent default behavior --\u0026gt; \u0026lt;form @submit.prevent=\u0026quot;handleSubmit\u0026quot;\u0026gt; \u0026lt;button type=\u0026quot;submit\u0026quot;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;!-- keyboard-specific events --\u0026gt; \u0026lt;input @keydown.enter=\u0026quot;submitForm\u0026quot; placeholder=\u0026quot;Press Enter to Submit\u0026quot; /\u0026gt; Event Propagation: The DOM follows a tree-like structure. Events propagate in three phases: starting from the top-most element (document) during the capture phase, moving down to the target element, where the target phase occurs and any associated JavaScript code is executed (if defined), and then propagating back up during the bubbling phase. By default, event listeners in JavaScript and Vue operate in the bubbling phase. However, switching to the capture phase is possible by using the .capture modifier.\nSHOW CODE Vue \u0026lt;button @click.capture=\u0026quot;handleClick\u0026quot;\u0026gt;Click Me\u0026lt;/button\u0026gt; Conditional Rendering Conditional rendering in Vue is typically achieved using the v-if, v-else-if, v-else, and v-show directives. The v-if directive controls the visibility of an element by conditionally mounting or unmounting it from the DOM. The v-else-if and v-else directives are used alongside v-if to create more complex conditional redering logic. In contrast, the v-show directive is useful in scenarios where elements need to be toggled frequently. It works by toggling the CSS display property, meaning the element remains in the DOM even when the condition is false, but its visibility is controlled via CSS.\nSHOW CODE Vue \u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt; \u0026lt;p v-if=\u0026quot;isVisible\u0026quot;\u0026gt;This is visible!\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026quot;toggleVisibility\u0026quot;\u0026gt;Toggle Visibility\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt; \u0026lt;p v-if=\u0026quot;status === 'success'\u0026quot;\u0026gt;Success!\u0026lt;/p\u0026gt; \u0026lt;p v-else-if=\u0026quot;status === 'loading'\u0026quot;\u0026gt;Loading...\u0026lt;/p\u0026gt; \u0026lt;p v-else\u0026gt;Something went wrong.\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026quot;changeStatus\u0026quot;\u0026gt;Change Status\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt; \u0026lt;p v-show=\u0026quot;isVisible\u0026quot;\u0026gt;This is visible!\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026quot;toggleVisibility\u0026quot;\u0026gt;Toggle Visibility\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; v-html The v-html directive is used to bind raw HTML to an element, enabling dynamic rendering of content. It is particularly useful for rendering rich text, such as HTML elements like \u0026lt;strong or \u0026lt;a\u0026gt;. However, using this directive can introduce security risks, as it allows untrusted content or malicoious code (including JavaScript within \u0026lt;script\u0026gt; tags) to be injected into the DOM, making the application vulnerable to XSS (Cross-Site Scripting) attacks. Therefore, it is essential to sanitize any dynamic HTML content before binding it with v-html to prevent such vulnerabilities.\nSHOW CODE Vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p v-html=\u0026quot;content\u0026quot;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { content: '\u0026lt;a href=\u0026quot;https://example.com\u0026quot;\u0026gt;Click here\u0026lt;/a\u0026gt; to visit our site.' }; } } \u0026lt;/script\u0026gt; v-text The v-text directive is used to display plain text by binding a value to an element\u0026rsquo;s text content. Unlike v-html, it escapes any HTML tags and renders the content as plain text. It is useful for text placeholders, as the predefined placeholder text will be replaced once the component has finished loading.\nSHOW CODE Vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p v-text=\u0026quot;message\u0026quot;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { message: 'Hello, \u0026lt;strong\u0026gt;Vue\u0026lt;/strong\u0026gt;!' }; } } \u0026lt;/script\u0026gt; SHOW OUTPUT Output \u0026lt;p\u0026gt;Hello, \u0026lt;strong\u0026gt;Vue\u0026lt;/strong\u0026gt;!\u0026lt;/p\u0026gt; SHOW CODE Vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p v-text=\u0026quot;message\u0026quot;\u0026gt;Placeholder Text\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { message: 'Hello, Vue!' }; } } \u0026lt;/script\u0026gt; The above code will render the application displaying Placeholder Text and will eventually replace it with Hello, Vue! received from message.\nv-once The v-once directive is used to render an element or a component only once. After the initial render, Vue will skip re-rendering it, even if its reactive data changes. This directive is useful for displaying static content, such as headers or footers, that do not change after the initial render.\nSHOW CODE Vue \u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt; \u0026lt;h1 v-once\u0026gt;This header is static and won't re-render\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;{{ message }}\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026quot;changeMessage\u0026quot;\u0026gt;Change Message\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: '#app', data: { message: 'Hello, Vue!' }, methods: { changeMessage() { this.message = 'Message changed!'; } } }); \u0026lt;/script\u0026gt; v-memo The v-memo directive, introduced in Vue 3, optimizes the rendering of DOM elements by memoizing their output based on specified dependencies. When the dependencies remain unchanged, the element will not be re-rendered, improving performance by avoiding unnecessary updates.\nSHOW CODE Vue \u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt; \u0026lt;p v-memo=\u0026quot;[message]\u0026quot;\u0026gt;{{ message }}\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026quot;changeMessage\u0026quot;\u0026gt;Change Message\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: '#app', data: { message: 'Hello, Vue!' }, methods: { changeMessage() { this.message = 'Message changed!'; } } }); \u0026lt;/script\u0026gt; In the above code, \u0026lt;p\u0026gt; tag will not re-rendered unless the message changes.\nRegistering a Global Component In Vue, registering a global component allows it to be used across all instances without needing to import it every time. To register a global component, follow these steps:\nDefine the component – Create the component as a standalone file. Register the component – In the main.js or main.ts file, use app.component to globally register the component. Use the component – After registration, the component can be used in any Vue instance within the application without needing to import it again. SHOW CODE Vue \u0026lt;!-- Define the Component --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Hello from MyComponent!\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: 'MyComponent' } \u0026lt;/script\u0026gt; \u0026lt;!-- Register the component globally --\u0026gt; import { createApp } from 'vue' import App from './App.vue' import MyComponent from './components/MyComponent.vue' const app = createApp(App) // Register MyComponent globally app.component('MyComponent', MyComponent) app.mount('#app') \u0026lt;!-- Use the global component in any template --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;MyComponent /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: 'AnotherComponent' } \u0026lt;/script\u0026gt; ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/framework/front-end/vue/1-vue-notes/","summary":"Virtual DOM A Virtual DOM is a lightweight, in-memory representation of the real DOM. Each Node in the Virtual DOM is represented as a plain JavaScript object with properties describing the element, its attributes, and its children. The Virtual DOM will be updated whenever an application\u0026rsquo;s state changes. It minimizes real DOM updates by batching changes and applying them through an optimized process. --- title: Virtual DOM --- graph TD B[\"","title":"Vue Notes"},{"content":"Generics SHOW CODE Java public class Test { public static void main(String[] args) { List\u0026lt;Integer\u0026gt; intList = List.of(1, 2, 3); // Integer 是 Number 的子类 processItems(\"Hello Integer!\", intList); // Double 是 Number 的子类 processItems(\"Hello, Double!\", List.of(1.1, 2.2, 3.3)); } // 定义泛型方法，T 是任何类型，V 限制为 Number 或其子类 private static \u0026lt;T, V extends Number\u0026gt; void processItems(T item, List\u0026lt;V\u0026gt; nums) { System.out.println(item); for (V num : nums) { System.out.println(\"num: \" + num); } } /** * ? extends 与 ? super 的区别 * 1、? extends T：表示上界通配符，用于类型的上限，只能读取，不能写入。适用于不修改集合内容的情景。 * 2、? super T：表示下界通配符，用于类型的下限，可以写入，适用于添加数据的情景。 */ } Lambda Expression Runnable SHOW CODE Java public class Test { public static void main(String[] args) { // Java 8 之前 Runnable runnable = new Runnable() { @Override public void run() { System.out.println(\"Inside Runnable 1\"); } }; new Thread(runnable).start(); // Java 8 - Lambda 语法 Runnable runnableLambda = () -\u003e {System.out.println(\"Inside Runnable 2\");}; new Thread(runnableLambda).start(); new Thread(() -\u003e System.out.println(\"Inside Runnable 3\")).start(); } } Comparator SHOW CODE Java public class Test { public static void main(String[] args) { // JAVA 8 之前 Comparator\u0026lt;Integer\u0026gt; comparator = new Comparator\u0026lt;Integer\u0026gt;() { @Override public int compare(Integer o1, Integer o2) { /** * o1 \u003c o2 -\u003e -1 * o1 == o2 -\u003e 0 * o1 \u003e o2 -\u003e 1 */ return o1.compareTo(o2); } }; System.out.println(comparator.compare(1, 2)); // -1 /** * JAVA 8 */ // Comparator\u0026lt;Integer\u0026gt; comparatorLambda1 = (Integer a, Integer b) -\u003e a.compareTo(b); Comparator\u0026lt;Integer\u0026gt; comparatorLambda1 = Comparator.naturalOrder(); System.out.println(comparatorLambda1.compare(1, 2)); // -1 // Comparator\u0026lt;Integer\u0026gt; comparatorLambda2 = (a, b) -\u003e b.compareTo(a); Comparator\u0026lt;Integer\u0026gt; comparatorLambda2 = Comparator.reverseOrder(); System.out.println(comparatorLambda2.compare(1, 2)); // 1 int[] nums = new int[]{2, 1, 4, 3}; System.out.println(\"nums = \" + Arrays.toString(nums)); Arrays.sort(nums); // 默认为升序排序 // 倒序排序 Integer[] newNums = Arrays.stream(nums).boxed().toArray(Integer[]::new); Arrays.sort(newNums, Comparator.reverseOrder()); } } Local Variables in Lambda Expression SHOW CODE Java public class Test { public static void main(String[] args) { /** * 1. The variable used in a lambda expression must be effectively final, * meaning its value cannot change after it has been assigned. * 2. A lambda captures the values of local variables, not the variables * themselves. * 3. Local variables in a lambda cannot have the same name as variables * in the enclosing scope to avoid shadowing. */ int num = 10; // effectively final Runnable r = () -\u003e System.out.println(num); r.run(); // Error: Variable num is already defined in the scope // Runnable r = () -\u003e { // int num = 20; // Compile-time error // System.out.println(num); // }; } } Functional Interface Consumer SHOW CODE Java import java.util.Arrays; import java.util.List; import java.util.function.Consumer; public class Test { public static void main(String[] args) { List\u0026lt;String\u0026gt; items = Arrays.asList(\"One\", \"Two\", \"Three\"); /** * Consumer 接收一个参数并执行一些操作，不返回结果 * Consumer 有 accept 和 andThen 两个方法 * accept 用于接收参数，andThen 用于链接多个 Consumer */ // 示例1：定义一个 Consumer，它将打印传入的字符串 Consumer\u0026lt;String\u0026gt; printConsumer = s -\u003e System.out.println(\"打印消息: \" + s); printConsumer.accept(\"Hello, World!\"); // 输出: 打印消息: Hello, World! // 示例 2：Consumer 链式操作 Consumer\u0026lt;String\u0026gt; printItem = item -\u003e System.out.print(\"打印: \" + item + \"\\t\"); Consumer\u0026lt;String\u0026gt; printLength = item -\u003e System.out.println(\"长度: \" + item.length()); Consumer\u0026lt;String\u0026gt; combined = printItem.andThen(printLength); // 将两个 Consumer 组合在一起 // 使用 forEach 遍历集合并执行组合操作 items.forEach(combined); // items.forEach(item -\u003e { // System.out.print(\"打印: \" + item + \"\\t\"); // System.out.println(\"长度: \" + item.length()); // }); } } BiConsumer SHOW CODE Java import java.util.Arrays; import java.util.List; import java.util.function.BiConsumer; // 定义 Student 记录类，包含学生的姓名和活动列表 record Student(String name, List\u0026lt;String\u0026gt; activities) { } //class Student { // private final String name; // private final List\u0026lt;String\u0026gt; activities; // // public Student(String name, List\u0026lt;String\u0026gt; activities) { // this.name = name; // this.activities = activities; // } // // public String getName() { // return name; // } // // public List\u0026lt;String\u0026gt; getActivities() { // return activities; // } //} class StudentDataBase { // 提供学生数据，返回一个包含多个学生的列表 public static List\u0026lt;Student\u0026gt; getAllStudents() { return Arrays.asList( new Student(\"Alice\", Arrays.asList(\"Swimming\", \"Basketball\")), new Student(\"Bob\", Arrays.asList(\"Cycling\", \"Chess\")), new Student(\"Charlie\", Arrays.asList(\"Running\", \"Reading\")) ); } } class Test { public static void main(String[] args) { /** * BiConsumer 适用于对两个参数执行操作，但不需要返回结果的场景。 */ // BiConsumer 接口用于处理学生姓名和活动列表 BiConsumer\u0026lt;\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; studentBiConsumer = (name, activities) -\u003e System.out.println(name + \" : \" + activities); // 获取学生列表 List\u0026lt;Student\u0026gt; students = StudentDataBase.getAllStudents(); // 使用 forEach 遍历每个学生对象并输出其姓名和活动列表 students.forEach(student -\u003e studentBiConsumer.accept(student.name(), student.activities())); } } Predicate SHOW CODE Java import java.util.Arrays; import java.util.List; import java.util.function.Predicate; class Test { public static void main(String[] args) { /* Predicate 用于测试输入对象是否满足某种条件，常用于过滤、条件判断等场景 Predicate 提供了 and, or 和 negate 三个默认方法 Predicate 提供了 isEqual 和 not (Java 11) 两个静态方法 */ // 示例 1: Predicate\u0026lt;Integer\u0026gt; isEven = num -\u003e num % 2 == 0; List\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6); List\u0026lt;Integer\u0026gt; evenNumbers = numbers.stream() .filter(isEven) .toList(); System.out.println(\"偶数: \" + evenNumbers); // 输出: 偶数: [2, 4, 6] // 示例 2: Predicate\u0026lt;Integer\u0026gt; isOdd = num -\u003e num % 2 == 0; Predicate\u0026lt;Integer\u0026gt; isGreaterThanFive = num -\u003e num \u003e 5; // 使用 and() 方法组合两个条件 Predicate\u0026lt;Integer\u0026gt; isOddAndGreaterThanFive = isOdd.and(isGreaterThanFive); System.out.println(isOddAndGreaterThanFive.test(7)); // 输出: true System.out.println(isOddAndGreaterThanFive.test(3)); // 输出: false // 示例 3 List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\", \"Alice\"); // 使用 isEqual 和 not 来筛选出不等于 \"Alice\" 的名字 List\u0026lt;String\u0026gt; filteredNames = names.stream() .filter(Predicate.not(Predicate.isEqual(\"Alice\"))) .toList(); System.out.println(filteredNames); // Output: [Bob, Charlie] } } BiPredicate SHOW CODE Java import java.util.function.BiPredicate; class Test { public static void main(String[] args) { // BiPredicate 适合需要对两个参数进行测试或判断的情况 // 示例 1 BiPredicate\u0026lt;Integer, Integer\u0026gt; isSumGreaterThanTen = (a, b) -\u003e (a + b) \u003e 10; BiPredicate\u0026lt;Integer, Integer\u0026gt; isProductEven = (a, b) -\u003e (a * b) % 2 == 0; BiPredicate\u0026lt;Integer, Integer\u0026gt; combined = isSumGreaterThanTen.and(isProductEven); System.out.println(combined.test(5, 6)); // 输出: true，因为和大于10且乘积为偶数 System.out.println(combined.test(5, 5)); // 输出: false，因为乘积为奇数 } } Function SHOW CODE Java import java.util.function.Function; class Test { public static void main(String[] args) { /** * Function 接受一个参数并返回一个结果 * apply(T t)：对给定的参数执行函数操作并返回结果 * andThen()：在当前函数之后执行另一个函数 * compose()：在当前函数之前执行另一个函数 */ // 示例 1 Function\u0026lt;Integer, Integer\u0026gt; squareFunction = x -\u003e x * x; Integer result = squareFunction.apply(5); System.out.println(\"5 的平方是: \" + result); // 示例 2 Function\u0026lt;Integer, Integer\u0026gt; multiplyBy2 = x -\u003e x * 2; Function\u0026lt;Integer, Integer\u0026gt; add3 = x -\u003e x + 3; // 使用 andThen：先乘以 2，再加 3 Integer result1 = multiplyBy2.andThen(add3).apply(5); System.out.println(\"(5 * 2) + 3 的结果是: \" + result1); // 使用 compose：先加 3，再乘以 2 Integer result2 = multiplyBy2.compose(add3).apply(5); System.out.println(\"(5 + 3) * 2 的结果是: \" + result2); } } BiFunction SHOW CODE Java import java.util.function.BiFunction; class Test { public static void main(String[] args) { // BiFunction takes two arguments and returns a result BiFunction\u0026lt;Integer, Integer, Integer\u0026gt; sum = (a, b) -\u003e a + b; int result = sum.apply(5, 3); // Returns 8 System.out.println(\"Result: \" + result); } } Method Reference SHOW CODE Java import java.util.Arrays; import java.util.List; import java.util.function.Function; import java.util.function.Supplier; public class Test { public static void main(String[] args) { /** * Method reference is a shortcut for writing the lambda function */ // 示例 1 List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"); // 使用 Lambda 表达式 names.stream().map(name -\u003e name.toUpperCase()).forEach(name -\u003e System.out.println(name)); // 使用Method Reference names.stream().map(String::toUpperCase).forEach(System.out::println); /** * 构造器引用是Method Reference的特例 * 用法如下： * () -\u003e new Person() \u003c--\u003e Person::new; * (name) -\u003e new Person() \u003c--\u003e Person::new; */ // 示例 2 // Using () -\u003e new Person() Supplier\u0026lt;Person\u0026gt; personSupplier = () -\u003e new Person(); Person p1 = personSupplier.get(); System.out.println(p1); // Output: Person{name='Default'} // Using Person::new Supplier\u0026lt;Person\u0026gt; personSupplierRef = Person::new; Person p2 = personSupplierRef.get(); System.out.println(p2); // Output: Person{name='Default'} // 示例 3 // Using (name) -\u003e new Person(name) Function\u0026lt;String, Person\u0026gt; personFunction = (name) -\u003e new Person(name); Person p3 = personFunction.apply(\"Alice\"); System.out.println(p3); // Output: Person{name='Alice'} // Using Person::new Function\u0026lt;String, Person\u0026gt; personFunctionRef = Person::new; Person p4 = personFunctionRef.apply(\"Bob\"); System.out.println(p4); // Output: Person{name='Bob'} } } class Person { private String name; // Default constructor public Person() { this.name = \"Default\"; } // Constructor with a parameter public Person(String name) { this.name = name; } @Override public String toString() { return \"Person{name='\" + name + \"'}\"; } } Stream API Introduction to Stream API A Stream is a sequence of elements designed for processing in a functional and sequential manner. Stream operations are lazy, meaning they are not executed until a terminal operation (e.g., collect, forEach, reduce, count) is invoked. Streams are immutable, allowing access to elements without modifying the source. Java provides two types of streams: stream (for sequential processing) and parallel stream (for concurrent processing).\nCollections V.S. Stream\nIn Java, Collections are data structures designed for storing and manipulating data, whereas Streams are a sequence of elements which enable functional-style operations on data. Collections allow data modification, whereas Streams provide read-only access to elements. Operations on Collections are executed eagerly, while Streams operations are lazy and only executed when a terminal operation is invoked. Collections can be reused multiple times, but Streams are single-use and cannot be reused after processing. Debugging Streams: the peek() method can be used to inspect the intermediate results during stream operations.\nArrays.asList(\u0026#34;hello\u0026#34;, \u0026#34;hi\u0026#34;).stream() .peek(System.out::println) .filter(s -\u0026gt; s.length() \u0026gt; 2) .peek(s -\u0026gt; System.out.println(\u0026#34;Filtered: \u0026#34; + s)) .map(String::toUpperCase) .peek(s -\u0026gt; System.out.println(\u0026#34;Mapped: \u0026#34; + s)) .collect(Collectors.toList()); hello Filtered: hello Mapped: HELLO hi flatMap The flatMap method is used to transform each element in a stream into another stream and then flatten the resulting streams into a single stream.\nSHOW CODE Java import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class Test { public static void main(String[] args) { List\u0026lt;List\u0026lt;String\u0026gt; nestedList = Arrays.asList( Arrays.asList(\"A\", \"B\"), Arrays.asList(\"C\", \"D\"), Arrays.asList(\"E\", \"F\") ); List\u0026lt;String\u0026gt; flattenedList = nestedList.stream() .flatMap(List::stream) // Flatten the nested lists .map(String::toLowerCase) // Convert each string to lowercase .collect(Collectors.toList()); System.out.println(flattenedList); // Output: [a, b, c, d, e, f] } } The map method transforms each element into another type, while the flatMap method transforms and flaten streams into a single stream.\ndistinct(), count(), sorted() The distinct() method eliminates duplicate elements from the stream. The count() method calculates the total number of elements in the stream. The sorted() method sorts the elements of the stream.\nSHOW CODE Java List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Alice\", \"Charlie\"); long count = names.stream() .distinct() // Optional: Count unique elements .count(); System.out.println(count); // Output: 3 List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"); List\u0026lt;String\u0026gt; sortedByLength = names.stream() .sorted(Comparator.comparingInt(String::length)) .collect(Collectors.toList()); System.out.println(sortedByLength); // Output: [Bob, Alice, Charlie] reduce() The reduce() method in Java 8 Streams is a terminal operation used to combine elements in a stream into a single result by repeatedly applying a binary operator.\nSHOW CODE Java // Summing numbers List\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5); int sum = numbers.stream().reduce(0, Integer::sum); System.out.println(sum); // Output: 15 // Finding maximum values List\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5); int max = numbers.stream().reduce(Integer.MIN_VALUE, Integer::max); System.out.println(max); // Output: 5 // Concatenating Strings List\u0026lt;String\u0026gt; words = Arrays.asList(\"Java\", \"Stream\", \"Reduce\"); String concatenated = words.stream().reduce(\"\", String::concat); System.out.println(concatenated); // Output: JavaStreamReduce // Product of numbers List\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4); int product = numbers.stream().reduce(1, (a, b) -\u003e a * b); System.out.println(product); // Output: 24 limit(), skip() The limit() method retrieves a specified number of elements from a stream. The skip() method discards the first specified number of elements in a stream.\nSHOW CODE Java List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\", \"David\", \"Eve\"); List\u0026lt;String\u0026gt; paginatedNames = names.stream() .skip(2) // Skip the first 2 elements .limit(2) // Take the next 2 elements .collect(Collectors.toList()); System.out.println(paginatedNames); // Output: [Charlie, David] allMatch(), anyMatch(), noneMatch() The allMatch() method verifies if all elements in a stream satisfy the given predicate. The anyMatch() method determines if any element in the stream matches the specified predicate. The noneMatch() method confirms if no element in the stream matches the specified predicate.\nSHOW CODE Java List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"); // Check if all names are longer than 3 characters boolean allLongNames = names.stream().allMatch(name -\u003e name.length() \u003e 3); System.out.println(allLongNames); // Output: true // Check if any name starts with 'A' boolean anyStartsWithA = names.stream().anyMatch(name -\u003e name.startsWith(\"A\")); System.out.println(anyStartsWithA); // Output: true // Check if no name is shorter than 3 characters boolean noneShortNames = names.stream().noneMatch(name -\u003e name.length() \u003c 3); System.out.println(noneShortNames); // Output: true findAny(), findFirst() The findAny() method retrieves an arbitrary element from a stream, particularly useful for parallel processing. The findFirst() method fetches the first element from a stream based on its encounter order.\nSHOW CODE Java List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"); Optional\u0026lt;String\u0026gt; anyName = names.stream().findAny(); System.out.println(anyName.orElse(\"No names found\")); // Output: Alice (or any other element) List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"); Optional\u0026lt;String\u0026gt; firstName = names.stream().findFirst(); System.out.println(firstName.orElse(\"No names found\")); // Output: Alice Factory Methods: Of(), generate(), iterate() Stream.of() is used to create a stream from a fixed set of elements.\nSHOW CODE Java import java.util.stream.Stream; public class Main { public static void main(String[] args) { Stream\u0026lt;String\u0026gt; stream = Stream.of(\"Apple\", \"Banana\", \"Cherry\"); stream.forEach(System.out::println); } } Stream.generate() method is used to create an infinite stream of elements generated by a Supplier.\nSHOW CODE Java import java.util.stream.Stream; public class Main { public static void main(String[] args) { Stream\u0026lt;String\u0026gt; infiniteStream = Stream.generate(() -\u003e \"Hello\"); infiniteStream.limit(5).forEach(System.out::println); } } Stream.iterate() is used to create an infinite stream by applying a function repeatedly to a seed value.\nSHOW CODE Java import java.util.Random; Stream\u0026lt;Integer\u0026gt; randomNumbers = Stream.generate(() -\u003e new Random().nextInt(100)); randomNumbers.limit(5).forEach(System.out::println); When working with infinite streams, such as those created by Stream.generate() or Stream.iterate(), always use operations like limit() to prevent infinite processing.\nTerminal Operations: joining(), counting(), mapping() The joining method is a terminal operation used to concatenate the elements of a stream into a single String. By default, the elements are joined without a delimiter, but a custom delimiter, prefix, and suffix can also be specified.\nSHOW CODE Java import java.util.*; import java.util.stream.Collectors; public class JoiningExample { public static void main(String[] args) { List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"); // Simple joining String result1 = names.stream().collect(Collectors.joining()); System.out.println(result1); // AliceBobCharlie // Joining with a delimiter String result2 = names.stream().collect(Collectors.joining(\", \")); System.out.println(result2); // Alice, Bob, Charlie // Joining with delimiter, prefix, and suffix String result3 = names.stream().collect(Collectors.joining(\", \", \"[\", \"]\")); System.out.println(result3); // [Alice, Bob, Charlie] } } The counting() method is a terminal operation used to count the number of elements in a stream and return the count as a long.\nSHOW CODE Java import java.util.*; import java.util.stream.Collectors; public class CountingExample { public static void main(String[] args) { List\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5); // Counting the elements in the stream long count = numbers.stream().collect(Collectors.counting()); System.out.println(count); // 5 } } The mapping() method is an intermediate collector that applies a function to the elements of a stream before passing the transformed elements to another collector for final processing.\nSHOW CODE Java import java.util.*; import java.util.stream.Collectors; public class MappingExample { public static void main(String[] args) { List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"); // Convert names to uppercase and join them String result = names.stream() .collect(Collectors.mapping(String::toUpperCase, Collectors.joining(\", \"))); System.out.println(result); // ALICE, BOB, CHARLIE } } Terminal Operations: minBy(), maxBy(), groupingBy() The minBy() collector finds the minimum element in a stream based on a specified Comparator and returns the result as an Optional.\nSHOW CODE Java Optional min = Stream.of(3, 5, 1, 2) .collect(Collectors.minBy(Comparator.naturalOrder())); System.out.println(min.orElse(-1)); // Output: 1 The maxBy() collector finds the maximum element in a stream based on a specified Comparator and returns the result as an Optional.\nSHOW CODE Java Optional max = Stream.of(3, 5, 1, 2) .collect(Collectors.maxBy(Comparator.naturalOrder())); System.out.println(max.orElse(-1)); // Output: 5 The groupingBy() collector groups the elements of a stream based on a classification function and returns the grouped data as a Map.\nSHOW CODE Java Map\u0026lt;Integer, List\u0026lt;String\u0026gt;\u0026gt; groupedByLength = Stream.of(\"cat\", \"dog\", \"bird\", \"fox\") .collect(Collectors.groupingBy(String::length)); System.out.println(groupedByLength); // Output: {3=[cat, dog, fox], 4=[bird]} Numeric Stream A Numeric Stream in Java is a specialized type of stream that operates specifically on numeric values. There are three types of numeric streams: IntStream, LongStream, and Double Stream, which handle int, long, and double values, respectively. Numeric streams eliminate the overhead of autoboxing and provide commonly used methods such as sum() and max() for performing operations on numeric data, making them more efficient compared to regular Stream types.\nSHOW CODE Java IntStream.range(1, 5).forEach(System.out::println); // Output: 1 2 3 4 IntStream.rangeClosed(1, 5).forEach(System.out::println); // Output: 1 2 3 4 5 long count = IntStream.range(1, 10).count(); System.out.println(count); // Output: 9 int sum = IntStream.range(1, 5).sum(); System.out.println(sum); // Output: 10 (1 + 2 + 3 + 4) OptionalInt max = IntStream.range(1, 5).max(); max.ifPresent(System.out::println); // Output: 4 OptionalInt min = IntStream.range(1, 5).min(); min.ifPresent(System.out::println); // Output: 1 OptionalDouble average = IntStream.range(1, 5).average(); average.ifPresent(System.out::println); // Output: 2.5 List\u0026lt;String\u0026gt; numbers = Arrays.asList(\"1\", \"2\", \"3\", \"4\"); IntStream intStream = numbers.stream().mapToInt(Integer::parseInt); intStream.forEach(System.out::println); // Output: 1, 2, 3, 4 List\u0026lt;String\u0026gt; numbers = Arrays.asList(\"1.1\", \"2.2\", \"3.3\", \"4.4\"); DoubleStream doubleStream = numbers.stream().mapToDouble(Double::parseDouble); doubleStream.forEach(System.out::println); // Output: 1.1, 2.2, 3.3, 4.4 List\u0026lt;String\u0026gt; numbers = Arrays.asList(\"10\", \"20\", \"30\", \"40\"); LongStream longStream = numbers.stream().mapToLong(Long::parseLong); longStream.forEach(System.out::println); // Output: 10, 20, 30, 40 IntStream intStream = IntStream.range(1, 5); Stream\u0026lt;String\u0026gt; stringStream = intStream.mapToObj(Integer::toString); stringStream.forEach(System.out::println); // Output: \"1\", \"2\", \"3\", \"4\" ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/programming/java/1-java-programming-notes/","summary":"Generics SHOW CODE Java public class Test { public static void main(String[] args) { List\u0026lt;Integer\u0026gt; intList = List.of(1, 2, 3); // Integer 是 Number 的子类 processItems(\"Hello Integer!\", intList); // Double 是 Number 的子类 processItems(\"Hello, Double!\", List.of(1.1, 2.2, 3.3)); } // 定义泛型方法，T 是任何类型，V 限制为 Number 或其子类 private static \u0026lt;T, V extends Number\u0026gt; void processItems(T item, List\u0026lt;V\u0026gt; nums) { System.out.println(item); for (V num : nums) { System.out.println(\"num: \" + num); } } /** * ?","title":"Java Programming Notes"}]