[{"content":"2024 Be cautious in both speech and action.\nFirst things first.\nAvoid living a life of suffering.\nOpportunity favors the prepared mind.\nFocus on your own matters, respect others\u0026rsquo; choices, and live in harmony with destiny.\nLife is the process of cultivating your soul.\nThink first, act later.\nSpeak less of what\u0026rsquo;s unnecessary, do less of what\u0026rsquo;s pointless, and waste less energy on what\u0026rsquo;s unimportant.\nIn times of peace, prepare for challenges.\nHope for the best, but always plan for the unexpected.\n","permalink":"https://signalyu.github.io/posts/3-humanities/personal-growth/1-mottos/","summary":"2024 Be cautious in both speech and action.\nFirst things first.\nAvoid living a life of suffering.\nOpportunity favors the prepared mind.\nFocus on your own matters, respect others\u0026rsquo; choices, and live in harmony with destiny.\nLife is the process of cultivating your soul.\nThink first, act later.\nSpeak less of what\u0026rsquo;s unnecessary, do less of what\u0026rsquo;s pointless, and waste less energy on what\u0026rsquo;s unimportant.\nIn times of peace, prepare for challenges.","title":"Mottos"},{"content":"Database Design Introduction to Databases A database is a collection of data that is stored, managed, and accessed electronically. It typically contains one or more tables, which resemble Excel or Google sheets, with data organized into rows and columns. As the number of tables grows, managing the database can become complex, making it essential to design a scalable and maintainable strucutre.\nDatabases canbe broadly categoried into two types: Relational database, primarily used for real-time data updates and transactions. and data warehouse, optimized for data analysis and reporting purposes.\nData Modeling Data modeling is the process of creating a conceptual representation of data structures, relationships, and rule to meet business requirements. It serves as a blueprint for designing and managing a database.\nThere are three types of data models: conceptual, logical, and physical. The conceptual data model provides a high-level overview, specifying relationships between objects without technical details. The logical data model refine the conceptual data model by adding more detail, such as fields for each object. The physical data model describe the internal schema of the database, including table structures, storage details, and implementation specifics.\n--- title: Conceptual Data Model --- erDiagram Customer ||--o{ Order : places Order ||--|{ Product : contains --- title: Logical Data Model --- erDiagram Customer { int customerId string name string email } Order { int orderId date orderDate float totalAmount } Product { int productId string productName float price } Customer ||--o{ Order : places Order ||--|{ Product : contains --- title: Physical Data Model --- erDiagram Customer { int customerId PK varchar name varchar email } Order { int orderId PK date orderDate float totalAmount int customerId FK } Product { int productId PK varchar productName decimal price } OrderItem { int orderItemId PK int orderId FK int productId FK int quantity } Customer ||--o{ Order : places Order ||--|{ OrderItem : includes OrderItem ||--|{ Product : contains Design Process ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/database/1-database-notes/","summary":"Database Design Introduction to Databases A database is a collection of data that is stored, managed, and accessed electronically. It typically contains one or more tables, which resemble Excel or Google sheets, with data organized into rows and columns. As the number of tables grows, managing the database can become complex, making it essential to design a scalable and maintainable strucutre.\nDatabases canbe broadly categoried into two types: Relational database, primarily used for real-time data updates and transactions.","title":"Database Notes"},{"content":"Core Concepts Loose Coupling Loose Coupling is a design principle that aims to reduce the dependencies between components within a system.\nInversion of Control (IoC) Inversion of Control is a design principle where the control of object creation and lifecycle management is transferred from the application code to an external container or framework.\nDependency Injection (DI) Dependency Injection is a design pattern commonly used in object-oriented programming, where the dependecies of a class are provided externally rather than being created within the class itself.\nBeans Beans are objects that are managed by the Spring framework.\nContainer A Spring Container is responsible for managing the life cycle, configuration, and dependencies injection of the beans in a Spring Application.\nLife Cycle of Beans Beans are objects that are managed by the Spring framework. Bean Definition includes configuration meta data required by the Spring container to create and manage the bean. Bean Configurations can be provided in various way, including XML configuration files, annotations, and Java-based configuration. Bean Instantiation $\\rightarrow$ Population of Properties $\\rightarrow$ Initialization $\\rightarrow$ Ready for Use $\\rightarrow$ Destruction The Difference between instantiation and initiation?\nInstantiation occurs when a new keyword is used to create an object. It focus on constructing the object\u0026rsquo;s structure and allocating memory. In contrast, initialization focus on assigning values to the object\u0026rsquo;s fields and setting up its initial state after instantiation.\nConstructor Injection \u0026amp; Setter Injection \u0026amp; Field Injection Constructor Injection Constructor Injection in Spring is a type of dependency injection where the Spring framework provides the required dependency to a class by invoking its constructor. Since dependencies are supplied via the constructor, they cannot be changed after object creation \u0026ndash; promoting immutability. However, this approach may cause circular dependency issues if two or more beans depend on each other in a circular manner.\nSHOW CODE Java @Component public class ServiceA { private final RepositoryA repositoryA; // Constructor injection @Autowired public ServiceA(RepositoryA repositoryA) { this.repositoryA = repositoryA; } } Setter Injection Setter Injection in Spring is a form of dependency injection where the Spring framework injects dependencies into a bean by calling the bean\u0026rsquo;s setter method. This approach is flexible and commonly used to inject optional dependencies or when the dependency might change after the object is initialized.\nSHOW CODE Java @Component public class ServiceB { private RepositoryB repositoryB; // Setter injection @Autowired public void setRepositoryB(RepositoryB repositoryB) { this.repositoryB = repositoryB; } } Field Injection Field Injection in Spring is a form of dependency injection where the Spring framework directly injects dependencies into a class\u0026rsquo;s fields. Like constructor injection, the dependencies remain immutable after being injected. Under the hood. Spring uses reflection to assign values to private fields.\nSHOW CODE Java @Component public class ServiceC { @Autowired private RepositoryC repositoryC; public void performAction() { repositoryC.doSomething(); } } @Component \u0026amp; @ComponentScan The @Component annotation in Spring is used to mark a class as spring-managed bean, allowing Spring to detect and register it as a bean in the application context. The @ComponentScan annotation is used to specify base packages that Spring should scan for @Component-annotated during configuration.\nSHOW CODE Java package com.example.myapp @Component public class MyService { public void performTask() { System.out.println(\"Task performed!\"); } } @Configuration @ComponentScan(basePackages = \"com.example.myapp\") public class AppConfig { } @Value \u0026amp; @Autowired \u0026amp; @Qualifier @Value The @Value annotation is used to inject values into fields, mathod parameters, and constructor arguments.\nSHOW CODE Java // Injects literal values @Value(\"Hello, World!\") private String message; // Injects from a properties file app.name=MySpringApp @Value(\"${app.name}\") private String appName; // Injects default values @Value(\"${app.version:1.0.0}\") private String appVersion; // Injects expression @Value(\"#{T(java.lang.Math).random() * 100}\") private double randomValue; @Autowired The @Autowired annotation is used for automatic dependency injection. It allows Spring resolve and inject the required bean into a class automatically by type.\nSHOW CODE Java // Field Injection @Component public class ServiceA { @Autowired private RepositoryA repositoryA; public void performTask() { repositoryA.doSomething(); } } // Setter Injection @Component public class ServiceB { private RepositoryB repositoryB; @Autowired public void setRepositoryB(RepositoryB repositoryB) { this.repositoryB = repositoryB; } } // Constructor Injection @Component public class ServiceB { private RepositoryB repositoryB; @Autowired public void setRepositoryB(RepositoryB repositoryB) { this.repositoryB = repositoryB; } } @Qualifier The @Qualifier annotation in Spring is used for resolve ambiguities when multiple beans of the same type are available in the application context.\nSHOW CODE Java @Component(\"repositoryImpl1\") public class RepositoryImpl1 implements Repository {} @Component(\"repositoryImpl2\") public class RepositoryImpl2 implements Repository {} @Component public class Service { @Autowired @Qualifier(\"repositoryImpl2\") private Repository repository; } Components of Spring Boot Spring Boot Starter: Simplifies dependency management by building commonly used dependencies, reducing the need for manual configuration.\nAuto Configuration: Automatically configures Spring Boot application beans and settings based on the libraries on the classpath, eliminating the need for extensive configuration in application.properties or XML files.\nSpring Boot Atuator: Provides production-ready features like monitoring, metrics, and health checks to ensure better application insights and management.\nEmbedded Server: Includes servers like Tomcat and Jetty, allowing applications to run as standalone programs, simplifying development and deployment.\nSpring Boot DevTools: A collection of tools that enhance the development experience by enabling features like hot reload and live reload for faster feedback.\nSpring Boot Auto Configuration Common Annotations Transformation between Object and Spring In Spring Boot, the transformation between objects and JSON is handled by the Jackson library which allows for easy serialization (converting an object to JSON) and deserialization (converting JSON to an object).\nSHOW CODE Java // When a controller returns an object, Spring Boot automatically // converts it to JSON @RestController public class UserController { @GetMapping(\"/user\") public User getUser() { return new User(1, \"John Doe\", \"john.doe@example.com\"); } } // When accessed via /user, the response is: { \"id\": 1, \"name\": \"John Doe\", \"email\": \"john.doe@example.com\" } // Spring Boot automatically converts the incoming JSON data into // an object when the object is a parameter in the controller method. @RestController public class UserController { @PostMapping(\"/user\") public String createUser(@RequestBody User user) { return \"User \" + user.getName() + \" created!\"; } } // Input JOSN: { \"id\": 2, \"name\": \"Jane Doe\", \"email\": \"jane.doe@example.com\" } ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/framework/backend/spring/1-spring-notes/","summary":"Core Concepts Loose Coupling Loose Coupling is a design principle that aims to reduce the dependencies between components within a system.\nInversion of Control (IoC) Inversion of Control is a design principle where the control of object creation and lifecycle management is transferred from the application code to an external container or framework.\nDependency Injection (DI) Dependency Injection is a design pattern commonly used in object-oriented programming, where the dependecies of a class are provided externally rather than being created within the class itself.","title":"Spring Notes"},{"content":"Virtual DOM A Virtual DOM is a lightweight, in-memory representation of the real DOM. Each Node in the Virtual DOM is represented as a plain JavaScript object with properties describing the element, its attributes, and its children. The Virtual DOM will be updated whenever an application\u0026rsquo;s state changes. It minimizes real DOM updates by batching changes and applying them through an optimized process. --- title: Virtual DOM --- graph TD B[\"\\{tag: 'div'\\}\"] B --\u003e C[\"\\{tag: 'div'\\}\"] B --\u003e D[\"\\{tag: 'div'\\}\"] B --\u003e E[\"\\{tag: 'div'\\}\"] C --\u003e F[\"\\{tag: 'ul'\\}\"] D --\u003e G[\"\\{tag: 'button'\\}\"] E --\u003e H[\"\\{tag: 'text'\\}\"] E --\u003e I[\"\\{tag: 'p'\\}\"] SHOW CODE Virtual DOM Node const vnode = { tag: 'div', // The HTML tag data: { id: 'container', class: 'main' }, // Attributes and properties children: [ { tag: 'p', data: { class: 'text' }, children: ['Hello, Virtual DOM!'], // Text content as a child }, { tag: 'button', data: { onClick: handleClick }, children: ['Click Me'], // Text content inside the button }, ], }; Data Binding The v-bind directive in Vue provides one-way data binding, allows dynamically binding an element\u0026rsquo;s attribute or property to a JavaScript expression. The shorthand for v-bind is a single colon (:).\nSHOW CODE Vue \u0026lt;!-- Full Syntax --\u0026gt; \u0026lt;div v-bind:attribute=\u0026quot;expression\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- Shorthand Syntax --\u0026gt; \u0026lt;div :attribute=\u0026quot;expression\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;img v-bind=\u0026quot;image\u0026quot; /\u0026gt; const app = Vue.createApp({ data() { return { image: { src: \u0026quot;image.jpg\u0026quot;, alt: \u0026quot;A beautiful image\u0026quot;, class: { cat: isVisible, image: !isVisible, } }, isVisible: true }; } }); app.mount('#app'); The v-model directive in Vue is used to create two-way data binding between input form elements and the component\u0026rsquo;s data. Modifiers such as trim and number can be applied to enhance its functionality. When the input data changes, the corresponding component data updates automatically.\nSHOW CODE Vue \u0026lt;input v-model.number=\u0026quot;age\u0026quot; /\u0026gt; \u0026lt;input v-model.trim=\u0026quot;username\u0026quot; /\u0026gt; \u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt; \u0026lt;input v-model=\u0026quot;name\u0026quot; placeholder=\u0026quot;Enter your name\u0026quot; /\u0026gt; \u0026lt;p\u0026gt;Hello, {{ name }}!\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const app = Vue.createApp({ data() { return { name: \u0026quot;\u0026quot; }; } }); app.mount('#app'); \u0026lt;/script\u0026gt; Iterate over Collections The v-for directive in Vue is used to iterate over collections such as arrays or objects in JavaScript. It is crucial that the value assigned to the key attribute is both unique and type of string or number. The key attribute allows Vue to efficently update the DOM by tracking each item, ensuring predictable behavior when the underlying data changes.\nSHOW CODE Vue \u0026lt;li v-for=\u0026quot;(item, index) in items\u0026quot; :key=\u0026quot;index\u0026quot;\u0026gt; {{ index + 1 }}. {{ item }} \u0026lt;/li\u0026gt; data() { return { items: [\u0026quot;Apple\u0026quot;, \u0026quot;Banana\u0026quot;, \u0026quot;Cherry\u0026quot;] }; } \u0026lt;li v-for=\u0026quot;(value, key) in user\u0026quot; :key=\u0026quot;key\u0026quot;\u0026gt; {{ key }}: {{ value }} \u0026lt;/li\u0026gt; data() { return { user: { name: \u0026quot;John\u0026quot;, age: 30, location: \u0026quot;USA\u0026quot; } }; } A common approach to ensure uniqueness is to assign a UUID value to the key attribute.\nAdding Event Listeners to Elements The v-on directive in Vue is used to add event listeners to elements. It listens for DOM events and executes the specified JavaScript function. The shorthand syntax for v-on is @. Vue also provides modifiers like .stop and .prevent to simplify handling common event-related tasks.\nSHOW CODE Vue \u0026lt;!-- Full syntax --\u0026gt; \u0026lt;button v-on:click=\u0026quot;handleClick\u0026quot;\u0026gt;Click Me\u0026lt;/button\u0026gt; \u0026lt;!-- Shorthand syntax --\u0026gt; \u0026lt;button @click=\u0026quot;handleClick\u0026quot;\u0026gt;Click Me\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026quot;handleClick('Hello')\u0026quot;\u0026gt;Click Me\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; export default { methods: { handleClick(message) { console.log(message); // Outputs: Hello } } } \u0026lt;/script\u0026gt; \u0026lt;button @click=\u0026quot;handleClick($event)\u0026quot;\u0026gt;Click Me\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; export default { methods: { handleClick(event) { console.log(event.target); // Logs the clicked element } } } \u0026lt;/script\u0026gt; \u0026lt;!-- Prevent default behavior --\u0026gt; \u0026lt;form @submit.prevent=\u0026quot;handleSubmit\u0026quot;\u0026gt; \u0026lt;button type=\u0026quot;submit\u0026quot;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;!-- keyboard-specific events --\u0026gt; \u0026lt;input @keydown.enter=\u0026quot;submitForm\u0026quot; placeholder=\u0026quot;Press Enter to Submit\u0026quot; /\u0026gt; Event Propagation: The DOM follows a tree-like structure. Events propagate in three phases: starting from the top-most element (document) during the capture phase, moving down to the target element, where the target phase occurs and any associated JavaScript code is executed (if defined), and then propagating back up during the bubbling phase. By default, event listeners in JavaScript and Vue operate in the bubbling phase. However, switching to the capture phase is possible by using the .capture modifier.\nSHOW CODE Vue \u0026lt;button @click.capture=\u0026quot;handleClick\u0026quot;\u0026gt;Click Me\u0026lt;/button\u0026gt; Conditional Rendering Conditional rendering in Vue is typically achieved using the v-if, v-else-if, v-else, and v-show directives. The v-if directive controls the visibility of an element by conditionally mounting or unmounting it from the DOM. The v-else-if and v-else directives are used alongside v-if to create more complex conditional redering logic. In contrast, the v-show directive is useful in scenarios where elements need to be toggled frequently. It works by toggling the CSS display property, meaning the element remains in the DOM even when the condition is false, but its visibility is controlled via CSS.\nSHOW CODE Vue \u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt; \u0026lt;p v-if=\u0026quot;isVisible\u0026quot;\u0026gt;This is visible!\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026quot;toggleVisibility\u0026quot;\u0026gt;Toggle Visibility\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt; \u0026lt;p v-if=\u0026quot;status === 'success'\u0026quot;\u0026gt;Success!\u0026lt;/p\u0026gt; \u0026lt;p v-else-if=\u0026quot;status === 'loading'\u0026quot;\u0026gt;Loading...\u0026lt;/p\u0026gt; \u0026lt;p v-else\u0026gt;Something went wrong.\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026quot;changeStatus\u0026quot;\u0026gt;Change Status\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt; \u0026lt;p v-show=\u0026quot;isVisible\u0026quot;\u0026gt;This is visible!\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026quot;toggleVisibility\u0026quot;\u0026gt;Toggle Visibility\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; v-html The v-html directive is used to bind raw HTML to an element, enabling dynamic rendering of content. It is particularly useful for rendering rich text, such as HTML elements like \u0026lt;strong or \u0026lt;a\u0026gt;. However, using this directive can introduce security risks, as it allows untrusted content or malicoious code (including JavaScript within \u0026lt;script\u0026gt; tags) to be injected into the DOM, making the application vulnerable to XSS (Cross-Site Scripting) attacks. Therefore, it is essential to sanitize any dynamic HTML content before binding it with v-html to prevent such vulnerabilities.\nSHOW CODE Vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p v-html=\u0026quot;content\u0026quot;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { content: '\u0026lt;a href=\u0026quot;https://example.com\u0026quot;\u0026gt;Click here\u0026lt;/a\u0026gt; to visit our site.' }; } } \u0026lt;/script\u0026gt; v-text The v-text directive is used to display plain text by binding a value to an element\u0026rsquo;s text content. Unlike v-html, it escapes any HTML tags and renders the content as plain text. It is useful for text placeholders. as the predefined placeholder text will be replaced once the component has finished loading.\nSHOW CODE Vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p v-text=\u0026quot;message\u0026quot;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { message: 'Hello, \u0026lt;strong\u0026gt;Vue\u0026lt;/strong\u0026gt;!' }; } } \u0026lt;/script\u0026gt; SHOW OUTPUT Output \u0026lt;p\u0026gt;Hello, \u0026lt;strong\u0026gt;Vue\u0026lt;/strong\u0026gt;!\u0026lt;/p\u0026gt; SHOW CODE Vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p v-text=\u0026quot;message\u0026quot;\u0026gt;Placeholder Text\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { message: 'Hello, Vue!' }; } } \u0026lt;/script\u0026gt; The above code will render the application displaying Placeholder Text and will eventually replace it with Hello, Vue! received from message.\n","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/framework/front-end/vue/1-vue-notes/","summary":"Virtual DOM A Virtual DOM is a lightweight, in-memory representation of the real DOM. Each Node in the Virtual DOM is represented as a plain JavaScript object with properties describing the element, its attributes, and its children. The Virtual DOM will be updated whenever an application\u0026rsquo;s state changes. It minimizes real DOM updates by batching changes and applying them through an optimized process. --- title: Virtual DOM --- graph TD B[\"","title":"Vue Notes"},{"content":"Recursion Recursion is a programming technique where a function repeatedly calls itself until it reaches a base case, whcih stops the recursion and allows it to return a result. It is a way of breaking down complex problems into smaller, simpler subproblems that are eaiser to solve.\nHead Recursion Head Recursion is a type of recursion where a function makes its recursive call first, immediately after checking the base case, and performs all other operations only after the recursive call returns.\nSHOW CODE: Head Recursion Head Recursion void printNumbers(int n) { if (n == 0) { return; // Base case } printNumbers(n - 1); // Recursive call printf(\"%d\\n\", n); // Processing after recursion } Call Stack Operation Current Value of n headRecursion(3) Call function 3 headRecursion(2) Call function 2 headRecursion(1) Call function 1 headRecursion(0) Base case, exit 0 Unwinding begins: printf(1) Print 1 1 printf(2) Print 2 2 printf(3) Print 3 3 Tail Recursion Tail Recursion is a type of recursion where a function makes its recursive call as the last operation in its body. with no further operations after the call. This type of recursion can be optimized by the compiler into an iterative loop through tail call optimization (TCO), which help reduce memory consumption by the reusing the stack frame.\nSHOW CODE: Tail Recursion Tail Recursion void tailRecursion(int n) { if (n \u003e 0) { printf(\"%d \", n); // Operation first tailRecursion(n - 1); // Recursive call at the end } } Call Stack Operation Current Value of n tailRecursion(3) Print 3 3 tailRecursion(2) Print 2 2 tailRecursion(1) Print 1 1 tailRecursion(0) Base case, exit 0 Tail recursion is generally perfered for performance when recursion depth is large because it can be optimized into an iterative process.\nSHOW CODE: Tail Recursion Optimization Tail Recursion Optimization void tailRecursionOptimized(int n) { while (n \u003e 0) { printf(\"%d \", n); // Operation first n--; // Decrement n, same as `tailRecursion(n - 1)` } } In the above code, optimized Loop replaces recursion with a loop, ensuring only a single stack frame is used.\nConditions for Tail Recursion: The recursive call must be the last operation in the function, and its result must be immediately returned without any further computation after the call.\nSHOW CODE: Tail Recursive Function Tail Recursive Function // Tail recursive function to calculate factorial int factorialTailRecursion(int n, int accumulator) { if (n == 0) { return accumulator; // Base case: return accumulated result } return factorialTailRecursion(n - 1, accumulator * n); // Recursive call is the last operation } SHOW CODE: Non-tail Recursive Function Non-tail recursive // Non-tail recursive function to calculate factorial int factorialNonTailRecursion(int n) { if (n == 0) { return 1; // Base case } return n * factorialNonTailRecursion(n - 1); // Recursive call is not the last operation } Tree Recursion Tree recursion is a type of recursion in which a function makes multiple recursive calls to itself in its body, it creates a tree-like data structure, as each call can branch into multiple additional calls.\nSHOW CODE C public int fib(int n) { if (n \u003c= 1) { return n; } return fib(n - 1) + fib(n - 2); } Recursion Tree Analysis:\n--- title: Recursion Tree Analysis - fibonacci sequence --- graph TD L0((\"fib\\(5\\)\")) --\u003e L1((\"fib\\(4\\)\")) L0 --\u003e L2((\"fib\\(3\\)\")) L1 --\u003e L3((\"fib\\(3\\)\")) L1 --\u003e L4((\"fib\\(2\\)\")) L2 --\u003e L5((\"fib\\(2\\)\")) L2 --\u003e L6((\"fib\\(1\\)\")) L3 --\u003e L7((\"fib\\(2\\)\")) L3 --\u003e L8((\"fib\\(1\\)\")) L4 --\u003e L9((\"fib\\(1\\)\")) L4 --\u003e L10((\"fib\\(0\\)\")) L5 --\u003e L11((\"fib\\(1\\)\")) L5 --\u003e L12((\"fib\\(0\\)\")) L7 --\u003e L13((\"fib\\(1\\)\")) L7 --\u003e L14((\"fib\\(0\\)\")) Array An array is a data structure that stores a collection of elements of the same type in a fixed-size, continguous block of memory. Arrays can be categorized into two types: static arrays and dynamic arrays.\nA static array has a fixed size that cannot be changed after its declaration. Memory for a static array is allocated at compile time, and its size must be explicitly specified.\nIn contrast, a dynamic array allows its size to be adjusted during runtime, enabling it to grow or shrink as needed. Unlike static arrays, the size of a dynamic array does not need to be specified at the time of declaration, and memory is allocated dynamically from the heap.\nImplementation of Static Arrays Implementation of Dynamic Arrays Compiler\u0026rsquo;s Memory Layout for Arrays The address of an array element is determined at runtime. Array elements are stored in a continguous block of memory, and the compiler calculates each element\u0026rsquo;s address using its index and the size of each element.\n1-Dimentional Array Element Access Formula (0-based index): $\\text{Addr}_{A[i]} = B + i \\times W$\nB: Base Address i: Zero-based Index of Each Element W: Size of Each Element SHOW CODE C #include \u0026lt;stdio.h\u0026gt; int main() { int arr[5] = {10, 20, 30, 40, 50}; for (int i = 0; i \u003c 5; i++) { void *addr_i = (void *) arr + (i * sizeof(int)); printf(\"Element at index %d: %d \\t Address: %p\\n\", i, arr[i], addr_i); } return 0; } SHOW OUTPUT Output Element at index 0: 10 Address: 0x7ff7bb0b7170 Element at index 1: 20 Address: 0x7ff7bb0b7174 Element at index 2: 30 Address: 0x7ff7bb0b7178 Element at index 3: 40 Address: 0x7ff7bb0b717c Element at index 4: 50 Address: 0x7ff7bb0b7180 2-Dimentional Array Element Access Formula (Row Major Order): $\\text{Addr}_{A[i][j]} = \\text{B} + [(i \\times \\text{C}) + j] \\times \\text{W}$\nB: Base Address i: Zero-based Row Index of Each Element j: Zero-based Column Index of Each ELement C: Number of Columns W: Size of Each Element SHOW CODE C #include \u0026lt;stdio.h\u0026gt; int main() { int arr[2][3] = {{1, 2, 3}, {4, 5, 6}}; for (int i = 0; i \u003c 2; i++) { for (int j = 0; j \u003c 3; j++) { void *addr_ij = (void *) \u0026arr + (i * 3 + j) * sizeof(int); printf(\"Element at [%d][%d]: %d, Address: %p\\n\", i, j, arr[i][j], addr_ij); } } return 0; } SHOW OUTPUT Output Element at [0][0]: 1, Address: 0x7ff7b2c64170 Element at [0][1]: 2, Address: 0x7ff7b2c64174 Element at [0][2]: 3, Address: 0x7ff7b2c64178 Element at [1][0]: 4, Address: 0x7ff7b2c6417c Element at [1][1]: 5, Address: 0x7ff7b2c64180 Element at [1][2]: 6, Address: 0x7ff7b2c64184 Why do most compilers use 0-based indexing? Take a 1-dimentional array as an example, the element access formula for a 0-based index is $\\text{Addr}_{A[i]} = B + i \\times W$. This formula requires two operations (multiplication and addition) to access each element in the array.\nIn contract, the formula for 1-based indexing is $\\text{Addr}_{A[i]} = B + (i - 1) \\times W$. This requires three operations (multiplication. subtraction, and addition). Compared to 0-based indexing, 1-based indexing introduces one additional operation, which becomes a significant overhead when dealing with large size arrays.\nString Matrix Linked List Stack Queue Tree Graph A graph is a fundamental data structure used to represent the connections or relationships between entities. It consists of vertices (also called node) and edges (also called arcs). A vertex represents a single entity in the graph, while an edge represents a connection or relationship between two vertices. Edges may have additional properties, such as weight (to indicate the cost or distance of the connection) or direction (to indicate the direction of the relationship).\nTypes of Graph Undirected Graph vs. Directed Graph In an undirected graph, the connection between two vertices is bidrectional. For example, if there is an edge between vertex A and vertex B, traversal is possible from A to B and from B to A. In contrast, in a directed graph, the relationships are one-way. For instance, if there is an edge from vertex A to vertex B, traversal is possible from A to B, but not from B to A unless there is a separate edge in the opposite direction.\nUnweighted Graph vs. Weighted Graph In an unweighted graph, the relationships between vertices have no additional properties, and all edges are treated equally. In contrast, a weighted graph assigns a weight to each node, which can represent attributes such as distance, time, cost, eetc. The weight provides more information about the connection between vertices and is often used in problems like shortest path or network flow.\nCyclic Graph vs. Acyclic Graph A cyclic graph contains at least one cycle, which is a path that starts and ends at the same vertex. In contrast, an acyclic graph doest not contain any cycles. A special case of an acyclic graph is the directed acyclic graph (DAG), which has directed edges and no cycles.\nConnected Graph vs. Disconnected Graph A connected graph is a graph in which there is a path between every pair of vertices. In contrast, a disconnected graph is a graph where at least one pair of vertices is not connected by any path.\nGraph Terminology The degree of a vertex is the number of edges incident to that vertex. In an undirected graph, the degree is simply the number of edges connected to the vertex. In a directed graph, the degree is the sum of the in-degree (number of incoming edges) and the out-degree (number of outgoing edges) of the vertex.\nA path is a sequence of vertices where each consecutive pair of vertices is connected by an edge.\nA cycle is a path that starts and ends at the same vertex, with no repeated vertices except for the starting or ending vertex. For example, in a cycle with $A \\rightarrow B \\rightarrow C \\rightarrow D \\rightarrow A$, the path starts and ends at the same vertex $A$, but each of the other vertices $(B, C, and D)$ is visited exactly once.\nConnectivity refers to whether there exists a path between any pair of vertices in the graph.\nA subgraph is a graph formd by a subset of the vertices and edges of the original graph.\nA component is a subgraph where there is a path between every pair of vertices in that subgraph.\nGraph Representation Adjacency Matrix An Adjacency Matrix ia a 2-dimentional array where each element at position [i][j] represents an edge between vertex i and j. In a weighted graph, the value at position [i][j] stores the weight of the edge between the two vertices. In an unweight graph, the value at position [i][j] typically stores 1 to indicate an edge exists between the vertices, and 0 to indicate no edge exists. The space complexity of an adjacency matrix is $O(V^2)$, where $V$ is the number of vertices, as it requires a matrix of size $V \\times V$ to represent the graph.\nAdjacency List An Adjacency List is a collection of lists, where each position i stores a list of nerighbors of vertex i. In a weighted graph. each element in the list typically represents a pair (neighbor, weight), where neighbor is a vertex connected to i, and weight is the weight of the edge between i and neighbor. The space complexity of an adjacency list is $O(V + E)$, where $V$ is the number of vertices and $E$ is the number of edges. This is because each vertex has a list of neighbors, and the total number of entries in all lists is proportional to the number of edges.\nEdge List An Edge List is a collection of pairs, where each pair (i, j) represents an edge between vertex i and vertex j. In a weighted graph. each element may also include the weight of the edge. typically represented as (i, j, weight). The space complexity of an edge list is $O(E)$, where $E$ is the number of edges, as each edge is stored as a separate entry in the list.\nGraph Traversal Breadth First Search Breadth-First Search (BFS) explores all the neighbors of a vertex before moving on to their neighbors. It proceeds level by level, ensuring that all vertices at a given distance from the starting vertex are visited before moving on to vertices at a greater distance. BFS is commonly used to find the shortest path in an unweighted graph.\nDepth First Search Depth-First Search (DFS) explores as far as possible alone a branch of the graph before backtracking to explore other branches. It follows a path from the starting vertex to a dead end, then retrace its steps and explores alternative paths. DFS is useful for finding all paths between vertices, detecting cycles, or performing topological sorting in directed acyclic graphs (DAGs).\nSpanning Tree A spanning tree is a subset of a graph that includes all the vertices and contains exactly $V - 1$ edges, where $V$ is the number of vertices in the graph. A connected graph can have multiple spanning trees, whereas a disconnected graph does not have a spanning tree because there is at least one pair of vertices that are not connected, making it impossible to form a tree that spans all the vertices.\nMinimum Spanning Tree (MST) A minimum spanning tree is a type of spanning tree that connects all the vertices of a graph with the smallest possible total edge weight, compared to all other possible spanning trees.\nMST Algorithms ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/1-data-structure-and-algorithms/","summary":"Recursion Recursion is a programming technique where a function repeatedly calls itself until it reaches a base case, whcih stops the recursion and allows it to return a result. It is a way of breaking down complex problems into smaller, simpler subproblems that are eaiser to solve.\nHead Recursion Head Recursion is a type of recursion where a function makes its recursive call first, immediately after checking the base case, and performs all other operations only after the recursive call returns.","title":"Data Structure \u0026 Algorithms"},{"content":"1. Solid Principle 1.1 Single Responsibility Principle A class should have only one reason to change, meaning each class should focus on a single functionality or responsibility.\nSHOW CODE Single Responsibility Principle import java.io.IOException; import java.util.*; import java.util.regex.*; import com.fasterxml.jackson.databind.ObjectMapper; /** * 1. User class is only used to represent entity. * 2. UserValidator class is solely responsible for validating user objects. * 3. Store class is only used to manage user objects storage. * 4. UserPersistenceService class is dedicated to save the user data. * 5. UserController is solely used to handle incoming requests (in this case, creating users form JSON input). */ /* \u0026lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.18.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; */ /** * Represents a user with basic details. * User class is only used to represent entity. */ class User { private String name; private String email; private String address; public User() {} public User(String name, String email, String address) { this.name = name; this.email = email; this.address = address; } // Getters and setters public String getName() { return name; } public void setName(String name) { this.name = name; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } @Override public String toString() { return \"User [name=\" + name + \", email=\" + email + \", address=\" + address + \"]\"; } } /** * Handles incoming JSON requests that work on User. * UserController is solely used to handle incoming requests (in this case, creating users form JSON input). */ class UserController { private final UserPersistenceService persistenceService = new UserPersistenceService(); public String createUser(String userJson) throws IOException { ObjectMapper mapper = new ObjectMapper(); User user = mapper.readValue(userJson, User.class); UserValidator validator = new UserValidator(); if (!validator.validateUser(user)) { return \"ERROR\"; } persistenceService.saveUser(user); return \"SUCCESS\"; } } /** * Handles persistence of User objects. * UserPersistenceService class is dedicated to save the user data. */ class UserPersistenceService { private final Store store = new Store(); public void saveUser(User user) { store.store(user); } } /** * Validates User data. * UserValidator class is solely responsible for validating user objects. */ class UserValidator { public boolean validateUser(User user) { if (!isPresent(user.getName()) || !isValidAlphaNumeric(user.getName())) { return false; } user.setName(user.getName().trim()); user.setEmail(user.getEmail().trim()); return isValidEmail(user.getEmail()); } private boolean isPresent(String value) { return value != null \u0026\u0026 value.trim().length() \u003e 0; } private boolean isValidAlphaNumeric(String value) { Pattern pattern = Pattern.compile(\"[^A-Za-z0-9]\"); Matcher matcher = pattern.matcher(value); return !matcher.find(); } private boolean isValidEmail(String value) { Pattern pattern = Pattern.compile(\"^[\\\\w-\\\\.]+@[\\\\w-]+(\\\\.[\\\\w-]+)+$\"); Matcher matcher = pattern.matcher(value); return matcher.find(); } } /** * Stores User data in memory. * Store class is only used to manage user objects storage. */ class Store { private static final Map\u0026lt;String, User\u0026gt; STORAGE = new HashMap\u003c\u003e(); public void store(User user) { synchronized (STORAGE) { STORAGE.put(user.getName(), user); } } public User getUser(String name) { synchronized (STORAGE) { return STORAGE.get(name); } } } /** * Main class for demonstrating the Single Responsibility Principle. */ public class Main { private static final String VALID_USER_JSON = \"{\\\"name\\\": \\\"Signal\\\", \\\"email\\\": \\\"signalyu999@gmail.com\\\", \\\"address\\\":\\\"999 Sugar lane\\\"}\"; private static final String INVALID_USER_JSON = \"{\\\"name\\\": \\\"Sam\\\", \\\"email\\\": \\\"sam@email\\\", \\\"address\\\":\\\"111 Sugar lane\\\"}\"; public static void main(String[] args) throws IOException { UserController controller = new UserController(); String response = controller.createUser(VALID_USER_JSON); System.out.println(\"Valid JSON response: \" + response); response = controller.createUser(INVALID_USER_JSON); System.out.println(\"Invalid JSON response: \" + response); } } Each class in the above code strictly adheres to the Single Responsibility Principle by focusing on a specific responsibility:\nUser for representing the user entity UserController for request handling UserPersistenceService for data persistence UserValidator for user data validation Store for managing in-memory data storage --- title: Single Responsibility Principle - Class Diagram --- classDiagram class User { - String name - String email - String address + String toString() } class Store { + void store(User user) + User getUser(String name) } class UserPersistenceService { + void saveUser(User user) } class UserValidator { - boolean isPresent(String value) - boolean isValidAlphaNumeric(String value) - boolean isValidEmail(String value) + boolean validateUser(User user) } class UserController { + String createUser(String userJson) } class Main { + void main(String[] args) } User --* Store Store --* UserPersistenceService UserPersistenceService --* UserController UserController --\u003e UserValidator : create Main --\u003e UserController : create 1.2 Open-Closed Principle A software entity (class, module, function, etc.) should be open for extension but closed for modification.\n点击查看代码 Java import java.time.LocalDateTime; import java.util.*; // Abstract base class, closed for modification but open for extension abstract class Subscriber { protected Long subscriberId; protected String address; protected Long phoneNumber; protected int baseRate; // Getter and Setter methods public Long getSubscriberId() { return subscriberId; } public void setSubscriberId(Long subscriberId) { this.subscriberId = subscriberId; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } public Long getPhoneNumber() { return phoneNumber; } public void setPhoneNumber(Long phoneNumber) { this.phoneNumber = phoneNumber; } public int getBaseRate() { return baseRate; } public void setBaseRate(int baseRate) { this.baseRate = baseRate; } // Abstract method to calculate the bill; implementation is defined in subclasses public abstract double calculateBill(); } // PhoneSubscriber class extends Subscriber, calculates the phone bill class PhoneSubscriber extends Subscriber { @Override public double calculateBill() { List\u0026lt;CallHistory.Call\u0026gt; calls = CallHistory.getCurrentCalls(subscriberId); long totalDuration = calls.stream().mapToLong(CallHistory.Call::getDuration).sum(); return (totalDuration * baseRate) / 100.0; } } // ISPSubscriber class extends Subscriber, calculates the internet bill class ISPSubscriber extends Subscriber { private long freeUsage; // Free usage limit in data units @Override public double calculateBill() { List\u0026lt;InternetSessionHistory.InternetSession\u0026gt; sessions = InternetSessionHistory.getCurrentSessions(subscriberId); long totalData = sessions.stream().mapToLong(InternetSessionHistory.InternetSession::getDataUsed).sum(); long chargeableData = totalData - freeUsage; return chargeableData \u003c= 0 ? 0 : (chargeableData * baseRate) / 100.0; } public long getFreeUsage() { return freeUsage; } public void setFreeUsage(long freeUsage) { this.freeUsage = freeUsage; } } // InternetSessionHistory class to manage internet usage records class InternetSessionHistory { public static class InternetSession { private final LocalDateTime begin; private final Long subscriberId; private final Long dataUsed; public InternetSession(Long subscriberId, LocalDateTime begin, long dataUsed) { this.subscriberId = subscriberId; this.begin = begin; this.dataUsed = dataUsed; } public LocalDateTime getBegin() { return begin; } public long getDataUsed() { return dataUsed; } public Long getSubscriberId() { return subscriberId; } } private static final Map\u0026lt;Long, List\u0026lt;InternetSession\u0026gt;\u0026gt; SESSIONS = new HashMap\u0026lt;\u0026gt;(); // Retrieves the current sessions for a subscriber, returns an empty list if none found public static synchronized List\u0026lt;InternetSession\u0026gt; getCurrentSessions(Long subscriberId) { return SESSIONS.getOrDefault(subscriberId, Collections.emptyList()); } // Adds a new internet session record for a subscriber public static synchronized void addSession(Long subscriberId, LocalDateTime begin, long dataUsed) { SESSIONS.computeIfAbsent(subscriberId, k -\u003e new LinkedList\u0026lt;\u0026gt;()).add(new InternetSession(subscriberId, begin, dataUsed)); } } // CallHistory class to manage call records class CallHistory { public static class Call { private final LocalDateTime begin; private final long duration; private final Long subscriberId; public Call(Long subscriberId, LocalDateTime begin, long duration) { this.subscriberId = subscriberId; this.begin = begin; this.duration = duration; } public LocalDateTime getBegin() { return begin; } public long getDuration() { return duration; } public Long getSubscriberId() { return subscriberId; } } private static final Map\u0026lt;Long, List\u0026lt;Call\u0026gt; CALLS = new HashMap\u0026lt;\u0026gt;(); // Retrieves the current calls for a subscriber, returns an empty list if none found public static synchronized List\u0026lt;Call\u0026gt; getCurrentCalls(Long subscriberId) { return CALLS.getOrDefault(subscriberId, Collections.emptyList()); } // Adds a new call record for a subscriber public static synchronized void addSession(Long subscriberId, LocalDateTime begin, long duration) { CALLS.computeIfAbsent(subscriberId, k -\u003e new LinkedList\u0026lt;\u0026gt;()).add(new Call(subscriberId, begin, duration)); } } public class Main { public static void main(String[] args) { // Initialize PhoneSubscriber and ISPSubscriber with sample data PhoneSubscriber phoneSubscriber = new PhoneSubscriber(); phoneSubscriber.setSubscriberId(1L); phoneSubscriber.setBaseRate(10); ISPSubscriber ispSubscriber = new ISPSubscriber(); ispSubscriber.setSubscriberId(2L); ispSubscriber.setBaseRate(5); ispSubscriber.setFreeUsage(1000); // Add call records for PhoneSubscriber CallHistory.addSession(1L, LocalDateTime.now().minusMinutes(5), 300); // 300 seconds call CallHistory.addSession(1L, LocalDateTime.now().minusMinutes(10), 600); // 600 seconds call // Calculate and print the phone subscriber's bill double phoneBill = phoneSubscriber.calculateBill(); System.out.println(\"Phone Subscriber's Bill: \" + phoneBill); // Add internet session records for ISPSubscriber InternetSessionHistory.addSession(2L, LocalDateTime.now().minusHours(1), 500); // 500 data units InternetSessionHistory.addSession(2L, LocalDateTime.now().minusHours(2), 800); // 800 data units // Calculate and print the ISP subscriber's bill double ispBill = ispSubscriber.calculateBill(); System.out.println(\"ISP Subscriber's Bill: \" + ispBill); } } The above code demonstrates the Open/Closed Principle (OCP) by separating the base Subscriber class from its specific implementations, PhoneSubscriber and ISPSubscriber, allowing for new functionalities to be added without modifying the existing code structure.\nClosed for Modification: The Subscriber base class is closed for modification. It defines common properties (like subscriberId, address, and baseRate) and an abstract calculateBill method that acts as a placeholder for billing logic. This base class remains unchanged even as new types of subscribers or billing strategies are introduced.\nOpen for Extension: The calculateBill method in Subscriber can be extended by subclasses, like PhoneSubscriber and ISPSubscriber, to implement custom billing calculations. Each subclass overrides calculateBill according to its unique billing requirements (e.g., PhoneSubscriber calculates based on call duration, while ISPSubscriber uses data usage with free data allowances). This enables additional subscriber types to be created without altering the base class or existing subclasses.\nFlexible to New Requirements: By following OCP, any new type of subscriber can be added—such as PremiumSubscriber or CorporateSubscriber—with its own billing logic without affecting the existing structure. This ensures that the core system remains stable, extensible, and easily maintainable as new features or subscriber types are introduced.\n--- title: Open Closed Principle - Class Diagram --- classDiagram class Subscriber { +Long subscriberId +String address +Long phoneNumber +int baseRate +double calculateBill() } class PhoneSubscriber { +double calculateBill() } class ISPSubscriber { +double calculateBill() +long freeUsage +void setFreeUsage(long freeUsage) +long getFreeUsage() } Subscriber \u003c|-- PhoneSubscriber Subscriber \u003c|-- ISPSubscriber 1.3 Liskov Substitution Principle Objects of a superclass should be replaceable with objects of a subclass without altering the correctness of the program.\nSHOW CODE: Violation of LSP Violation of LSP package dev.signalyu.solid.lsp; class Rectangle { private int width; private int height; public Rectangle(int width, int height) { this.width = width; this.height = height; } public int getWidth() { return width; } public void setWidth(int width) { this.width = width; } public int getHeight() { return height; } public void setHeight(int height) { this.height = height; } public int computeArea() { return width * height; } } class Square extends Rectangle { public Square(int side) { super(side, side); } @Override public void setWidth(int width) { setSide(width); } @Override public void setHeight(int height) { setSide(height); } public void setSide(int side) { super.setWidth(side); super.setHeight(side); } } public class Main { public static void main(String[] args) { Rectangle rectangle = new Rectangle(10, 20); System.out.println(rectangle.computeArea()); // 200 = 10 * 20 Square square = new Square(10); System.out.println(square.computeArea()); // 100 = 10 * 10 useRectangle(rectangle); System.out.println(rectangle.computeArea()); // 600 = 20 * 30 useRectangle(square); // Violates Liskov Substitution Principle System.out.println(square.computeArea()); // 900 = 30 * 30 } private static void useRectangle(Rectangle rectangle) { rectangle.setHeight(20); rectangle.setWidth(30); assert rectangle.getHeight() == 20 : \"Height Not equal to 20\"; assert rectangle.getWidth() == 30 : \"Width Not equal to 30\"; } } In the above code, the useRectangle method assumes that it can independently set the width and height of a Rectangle. However, when a Square (a subclass of Rectangle) object is passed to it, unexpected behavior will occur.\nSHOW CODE: After Refactoring After Refactoring package dev.signalyu.solid.lsp; interface Shape { int computeArea(); } class Rectangle implements Shape { private int width; private int height; public Rectangle(int width, int height) { this.width = width; this.height = height; } public int getWidth() { return width; } public void setWidth(int width) { this.width = width; } public int getHeight() { return height; } public void setHeight(int height) { this.height = height; } @Override public int computeArea() { return width * height; } } class Square implements Shape { private int side; public Square(int side) { this.side = side; } public void setSide(int side) { this.side = side; } public int getSide() { return side; } @Override public int computeArea() { return side * side; } } public class Main { public static void main(String[] args) { Rectangle rectangle = new Rectangle(10, 20); System.out.println(rectangle.computeArea()); Square square = new Square(10); System.out.println(square.computeArea()); useRectangle(rectangle); } private static void useRectangle(Rectangle rectangle) { rectangle.setHeight(20); rectangle.setWidth(30); assert rectangle.getHeight() == 20 : \"Height Not equal to 20\"; assert rectangle.getWidth() == 30 : \"Width Not equal to 30\"; } } After refactoring, the useRectangle method is now dedicated exclusively to the Rectangle class.\n1.4 Interface Segregation Principle No client should be forced to depend on methods it does not use.\nSHOW CODE: Violation of ISP Violation of ISP package dev.signalyu.solid.isp; import java.time.LocalDateTime; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.stream.Collectors; // Abstract Entity Class abstract class Entity { private Long id; public Long getId() { return id; } public void setId(Long id) { this.id = id; } } // Order Entity class Order extends Entity { private LocalDateTime orderPlacedOn; private double totalValue; public LocalDateTime getOrderPlacedOn() { return orderPlacedOn; } public void setOrderPlacedOn(LocalDateTime orderPlacedOn) { this.orderPlacedOn = orderPlacedOn; } public double getTotalValue() { return totalValue; } public void setTotalValue(double totalValue) { this.totalValue = totalValue; } } // User Entity class User extends Entity { private String name; private LocalDateTime lastLogin; public String getName() { return name; } public void setName(String name) { this.name = name; } public LocalDateTime getLastLogin() { return lastLogin; } public void setLastLogin(LocalDateTime lastLogin) { this.lastLogin = lastLogin; } } // Persistence Service Interface interface PersistenceService\u0026lt;T extends Entity\u0026gt; { void save(T entity); void delete(T entity); T findById(Long id); /** * ISP VIOLATION!!! * * Order entity doesn't have a name property and hence doesn't * need to implement the findByName method */ List findByName(String name); } // User Persistence Service class UserPersistenceService implements PersistenceService\u0026lt;User\u0026gt; { private static final Map\u0026lt;Long, User\u0026gt; USERS = new HashMap\u0026lt;\u0026gt;(); @Override public void save(User entity) { synchronized (USERS) { USERS.put(entity.getId(), entity); } } @Override public void delete(User entity) { synchronized (USERS) { USERS.remove(entity.getId()); } } @Override public User findById(Long id) { synchronized (USERS) { return USERS.get(id); } } @Override public List findByName(String name) { synchronized (USERS) { return USERS.values().stream() .filter(u -\u003e u.getName().equalsIgnoreCase(name)) .collect(Collectors.toList()); } } } The above code violates the Interface Segregation Principle because the PersistenceService interface defines methods that are not applicable to all entities. For instance, the Order entity does not have a name property and therefore does not require the findByName method.\nSHOW CODE: After Refactoring After Refactoring import java.time.LocalDateTime; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.stream.Collectors; // Abstract Entity Class abstract class Entity { private Long id; public Long getId() { return id; } public void setId(Long id) { this.id = id; } } // User Entity class User extends Entity { private String name; private LocalDateTime lastLogin; public String getName() { return name; } public void setName(String name) { this.name = name; } public LocalDateTime getLastLogin() { return lastLogin; } public void setLastLogin(LocalDateTime lastLogin) { this.lastLogin = lastLogin; } } // Order Entity class Order extends Entity { private LocalDateTime orderPlacedOn; private double totalValue; public LocalDateTime getOrderPlacedOn() { return orderPlacedOn; } public void setOrderPlacedOn(LocalDateTime orderPlacedOn) { this.orderPlacedOn = orderPlacedOn; } public double getTotalValue() { return totalValue; } public void setTotalValue(double totalValue) { this.totalValue = totalValue; } } // Persistence Service Interface interface PersistenceService\u0026lt;T extends Entity\u0026gt; { void save(T entity); void delete(T entity); T findById(Long id); } // Order Persistence Service class OrderPersistenceService implements PersistenceService\u0026lt;Order\u0026gt; { private static final Map\u0026lt;Long, Order\u0026gt; ORDERS = new HashMap\u0026lt;\u0026gt;(); @Override public void save(Order entity) { synchronized (ORDERS) { ORDERS.put(entity.getId(), entity); } } @Override public void delete(Order entity) { synchronized (ORDERS) { ORDERS.remove(entity.getId()); } } @Override public Order findById(Long id) { synchronized (ORDERS) { return ORDERS.get(id); } } } // User Persistence Service class UserPersistenceService implements PersistenceService\u0026lt;User\u0026gt; { private static final Map\u0026lt;Long, User\u0026gt; USERS = new HashMap\u0026lt;\u0026gt;(); @Override public void save(User entity) { synchronized (USERS) { USERS.put(entity.getId(), entity); } } @Override public void delete(User entity) { synchronized (USERS) { USERS.remove(entity.getId()); } } @Override public User findById(Long id) { synchronized (USERS) { return USERS.get(id); } } public List findByName(String name) { synchronized (USERS) { return USERS.values().stream() .filter(u -\u003e u.getName().equalsIgnoreCase(name)) .collect(Collectors.toList()); } } } After refactoring, the PersistenceService interface includes only the generic methods (save, findById, and delete) that are applicable to all entities.\n1.5 Dependency Inversion Principle High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions\nSHOW CODE: Violation of DIP Violation of DIP package dev.signalyu.solid.dip; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.ObjectMapper; import java.io.FileWriter; import java.io.IOException; import java.io.PrintWriter; import java.time.LocalDateTime; import java.time.ZoneId; // Common interface for classes formatting Message object interface Formatter { String format(Message message) throws FormatException; } // Thrown by formatter class FormatException extends IOException { public FormatException(Exception cause) { super(cause); } } // Formats message to JSON format class JSONFormatter implements Formatter { public String format(Message message) throws FormatException { ObjectMapper mapper = new ObjectMapper(); try { return mapper.writeValueAsString(message); } catch (JsonProcessingException e) { e.printStackTrace(); throw new FormatException(e); } } } // Message class with content and timestamp class Message { private String msg; private LocalDateTime timestamp; public Message(String msg) { this.msg = msg; this.timestamp = LocalDateTime.now(ZoneId.of(\"UTC\")); } public String getMsg() { return msg; } public LocalDateTime getTimestamp() { return timestamp; } } // Writes message to a file class MessagePrinter { /** * MessagePrinter directly instantiates the JSONFormatter object inside the * writeMessage method, which violates the Dependency Inversion Principle. */ public void writeMessage(Message msg, String fileName) throws IOException { Formatter formatter = new JSONFormatter(); // creates formatter try (PrintWriter writer = new PrintWriter(new FileWriter(fileName))) { // creates print writer writer.println(formatter.format(msg)); // formats and writes message writer.flush(); } } } // Main class public class Main { public static void main(String[] args) throws IOException { Message msg = new Message(\"This is a message again\"); MessagePrinter printer = new MessagePrinter(); printer.writeMessage(msg, \"test_msg.txt\"); } } In the above code, the MessagePrinter class directly instanitiates the JSONFormatter object inside the writeMessage method, which violates the Dependency Inversion Principle. This tight coupling means that if a new formatter, such as TextFormatter, needs to be added, the writeMessage method must be modified. This violates the Open-Closed Principle, which states that classes should be open for extension but closed for modification. According to the Dependency Inversion Principle, the high-level module (MessagePrinter) should not depend on the low-level module (JSONFormatter). Instead, both should depend on abstractions, such as the Formatter interface.\nSHOW CODE: After Refactoring After Refactoring import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule; import java.io.IOException; import java.io.PrintWriter; import java.time.LocalDateTime; import java.time.ZoneId; // Common interface for classes formatting Message objects interface Formatter { String format(Message message) throws FormatException; } // Custom exception thrown by Formatter class FormatException extends IOException { public FormatException(Exception cause) { super(cause); } } // Formats a Message object to JSON format class JSONFormatter implements Formatter { public String format(Message message) throws FormatException { ObjectMapper mapper = new ObjectMapper(); mapper.registerModule(new JavaTimeModule()); try { return mapper.writeValueAsString(message); } catch (JsonProcessingException e) { e.printStackTrace(); throw new FormatException(e); } } } // Represents a message with content and a timestamp class Message { private String msg; private LocalDateTime timestamp; public Message(String msg) { this.msg = msg; this.timestamp = LocalDateTime.now(ZoneId.of(\"UTC\")); } public String getMsg() { return msg; } public LocalDateTime getTimestamp() { return timestamp; } } // Responsible for writing a formatted Message to a file or output stream class MessagePrinter { public void writeMessage(Message msg, Formatter formatter, PrintWriter writer) throws IOException { writer.println(formatter.format(msg)); // Formats and writes the message writer.flush(); } } // Main class demonstrating functionality public class Main { public static void main(String[] args) throws IOException { Message msg = new Message(\"This is a message again\"); MessagePrinter printer = new MessagePrinter(); try (PrintWriter writer = new PrintWriter(System.out)) { // Writing to console output printer.writeMessage(msg, new JSONFormatter(), writer); } } } After refactoring, the MessagePrinter class now depends on the Formatter abstraction rather than its concrete implementations. This makes it easier to replace JSONFormatter with any other implementation of Formatter without modifying the existing code, adhering to the Open-Closed Principle.\n2. Creational Design Patterns Creational Design Patterns focus on the process of object creation, ensuring flexibility and promoting code reuse.\n2.1 Builder The Builder Design Pattern is a creational design pattern that enables the step-by-step construction of complex objects. It separates the construction process form the object\u0026rsquo;s representation, allowing the same process to produce different representations. This pattern is often used to build complex or immutable obejcts.\n❔❔❔ Same Construction Process Creates Different Representations:\nConsider building a meal in a fast-food restaurant, where the construction steps include:\nAdd a main dish (e.g., burger, sandwich, or pizza). Add a side dish (e.g., fries, salad, or breadsticks). Add a drink (e.g., soda, coffee, or juice). The construction process remains consistent: (main dish + side dish + drink). However, the final representation varies based on the choices:\nVeggie Meal: Sandwich + Salad + Juice. Classic Meal: Burger + Fries + Soda. Kids\u0026rsquo; Meal: Mini Pizza + Fries + Milk. --- title: URL Diagram of Builder Pattern --- classDiagram class Builder { +buildPartA() +buildPartB() +getResult()* } class ConcreteBuilder1 { +buildPartA() +buildPartB() +getResult() } class ConcreteBuilder2 { +buildPartA() +buildPartB() +getResult() } class Director { +construct(builder: Builder) } class Product { +PartA +PartB } Builder \u003c|-- ConcreteBuilder1 Builder \u003c|-- ConcreteBuilder2 Director --\u003e Builder : uses ConcreteBuilder1 --\u003e Product : creates ConcreteBuilder2 --\u003e Product : creates ℹ️ In a context of design patterns, UML (Unified Modeling Language) is commonly used to represent the structure and behavior of the patterns in a clear and simple manner.\nSHOW CODE: Director Java import java.time.LocalDate; import java.time.Period; import java.util.Objects; // Address class class Address { private String houseNumber; private String street; private String city; private String zipcode; private String state; public Address(String houseNumber, String street, String city, String state, String zipcode) { this.houseNumber = houseNumber; this.street = street; this.city = city; this.state = state; this.zipcode = zipcode; } public String getFullAddress() { return houseNumber + \", \" + street + \"\\n\" + city + \"\\n\" + state + \" \" + zipcode; } } // User class class User { private String firstName; private String lastName; private LocalDate birthday; private Address address; public User(String firstName, String lastName, LocalDate birthday, Address address) { this.firstName = firstName; this.lastName = lastName; this.birthday = birthday; this.address = address; } public String getFirstName() { return firstName; } public String getLastName() { return lastName; } public LocalDate getBirthday() { return birthday; } public Address getAddress() { return address; } } // UserDTO interface interface UserDTO { String getName(); String getAddress(); String getAge(); } // UserWebDTO implementation class UserWebDTO implements UserDTO { private final String name; private final String address; private final String age; public UserWebDTO(String name, String address, String age) { this.name = name; this.address = address; this.age = age; } @Override public String getName() { return name; } @Override public String getAddress() { return address; } @Override public String getAge() { return age; } @Override public String toString() { return \"Name: \" + name + \"\\nAge: \" + age + \"\\nAddress:\\n\" + address; } } // UserDTOBuilder interface interface UserDTOBuilder { UserDTOBuilder withFirstName(String firstName); UserDTOBuilder withLastName(String lastName); UserDTOBuilder withBirthday(LocalDate birthday); UserDTOBuilder withAddress(Address address); UserDTO build(); } // Concrete builder class UserWebDTOBuilder implements UserDTOBuilder { private String firstName; private String lastName; private String age; private String address; @Override public UserDTOBuilder withFirstName(String firstName) { this.firstName = firstName; return this; } @Override public UserDTOBuilder withLastName(String lastName) { this.lastName = lastName; return this; } @Override public UserDTOBuilder withBirthday(LocalDate birthday) { if (Objects.nonNull(birthday)) { this.age = String.valueOf(Period.between(birthday, LocalDate.now()).getYears()); } return this; } @Override public UserDTOBuilder withAddress(Address address) { if (Objects.nonNull(address)) { this.address = address.getFullAddress(); } return this; } @Override public UserDTO build() { return new UserWebDTO(firstName + \" \" + lastName, address, age); } } // Client code (Director) public class Client { public static void main(String[] args) { User user = createUser(); UserDTOBuilder builder = new UserWebDTOBuilder(); UserDTO userDTO = buildUserDTO(builder, user); System.out.println(userDTO); } private static UserDTO buildUserDTO(UserDTOBuilder builder, User user) { return builder.withFirstName(user.getFirstName()) .withLastName(user.getLastName()) .withBirthday(user.getBirthday()) .withAddress(user.getAddress()) .build(); } private static User createUser() { Address address = new Address(\"100\", \"State Street\", \"Pawnee\", \"Indiana\", \"47998\"); return new User(\"Ron\", \"Swanson\", LocalDate.of(1960, 5, 6), address); } } SHOW CODE: Inner Builder Java import java.time.LocalDate; import java.time.Period; // Address class with Builder class Address { private final String houseNumber; private final String street; private final String city; private final String zipcode; private final String state; private Address(Builder builder) { this.houseNumber = builder.houseNumber; this.street = builder.street; this.city = builder.city; this.zipcode = builder.zipcode; this.state = builder.state; } public String getFullAddress() { return houseNumber + \", \" + street + \"\\n\" + city + \"\\n\" + state + \" \" + zipcode; } public static class Builder { private String houseNumber; private String street; private String city; private String zipcode; private String state; public Builder setHouseNumber(String houseNumber) { this.houseNumber = houseNumber; return this; } public Builder setStreet(String street) { this.street = street; return this; } public Builder setCity(String city) { this.city = city; return this; } public Builder setZipcode(String zipcode) { this.zipcode = zipcode; return this; } public Builder setState(String state) { this.state = state; return this; } public Address build() { return new Address(this); } } } // User class with Builder class User { private final String firstName; private final String lastName; private final LocalDate birthday; private final Address address; private User(Builder builder) { this.firstName = builder.firstName; this.lastName = builder.lastName; this.birthday = builder.birthday; this.address = builder.address; } public String getFirstName() { return firstName; } public String getLastName() { return lastName; } public LocalDate getBirthday() { return birthday; } public Address getAddress() { return address; } public static class Builder { private String firstName; private String lastName; private LocalDate birthday; private Address address; public Builder setFirstName(String firstName) { this.firstName = firstName; return this; } public Builder setLastName(String lastName) { this.lastName = lastName; return this; } public Builder setBirthday(LocalDate birthday) { this.birthday = birthday; return this; } public Builder setAddress(Address address) { this.address = address; return this; } public User build() { return new User(this); } } } // UserDTO interface interface UserDTO { String getName(); String getAddress(); String getAge(); } // UserWebDTO implementation class UserWebDTO implements UserDTO { private final String name; private final String address; private final String age; private UserWebDTO(Builder builder) { this.name = builder.name; this.address = builder.address; this.age = builder.age; } @Override public String getName() { return name; } @Override public String getAddress() { return address; } @Override public String getAge() { return age; } @Override public String toString() { return \"Name: \" + name + \"\\nAge: \" + age + \"\\nAddress:\\n\" + address; } public static class Builder { private String name; private String address; private String age; public Builder setName(String name) { this.name = name; return this; } public Builder setAddress(String address) { this.address = address; return this; } public Builder setAge(String age) { this.age = age; return this; } public UserWebDTO build() { return new UserWebDTO(this); } } } // Client code public class Client { public static void main(String[] args) { Address address = new Address.Builder() .setHouseNumber(\"100\") .setStreet(\"State Street\") .setCity(\"Pawnee\") .setState(\"Indiana\") .setZipcode(\"47998\") .build(); User user = new User.Builder() .setFirstName(\"Ron\") .setLastName(\"Swanson\") .setBirthday(LocalDate.of(1960, 5, 6)) .setAddress(address) .build(); UserWebDTO userDTO = new UserWebDTO.Builder() .setName(user.getFirstName() + \" \" + user.getLastName()) .setAddress(user.getAddress().getFullAddress()) .setAge(String.valueOf(Period.between(user.getBirthday(), LocalDate.now()).getYears())) .build(); System.out.println(userDTO); } } Summary Why builder pattern is capable of creating immutable objects?\nImplementing the builder as a static inner class facilitates the creation of immutable objects. The builder class has provileged access to the enclosing class\u0026rsquo;s internal state during the construction process. However, once the final object is built, it does not expose any setters or methods that modify its state, ensuring immutability.\nThe Director in the Builder Design Pattern is responsible for the construction process but is often not implemented as a standalone class. Instead, its responsibilities are typically handled by the client code or the consumer that requires the constructed object. This approach avoids the need for a separate director class, especially when the construction logic is simple or tailored to the client\u0026rsquo;s specific requirements.\nSHOW CODE: Without a Director Java UserDTO userDTO = new UserWebDTOBuilder() .withFirstName(\"John\") .withLastName(\"Doe\") .withBirthday(LocalDate.of(1990, 1, 1)) .withAddress(new Address(\"123\", \"Main St\", \"City\", \"State\", \"12345\")) .build(); SHOW CODE: With a Director Java public class Director { public UserDTO constructUser(UserDTOBuilder builder) { return builder.withFirstName(\"John\") .withLastName(\"Doe\") .withBirthday(LocalDate.of(1990, 1, 1)) .withAddress(new Address(\"123\", \"Main St\", \"City\", \"State\", \"12345\")) .build(); } } If a Product in the Builder Design Pattern is not part of an inheritance hierarchy, creating an abstract builder is unnecessary. The abstract builder is typically used to define method for mutiple types of builders. When there is only one type of product to construct, a concrete builder alone is sufficient to meet the requirements.\n2.2 Simple Factory The Simple Factory design pattern is a creational design pattern that delegates the responsibility of creating instances of different classes to a factory class, typically using a static method based on input parameters. This pattern centralizes object creation, simplifying the client code. However, it can violate the Open-Closed Principle (OCP), because adding a new product type requires modifying the factory class itself. This makes the code less flexible and harder to extend without altering existing source code.\nSHOW CODE Java import java.time.LocalDateTime; import java.time.LocalDate; // Abstract Post class public abstract class Post { private Long id; private String title; private String content; private LocalDateTime createdOn; private LocalDateTime publishedOn; public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } public LocalDateTime getCreatedOn() { return createdOn; } public void setCreatedOn(LocalDateTime createdOn) { this.createdOn = createdOn; } public LocalDateTime getPublishedOn() { return publishedOn; } public void setPublishedOn(LocalDateTime publishedOn) { this.publishedOn = publishedOn; } } // BlogPost class extends Post public class BlogPost extends Post { private String author; private String[] tags; public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } public String[] getTags() { return tags; } public void setTags(String[] tags) { this.tags = tags; } } // NewsPost class extends Post public class NewsPost extends Post { private String headline; private LocalDate newsTime; public String getHeadline() { return headline; } public void setHeadline(String headline) { this.headline = headline; } public LocalDate getNewsTime() { return newsTime; } public void setNewsTime(LocalDate newsTime) { this.newsTime = newsTime; } } // ProductPost class extends Post public class ProductPost extends Post { private String imageUrl; private String name; public String getImageUrl() { return imageUrl; } public void setImageUrl(String imageUrl) { this.imageUrl = imageUrl; } public String getName() { return name; } public void setName(String name) { this.name = name; } } // PostFactory class to create different types of posts public class PostFactory { public static Post createPost(String type) { switch (type) { case \"blog\": return new BlogPost(); case \"news\": return new NewsPost(); case \"product\": return new ProductPost(); default: throw new IllegalArgumentException(\"Post type is unknown\"); } } } // Client class to demonstrate the usage of Simple Factory public class Client { public static void main(String[] args) { Post post = PostFactory.createPost(\"news\"); System.out.println(post.getClass().getSimpleName()); // Prints the type of the created post (NewsPost) } } classDiagram direction RL class Post { - Long id - String title - String content - LocalDateTime createdOn - LocalDateTime publishedOn + getId() + setId(Long) + getTitle() + setTitle(String) + getContent() + setContent(String) + getCreatedOn() + setCreatedOn(LocalDateTime) + getPublishedOn() + setPublishedOn(LocalDateTime) } class BlogPost { - String author - String[] tags + getAuthor() + setAuthor(String) + getTags() + setTags(String[]) } class NewsPost { - String headline - LocalDate newsTime + getHeadline() + setHeadline(String) + getNewsTime() + setNewsTime(LocalDate) } class ProductPost { - String imageUrl - String name + getImageUrl() + setImageUrl(String) + getName() + setName(String) } class PostFactory { + createPost(String) } Post \u003c|-- BlogPost Post \u003c|-- NewsPost Post \u003c|-- ProductPost PostFactory --|\u003e BlogPost : creates PostFactory --|\u003e NewsPost : creates PostFactory --|\u003e ProductPost : creates The above code violates the Open-Closed Principle because when adding a new post type, such as EventPost, to the factory, the code must be modified by adding a new case statement, like the following:\ncase \u0026#34;event\u0026#34;: return new EventPost(); This approach breaks the OCP, which dictates that entities should be open for extension but closed for modification.\n2.3 Factory Method The Factory Method design pattern is a creational pattern that provides a method for creating objects in a superclass, while allowing subclasses to determine the type of object that will be created. This approach delegates the object creation process to the subclasses, enabling them to instantiate specific classes without the superclass needing to know the exact class being instantiated.\nSHOW CODE Java import java.util.*; /** * Abstract class representing a message, which is the \"product\". * Subclasses will provide specific content types. */ abstract class Message { public abstract String getContent(); public void addDefaultHeaders() { // Adds some default headers } public void encrypt() { // Has some code to encrypt the content } } /** * Concrete implementation of the Message class for Text messages. */ class TextMessage extends Message { @Override public String getContent() { return \"Text\"; } } /** * Concrete implementation of the Message class for JSON messages. */ class JSONMessage extends Message { @Override public String getContent() { return \"{\\\"JSON\\\":[]}\"; } } /** * Abstract creator class. The factory method createMessage() must be implemented * by subclasses to instantiate the specific message type. */ abstract class MessageCreator { public Message getMessage() { Message msg = createMessage(); msg.addDefaultHeaders(); msg.encrypt(); return msg; } // Factory method to create a message protected abstract Message createMessage(); } /** * Concrete creator for creating JSON messages. */ class JSONMessageCreator extends MessageCreator { @Override public Message createMessage() { return new JSONMessage(); } } /** * Concrete creator for creating Text messages. */ class TextMessageCreator extends MessageCreator { @Override public Message createMessage() { return new TextMessage(); } } /** * Client class demonstrating the use of the Factory Method pattern. */ public class Client { public static void main(String[] args) { printMessage(new JSONMessageCreator()); printMessage(new TextMessageCreator()); } public static void printMessage(MessageCreator creator) { Message msg = creator.getMessage(); System.out.println(msg.getContent()); } } --- title: URL Diagram of Factory Method Pattern --- classDiagram Message \u003c|-- TextMessage Message \u003c|-- JSONMessage MessageCreator \u003c|-- JSONMessageCreator MessageCreator \u003c|-- TextMessageCreator JSONMessageCreator \"1\" --\u003e \"1\" JSONMessage : creates TextMessageCreator \"1\" --\u003e \"1\" TextMessage : creates MessageCreator : +getMessage() MessageCreator : +createMessage() JSONMessageCreator : +createMessage() TextMessageCreator : +createMessage() Message : +getContent() Message : +addDefaultHeaders() Message : +encrypt() 2.4 Prototype Prototype v.s. Builder\n2.5 Abstract Factory 2.6 Singleton 2.7 Object Pool 3. Structural Design Patterns 3.1 Adapter 3.2 Bridge 3.3 Decorator 3.4 Composite 3.5 Facade 3.6 Flyweight 3.7 Proxy 4. Behavioral Design Patterns 4.1 Chain of Responsibility 4.2 Command 4.3 Interpreter 4.4 Mediator 4.5 Iterator 4.6 Momento 4.7 Observer 4.8 State 4.9 Strategy 4.10 Template Method 4.11 Visitor 4.12 Null Object ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/design-patterns/1-design-patterns/","summary":"1. Solid Principle 1.1 Single Responsibility Principle A class should have only one reason to change, meaning each class should focus on a single functionality or responsibility.\nSHOW CODE Single Responsibility Principle import java.io.IOException; import java.util.*; import java.util.regex.*; import com.fasterxml.jackson.databind.ObjectMapper; /** * 1. User class is only used to represent entity. * 2. UserValidator class is solely responsible for validating user objects. * 3. Store class is only used to manage user objects storage.","title":"Design Patterns"}]