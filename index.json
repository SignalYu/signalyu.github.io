[{"content":"深度优先搜索 深度优先搜索算法基于栈数据结构实现 对于递归形式的深度优先搜索算法，函数调用栈充当栈数据结构 对于迭代形式的深度优先搜索算法，需要显式定义栈数据结构 深度优先搜索算法最大限度地探索每条路径，当遇到死胡同（dead end）时，将回溯到原出发点，并选择新的路径继续搜索 深度优先搜索算法的搜索顺序取决于邻居结点的被访问的顺序 递归实现 import java.util.LinkedList; class Graph { // Number of vertices private int vertices; // Adjacency list representation of the graph private LinkedList\u0026lt;Integer\u0026gt;[] adjList; public Graph(int vertices) { this.vertices = vertices; // Initialize adjacency list adjList = new LinkedList[vertices]; for (int i = 0; i \u003c vertices; i++) { adjList[i] = new LinkedList\u0026lt;\u0026gt;(); } } // Add edge to the undirected graph public void addEdge(int src, int dest) { adjList[src].add(dest); adjList[dest].add(src); } // Add edge to the graph (directed) public void addDirectedEdge(int src, int dest) { adjList[src].add(dest); } // Print the graph public void printGraph() { for (int i = 0; i \u003c vertices; i++) { System.out.print(\"Vertex \" + i + \":\"); for (Integer node : adjList[i]) { System.out.print(\" -\u003e \" + node); } System.out.println(); } } // Depth-First Search (DFS) public void dfs(int startVertex) { boolean[] visited = new boolean[vertices]; dfs(startVertex, visited); System.out.println(); } private void dfs(int vertex, boolean[] visited) { visited[vertex] = true; System.out.print(vertex + \" \"); // base case 隐藏在 for 循环中 for (int adjVertex : adjList[vertex]) { if (!visited[adjVertex]) { dfs(adjVertex, visited); } } } public static void main(String[] args) { Graph graph = new Graph(6); graph.addDirectedEdge(0,1); graph.addDirectedEdge(0,2); graph.addDirectedEdge(0,4); graph.addDirectedEdge(1,3); graph.addDirectedEdge(2,4); graph.addDirectedEdge(5,3); graph.addDirectedEdge(4,1); System.out.println(\"Graph:\"); graph.printGraph(); System.out.println(\"DFS starting from vertex 0:\"); graph.dfs(0); } } 图及其邻接表 递归深度优先搜索进出栈顺序图 迭代实现 import java.util.LinkedList; import java.util.Stack; class Graph { // Number of vertices private int vertices; // Adjacency list representation of the graph private LinkedList\u0026lt;Integer\u0026gt;[] adjList; public Graph(int vertices) { this.vertices = vertices; // Initialize adjacency list adjList = new LinkedList[vertices]; for (int i = 0; i \u003c vertices; i++) { adjList[i] = new LinkedList\u0026lt;\u0026gt;(); } } // Add edge to the undirected graph public void addEdge(int src, int dest) { adjList[src].add(dest); adjList[dest].add(src); } // Add edge to the graph (directed) public void addDirectedEdge(int src, int dest) { adjList[src].add(dest); } // Print the graph public void printGraph() { for (int i = 0; i \u003c vertices; i++) { System.out.print(\"Vertex \" + i + \":\"); for (Integer node : adjList[i]) { System.out.print(\" -\u003e \" + node); } System.out.println(); } } // Depth-First Search (DFS) public void dfs(int startVertex) { boolean[] visited = new boolean[vertices]; Stack stack = new Stack\u0026lt;\u0026gt;(); stack.push(startVertex); while (!stack.isEmpty()) { int vertex = stack.pop(); if (!visited[vertex]) { System.out.print(vertex + \" \"); visited[vertex] = true; } for (int adjVertex : adjList[vertex]) { if (!visited[adjVertex]) { stack.push(adjVertex); } } } System.out.println(); } public static void main(String[] args) { Graph graph = new Graph(6); graph.addDirectedEdge(0,1); graph.addDirectedEdge(0,2); graph.addDirectedEdge(0,4); graph.addDirectedEdge(1,3); graph.addDirectedEdge(2,4); graph.addDirectedEdge(5,3); graph.addDirectedEdge(4,1); System.out.println(\"Graph:\"); graph.printGraph(); System.out.println(\"DFS starting from vertex 0:\"); graph.dfs(0); } } 迭代深度优先搜索进出栈顺序图 广度优先搜索 广度优先搜索算法基于队列数据结构实现 广度优先搜索算法会先遍历当前深度层级的所有节点，然后再遍历下一个深度层级的节点 import java.util.LinkedList; class Graph { // Number of vertices private int vertices; // Adjacency list representation of the graph private LinkedList\u0026lt;Integer\u0026gt;[] adjList; public Graph(int vertices) { this.vertices = vertices; // Initialize adjacency list adjList = new LinkedList[vertices]; for (int i = 0; i \u003c vertices; i++) { adjList[i] = new LinkedList\u0026lt;\u0026gt;(); } } // Add edge to the undirected graph public void addEdge(int src, int dest) { adjList[src].add(dest); adjList[dest].add(src); } // Add edge to the graph (directed) public void addDirectedEdge(int src, int dest) { adjList[src].add(dest); } // Print the graph public void printGraph() { for (int i = 0; i \u003c vertices; i++) { System.out.print(\"Vertex \" + i + \":\"); for (Integer node : adjList[i]) { System.out.print(\" -\u003e \" + node); } System.out.println(); } } // Breadth-First Search (BFS) public void bfs(int startVertex) { boolean[] visited = new boolean[vertices]; LinkedList\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); visited[startVertex] = true; queue.add(startVertex); while (!queue.isEmpty()) { int vertex = queue.poll(); System.out.print(vertex + \" \"); for (int adjVertex : adjList[vertex]) { if (!visited[adjVertex]) { visited[adjVertex] = true; queue.add(adjVertex); } } } System.out.println(); } public static void main(String[] args) { Graph graph = new Graph(6); graph.addDirectedEdge(0, 1); graph.addDirectedEdge(0, 2); graph.addDirectedEdge(0, 4); graph.addDirectedEdge(1, 3); graph.addDirectedEdge(2, 4); graph.addDirectedEdge(5, 3); graph.addDirectedEdge(4, 1); System.out.println(\"Graph:\"); graph.printGraph(); System.out.println(\"BFS starting from vertex 0:\"); graph.bfs(0); } } 判断两点间路径是否存在 图及其邻接表 import java.util.LinkedList; class Graph { // Number of vertices private int vertices; // Adjacency list representation of the graph private LinkedList\u0026lt;Integer\u0026gt;[] adjList; public Graph(int vertices) { this.vertices = vertices; // Initialize adjacency list adjList = new LinkedList[vertices]; for (int i = 0; i \u003c vertices; i++) { adjList[i] = new LinkedList\u0026lt;\u0026gt;(); } } // Add edge to the undirected graph public void addEdge(int src, int dest) { adjList[src].add(dest); adjList[dest].add(src); } // Add edge to the graph (directed) public void addDirectedEdge(int src, int dest) { adjList[src].add(dest); } // Print the graph public void printGraph() { for (int i = 0; i \u003c vertices; i++) { System.out.print(\"Vertex \" + i + \":\"); for (Integer node : adjList[i]) { System.out.print(\" -\u003e \" + node); } System.out.println(); } } // Function to determine if there is a path between two vertices public boolean hasPath(int startVertex, int endVertex) { boolean[] visited = new boolean[vertices]; return hasPathDFS(startVertex, endVertex, visited); } private boolean hasPathDFS(int current, int endVertex, boolean[] visited) { if (current == endVertex) { return true; } visited[current] = true; for (int adjVertex : adjList[current]) { if (!visited[adjVertex]) { if (hasPathDFS(adjVertex, endVertex, visited)) { return true; } } } return false; } public static void main(String[] args) { Graph graph = new Graph(6); graph.addDirectedEdge(0, 1); graph.addDirectedEdge(0, 2); graph.addDirectedEdge(0, 4); graph.addDirectedEdge(1, 3); graph.addDirectedEdge(2, 4); graph.addDirectedEdge(5, 3); graph.addDirectedEdge(4, 1); System.out.println(\"Graph:\"); graph.printGraph(); System.out.println(\"Is there a path from \" + 0 + \" to \" + 3 + \"? \" + graph.hasPath(0, 3)); // true System.out.println(\"Is there a path from \" + 1 + \" to \" + 5 + \"? \" + graph.hasPath(1, 5)); // flase } } 无向路径 点击查看题目 连接点计算 最大结点 最短路径 岛的数量 最少岛屿 ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/algorithms/6-graph/","summary":"深度优先搜索 深度优先搜索算法基于栈数据结构实现 对于递归形式的深度优先搜索算法，函数调用栈充当栈数据结构 对于迭代形式的深度优先搜索算法，需要显式定义栈数据结构 深度优先搜索算法最大限度地探索每条路径，当遇到死胡同（dead end）时，将回溯到原出发点，并选择新的路径继续搜索 深度优先搜索算法的搜索顺序取决于邻居结点的被访问的顺序 递归实现 import java.util.LinkedList; class Graph { // Number of vertices private int vertices; // Adjacency list representation of the graph private LinkedList\u0026lt;Integer\u0026gt;[] adjList; public Graph(int vertices) { this.vertices = vertices; // Initialize adjacency list adjList = new LinkedList[vertices]; for (int i = 0; i \u003c vertices; i++) { adjList[i] = new LinkedList\u0026lt;\u0026gt;(); } } // Add edge to the undirected graph public void addEdge(int src, int dest) { adjList[src].","title":"数据结构与算法：图"},{"content":"递归定义 递归（Recursion）是指函数在执行过程中调用自身的过程，通常用于将问题划分为类似的子问题。递归函数通常由两部分组成：\n基本情况（Base Case(s)）：基本情况指的是函数用于避免无限递归、停止调用自身的条件。（寻找最小子问题） 递归情况（Recursive Case(s)）：递归情况是指函数使用不同参数调用自身，并逐渐向基本情况靠拢。（寻找每调用一次函数能缩小问题规模的最小单元） 例题 字符串反转 点击查看题目 字符串反转：\u0026ldquo;signal yu\u0026rdquo; 输出为 \u0026ldquo;uy langis\u0026rdquo; 基本情况：当字符串 s 为空串时返回 \u0026quot;\u0026quot;，当字符串 s 长度为 1 时，返回 s，即当字符串长度小于等于 1 时，返回 s。 递归情况：执行一次函数操作一个字符，因此每调用一次函数能缩小问题规模的最小单元为 1。 public class ReverseString { // 递归方法反转字符串 public static String reverseString(String s) { // 基本情况：如果字符串为空或只有一个字符，直接返回它 if (s.length() \u003c= 1) { return s; } // 递归情况：取出第一个字符，并将剩余字符串反转后再将第一个字符加到末尾 return reverseString(s.substring(1)) + s.charAt(0); } public static void main(String[] args) { String inputStr = \"signal yu\"; String reversedStr = reverseString(inputStr); System.out.println(reversedStr); // uy langis } } 反转字符串调用栈 回文字符串（Palindrom） 点击查看题目 如果一个序列是对称的，即从左往右读与从右往左读完全相同，那么它就被认为是一个回文字符串，例如 \u0026ldquo;radar\u0026rdquo;, \u0026ldquo;level\u0026rdquo;, \u0026ldquo;madam\u0026rdquo;。 基本情况：字符串长度为 0 或 1 递归情况：每调用一次函数能缩小问题规模的最小单元为 2（去掉首尾字符） public class Palindrome { public static boolean isPalindrome(String str) { // Base case: if the string is empty or has one character, it is a palindrome if (str.isEmpty() || str.length() == 1) { return true; } // Check if the first and last characters are the same if (str.charAt(0) == str.charAt(str.length() - 1)) { // Recur with the substring excluding the first and last characters return isPalindrome(str.substring(1, str.length() - 1)); } // If the first and last characters are not the same, it is not a palindrome return false; } public static void main(String[] args) { String[] testStrings = {\"racecar\", \"madam\", \"hello\", \"A\", \"\", \"level\"}; for (String str : testStrings) { if (isPalindrome(str)) { System.out.println(str + \" is a palindrome.\"); } else { System.out.println(str + \" is not a palindrome.\"); } } } } 回文字符串调用栈 I 回文字符串调用栈 II 十进制转二进制 点击查看题目 将指定的十进制数字，返回其二进制表示形式。例如 10 的二进制形式为 1010。 基本情况：当数字为 1 时，当数字为 0 时，返回 0. 递归情况：每调用一次函数能缩小问题规模的最小单元为原问题的一半。 public class DecimalToBinary { public static String decimalToBinary(int n) { // Base case: if the number is 0, return \"0\" if (n == 0) { return \"0\"; } // If the number is 1, return \"1\" if (n == 1) { return \"1\"; } // Recursive call: divide the number by 2 and concatenate the remainder return decimalToBinary(n / 2) + (n % 2); } public static void main(String[] args) { int[] testNumbers = {0, 1, 2, 3, 4, 5, 10, 255}; for (int number : testNumbers) { System.out.println(\"Decimal: \" + number + \" -\u003e Binary: \" + decimalToBinary(number)); } } } 十进制转二进制调用栈 分而治之（Divide and Conquer） 分治算法（Divide and Conquer）的核心思想为：\n分（Divide）：将原问题不断分解为更小的子问题 治（Conquer）：递归解决子问题，对于基本情况（Base Case）则直接求解 合（Combine）：将子问题的求解结果合并，以获得原问题的解 二分查找 归并排序 归并排序核心思想如下：\n递归地将数组划分为两部分，直至不能进一步划分（数组中的元素只有一个） 递归地将排序后的数组进行合并 归并排序——划分数组 归并排序——合并数组 需要注意的是，归并排序并不是将所有子数组都划分至最小子数组后才进行合并，而是先将某一分支上的数组划分至最小子数组，然后对该分支的元素进行合并。具体过程如下列视频所示： import java.util.Arrays; public class MergeSort { // Method to merge two halves public static void merge(int[] arr, int left, int mid, int right) { int n1 = mid - left + 1; int n2 = right - mid; // Create temporary arrays int[] leftArray = new int[n1]; int[] rightArray = new int[n2]; // Copy data to temp arrays for (int i = 0; i \u003c n1; i++) { leftArray[i] = arr[left + i]; } for (int j = 0; j \u003c n2; j++) { rightArray[j] = arr[mid + 1 + j]; } // Merge the temp arrays // Initial indexes of first and second subarrays int i = 0, j = 0; // Initial index of merged subarray int k = left; while (i \u003c n1 \u0026\u0026 j \u003c n2) { if (leftArray[i] \u003c= rightArray[j]) { arr[k++] = leftArray[i++]; } else { arr[k++] = rightArray[j++]; } } // Copy remaining elements of leftArray if any while (i \u003c n1) { arr[k++] = leftArray[i++]; } // Copy remaining elements of rightArray if any while (j \u003c n2) { arr[k++] = rightArray[j++]; } } // Main function that sorts arr[left...right] using merge() public static void mergeSort(int[] arr, int left, int right) { if (left \u003c right) { // Find the middle point int mid = left + (right - left) / 2; // Sort first and second halves mergeSort(arr, left, mid); mergeSort(arr, mid + 1, right); // Merge the sorted halves merge(arr, left, mid, right); } } public static void main(String[] args) { int[] arr1 = {3, 7, 8, 5, 4, 2, 6, 1}; System.out.println(\"arr1 = \" + Arrays.toString(arr1)); mergeSort(arr1, 0, arr1.length - 1); System.out.println(\"Sorted arr1 = \" + Arrays.toString(arr1)); } } 快速排序 快速排序（Quick Sort）的核心思想如下：\n选择基准（Pivot）：从数组中选择一个元素作为基准。 分区（Partition）：将数组重新排列，使得比中枢值小的元素都排在基准的左边，比基准值大的元素都排在基准的右边。 递归排序：对基准左边和右边的子数组分别递归地应用快速排序算法。 合并结果： 将左边子数组、基准和右边子数组合并起来，得到最终的排序结果。 快速排序的基准元素选择通常有三种：第一个元素、随机元素和最后一个元素。\n当选择随机元素为基准元素时，在排序之前将它与第一个元素或最后一个元素进行交换后再排序即可。\n点击查看代码 最后一个元素作为基准元素 第一个元素作为基准元素 随机元素作为基准元素 import java.util.Arrays; public class QuickSort { // Method to perform Quick Sort public static void quickSort(int[] array, int low, int high) { if (low \u003c high) { // Partition the array and get the pivot index int pivotIndex = partition(array, low, high); // Recursively sort elements before and after partition quickSort(array, low, pivotIndex - 1); quickSort(array, pivotIndex + 1, high); } } // Method to partition the array private static int partition(int[] array, int low, int high) { // Choose the pivot (here we are choosing the last element as pivot) int pivot = array[high]; int i = low - 1; for (int j = low; j \u003c high; j++) { if (array[j] \u003c pivot) { i++; // Swap array[i] and array[j] int temp = array[i]; array[i] = array[j]; array[j] = temp; } } i++; // Swap array[i] and pivot int temp = array[i]; array[i] = array[high]; array[high] = temp; return i; // return index of new pivot } // Main method to test the Quick Sort algorithm public static void main(String[] args) { int[] array = {8, 2, 4, 7, 1, 3, 9, 6, 5}; System.out.println(\"Unsorted array: \" + Arrays.toString(array)); quickSort(array, 0, array.length - 1); System.out.println(\"Sorted array: \" + Arrays.toString(array)); } } import java.util.Arrays; public class QuickSort { // Method to partition the array and return the pivot index private static int partition(int[] arr, int low, int high) { // Choose the pivot element (first element of the array) int pivot = arr[low]; // Index of the smaller element int i = low; for (int j = low + 1; j \u003c= high; j++) { // If current element is smaller than the pivot if (arr[j] \u003c= pivot) { // Comparison should include equality to maintain stability i++; // Swap arr[i] and arr[j] int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } // Swap arr[i] and pivot int temp = arr[low]; arr[low] = arr[i]; arr[i] = temp; // Return the pivot index return i; } // Recursive method to partition and sort subarrays private static void quickSort(int[] arr, int low, int high) { if (low \u003c high) { // Partition the array and get the pivot index int pivotIndex = partition(arr, low, high); // Recursively sort the left and right subarrays quickSort(arr, low, pivotIndex - 1); quickSort(arr, pivotIndex + 1, high); } } // Main method to test the quick sort algorithm public static void main(String[] args) { int[] array = {8, 2, 4, 7, 1, 3, 9, 6, 5}; System.out.println(\"Unsorted array: \" + Arrays.toString(array)); quickSort(array, 0, array.length - 1); System.out.println(\"Sorted array: \" + Arrays.toString(array)); } } import java.util.Arrays; import java.util.Random; public class QuickSort { // Method to perform Quick Sort public static void quickSort(int[] array, int low, int high) { if (low \u003c high) { // Randomize pivot and partition the array int pivotIndex = partition(array, low, high); // Recursively sort elements before and after partition quickSort(array, low, pivotIndex - 1); quickSort(array, pivotIndex + 1, high); } } // Method to partition the array private static int partition(int[] array, int low, int high) { // Choose the pivot (here it is the last element after randomization) int pivotIndex = low + new Random().nextInt(high - low + 1); swap(array, pivotIndex, high); // Move the pivot element to the end int pivot = array[high]; int i = low - 1; for (int j = low; j \u003c high; j++) { if (array[j] \u003c= pivot) { i++; // Swap array[i] and array[j] swap(array, i, j); } } i++; // Swap array[i] and pivot swap(array, i, high); return i; // return new pivot index } // Utility method to swap two elements in the array private static void swap(int[] array, int i, int j) { int temp = array[i]; array[i] = array[j]; array[j] = temp; } // Main method to test the quick sort algorithm public static void main(String[] args) { int[] array = {8, 2, 4, 7, 1, 3, 9, 6, 5}; System.out.println(\"Unsorted array: \" + Arrays.toString(array)); quickSort(array, 0, array.length - 1); System.out.println(\"Sorted array: \" + Arrays.toString(array)); } } 链表反转 基本情况：链表为空或者链表中仅有一个结点 递归情况：每调用一次函数能缩小问题规模的最小单元为 1 public class LinkedList { Node head; static class Node { int data; Node next; // Constructor to create a new node Node(int data) { this.data = data; next = null; } } Node reverse(Node head) { // if (head == null || head.next == null) { return head; } // Reverse the rest of the list Node p = reverse(head.next); // Set the next of the last node to the current head head.next.next = head; // Set the next of the current head to null head.next = null; // Return the new head of the reversed list return p; } // Utility function to print the linked list void printList(Node head) { Node temp = head; while (temp != null) { System.out.print(temp.data + \"-\u003e\"); temp = temp.next; } System.out.println(\"null\"); } public static void main(String[] args) { LinkedList list = new LinkedList(); list.head = new Node(1); list.head.next = new Node(2); list.head.next.next = new Node(3); list.head.next.next.next = new Node(4); list.head.next.next.next.next = new Node(5); list.head.next.next.next.next.next = new Node(6); System.out.println(\"Original Linked List:\"); list.printList(list.head); list.head = list.reverse(list.head); System.out.println(\"Reversed Linked List:\"); list.printList(list.head); } } 链表反转调用栈——入栈 链表反转调用栈——出栈 有序链表合并 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。\npublic class LinkedList { static class Node { int data; Node next; // Constructor to create a new node Node(int data) { this.data = data; next = null; } } // Utility function to print the linked list void printList(Node head) { Node temp = head; while (temp != null) { System.out.print(temp.data + \"-\u003e\"); temp = temp.next; } System.out.println(\"null\"); } public Node mergeTwoLists(Node A, Node B) { if (A == null) { return B; } if (B == null) { return A; } if (A.data \u003c= B.data) { A.next = mergeTwoLists(A.next, B); return A; } else { B.next = mergeTwoLists(A, B.next); return B; } } public static void main(String[] args) { // Create first sorted list: 1 -\u003e 8 -\u003e 22 Node l1 = new Node(1); l1.next = new Node(8); l1.next.next = new Node(22); // Create second sorted list: 4 -\u003e 11 -\u003e 16 Node l2 = new Node(4); l2.next = new Node(11); l2.next.next = new Node(16); // Merge the lists LinkedList solution = new LinkedList(); Node mergedList = solution.mergeTwoLists(l1, l2); // Print the merged list: 1 -\u003e 4 -\u003e 8 -\u003e 16 -\u003e 22 -\u003e null new LinkedList().printList(mergedList); } } 合并两个有序链表入栈与出栈 二叉搜索树插值 public class BinarySearchTree { static class Node { int data; Node left, right; public Node(int item) { data = item; left = right = null; } } Node root; public BinarySearchTree() { root = null; } // A recursive function to insert a new key in BST public Node insert(Node root, int key) { // If the tree is empty, return a new node if (root == null) { root = new Node(key); return root; } // Otherwise, recur down the tree if (key \u003c root.data) { root.left = insert(root.left, key); } else if (key \u003e root.data) { root.right = insert(root.right, key); } // return the (unchanged) node pointer return root; } public static void main(String[] args) { BinarySearchTree tree = new BinarySearchTree(); /* Create following BST 50 / \\ 30 70 / \\ / \\ 20 40 60 80 */ tree.root = tree.insert(tree.root, 50); tree.insert(tree.root, 30); tree.insert(tree.root, 20); tree.insert(tree.root, 40); tree.insert(tree.root, 70); tree.insert(tree.root, 60); tree.insert(tree.root, 80); } } 二叉搜索树插值调用栈 打印所有叶子结点 public class BinarySearchTree { static class Node { int data; Node left, right; public Node(int item) { data = item; left = right = null; } } Node root; public BinarySearchTree() { } // A recursive function to insert a new key in BST public Node insert(Node root, int key) { // If the tree is empty, return a new node if (root == null) { root = new Node(key); return root; } // Otherwise, recur down the tree if (key \u003c root.data) { root.left = insert(root.left, key); } else if (key \u003e root.data) { root.right = insert(root.right, key); } // return the (unchanged) node pointer return root; } // A recursive function to print all leaf nodes of the BST public void printAllLeafNodes(Node root) { if (root == null) return; // Check if this node is a leaf node if (root.left == null \u0026\u0026 root.right == null) { System.out.print(root.data + \" \"); return; } // Otherwise, recur for the left and right subtree if (root.left != null) printAllLeafNodes(root.left); if (root.right != null) printAllLeafNodes(root.right); } // Driver Program to test above functions public static void main(String[] args) { BinarySearchTree tree = new BinarySearchTree(); /* Create following BST 50 / \\ 30 70 / \\ / \\ 20 40 60 80 */ tree.root = tree.insert(tree.root, 50); tree.insert(tree.root, 30); tree.insert(tree.root, 20); tree.insert(tree.root, 40); tree.insert(tree.root, 70); tree.insert(tree.root, 60); tree.insert(tree.root, 80); // Print all leaf nodes System.out.println(\"Leaf nodes of the BST:\"); tree.printAllLeafNodes(tree.root); } } 深度优先搜索算法 深度优先搜索算法基于栈数据结构实现 对于递归形式的深度优先搜索算法，函数调用栈充当栈数据结构 对于迭代形式的深度优先搜索算法，需要显式定义栈数据结构 深度优先搜索算法最大限度地探索每条路径，当遇到死胡同（dead end）时，将回溯到原出发点，并选择新的路径继续搜索 深度优先搜索算法的搜索顺序取决于邻居结点的被访问的顺序 import java.util.LinkedList; class Graph { // Number of vertices private int vertices; // Adjacency list representation of the graph private LinkedList\u0026lt;Integer\u0026gt;[] adjList; public Graph(int vertices) { this.vertices = vertices; // Initialize adjacency list adjList = new LinkedList[vertices]; for (int i = 0; i \u003c vertices; i++) { adjList[i] = new LinkedList\u0026lt;\u0026gt;(); } } // Add edge to the undirected graph public void addEdge(int src, int dest) { adjList[src].add(dest); adjList[dest].add(src); } // Add edge to the graph (directed) public void addDirectedEdge(int src, int dest) { adjList[src].add(dest); } // Print the graph public void printGraph() { for (int i = 0; i \u003c vertices; i++) { System.out.print(\"Vertex \" + i + \":\"); for (Integer node : adjList[i]) { System.out.print(\" -\u003e \" + node); } System.out.println(); } } // Depth-First Search (DFS) public void dfs(int startVertex) { boolean[] visited = new boolean[vertices]; dfs(startVertex, visited); System.out.println(); } private void dfs(int vertex, boolean[] visited) { visited[vertex] = true; System.out.print(vertex + \" \"); // base case 隐藏在 for 循环中 for (int adjVertex : adjList[vertex]) { if (!visited[adjVertex]) { dfs(adjVertex, visited); } } } public static void main(String[] args) { Graph graph = new Graph(6); graph.addDirectedEdge(0,1); graph.addDirectedEdge(0,2); graph.addDirectedEdge(0,4); graph.addDirectedEdge(1,3); graph.addDirectedEdge(2,4); graph.addDirectedEdge(5,3); graph.addDirectedEdge(4,1); System.out.println(\"Graph:\"); graph.printGraph(); System.out.println(\"DFS starting from vertex 0:\"); graph.dfs(0); } } 递归深度优先搜索进出栈顺序图 递归优化 使用缓存：使用缓存存储重复计算的值，需要时直接使用即可 点击查看代码 不使用缓存 使用缓存 public static long fib(int n) { if (n == 1) { return 0; } if (n == 2) { return 1; } return fib(n - 1) + fib(n - 2); } import java.util.HashMap; import java.util.Map; public class Fibonacci { // 使用 HashMap 来存储已经计算过的斐波那契数 private Map\u0026lt;Integer, Long\u0026gt; cache = new HashMap\u0026lt;\u0026gt;(); public long fib(int n) { // 基本情况 if (n == 1) { return 0; } if (n == 2) { return 1; } // 检查缓存中是否已有结果 if (cache.containsKey(n)) { return cache.get(n); } // 递归计算斐波那契数，并存储结果到缓存中 long result = fib(n - 1) + fib(n - 2); cache.put(n, result); return result; } } --- title: 斐波那契：暴力递归（不使用缓存） --- flowchart TB f6((\"fib(6)\")) --\u003e f5((\"fib(5)\")) f6 --\u003e f4((\"fib(4)\")) f5 --\u003e f41((\"fib(4)\")) f5 --\u003e f3((\"fib(3)\")) f4 --\u003e f31((\"fib(3)\")) f4 --\u003e f2((\"fib(2)\")) f41 --\u003e f32((\"fib(3)\")) f41 --\u003e f21((\"fib(2)\")) f3 --\u003e f20((\"fib(2)\")) f3 --\u003e f10((\"fib(1)\")) f31 --\u003e f22((\"fib(2)\")) f31 --\u003e f1((\"fib(1)\")) f32 --\u003e f23((\"fib(2)\")) f32 --\u003e f11((\"fib(1)\")) style f5 fill:lightblue,color:black style f4 fill:orange,color:black style f41 fill:orange,color:black style f3 fill:red style f31 fill:red style f32 fill:red style f20 fill:purple style f2 fill:purple style f21 fill:purple style f22 fill:purple style f23 fill:purple style f1 fill:grey style f11 fill:grey style f10 fill:grey 斐波那契：递归 \u0026#43; 缓存 2. 尾调用递归（Tail-Call Recursion）优化：当函数调用是尾递归调用时，编译器可以优化递归调用以避免在调用栈中添加新的帧。换句话说，编译器可以重复使用当前函数的堆栈帧，从而有效地将递归转化为迭代。（Python、JVM 等并不支持尾递归调用优化）\n点击查看代码 递归 尾递归 public static long factorial(int n) { if (n == 1) { return 1; } return n * factorial(n - 1); } /* factorial(5) 5 * factorial(4) 5 * (4 * factorial(3)) 5 * (4 * (3 * factorial(2))) 5 * (4 * (3 * (2 * factorial(1)))) 5 * (4 * (3 * (2 * 1))) 5 * (4 * (3 * 2))) 5 * (4 * 6)) 5 * 24 120 */ public static long tailFactorial(int n) { return tailFactorial(n, 1); } public static long tailFactorial(int n, int acc) { if (n == 1) { return acc; } return tailFactorial(n - 1, n * acc); } ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/algorithms/3-recursion/","summary":"递归定义 递归（Recursion）是指函数在执行过程中调用自身的过程，通常用于将问题划分为类似的子问题。递归函数通常由两部分组成：\n基本情况（Base Case(s)）：基本情况指的是函数用于避免无限递归、停止调用自身的条件。（寻找最小子问题） 递归情况（Recursive Case(s)）：递归情况是指函数使用不同参数调用自身，并逐渐向基本情况靠拢。（寻找每调用一次函数能缩小问题规模的最小单元） 例题 字符串反转 点击查看题目 字符串反转：\u0026ldquo;signal yu\u0026rdquo; 输出为 \u0026ldquo;uy langis\u0026rdquo; 基本情况：当字符串 s 为空串时返回 \u0026quot;\u0026quot;，当字符串 s 长度为 1 时，返回 s，即当字符串长度小于等于 1 时，返回 s。 递归情况：执行一次函数操作一个字符，因此每调用一次函数能缩小问题规模的最小单元为 1。 public class ReverseString { // 递归方法反转字符串 public static String reverseString(String s) { // 基本情况：如果字符串为空或只有一个字符，直接返回它 if (s.length() \u003c= 1) { return s; } // 递归情况：取出第一个字符，并将剩余字符串反转后再将第一个字符加到末尾 return reverseString(s.substring(1)) + s.charAt(0); } public static void main(String[] args) { String inputStr = \"signal yu\"; String reversedStr = reverseString(inputStr); System.","title":"数据结构与算法：递归"},{"content":"动态规划相关概念 动态规划核心思想： 将原问题划分为更简单的子问题，通过子问题的解来构建问题的解。 Memoization（自上而下法）：将原问题递归地划分为更小的子问题，并在对子问题的结果进行缓存，以避免重复计算。 Tabulation（自下而上法）：从最小的子问题开始，迭代地构建原问题的解。 动态规划例题 斐波那契数列 点击查看题目 斐波那契数（通常用 $F(n)$ 表示）形成的序列称为斐波那契数列。该数列由 $0$ 和 $1$ 开始，后面的每一项数字都是前面两项数字的和。也就是：\n$F(1) = 0，F(2) = 1$\n$F(n) = F(n - 1) + F(n - 2)，其中\\; n \u0026gt; 2$\n给定 $n$ ，请计算 $F(n)$。\n示例 1：\n输入：$n = 2$\n输出：$1$\n解释：$F(2) = 1$\n示例 2：\n输入：$n = 3$\n输出：$2$\n解释：$F(3) = F(2) + F(1) = 1 + 0 = 1$\n示例 3：\n输入：$n = 4$\n输出：$3$\n解释：$F(4) = F(3) + F(2) = 1 + 1 = 2$\n提示：$1 \\le n \\le 30$ 解法一：暴力递归 --- title: 斐波那契：暴力递归 --- flowchart TB f6((\"fib(6)\")) --\u003e f5((\"fib(5)\")) f6 --\u003e f4((\"fib(4)\")) f5 --\u003e f41((\"fib(4)\")) f5 --\u003e f3((\"fib(3)\")) f4 --\u003e f31((\"fib(3)\")) f4 --\u003e f2((\"fib(2)\")) f41 --\u003e f32((\"fib(3)\")) f41 --\u003e f21((\"fib(2)\")) f3 --\u003e f20((\"fib(2)\")) f3 --\u003e f10((\"fib(1)\")) f31 --\u003e f22((\"fib(2)\")) f31 --\u003e f1((\"fib(1)\")) f32 --\u003e f23((\"fib(2)\")) f32 --\u003e f11((\"fib(1)\")) style f5 fill:lightblue,color:black style f4 fill:orange,color:black style f41 fill:orange,color:black style f3 fill:red style f31 fill:red style f32 fill:red style f20 fill:purple style f2 fill:purple style f21 fill:purple style f22 fill:purple style f23 fill:purple style f1 fill:grey style f11 fill:grey style f10 fill:grey public static long fib(int n) { if (n == 1) { return 0; } if (n == 2) { return 1; } return fib(n - 1) + fib(n - 2); } 如上图所示，暴力递归过程中，只有 $fib(6)$ 和 $fib(5)$ 计算了 1 次，$fib(4)$，$fib(3)$，$fib(2)$，$fib(1)$ 都进行了重复计算。\n解法二：递归 + 缓存 Memoization（自上而下法）：在递归求解子问题时，将子问题的结果缓存起来，之后计算相同的子问题时，直接从缓存中获取结果，以避免重复计算。\n斐波那契：递归 \u0026#43; 缓存 import java.util.HashMap; import java.util.Map; public class Fibonacci { // 使用 HashMap 来存储已经计算过的斐波那契数 private Map\u0026lt;Integer, Long\u0026gt; cache = new HashMap\u0026lt;\u0026gt;(); public long fib(int n) { // 基本情况 if (n == 1) { return 0; } if (n == 2) { return 1; } // 检查缓存中是否已有结果 if (cache.containsKey(n)) { return cache.get(n); } // 递归计算斐波那契数，并存储结果到缓存中 long result = fib(n - 1) + fib(n - 2); cache.put(n, result); return result; } } 上述方法缺陷：当 $n$ 比较大时会导致栈溢出（StackOverflow）。\n解法三：迭代 Tabulation（自下而上法）：从最小的子问题 $fib(1)$ 和 $fib(2)$ 入手，迭代地计算出更大子问题的结果。\n迭代（自下而上） import java.util.HashMap; import java.util.Map; public class Solution { private static Map\u0026lt;Integer, Long\u0026gt; cache = new HashMap\u0026lt;\u0026gt;(); public static void main(String[] args) { System.out.println(fib(1)); System.out.println(fib(2)); System.out.println(fib(2000)); } public static long fib(int n) { cache.put(1, 0L); cache.put(2, 1L); for (int i = 3; i $\\le$ n; i++) { cache.put(i, cache.get(i - 1) + cache.get(i - 2)); } return cache.get(n); } } 解法四：迭代 + 中间变量 解法三解决了栈溢出问题，其空间复杂度为 $O(n)$，可以进一步优化为 $O(1)$。\npublic class Solution { public static void main(String[] args) { System.out.println(fib(1)); System.out.println(fib(2)); System.out.println(fib(6)); } public static long fib(int n) { if (n == 1) { return 0; } if (n == 2){ return 1; } long prev1 = 0L; // F(1) long prev2 = 1L; // F(2) long current = 0L; for (int i = 3; i $\\le$ n; i++) { current = prev1 + prev2; prev1 = prev2; prev2 = current; } return current; } } 不同路径 点击查看题目 一个机器人位于一个 m x n 网格的左上角（如下图所示）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。\n问总共有多少条不同的路径？\n走格子示意图 示例 1\n输入：m = 3, n = 7\n输出：28\n示例 2：\n输入：m = 3, n = 2\n输出：3\n解释：\n从左上角开始，总共有 3 条路径可以到达右下角。\n向右 -\u0026gt; 向下 -\u0026gt; 向下 向下 -\u0026gt; 向下 -\u0026gt; 向右 向下 -\u0026gt; 向右 -\u0026gt; 向下 示例 3：\n输入：m = 7, n = 3\n输出：28\n示例 4：\n输入：m = 3, n = 3\n输出：6\n$1 \\le m, n \\le 100$\n题目数据保证答案小于等于 $2 * 10^9$\n--- title: 走格子：2 × 3 --- flowchart g23((\"2,3\")) --\u003e|down| g13((\"1,3\")) g23 --\u003e|right| g22((\"2,2\")) g13 --\u003e|down| g03((\"0,3\")) g13 --\u003e|right| g12((\"1,2\")) g22 --\u003e|down| g121((\"1,2\")) g22 --\u003e|right| g21((\"2,1\")) g12 --\u003e|down| g02((\"0,2\")) g12 --\u003e|right| g11((\"1,1\")) g121 --\u003e|down| g021((\"0,2\")) g121 --\u003e|right| g111((\"1,1\")) g21 --\u003e|down| g1111((\"1,1\")) g21 --\u003e|right| g20((\"2,0\")) style g23 fill:lightgreen,color:black style g13 fill:lightgreen,color:black style g22 fill:lightgreen,color:black style g12 fill:lightgreen,color:black style g22 fill:lightgreen,color:black style g121 fill:lightgreen,color:black style g21 fill:lightgreen,color:black style g11 fill:lightgreen,color:black style g111 fill:lightgreen,color:black style g1111 fill:lightgreen,color:black 走格子（$2\\times 3$）示意图 由上图可得出基本情况：当 $n$ 为 $0$ 或者 $m$ 为 $0$ 时，返回 $0$，当 $n = 1$ 并且 $m=1$ 时，返回 $1$.\n解法一：暴力递归 public static long gridTraveller(int m, int n) { if (m == 1 \u0026\u0026 n == 1) { return 1; } if (m == 0 || n == 0) { return 0; } return gridTraveller(m - 1, n) + gridTraveller(m, n - 1); } 解法二：递归 + 缓存 gridTraveller(m, n) = gridTraveller(n, m) 暴力递归解法的重复计算 import java.util.HashMap; import java.util.Map; public class GridTraveller { public static long gridTraveller(int m, int n) { return gridTraveller(m, n, new HashMap\u0026lt;\u0026gt;()); } private static long gridTraveller(int m, int n, Map\u0026lt;String, Long\u0026gt; memo) { String key = m + \",\" + n; if (memo.containsKey(key)) { return memo.get(key); } if (m == 1 \u0026\u0026 n == 1) { return 1; } if (m == 0 || n == 0) { return 0; } long result = gridTraveller(m - 1, n, memo) + gridTraveller(m, n - 1, memo); memo.put(key, result); return result; } public static void main(String[] args) { System.out.println(gridTraveller(3, 3)); // Output: 6 System.out.println(gridTraveller(18, 18)); // Output: 2333606220 } } 动态规划方法论（先递归再优化） 问题树化 寻找基本情况 暴力递归实现 使用缓存优化 题目 组合总和（canSum） 点击查看题目 给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target，判断 target 是否可以从 candidates 中的元素求和得到。\ncandidates 中的同一个数字可以无限制重复被选取 。\n示例 1:\n输入：candidates = [2,3,6,7], target = 7\n输出：true\n示例 2：\n输入: candidates = [2,3], target = 8\n输出：true\n示例 3：\n输入: candidates = [2], target = 1\n输出：false\n提示：\n1 $\\le$ candidates.length $\\le$ 30 2 $\\le$ candidates[i] $\\le$ 40 candidates 的所有元素互不相同 1 $\\le$ target $\\le$ 40 暴力递归 --- title: 组合总和（cansum）暴力递归 --- flowchart TB l1((8))--\u003e|-2| l21((6)) l1 --\u003e|-3| l22((5)) l21 --\u003e|-2| l31((4)) l21 --\u003e|-3| l32((3)) l22 --\u003e|-2| l33((3)) l22 --\u003e|-3| l34((2)) l31 --\u003e|-2| l41((2)) l31 --\u003e|-3| l42((1)) l32 --\u003e|-2| l43((1)) l32 --\u003e|-3| l44((0)) l33 --\u003e|-2| l45((1)) l33 --\u003e|-3| l46((0)) l34 --\u003e|-2| l47((0)) l34 --\u003e|-3| l48((\"-1\")) l41 --\u003e|-2| l51((0)) l41 --\u003e|-3| l52((\"-1\")) style l32 fill:lightblue,color:black style l33 fill:lightblue,color:black style l34 fill:red style l41 fill:red public class CanSum { public static void main(String[] args) { System.out.println(canSum(7, new int[]{2, 3})); // true System.out.println(canSum(7, new int[]{5, 3, 4, 7})); // true System.out.println(canSum(7, new int[]{2, 4})); // false System.out.println(canSum(8, new int[]{2, 3})); // true System.out.println(canSum(300, new int[]{7, 14})); // false } public static boolean canSum(int targetSum, int[] numbers) { if (targetSum == 0) { return true; } if (targetSum == 1 || targetSum \u003c 0) { // targetSum \u003c= 1 return false; } for (int number : numbers) { int remainder = targetSum - number; if (canSum(remainder, numbers)) { return true; } } return false; } } 使用缓存优化 --- title: 组合总和（cansum）使用缓存优化 --- flowchart subgraph tree[递归树] l1((8))--\u003e|-2| l21((6)) l1 --\u003e|-3| l22((5)) l21 --\u003e|-2| l31((4)) l21 --\u003e|-3| l32((3)) l22 --\u003e|-2| l33((3)) l22 --\u003e|-3| l34((2)) l31 --\u003e|-2| l41((2)) l31 --\u003e|-3| l42((1)) l32 --\u003e|-2| l43((1)) l32 --\u003e|-3| l44((0)) l41 --\u003e|-2| l51((0)) l41 --\u003e|-3| l52((\"-1\")) end subgraph cache[缓存] canSum2[\"canSum(2)\"] ~~~ canSum3[\"canSum(3)\"] end canSum2 -.-\u003e|使用缓存| l34 canSum3 -.-\u003e|使用缓存| l33 style l32 fill:lightblue,color:black style l33 fill:lightblue,color:black style l34 fill:red style l41 fill:red import java.util.HashMap; import java.util.Map; public class CanSum { public static void main(String[] args) { System.out.println(canSum(7, new int[]{2, 3})); // true System.out.println(canSum(7, new int[]{5, 3, 4, 7})); // true System.out.println(canSum(7, new int[]{2, 4})); // false System.out.println(canSum(8, new int[]{2, 3})); // true System.out.println(canSum(300, new int[]{7, 14})); // false } public static boolean canSum(int targetSum, int[] numbers) { return canSum(targetSum, numbers, new HashMap\u0026lt;\u0026gt;()); } private static boolean canSum(int targetSum, int[] numbers, Map\u0026lt;Integer, Boolean\u0026gt; memo) { if (memo.containsKey(targetSum)) { return memo.get(targetSum); } if (targetSum == 0) { return true; } if (targetSum == 1 || targetSum \u003c 0) { // targetSum \u003c= 1 return false; } for (int number : numbers) { int remainder = targetSum - number; if (canSum(remainder, numbers, memo)) { memo.put(targetSum, true); return true; } } memo.put(targetSum, false); return false; } } 组合总和（howSum） 组合总和（bestSum） ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/algorithms/2-dynamic-programming/","summary":"动态规划相关概念 动态规划核心思想： 将原问题划分为更简单的子问题，通过子问题的解来构建问题的解。 Memoization（自上而下法）：将原问题递归地划分为更小的子问题，并在对子问题的结果进行缓存，以避免重复计算。 Tabulation（自下而上法）：从最小的子问题开始，迭代地构建原问题的解。 动态规划例题 斐波那契数列 点击查看题目 斐波那契数（通常用 $F(n)$ 表示）形成的序列称为斐波那契数列。该数列由 $0$ 和 $1$ 开始，后面的每一项数字都是前面两项数字的和。也就是：\n$F(1) = 0，F(2) = 1$\n$F(n) = F(n - 1) + F(n - 2)，其中\\; n \u0026gt; 2$\n给定 $n$ ，请计算 $F(n)$。\n示例 1：\n输入：$n = 2$\n输出：$1$\n解释：$F(2) = 1$\n示例 2：\n输入：$n = 3$\n输出：$2$\n解释：$F(3) = F(2) + F(1) = 1 + 0 = 1$\n示例 3：\n输入：$n = 4$\n输出：$3$\n解释：$F(4) = F(3) + F(2) = 1 + 1 = 2$","title":"数据结构与算法：动态规划"},{"content":"导数 导数的定义 设函数 y = f(x) 在 x_0 的某邻域内有定义，如果极限 $$ \\displaystyle\\lim_{\\Delta x\\rightarrow 0}\\frac{\\Delta y}{\\Delta x} = \\lim_{\\Delta x \\rightarrow 0}\\frac{f(x_0 + \\Delta x) - f(x_0)}{\\Delta x} $$ 存在，则称 $f(x)$ 在点 $x_0$ 处可导，并称此极限值为 $f(x)$ 在点 $x_0$ 处的导数，记为 $f^\\prime(x_0)$。如果上述极限不存在，则称 $f(x)$ 在点 $x_0$ 处不可导。 记 $x = x_0 + \\Delta x$，则 $\\Delta x = x - x_0$，所以 $f^\\prime(x_0)$ 可表示为 $\\displaystyle\\lim_{x\\rightarrow 0}\\frac{f(x) - f(x_0)}{x - x_0}$。 $f^\\prime(x_0)$ 与 $f(x_0)$ 有关。 导数的本质是函数的变化率。 微分 微分的定义 微分是函数变化量的近似值。 设函数 $y = f(x)$ 在点 $x_0$ 的某一邻域内有定义，如果函数的增量 $\\Delta y = f(x_0 + \\Delta x) - f(x_0)$ 可以表示为 $$ \\Delta y = A\\Delta x + o(\\Delta x)，(\\Delta x \\rightarrow 0) $$ 其中 $A$ 为不依赖于 $\\Delta x$ 的常数，$o(\\Delta x)$ 是 $\\Delta x$ 的高阶无穷小，则称函数 $y = f(x)$ 在点 $x_0$ 处可微，并称 $\\Delta y$ 的线性主部 $A\\Delta x$ 为函数 $y = f(x)$ 在点 $x_0$ 处的微分，记作 $\\mathrm{d}y$，即 $\\mathrm{d}y = A\\Delta x$ 微分本质是函数变化量的线性主部（$\\Delta y = A\\Delta x, A\\;为常数$） 导数与微分的几何意义 导数是切线的斜率，微分是切线上的增量。 导数与微分的几何意义 导数 $f^\\prime(x_0)$ 在几何上表示曲线 $y = f(x)$ 在点 $(x_0, f(x_0))$ 处切线的斜率。 如果函数 $f(x)$ 在点 $x_0$ 处可导，则曲线 $y = f(x)$ 在点 $(x_0, f(x_0))$ 处的切线方程为 $$ y - f(x_0) = f\u0026rsquo;(x_0)(x - x_0) $$ 如果 $f\u0026rsquo;(x_0) \\ne 0$，则此曲线 $y = f(x)$ 在点 $(x_0, f(x_0))$ 处的法线方程为 $$ y - f(x_0) = -\\frac{1}{f\u0026rsquo;(x_0)}(x - x_0) $$ 微积分思想 在微小的局部，用线性变化代替非线性变化。 在微小的局部，用切线上的增量代替曲线上的增量。 ","permalink":"https://signalyu.github.io/posts/1-natural-science/math/calculus/4-derivative-and-differential/","summary":"导数 导数的定义 设函数 y = f(x) 在 x_0 的某邻域内有定义，如果极限 $$ \\displaystyle\\lim_{\\Delta x\\rightarrow 0}\\frac{\\Delta y}{\\Delta x} = \\lim_{\\Delta x \\rightarrow 0}\\frac{f(x_0 + \\Delta x) - f(x_0)}{\\Delta x} $$ 存在，则称 $f(x)$ 在点 $x_0$ 处可导，并称此极限值为 $f(x)$ 在点 $x_0$ 处的导数，记为 $f^\\prime(x_0)$。如果上述极限不存在，则称 $f(x)$ 在点 $x_0$ 处不可导。 记 $x = x_0 + \\Delta x$，则 $\\Delta x = x - x_0$，所以 $f^\\prime(x_0)$ 可表示为 $\\displaystyle\\lim_{x\\rightarrow 0}\\frac{f(x) - f(x_0)}{x - x_0}$。 $f^\\prime(x_0)$ 与 $f(x_0)$ 有关。 导数的本质是函数的变化率。 微分 微分的定义 微分是函数变化量的近似值。 设函数 $y = f(x)$ 在点 $x_0$ 的某一邻域内有定义，如果函数的增量 $\\Delta y = f(x_0 + \\Delta x) - f(x_0)$ 可以表示为 $$ \\Delta y = A\\Delta x + o(\\Delta x)，(\\Delta x \\rightarrow 0) $$ 其中 $A$ 为不依赖于 $\\Delta x$ 的常数，$o(\\Delta x)$ 是 $\\Delta x$ 的高阶无穷小，则称函数 $y = f(x)$ 在点 $x_0$ 处可微，并称 $\\Delta y$ 的线性主部 $A\\Delta x$ 为函数 $y = f(x)$ 在点 $x_0$ 处的微分，记作 $\\mathrm{d}y$，即 $\\mathrm{d}y = A\\Delta x$ 微分本质是函数变化量的线性主部（$\\Delta y = A\\Delta x, A\\;为常数$） 导数与微分的几何意义 导数是切线的斜率，微分是切线上的增量。 导数与微分的几何意义 导数 $f^\\prime(x_0)$ 在几何上表示曲线 $y = f(x)$ 在点 $(x_0, f(x_0))$ 处切线的斜率。 如果函数 $f(x)$ 在点 $x_0$ 处可导，则曲线 $y = f(x)$ 在点 $(x_0, f(x_0))$ 处的切线方程为 $$ y - f(x_0) = f\u0026rsquo;(x_0)(x - x_0) $$ 如果 $f\u0026rsquo;(x_0) \\ne 0$，则此曲线 $y = f(x)$ 在点 $(x_0, f(x_0))$ 处的法线方程为 $$ y - f(x_0) = -\\frac{1}{f\u0026rsquo;(x_0)}(x - x_0) $$ 微积分思想 在微小的局部，用线性变化代替非线性变化。 在微小的局部，用切线上的增量代替曲线上的增量。 ","title":"导数与微分"},{"content":"数组 数组基本概念 在 C 语言中，越界访问数组编译器并不会报错； 一维数组的长度计算：int length = sizeof(arr) / sizeof(arr[0]); sizeof 返回值的数据类型是 size_t ，所以 sizeof(a) / sizeof(a[0]) 的数据类型也是 size_t。在 printf() 里面的占位符，要用 %zd 或 %zu 。 一维数组的内存分析： 一维数组的内存分析 C 语言规定，数组变量一旦声明，数组名指向的地址就不可更改。因此，使用大括号赋值时，必须在数组声明时赋值，否则编译时会报错。 int nums[5]; nums = {1, 2, 3, 4, 5}; // 报错 int nums[5] = {1, 2, 3, 4, 5}; // 正确写法 数组的复制 使用循环复制数组： void copyArray(int src[], int dest[], int size) { for (int i = 0; i \u003c size; i++) { dest[i] = src[i]; } } 使用 memcopy() 函数复制数组： #include \u0026lt;string.h\u0026gt; int main() { // ... memcpy(dest, src, sizeof(src)); return 0; } 使用指针对数组进行赋值和遍历 使用指针变量对数组进行赋值和遍历的效率比下标法高。\n#include \u0026lt;stdio.h\u0026gt; #define N 5 int main() { int a[N]; int *p = a; printf(\"请输入%d个整数：\\n\", N); for (int i = 0; i \u003c N; i++) { scanf(\"%d\", p + i); } for (int i = 0; i \u003c N; i++) { printf(\"%d \", *(p + i)); } printf(\"\\n\"); return 0; } 点击查看题目 下列 C 语言代码是否正确？ #include \u0026lt;stdio.h\u0026gt; #define N 5 int main() { int a[N]; int *p = a; printf(\"请输入%d个整数：\\n\", N); for (int i = 0; i \u003c N; i++) { scanf(\"%d\", \u0026a[i]); } for (p = a; a \u003c (p + N); a++) { printf(\"%d\", *a); } printf(\"\\n\"); return 0; } 点击查看答案 下列代码不正确： for (p = a; a \u003c (p + N); a++) { printf(\"%d\", *a); } 数组名 a 代表数组的首地址（或数组首元素的地址），它是一个指针型常量 ，它的值在程序运行期间是固定不变的。所以 a++ 是无法实现的。必须将 a 的地址赋值给指针变量 p ，然后对 p 进行自增。正确写法为： for (p = a; p \u003c (a + N); p++) { printf(\"%d \", *p); } 指针 指针的基本概念 变量：命名的内存空间，用于存放各种类型的数据； 变量名：为标记某块内存空间而采用的便于记忆的名字； 变量值：在变量单元中存放的数据值； 指针：指针是指变量所使用的内存空间的地址； 变量名 内存地址 内容 i 0x00000001 1 0x00000002 0x00000003 0x00000004 j 0x00000005 2 0x00000006 0x00000007 0x00000008 指针变量：指针变量是一个专门用来存放另一变量在内存中数据的地址的变量。通过访问指针变量，可以访问内存中另一个变量数据。 指针变量 指针的本质及其运算 指针本质上是一个代表内存地址的无符号整数。因此它可以进行整数加减，自增自减、同类指针相减等操作，但运算规则并不是整数运算规则。 指针与整数值的加减运算：表示指针所指向内存地址的移动。指针移动的单位，与指针指向的数据类型有关。数据类型占据多少个字节，每单位就移动多少个字节。 注意：只有指向连续的同类型数据区域，指针加、减整数才有实际意义。 指针的自增与自减：指针的增加或减少是指内存地址的向前或向后移动。 int arr[] = {1, 2, 3}; int *p = \u0026amp;arr; printf(\"arr[0] = %d\\n\", *p); // arr[0] = 1 printf(\"arr[1] = %d\\n\", *(++p)); // arr[1] = 2 同类指针相减运算：相同类型的指针允许进行减法运算，返回它们之间的距离，即相隔多少个数据单位（非字节数）。返回的值属于头文件 stddef.h 里面的 ptrdiff_t 类型，这是一个带符号的整数类型别名，具体类型根据系统不同而不同。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stddef.h\u0026gt; int main() { short *ps1; short *ps2; ps1 = (short *) 0x1234; ps2 = (short *) 0x1236; ptrdiff_t dist = ps2 - ps1; printf(\"%d\\n\", dist); // 1（相差2个字节正好存放1个short类型的值） int *pi1; int *pi2; pi1 = (int *) 0x1234; pi2 = (int *) 0x1244; ptrdiff_t dist1 = pi2 - pi1; printf(\"%d\\n\",dist1); // 4（相差16个字节正好存放4个int类型的值） return 0; } 指针间的比较运算：比较各自的内存地址的大小，返回值是整数 1（true）或 0（false）。 取址运算符（\u0026amp;）：取之运算符用于取出指定变量在内存中的地址。 int num = 10; int *p; // p 为整型指针变量，建议写成 int *p = NULL; p = \u0026amp;num; // 必须为整型指针 printf(\"\u0026num = %p\", \u0026num); // 格式输出符为 %p 取值运算符（*）：取值运算符用于获取给定内存地址的数据值，它与取址运算符（\u0026amp;）互为逆运算。 int num = 10; int *p; // p 为整型指针变量，建议写成 int *p = NULL; p = \u0026amp;num; // 必须为整型指针 printf(\"\u0026num = %p\\n\", \u0026num); // 格式输出符为 %p printf(\"num = %d\", *p); // 取出指针 p 的值 野指针 野指针：野指针指的是指向未知知内存的一类指针； 野指针的成因主要有如下三种： 指针使用前未初始化：指针变量在定义时如果未初始化，其值是随机的，此时操作指针就是去访问一个不确定的地址，所以结果是不可知的。此时 p 为野指针。 int *p; // 建议写成 int *p = NULL; printf(\"%d\\n\", *p); // 输出的值每次都不一样 指针越界访问： int arr[10] = {0}; int *p = arr; for (int i = 0; i \u003c= 10; i++, p++) { *p = i; // i = 10 时越界 } 指针指向已释放的空间： test.c 输出结果 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int *test() { int a = 10; return \u0026amp;a; } int main() { int *p = test(); printf(\"*p = %d\", *p); printf(\"\\n暂停两秒...\\n\"); sleep(2); // 暂停两秒 printf(\"*p = %d\\n\", *p); return 0; } $ gcc -Wall -o test test.c test.c:6:13: warning: address of stack memory associated with local variable 'a' returned [-Wreturn-stack-address] return \u0026amp;a; ^ 1 warning generated. $ ./test *p = 10 暂停两秒... *p = 1 调用 test 函数将返回值赋给 p，test 函数的返回值是局部变量 a 的地址。由于 a 只在 test 函数内有效，出了 test 函数其内存空间就被释放，也就意味着 a 的地址编号不存在，若将其赋值给 p，导致 p 获取到的地址是无效的。如果短时间内再次利用这块地址，它的值还未被改变，此时 p 的值为 a 的地址值，*p 返回 10。如果在打印之前有其他函数调用了这块地址，这块地址的名称就会发生变化，*p 不再返回 10。 野指针的避免： 定义指针时，如果没有确切的地址赋值，应该为指针变量赋一个NULL值。即： int *p = NULL; 赋为NULL值的指针被称为空指针，NULL指针是一个定义在标准库中的值为零的常量#define NULL 0。 访问数组元素时，避免越界(0 ≤ i \u0026lt; arr.length)访问。 避免将函数返回的局部变量的地址值赋值给指针。 指针指向的空间被释放时，应该及时将指针置为NULL。 int *ptr = (int *) malloc(sizeof(int)); free(ptr); // 释放内存 ptr = NULL; // 将指针设置为 NULL 指针使用之前应进行有效性检查： if (ptr != NULL) { // ... } 二级指针 二级指针是指一个指针变量的值是另一个指针变量的地址。 int a = 20; int *pa = \u0026a; // pa是一级指针 int **ppa = \u0026pa; // ppa是二级指针，类型为int ** 二级指针 数组指针与指针数组 数组指针是指存放数组首地址的指针变量；指针数组是指存放指针的数组。 ###添加案例 数组指针与指针数组 字符数组和字符指针变量 字符数组由若干个元素组成，每个元素存放一个字符。 char str[] = \"signal\"; // 使用字符数组 字符数组 字符指针变量中存放的是地址（字符串或字符数组的首地址）。 char *pStr = \"signal\"; // 使用字符指针 字符指针 对已声明好的字符数组，只能一一对各个元素赋值，而不能对整个字符数组赋值： char str[14]; str[0] = 'i'; // 正确 str = \"signal\"; // 错误，不能对整个字符数组赋值 对已声明好的字符指针变量，可以采用如下方式赋值： char *pStr = \"\"; pStr = \"signal\"; // 正确 字符指针重新赋值 一个字符数组，因为它有确定的内存地址，所以字符数组名是一个常量 。而定义一个字符指针变量时，它在指向某个确定的字符串数据的情况下，可以多次重新赋值 。 字符串字面量存储在只读内存区域，是不可变的，不能修改其值。 char arr[] = \"hello\"; arr[1] = \"m\"; // 运行时错误 char *pStr = \"hello\"; pStr = \"hello tom\"; // 正确 pStr[1] = 'm'; // 运行时错误 ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/tech/c/1-array-and-pointer-in-c/","summary":"数组 数组基本概念 在 C 语言中，越界访问数组编译器并不会报错； 一维数组的长度计算：int length = sizeof(arr) / sizeof(arr[0]); sizeof 返回值的数据类型是 size_t ，所以 sizeof(a) / sizeof(a[0]) 的数据类型也是 size_t。在 printf() 里面的占位符，要用 %zd 或 %zu 。 一维数组的内存分析： 一维数组的内存分析 C 语言规定，数组变量一旦声明，数组名指向的地址就不可更改。因此，使用大括号赋值时，必须在数组声明时赋值，否则编译时会报错。 int nums[5]; nums = {1, 2, 3, 4, 5}; // 报错 int nums[5] = {1, 2, 3, 4, 5}; // 正确写法 数组的复制 使用循环复制数组： void copyArray(int src[], int dest[], int size) { for (int i = 0; i \u003c size; i++) { dest[i] = src[i]; } } 使用 memcopy() 函数复制数组： #include \u0026lt;string.","title":"C 语言中的数组与指针"},{"content":"用户管理 软件安装 yum 和 dnf yum (Yellowdog Updater, Modified) 和 dnf (Dandified Yum) 都是基于 Red Hat 的 Linux 发行版的包管理工具。dnf 是 yum 管理工具的增强版，centos 8 及后续版本采用 dnf 为 软件包管理工具。 dnf 常用命令如下： 更新所有 package：sudo dnf update 安装 package：sudo dnf install package_name 移除一个 package：sudo dnf remove package_name 列出已安装的 package：dnf list installed 查找指定的 package：dnf search package_naem 安装 MySQL 更新所有已安装的 package： $ sudo dnf update 安装 mysql-server： $ sudo dnf install mysql-server -y 启动 mysqld 服务查看其状态： $ sudo systemctl start mysqld # 允许机器启动时自动启动 mysqld $ sudo systemctl enable mysqld Created symlink /etc/systemd/system/multi-user.target.wants/mysqld.service → /usr/lib/systemd/system/mysqld.service. # 查看 MySQL 服务状态 $ sudo systemctl status mysqld # 列出所有服务状态 $ sudo systemctl list-units --type=service MySQL 安全设置： $ mysql_secure_installation # 执行 mysql_secure_installation 命令后根据提示设置即可 配置 MySQL 用户和权限： $ mysql -u root -p # 登录 MySQL shell # @'localhost' 表示只允许当前创建的用户从本机连接 MySQL # @'%' 表示允许当前创建的用户从任意主机连接 MySQL # @'192.168.252.140' 表示只允许当前创建的用户从 IP 地址为 192.168.252.140 的主机连接 MySQL $ CREATE USER 'user_name'@'%' IDENTIFIED BY 'user_password'; # 创建时更改 'user_name' 和 'user_password' Query OK, 0 rows affected (0.01 sec) # ON *.* 表示权限的允许范围 # 第一个 * 表示所有数据库 # 第二个 * 表示这些数据库的所有表 # WITH GRANT OPTION 表示允许用户向其他用户授予相同的权限 # 即当前被授予权限的用户可以创建其他用户，并授予他们相同的权限 $ GRANT ALL PRIVILEGES ON *.* TO 'user_name'@'%' WITH GRANT OPTION; Query OK, 0 rows affected (0.00 sec) $ FLUSH PRIVILEGES; # 刷新权限，确保操作生效 Query OK, 0 rows affected (0.00 sec) 配置 MySQL 的配置文件：\n/etc/my.cnf：适用于设置服务器和客户端的全局配置选项 [client] port=3306 socket=/var/lib/mysql/mysql.sock [mysqld] port=3306 datadir=/var/lib/mysql socket=/var/lib/mysql/mysql.sock log-error=/var/log/mysqld.log pid-file=/var/run/mysqld/mysqld.pid /etc/my.cnf.d/client.cnf：适用于设置客户端的配置信息 [client] user=root password=my-secret-password /etc/my.cnf.d/mysql-server.cnf：适用于设置服务器的配置信息 [mysqld] bind-address=0.0.0.0 max_connections=500 default-storage-engine=InnoDB 常用配置如下： bind-address=127.0.0.1 # 不允许远程连接 sql_mode=STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER # 防止创建没有密码的用户 default-character-set=utf8mb4 # 默认字符集 log-error=/var/log/mysql/error.log：错误日志 防火墙配置： $ firewall-cmd --permanent --zone=public --add-service=mysql success $ sudo firewall-cmd --reload success 定期更新 MySQL：sudo dnf update mysql-server\n备份 MySQL 数据库： # 将所有数据库备份到 all_databases_backup.sql 文件中 $ mysqldump -u root -p --all-databases \u003e all_databases_backup.sql # 恢复所有数据库 $ mysql -u root -p \u003c all_databases_backup.sql # 将指定数据库备份到 mydatabase_backup.sql 文件中 $ mysqldump -u root -p mydatabase \u003e mydatabase_backup.sql # 恢复指数据库 $ mysql -u root -p mydatabase \u003c mydatabase_backup.sql 从 IntelliJ 连接 MySQL 前务必关闭 VPN\n安装 Minio $ wget https://dl.min.io/server/minio/release/linux-amd64/archive/minio-20240528171904.0.0-1.x86_64.rpm -O minio.rpm # Minio 官网：https://min.io/docs/minio/linux/operations/install-deploy-manage/deploy-minio-single-node-single-drive.html sudo dnf install minio.rpm -y 创建 systemd 服务文件：需要注意的是，systemd 在检查 /usr/lib/systemd/\u0026hellip; 路径之前会先检查 /etc/systemd/...，为避免冲突，应确保 minio.service 文件仅存在 /usr/lib/systemd/system/ 目录内。 $ sudo vim /usr/lib/systemd/system/minio.service [Service] Type=notify WorkingDirectory=/usr/local User=signal # 更改用户名 Group=signal # 更改用户组 点击查看 systemd 服务文件相关知识 \u0026ldquo;systemd service file\u0026rdquo; 是 Linux 中用于定义管理服务规则的文件，其核心概念包括 Unit Section、Service Section 和 Install Section。 [Unit] Description=My Web Application After=network.target [Service] Type=simple User=myappuser ExecStart=/usr/bin/myapp Restart=on-failure [Install] WantedBy=multi-user.target Unit Section： Description：服务描述 After：服务在某个服务启动后启动 例：Description=My Web Application 例：After=network.target # 在 network.target 启动后启动\nType：定义服务的启动类型。常见类型包括 simple：默认；立即启动服务。 forking：服务作为后台进程启动。 oneshot：服务只执行一项任务，然后退出。 notify：服务将通知 systemd 其启动完成。 idle：服务将在系统空闲时启动。 例：Type=simple\nUser：指定服务运行的用户 例：User=minioadmin\nExecStart：启动服务的命令 例：ExecStart=/usr/bin/myapp\nRestart：定义服务退出时的重启行为 no：不重启 on-failure：在非零错误状态下（non-zero exit status）重启服务 always：始终重启服务 例子：Restart=always\n知识延伸（exit status）：\n在类 Unix 操作系统中，进程终止时会返回一个数值类型的退出状态码。0 表示成功退出，非 0 表示非正常退出。 常见的退出状态码如下： Exit Status 0: 成功 Exit Status 1: General error. Exit Status 2: Misuse of shell builtins (e.g., unknown command). Exit Status 126: Command invoked cannot execute. Exit Status 127: Command not found. Exit Status 128: Invalid argument to exit. Exit Status 130: Terminated by Control-C (interrupt signal). Exit Status 137: Terminated by kill signal. Exit Status 255: Exit status out of range. 创建环境变量文件： $ sudo vim /etc/default/minio # 配置内容如下： MINIO_ROOT_USER=minioadmin MINIO_ROOT_PASSWORD=minioadmin MINIO_VOLUMES=\"/mnt/data\" MINIO_OPTS=\"--console-address :9001\" 更改 /usr/lib/systemd/system/minio.service 文件中 User 和 Group 为 root： User=root Group=root # 因为 /usr/local/bin/minio 文件执行需要 root 用户 禁用防火墙： $ sudo systemctl stop firewalld $ sudo systemctl disable firewalld # 不禁用防火墙可以使用如下步骤： sudo firewall-cmd --zone=public --add-service=minio --permanent sudo firewall-cmd --reload 从浏览器访问 Minio 前务必关闭 VPN Minio 相关错误 sudo firewall-cmd --check-config Error: INVALID_SERVICE: Zone 'public': 'minio' not among existing services 解决方案： sudo vim /etc/firewalld/services/minio.xml # 添加如何内容后保存退出 \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt; \u0026lt;service\u0026gt; \u0026lt;short\u0026gt;Minio\u0026lt;/short\u0026gt; \u0026lt;description\u0026gt;Minio Object Storage\u0026lt;/description\u0026gt; \u0026lt;port protocol=\u0026quot;tcp\u0026quot; port=\u0026quot;9000\u0026quot;/\u0026gt; \u0026lt;/service\u0026gt; sudo firewall-cmd --reload sudo systemctl restart firewalld 安装 Redis sudo dnf update -y sudo dnf install redis -y sudo systemctl enable redis sudo systemctl start redis sudo systemctl status redis sudo vim /etc/redis/redis.conf 安装 Docker 添加 Docker 仓库： sudo dnf config-manager --add-repo=https://download.docker.com/linux/centos/docker-ce.repo sudo dnf repolist -v（可以下载，网速很慢） 下载 Docker CE：sudo dnf install docker-ce 允许开机自启：sudo systemctl enable --now docker 查看状态：sudo systemctl status docker 测试：docker run hello-world vim bash 网络管理 配置静态 IP 设置虚拟机的网络为 NAT：VMware Fusion -\u0026gt; Virtual Machine -\u0026gt; Network Adapter -\u0026gt; NAT 修改虚拟机的网络适配器网络：选中虚拟机 -\u0026gt; CMD+, -\u0026gt; Network -\u0026gt; Share with my Mac 获取子网掩码（Mac 终端）： $ cat /Library/Preferences/VMware\\ Fusion/vmnet8/nat.conf | grep netmask netmask = 255.255.255.0 获取网关（Mac 终端）： $ cat /Library/Preferences/VMware\\ Fusion/vmnet8/nat.conf | grep \"ip =\" ip = 192.168.252.2 获取网络接口名称（Centos 终端）： $ ip a | grep ens 2: ens33: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 inet 192.168.252.145/24 brd 192.168.252.255 scope global dynamic noprefixroute ens33 配置静态 IP（Centos 终端）： $ sudo vim /etc/sysconfig//network-scripts/ifcfg-ens33 # 具体配置如下： TYPE=Ethernet NAME=ens33 DEVICE=ens33 BOOTPROTO=static ONBOOT=yes IPADDR=192.168.252.140 NETMASK=255.255.255.0 GATEWAY=192.168.252.2 DNS1=223.5.5.5 重启网络： $ sudo systemctl restart NetworkManager 查看 IP 是否生效： $ ip a # 如果未生效，重启 centos 即可 检验网络： $ ping baidu.com PING baidu.com (39.156.66.10) 56(84) bytes of data. 64 bytes from 39.156.66.10 (39.156.66.10): icmp_seq=1 ttl=128 time=47.6 ms 64 bytes from 39.156.66.10 (39.156.66.10): icmp_seq=2 ttl=128 time=52.9 ms 64 bytes from 39.156.66.10 (39.156.66.10): icmp_seq=3 ttl=128 time=46.1 ms ^C --- baidu.com ping statistics --- 3 packets transmitted, 3 received, 0% packet loss, time 2002ms rtt min/avg/max/mdev = 46.103/48.852/52.875/2.907 ms Firewall firewalld-cmd 是一种动态防火墙管理工具，提供了一种无需重启防火墙即可配置防火墙规则和设置的方法。firewalld-cmd 相关的常用命令如下： $ sudo systemctl start firewalld # 启动防火墙 $ sudo systemctl enable firewalld # 允许开机时自动启动防火墙 $ sudo firewall-cmd --state # 检查防火墙状态 running # firewalld 使用 zone 来定义网络连接或接口的信任级别。 $ sudo firewall-cmd --get-zones # 列出所有的 zone block dmz drop external home internal nm-shared public trusted work $ sudo firewall-cmd --get-active-zone # 获取活跃的 zone public interfaces: ens33 $ sudo firewall-cmd --zone=public --list-all # 列出某个 zone 的所有规则 public (active) target: default icmp-block-inversion: no interfaces: ens33 sources: services: cockpit dhcpv6-client ssh ports: protocols: forward: yes masquerade: no forward-ports: source-ports: icmp-blocks: rich rules: # 添加服务到 zone $ sudo firewall-cmd --zone=public --add-service=mysql # 操作重启后失效 $ sudo firewall-cmd --zone=public --add-service=mysql --permanent # 操作永久有效 # 从 zone 中移除一个服务 $ sudo firewall-cmd --zone=public --remove-service=mysql # 操作重启后失效 $ sudo firewall-cmd --zone=public --remove-service=http --permanent # 操作永久有效 # 添加端口到 zone $ sudo firewall-cmd --zone=public --add-port=8080/tcp # 操作重启后失效 $ sudo firewall-cmd --zone=public --add-port=8080/tcp --permanent # 操作永久有效 # 从 zone 中移除端口 $ sudo firewall-cmd --zone=public --remove-port=8080/tcp # 操作重启后失效 $ sudo firewall-cmd --zone=public --remove-port=8080/tcp --permanent # 操作永久有效 # 对带有 --permanent 参数的操作，需要进行 reload 操作 $ sudo firewall-cmd --reload # firewalld 的 zone 的常见信任级别： # public：用于公共区域，只允许选定的连接。 # trusted：接受所有网络连接。 ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/tech/linux/1-centos-linux-manual/","summary":"用户管理 软件安装 yum 和 dnf yum (Yellowdog Updater, Modified) 和 dnf (Dandified Yum) 都是基于 Red Hat 的 Linux 发行版的包管理工具。dnf 是 yum 管理工具的增强版，centos 8 及后续版本采用 dnf 为 软件包管理工具。 dnf 常用命令如下： 更新所有 package：sudo dnf update 安装 package：sudo dnf install package_name 移除一个 package：sudo dnf remove package_name 列出已安装的 package：dnf list installed 查找指定的 package：dnf search package_naem 安装 MySQL 更新所有已安装的 package： $ sudo dnf update 安装 mysql-server： $ sudo dnf install mysql-server -y 启动 mysqld 服务查看其状态： $ sudo systemctl start mysqld # 允许机器启动时自动启动 mysqld $ sudo systemctl enable mysqld Created symlink /etc/systemd/system/multi-user.","title":"Linux 参考手册（Centos 9 Stream）"},{"content":"Boyer Moore 投票算法逻辑步骤 初始化候选人（candidate）和计票器（counter）； 遍历数组寻找可能为最大元素的候选人： count == 0 --\u0026gt; candidate = current element; count = 0 (current element == candidate) ? count++ : count-- 遍历数组验证候选人是否为多数元素（majority element）： count = 0 (current element == candidate) ? count++ 判断 count 是否过半 Boyer Moore 投票算法核心：只要数组中某元素出现次数过半，则遍历完毕后 candidate 变量必然指向该元素。 点击查看代码 majorityElement.c 测试代码 输出结果 int majorityElement(int const nums[], int size) { // 初始化候选人和计票器 int candidate = 0; int count = 0; // 遍历数组确定候选人 for (int i = 0; i \u003c size; i++) { if (count == 0) { candidate = nums[i]; count++; } else if (nums[i] == candidate) { count++; } else { count--; } } // 遍历数组判断候选人是否为多数元素 count = 0; for (int i = 0; i \u003c size; i++) { if (nums[i] == candidate) { count++; } } // 存在多数元素 if (count \u003e size / 2) { return candidate; } // 不存在多数元素 return -1; } #include \u0026lt;stdio.h\u0026gt; int main() { int nums1[] = {3, 2, 3}; int numsSize1 = sizeof(nums1) / sizeof(nums1[0]); printf(\"Majority element in nums1: %d\\n\", majorityElement(nums1, numsSize1)); int nums2[] = {2, 2, 1, 1, 1, 2, 2}; int numsSize2 = sizeof(nums2) / sizeof(nums2[0]); printf(\"Majority element in nums2: %d\\n\", majorityElement(nums2, numsSize2)); } Majority element in nums1: 3 Majority element in nums2: 2 ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/algorithms/1-boyer-moore-voting-algorithm/","summary":"Boyer Moore 投票算法逻辑步骤 初始化候选人（candidate）和计票器（counter）； 遍历数组寻找可能为最大元素的候选人： count == 0 --\u0026gt; candidate = current element; count = 0 (current element == candidate) ? count++ : count-- 遍历数组验证候选人是否为多数元素（majority element）： count = 0 (current element == candidate) ? count++ 判断 count 是否过半 Boyer Moore 投票算法核心：只要数组中某元素出现次数过半，则遍历完毕后 candidate 变量必然指向该元素。 点击查看代码 majorityElement.c 测试代码 输出结果 int majorityElement(int const nums[], int size) { // 初始化候选人和计票器 int candidate = 0; int count = 0; // 遍历数组确定候选人 for (int i = 0; i \u003c size; i++) { if (count == 0) { candidate = nums[i]; count++; } else if (nums[i] == candidate) { count++; } else { count--; } } // 遍历数组判断候选人是否为多数元素 count = 0; for (int i = 0; i \u003c size; i++) { if (nums[i] == candidate) { count++; } } // 存在多数元素 if (count \u003e size / 2) { return candidate; } // 不存在多数元素 return -1; } #include \u0026lt;stdio.","title":"数据结构与算法：投票算法"},{"content":"基本等价无穷小 $\\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\sin x}{x} = 1$ 点击查看证明过程 $ 如下图可知：S_{三角形ABC} \u0026lt; S_{扇形ABC} \u0026lt; S_{三角形 ABD}\\\\ 即：\\frac{1}{2}\\sin x \u0026lt; \\frac{1}{2}x\u0026lt;\\frac{1}{2}\\tan x\\\\ 即：\\sin x \u0026lt; x \u0026lt; \\tan x\\\\ 即：1 \u0026lt; \\frac{x}{\\sin x} \u0026lt; \\frac{1}{\\cos x}\\\\ 即：\\cos x \u0026lt; \\frac{\\sin x}{x} \u0026lt; 1\\\\ 因为 \\lim_{x\\rightarrow 0}\\cos x = \\lim_{x\\rightarrow 0} 1 = 1\\\\ 由夹逼准则可知 \\lim_{x\\rightarrow 0}\\frac{\\sin x}{x} = 1 $ 图：$\\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\sin x}{x}$ $\\displaystyle\\lim_{x\\rightarrow 0}(1+x)^{\\frac{1}{x}} = e$ 点击查看证明过程 $ 令\\;L = \\displaystyle\\lim_{x\\rightarrow 0}(1+x)^{\\frac{1}{x}}\\\\ 则\\;\\ln L = \\displaystyle\\lim_{x\\rightarrow 0}\\ln (1+x)^{\\frac{1}{x}}\\\\ 即：\\ln L = \\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\ln (1+x)}{x} \\xlongequal{ 洛必达法则 }\\lim_{x\\rightarrow 0}\\frac{1}{1+x} = 1\\\\ 所以\\;L = e $ 点击查看证明过程 $ $ $\\displaystyle\\lim_{x\\rightarrow \\infty}(1+\\frac{1}{x})^x = e$ 点击查看证明过程 $ 令\\;L = \\displaystyle\\lim_{x\\rightarrow 0}(1+\\frac{1}{x})^x\\\\ 则\\;ln L = \\lim_{x\\rightarrow 0}x\\ln(1+\\frac{1}{x}) = \\lim_{x\\rightarrow 0}\\frac{\\ln(1 + \\frac{1}{x})}{\\frac{1}{x}} \\xlongequal{洛必达法则} \\lim_{x\\rightarrow 0}\\frac{\\frac{-\\frac{1}{x^2}}{1+\\frac{1}{x}}}{-\\frac{1}{x^2}} = \\lim_{x\\rightarrow 0}\\frac{1}{1+\\frac{1}{x}} = 1\\\\ 所以 \\;L = e $ 常用等价无穷小证明 $x \\sim \\tan x$ 点击查看证明过程 $ \\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\tan x}{x} = \\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\sin x}{\\cos x\\cdot x} = \\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\sin x}{x} = 1 $ $\\arcsin x \\sim x$ 点击查看证明过程 $ 令 \\;t = \\arcsin x，则\\;x = \\sin t\\\\ 所以\\;\\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\arcsin x}{x} = \\displaystyle\\lim_{t\\rightarrow 0} = \\frac{t}{\\sin t} = 1 $ $\\arctan x \\sim x$ 点击查看证明过程 $ 令 \\;t = \\arctan x，则\\;x = \\tan t\\\\ 所以\\;\\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\arctan x}{x} = \\displaystyle\\lim_{t\\rightarrow 0} = \\frac{t}{\\tan t} = 1 $ $\\log_a(1+x) \\sim \\frac{x}{\\ln a}$ 点击查看证明过程 $\n$\n$\\ln (1+x) \\sim x$ 点击查看证明过程 $ \\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\ln (1+x)}{x} = \\frac{1}{x}\\cdot \\lim_{x\\rightarrow 0} \\ln(1+x) = \\lim_{x\\rightarrow 0} (1+x)^{\\frac{1}{x}} = \\ln e = 1 $ $\\log_a(1+x) \\sim \\frac{x}{\\ln a}$ 点击查看证明过程 $ \\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\log_a(1+x)}{\\frac{x}{\\ln a}} \\xlongequal{ 对数换底公式 } \\frac{\\frac{\\ln (1+x)}{\\ln a}}{\\frac{x}{\\ln a}} = \\frac{\\ln(1+x)}{x} = 1 $ $对数换底公式证明\\;(\\log_a M = \\frac{\\log_b M}{\\log_b a})：\\\\ \\;\\\\ 令\\begin{cases} x = \\log_a M \\\\ y = \\log_b M \\\\ z = \\log_b a \\end{cases} \\implies \\begin{cases} M = a^x \u0026amp;\\\\ M = b^y \u0026amp;\\\\ a = b^z \\end{cases}\\\\ \\therefore b^y = M = a^x = (b^z)^x = b^{xz}\\\\ \\therefore y = xz，即：\\log_b M = \\log_a \\cdot \\log_b a\\\\ 即：\\log_a M = \\frac{\\log_b M}{\\log_b a} = \\frac{\\ln M}{\\ln a} \\;(b = e)\\\\ 原命题得证。 $ $e^x - 1 \\sim x$ 点击查看证明过程 $ 令 \\;t = e^x - 1，则\\;x = \\ln(1+t)\\\\ 所以 \\displaystyle\\lim_{x\\rightarrow 0}\\frac{e^x - 1}{x} = \\lim_{t\\rightarrow 0}\\frac{t}{\\ln(1+t)} = 1 $ $a^x - 1 \\sim x\\ln a$ 点击查看证明过程 $ 令 \\;t = a^x - 1，则\\;x\\ln a = \\ln(1+t)\\\\ 所以 \\displaystyle\\lim_{x\\rightarrow 0}\\frac{a^x - 1}{x\\ln a} = \\lim_{t\\rightarrow 0}\\frac{t}{\\ln(1+t)} = 1 $ $(1+x)^{\\alpha} - 1 \\sim \\alpha x$ 点击查看证明过程 $ \\displaystyle\\lim_{x\\rightarrow 0}\\frac{(1+x)^{\\alpha} - 1}{\\alpha x} = \\lim_{x\\rightarrow 0}\\frac{e^{\\alpha\\ln(1+x)} - 1}{\\alpha x} = \\lim_{x\\rightarrow 0}\\frac{\\alpha \\ln(1+x)}{\\alpha x} = \\lim_{x\\rightarrow 0}\\frac{\\alpha x}{\\alpha x} = 1 $ $1 - \\cos x \\sim \\frac{1}{2}x^2$ 点击查看证明过程 $ \\displaystyle\\lim_{x\\rightarrow 0}\\frac{1-\\cos x}{\\frac{1}{2}x^2} = \\lim_{x\\rightarrow 0}\\frac{2\\sin^2\\left(\\frac{x}{2}\\right)}{\\frac{1}{2}x^2} = \\lim_{x\\rightarrow 0}\\frac{2\\left(\\frac{x}{2}\\right)^2}{\\frac{1}{2}x^2} = \\lim_{x\\rightarrow 0}\\frac{\\frac{1}{2}x^2}{\\frac{1}{2}x^2} = 1 $ $ 证明\\;1 - \\cos x = 2\\sin^2 \\left(\\frac{x}{2}\\right)\\\\ \\;\\\\ \\because\\cos(\\alpha + \\beta) = \\cos \\alpha \\cos\\beta - \\sin\\alpha\\sin\\beta\\\\ \\therefore \\cos 2x = \\cos(x+x) = \\cos^2 x - \\sin^2 x\\\\ \\because \\cos^2 x = 1 - \\sin^2 x\\\\ \\therefore \\cos 2x = 1 - 2\\sin^2 x\\\\ \\therefore 1 - \\cos 2x = 2\\sin^2x $ $\\tan x - \\sin x \\sim \\frac{1}{2}x^3$ 点击查看证明过程 $ \\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\tan x - \\sin x}{\\frac{1}{2}x^3} = \\lim_{x\\rightarrow 0}\\frac{\\frac{\\sin x}{\\cos x} - \\sin x}{\\frac{1}{2}x^3} = \\lim_{x\\rightarrow 0}\\frac{\\sin x\\left(\\frac{1-\\cos x}{\\cos x}\\right)}{\\frac{1}{2}x^3} = \\lim_{x\\rightarrow 0}\\frac{1-\\cos x}{\\frac{x^2}{2}\\cos x} = \\lim_{x\\rightarrow 0}\\frac{\\frac{x^2}{2}}{\\frac{x^2}{2}} = 1 $ $x - \\sin x \\sim \\frac{1}{6}x^3$ 点击查看证明过程 $ \\displaystyle\\lim_{x\\rightarrow 0}\\frac{x-\\sin x}{\\frac{1}{6}x^3} = \\lim_{x\\rightarrow 0}\\frac{1-\\cos x}{\\frac{1}{2}x^2} = 1 $ $\\arcsin x - x \\sim \\frac{1}{6}x^3$ 点击查看证明过程 $\n$\n$\\tan x - x \\sim \\frac{1}{3}x^3$ 点击查看证明过程 $ \\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\tan x - x}{\\frac{1}{3}x^3} \\xlongequal{洛必达法则} \\lim_{x\\rightarrow 0}\\frac{\\frac{1}{\\cos^2}-1}{x^2}\\lim_{x\\rightarrow 0}\\frac{1-\\cos^2 x}{x^2\\cos^2 x} \\xlongequal{等价无穷小}\\lim_{x\\rightarrow 0}\\frac{x^2}{x^2} = 1 $ $x - \\arctan x \\sim \\frac{1}{3}x^3$ 点击查看证明过程 $\n$\n$1 - \\cos^{\\alpha} x \\sim \\frac{\\alpha}{2}x^2$ 点击查看证明过程 $ \\displaystyle\\lim_{x\\rightarrow 0} \\frac{1-\\cos^{\\alpha}x}{\\frac{\\alpha}{2}x^2} = -\\lim_{x\\rightarrow 0}\\frac{\\cos^{\\alpha}-1}{\\frac{\\alpha}{2}x^2} = -\\lim_{x\\rightarrow 0}\\frac{\\ln(1+\\cos^{\\alpha}x-1)}{\\frac{\\alpha}{2}x^2} = -\\lim_{x\\rightarrow 0}\\frac{\\alpha\\ln\\cos x}{\\frac{\\alpha}{2}x^2} = -\\lim_{x\\rightarrow 0}\\frac{\\ln[1 + (\\cos x - 1)]}{\\frac{1}{2}x^2} = -\\lim_{x\\rightarrow 0}\\frac{-\\frac{1}{2}x^2}{\\frac{1}{2}x^2} = 1 $ ","permalink":"https://signalyu.github.io/posts/1-natural-science/math/calculus/3-proof-of-common-equivalent-infinitesimals/","summary":"基本等价无穷小 $\\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\sin x}{x} = 1$ 点击查看证明过程 $ 如下图可知：S_{三角形ABC} \u0026lt; S_{扇形ABC} \u0026lt; S_{三角形 ABD}\\\\ 即：\\frac{1}{2}\\sin x \u0026lt; \\frac{1}{2}x\u0026lt;\\frac{1}{2}\\tan x\\\\ 即：\\sin x \u0026lt; x \u0026lt; \\tan x\\\\ 即：1 \u0026lt; \\frac{x}{\\sin x} \u0026lt; \\frac{1}{\\cos x}\\\\ 即：\\cos x \u0026lt; \\frac{\\sin x}{x} \u0026lt; 1\\\\ 因为 \\lim_{x\\rightarrow 0}\\cos x = \\lim_{x\\rightarrow 0} 1 = 1\\\\ 由夹逼准则可知 \\lim_{x\\rightarrow 0}\\frac{\\sin x}{x} = 1 $ 图：$\\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\sin x}{x}$ $\\displaystyle\\lim_{x\\rightarrow 0}(1+x)^{\\frac{1}{x}} = e$ 点击查看证明过程 $ 令\\;L = \\displaystyle\\lim_{x\\rightarrow 0}(1+x)^{\\frac{1}{x}}\\\\ 则\\;\\ln L = \\displaystyle\\lim_{x\\rightarrow 0}\\ln (1+x)^{\\frac{1}{x}}\\\\ 即：\\ln L = \\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\ln (1+x)}{x} \\xlongequal{ 洛必达法则 }\\lim_{x\\rightarrow 0}\\frac{1}{1+x} = 1\\\\ 所以\\;L = e $ 点击查看证明过程 $ $ $\\displaystyle\\lim_{x\\rightarrow \\infty}(1+\\frac{1}{x})^x = e$ 点击查看证明过程 $ 令\\;L = \\displaystyle\\lim_{x\\rightarrow 0}(1+\\frac{1}{x})^x\\\\ 则\\;ln L = \\lim_{x\\rightarrow 0}x\\ln(1+\\frac{1}{x}) = \\lim_{x\\rightarrow 0}\\frac{\\ln(1 + \\frac{1}{x})}{\\frac{1}{x}} \\xlongequal{洛必达法则} \\lim_{x\\rightarrow 0}\\frac{\\frac{-\\frac{1}{x^2}}{1+\\frac{1}{x}}}{-\\frac{1}{x^2}} = \\lim_{x\\rightarrow 0}\\frac{1}{1+\\frac{1}{x}} = 1\\\\ 所以 \\;L = e $ 常用等价无穷小证明 $x \\sim \\tan x$ 点击查看证明过程 $ \\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\tan x}{x} = \\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\sin x}{\\cos x\\cdot x} = \\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\sin x}{x} = 1 $ $\\arcsin x \\sim x$ 点击查看证明过程 $ 令 \\;t = \\arcsin x，则\\;x = \\sin t\\\\ 所以\\;\\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\arcsin x}{x} = \\displaystyle\\lim_{t\\rightarrow 0} = \\frac{t}{\\sin t} = 1 $ $\\arctan x \\sim x$ 点击查看证明过程 $ 令 \\;t = \\arctan x，则\\;x = \\tan t\\\\ 所以\\;\\displaystyle\\lim_{x\\rightarrow 0}\\frac{\\arctan x}{x} = \\displaystyle\\lim_{t\\rightarrow 0} = \\frac{t}{\\tan t} = 1 $ $\\log_a(1+x) \\sim \\frac{x}{\\ln a}$ 点击查看证明过程 $","title":"常用等价无穷小的证明"},{"content":"函数 设 $x$ 和 $y$ 是两个变量，$\\mathcal{D}$ 是一个给定的非空集合数集。如果对于每个数 $x \\in \\mathcal{D}$，变量 $x$ 按照一定的对应法则 $f$ 总有一个确定的数值 $y$ 和它对应，则称 $y$ 是 $x$ 的函数，记为 $$y = f(x), x \\in \\mathcal{D}$$\n其中 $x$ 称为自变量，$y$ 称为因变量，$\\mathcal{D}$ 称为函数的定义域，记作 $\\mathcal{D}_f$，即 $\\mathcal{D}_f = \\mathcal{D}$。函数值 $f(x)$ 的全体所构成的集合称为函数 $f$ 的值域，记作 $\\mathcal{R}_f$ 或 $f(\\mathcal{D})$，即 $$\\mathcal{R}_f = f(\\mathcal{D}) = \\{y|y=f(x), x\\in \\mathcal{D}\\}$$\n函数定义 定义域和对应法则是函数定义的两个基本要素，若两个函数的定义域和对应法则相同，则这两个函数为同一函数。 复合函数 设函数 $y = f(u)$ 的定义域为 $\\mathcal{D}_f$，函数 $u = g(x)$ 的定义域为 $\\mathcal{D}_g$，值域为 $\\mathcal{R}_g$，若 $\\mathcal{D}_f \\cap \\mathcal{R}_g \\ne \\varnothing$，则称函数 $y = f[g(x)]$ 为函数 $y = f(u)$ 与 $u = g(x)$ 的复合函数。它的定义域为 $\\{x | x \\in \\mathcal{D}_g，g(x) \\in \\mathcal{D}_f\\}$。\n函数的定义域必须是非空数集。如果两个函数 $f$，$g$ 能够复合为 $f(g)$，则必须满足 $\\mathcal{D}_{f(g)} \\ne \\varnothing$，即 $\\mathcal{D}_f \\cap \\mathcal{R}_g \\ne \\varnothing$。例如，$f(x) = ln x$ 与 $g(x) = \\sin x - 1$ 不能复合为 $f(g)$，因为 $\\mathcal{D}_f = (0,+\\infty] \\cap \\mathcal{R}_g = [-2, 0] = \\varnothing$。 题目 题目 1 已知 $f(x+1)$ 的定义域为 $[0, a]（a \u0026gt; 0）$，求 $f(x)$ 的定义域。\n点击查看答案 $令\\; g(x) = x + 1，由题意得：\\\\ D_{f\\cdot g} = [0,a]，即：0 \\le x \\le a\\\\ 所以 \\; 1 \\le x+1 \\le a+1\\\\ 如下图所示，f(x)\\;的定义域为\\;[1,a+1]$ $题目一：f(x)$ 定义域 函数的两个基本要素是定义域和映射关系，两者与自变量的符号没有关系。 题目 2 设函数 $f(x) = \\begin{cases}1，\u0026amp;|x| \\le 1\\\\ 0，\u0026amp; |x| \u0026gt; 1\\end{cases}$，则函数 $f[f(x)] = $\n点击查看答案 如下图易得 $f[f(x)] = 1$ 题目二：$f[f(x)] = 1$ 题目 3 设 $g(x) = \\begin{cases}2 - x, \u0026amp; x \\le 0\\\\ x + 2, \u0026amp; x \u0026gt; 0\\end{cases}，f(x) = \\begin{cases}x^2, \u0026amp; x \u0026lt; 0\\\\ -x, \u0026amp; x \\ge 0\\end{cases}$，求 $g[f(x)]$。\n点击查看答案 如下图易得 $g[f(x)] = \\begin{cases}x^2 + 2, \u0026amp; x \u0026lt; 0\\\\ x + 2, \u0026amp; x \\ge 0 \\end{cases}$ $题目三：g[f(x)] = \\begin{cases}x^2 \u0026#43; 2, \u0026amp; x \u0026lt; 0\\\\\\\\ x \u0026#43; 2, \u0026amp; x \\ge 0 \\end{cases}$ 题目 4 下列各题中，函数 $f(x)$ 和 $g(x)$ 是否相同？为什么？\n$f(x) = \\ln x^2，g(x) = 2\\ln x$ 点击查看答案 $ 两个函数相同的条件：定义域和映射关系相同。\\\\ f(x) = \\ln x^2 的定义域为\\; x \\ne 0\\\\ g(x) = 2\\ln x 的定义域为 \\; x\u0026gt;0\\\\ 故\\;f(x) \\;与\\;g(x)\\;不为同一函数 $ $f(x) = \\sqrt[3]{x^4 - x^3}，g(x) = x \\sqrt[3]{x - 1}$ 点击查看答案 $ 两个函数相同的条件：定义域和映射关系相同。\\\\ f(x) \\;与\\; g(x) \\;的定义域均为\\; x\\ge 1\\;且映射关系相同\\\\ 所以\\; f(x) \\;与\\; g(x) \\;为同一函数。 $ 题目 5 设 $f(x)$ 的定义域 $D = [0,1]$，则函数 $f(\\sin x)$ 的定义域为：\n点击查看答案 $$ 已知\\;D_f\\;求D_{f\\cdot g}$$ $ 令\\;g(x) \\; = x^2，根据下图可得：\\\\ R_g = D_f，即\\; 0 \\le \\sin x \\le 1\\\\ 所以\\;D_{f\\cdot g} = D_{g} = [2n\\pi, \\frac{\\pi}{2}+2n\\pi]，n \\in Z $ 图：题目 5 ","permalink":"https://signalyu.github.io/posts/1-natural-science/math/calculus/2-function-definition/","summary":"函数 设 $x$ 和 $y$ 是两个变量，$\\mathcal{D}$ 是一个给定的非空集合数集。如果对于每个数 $x \\in \\mathcal{D}$，变量 $x$ 按照一定的对应法则 $f$ 总有一个确定的数值 $y$ 和它对应，则称 $y$ 是 $x$ 的函数，记为 $$y = f(x), x \\in \\mathcal{D}$$\n其中 $x$ 称为自变量，$y$ 称为因变量，$\\mathcal{D}$ 称为函数的定义域，记作 $\\mathcal{D}_f$，即 $\\mathcal{D}_f = \\mathcal{D}$。函数值 $f(x)$ 的全体所构成的集合称为函数 $f$ 的值域，记作 $\\mathcal{R}_f$ 或 $f(\\mathcal{D})$，即 $$\\mathcal{R}_f = f(\\mathcal{D}) = \\{y|y=f(x), x\\in \\mathcal{D}\\}$$\n函数定义 定义域和对应法则是函数定义的两个基本要素，若两个函数的定义域和对应法则相同，则这两个函数为同一函数。 复合函数 设函数 $y = f(u)$ 的定义域为 $\\mathcal{D}_f$，函数 $u = g(x)$ 的定义域为 $\\mathcal{D}_g$，值域为 $\\mathcal{R}_g$，若 $\\mathcal{D}_f \\cap \\mathcal{R}_g \\ne \\varnothing$，则称函数 $y = f[g(x)]$ 为函数 $y = f(u)$ 与 $u = g(x)$ 的复合函数。它的定义域为 $\\{x | x \\in \\mathcal{D}_g，g(x) \\in \\mathcal{D}_f\\}$。","title":"函数与复合函数"},{"content":"Ɛ-N 定义 数列的极限 如果 $\\forall \\varepsilon \u0026gt; 0$，总存在正数 $N$，当 $n \u0026gt; N$ 时，恒有 $$|x_n - a| \u0026lt; \\varepsilon$$ 成立，则称常数 $a$ 为 数列 $\\{x_n\\}$ 当 $n$ 趋于无穷时的极限，记为 $\\displaystyle \\lim_{n\\rightarrow \\infty} x_n = a$\n$\\varepsilon$ 用于刻画数列的项与常数 $a$ 的接近程度，即 $|x_n - a|$ 的大小。$\\forall \\varepsilon \u0026gt; 0$ 表示数列的项与常数 $a$ “要多近有多近”，即 $|x_n - a|$ 要多小有多小。 $N$ 用于刻画 $n \\rightarrow \\infty$ 这个动态过程。“当 $n \u0026gt; N$ 时，恒有 $|x_n - a| \u0026lt; \\varepsilon$” 表示“在 $N$ 之后的无穷多个项 $x_n$ 与常数 $a$ 的距离小于 $\\varepsilon$ 恒成立。 Ɛ-N 定义的几何意义 数列极限的几何意义 $\\varepsilon-N$ 的几何意义：在极限值点 $a$ 任意作一个 $\\varepsilon$-领域，不论该领域的半径有多么小（$\\forall \\varepsilon \u0026gt; 0$），对数列 $a_n$ 而言，必有一个下标 $N$，使得第 $N$ 项以后的无穷多个项对应的那些点全部落入 $a$ 点的 $\\varepsilon$-邻域内，而不落入 $a$ 点的 $\\varepsilon$-邻域内的点，最多是下标 $N$ 前面的有限项。 根据 $\\varepsilon-N$ 的几何意义，可得出如下两个基本结论： 若 $b \u0026lt; a，\\exists N$，当 $n \u0026gt; N$ 时，$a_n \u0026gt; b$（把 $b$ 当成 $a - \\varepsilon$ 即可） 若 $c \u0026gt; a，\\exists N$，当 $n \u0026gt; N$ 时，$a_n \u0026lt; c$（把 $c$ 当成 $a + \\varepsilon$ 即可） 常用结论及其证明 $若 \\displaystyle\\lim_{n \\rightarrow \\infty} x_n = a，则 \\lim_{n \\rightarrow \\infty} |x_n| = |a|$，但反之不成立。 点击查看证明过程 $\\forall \\varepsilon \u0026gt; 0，\\;\\exists N \u0026gt; 0，当\\; n \u0026gt; N\\;时，|x_n - a| \u0026lt; \\varepsilon，又\\;||x_n - |a|| \\le |x_n - a|，则 \\;\\forall \\varepsilon \u0026gt; 0，\\exists N \u0026gt; 0，当 \\; n \u0026gt; N\\;时，||x_n| - |a|| \u0026lt; \\varepsilon，故 \\;\\displaystyle\\lim_{n \\rightarrow \\infty}|x_n| = a.\\\\ \\;\\\\ 反之不成立。例如\\; x_n = (-1)^n，则\\;\\lim_{n \\rightarrow \\infty} |x_n| = 1 = |1|，但\\;\\lim_{n \\rightarrow \\infty}x_n = \\lim_{n \\rightarrow \\infty}(-1)^n\\;不存在。$ 点击查看 $||a| - |b|| \\le |a - b|$ 证明过程 $\\because |a - b| + |b| \\ge |a|\\\\ \\therefore |a - b| \\ge |a| - |b|\\dots\\textcircled{1}\\\\ \\;\\\\ \\because |b - a| \\ge |b| - |a| = -(|a| - |b|)\\\\ \\therefore -|b - a| \\le |a| - |b|\\\\ \\because |a - b| = |b - a|\\\\ \\therefore -|b - a| = -|a - b | \\le |a| - |b|\\dots\\textcircled{2} \\;\\\\ 联立\\;\\textcircled{1}\\;\\textcircled{2}\\;得：-|a - b | \\le |a| - |b| \\le |a - b|\\\\ 即：||a| - |b|| \\le |a - b|$ 题目 题目一 对任意给定的 $\\varepsilon \\in (0,1)$，总存在正整数 $N$，当 $n \u0026gt; N$ 时，恒有 $|x_n - a| \\le 2\\varepsilon$ 是数列 $\\{x_n\\}$ 收敛于 $a$ 的\nA. 充分条件但非必要条件 B. 必要条件但非充分条件 C. 充分必要条件 D. 既非充分条件又非必要条件 点击查看答案 $充分性：对\\;\\forall \\varepsilon \u0026gt; 0，当 \\;n \\;大于正整数 \\;N\\;时，恒有\\;|x_n - a| \\le 2\\varepsilon，由 \\; \\varepsilon\\; 的任意性可设\\;\\forall\\varepsilon_1\u0026gt;0，取 \\;|x_n - a| \u0026lt; 2\\varepsilon \\;中的 \\;\\varepsilon = \\frac{\\varepsilon_1}{3}，则有\\; |x_n - a| = 2\\varepsilon = \\frac{2\\varepsilon_1}{3}\u0026lt;\\varepsilon_1\\\\ \\;\\\\ 必要性：数列 \\;x_n\\; 收敛于\\; n，则\\; |x_n - a| \u0026lt; \\varepsilon \u0026lt; 2\\varepsilon $ 题目二 设 $\\displaystyle\\lim_{n\\rightarrow \\infty} a_n = a$，且 $a \\ne 0$，则当 $n$ 充分大时有：\nA. $|a_n| \u0026gt; \\frac{|a|}{2}$ B. $|a_n| \u0026lt; \\frac{|a|}{2}$ C. $a_n \u0026gt; a - \\frac{1}{n}$ D. $a_n \u0026lt; a + \\frac{1}{n}$ 点击查看答案 $ 由 \\displaystyle\\lim_{n \\rightarrow \\infty} a_n = a，且 \\; a \\ne 0\\; 知，\\lim_{n \\rightarrow \\infty} |a_n| = |a| \u0026gt; 0，则当\\;n \\;充分大时有\\;|a_n| \u0026gt; \\frac{|a|}{2}。 $ ","permalink":"https://signalyu.github.io/posts/1-natural-science/math/calculus/1-epsilon-n-definition-of-limit/","summary":"Ɛ-N 定义 数列的极限 如果 $\\forall \\varepsilon \u0026gt; 0$，总存在正数 $N$，当 $n \u0026gt; N$ 时，恒有 $$|x_n - a| \u0026lt; \\varepsilon$$ 成立，则称常数 $a$ 为 数列 $\\{x_n\\}$ 当 $n$ 趋于无穷时的极限，记为 $\\displaystyle \\lim_{n\\rightarrow \\infty} x_n = a$\n$\\varepsilon$ 用于刻画数列的项与常数 $a$ 的接近程度，即 $|x_n - a|$ 的大小。$\\forall \\varepsilon \u0026gt; 0$ 表示数列的项与常数 $a$ “要多近有多近”，即 $|x_n - a|$ 要多小有多小。 $N$ 用于刻画 $n \\rightarrow \\infty$ 这个动态过程。“当 $n \u0026gt; N$ 时，恒有 $|x_n - a| \u0026lt; \\varepsilon$” 表示“在 $N$ 之后的无穷多个项 $x_n$ 与常数 $a$ 的距离小于 $\\varepsilon$ 恒成立。 Ɛ-N 定义的几何意义 数列极限的几何意义 $\\varepsilon-N$ 的几何意义：在极限值点 $a$ 任意作一个 $\\varepsilon$-领域，不论该领域的半径有多么小（$\\forall \\varepsilon \u0026gt; 0$），对数列 $a_n$ 而言，必有一个下标 $N$，使得第 $N$ 项以后的无穷多个项对应的那些点全部落入 $a$ 点的 $\\varepsilon$-邻域内，而不落入 $a$ 点的 $\\varepsilon$-邻域内的点，最多是下标 $N$ 前面的有限项。 根据 $\\varepsilon-N$ 的几何意义，可得出如下两个基本结论： 若 $b \u0026lt; a，\\exists N$，当 $n \u0026gt; N$ 时，$a_n \u0026gt; b$（把 $b$ 当成 $a - \\varepsilon$ 即可） 若 $c \u0026gt; a，\\exists N$，当 $n \u0026gt; N$ 时，$a_n \u0026lt; c$（把 $c$ 当成 $a + \\varepsilon$ 即可） 常用结论及其证明 $若 \\displaystyle\\lim_{n \\rightarrow \\infty} x_n = a，则 \\lim_{n \\rightarrow \\infty} |x_n| = |a|$，但反之不成立。 点击查看证明过程 $\\forall \\varepsilon \u0026gt; 0，\\;\\exists N \u0026gt; 0，当\\; n \u0026gt; N\\;时，|x_n - a| \u0026lt; \\varepsilon，又\\;||x_n - |a|| \\le |x_n - a|，则 \\;\\forall \\varepsilon \u0026gt; 0，\\exists N \u0026gt; 0，当 \\; n \u0026gt; N\\;时，||x_n| - |a|| \u0026lt; \\varepsilon，故 \\;\\displaystyle\\lim_{n \\rightarrow \\infty}|x_n| = a.","title":"极限的 Ɛ-N 定义"},{"content":"静态代理 静态代理模式类图 在静态代理模式下，可以在不修改目标对象代码的前提下对其进行功能扩展； 在静态代理模式下，代理对象和目标对象都需要实现父接口或者继承父类； 由于代理对象和目标对象需要实现相同的接口或者继承相同的父类，因此容易导致很多代理类的存在； 当父接口或父类增加方法时，目标对象和代理对象都需要维护。 代码示例 代码示例类图 点击查看代码 BankAccount ConcreteBankAccount StaticBankAccountProxy StaticProxyTest 输出结果 package org.signalyu.patterns.proxy; public interface BankAccount { boolean deposit(double amount); boolean withdraw(double amount); double getBalance(); } package org.signalyu.patterns.proxy; public class ConcreteBankAccount implements BankAccount { private double balance; public ConcreteBankAccount(double balance) { this.balance = balance; } @Override public boolean deposit(double amount) { if (amount \u003e 0) { this.balance += amount; return true; } return false; } @Override public boolean withdraw(double amount) { if (balance \u003e= amount) { balance -= amount; return true; } else { return false; } } @Override public double getBalance() { return balance; } } package org.signalyu.patterns.proxy; import java.time.LocalDateTime; public class StaticBankAccountProxy implements BankAccount { private final ConcreteBankAccount target; public StaticBankAccountProxy(double initialBalance) { this.target = new ConcreteBankAccount(initialBalance); } @Override public boolean withdraw(double amount) { System.out.println(LocalDateTime.now() + \": 取款中...\"); boolean withdraw = target.withdraw(amount); if (withdraw) { System.out.println(LocalDateTime.now() + \": 取款成功！\"); return true; } else { System.out.println(LocalDateTime.now() + \": 取款失败！\"); return false; } } @Override public boolean deposit(double amount) { boolean deposited = target.deposit(amount); System.out.println(LocalDateTime.now() + \": 存款中...\"); if (deposited) { System.out.println(LocalDateTime.now() + \": 存款完毕！\"); return true; } } @Override public double getBalance() { System.out.println(LocalDateTime.now() + \": 正在查询...\"); double balance = target.getBalance(); System.out.println(\"您的账户余额为：\" + target.getBalance()); return balance; } } import org.junit.jupiter.api.Test; import org.signalyu.patterns.proxy.BankAccount; import org.signalyu.patterns.proxy.StaticBankAccountProxy; public class StaticProxyTest { @Test public void testBankAccountProxy() { BankAccount proxy = new StaticBankAccountProxy(0); proxy.deposit(999); System.out.println(\"==================\"); proxy.withdraw(666); System.out.println(\"==================\"); proxy.getBalance(); System.out.println(\"==================\"); proxy.withdraw(400); } } 2024-05-22T13:11:10.480679: 存款中... 2024-05-22T13:11:10.481097: 存款完毕！ ================== 2024-05-22T13:11:10.481258: 取款中... 2024-05-22T13:11:10.481394: 取款成功！ ================== 2024-05-22T13:11:10.481567: 正在查询... 您的账户余额为：333.0 ================== 2024-05-22T13:11:10.486958: 取款中... 2024-05-22T13:11:10.487005: 取款失败！ 动态代理（JDK） 动态代理模式类图 在动态代理模式中，代理对象不需要实现父接口（或继承父接口），但目标对象需要实现接口； 在动态代理模式下，通过 JDK 的 API 动态地在内存中创建代理对象。 代码示例 示例代码类图 点击查看代码 BankAccount ConcreteBankAccount JDkBankAccountProxy Client 输出结果 package org.signalyu.patterns.proxy; public interface BankAccount { boolean deposit(double amount); boolean withdraw(double amount); double getBalance(); } package org.signalyu.patterns.proxy; public class ConcreteBankAccount implements BankAccount { private double balance; public ConcreteBankAccount(double balance) { this.balance = balance; } @Override public boolean deposit(double amount) { if (amount \u003e 0) { this.balance += amount; return true; } return false; } @Override public boolean withdraw(double amount) { if (balance \u003e= amount) { balance -= amount; return true; } else { return false; } } @Override public double getBalance() { return balance; } } package org.signalyu.patterns.proxy; import java.lang.reflect.Proxy; import java.time.LocalDateTime; public class JDKBankAccountProxy { private final Object target; public JDKBankAccountProxy(Object target) { this.target = target; } public Object getProxyInstance() { return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), (proxy, method, args) -\u003e { String methodName = method.getName(); if (\"deposit\".equals(methodName)) { System.out.println(LocalDateTime.now() + \": 存款中...\"); boolean invoked = (boolean) method.invoke(target, args); if (invoked) { System.out.println(LocalDateTime.now() + \": 存款完毕！\"); } return invoked; } else if (\"withdraw\".equals(methodName)) { boolean invoked = (boolean)method.invoke(target, args); if (invoked){ System.out.println(LocalDateTime.now() + \": 取款中...\"); System.out.println(LocalDateTime.now() + \": 取款成功！\"); } else { System.out.println(LocalDateTime.now() + \": 取款失败！\"); } return invoked; } else { System.out.println(LocalDateTime.now() + \": 正在查询余额...\"); Object invoked = method.invoke(target, args); System.out.println(\"您的余额为：\"+ method.invoke(target, args)); return invoked; } }); } } package org.signalyu.patterns.proxy; public class Client { public static void main(String[] args) { ConcreteBankAccount target = new ConcreteBankAccount(0); BankAccount proxyInstance = (BankAccount) new JDKBankAccountProxy(target).getProxyInstance(); proxyInstance.deposit(999); System.out.println(\"==================\"); proxyInstance.withdraw(666); System.out.println(\"==================\"); proxyInstance.getBalance(); System.out.println(\"==================\"); proxyInstance.withdraw(400); } } 2024-05-22T13:02:27.648927: 存款中... 2024-05-22T13:02:27.649245: 存款完毕！ ================== 2024-05-22T13:02:27.649376: 取款中... 2024-05-22T13:02:27.649448: 取款成功！ ================== 2024-05-22T13:02:27.649523: 正在查询余额... 您的余额为：333.0 ================== 2024-05-22T13:02:27.650227: 取款失败！ ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/tech/design-patterns/2-proxy-pattern/","summary":"静态代理 静态代理模式类图 在静态代理模式下，可以在不修改目标对象代码的前提下对其进行功能扩展； 在静态代理模式下，代理对象和目标对象都需要实现父接口或者继承父类； 由于代理对象和目标对象需要实现相同的接口或者继承相同的父类，因此容易导致很多代理类的存在； 当父接口或父类增加方法时，目标对象和代理对象都需要维护。 代码示例 代码示例类图 点击查看代码 BankAccount ConcreteBankAccount StaticBankAccountProxy StaticProxyTest 输出结果 package org.signalyu.patterns.proxy; public interface BankAccount { boolean deposit(double amount); boolean withdraw(double amount); double getBalance(); } package org.signalyu.patterns.proxy; public class ConcreteBankAccount implements BankAccount { private double balance; public ConcreteBankAccount(double balance) { this.balance = balance; } @Override public boolean deposit(double amount) { if (amount \u003e 0) { this.balance += amount; return true; } return false; } @Override public boolean withdraw(double amount) { if (balance \u003e= amount) { balance -= amount; return true; } else { return false; } } @Override public double getBalance() { return balance; } } package org.","title":"设计模式——代理模式"},{"content":"简单工厂（Simple Factory） 简单工厂模式通过一个专门的工厂类基于特定的参数来创建产品类的实例； 简单工厂模式违反了开闭原则，即在需要添加新的产品类型时需要修改工厂类。 代码示例 简单工厂示例类图 点击查看代码 Pizza MargheritaPizza PepperoniPizza BeefPizza PizzaFactory SimpleFactoryTest 输出结果 package org.signalyu.patterns.factory; public interface Pizza { void prepare(); void bake(); void cut(); void box(); } package org.signalyu.patterns.factory; public class MargheritaPizza implements Pizza { @Override public void prepare() { System.out.println(\"玛格丽特比萨：1. 准备材料\"); } @Override public void bake() { System.out.println(\"玛格丽特比萨：2. 烘烤比萨 \"); } @Override public void cut() { System.out.println(\"玛格丽特比萨：3. 切比萨\"); } @Override public void box() { System.out.println(\"玛格丽特比萨：4. 披萨打包\"); } } package org.signalyu.patterns.factory; public class PepperoniPizza implements Pizza { @Override public void prepare() { System.out.println(\"意大利辣式披萨：1. 准备原料\"); } @Override public void bake() { System.out.println(\"意大利辣式披萨：2. 烘烤披萨\"); } @Override public void cut() { System.out.println(\"意大利辣式披萨：3. 切披萨\"); } @Override public void box() { System.out.println(\"意大利辣式披萨：4. 披萨打包\"); } } package org.signalyu.patterns.factory; public class BeefPizza implements Pizza { @Override public void prepare() { System.out.println(\"牛肉披萨：1. 准备原料\"); } @Override public void bake() { System.out.println(\"牛肉披萨：2. 烘烤披萨\"); } @Override public void cut() { System.out.println(\"牛肉披萨：3. 切披萨\"); } @Override public void box() { System.out.println(\"牛肉披萨：4. 披萨打包\"); } } package org.signalyu.patterns.factory; public class PizzaFactory { public Pizza createPizza(String type) { // 当需要生产新品种披萨时，需要修改下面的代码，违背开闭原则 return switch (type) { case \"Margherita\" -\u003e new MargheritaPizza(); case \"Pepperoni\" -\u003e new PepperoniPizza(); case \"Beef\" -\u003e new BeefPizza(); default -\u003e throw new IllegalArgumentException(\"请选择正确的披萨类型: \" + type); }; } } import org.junit.jupiter.api.Test; import org.signalyu.patterns.factory.Pizza; import org.signalyu.patterns.factory.PizzaFactory; public class SimpleFactoryTest { @Test public void testPizzaFactory() { PizzaFactory pizzaFactory = new PizzaFactory(); Pizza margheritaPizza = pizzaFactory.createPizza(\"Margherita\"); margheritaPizza.prepare(); margheritaPizza.bake(); margheritaPizza.cut(); margheritaPizza.box(); System.out.println(\"----------------------\"); Pizza pepperoniPizza = pizzaFactory.createPizza(\"Pepperoni\"); pepperoniPizza.prepare(); pepperoniPizza.bake(); pepperoniPizza.cut(); pepperoniPizza.box(); System.out.println(\"----------------------\"); Pizza veggiePizza = pizzaFactory.createPizza(\"Beef\"); veggiePizza.prepare(); veggiePizza.bake(); veggiePizza.cut(); veggiePizza.box(); } } 玛格丽特比萨：1. 准备材料 玛格丽特比萨：2. 烘烤比萨 玛格丽特比萨：3. 切比萨 玛格丽特比萨：4. 披萨打包 ---------------------- 意大利辣式披萨：1. 准备原料 意大利辣式披萨：2. 烘烤披萨 意大利辣式披萨：3. 切披萨 意大利辣式披萨：4. 披萨打包 ---------------------- 牛肉披萨：1. 准备原料 牛肉披萨：2. 烘烤披萨 牛肉披萨：3. 切披萨 牛肉披萨：4. 披萨打包 工厂方法（Factory Method） 工厂方法模式提供一个抽象工厂接口，具体工厂类实现该接，并为创建对象提供具体实现； 工厂方法模式使用单个工厂方法创建单个产品类型； 工厂方法模式遵循开闭原则。 代码示例 工厂方法示例类图 点击查看代码 Car BruBus Porsche Lamborghini CarFactory BruBusFactory PorscheFactory LamborghiniFactory FactoryMethodTest 输出结果 package org.signalyu.patterns.factory; public interface Car { void assemble(); void paint(); void polish(); void testDrive(); } package org.signalyu.patterns.factory; public class BruBus implements Car { @Override public void assemble() { System.out.println(\"博速：1. 组装\"); } @Override public void paint() { System.out.println(\"博速：2. 刷漆\"); } @Override public void polish() { System.out.println(\"博速：3. 抛光\"); } @Override public void testDrive() { System.out.println(\"博速：4. 驾驶测试\"); } } package org.signalyu.patterns.factory; public class Porsche implements Car { @Override public void assemble() { System.out.println(\"保时捷：1. 组装\"); } @Override public void paint() { System.out.println(\"保时捷：2. 刷漆\"); } @Override public void polish() { System.out.println(\"保时捷：3. 抛光\"); } @Override public void testDrive() { System.out.println(\"保时捷：4. 驾驶测试\"); } } package org.signalyu.patterns.factory; public class Lamborghini implements Car { @Override public void assemble() { System.out.println(\"兰博基尼：1. 组装\"); } @Override public void paint() { System.out.println(\"兰博基尼：2. 刷漆\"); } @Override public void polish() { System.out.println(\"兰博基尼：3. 抛光\"); } @Override public void testDrive() { System.out.println(\"兰博基尼：4. 驾驶测试\"); } } package org.signalyu.patterns.factory; public interface CarFactory { Car createCar(); } package org.signalyu.patterns.factory; public class BruBusFactory implements CarFactory{ @Override public Car createCar() { return new BruBus(); } } package org.signalyu.patterns.factory; public class PorscheFactory implements CarFactory{ @Override public Car createCar() { return new Porsche(); } } package org.signalyu.patterns.factory; public class LamborghiniFactory implements CarFactory{ @Override public Car createCar() { return new Lamborghini(); } } import org.junit.jupiter.api.Test; import org.signalyu.patterns.factory.*; public class FactoryMethodTest { @Test public void testCarFactory() { CarFactory bruBusFactory = new BruBusFactory(); Car bruBus = bruBusFactory.createCar(); bruBus.assemble(); bruBus.paint(); bruBus.polish(); bruBus.testDrive(); System.out.println(\"-------------------\"); CarFactory porscheFactory = new PorscheFactory(); Car porsche = porscheFactory.createCar(); porsche.assemble(); porsche.paint(); porsche.polish(); porsche.testDrive(); System.out.println(\"-------------------\"); CarFactory lamborghiniFactory = new LamborghiniFactory(); Car lamborghini = lamborghiniFactory.createCar(); lamborghini.assemble(); lamborghini.paint(); lamborghini.polish(); lamborghini.testDrive(); } } 博速：1. 组装 博速：2. 刷漆 博速：3. 抛光 博速：4. 驾驶测试 ------------------- 保时捷：1. 组装 保时捷：2. 刷漆 保时捷：3. 抛光 保时捷：4. 驾驶测试 ------------------- 兰博基尼：1. 组装 兰博基尼：2. 刷漆 兰博基尼：3. 抛光 兰博基尼：4. 驾驶测试 抽象工厂（Abstract Factory） 抽象工厂模式提供一个接口，并提供多个工厂方法用于创建相关产品系列； 具体工厂类实现抽象工厂接口，并为创建对象提供具体实现； 抽象工厂模式遵循开闭原则。 代码示例 抽象工厂示例类图 点击查看代码 AbstractChair AbstractSofa ModernChair ModernSofa VictorianChair VictorianSofa FurnitureFactory ModernFurnitureFactory VictorianFurnitureFactory AbstractFactoryTest 输出结果 package org.signalyu.patterns.factory; public abstract class AbstractChair { public abstract void sitOn(); } package org.signalyu.patterns.factory; public abstract class AbstractSofa { public abstract void lieOn(); } package org.signalyu.patterns.factory; public class ModernChair extends AbstractChair { @Override public void sitOn() { System.out.println(\"坐在现代风格椅子...\"); } } package org.signalyu.patterns.factory; public class ModernSofa extends AbstractSofa{ @Override public void lieOn() { System.out.println(\"躺在现代风格沙发...\"); } } package org.signalyu.patterns.factory; public class VictorianChair extends AbstractChair { @Override public void sitOn() { System.out.println(\"坐在维多利亚风格椅子...\"); } } package org.signalyu.patterns.factory; public class VictorianSofa extends AbstractSofa { @Override public void lieOn() { System.out.println(\"躺在维多利亚风格沙发上...\"); } } package org.signalyu.patterns.factory; public interface FurnitureFactory { AbstractChair createChair(); AbstractSofa createSofa(); } package org.signalyu.patterns.factory; public class ModernFurnitureFactory implements FurnitureFactory { @Override public AbstractChair createChair() { return new ModernChair(); } @Override public AbstractSofa createSofa() { return new ModernSofa(); } } package org.signalyu.patterns.factory; public class VictorianFurnitureFactory implements FurnitureFactory { @Override public AbstractChair createChair() { return new VictorianChair(); } @Override public AbstractSofa createSofa() { return new VictorianSofa(); } } import org.junit.jupiter.api.Test; import org.signalyu.patterns.factory.*; public class AbstractFactoryTest { @Test public void testFurnitureFactory() { FurnitureFactory modernFactory = new ModernFurnitureFactory(); AbstractChair modernChair = modernFactory.createChair(); AbstractSofa modernSofa = modernFactory.createSofa(); modernChair.sitOn(); modernSofa.lieOn(); FurnitureFactory victorianFactory = new VictorianFurnitureFactory(); AbstractChair victorianChair = victorianFactory.createChair(); AbstractSofa victorianSofa = victorianFactory.createSofa(); System.out.println(\"----------------------\"); victorianChair.sitOn(); victorianSofa.lieOn(); } } 坐在现代风格椅子... 躺在现代风格沙发... ---------------------- 坐在维多利亚风格椅子... 躺在维多利亚风格沙发上... 总结 简单工厂模式、工厂方法模式和抽象工厂模式的主要区别在于创建对象的方法和抽象程度不同。简单工厂模式为创建对象提供了一个基本的集中式工厂，违背开闭原则；工厂方法模式将创建对象的工作委托给子类，不违背开闭原则；抽象工厂模式则通过一系列工厂方法创建相关对象簇，不违背开闭原则。 ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/tech/design-patterns/1-factory-pattern/","summary":"简单工厂（Simple Factory） 简单工厂模式通过一个专门的工厂类基于特定的参数来创建产品类的实例； 简单工厂模式违反了开闭原则，即在需要添加新的产品类型时需要修改工厂类。 代码示例 简单工厂示例类图 点击查看代码 Pizza MargheritaPizza PepperoniPizza BeefPizza PizzaFactory SimpleFactoryTest 输出结果 package org.signalyu.patterns.factory; public interface Pizza { void prepare(); void bake(); void cut(); void box(); } package org.signalyu.patterns.factory; public class MargheritaPizza implements Pizza { @Override public void prepare() { System.out.println(\"玛格丽特比萨：1. 准备材料\"); } @Override public void bake() { System.out.println(\"玛格丽特比萨：2. 烘烤比萨 \"); } @Override public void cut() { System.out.println(\"玛格丽特比萨：3. 切比萨\"); } @Override public void box() { System.out.println(\"玛格丽特比萨：4. 披萨打包\"); } } package org.","title":"设计模式——工厂模式"},{"content":"Spring MVC 执行流程图 Spring MVC 执行流程图 graph TB subgraph dispatchServlet[前端控制器（DispatchServlet）] direction TB doDispatch ~~~ getHandler ~~~ getHandlerAdapter ~~~ processDispatchResult end subgraph handlerMapping[处理器映射器] end subgraph handlerAdapter[处理器适配器] handle end subgraph handler[处理器（Handler）] 执行业务逻辑 end subgraph viewResolver[视图解析器] resolveViewName end subgraph view[视图（View）] render end user(((用户))) --\u003e|① 请求| dispatchServlet dispatchServlet --\u003e|② 匹配 Handler| handlerMapping handlerMapping --\u003e|③ 返回 HandlerExecutionChain| dispatchServlet dispatchServlet --\u003e|④ 获取 HandlerAdapter| handlerAdapter handlerAdapter --\u003e|⑤ 返回 HandlerAdapter| dispatchServlet dispatchServlet -.- preHandler[⑥ 执行 preHandler] -.-\u003e|⑦ 执行 handle| handlerAdapter handlerAdapter --\u003e|⑧ 执行 handleInternal| handler --\u003e|⑨ 返回 ModelAndView| handlerAdapter handlerAdapter -.-|⑩ 返回 ModelAndView| postHandler[⑪ 执行 postHandler] -.-\u003e dispatchServlet dispatchServlet --\u003e|⑫ 解析视图| viewResolver --\u003e|⑬ 返回 view|dispatchServlet dispatchServlet --\u003e|⑭ 调用 render| view --\u003e|⑮ 渲染视图| dispatchServlet dispatchServlet -.- afterCompletion[⑯ 执行 afterCompletion] --\u003e|⑰ 响应| user DispatcherServlet（前端控制器） 点击查看 DispatcherServlet.class 核心代码 DispatcherServlet.class public class DispatcherServlet extends FrameworkServlet { protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {} protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {} private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv, @Nullable Exception exception) throws Exception {} protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception {} protected View resolveViewName(String viewName, @Nullable Map model, Locale locale, HttpServletRequest request) throws Exception {} } doDispatch 点击查看 doDispatch 方法核心代码 java protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception { /* * 根据请求获取处理器（处理器执行链对象） * 该处理器属于请求级别，一次请求对应一个对象 * 该对象描述了本次请求执行的具体处理器、应该执行的拦截器及其执行顺序 */ HandlerExecutionChain mappedHandler = this.getHandler(processedRequest); /* * 根据处理器获取处理器适配器 * Web 服务器在启动时创建多个 HandlerAdapter 并使用 List 集合保存 * 此时还没有进行数据绑定，即表单提交的数据在此时还没有转换为 pojo 对象 */ HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // 执行请求对应的所有拦截器中的 preHandle 方法 if (!mappedHandler.applyPreHandle(processedRequest, response)) { return; } /* * 通过处理器适配器调用 handle 方法，并返回 ModelAndView 对象 * 在调用 handle 之前会进行数据绑定，将表单提交的数据绑定到处理器方法上 * 在数据绑定的过程中会使用到 HttpMessageConverter 消息转换器 */ mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); // 执行请求对应的所有拦截器中的 postHandle 方法 mappedHandler.applyPostHandle(processedRequest, response, mv); // 处理分发结果 this.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException); } HandlerExecutionChain（处理器执行链对象） HandlerExecutionChain mappedHandler = this.getHandler(processedRequest); 点击查看 HandlerExecutionChain 核心代码 HandlerExecutionChain.class public class HandlerExecutionChain { private final Object handler; private final List interceptorList; private int interceptorIndex; public HandlerExecutionChain(Object handler, List interceptorList) { this.interceptorList = new ArrayList(); this.interceptorIndex = -1; // 检查传入的 handler 是否是 HandlerExecutionChain 的实例 if (handler instanceof HandlerExecutionChain originalChain) { // 如果是，则从原始链中获取处理器并复制其拦截器列表 this.handler = originalChain.getHandler(); this.interceptorList.addAll(originalChain.interceptorList); } else { // 如果不是，则直接使用传入的 handler this.handler = handler; } // 将传入的拦截器列表添加到现有的拦截器列表中 this.interceptorList.addAll(interceptorList); } } Object handler 底层对应的是一个 HandlerMethod 对象，该对象在 Web 服务器启动初始化 Spring IoC 容器时创建，它的两个主要参数为 beanName 和 Method。 HandlerMethod 对象 this.getHandler 代码分析 HandlerExecutionChain mappedHandler = this.getHandler(processedRequest); 点击查看 this.getHandler 方法代码 getHandler @Nullable protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception { if (this.handlerMappings != null) { Iterator var2 = this.handlerMappings.iterator(); /* * 遍历获取符合请求的 HandlerMapping 对象，以此获取正确的 HandlerExecutionChain * 如果处理方法中使用的是 @RequestMapping 注解，则对应的 mapping 为 RequestMappingHandlerMapping */ while(var2.hasNext()) { HandlerMapping mapping = (HandlerMapping)var2.next(); HandlerExecutionChain handler = mapping.getHandler(request); if (handler != null) { return handler; } } } return null; } mapping.getHandler 代码分析 HandlerExecutionChain handler = mapping.getHandler(request); mapping 的变量类型为接口 HandlerMapping（处理器映射器），该接口有很多实现类，常用的是 RequestMappingHandlerMapping，它是 RequestMapping 注解专用的处理器映射器。 所有 HandlerMapping 都是在 Web 服务器启动时创建并存放在 List 集合中。 处理器映射器创建过程 创建 HandlerMapping 时，底层会执行 new HandlerMethod()，具体过程如下图： --- title: 处理器映射器创建过程与 mapping.getHandler --- graph subgraph handlerMapping[HandlerMapping 接口] HM_getHandler[getHandler] end subgraph abstractHandlerMapping[AbstractHandlerMapping 抽象类] AHM_getHandler[getHandler] end subgraph abstractHandlerMethodMapping[AbstractHandlerMethodMapping 抽象类] AHMM_registerHandlerMethod[registerHandlerMethod] --\u003e|② 调用| AHMM_register[register] --\u003e|③ 调用| AHMM_createHandlerMethod[createHandlerMethod] end subgraph requestMappingInfoHandlerMapping[RequestMappingInfoHandlerMapping 抽象类] end subgraph requestMappingHandlerMapping[RequestMappingHandlerMapping 类] RMHM_registerHandlerMethod[registerHandlerMethod] end handlerMapping -.-\u003e|实现| abstractHandlerMapping --\u003e|继承| abstractHandlerMethodMapping --\u003e|继承| requestMappingInfoHandlerMapping --\u003e|继承| requestMappingHandlerMapping RMHM_registerHandlerMethod --\u003e|① 调用| AHMM_registerHandlerMethod AHMM_createHandlerMethod --\u003e|④调用| handlerMethodConstructor[\"new HandlerMethod(...)\"] mapping.getHandler --\u003e|调用| AHM_getHandler 点击查看上图涉及的代码 getHandler registerHandlerMethod register createHandlerMethod // AbstractHandlerMapping 抽象类中的 getHandler 方法 public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception { Object handler = this.getHandlerInternal(request); // ... if (handler instanceof String) { String handlerName = (String)handler; handler = this.obtainApplicationContext().getBean(handlerName); } HandlerExecutionChain executionChain = this.getHandlerExecutionChain(handler, request); // ... return executionChain; } protected HandlerMethod createHandlerMethod(Object handler, Method method) { if (handler instanceof String beanName) { return new HandlerMethod(beanName, this.obtainApplicationContext().getAutowireCapableBeanFactory(), this.obtainApplicationContext(), method); } else { return new HandlerMethod(handler, method); } } public void register(T mapping, Object handler, Method method) { // ... HandlerMethod handlerMethod = AbstractHandlerMethodMapping.this.createHandlerMethod(handler, method); // ... } protected HandlerMethod createHandlerMethod(Object handler, Method method) { if (handler instanceof String beanName) { return new HandlerMethod(beanName, this.obtainApplicationContext().getAutowireCapableBeanFactory(), this.obtainApplicationContext(), method); } else { return new HandlerMethod(handler, method); } } getHandlerAdapter HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); 程序员写的每一个 Controller 都有与之对应的处理器适配器，常用的处理器适配器是 RequestMappingHandlerAdapter。 HandlerAdapter 是一个接口。在 Web 服务器启动阶段，所有该接口的实现类都会被创建并存放在 List 集合中。 点击查看 getHandlerAdapter 代码 getHandlerAdapter protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException { if (this.handlerAdapters != null) { Iterator var2 = this.handlerAdapters.iterator(); while(var2.hasNext()) { HandlerAdapter adapter = (HandlerAdapter)var2.next(); if (adapter.supports(handler)) { // 返回支持处理器的适配器 return adapter; } } } // 未找到支持处理器的适配器，抛出 Servlet 异常 throw new ServletException(\"No adapter for handler [\" + handler + \"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler\"); } applyPreHandle if (!mappedHandler.applyPreHandle(processedRequest, response)) { return; } 点击查看 applyPreHandle 代码 applyPreHandle boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception { // 顺序调用 interceptorList 中的 HandlerInterceptor 对象的 preHandle 方法 for(int i = 0; i \u003c this.interceptorList.size(); this.interceptorIndex = i++) { HandlerInterceptor interceptor = (HandlerInterceptor)this.interceptorList.get(i); if (!interceptor.preHandle(request, response, this.handler)) { this.triggerAfterCompletion(request, response, (Exception)null); return false; } } return true; } ha.handle mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); 在处理器适配器（HandlerAdapter）中执行的任务主要包括：\n将前端提交的 form 数据通过 HttpMessageConverter 转换为 POJO 对象 将数据绑定到 HandlerMethod 对象上 调用 HandlerMethod 并返回 ModelView 点击查看 ha.handle 相关代码 handle 方法 handleInternal 方法 invokeHandlerMethod 方法 @Nullable public final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { return this.handleInternal(request, response, (HandlerMethod)handler); } // RequestMappingHandlerAdapter.class protected ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception { // ... ModelAndView mav = this.invokeHandlerMethod(request, response, handlerMethod); // ... return mav; } // RequestMappingHandlerAdapter.class @Nullable protected ModelAndView invokeHandlerMethod(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception { // 获取一个数据绑定工厂 WebDataBinderFactory binderFactory = this.getDataBinderFactory(handlerMethod); // 获取一个可调用的处理器方法 ServletInvocableHandlerMethod invocableMethod = this.createInvocableHandlerMethod(handlerMethod); // 给可调用的方法绑定数据 invocableMethod.setDataBinderFactory(binderFactory); // 给可调用的方法设置参数 invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer); // 执行可调用方法 invocableMethod.invokeAndHandle(webRequest, mavContainer, new Object[0]); } applyPostHandle mappedHandler.applyPostHandle(processedRequest, response, mv); 点击查看 applyPostHandle 相关代码 applyPostHandle 方法 void applyPostHandle(HttpServletRequest request, HttpServletResponse response, @Nullable ModelAndView mv) throws Exception { // 逆序（--i）取出拦截器对象并执行每个对象的 postHandle 方法 for(int i = this.interceptorList.size() - 1; i \u003e= 0; --i) { HandlerInterceptor interceptor = (HandlerInterceptor)this.interceptorList.get(i); interceptor.postHandle(request, response, this.handler, mv); } } processDispatchResult this.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException); 点击查看 processDispatchResult 相关代码 processDispatchResult 方法 render 方法 resolveViewName 方法 triggerAfterCompletion 方法 private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv, @Nullable Exception exception) throws Exception { // ... this.render(mv, request, response); // ... if (mappedHandler != null) { mappedHandler.triggerAfterCompletion(request, response, (Exception)null); } } protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception { // ... // 通过视图解析器进行解析，返回视图对象 this.resolveViewName(viewName, mv.getModelInternal(), locale, request); // ... // 调用视图的渲染方法，完成响应 view.render(mv.getModelInternal(), request, response); } @Nullable protected View resolveViewName(String viewName, @Nullable Map\u0026lt;String, Object\u003e model, Locale locale, HttpServletRequest request) throws Exception { if (this.viewResolvers != null) { Iterator var5 = this.viewResolvers.iterator(); while(var5.hasNext()) { // 视图解析器 ViewResolver viewResolver = (ViewResolver)var5.next(); // 通过视图解析器返回视图对象 View view = viewResolver.resolveViewName(viewName, locale); if (view != null) { return view; } } } return null; } // HandlerExecutionChain.class void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, @Nullable Exception ex) { // // 逆序调用拦截器对象的 afterCompletion 方法 for(int i = this.interceptorIndex; i \u003e= 0; --i) { HandlerInterceptor interceptor = (HandlerInterceptor)this.interceptorList.get(i); try { interceptor.afterCompletion(request, response, this.handler, ex); } catch (Throwable var7) { logger.error(\"HandlerInterceptor.afterCompletion threw exception\", var7); } } } 面试题 简述 Spring MVC 的工作流程 用户发送请求至前端控制器（DispatcherServlet） DispatcherServlet 收到请求调用处理器映射器（HandlerMapping） 处理器映射器返回处理器执行链（HandlerExecutionChain） 前端控制器调用处理器适配器（HandlerAdapter） 处理器适配器找到具体的处理器（Controller） 处理器执行完业务逻辑后返回 ModelAndView 处理器适配器将 Controller 的执行结果返回给前端控制器 前端控制器将 ModelAndView 传给视图解析器（ViewResolver） 视图解析器解析后返回具体的 View 前端控制器根据 View 进行视图渲染 前端控制器响应用户 ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/tech/spring-mvc/1-spring-mvc-execution-flow/","summary":"Spring MVC 执行流程图 Spring MVC 执行流程图 graph TB subgraph dispatchServlet[前端控制器（DispatchServlet）] direction TB doDispatch ~~~ getHandler ~~~ getHandlerAdapter ~~~ processDispatchResult end subgraph handlerMapping[处理器映射器] end subgraph handlerAdapter[处理器适配器] handle end subgraph handler[处理器（Handler）] 执行业务逻辑 end subgraph viewResolver[视图解析器] resolveViewName end subgraph view[视图（View）] render end user(((用户))) --\u003e|① 请求| dispatchServlet dispatchServlet --\u003e|② 匹配 Handler| handlerMapping handlerMapping --\u003e|③ 返回 HandlerExecutionChain| dispatchServlet dispatchServlet --\u003e|④ 获取 HandlerAdapter| handlerAdapter handlerAdapter --\u003e|⑤ 返回 HandlerAdapter| dispatchServlet dispatchServlet -.- preHandler[⑥ 执行 preHandler] -.-\u003e|⑦ 执行 handle| handlerAdapter handlerAdapter --\u003e|⑧ 执行 handleInternal| handler --\u003e|⑨ 返回 ModelAndView| handlerAdapter handlerAdapter -.","title":"Spring MVC 执行流程"},{"content":"AOP 相关概念 AOP 相关概念 横切关注点（Crosscutting Concern）：横切关注点是指业务处理过程中的附加功能。一类业务可以有多个横切关注点（附加功能），例如上述例子中的的借书方法具有日志和安全校验两个附加功能，即具有两个横切关注点。 切面（Aspect）：在不同类业务中提取的同类核心关注点构成的模块称为切面。例如上述例子中的借书和还书方法可提取出日志切面（LoggingAspect）和校验切面（AuthenticationAspect）。 连接点（Joint Point）：连接点是指业务处理过程中能够应用切面功能的位置。 通知（Advice）：通知是指切面在某个特定连接点上触发的行为。 切入点（Pointcut）：切入点是指业务处理过程中实际应用切面功能的连接点位置。例如核心业务处理前，核心业务成功处理后，核心业务处理发生异常时等等。 织入（Weaving）：织入是指将附加功能集成到目标对象的过程。 AOP 代码 点击查看代码 BookService BookServiceImpl LoggingAspect AuthenticationAspect BookServiceTest beans.xml 输出结果 package org.signalyu; public interface BookService { boolean borrowBook(String bookId); boolean returnBook(String bookId); } package org.signalyu; import org.springframework.stereotype.Service; import java.util.HashMap; import java.util.Map; @Service public class BookServiceImpl implements BookService { final private Map\u0026ltString, Boolean\u003e bookStatus = new HashMap\u0026lt;\u003e(); public BookServiceImpl() { // Initialize book status map with some books available initially bookStatus.put(\"1234567890\", true); bookStatus.put(\"0987654321\", true); bookStatus.put(\"9876543210\", true); } @Override public boolean borrowBook(String bookId) { if (bookStatus.containsKey(bookId)) { if (bookStatus.get(bookId)) { System.out.println(\"Borrowing book: \" + bookId); // Set the book status to false indicating it's borrowed bookStatus.put(bookId, false); return true; } else { System.out.println(\"Book: \" + bookId + \" is already borrowed.\"); return false; } } else { throw new RuntimeException(\"Error: The book with ID \" + bookId + \" is not available in the library.\"); } } @Override public boolean returnBook(String bookId) { if (bookStatus.containsKey(bookId)) { if (!bookStatus.get(bookId)) { System.out.println(\"Returning book: \" + bookId); // Set the book status to true indicating it's returned and available again bookStatus.put(bookId, true); return true; } else { System.out.println(\"Error: The book with ID \" + bookId + \" is not borrowed.\"); return false; } } else { throw new RuntimeException(\"Error: The book with ID \" + bookId + \" is not available in the library.\"); } } } package org.signalyu; import org.aspectj.lang.JoinPoint; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.*; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component; @Aspect @Component @Order(1) public class LoggingAspect { // Pointcut for methods in BookService class @Pointcut(\"execution(* org.signalyu.BookService.*(..))\") public void bookServiceMethods() { } // Advice for logging before method execution @Before(\"bookServiceMethods()\") public void beforeMethodExecution(JoinPoint joinPoint) { System.out.println(\"Logging before \" + joinPoint.getSignature().getName() + \" execution\"); } // Advice for logging after method execution @After(\"bookServiceMethods()\") public void afterMethodExecution(JoinPoint joinPoint) { System.out.println(\"Logging after \" + joinPoint.getSignature().getName() + \" execution\"); } // Advice for logging after method returns a value @AfterReturning(pointcut = \"bookServiceMethods()\", returning = \"result\") public void afterReturningMethod(JoinPoint joinPoint, Object result) { System.out.println(\"Logging after \" + joinPoint.getSignature().getName() + \" returns: \" + result); } // Advice for logging after method throws an exception @AfterThrowing(pointcut = \"bookServiceMethods()\", throwing = \"exception\") public void afterThrowingMethod(JoinPoint joinPoint, Exception exception) { System.out.println(\"Logging after \" + joinPoint.getSignature().getName() + \" throws exception: \" + exception.getMessage()); } // Advice for logging around method execution @Around(\"bookServiceMethods()\") public Object aroundMethodExecution(ProceedingJoinPoint joinPoint) throws Throwable { System.out.println(\"Logging around \"+ joinPoint.getSignature().getName() +\" execution - Before\"); Object result; try { result = joinPoint.proceed(); System.out.println(\"Logging around \"+ joinPoint.getSignature().getName() +\" execution - After\"); } catch (Exception e) { System.out.println(\"Logging around \"+ joinPoint.getSignature().getName() +\" execution - Exception\"); throw e; } return result; } } package org.signalyu; import org.aspectj.lang.JoinPoint; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; import org.aspectj.lang.annotation.Pointcut; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component; @Aspect @Component @Order(2) public class AuthenticationAspect { // Pointcut for methods in BookService class that require authentication @Pointcut(\"execution(* org.signalyu.BookService.borrowBook(..)) || execution(* org.signalyu.BookService.returnBook(..))\") public void authenticatedMethods() { } // Advice for authenticating before method execution @Before(value = \"authenticatedMethods()\") public void authenticate(JoinPoint joinPoint) { System.out.println(\"Authentication before \" + joinPoint.getSignature().getName() + \" execution\"); } } import org.junit.jupiter.api.Test; import org.signalyu.BookService; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class BookServiceTest { @Test public void testBookService() { ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); BookService bookService = context.getBean(BookService.class); String bookId = \"1234567890\"; System.out.println(\"==============Borrowing Book================\"); bookService.borrowBook(bookId); System.out.println(\"=======Borrowing the same book again =======\"); bookService.borrowBook(bookId); System.out.println(\"==============Returning Book================\"); bookService.returnBook(bookId); System.out.println(\"=================== END ====================\"); // bookService.borrowBook(\"999\"); // Wrong book id } } \u0026lt;?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u0026lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e \u0026lt;!-- 进行包扫描--\u003e \u0026lt;context:component-scan base-package=\"org.signalyu\" /\u003e \u0026lt;!-- 开启aspectj框架注解支持--\u003e \u0026lt;aop:aspectj-autoproxy /\u003e \u0026lt;/beans\u003e ==============Borrowing Book================ Logging around borrowBook execution - Before Logging before borrowBook execution Authentication before borrowBook execution Borrowing book: 1234567890 Logging after borrowBook returns: true Logging after borrowBook execution Logging around borrowBook execution - After =======Borrowing the same book again ======= Logging around borrowBook execution - Before Logging before borrowBook execution Authentication before borrowBook execution Book: 1234567890 is already borrowed. Logging after borrowBook returns: false Logging after borrowBook execution Logging around borrowBook execution - After ==============Returning Book================ Logging around returnBook execution - Before Logging before returnBook execution Authentication before returnBook execution Returning book: 1234567890 Logging after returnBook returns: true Logging after returnBook execution Logging around returnBook execution - After =================== END ==================== ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/tech/spring/2-spring-aop/","summary":"AOP 相关概念 AOP 相关概念 横切关注点（Crosscutting Concern）：横切关注点是指业务处理过程中的附加功能。一类业务可以有多个横切关注点（附加功能），例如上述例子中的的借书方法具有日志和安全校验两个附加功能，即具有两个横切关注点。 切面（Aspect）：在不同类业务中提取的同类核心关注点构成的模块称为切面。例如上述例子中的借书和还书方法可提取出日志切面（LoggingAspect）和校验切面（AuthenticationAspect）。 连接点（Joint Point）：连接点是指业务处理过程中能够应用切面功能的位置。 通知（Advice）：通知是指切面在某个特定连接点上触发的行为。 切入点（Pointcut）：切入点是指业务处理过程中实际应用切面功能的连接点位置。例如核心业务处理前，核心业务成功处理后，核心业务处理发生异常时等等。 织入（Weaving）：织入是指将附加功能集成到目标对象的过程。 AOP 代码 点击查看代码 BookService BookServiceImpl LoggingAspect AuthenticationAspect BookServiceTest beans.xml 输出结果 package org.signalyu; public interface BookService { boolean borrowBook(String bookId); boolean returnBook(String bookId); } package org.signalyu; import org.springframework.stereotype.Service; import java.util.HashMap; import java.util.Map; @Service public class BookServiceImpl implements BookService { final private Map\u0026ltString, Boolean\u003e bookStatus = new HashMap\u0026lt;\u003e(); public BookServiceImpl() { // Initialize book status map with some books available initially bookStatus.","title":"Spring：理解 AOP"},{"content":"控制反转 控制反转（IoC）：控制反转是一种设计原则，指的是对象的创建和管理权从应用程序的某个对象反转给 IoC 容器。如下图所示，汽车类（Car）依赖于引擎类（Engine），即 Car 类对其依赖—— Engine 类对象的创建具有控制权。在传统模式下，Car 类必须在其内部创建 Engine 类。而在 IoC 模式下，Engine 类对象的创建和管理由外部实体——IoC 容器完成，也就是说，对 Engine 类对象的创建和管理权限由 Car 类转移到 IoC 容器中。由于在 IoC 模式下 Car 类不需要在其内部创建 Engine 类对象，因此实现了代码解耦。\ngraph LR direction LR subgraph traditional[传统模式] direction LR car[Car] -.- depend((依赖)) -.-\u003e engine[Engine] car --\u003e|创建| engine end graph subgraph iocPattern[IoC 模式] engine[Engine] -.- depend((依赖)) -.-\u003e car[Car] config[XML/注解配置] ==\u003e ioc[IoC 容器] --\u003e|依赖注入| depend ioc --\u003e|创建| car \u0026 engine end 点击查看传统模式代码 Car.java Engine.java package org.signalyu; public class Car { private Engine engine; public Car() { // Car 类在其内部创建 Engine 类 this.engine = new Engine(); } public void start() { engine.start(); } } package org.signalyu; public class Engine { public void start() { System.out.println(\"org.signalyu.Engine started\"); } } 点击 IoC 模式查看代码 Car.java Engine.java Main.java beans.xml package org.signalyu; public class Car { private Engine engine; public Car(Engine engine) { this.engine = engine; } public void start() { engine.start(); } } package org.signalyu; public class Engine { public Engine() { } public void start() { System.out.println(\"org.signalyu.Engine started\"); } } package org.signalyu; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class Main { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); Car car = context.getBean(\"car\",Car.class); car.start(); } } \u0026lt;?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u0026lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u0026lt;!-- Define the Engine bean --\u003e \u0026lt;bean id=\"engine\" class=\"org.signalyu.Engine\"/\u003e \u0026lt;!-- Define the Car bean with constructor injection --\u003e \u0026lt;bean id=\"car\" class=\"org.signalyu.Car\"\u003e \u0026lt;constructor-arg name=\"engine\" ref=\"engine\"/\u003e \u0026lt;/bean\u003e \u0026lt;/beans\u003e 依赖注入 依赖注入：- 依赖指的是对象和对象之间的关联关系，注入指的是一种数据传递行为，通过注入行为来让对象和对象产生关系。综合来看，依赖注入是指 IoC 容器动态地向某个对象提供它所依赖的外部资源。在上述例子中，IoC 容器会在运行时动态地创建 Engine 类并将其注入到 Car 类对象中。\n","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/tech/spring/1-spring-ioc-di/","summary":"控制反转 控制反转（IoC）：控制反转是一种设计原则，指的是对象的创建和管理权从应用程序的某个对象反转给 IoC 容器。如下图所示，汽车类（Car）依赖于引擎类（Engine），即 Car 类对其依赖—— Engine 类对象的创建具有控制权。在传统模式下，Car 类必须在其内部创建 Engine 类。而在 IoC 模式下，Engine 类对象的创建和管理由外部实体——IoC 容器完成，也就是说，对 Engine 类对象的创建和管理权限由 Car 类转移到 IoC 容器中。由于在 IoC 模式下 Car 类不需要在其内部创建 Engine 类对象，因此实现了代码解耦。\ngraph LR direction LR subgraph traditional[传统模式] direction LR car[Car] -.- depend((依赖)) -.-\u003e engine[Engine] car --\u003e|创建| engine end graph subgraph iocPattern[IoC 模式] engine[Engine] -.- depend((依赖)) -.-\u003e car[Car] config[XML/注解配置] ==\u003e ioc[IoC 容器] --\u003e|依赖注入| depend ioc --\u003e|创建| car \u0026 engine end 点击查看传统模式代码 Car.java Engine.java package org.signalyu; public class Car { private Engine engine; public Car() { // Car 类在其内部创建 Engine 类 this.","title":"Spring：理解控制反转和依赖注入"},{"content":"Maven 简介 --- title: Maven 软件的工作原理图 --- flowchart subgraph mavenRepo[Maven 依赖仓库] officialRepo[官方仓库]--\u003e|定期备份|mirrorRepo[镜像仓库] mirrorRepo[镜像仓库]--\u003e|下载|localRepo[本地仓库] end subgraph dependencyManage[依赖管理] dispatch[依赖传递]~~~conflict[依赖冲突]~~~inheritence[依赖继承]~~~cohesion[依赖聚合] end subgraph settings[配置 settings.xml] localRepository~~~mirror~~~jdk end subgraph lifeCircle[生命周期] clean ~~~ compile ~~~ test ~~~ package ~~~ install ~~~ others[...] end subgraph projects[项目] javaSE[JavaSE]~~~javaWeb[JavaWeb] pom.xml -.- javaSE \u0026 javaWeb end subgraph app[包] jar ~~~ war end localRepo --\u003e|引用| maven((Maven)) --- dependencyManage maven -.- settings javaSE \u0026 javaWeb --\u003e install install --\u003e localRepo package --\u003e app IntelliJ --\u003e|新建| javaSE --\u003e|war| javaWeb 依赖管理：Maven 可以管理项目的依赖，包括自动下载所需依赖库、自动下载依赖需要的依赖并且保证版本没有冲突、依赖版本管理等。 构建管理：项目构建是指将源代码、配置文件、资源文件等转化为能够运行或部署的应用程序或库的过程。Maven 可以管理项目的编译、测试、打包、部署等构建过程。通过实现标准的构建生命周期，Maven 可以确保每一个构建过程都遵循同样的的规则和最佳实践。同时，Maven 的插件机制也使得开发者可以对构建过程进行扩展和定制。 Maven 目录结构 点击查看代码 Maven 目录结构 . ├── bin ├── boot ├── conf │ └── logging └── lib ├── ext │ ├── hazelcast │ └── redisson └── jansi-native └── Windows ├── x86 └── x86_64 bin 目录含有 Maven 的运行脚本 boot 目录含有 plexus-classworlds 类加载器框架 conf 目录含有 Maven 的核心配置文件（settings.xml） lib 目录含有 Maven 运行时所需要的 Java 类库 Maven 功能配置 通过修改 conf 目录下的 settings.xml 来修改 Maven 的一些默认配置。通常需要修改一下三项配置：\n依赖本地缓存位置（本地仓库位置） Maven 下载镜像 Maven 选用编译项目的 JDK 版本 修改本地仓库缓存位置 修改本地仓库缓存位置 localRepository \u0026lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: ${user.home}/.m2/repository \u0026lt;localRepository\u003e/path/to/local/repo\u0026lt;/localRepository\u003e --\u003e \u0026lt;localRepository\u003e/Users/signal/maven-repository\u0026lt;/localRepository\u003e 为什么要修改本地仓库缓存位置？ 当 jar 包下载失败时，需要找到本地仓库缓存位置下的 jar 包删除后才能正常继续下载。 配置国内阿里云镜像 配置国内镜像可以提升 jar 包下载速度。\n配置国内镜像 mirror \u0026lt;mirrors\u003e ... \u0026lt;mirror\u003e \u0026lt;id\u003ealimaven\u0026lt;/id\u003e \u0026lt;name\u003ealiyun maven\u0026lt;/name\u003e \u0026lt;url\u003ehttp://maven.aliyun.com/nexus/content/groups/public/\u0026lt;/url\u003e \u0026lt;mirrorOf\u003ecentral\u0026lt;/mirrorOf\u003e \u0026lt;/mirror\u003e ... \u0026lt;/mirrors\u003e 配置完毕后将默认 mirror 注释掉。\n配置 JDK 17 配置 JDK 17 配置 JDK 17 \u0026lt;profiles\u003e ... \u0026lt;profile\u003e \u0026lt;id\u003ejdk-17\u0026lt;/id\u003e \u0026lt;activation\u003e \u0026lt;activeByDefault\u003etrue\u0026lt;/activeByDefault\u003e \u0026lt;jdk\u003e17\u0026lt;/jdk\u003e \u0026lt;/activation\u003e \u0026lt;properties\u003e \u0026lt;maven.compiler.source\u003e17\u0026lt;/maven.compiler.source\u003e \u0026lt;maven.compiler.target\u003e17\u0026lt;/maven.compiler.target\u003e \u0026lt;maven.compiler.compilerVersion\u003e17\u0026lt;/maven.compiler.compilerVersion\u003e \u0026lt;/properties\u003e \u0026lt;/profile\u003e ... \u0026lt;/profiles\u003e Maven 工程 Maven 工程的 GAVP Maven 中的 GAVP 是指 GroupId、ArtifactId、Version、Packaging 等四个属性的缩写，其中前三个为必选项，Packaging 为可选项。\nGroupID 格式：com.{公司/BU}.业务线.[子业务线]，最多四级。例如：com.alibaba.sourcing.multilang ArtifactId 格式：产品线-模块名。例如：tc-client Version 版本号格式推荐：主版本号.次版本号.修订号 主版本号：做了不兼容的 API 修改或者增加了能改变产品方向的新功能。 次版本号：做了向下兼容的功能性新增，例如新增类、接口等。 修订号：修复 bug，保持 API 兼容性等。 Packaging 定义规则：指定项目打包类型。 jar：默认值，代表普通的 Java 工程，打包以后是 .jar 结尾的文件 war：代表 Java 的 web 工程，打包以后是 .war 结尾的文件 pom：表示不打包，用作继承中的父工程（父工程只负责依赖管理和聚合，不参与打包）。 创建 Maven Java SE 工程 ⌘ + , 打开设置面板 -\u0026gt; Build, Execution, Deployment + -\u0026gt; Build Tools -\u0026gt; Maven -\u0026gt; Maven Home Path 处选择本地 Maven -\u0026gt; User Settings 处选择本地 Maven 的 conf 目录下的 settings.xml IDEA 中 Maven 项目设置 File -\u0026gt; new Module IDEA 中创建 Maven Module 创建 Maven Java Web 工程（方式一） 先创建 Maven Java SE 工程，并在 pom.xml 文件中添加 \u0026lt;packaging\u0026gt;war\u0026lt;packaging/\u0026gt; \u0026lt;?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u0026lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u0026lt;modelVersion\u003e4.0.0\u0026lt;/modelVersion\u003e \u0026lt;parent\u003e \u0026lt;groupId\u003eorg.signalyu\u0026lt;/groupId\u003e \u0026lt;artifactId\u003emaven_java\u0026lt;/artifactId\u003e \u0026lt;version\u003e1.0-SNAPSHOT\u0026lt;/version\u003e \u0026lt;/parent\u003e \u0026lt;artifactId\u003emaven_web\u0026lt;/artifactId\u003e \u0026lt;packaging\u003ewar\u0026lt;/packaging\u003e \u0026lt;properties\u003e \u0026lt;maven.compiler.source\u003e17\u0026lt;/maven.compiler.source\u003e \u0026lt;maven.compiler.target\u003e17\u0026lt;/maven.compiler.target\u003e \u0026lt;project.build.sourceEncoding\u003eUTF-8\u0026lt;/project.build.sourceEncoding\u003e \u0026lt;/properties\u003e \u0026lt;/project\u003e 设置 web 资源路径和 web.xml 路径：File -\u0026gt; Project Structure -\u0026gt; 操作如下步骤： 设置 web 资源路径和 web.xml 路径 webapp 有小蓝点表示创建成功（没有小蓝点可点击 Maven 面板中的刷新按钮）。 创建 Maven Java Web 工程（方式二） ⌘ + , 打开设置面板 -\u0026gt; Plugins -\u0026gt; 搜索 JBLJavaToWeb 并安装 创建 Maven Java SE 工程 选中新添加的 Java SE 工程，右击选中 JBLJavaToWeb 即可完成创建。 Maven 工程项目结构 |-- pom.xml # Maven 项目管理文件 |-- src |-- main # 项目主要代码 | |-- java # Java 源代码目录 | | `-- com/example/myapp # 开发者代码主目录 | | |-- controller # 存放 Controller 层代码的目录 | | |-- service # 存放 Service 层代码的目录 | | |-- dao # 存放 DAO 层代码的目录 | | `-- model # 存放数据模型的目录 | |-- resources # 资源目录，存放配置文件、静态资源等 | | |-- log4j.properties # 日志配置文件 | | |-- spring-mybatis.xml # Spring Mybatis 配置文件 | | `-- static # 存放静态资源的目录 | | |-- css # 存放 CSS 文件的目录 | | |-- js # 存放 JavaScript 文件的目录 | | `-- images # 存放图片资源的目录 | `-- webapp # 存放 WEB 相关配置和资源 | |-- WEB-INF # 存放 WEB 应用配置文件 | | |-- web.xml # Web 应用的部署描述文件 | | `-- classes # 存放编译后的 class 文件 | `-- index.html # Web 应用入口页面 `-- test # 项目测试代码 |-- java # 单元测试目录 `-- resources # 测试资源目录 pom.xml：Maven 项目管理文件，用于描述目的依赖和构建配置等信息。 src/main/java：存放项目的 Java 源代码。 src/main/resource：存放项目的资源文件，如配置文件、静态资源等。 src/main/webapp/WEB-INF：存放 Web 应用的配置文件。 src/main/webapp/index.jsp：Web 应用的入口页面。 src/test/java：存放项目的测试代码。 src/test/resources：存放测试相关的资源文件，如测试配置文件等。 基于 IDEA 进行 Maven 工程构建 命令 描述 mvn compile 编译项目，生成 target 文件 mvn package 打包项目，生成 jar 或 war 文件 mvn clean 清理编译或打包后的项目结构 mvn install 打包后上传到 maven 本地仓库 mvn deploy 只打包，上传到 maven 私服仓库 mvn site 生成站点 mvn test 执行测试源码 当构建 Maven Web 工程时，如果 war 包打包插件与 JDK 版本不匹配，则在 pom.xml 文件下添加如下代码即可： \u0026lt;build\u003e \u0026lt;!-- jdk17 和 war包版本插件不匹配 --\u003e \u0026lt;plugins\u003e \u0026lt;plugin\u003e \u0026lt;groupId\u003eorg.apache.maven.plugins\u0026lt;/groupId\u003e \u0026lt;artifactId\u003emaven-war-plugin\u0026lt;/artifactId\u003e \u0026lt;version\u003e3.2.2\u0026lt;/version\u003e \u0026lt;/plugin\u003e \u0026lt;/plugins\u003e \u0026lt;/build\u003e 打包（package）与安装（install）的区别：打包是指将工程打成 jar 或者 war 文件，保存在 target 目录下；安装是指将当前工程所生成的 jar 或者 war 文件，安装到本地仓库，会按照坐标保存到指定位置。 基于 IDEA 进行 Maven 依赖管理 Maven 的依赖管理能够帮助开发人员自动解决软件包依赖问题，使得开发人员能够轻松地将其他开发人员开发的模块或第三方框架集成到自己的应用程序或模块中，避免出现版本冲突和依赖缺失等问题。\n通过定义 POM 文件，Maven 能够自动解析项目的依赖关系，并通过 Maven 仓库自动下载和管理依赖，从而避免了手动下载和管理依赖的繁琐工作和可能引发的版本冲突问题。\n依赖管理 \u0026lt;!-- 通过编写依赖 jar 包的 gav 必要属性，引入第三方依赖！ scope 属性是可选的，可以指定依赖生效范围！ 依赖信息查询方式： 1. maven仓库信息官网 https://mvnrepository.com/ 2. mavensearch插件搜索 --\u003e \u0026lt;dependencies\u003e \u0026lt;!-- 引入具体的依赖包 --\u003e \u0026lt;dependency\u003e \u0026lt;groupId\u003elog4j\u0026lt;/groupId\u003e \u0026lt;artifactId\u003elog4j\u0026lt;/artifactId\u003e \u0026lt;version\u003e1.2.17\u0026lt;/version\u003e \u0026lt;!-- 依赖范围 --\u003e \u0026lt;scope\u003eruntime\u0026lt;/scope\u003e \u0026lt;/dependency\u003e \u0026lt;/dependencies\u003e 依赖版本统一提取和维护 \u0026lt;properties\u003e \u0026lt;!--声明版本--\u003e \u0026lt;junit.version\u003e4.12\u0026lt;/junit.version\u003e \u0026lt;!-- 也可以通过 maven规定的固定的key，配置maven的参数！如下配置编码格式！--\u003e \u0026lt;project.build.sourceEncoding\u003eUTF-8\u0026lt;/project.build.sourceEncoding\u003e \u0026lt;project.reporting.outputEncoding\u003eUTF-8\u0026lt;/project.reporting.outputEncoding\u003e \u0026lt;/properties\u003e \u0026lt;dependencies\u003e \u0026lt;dependency\u003e \u0026lt;groupId\u003ejunit\u0026lt;/groupId\u003e \u0026lt;artifactId\u003ejunit\u0026lt;/artifactId\u003e \u0026lt;!--引用 properties 声明版本 --\u003e \u0026lt;version\u003e${junit.version}\u0026lt;/version\u003e \u0026lt;/dependency\u003e \u0026lt;/dependencies\u003e 依赖范围 通过设置坐标的依赖范围（scope），可以设置对应 jar 包的作用范围：编译环境、测试环境、运行环境\n依赖范围 描述 compile 编译依赖范围，scope 元素的缺省值，在编译、测试、运行过程均会被引入。 test 测试依赖范围，只对测试 classpath 有效。 provided 已提供依赖范围，只对编译和测试有效。 runtime 运行时依赖范围，只对测试和运行有效。 system 系统依赖范围，其效果与 provided 的依赖范围一致。其用于添加非 Maven 仓库的本地依赖，通过依赖元素 dependency 中的 systemPath 元素指定本地依赖的路径。鉴于使用其会导致项目的可移植性降低，一般不推荐使用。 import 导入依赖范围，该依赖范围只能与 dependencyManagement 元素配合使用，其功能是将目标 pom.xml 文件中 dependencyManagement 的配置导入合并到当前 pom.xml 的 dependencyManagement 中。 Maven 工程依赖下载失败错误解决 在使用 Maven 构建项目时，可能会发生依赖下载错误的情况，主要原因有以下几种：\n下载依赖时出现网络故障或仓库服务器宕机等原因，导致无法连接至 Maven 仓库，从而无法下载依赖。 依赖项的版本号或配置文件中的版本号错误，或者依赖项没有正确定义，导致 Maven 下载的依赖项与实际需要的不一致，从而引发错误。 本地 Maven 仓库或缓存被污染或损坏，导致 Maven 无法正确地使用现有的依赖项。 解决方案如下：\n检查网络的连接和 Maven 仓库服务器状态。 确保依赖项的版本号与项目对应的版本号匹配，并检查 POM 文件中的依赖项是否正确。 清楚本地 Maven 仓库缓存 （lastUpdated 文件）。因为当本地仓库缓存中存在 lastUpdated 缓存文件时，刷新 Maven 面板也不会重新下载。 Maven 工程 Build 构建配置 构建配置在 pom.xml 文件中的 build 标签中指定。\n指定打包命名 \u0026lt;!-- 默认的打包名称：artifactid+verson.打包方式 --\u003e \u0026lt;build\u003e \u0026lt;finalName\u003e定义打包名称\u0026lt;/finalName\u003e \u0026lt;/build\u003e 指定打包文件 默认情况下，按照 maven 工程结构放置的文件会默认被编译和打包。当需要指定打包文件时，可以使用 resources 标签来指定要打包资源的文件夹要把哪些静态资源打包到 classes 根目录下。例如，mybatis 中有时需要将用于编写 SQL 语句的映射文件和 mapper 接口都写在 src/main/java 下的某个包中，此时映射文件默认不打包，解决方法如下：\n\u0026lt;build\u003e \u0026lt;!--设置要打包的资源位置--\u003e \u0026lt;resources\u003e \u0026lt;resource\u003e \u0026lt;!--设置资源所在目录--\u003e \u0026lt;directory\u003esrc/main/java\u0026lt;/directory\u003e \u0026lt;includes\u003e \u0026lt;!--设置包含的资源类型--\u003e \u0026lt;include\u003e**/*.xml\u0026lt;/include\u003e \u0026lt;/includes\u003e \u0026lt;/resource\u003e \u0026lt;/resources\u003e \u0026lt;/build\u003e 配置依赖插件 可以通过 build/plugins/plugin 标签引入插件。常用的插件主要包括：修改 JDK 版本、tomcat 插件、mybatis 分页插件、mybatis 逆向工程插件等等。\n\u0026lt;build\u003e \u0026lt;plugins\u003e \u0026lt;!-- java 编译插件，配置 jdk 的编译版本 --\u003e \u0026lt;plugin\u003e \u0026lt;groupId\u003eorg.apache.maven.plugins\u0026lt;/groupId\u003e \u0026lt;artifactId\u003emaven-compiler-plugin\u0026lt;/artifactId\u003e \u0026lt;configuration\u003e \u0026lt;source\u003e1.8\u0026lt;/source\u003e \u0026lt;target\u003e1.8\u0026lt;/target\u003e \u0026lt;encoding\u003eUTF-8\u0026lt;/encoding\u003e \u0026lt;/configuration\u003e \u0026lt;/plugin\u003e \u0026lt;!-- tomcat 插件 --\u003e \u0026lt;plugin\u003e \u0026lt;groupId\u003eorg.apache.tomcat.maven\u0026lt;/groupId\u003e \u0026lt;artifactId\u003etomcat7-maven-plugin\u0026lt;/artifactId\u003e \u0026lt;version\u003e2.2\u0026lt;/version\u003e \u0026lt;configuration\u003e \u0026lt;port\u003e8090\u0026lt;/port\u003e \u0026lt;path\u003e/\u0026lt;/path\u003e \u0026lt;uriEncoding\u003eUTF-8\u0026lt;/uriEncoding\u003e \u0026lt;server\u003etomcat7\u0026lt;/server\u003e \u0026lt;/configuration\u003e \u0026lt;/plugin\u003e \u0026lt;/plugins\u003e \u0026lt;/build\u003e 依赖传递 依赖传递性：假设存在 Maven 项目 A、B、C，且项目 B 依赖项目 A，项目 C 依赖项目 B，则项目 C 依赖 项目 A。 在 C 依赖 B，B 依赖 A 的前提下，A 能否传递到 C，取决于 B 依赖 A 时使用的依赖范围以及配置 B 依赖 A 时使用 compile 范围，可以传递 B 依赖 A 时使用 test 和 provided 范围，不能传递，此时需要专门配置。 B 依赖 A 时，若配置了\u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt;标签，则不能传递。 依赖冲突 当项目中出现重复的 jar 包时，将产生依赖冲突。 Maven 可以根据“短路优先”和“先声明优先”原则自动解决依赖冲突。 短路优先原则： A -\u0026gt; B -\u0026gt; C -\u0026gt; D -\u0026gt; X(version 0.0.1) A -\u0026gt; F -\u0026gt; X(version 0.0.2) 则 A 依赖与 X(version 0.0.2) 先声明优先原则： A—\u0026gt;E—\u0026gt;X(version 0.0.1) A—\u0026gt;F—\u0026gt;X(version 0.0.2) 优先选择先声明的 X 手动解决依赖冲突（不推荐）： \u0026lt;dependency\u003e \u0026lt;groupId\u003ecom.atguigu.maven\u0026lt;/groupId\u003e \u0026lt;artifactId\u003epro01-maven-java\u0026lt;/artifactId\u003e \u0026lt;version\u003e1.0-SNAPSHOT\u0026lt;/version\u003e \u0026lt;scope\u003ecompile\u0026lt;/scope\u003e \u0026lt;!-- 使用excludes标签配置依赖的排除 --\u003e \u0026lt;exclusions\u003e \u0026lt;exclusion\u003e \u0026lt;!-- 指定要排除的依赖的坐标（不需要写version） --\u003e \u0026lt;groupId\u003ecommons-logging\u0026lt;/groupId\u003e \u0026lt;artifactId\u003ecommons-logging\u0026lt;/artifactId\u003e \u0026lt;/exclusion\u003e \u0026lt;/exclusions\u003e \u0026lt;/dependency\u003e 依赖继承 Maven 中的依赖继承是指在父工程中统一管理项目中的依赖信息，以简化项目的管理和维护工作。\n父工程配置 父工程的打包方式必须是 pom。\n\u0026lt;groupId\u003eorg.signalyu.maven\u0026lt;/groupId\u003e \u0026lt;artifactId\u003emaven-parent\u0026lt;/artifactId\u003e \u0026lt;version\u003e1.0-SNAPSHOT\u0026lt;/version\u003e \u0026lt;packaging\u003epom\u0026lt;/packaging\u003e 子工程 子工程中使用 parent 标签指定当前工程的父工程。 如果子工程坐标中的 groupId 和 version 与父工程一致，那么可以省略。 \u0026lt;parent\u003e \u0026lt;!-- 父工程的坐标 --\u003e \u0026lt;groupId\u003eorg.signalyu.maven\u0026lt;/groupId\u003e \u0026lt;artifactId\u003emaven-parent\u0026lt;/artifactId\u003e \u0026lt;version\u003e1.0-SNAPSHOT\u0026lt;/version\u003e \u0026lt;/parent\u003e \u0026lt;!-- 子工程的坐标 --\u003e \u0026lt;artifactId\u003emaven-module1\u0026lt;/artifactId\u003e 父工程依赖统一管理 父工程使用 dependencyManagement 标签对依赖进行管理，被管理的依赖并没有真正被引入到工程。\n\u0026lt;dependencyManagement\u003e \u0026lt;dependencies\u003e \u0026lt;dependency\u003e \u0026lt;groupId\u003eorg.springframework\u0026lt;/groupId\u003e \u0026lt;artifactId\u003espring-core\u0026lt;/artifactId\u003e \u0026lt;version\u003e6.0.10\u0026lt;/version\u003e \u0026lt;/dependency\u003e \u0026lt;dependency\u003e \u0026lt;groupId\u003eorg.springframework\u0026lt;/groupId\u003e \u0026lt;artifactId\u003espring-beans\u0026lt;/artifactId\u003e \u0026lt;version\u003e6.0.10\u0026lt;/version\u003e \u0026lt;/dependency\u003e \u0026lt;dependency\u003e \u0026lt;groupId\u003eorg.springframework\u0026lt;/groupId\u003e \u0026lt;artifactId\u003espring-context\u0026lt;/artifactId\u003e \u0026lt;version\u003e6.0.10\u0026lt;/version\u003e \u0026lt;/dependency\u003e \u0026lt;dependency\u003e \u0026lt;groupId\u003eorg.springframework\u0026lt;/groupId\u003e \u0026lt;artifactId\u003espring-aop\u0026lt;/artifactId\u003e \u0026lt;version\u003e6.0.10\u0026lt;/version\u003e \u0026lt;/dependency\u003e \u0026lt;/dependencies\u003e \u0026lt;/dependencyManagement\u003e 子工程引用父工程中的依赖信息时，若版本号省略，则表示当前依赖版本由父工程的 dependencyManagement 决定。\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-core\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-beans\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-aop\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; Maven 聚合 Maven 聚合是指将多个项目组织到一个父级项目中，以便一起构建和管理的机制。\n\u0026lt;project\u0026gt; \u0026lt;groupId\u0026gt;org.signalyu\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;parent-project\u0026lt;/artifactId\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;child-project1\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;child-project2\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; \u0026lt;/project\u0026gt; 当触发父工程构建命令时、将引发所有子模块构建。\n","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/tech/maven/1-maven-notes/","summary":"Maven 简介 --- title: Maven 软件的工作原理图 --- flowchart subgraph mavenRepo[Maven 依赖仓库] officialRepo[官方仓库]--\u003e|定期备份|mirrorRepo[镜像仓库] mirrorRepo[镜像仓库]--\u003e|下载|localRepo[本地仓库] end subgraph dependencyManage[依赖管理] dispatch[依赖传递]~~~conflict[依赖冲突]~~~inheritence[依赖继承]~~~cohesion[依赖聚合] end subgraph settings[配置 settings.xml] localRepository~~~mirror~~~jdk end subgraph lifeCircle[生命周期] clean ~~~ compile ~~~ test ~~~ package ~~~ install ~~~ others[...] end subgraph projects[项目] javaSE[JavaSE]~~~javaWeb[JavaWeb] pom.xml -.- javaSE \u0026 javaWeb end subgraph app[包] jar ~~~ war end localRepo --\u003e|引用| maven((Maven)) --- dependencyManage maven -.- settings javaSE \u0026 javaWeb --\u003e install install --\u003e localRepo package --\u003e app IntelliJ --\u003e|新建| javaSE --\u003e|war| javaWeb 依赖管理：Maven 可以管理项目的依赖，包括自动下载所需依赖库、自动下载依赖需要的依赖并且保证版本没有冲突、依赖版本管理等。 构建管理：项目构建是指将源代码、配置文件、资源文件等转化为能够运行或部署的应用程序或库的过程。Maven 可以管理项目的编译、测试、打包、部署等构建过程。通过实现标准的构建生命周期，Maven 可以确保每一个构建过程都遵循同样的的规则和最佳实践。同时，Maven 的插件机制也使得开发者可以对构建过程进行扩展和定制。 Maven 目录结构 点击查看代码 Maven 目录结构 .","title":"Maven 笔记"},{"content":" 子类对象拥有父类的私有成员，但子类不继承父类的私有属性。 子类对象包含父类私有属性 首先验证子类对象包含父类的私有属性，代码如下：\n点击查看代码 class Parent { private int privateField; public Parent() { System.out.println(\"this in Parent() =\u003e \" + this); this.privateField = 666; } public Parent(int privateField) { System.out.println(\"this in Parent(int) =\u003e \" + this); this.privateField = privateField; } private void printPrivateField() { System.out.println(this.privateField); } public void accessPrivateMembers() { System.out.println(\"this in accessPrivateMembers() =\u003e \" + this); System.out.print(\"调用 this.printPrivateField() 方法 =\u003e \"); this.printPrivateField(); } } class Child extends Parent { public Child() { System.out.println(\"this in Child() =\u003e \" + this); } } public class Main { public static void main(String[] args) { Child child = new Child(); child.accessPrivateMembers(); } } 上述代码输出结果为：\nthis in Parent() =\u003e Child@372f7a8d this in Child() =\u003e Child@372f7a8d this in accessPrivateMembers() =\u003e Child@372f7a8d 调用 this.printPrivateField() 方法 =\u003e 666 上述代码的输出结果表明，执行 new Child() 后，会调用子类 Child 的无参构造器，而在子类构造器中默认会调用父类的无参构造器。而从输出结果可知，父类无参构造中的 this 指向子类 Child。并且 this.privateField = 666; 也成功执行。同样地，在调用公有（public）方法 accessPrivateMembers() 时，此时的 this 为 Child，并且通过 this 也可以访问父类的私有方法 printPrivateFields()。显然，this 中包含父类的私有属性 privateField 和私有方法 printPrivateField()。事实上，可以通过 org.openjdk.jol 工具中的 ClassLayout 来查看 child 对象在内存中的布局。代码如下：\n点击查看代码 import org.openjdk.jol.info.ClassLayout; class Parent { private int privateField; public Parent() { System.out.println(\"this in Parent() =\u003e \" + this); this.privateField = 666; } public Parent(int privateField) { System.out.println(\"this in Parent(int) =\u003e \" + this); this.privateField = privateField; } private void printPrivateField() { System.out.println(this.privateField); } public void accessPrivateMembers() { System.out.println(\"this in accessPrivateMembers() =\u003e \" + this); System.out.print(\"调用 this.printPrivateField() 方法 =\u003e \"); this.printPrivateField(); } } class Child extends Parent { public Child() { System.out.println(\"this in Child() =\u003e \" + this); } } public static void main(String[] args) { Child child = new Child(); String childLayout = ClassLayout.parseInstance(child).toPrintable(); System.out.println(childLayout); } 上述代码输出结果为：\nChild object internals: OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x000000372f7a8d01 (hash: 0x372f7a8d; age: 0) 8 4 (object header: class) 0x01001418 12 4 int Parent.privateField 666 Instance size: 16 bytes Space losses: 0 bytes internal + 0 bytes external = 0 bytes total 根据上述输出结果可以看出，child 对象中确实包含父类的私有属性。\nJava 语言规范中关于类成员的规定 Java 类成员 Java 语言规范中关于类成的部分陈述如下：\n类的成员包括以下所有成员（The members of a class type are all of the following）：\n从除 Object 类之外的直接父类继承的成员（Members inherited from its direct superclass, except in class Object, which has no direct superclass） 从任何直接父接口继承的成员（Members inherited from any direct superinterfaces） 类中声明的成员（Members declared in the body of the class） 类中声明为私有的成员不会被该类的子类继承。（Members of a class that are declared private are not inherited by subclasses of that class.）\n只有声明为受保护（protected）或公共（public）的类成员才会被本包外的子类继承。（Only members of a class that are declared protected or public are inherited by subclasses declared in a package other than the one in which the class is declared.）\n构造器（constructors）、静态初始化器（static initializers）和实例初始化器（instance initializers）不是类成员，因此不会被继承。（Constructors, static initializers, and instance initializers are not members and therefore are not inherited.）\n超类的私有成员 Oracle 官方 Java 教程中关于超类的私有成员的说明：\n子类不继承父类的私有成员。不过，如果超类有访问其私有字段的公共或保护方法，子类也可以使用这些方法（间接访问父类的私有属性）。（A subclass does not inherit the private members of its parent class. However, if the superclass has public or protected methods for accessing its private fields, these can also be used by the subclass.）\n官方已明确说明子类不继承父类的私有成员，那为什么子类对象可以访问父类的私有成员呢？博主认为，继承是发生在类之间行为，而非对象之间的行为。子类 Child 不继承父类 Parent 的私有成员，并不代表子类对象 child 不可以拥有父类的私有成员。 参考资料 知乎：java中子类有没有继承父类的私有变量？ Java Language Specification : 8.2. Class Members Oracle Java Tutorial: Private Members in a Superclass Do subclasses inherit private fields? ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/tech/java/1-java-private-inheritance/","summary":"子类对象拥有父类的私有成员，但子类不继承父类的私有属性。 子类对象包含父类私有属性 首先验证子类对象包含父类的私有属性，代码如下：\n点击查看代码 class Parent { private int privateField; public Parent() { System.out.println(\"this in Parent() =\u003e \" + this); this.privateField = 666; } public Parent(int privateField) { System.out.println(\"this in Parent(int) =\u003e \" + this); this.privateField = privateField; } private void printPrivateField() { System.out.println(this.privateField); } public void accessPrivateMembers() { System.out.println(\"this in accessPrivateMembers() =\u003e \" + this); System.out.print(\"调用 this.printPrivateField() 方法 =\u003e \"); this.printPrivateField(); } } class Child extends Parent { public Child() { System.","title":"Java 私有成员继承"}]