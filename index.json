[{"content":"1. Solid Principle 1.1 Single Responsibility Principle A class should have only one reason to change, meaning each class should focus on a single functionality or responsibility.\nSHOW CODE Single Responsibility Principle import java.io.IOException; import java.util.*; import java.util.regex.*; import com.fasterxml.jackson.databind.ObjectMapper; /** * 1. User class is only used to represent entity. * 2. UserValidator class is solely responsible for validating user objects. * 3. Store class is only used to manage user objects storage. * 4. UserPersistenceService class is dedicated to save the user data. * 5. UserController is solely used to handle incoming requests (in this case, creating users form JSON input). */ /* \u0026lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.18.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; */ /** * Represents a user with basic details. * User class is only used to represent entity. */ class User { private String name; private String email; private String address; public User() {} public User(String name, String email, String address) { this.name = name; this.email = email; this.address = address; } // Getters and setters public String getName() { return name; } public void setName(String name) { this.name = name; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } @Override public String toString() { return \"User [name=\" + name + \", email=\" + email + \", address=\" + address + \"]\"; } } /** * Handles incoming JSON requests that work on User. * UserController is solely used to handle incoming requests (in this case, creating users form JSON input). */ class UserController { private final UserPersistenceService persistenceService = new UserPersistenceService(); public String createUser(String userJson) throws IOException { ObjectMapper mapper = new ObjectMapper(); User user = mapper.readValue(userJson, User.class); UserValidator validator = new UserValidator(); if (!validator.validateUser(user)) { return \"ERROR\"; } persistenceService.saveUser(user); return \"SUCCESS\"; } } /** * Handles persistence of User objects. * UserPersistenceService class is dedicated to save the user data. */ class UserPersistenceService { private final Store store = new Store(); public void saveUser(User user) { store.store(user); } } /** * Validates User data. * UserValidator class is solely responsible for validating user objects. */ class UserValidator { public boolean validateUser(User user) { if (!isPresent(user.getName()) || !isValidAlphaNumeric(user.getName())) { return false; } user.setName(user.getName().trim()); user.setEmail(user.getEmail().trim()); return isValidEmail(user.getEmail()); } private boolean isPresent(String value) { return value != null \u0026\u0026 value.trim().length() \u003e 0; } private boolean isValidAlphaNumeric(String value) { Pattern pattern = Pattern.compile(\"[^A-Za-z0-9]\"); Matcher matcher = pattern.matcher(value); return !matcher.find(); } private boolean isValidEmail(String value) { Pattern pattern = Pattern.compile(\"^[\\\\w-\\\\.]+@[\\\\w-]+(\\\\.[\\\\w-]+)+$\"); Matcher matcher = pattern.matcher(value); return matcher.find(); } } /** * Stores User data in memory. * Store class is only used to manage user objects storage. */ class Store { private static final Map\u0026lt;String, User\u0026gt; STORAGE = new HashMap\u0026lt;\u0026gt;(); public void store(User user) { synchronized (STORAGE) { STORAGE.put(user.getName(), user); } } public User getUser(String name) { synchronized (STORAGE) { return STORAGE.get(name); } } } /** * Main class for demonstrating the Single Responsibility Principle. */ public class Main { private static final String VALID_USER_JSON = \"{\\\"name\\\": \\\"Signal\\\", \\\"email\\\": \\\"signalyu999@gmail.com\\\", \\\"address\\\":\\\"999 Sugar lane\\\"}\"; private static final String INVALID_USER_JSON = \"{\\\"name\\\": \\\"Sam\\\", \\\"email\\\": \\\"sam@email\\\", \\\"address\\\":\\\"111 Sugar lane\\\"}\"; public static void main(String[] args) throws IOException { UserController controller = new UserController(); String response = controller.createUser(VALID_USER_JSON); System.out.println(\"Valid JSON response: \" + response); response = controller.createUser(INVALID_USER_JSON); System.out.println(\"Invalid JSON response: \" + response); } } Each class in the above code strictly adheres to the Single Responsibility Principle by focusing on a specific responsibility:\nUser for representing the user entity UserController for request handling UserPersistenceService for data persistence UserValidator for user data validation Store for managing in-memory data storage --- title: Single Responsibility Principle - Class Diagram --- classDiagram class User { - String name - String email - String address + String toString() } class Store { + void store(User user) + User getUser(String name) } class UserPersistenceService { + void saveUser(User user) } class UserValidator { - boolean isPresent(String value) - boolean isValidAlphaNumeric(String value) - boolean isValidEmail(String value) + boolean validateUser(User user) } class UserController { + String createUser(String userJson) } class Main { + void main(String[] args) } User --* Store Store --* UserPersistenceService UserPersistenceService --* UserController UserController --\u003e UserValidator : create Main --\u003e UserController : create 1.2 Open-Closed Principle A software entity (class, module, function, etc.) should be open for extension but closed for modification.\n点击查看代码 Java import java.time.LocalDateTime; import java.util.*; // Abstract base class, closed for modification but open for extension abstract class Subscriber { protected Long subscriberId; protected String address; protected Long phoneNumber; protected int baseRate; // Getter and Setter methods public Long getSubscriberId() { return subscriberId; } public void setSubscriberId(Long subscriberId) { this.subscriberId = subscriberId; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } public Long getPhoneNumber() { return phoneNumber; } public void setPhoneNumber(Long phoneNumber) { this.phoneNumber = phoneNumber; } public int getBaseRate() { return baseRate; } public void setBaseRate(int baseRate) { this.baseRate = baseRate; } // Abstract method to calculate the bill; implementation is defined in subclasses public abstract double calculateBill(); } // PhoneSubscriber class extends Subscriber, calculates the phone bill class PhoneSubscriber extends Subscriber { @Override public double calculateBill() { List\u0026lt;CallHistory.Call\u0026gt; calls = CallHistory.getCurrentCalls(subscriberId); long totalDuration = calls.stream().mapToLong(CallHistory.Call::getDuration).sum(); return (totalDuration * baseRate) / 100.0; } } // ISPSubscriber class extends Subscriber, calculates the internet bill class ISPSubscriber extends Subscriber { private long freeUsage; // Free usage limit in data units @Override public double calculateBill() { List\u0026lt;InternetSessionHistory.InternetSession\u0026gt; sessions = InternetSessionHistory.getCurrentSessions(subscriberId); long totalData = sessions.stream().mapToLong(InternetSessionHistory.InternetSession::getDataUsed).sum(); long chargeableData = totalData - freeUsage; return chargeableData \u003c= 0 ? 0 : (chargeableData * baseRate) / 100.0; } public long getFreeUsage() { return freeUsage; } public void setFreeUsage(long freeUsage) { this.freeUsage = freeUsage; } } // InternetSessionHistory class to manage internet usage records class InternetSessionHistory { public static class InternetSession { private final LocalDateTime begin; private final Long subscriberId; private final Long dataUsed; public InternetSession(Long subscriberId, LocalDateTime begin, long dataUsed) { this.subscriberId = subscriberId; this.begin = begin; this.dataUsed = dataUsed; } public LocalDateTime getBegin() { return begin; } public long getDataUsed() { return dataUsed; } public Long getSubscriberId() { return subscriberId; } } private static final Map\u0026lt;Long, List\u0026lt;InternetSession\u0026gt;\u0026gt; SESSIONS = new HashMap\u0026lt;\u0026gt;(); // Retrieves the current sessions for a subscriber, returns an empty list if none found public static synchronized List\u0026lt;InternetSession\u0026gt; getCurrentSessions(Long subscriberId) { return SESSIONS.getOrDefault(subscriberId, Collections.emptyList()); } // Adds a new internet session record for a subscriber public static synchronized void addSession(Long subscriberId, LocalDateTime begin, long dataUsed) { SESSIONS.computeIfAbsent(subscriberId, k -\u003e new LinkedList\u0026lt;\u0026gt;()).add(new InternetSession(subscriberId, begin, dataUsed)); } } // CallHistory class to manage call records class CallHistory { public static class Call { private final LocalDateTime begin; private final long duration; private final Long subscriberId; public Call(Long subscriberId, LocalDateTime begin, long duration) { this.subscriberId = subscriberId; this.begin = begin; this.duration = duration; } public LocalDateTime getBegin() { return begin; } public long getDuration() { return duration; } public Long getSubscriberId() { return subscriberId; } } private static final Map\u0026lt;Long, List\u0026lt;Call\u0026gt; CALLS = new HashMap\u0026lt;\u0026gt;(); // Retrieves the current calls for a subscriber, returns an empty list if none found public static synchronized List\u0026lt;Call\u0026gt; getCurrentCalls(Long subscriberId) { return CALLS.getOrDefault(subscriberId, Collections.emptyList()); } // Adds a new call record for a subscriber public static synchronized void addSession(Long subscriberId, LocalDateTime begin, long duration) { CALLS.computeIfAbsent(subscriberId, k -\u003e new LinkedList\u0026lt;\u0026gt;()).add(new Call(subscriberId, begin, duration)); } } public class Main { public static void main(String[] args) { // Initialize PhoneSubscriber and ISPSubscriber with sample data PhoneSubscriber phoneSubscriber = new PhoneSubscriber(); phoneSubscriber.setSubscriberId(1L); phoneSubscriber.setBaseRate(10); ISPSubscriber ispSubscriber = new ISPSubscriber(); ispSubscriber.setSubscriberId(2L); ispSubscriber.setBaseRate(5); ispSubscriber.setFreeUsage(1000); // Add call records for PhoneSubscriber CallHistory.addSession(1L, LocalDateTime.now().minusMinutes(5), 300); // 300 seconds call CallHistory.addSession(1L, LocalDateTime.now().minusMinutes(10), 600); // 600 seconds call // Calculate and print the phone subscriber's bill double phoneBill = phoneSubscriber.calculateBill(); System.out.println(\"Phone Subscriber's Bill: \" + phoneBill); // Add internet session records for ISPSubscriber InternetSessionHistory.addSession(2L, LocalDateTime.now().minusHours(1), 500); // 500 data units InternetSessionHistory.addSession(2L, LocalDateTime.now().minusHours(2), 800); // 800 data units // Calculate and print the ISP subscriber's bill double ispBill = ispSubscriber.calculateBill(); System.out.println(\"ISP Subscriber's Bill: \" + ispBill); } } The above code demonstrates the Open/Closed Principle (OCP) by separating the base Subscriber class from its specific implementations, PhoneSubscriber and ISPSubscriber, allowing for new functionalities to be added without modifying the existing code structure.\nClosed for Modification: The Subscriber base class is closed for modification. It defines common properties (like subscriberId, address, and baseRate) and an abstract calculateBill method that acts as a placeholder for billing logic. This base class remains unchanged even as new types of subscribers or billing strategies are introduced.\nOpen for Extension: The calculateBill method in Subscriber can be extended by subclasses, like PhoneSubscriber and ISPSubscriber, to implement custom billing calculations. Each subclass overrides calculateBill according to its unique billing requirements (e.g., PhoneSubscriber calculates based on call duration, while ISPSubscriber uses data usage with free data allowances). This enables additional subscriber types to be created without altering the base class or existing subclasses.\nFlexible to New Requirements: By following OCP, any new type of subscriber can be added—such as PremiumSubscriber or CorporateSubscriber—with its own billing logic without affecting the existing structure. This ensures that the core system remains stable, extensible, and easily maintainable as new features or subscriber types are introduced.\n--- title: Open Closed Principle - Class Diagram --- classDiagram class Subscriber { +Long subscriberId +String address +Long phoneNumber +int baseRate +double calculateBill() } class PhoneSubscriber { +double calculateBill() } class ISPSubscriber { +double calculateBill() +long freeUsage +void setFreeUsage(long freeUsage) +long getFreeUsage() } Subscriber \u003c|-- PhoneSubscriber Subscriber \u003c|-- ISPSubscriber 1.3 Liskov Substitution Principle Objects of a superclass should be replaceable with objects of a subclass without altering the correctness of the program.\nSHOW CODE: Violation of LSP Violation of LSP package dev.signalyu.solid.lsp; class Rectangle { private int width; private int height; public Rectangle(int width, int height) { this.width = width; this.height = height; } public int getWidth() { return width; } public void setWidth(int width) { this.width = width; } public int getHeight() { return height; } public void setHeight(int height) { this.height = height; } public int computeArea() { return width * height; } } class Square extends Rectangle { public Square(int side) { super(side, side); } @Override public void setWidth(int width) { setSide(width); } @Override public void setHeight(int height) { setSide(height); } public void setSide(int side) { super.setWidth(side); super.setHeight(side); } } public class Main { public static void main(String[] args) { Rectangle rectangle = new Rectangle(10, 20); System.out.println(rectangle.computeArea()); // 200 = 10 * 20 Square square = new Square(10); System.out.println(square.computeArea()); // 100 = 10 * 10 useRectangle(rectangle); System.out.println(rectangle.computeArea()); // 600 = 20 * 30 useRectangle(square); // Violates Liskov Substitution Principle System.out.println(square.computeArea()); // 900 = 30 * 30 } private static void useRectangle(Rectangle rectangle) { rectangle.setHeight(20); rectangle.setWidth(30); assert rectangle.getHeight() == 20 : \"Height Not equal to 20\"; assert rectangle.getWidth() == 30 : \"Width Not equal to 30\"; } } In the above code, the useRectangle method assumes that it can independently set the width and height of a Rectangle. However, when a Square (a subclass of Rectangle) object is passed to it, unexpected behavior will occur.\nSHOW CODE: After Refactoring After Refactoring package dev.signalyu.solid.lsp; interface Shape { int computeArea(); } class Rectangle implements Shape { private int width; private int height; public Rectangle(int width, int height) { this.width = width; this.height = height; } public int getWidth() { return width; } public void setWidth(int width) { this.width = width; } public int getHeight() { return height; } public void setHeight(int height) { this.height = height; } @Override public int computeArea() { return width * height; } } class Square implements Shape { private int side; public Square(int side) { this.side = side; } public void setSide(int side) { this.side = side; } public int getSide() { return side; } @Override public int computeArea() { return side * side; } } public class Main { public static void main(String[] args) { Rectangle rectangle = new Rectangle(10, 20); System.out.println(rectangle.computeArea()); Square square = new Square(10); System.out.println(square.computeArea()); useRectangle(rectangle); } private static void useRectangle(Rectangle rectangle) { rectangle.setHeight(20); rectangle.setWidth(30); assert rectangle.getHeight() == 20 : \"Height Not equal to 20\"; assert rectangle.getWidth() == 30 : \"Width Not equal to 30\"; } } After refactoring, the useRectangle method is now dedicated exclusively to the Rectangle class.\n1.4 Interface Segregation Principle No client should be forced to depend on methods it does not use.\nSHOW CODE: Violation of ISP Violation of ISP package dev.signalyu.solid.isp; import java.time.LocalDateTime; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.stream.Collectors; // Abstract Entity Class abstract class Entity { private Long id; public Long getId() { return id; } public void setId(Long id) { this.id = id; } } // Order Entity class Order extends Entity { private LocalDateTime orderPlacedOn; private double totalValue; public LocalDateTime getOrderPlacedOn() { return orderPlacedOn; } public void setOrderPlacedOn(LocalDateTime orderPlacedOn) { this.orderPlacedOn = orderPlacedOn; } public double getTotalValue() { return totalValue; } public void setTotalValue(double totalValue) { this.totalValue = totalValue; } } // User Entity class User extends Entity { private String name; private LocalDateTime lastLogin; public String getName() { return name; } public void setName(String name) { this.name = name; } public LocalDateTime getLastLogin() { return lastLogin; } public void setLastLogin(LocalDateTime lastLogin) { this.lastLogin = lastLogin; } } // Persistence Service Interface interface PersistenceService\u0026lt;T extends Entity\u0026gt; { void save(T entity); void delete(T entity); T findById(Long id); /** * ISP VIOLATION!!! * * Order entity doesn't have a name property and hence doesn't * need to implement the findByName method */ List\u0026lt;T\u0026gt; findByName(String name); } // User Persistence Service class UserPersistenceService implements PersistenceService\u0026lt;User\u0026gt; { private static final Map\u0026lt;Long, User\u0026gt; USERS = new HashMap\u0026lt;\u0026gt;(); @Override public void save(User entity) { synchronized (USERS) { USERS.put(entity.getId(), entity); } } @Override public void delete(User entity) { synchronized (USERS) { USERS.remove(entity.getId()); } } @Override public User findById(Long id) { synchronized (USERS) { return USERS.get(id); } } @Override public List findByName(String name) { synchronized (USERS) { return USERS.values().stream() .filter(u -\u003e u.getName().equalsIgnoreCase(name)) .collect(Collectors.toList()); } } } The above code violates the Interface Segregation Principle because the PersistenceService interface defines methods that are not applicable to all entities. For instance, the Order entity does not have a name property and therefore does not require the findByName method.\nSHOW CODE: After Refactoring After Refactoring import java.time.LocalDateTime; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.stream.Collectors; // Abstract Entity Class abstract class Entity { private Long id; public Long getId() { return id; } public void setId(Long id) { this.id = id; } } // User Entity class User extends Entity { private String name; private LocalDateTime lastLogin; public String getName() { return name; } public void setName(String name) { this.name = name; } public LocalDateTime getLastLogin() { return lastLogin; } public void setLastLogin(LocalDateTime lastLogin) { this.lastLogin = lastLogin; } } // Order Entity class Order extends Entity { private LocalDateTime orderPlacedOn; private double totalValue; public LocalDateTime getOrderPlacedOn() { return orderPlacedOn; } public void setOrderPlacedOn(LocalDateTime orderPlacedOn) { this.orderPlacedOn = orderPlacedOn; } public double getTotalValue() { return totalValue; } public void setTotalValue(double totalValue) { this.totalValue = totalValue; } } // Persistence Service Interface interface PersistenceService\u0026lt;T extends Entity\u0026gt; { void save(T entity); void delete(T entity); T findById(Long id); } // Order Persistence Service class OrderPersistenceService implements PersistenceService\u0026lt;Order\u0026gt; { private static final Map\u0026lt;Long, Order\u0026gt; ORDERS = new HashMap\u0026lt;\u0026gt;(); @Override public void save(Order entity) { synchronized (ORDERS) { ORDERS.put(entity.getId(), entity); } } @Override public void delete(Order entity) { synchronized (ORDERS) { ORDERS.remove(entity.getId()); } } @Override public Order findById(Long id) { synchronized (ORDERS) { return ORDERS.get(id); } } } // User Persistence Service class UserPersistenceService implements PersistenceService\u0026lt;User\u0026gt; { private static final Map\u0026lt;Long, User\u0026gt; USERS = new HashMap\u0026lt;\u0026gt;(); @Override public void save(User entity) { synchronized (USERS) { USERS.put(entity.getId(), entity); } } @Override public void delete(User entity) { synchronized (USERS) { USERS.remove(entity.getId()); } } @Override public User findById(Long id) { synchronized (USERS) { return USERS.get(id); } } public List findByName(String name) { synchronized (USERS) { return USERS.values().stream() .filter(u -\u003e u.getName().equalsIgnoreCase(name)) .collect(Collectors.toList()); } } } After refactoring, the PersistenceService interface includes only the generic methods (save, findById, and delete) that are applicable to all entities.\n1.5 Dependency Inversion Principle High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions\nSHOW CODE: Violation of DIP Violation of DIP package dev.signalyu.solid.dip; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.ObjectMapper; import java.io.FileWriter; import java.io.IOException; import java.io.PrintWriter; import java.time.LocalDateTime; import java.time.ZoneId; // Common interface for classes formatting Message object interface Formatter { String format(Message message) throws FormatException; } // Thrown by formatter class FormatException extends IOException { public FormatException(Exception cause) { super(cause); } } // Formats message to JSON format class JSONFormatter implements Formatter { public String format(Message message) throws FormatException { ObjectMapper mapper = new ObjectMapper(); try { return mapper.writeValueAsString(message); } catch (JsonProcessingException e) { e.printStackTrace(); throw new FormatException(e); } } } // Message class with content and timestamp class Message { private String msg; private LocalDateTime timestamp; public Message(String msg) { this.msg = msg; this.timestamp = LocalDateTime.now(ZoneId.of(\"UTC\")); } public String getMsg() { return msg; } public LocalDateTime getTimestamp() { return timestamp; } } // Writes message to a file class MessagePrinter { /** * MessagePrinter directly instantiates the JSONFormatter object inside the * writeMessage method, which violates the Dependency Inversion Principle. */ public void writeMessage(Message msg, String fileName) throws IOException { Formatter formatter = new JSONFormatter(); // creates formatter try (PrintWriter writer = new PrintWriter(new FileWriter(fileName))) { // creates print writer writer.println(formatter.format(msg)); // formats and writes message writer.flush(); } } } // Main class public class Main { public static void main(String[] args) throws IOException { Message msg = new Message(\"This is a message again\"); MessagePrinter printer = new MessagePrinter(); printer.writeMessage(msg, \"test_msg.txt\"); } } In the above code, the MessagePrinter class directly instanitiates the JSONFormatter object inside the writeMessage method, which violates the Dependency Inversion Principle. This tight coupling means that if a new formatter, such as TextFormatter, needs to be added, the writeMessage method must be modified. This violates the Open-Closed Principle, which states that classes should be open for extension but closed for modification. According to the Dependency Inversion Principle, the high-level module (MessagePrinter) should not depend on the low-level module (JSONFormatter). Instead, both should depend on abstractions, such as the Formatter interface.\nSHOW CODE: After Refactoring After Refactoring import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule; import java.io.IOException; import java.io.PrintWriter; import java.time.LocalDateTime; import java.time.ZoneId; // Common interface for classes formatting Message objects interface Formatter { String format(Message message) throws FormatException; } // Custom exception thrown by Formatter class FormatException extends IOException { public FormatException(Exception cause) { super(cause); } } // Formats a Message object to JSON format class JSONFormatter implements Formatter { public String format(Message message) throws FormatException { ObjectMapper mapper = new ObjectMapper(); mapper.registerModule(new JavaTimeModule()); try { return mapper.writeValueAsString(message); } catch (JsonProcessingException e) { e.printStackTrace(); throw new FormatException(e); } } } // Represents a message with content and a timestamp class Message { private String msg; private LocalDateTime timestamp; public Message(String msg) { this.msg = msg; this.timestamp = LocalDateTime.now(ZoneId.of(\"UTC\")); } public String getMsg() { return msg; } public LocalDateTime getTimestamp() { return timestamp; } } // Responsible for writing a formatted Message to a file or output stream class MessagePrinter { public void writeMessage(Message msg, Formatter formatter, PrintWriter writer) throws IOException { writer.println(formatter.format(msg)); // Formats and writes the message writer.flush(); } } // Main class demonstrating functionality public class Main { public static void main(String[] args) throws IOException { Message msg = new Message(\"This is a message again\"); MessagePrinter printer = new MessagePrinter(); try (PrintWriter writer = new PrintWriter(System.out)) { // Writing to console output printer.writeMessage(msg, new JSONFormatter(), writer); } } } After refactoring, the MessagePrinter class now depends on the Formatter abstraction rather than its concrete implementations. This makes it easier to replace JSONFormatter with any other implementation of Formatter without modifying the existing code, adhering to the Open-Closed Principle.\n2. Creational Design Patterns Creational Design Patterns focus on the process of object creation, ensuring flexibility and promoting code reuse.\n2.1 Builder The Builder Design Pattern is a creational design pattern that enables the step-by-step construction of complex objects. It separates the construction process form the object\u0026rsquo;s representation, allowing the same process to produce different representations. This pattern is often used to build complex or immutable obejcts.\n❔❔❔ Same Construction Process Creates Different Representations:\nConsider building a meal in a fast-food restaurant, where the construction steps include:\nAdd a main dish (e.g., burger, sandwich, or pizza). Add a side dish (e.g., fries, salad, or breadsticks). Add a drink (e.g., soda, coffee, or juice). The construction process remains consistent: (main dish + side dish + drink). However, the final representation varies based on the choices:\nVeggie Meal: Sandwich + Salad + Juice. Classic Meal: Burger + Fries + Soda. Kids\u0026rsquo; Meal: Mini Pizza + Fries + Milk. --- title: UML Diagram of Builder Pattern --- classDiagram class Builder { +buildPartA() +buildPartB() +getResult() } class ConcreteBuilder1 { +buildPartA() +buildPartB() +getResult() } class ConcreteBuilder2 { +buildPartA() +buildPartB() +getResult() } class Director { +construct(builder: Builder) } class Product { +PartA +PartB } Builder \u003c|-- ConcreteBuilder1 Builder \u003c|-- ConcreteBuilder2 Director --\u003e Builder : uses ConcreteBuilder1 --\u003e Product : creates ConcreteBuilder2 --\u003e Product : creates ℹ️ In a context of design patterns, UML (Unified Modeling Language) is commonly used to represent the structure and behavior of the patterns in a clear and simple manner.\nSHOW CODE: Director Java import java.time.LocalDate; import java.time.Period; import java.util.Objects; // Address class class Address { private String houseNumber; private String street; private String city; private String zipcode; private String state; public Address(String houseNumber, String street, String city, String state, String zipcode) { this.houseNumber = houseNumber; this.street = street; this.city = city; this.state = state; this.zipcode = zipcode; } public String getFullAddress() { return houseNumber + \", \" + street + \"\\n\" + city + \"\\n\" + state + \" \" + zipcode; } } // User class class User { private String firstName; private String lastName; private LocalDate birthday; private Address address; public User(String firstName, String lastName, LocalDate birthday, Address address) { this.firstName = firstName; this.lastName = lastName; this.birthday = birthday; this.address = address; } public String getFirstName() { return firstName; } public String getLastName() { return lastName; } public LocalDate getBirthday() { return birthday; } public Address getAddress() { return address; } } // UserDTO interface interface UserDTO { String getName(); String getAddress(); String getAge(); } // UserWebDTO implementation class UserWebDTO implements UserDTO { private final String name; private final String address; private final String age; public UserWebDTO(String name, String address, String age) { this.name = name; this.address = address; this.age = age; } @Override public String getName() { return name; } @Override public String getAddress() { return address; } @Override public String getAge() { return age; } @Override public String toString() { return \"Name: \" + name + \"\\nAge: \" + age + \"\\nAddress:\\n\" + address; } } // UserDTOBuilder interface interface UserDTOBuilder { UserDTOBuilder withFirstName(String firstName); UserDTOBuilder withLastName(String lastName); UserDTOBuilder withBirthday(LocalDate birthday); UserDTOBuilder withAddress(Address address); UserDTO build(); } // Concrete builder class UserWebDTOBuilder implements UserDTOBuilder { private String firstName; private String lastName; private String age; private String address; @Override public UserDTOBuilder withFirstName(String firstName) { this.firstName = firstName; return this; } @Override public UserDTOBuilder withLastName(String lastName) { this.lastName = lastName; return this; } @Override public UserDTOBuilder withBirthday(LocalDate birthday) { if (Objects.nonNull(birthday)) { this.age = String.valueOf(Period.between(birthday, LocalDate.now()).getYears()); } return this; } @Override public UserDTOBuilder withAddress(Address address) { if (Objects.nonNull(address)) { this.address = address.getFullAddress(); } return this; } @Override public UserDTO build() { return new UserWebDTO(firstName + \" \" + lastName, address, age); } } // Client code (Director) public class Client { public static void main(String[] args) { User user = createUser(); UserDTOBuilder builder = new UserWebDTOBuilder(); UserDTO userDTO = buildUserDTO(builder, user); System.out.println(userDTO); } private static UserDTO buildUserDTO(UserDTOBuilder builder, User user) { return builder.withFirstName(user.getFirstName()) .withLastName(user.getLastName()) .withBirthday(user.getBirthday()) .withAddress(user.getAddress()) .build(); } private static User createUser() { Address address = new Address(\"100\", \"State Street\", \"Pawnee\", \"Indiana\", \"47998\"); return new User(\"Ron\", \"Swanson\", LocalDate.of(1960, 5, 6), address); } } SHOW CODE: Inner Builder Java import java.time.LocalDate; import java.time.Period; // Address class with Builder class Address { private final String houseNumber; private final String street; private final String city; private final String zipcode; private final String state; private Address(Builder builder) { this.houseNumber = builder.houseNumber; this.street = builder.street; this.city = builder.city; this.zipcode = builder.zipcode; this.state = builder.state; } public String getFullAddress() { return houseNumber + \", \" + street + \"\\n\" + city + \"\\n\" + state + \" \" + zipcode; } public static class Builder { private String houseNumber; private String street; private String city; private String zipcode; private String state; public Builder setHouseNumber(String houseNumber) { this.houseNumber = houseNumber; return this; } public Builder setStreet(String street) { this.street = street; return this; } public Builder setCity(String city) { this.city = city; return this; } public Builder setZipcode(String zipcode) { this.zipcode = zipcode; return this; } public Builder setState(String state) { this.state = state; return this; } public Address build() { return new Address(this); } } } // User class with Builder class User { private final String firstName; private final String lastName; private final LocalDate birthday; private final Address address; private User(Builder builder) { this.firstName = builder.firstName; this.lastName = builder.lastName; this.birthday = builder.birthday; this.address = builder.address; } public String getFirstName() { return firstName; } public String getLastName() { return lastName; } public LocalDate getBirthday() { return birthday; } public Address getAddress() { return address; } public static class Builder { private String firstName; private String lastName; private LocalDate birthday; private Address address; public Builder setFirstName(String firstName) { this.firstName = firstName; return this; } public Builder setLastName(String lastName) { this.lastName = lastName; return this; } public Builder setBirthday(LocalDate birthday) { this.birthday = birthday; return this; } public Builder setAddress(Address address) { this.address = address; return this; } public User build() { return new User(this); } } } // UserDTO interface interface UserDTO { String getName(); String getAddress(); String getAge(); } // UserWebDTO implementation class UserWebDTO implements UserDTO { private final String name; private final String address; private final String age; private UserWebDTO(Builder builder) { this.name = builder.name; this.address = builder.address; this.age = builder.age; } @Override public String getName() { return name; } @Override public String getAddress() { return address; } @Override public String getAge() { return age; } @Override public String toString() { return \"Name: \" + name + \"\\nAge: \" + age + \"\\nAddress:\\n\" + address; } public static class Builder { private String name; private String address; private String age; public Builder setName(String name) { this.name = name; return this; } public Builder setAddress(String address) { this.address = address; return this; } public Builder setAge(String age) { this.age = age; return this; } public UserWebDTO build() { return new UserWebDTO(this); } } } // Client code public class Client { public static void main(String[] args) { Address address = new Address.Builder() .setHouseNumber(\"100\") .setStreet(\"State Street\") .setCity(\"Pawnee\") .setState(\"Indiana\") .setZipcode(\"47998\") .build(); User user = new User.Builder() .setFirstName(\"Ron\") .setLastName(\"Swanson\") .setBirthday(LocalDate.of(1960, 5, 6)) .setAddress(address) .build(); UserWebDTO userDTO = new UserWebDTO.Builder() .setName(user.getFirstName() + \" \" + user.getLastName()) .setAddress(user.getAddress().getFullAddress()) .setAge(String.valueOf(Period.between(user.getBirthday(), LocalDate.now()).getYears())) .build(); System.out.println(userDTO); } } Summary Why builder pattern is capable of creating immutable objects?\nImplementing the builder as a static inner class facilitates the creation of immutable objects. The builder class has provileged access to the enclosing class\u0026rsquo;s internal state during the construction process. However, once the final object is built, it does not expose any setters or methods that modify its state, ensuring immutability.\nThe Director in the Builder Design Pattern is responsible for the construction process but is often not implemented as a standalone class. Instead, its responsibilities are typically handled by the client code or the consumer that requires the constructed object. This approach avoids the need for a separate director class, especially when the construction logic is simple or tailored to the client\u0026rsquo;s specific requirements.\nSHOW CODE: Without a Director Java UserDTO userDTO = new UserWebDTOBuilder() .withFirstName(\"John\") .withLastName(\"Doe\") .withBirthday(LocalDate.of(1990, 1, 1)) .withAddress(new Address(\"123\", \"Main St\", \"City\", \"State\", \"12345\")) .build(); SHOW CODE: With a Director Java public class Director { public UserDTO constructUser(UserDTOBuilder builder) { return builder.withFirstName(\"John\") .withLastName(\"Doe\") .withBirthday(LocalDate.of(1990, 1, 1)) .withAddress(new Address(\"123\", \"Main St\", \"City\", \"State\", \"12345\")) .build(); } } If a Product in the Builder Design Pattern is not part of an inheritance hierarchy, creating an abstract builder is unnecessary. The abstract builder is typically used to define method for mutiple types of builders. When there is only one type of product to construct, a concrete builder alone is sufficient to meet the requirements.\n2.2 Simple Factory The Simple Factory design pattern is a creational design pattern that delegates the responsibility of creating instances of different classes to a factory class, typically using a static method based on input parameters. This pattern centralizes object creation, simplifying the client code. However, it can violate the Open-Closed Principle (OCP), because adding a new product type requires modifying the factory class itself. This makes the code less flexible and harder to extend without altering existing source code.\nSHOW CODE Java import java.time.LocalDateTime; import java.time.LocalDate; // Abstract Post class public abstract class Post { private Long id; private String title; private String content; private LocalDateTime createdOn; private LocalDateTime publishedOn; public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } public LocalDateTime getCreatedOn() { return createdOn; } public void setCreatedOn(LocalDateTime createdOn) { this.createdOn = createdOn; } public LocalDateTime getPublishedOn() { return publishedOn; } public void setPublishedOn(LocalDateTime publishedOn) { this.publishedOn = publishedOn; } } // BlogPost class extends Post public class BlogPost extends Post { private String author; private String[] tags; public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } public String[] getTags() { return tags; } public void setTags(String[] tags) { this.tags = tags; } } // NewsPost class extends Post public class NewsPost extends Post { private String headline; private LocalDate newsTime; public String getHeadline() { return headline; } public void setHeadline(String headline) { this.headline = headline; } public LocalDate getNewsTime() { return newsTime; } public void setNewsTime(LocalDate newsTime) { this.newsTime = newsTime; } } // ProductPost class extends Post public class ProductPost extends Post { private String imageUrl; private String name; public String getImageUrl() { return imageUrl; } public void setImageUrl(String imageUrl) { this.imageUrl = imageUrl; } public String getName() { return name; } public void setName(String name) { this.name = name; } } // PostFactory class to create different types of posts public class PostFactory { public static Post createPost(String type) { switch (type) { case \"blog\": return new BlogPost(); case \"news\": return new NewsPost(); case \"product\": return new ProductPost(); default: throw new IllegalArgumentException(\"Post type is unknown\"); } } } // Client class to demonstrate the usage of Simple Factory public class Client { public static void main(String[] args) { Post post = PostFactory.createPost(\"news\"); System.out.println(post.getClass().getSimpleName()); // Prints the type of the created post (NewsPost) } } classDiagram direction RL class Post { - Long id - String title - String content - LocalDateTime createdOn - LocalDateTime publishedOn + getId() + setId(Long) + getTitle() + setTitle(String) + getContent() + setContent(String) + getCreatedOn() + setCreatedOn(LocalDateTime) + getPublishedOn() + setPublishedOn(LocalDateTime) } class BlogPost { - String author - String[] tags + getAuthor() + setAuthor(String) + getTags() + setTags(String[]) } class NewsPost { - String headline - LocalDate newsTime + getHeadline() + setHeadline(String) + getNewsTime() + setNewsTime(LocalDate) } class ProductPost { - String imageUrl - String name + getImageUrl() + setImageUrl(String) + getName() + setName(String) } class PostFactory { + createPost(String) } Post \u003c|-- BlogPost Post \u003c|-- NewsPost Post \u003c|-- ProductPost PostFactory --|\u003e BlogPost : creates PostFactory --|\u003e NewsPost : creates PostFactory --|\u003e ProductPost : creates The above code violates the Open-Closed Principle because when adding a new post type, such as EventPost, to the factory, the code must be modified by adding a new case statement, like the following:\ncase \u0026#34;event\u0026#34;: return new EventPost(); This approach breaks the OCP, which dictates that entities should be open for extension but closed for modification.\n2.3 Factory Method The Factory Method design pattern is a creational pattern that provides a method for creating objects in a superclass, while allowing subclasses to determine the type of object that will be created. This approach delegates the object creation process to the subclasses, enabling them to instantiate specific classes without the superclass needing to know the exact class being instantiated.\nSHOW CODE Java import java.util.*; /** * Abstract class representing a message, which is the \"product\". * Subclasses will provide specific content types. */ abstract class Message { public abstract String getContent(); public void addDefaultHeaders() { // Adds some default headers } public void encrypt() { // Has some code to encrypt the content } } /** * Concrete implementation of the Message class for Text messages. */ class TextMessage extends Message { @Override public String getContent() { return \"Text\"; } } /** * Concrete implementation of the Message class for JSON messages. */ class JSONMessage extends Message { @Override public String getContent() { return \"{\\\"JSON\\\":[]}\"; } } /** * Abstract creator class. The factory method createMessage() must be implemented * by subclasses to instantiate the specific message type. */ abstract class MessageCreator { public Message getMessage() { Message msg = createMessage(); msg.addDefaultHeaders(); msg.encrypt(); return msg; } // Factory method to create a message protected abstract Message createMessage(); } /** * Concrete creator for creating JSON messages. */ class JSONMessageCreator extends MessageCreator { @Override public Message createMessage() { return new JSONMessage(); } } /** * Concrete creator for creating Text messages. */ class TextMessageCreator extends MessageCreator { @Override public Message createMessage() { return new TextMessage(); } } /** * Client class demonstrating the use of the Factory Method pattern. */ public class Client { public static void main(String[] args) { printMessage(new JSONMessageCreator()); printMessage(new TextMessageCreator()); } public static void printMessage(MessageCreator creator) { Message msg = creator.getMessage(); System.out.println(msg.getContent()); } } --- title: UML Diagram of Factory Method Pattern --- classDiagram Message \u003c|-- TextMessage Message \u003c|-- JSONMessage MessageCreator \u003c|-- JSONMessageCreator MessageCreator \u003c|-- TextMessageCreator JSONMessageCreator \"1\" --\u003e \"1\" JSONMessage : creates TextMessageCreator \"1\" --\u003e \"1\" TextMessage : creates MessageCreator : +getMessage() MessageCreator : +createMessage() JSONMessageCreator : +createMessage() TextMessageCreator : +createMessage() Message : +getContent() Message : +addDefaultHeaders() Message : +encrypt() 2.4 Prototype The Prototype design pattern is a creational pattern that enables the creation of new objects by copying an existing object, known as the prototype. It is particularly useful when object creation is resource-intensive or when there is a need to dynamically create mana similar objects.\nSHOW CODE Java // Point3D class representing a 3D point class Point3D { private float x, y, z; public static final Point3D ZERO = new Point3D(0, 0, 0); public Point3D(float x, float y, float z) { this.x = x; this.y = y; this.z = z; } public Point3D normalize() { float mag = magnitude(); return new Point3D(x / mag, y / mag, z / mag); } private float magnitude() { return (float) Math.sqrt(x * x + y * y + z * z); } public Point3D multiply(float scale) { return new Point3D(x * scale, y * scale, z * scale); } public Point3D add(Point3D vector) { return new Point3D(x + vector.x, y + vector.y, z + vector.z); } @Override public String toString() { return \"(\" + x + \", \" + y + \", \" + z + \")\"; } } // Abstract GameUnit class defining the clone method abstract class GameUnit implements Cloneable { private Point3D position; public GameUnit() { position = Point3D.ZERO; } @Override public GameUnit clone() throws CloneNotSupportedException { GameUnit unit = (GameUnit) super.clone(); unit.initialize(); return unit; } protected void initialize() { this.position = Point3D.ZERO; reset(); } protected abstract void reset(); public GameUnit(float x, float y, float z) { position = new Point3D(x, y, z); } public void move(Point3D direction, float distance) { Point3D finalMove = direction.normalize(); finalMove = finalMove.multiply(distance); position = position.add(finalMove); } public Point3D getPosition() { return position; } } // Swordsman class extends GameUnit and implements specific behavior class Swordsman extends GameUnit { private String state = \"idle\"; public void attack() { this.state = \"attacking\"; } @Override public String toString() { return \"Swordsman \" + state + \" @ \" + getPosition(); } @Override protected void reset() { state = \"idle\"; } } // General class extends GameUnit but does not support cloning class General extends GameUnit { private String state = \"idle\"; public void boostMorale() { this.state = \"MoralBoost\"; } @Override public String toString() { return \"General \" + state + \" @ \" + getPosition(); } @Override public GameUnit clone() throws CloneNotSupportedException { throw new CloneNotSupportedException(\"Generals are unique\"); } @Override protected void reset() { throw new UnsupportedOperationException(\"Reset not supported\"); } } public class Main { // Client code to demonstrate the Prototype Pattern public static void main(String[] args) throws CloneNotSupportedException { // Creating and moving a Swordsman Swordsman s1 = new Swordsman(); s1.move(new Point3D(-10, 0, 0), 20); s1.attack(); System.out.println(s1); // Cloning the Swordsman Swordsman s2 = (Swordsman) s1.clone(); System.out.println(\"Cloned swordsman: \" + s2); } } Shallow Copy vs. Deep Copy: A shallow copy creates a new object but only copies the references of the original object\u0026rsquo;s fields. As a result, both the original and the copied object share references to the same inner objects. Any changes made to the inner mutable objects of the copied object will affect the original object as well. In Java, the clone method performs a shallow copy. On the other hand, a deep copy involves recursively copying the original object and all the objects it references. As a result, the copied object is entirely independent of the original, and changes made to the copied object do not affect the original one.\nSHOW CODE: Shallow Copy Java import java.util.ArrayList; import java.util.List; /** * @author Signal Yu * @since 2024-12-2 */ class Person { String name; int age; public Person(String name, int age) { this.name = name; this.age = age; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"Person{name='\" + name + \"', age=\" + age + '}'; } } public class Solution { public static void main(String[] args) { // Original list with mutable objects (Person) List\u0026lt;Person\u0026gt; originalList = new ArrayList\u0026lt;\u0026gt;(); originalList.add(new Person(\"Alice\", 30)); originalList.add(new Person(\"Bob\", 25)); // Shallow copy of the list List\u0026lt;Person\u0026gt; shallowCopyList = new ArrayList\u0026lt;\u0026gt;(originalList); // Modify the object in the shallow copy shallowCopyList.get(1).setName(\"Signal\"); // Print both lists System.out.println(\"Original List: \" + originalList); System.out.println(\"Shallow Copy List: \" + shallowCopyList); } } SHOW OUTPUT: Shallow Copy Output Original List: [Person{name='Alice', age=30}, Person{name='Signal', age=25}] Shallow Copy List: [Person{name='Alice', age=30}, Person{name='Signal', age=25}] SHOW CODE: Deep Copy Java import java.util.ArrayList; import java.util.List; class Person { String name; int age; public Person(String name, int age) { this.name = name; this.age = age; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"Person{name='\" + name + \"', age=\" + age + '}'; } // Deep copy method for Person class public Person deepCopy() { return new Person(this.name, this.age); } } public class Solution { public static void main(String[] args) { // Original list with mutable objects (Person) List\u0026lt;Person\u0026gt; originalList = new ArrayList\u0026lt;\u0026gt;(); originalList.add(new Person(\"Alice\", 30)); originalList.add(new Person(\"Bob\", 25)); // Deep copy of the list (creating new Person objects) List\u0026lt;Person\u0026gt; deepCopyList = new ArrayList\u0026lt;\u0026gt;(); for (Person person : originalList) { deepCopyList.add(person.deepCopy()); // Add a deep copy of each person } // Modify the object in the deep copy deepCopyList.get(1).setName(\"Signal\"); // Print both lists System.out.println(\"Original List: \" + originalList); System.out.println(\"Deep Copy List: \" + deepCopyList); } } SHOW OUTPUT: Deep Copy Output Original List: [Person{name='Alice', age=30}, Person{name='Bob', age=25}] Deep Copy List: [Person{name='Alice', age=30}, Person{name='Signal', age=25}] It is important to note that changes made to immutable objects in a shallow copied object will not affect the original object. For example, when performing a shallow copy of an ArrayList that contains Integer values, changes made to the Integer of the copied object will not affect the original object because Integer is immutable (since it is marked as final and its value cannot be changed).\nSHOW CODE Java import java.util.ArrayList; import java.util.List; /** * @author Signal Yu * @since 2024-12-2 */ public class Solution { public static void main(String[] args) { // Integer is an immutable class List\u0026lt;Integer\u0026gt; original = new ArrayList\u0026lt;\u0026gt;(); original.add(1); original.add(2); List\u0026lt;Integer\u0026gt; shallowCopy = new ArrayList\u0026lt;\u0026gt;(original); // Shallow copy shallowCopy.set(0, 99); // Modify the shallow copy System.out.println(original); // Output: [1, 2] System.out.println(shallowCopy); // Output: [99, 2] } } Prototype v.s. Builder\n2.5 Abstract Factory The Abstract Factory design pattern is a creational pattern that creates families of related objects without specifying their concrete classes. It allows the client to instantiate objects from a group of related products while ensuring that these objects are compatible with each other. This pattern is particularly useful when a system needs to be independent of how objects are created, composed, and represented. However, a limitation of this pattern is that when a new product type is added, the base factory typically needs to be modified, which can increase the maintainence overhead.\nSHOW CODE Java // Represents an abstract product interface Storage { String getId(); } // Represents a concrete product in a family \"Amazon Web Services\" class S3Storage implements Storage { public S3Storage(int capacityInMib) { System.out.println(\"Allocated \" + capacityInMib + \" on S3\"); } @Override public String getId() { return \"S31\"; } @Override public String toString() { return \"S3 Storage\"; } } // Represents a concrete product in a family \"Google Cloud Platform\" class GoogleCloudStorage implements Storage { public GoogleCloudStorage(int capacityInMib) { System.out.println(\"Allocated \" + capacityInMib + \" on Google Cloud Storage\"); } @Override public String getId() { return \"gcpcs1\"; } @Override public String toString() { return \"Google cloud storage\"; } } // Represents an abstract product interface Instance { enum Capacity {micro, small, large} void start(); void attachStorage(Storage storage); void stop(); } // Represents a concrete product in a family \"Amazon Web Services\" class Ec2Instance implements Instance { public Ec2Instance(Capacity capacity) { System.out.println(\"Created Ec2Instance\"); } @Override public void start() { System.out.println(\"Ec2Instance started\"); } @Override public void attachStorage(Storage storage) { System.out.println(\"Attached \" + storage + \" to Ec2Instance\"); } @Override public void stop() { System.out.println(\"Ec2Instance stopped\"); } @Override public String toString() { return \"EC2Instance\"; } } // Represents a concrete product in a family \"Google Cloud Platform\" class GoogleComputeEngineInstance implements Instance { public GoogleComputeEngineInstance(Capacity capacity) { System.out.println(\"Created Google Compute Engine instance\"); } @Override public void start() { System.out.println(\"Compute engine instance started\"); } @Override public void attachStorage(Storage storage) { System.out.println(\"Attached \" + storage + \" to Compute engine instance\"); } @Override public void stop() { System.out.println(\"Compute engine instance stopped\"); } } // Abstract factory with methods defined for each object type. interface ResourceFactory { Instance createInstance(Instance.Capacity capacity); Storage createStorage(int capMib); } // Factory implementation for Amazon Web Services resources class AwsResourceFactory implements ResourceFactory { @Override public Instance createInstance(Instance.Capacity capacity) { return new Ec2Instance(capacity); } @Override public Storage createStorage(int capMib) { return new S3Storage(capMib); } } // Factory implementation for Google Cloud Platform resources class GoogleResourceFactory implements ResourceFactory { @Override public Instance createInstance(Instance.Capacity capacity) { return new GoogleComputeEngineInstance(capacity); } @Override public Storage createStorage(int capMib) { return new GoogleCloudStorage(capMib); } } // Client class public class Client { private ResourceFactory factory; public Client(ResourceFactory factory) { this.factory = factory; } public Instance createServer(Instance.Capacity cap, int storageMib) { Instance instance = factory.createInstance(cap); Storage storage = factory.createStorage(storageMib); instance.attachStorage(storage); return instance; } public static void main(String[] args) { Client aws = new Client(new AwsResourceFactory()); Instance i1 = aws.createServer(Instance.Capacity.micro, 20480); i1.start(); i1.stop(); System.out.println(\"***************************************\"); Client gcp = new Client(new GoogleResourceFactory()); i1 = gcp.createServer(Instance.Capacity.micro, 20480); i1.start(); i1.stop(); } } SHOW OUTPUT Output Created Ec2Instance Allocated 20480 on S3 Attached S3 Storage to Ec2Instance Ec2Instance started Ec2Instance stopped *************************************** Created Google Compute Engine instance Allocated 20480 on Google Cloud Storage Attached Google cloud storage to Compute engine instance Compute engine instance started Compute engine instance stopped Adding a new product type, such as Engine, may require modifications to the base factory. This is because the new Engine product froms a new combination with Storage and Instance, and the base factory is responsible for creating all the products (i.e., Storage, Instance, and Engine). As a result, the base factory needs to include a new method, createEngine. This modification violates the Open/Closed Principle (OCP), which states that classes should be open for extension but closed for modification.\nSHOW CODE Java // Represents an abstract product for Storage interface Storage { String getId(); } // Represents a concrete product in a family \"Amazon Web Services\" for Storage class S3Storage implements Storage { public S3Storage(int capacityInMib) { System.out.println(\"Allocated \" + capacityInMib + \" on S3\"); } @Override public String getId() { return \"S31\"; } @Override public String toString() { return \"S3 Storage\"; } } // Represents a concrete product in a family \"Google Cloud Platform\" for Storage class GoogleCloudStorage implements Storage { public GoogleCloudStorage(int capacityInMib) { System.out.println(\"Allocated \" + capacityInMib + \" on Google Cloud Storage\"); } @Override public String getId() { return \"gcpcs1\"; } @Override public String toString() { return \"Google Cloud Storage\"; } } // Represents an abstract product for Engine interface Engine { String getName(); } // Represents a concrete product in a family \"Amazon Web Services\" for Engine class Ec2Engine implements Engine { String name; public Ec2Engine(String name) { this.name = name; System.out.println(name + \" engine selected.\"); } @Override public String getName() { return name; } } // Represents a concrete product in a family \"Google Cloud Platform\" for Engine class GoogleComputeEngine implements Engine { String name; public GoogleComputeEngine(String name) { this.name = name; System.out.println(name + \" engine selected.\"); } @Override public String getName() { return name; } } // Represents an abstract product for Instance interface Instance { enum Capacity {micro, small, large} void start(); void attachStorage(Storage storage); void stop(); void useEngine(Engine engine); } // Represents a concrete product in a family \"Amazon Web Services\" for Instance class Ec2Instance implements Instance { public Ec2Instance(Instance.Capacity capacity) { System.out.println(\"Created Ec2Instance\"); } @Override public void start() { System.out.println(\"Ec2Instance started\"); } @Override public void attachStorage(Storage storage) { System.out.println(\"Attached \" + storage + \" to Ec2Instance\"); } @Override public void stop() { System.out.println(\"Ec2Instance stopped\"); } @Override public void useEngine(Engine engine) { System.out.println(\"Ec2Instance uses \" + engine.getName() + \" engine.\"); } @Override public String toString() { return \"EC2Instance\"; } } // Represents a concrete product in a family \"Google Cloud Platform\" for Instance class GoogleComputeEngineInstance implements Instance { public GoogleComputeEngineInstance(Instance.Capacity capacity) { System.out.println(\"Created Google Compute Engine instance\"); } @Override public void start() { System.out.println(\"Compute engine instance started\"); } @Override public void attachStorage(Storage storage) { System.out.println(\"Attached \" + storage + \" to Compute engine instance\"); } @Override public void stop() { System.out.println(\"Compute engine instance stopped\"); } @Override public void useEngine(Engine engine) { System.out.println(\"Google compute engine instance uses \" + engine.getName() + \" engine.\"); } } // Abstract factory with methods defined for each object type interface ResourceFactory { Instance createInstance(Instance.Capacity capacity); Storage createStorage(int capMib); Engine createEngine(String name); } // Factory implementation for Amazon Web Services resources class AwsResourceFactory implements ResourceFactory { @Override public Instance createInstance(Instance.Capacity capacity) { return new Ec2Instance(capacity); // Pass engine to the Ec2Instance } @Override public Storage createStorage(int capMib) { return new S3Storage(capMib); } @Override public Engine createEngine(String name) { return new Ec2Engine(name); } } // Factory implementation for Google Cloud Platform resources class GoogleResourceFactory implements ResourceFactory { @Override public Instance createInstance(Instance.Capacity capacity) { return new GoogleComputeEngineInstance(capacity); } @Override public Storage createStorage(int capMib) { return new GoogleCloudStorage(capMib); } @Override public Engine createEngine(String name) { return new GoogleComputeEngine(name); } } // Client class to test the code public class Client { private ResourceFactory factory; public Client(ResourceFactory factory) { this.factory = factory; } public Instance createServer(Instance.Capacity cap, int storageMib, String name) { Instance instance = factory.createInstance(cap); // Pass engine to instance creation Storage storage = factory.createStorage(storageMib); Engine engine = factory.createEngine(name); instance.attachStorage(storage); instance.useEngine(engine); // Call useEngine() on instance, which delegates to engine's getName() return instance; } public static void main(String[] args) { Client aws = new Client(new AwsResourceFactory()); Instance i1 = aws.createServer(Instance.Capacity.micro, 20480, \"Ec2\"); i1.start(); i1.stop(); System.out.println(\"***************************************\"); Client gcp = new Client(new GoogleResourceFactory()); i1 = gcp.createServer(Instance.Capacity.micro, 20480, \"GCE\"); i1.start(); i1.stop(); } } 2.6 Singleton Singleton is a creational design pattern that ensures a class has only one instance and provides a global point of access to that instance (typically through a static method). To implement a Singleton, the class constructor must be private, which prevents external classes from creating instances of the class directly, and a global static method should be provided to access the instance. There are two common types of Singleton: Eager Singleton and Lazy Singleton.\n2.6.1 Eager Singleton Eager Singleton ensures that an instance is created as soon as the class is loaded, rather than being created when needed. This guarantees that the instance is ready to use but may cause unnecessary overhead if the instance is never actually used.\nSHOW CODE: Eager Singleton Eager Singleton package dev.signalyu.singleton; public class EagerRegistry { private EagerRegistry() { // Private constructor to prevent instantiation } // Eagerly initializing the single instance of EagerRegistry private static final EagerRegistry INSTANCE = new EagerRegistry(); // Public method to provide access to the instance public static EagerRegistry getInstance() { return INSTANCE; } // Main method to demonstrate usage public static void main(String[] args) { // Accessing the singleton instance EagerRegistry registry = EagerRegistry.getInstance(); System.out.println(\"Singleton instance: \" + registry); } } SHOW OUTPUT Output Singleton instance: dev.signalyu.singleton.EagerRegistry@7a81197d 2.6.2 Lazy Singleton Lazy Singleton ensures that an instance of the class is created only when it is actually needed. This approach helps avoid unnecessary overhead but requires additional mechanisms to ensure thread safety in multi-threaded environments. It is commonly implemented using techniques like Double-Checked Locking or Initialization-on-Demand Holder.\nDouble-Checked Locking is an optimization technique ensures only one instance of a class is created, even in a multi-threaded environment, while minimizing synchronization overhead. This approach involves two checks: The first check, outside the synchronized block, allows the thread to bypass synchronization if the instance has already been created. The second check, inside the synchronized block, ensures that only one thread can create the instance, even if multiple threads attempt to do so concurrently.\nSHOW CODE: Double-Checked Locking Double-Checked Locking package dev.signalyu.singleton; public class LazyRegistryWithDCL { // Private constructor to prevent external instantiation private LazyRegistryWithDCL() {} // Volatile keyword ensures visibility of changes across threads private static volatile LazyRegistryWithDCL INSTANCE; // Public method to provide access to the Singleton instance public static LazyRegistryWithDCL getInstance() { if (INSTANCE == null) { // First check (outside synchronized block) synchronized (LazyRegistryWithDCL.class) { // Synchronized block to ensure only one thread can create the instance if (INSTANCE == null) { // Second check (inside synchronized block) INSTANCE = new LazyRegistryWithDCL(); // Lazy initialization } } } return INSTANCE; } // Main method to demonstrate the usage of the Singleton public static void main(String[] args) { // Accessing the Singleton instance LazyRegistryWithDCL registry = LazyRegistryWithDCL.getInstance(); System.out.println(\"Singleton instance: \" + registry); } } SHOW OUTPUT Output Singleton instance: dev.signalyu.singleton.LazyRegistryWithDCL@7a81197d The Initialization-on-Demand Holder technique leverages the class loading mechnism to ensure that the Singleton instance is created only when it is first accessed. It takes advantages of the fact that class loading in Java inherently thread-safe. This approach relies on static inner classes, which are not loaded until they are referenced, meaning that the instance is created only when it is actually needed.\nSHOW CODE: Initialization-on-Demand Holder Initialization-on-Demand Holder package dev.signalyu.singleton; public class LazyRegistryIODH { // Private constructor to prevent external instantiation private LazyRegistryIODH() { System.out.println(\"In LazyRegistryIODH singleton\"); } // Static inner class that holds the Singleton instance private static class RegistryHolder { // The Singleton instance is created when the class is loaded static final LazyRegistryIODH INSTANCE = new LazyRegistryIODH(); } // Public method to provide access to the Singleton instance public static LazyRegistryIODH getInstance() { return RegistryHolder.INSTANCE; } // Main method to demonstrate the usage of the Singleton public static void main(String[] args) { // Accessing the Singleton instance LazyRegistryIODH registry = LazyRegistryIODH.getInstance(); System.out.println(\"Singleton instance: \" + registry); } } SHOW OUTPUT Output In LazyRegistryIODH singleton Singleton instance: dev.signalyu.singleton.LazyRegistryIODH@5ca881b5 2.7 Object Pool Object Pool Design Pattern is a creational design pattern that manages a collection of reusable objects, rather than frequently creating and destroying objects. These objects are stored in a pool, from which clients can borrow objects, use them, and return them when they are done. This pattern is particularly useful in scenerios where a large number of objects are needed temporarily, and the cost of creating these objects is high, such as resource management (e.g., database connection or thread pools).\nSHOW CODE Java import java.util.concurrent.BlockingQueue; import java.util.concurrent.LinkedBlockingQueue; import java.util.function.Supplier; // Point2D class class Point2D { private float x, y; public Point2D(float x, float y) { this.x = x; this.y = y; } @Override public String toString() { return \"Point2D [x=\" + x + \", y=\" + y + \"]\"; } } // Poolable interface interface Poolable { // state reset void reset(); } // Image interface extending Poolable interface Image extends Poolable { void draw(); Point2D getLocation(); void setLocation(Point2D location); } // Bitmap class implementing Image and Poolable class Bitmap implements Image { private Point2D location; private String name; public Bitmap(String name) { this.name = name; } @Override public void draw() { System.out.println(\"Drawing \" + name + \" @ \" + location); } @Override public Point2D getLocation() { return location; } @Override public void setLocation(Point2D location) { this.location = location; } @Override public void reset() { location = null; System.out.println(\"Bitmap is reset\"); } } // ObjectPool class for reusable objects class ObjectPool { private BlockingQueue\u0026lt;T\u0026gt; availablePool; public ObjectPool(Supplier\u0026lt;T\u0026gt; creator, int count) { availablePool = new LinkedBlockingQueue\u0026lt;\u0026gt;(); for (int i = 0; i \u003c count; i++) { availablePool.offer(creator.get()); } } public T get() { try { return availablePool.take(); } catch (InterruptedException ex) { System.err.println(\"take() was interrupted\"); } return null; } public void release(T obj) { obj.reset(); try { availablePool.put(obj); } catch (InterruptedException e) { System.err.println(\"put() was interrupted\"); } } } // Main class to demonstrate Object Pool usage public class Client { public static void main(String[] args) { // Create a pool for Bitmap objects with 5 instances ObjectPool\u0026lt;Bitmap\u0026gt; bitmapPool = new ObjectPool\u0026lt;\u0026gt;(() -\u003e new Bitmap(\"Logo.bmp\"), 5); // Borrow Bitmap objects from the pool Bitmap b1 = bitmapPool.get(); b1.setLocation(new Point2D(10, 10)); Bitmap b2 = bitmapPool.get(); b2.setLocation(new Point2D(-10, 0)); // Use the objects b1.draw(); b2.draw(); // Release the objects back to the pool bitmapPool.release(b1); bitmapPool.release(b2); } } --- title: UML Diagram of Object Pool Design Pattern --- classDiagram ObjectPool --\u003e Bitmap : uses Bitmap --\u003e Point2D : uses Poolable \u003c|-- Image : implements Image \u003c|-- Bitmap : implements Client --\u003e ObjectPool : uses class ObjectPool { +BlockingQueue~T~ availablePool +ObjectPool(Supplier~T~ creator, int count) +T get() +void release(T obj) } class Bitmap { +Point2D location +String name +Bitmap(String name) +void draw() +Point2D getLocation() +void setLocation(Point2D location) +void reset() } class Point2D { +float x +float y +Point2D(float x, float y) +String toString() } class Poolable { +void reset() } class Image { +void draw() +Point2D getLocation() +void setLocation(Point2D location) } class Client { +void main() } 3. Structural Design Patterns Structural Design Pattern focus on optimizing object composition, helping achieve better organization and efficiency.\n3.1 Adapter The Adapter Design Pattern is a structural design pattern that allows two incompatible interfaces to work together, enabling them to communicate despite differences in their method signatures. This pattern is commonly used in situations where legacy code cannot be modified but needs to integrate with a new system that has a different interface.\nSHOW CODE Java // Target Interface interface Customer { String getName(); String getDesignation(); String getAddress(); } // Client code which requires Customer interface. class BusinessCardDesigner { public String designCard(Customer customer) { String card = \"\"; card += customer.getName(); card += \"\\n\" + customer.getDesignation(); card += \"\\n\" + customer.getAddress(); return card; } } // An existing class used in our system - Adaptee class Employee { private String fullName; private String jobTitle; private String officeLocation; public String getFullName() { return fullName; } public void setFullName(String fullName) { this.fullName = fullName; } public String getJobTitle() { return jobTitle; } public void setJobTitle(String jobTitle) { this.jobTitle = jobTitle; } public String getOfficeLocation() { return officeLocation; } public void setOfficeLocation(String officeLocation) { this.officeLocation = officeLocation; } } // An object adapter using composition to translate the interface class EmployeeObjectAdapter implements Customer { private final Employee adaptee; public EmployeeObjectAdapter(Employee adaptee) { this.adaptee = adaptee; } @Override public String getName() { return adaptee.getFullName(); } @Override public String getDesignation() { return adaptee.getJobTitle(); } @Override public String getAddress() { return adaptee.getOfficeLocation(); } } public class Client { public static void main(String[] args) { // Using Object Adapter Employee employee = new Employee(); populateEmployeeData(employee); EmployeeObjectAdapter objectAdapter = new EmployeeObjectAdapter(employee); BusinessCardDesigner designer = new BusinessCardDesigner(); String card = designer.designCard(objectAdapter); System.out.println(card); } private static void populateEmployeeData(Employee employee) { employee.setFullName(\"Signal Yu\"); employee.setJobTitle(\"Software Engineer\"); employee.setOfficeLocation(\"Shenzhen, Guangdong Province\"); } } --- title: UML Diagram of Adapter Design Pattern --- classDiagram class Customer { +String getName() +String getDesignation() +String getAddress() } class BusinessCardDesigner { +String designCard(Customer customer) } class Employee { -String fullName -String jobTitle -String officeLocation +String getFullName() +String getJobTitle() +String getOfficeLocation() +setFullName(String fullName) +setJobTitle(String jobTitle) +setOfficeLocation(String officeLocation) } class EmployeeObjectAdapter { -Employee adaptee +String getName() +String getDesignation() +String getAddress() } Customer \u003c|-- EmployeeObjectAdapter : implements BusinessCardDesigner --\u003e Customer : uses EmployeeObjectAdapter --\u003e Employee : adapts 3.2 Bridge The Bridge Design Pattern is a structural design pattern that separates the abstraction and implementation, enabling them to evolve independently without affecting each other.\nIn the following example, the Queue data structure is decoupled from the implementation of LinkedList. When there is a need to change the way data is stored, this can be done without modifying the Queue class. Additionally, when a new type of list, such as Doubly Linked List, is introduced, it can be done without affecting the behavior of the Queue class.\nSHOW CODE Java // This is the implementor interface. // It defines the basic operations for a LinkedList. interface LinkedList { void addFirst(T element); T removeFirst(); void addLast(T element); T removeLast(); int getSize(); } // A concrete implementor that uses nodes to implement a Singly Linked List. // **NOT thread safe** class SinglyLinkedList implements LinkedList { private int size; private Node head; private Node last; private static class Node { private final Object data; private Node next; private Node(Object data, Node next) { this.data = data; this.next = next; } } @Override public void addFirst(T element) { if (head == null) { last = head = new Node(element, null); } else { head = new Node(element, head); } size++; } @Override public T removeFirst() { if (head == null) { return null; } @SuppressWarnings(\"unchecked\") T temp = (T) head.data; if (head.next != null) { head = head.next; } else { head = null; last = null; } size--; return temp; } @Override public void addLast(T element) { if (last == null) { last = head = new Node(element, null); } else { last.next = new Node(element, null); last = last.next; } size++; } @Override public T removeLast() { if (last == null) { return null; } if (head == last) { @SuppressWarnings(\"unchecked\") T temp = (T) head.data; head = last = null; size--; return temp; } // since we don't have a back pointer Node temp = head; while (temp.next != last) { temp = temp.next; } @SuppressWarnings(\"unchecked\") T result = (T) last.data; last = temp; last.next = null; size--; return result; } @Override public int getSize() { return size; } @Override public String toString() { StringBuilder result = new StringBuilder(\"[\"); Node temp = head; while (temp != null) { result.append(temp.data).append(temp.next == null ? \"\" : \", \"); temp = temp.next; } result.append(\"]\"); return result.toString(); } } // A concrete implementor that uses arrays to implement a LinkedList. // **NOT thread safe** class ArrayLinkedList implements LinkedList { private static final int DEFAULT_SIZE = 2; private Object[] data; private int size; public ArrayLinkedList() { data = new Object[DEFAULT_SIZE]; } @Override public void addFirst(T element) { ensureCapacity(++size); shiftOneRight(); data[0] = element; } @Override public T removeFirst() { if (size == 0) { return null; } @SuppressWarnings(\"unchecked\") T first = (T) data[0]; size--; shiftOneLeft(); return first; } @Override public void addLast(T element) { ensureCapacity(size + 1); data[size++] = element; } @Override @SuppressWarnings(\"unchecked\") public T removeLast() { if (size == 0) { return null; } return (T) data[size--]; } private void ensureCapacity(int newSize) { if (data.length \u003e newSize) { return; } Object[] temp = new Object[data.length + DEFAULT_SIZE]; System.arraycopy(data, 0, temp, 0, data.length); data = temp; } private void shiftOneRight() { System.arraycopy(data, 0, data, 1, size); } private void shiftOneLeft() { System.arraycopy(data, 1, data, 0, size); } public int getSize() { return size; } @Override public String toString() { StringBuilder result = new StringBuilder(\"[\"); for (int i = 0; i \u003c size; i++) { result.append(data[i]).append(i == size - 1 ? \"\" : \", \"); } result.append(\"]\"); return result.toString(); } } // This is the abstraction interface representing a FIFO collection. interface FifoCollection { // Adds an element to the collection void offer(T element); // Removes \u0026 returns the first element from the collection T poll(); } // A refined abstraction that uses LinkedList to implement a Queue. class Queue implements FifoCollection { private final LinkedList list; public Queue(LinkedList list) { this.list = list; } @Override public void offer(T element) { list.addLast(element); } @Override public T poll() { return list.removeFirst(); } @Override public String toString() { return \"Queue{\" + \"list=\" + list.toString() + '}'; } } // Client code to demonstrate the bridge pattern public class Client { public static void main(String[] args) { FifoCollection\u0026lt;Integer\u0026gt; arrayQueue = new Queue\u0026lt;\u0026gt;(new ArrayLinkedList\u0026lt;\u0026gt;()); arrayQueue.offer(1); arrayQueue.offer(2); arrayQueue.offer(3); System.out.print(\"Array List Queue: \"); System.out.println(arrayQueue); FifoCollection\u0026lt;Integer\u0026gt; linkedListQueue = new Queue\u0026lt;\u0026gt;(new SinglyLinkedList\u0026lt;\u0026gt;()); linkedListQueue.offer(11); linkedListQueue.offer(22); linkedListQueue.offer(33); System.out.print(\"Linked List Queue: \"); System.out.println(linkedListQueue); System.out.print(linkedListQueue.poll() + \" \"); System.out.print(linkedListQueue.poll() + \" \"); System.out.print(linkedListQueue.poll() + \"\\n\"); // Should print null as all elements are removed System.out.println(linkedListQueue.poll()); // null } } SHOW OUTPUT Output Array List Queue: Queue{list=[1, 2, 3]} Linked List Queue: Queue{list=[11, 22, 33]} 11 22 33 null --- title: UML Diagram of Adapter Design Pattern --- classDiagram class LinkedList { +addFirst(T element) +removeFirst() +addLast(T element) +removeLast() +getSize() } class SinglyLinkedList { -int size -Node head -Node last +addFirst(T element) +removeFirst() +addLast(T element) +removeLast() +getSize() +toString() } class ArrayLinkedList { -Object[] data -int size +addFirst(T element) +removeFirst() +addLast(T element) +removeLast() +getSize() +toString() } class FifoCollection { +offer(T element) +poll() } class Queue { -LinkedList list +offer(T element) +poll() +toString() } LinkedList \u003c|.. SinglyLinkedList LinkedList \u003c|.. ArrayLinkedList FifoCollection \u003c|.. Queue : implements Queue *--\u003e LinkedList : composites %% Client code class class Client { +main(String[] args) } Client --\u003e FifoCollection : Uses 3.3 Decorator Decorator Design Pattern is a structural design pattern that allows addding new behaviors to an object dynamically, without altering its structure.\nSHOW CODE Java import org.apache.commons.text.StringEscapeUtils; import java.util.Base64; // Base interface or component interface Message { String getContent(); } // Concrete component. Object to be decorated class TextMessage implements Message { private String msg; public TextMessage(String msg) { this.msg = msg; } @Override public String getContent() { return msg; } } // Decorator. Implements component interface class HtmlEncodedMessage implements Message { private Message msg; public HtmlEncodedMessage(Message msg) { this.msg = msg; } @Override public String getContent() { return StringEscapeUtils.escapeHtml4(msg.getContent()); } } // Decorator for Base64 encoding class Base64EncodedMessage implements Message { private Message msg; public Base64EncodedMessage(Message msg) { this.msg = msg; } @Override public String getContent() { // Be wary of charset!! This is platform dependent.. return Base64.getEncoder().encodeToString(msg.getContent().getBytes()); } } // Client to demonstrate the decorators public class Client { public static void main(String[] args) { Message m = new TextMessage(\"The is strong with this one!\"); System.out.println(\"Original: \" + m.getContent()); // Apply HTML encoding Message decorator = new HtmlEncodedMessage(m); System.out.println(\"HTML Encoded: \" + decorator.getContent()); // Apply Base64 encoding decorator = new Base64EncodedMessage(decorator); System.out.println(\"Base64 Encoded: \" + decorator.getContent()); } } --- title: UML Diagram of Decorator Design Pattern --- classDiagram class Message { +String getContent() } class TextMessage { -String msg +TextMessage(String msg) +String getContent() } class HtmlEncodedMessage { -Message msg +HtmlEncodedMessage(Message msg) +String getContent() } class Base64EncodedMessage { -Message msg +Base64EncodedMessage(Message msg) +String getContent() } Message \u003c|-- TextMessage Message \u003c|-- HtmlEncodedMessage Message \u003c|-- Base64EncodedMessage TextMessage --\u003e HtmlEncodedMessage : Wraps HtmlEncodedMessage --\u003e Base64EncodedMessage : Wraps 3.4 Composite The Composite Design Pattern is a structural pattern that enables treating both individual objects and compositions of objects uniformly. It is designed to represent part-whole hierarchies, where individual objects (leaf nodes) and their composites are handled in the same way. This pattern is often used for managing complex hierarchical structures, such as file systems or organization structures.\nSHOW CODE Java import java.util.ArrayList; import java.util.List; // The component base class for composite pattern // Defines operations applicable both leaf \u0026 composite abstract class File { private String name; public File(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } public abstract void ls(); public abstract void addFile(File file); public abstract File[] getFiles(); public abstract boolean removeFile(File file); } // Leaf node in composite pattern class BinaryFile extends File { private long size; public BinaryFile(String name, long size) { super(name); this.size = size; } @Override public void ls() { System.out.println(getName() + \"\\t\" + size); } @Override public void addFile(File file) { throw new UnsupportedOperationException(\"Leaf node doesn't support add operation\"); } @Override public File[] getFiles() { throw new UnsupportedOperationException(\"Leaf node doesn't support get operation\"); } @Override public boolean removeFile(File file) { throw new UnsupportedOperationException(\"Leaf node doesn't support remove operation\"); } } // Composite in the composite pattern class Directory extends File { private List\u0026lt;File\u0026gt; children = new ArrayList\u0026lt;\u0026gt;(); public Directory(String name) { super(name); } @Override public void ls() { System.out.println(getName()); children.forEach(File::ls); } @Override public void addFile(File file) { children.add(file); } @Override public File[] getFiles() { return children.toArray(new File[children.size()]); } @Override public boolean removeFile(File file) { return children.remove(file); } } // Client class that creates and displays directory structure public class Client { public static void main(String[] args) { File root1 = createTreeOne(); root1.ls(); System.out.println(\"***********************************\"); File root2 = createTreeTwo(); root2.ls(); } // Client builds tree using leaf and composites private static File createTreeOne() { File file1 = new BinaryFile(\"file1\", 1000); File file2 = new BinaryFile(\"file2\", 2000); Directory dir1 = new Directory(\"dir1\"); dir1.addFile(file1); dir1.addFile(file2); File file3 = new BinaryFile(\"file3\", 3000); Directory dir2 = new Directory(\"dir2\"); dir2.addFile(file3); dir2.addFile(dir1); return dir2; } private static File createTreeTwo() { return new BinaryFile(\"Another file\", 200); } } In the above code, the statements dir2.addFile(file3); and dir2.addFile(dir1); demonstrate how both individual objects (file3) and compositions of objects (file1 and file2) are treated in the same way.\n--- title: UML Diagram of Composite Design Pattern --- classDiagram class File { +String name +getName() +setName(String name) +ls() +addFile(File file) +getFiles() +removeFile(File file) } class BinaryFile { +long size +BinaryFile(String name, long size) +ls() +addFile(File file) +getFiles() +removeFile(File file) } class Directory { +List~File~ children +Directory(String name) +ls() +addFile(File file) +getFiles() +removeFile(File file) } File \u003c|-- BinaryFile File \u003c|-- Directory Directory *--\u003e File : contains 3.5 Facade The Facade Design Pattern is a structural design pattern that provides a simplified interface to a complex subsystem. It is often used when the client needs to interact with only a specific part of a large system, hiding its complexity and making it easier to use.\nSHOW CODE Java package dev.signalyu.facade; // Template class and related classes abstract class Template { public enum TemplateType {Email, NewsLetter} public abstract String format(Object obj); } class TemplateFactory { public static Template createTemplateFor(Template.TemplateType type) { switch (type) { case Email: return new OrderEmailTemplate(); default: throw new IllegalArgumentException(\"Unknown TemplateType\"); } } } class OrderEmailTemplate extends Template { @Override public String format(Object obj) { return \"TEMPLATE\"; } } // Stationary class and related classes interface Stationary { String getHeader(); String getFooter(); } class StationaryFactory { public static Stationary createStationary() { return new HalloweenStationary(); } } class HalloweenStationary implements Stationary { @Override public String getHeader() { return \"It's Halloween!!\"; } @Override public String getFooter() { return \"BUY MORE STUFF! It's Halloween, c'mon!!\"; } } // Email class and related classes class EmailBuilder { public EmailBuilder withTemplate(Template template) { return this; } public EmailBuilder withStationary(Stationary stationary) { return this; } public EmailBuilder forObject(Object object) { return this; } public Email build() { return new Email(); } public Email getEmail() { return new Email(); } } class Email { public static EmailBuilder getBuilder() { return new EmailBuilder(); } } // Mailer class class Mailer { private static final Mailer MAILER = new Mailer(); public static Mailer getMailer() { return MAILER; } private Mailer() { } public boolean send(Email email) { return true; } } // Order class for reference (assuming Order exists as a placeholder) class Order { private String id; private double total; public Order(String id, double total) { this.id = id; this.total = total; } public String getId() { return id; } public void setId(String id) { this.id = id; } public double getTotal() { return total; } public void setTotal(double total) { this.total = total; } } // Facade provides simple methods for the client to use class EmailFacade { public boolean sendOrderEmail(Order order) { Template template = TemplateFactory.createTemplateFor(Template.TemplateType.Email); Stationary stationary = StationaryFactory.createStationary(); Email email = Email.getBuilder() .withTemplate(template) .withStationary(stationary) .forObject(order) .build(); Mailer mailer = Mailer.getMailer(); return mailer.send(email); } } public class Client { public static void main(String[] args) { Order order = new Order(\"101\", 99.99); EmailFacade facade = new EmailFacade(); boolean result = facade.sendOrderEmail(order); System.out.println(\"Order Email \" + (result ? \"sent!\" : \"NOT sent...\")); } } --- title: UML Diagram of Facade Design Pattern --- classDiagram class EmailFacade { +sendOrderEmail(order: Order) bool } class Template { +format(obj: Object) String } class TemplateFactory { +createTemplateFor(type: TemplateType) Template } class OrderEmailTemplate { +format(obj: Object) String } class Stationary { +getHeader() String +getFooter() String } class StationaryFactory { +createStationary() Stationary } class HalloweenStationary { +getHeader() String +getFooter() String } class EmailBuilder { +withTemplate(template: Template) EmailBuilder +withStationary(stationary: Stationary) EmailBuilder +forObject(object: Object) EmailBuilder +build() Email } class Email { +getBuilder() EmailBuilder } class Mailer { +getMailer() Mailer +send(email: Email) bool } EmailFacade --\u003e TemplateFactory : uses EmailFacade --\u003e StationaryFactory : uses EmailFacade --\u003e Mailer : uses TemplateFactory --\u003e OrderEmailTemplate : creates StationaryFactory --\u003e HalloweenStationary : creates Email --\u003e EmailBuilder : has EmailBuilder --\u003e Template : uses EmailBuilder --\u003e Stationary : uses Mailer --\u003e Email : uses EmailBuilder --\u003e Email : creates OrderEmailTemplate --\u003e Template : inherits HalloweenStationary --\u003e Stationary : implements 3.6 Flyweight The Flyweight Design Pattern is a structural design pattern used to optimize memory usuage by sharing common data across multiple objects. In this pattern, an object is divided into two categories: intrinsic state and extrinsic state.\nIntrinsic state refers to the data that is shared and remains consistent across different instances. It is usually stored within the Flyweight object. Extrinsic state, on the other hand, refers to data that can vary between instances. This state is typically managed and provided by the client or the object using the Flyweight. SHOW CODE Java import java.time.Duration; import java.util.HashMap; import java.util.Map; // Interface implemented by Flyweights interface ErrorMessage { // Get error message String getText(String code); } // A concrete Flyweight. Instance is shared class SystemErrorMessage implements ErrorMessage { // some error message $errorCode private String messageTemplate; // http://somedomain.com/help?error= private String helpUrlBase; public SystemErrorMessage(String messageTemplate, String helpUrlBase) { this.messageTemplate = messageTemplate; this.helpUrlBase = helpUrlBase; } @Override public String getText(String code) { return messageTemplate.replace(\"$errorCode\", code) + helpUrlBase + code; } } // Unshared concrete flyweight. class UserBannedErrorMessage implements ErrorMessage { // All state is defined here private String caseId; private String remarks; private Duration banDuration; private String msg; public UserBannedErrorMessage(String caseId) { // Load case info from DB. this.caseId = caseId; remarks = \"You violated terms of use.\"; banDuration = Duration.ofDays(2); msg = \"You are BANNED. Sorry. \\nMore information:\\n\"; msg += caseId + \"\\n\"; msg += remarks + \"\\n\"; msg += \"Banned For:\" + banDuration.toHours() + \" Hours\"; } // We ignore the extrinsic state argument @Override public String getText(String code) { return msg; } public String getCaseNo() { return caseId; } } // Flyweight factory. Returns shared flyweight based on key class ErrorMessageFactory { // This serves as key for getting flyweight instance public enum ErrorType { GenericSystemError, PageNotFoundError, ServerError } private static final ErrorMessageFactory FACTORY = new ErrorMessageFactory(); public static ErrorMessageFactory getInstance() { return FACTORY; } private Map\u0026lt;ErrorType, SystemErrorMessage\u0026gt; errorMessages = new HashMap\u0026lt;\u0026gt;(); private ErrorMessageFactory() { errorMessages.put(ErrorType.GenericSystemError, new SystemErrorMessage(\"A genetic error of type $errorCode occurred. Please refer to:\\n\", \"https://google.com/q=\")); errorMessages.put(ErrorType.PageNotFoundError, new SystemErrorMessage(\"Page not found. An error of type $errorCode occurred. Please refer to:\\n\", \"https://google.com/q=\")); } public SystemErrorMessage getError(ErrorType type) { return errorMessages.get(type); } public UserBannedErrorMessage getUserBannedMessage(String caseId) { return new UserBannedErrorMessage(caseId); } } // Client public class Client { public static void main(String[] args) { // Accessing shared flyweight objects SystemErrorMessage msg1 = ErrorMessageFactory.getInstance().getError(ErrorMessageFactory.ErrorType.GenericSystemError); System.out.println(msg1.getText(\"4056\")); // Accessing unshared flyweight objects UserBannedErrorMessage msg2 = ErrorMessageFactory.getInstance().getUserBannedMessage(\"1202\"); System.out.println(msg2.getText(null)); } } SHOW OUTPUT Output A genetic error of type 4056 occurred. Please refer to: https://google.com/q=4056 You are BANNED. Sorry. More information: 1202 You violated terms of use. Banned For:48 Hours --- title: UML Diagram of Flyweight Design Pattern --- classDiagram class ErrorMessage { +getText(code: String): String } class SystemErrorMessage { -messageTemplate: String -helpUrlBase: String +getText(code: String): String } class UserBannedErrorMessage { -caseId: String -remarks: String -banDuration: Duration -msg: String +getText(code: String): String +getCaseNo(): String } class ErrorMessageFactory { -errorMessages: Map~ErrorType, SystemErrorMessage~ +getInstance(): ErrorMessageFactory +getError(type: ErrorType): SystemErrorMessage +getUserBannedMessage(caseId: String): UserBannedErrorMessage } class Client { +main(args: String[]): void } ErrorMessage \u003c|-- SystemErrorMessage ErrorMessage \u003c|-- UserBannedErrorMessage ErrorMessageFactory *--\u003e SystemErrorMessage ErrorMessageFactory *--\u003e UserBannedErrorMessage Client --\u003e ErrorMessageFactory 3.7 Proxy The Proxy Design Pattern is a structural design pattern that involves using a proxy object to represent another object. The proxy controls access to the real object and can add additional functionality, such aas lazy initialization, logging, or monitoring. This pattern can be primarily categorized into two types: Static Proxy and Dynamic Proxy.\nThe Static Proxy is created at compile time, where a separate proxy class is written to manage method calls to the real object. In contrast, the Dynamic Proxy is created at runtime, often using reflection techniques in languages like Java. A dynamic proxy delegates method calls to the real object without the need for manually creating a proxy class.\nSHOW CODE: Static Proxy Java // Point2D class to represent the location of the image class Point2D { private final float x; private final float y; public Point2D(float x, float y) { this.x = x; this.y = y; } @Override public String toString() { return \"Point2D [x=\" + x + \", y=\" + y + \"]\"; } } // Interface implemented by proxy and concrete objects interface Image { void setLocation(Point2D point2d); Point2D getLocation(); void render(); } // Concrete class providing actual functionality class BitmapImage implements Image { private Point2D location; private final String name; public BitmapImage(String filename) { // Loads image from file on disk System.out.println(\"Loaded from disk: \" + filename); name = filename; } @Override public void setLocation(Point2D point2d) { location = point2d; } @Override public Point2D getLocation() { return location; } @Override public void render() { // Renders to screen System.out.println(\"Rendered \" + this.name); } } // Proxy class class ImageProxy implements Image { private final String name; private BitmapImage image; private Point2D location; public ImageProxy(String name) { this.name = name; } @Override public void setLocation(Point2D point2d) { if (image != null) { image.setLocation(point2d); } else { location = point2d; } } @Override public Point2D getLocation() { if (image != null) { return image.getLocation(); } return location; } @Override public void render() { if (image == null) { image = new BitmapImage(name); if (location != null) { image.setLocation(location); } } image.render(); } } // Factory to get image objects class ImageFactory { // We'll provide proxy to caller instead of real object public static Image getImage(String name) { return new ImageProxy(name); } } // Client class to test the proxy pattern public class Client { public static void main(String[] args) { Image img = ImageFactory.getImage(\"A1.bmp\"); img.setLocation(new Point2D(10, 10)); System.out.println(\"Image location: \" + img.getLocation()); System.out.println(\"Rendering image now...\"); img.render(); } } SHOW OUTPUT Output Image location: Point2D [x=10.0, y=10.0] Rendering image now... Loaded from disk: A1.bmp Rendered A1.bmp --- title: UML Diagram of Static Proxy Design Pattern --- classDiagram class Image { + setLocation(Point2D point2d) + Point2D getLocation() + render() } class BitmapImage { - Point2D location - String name + BitmapImage(String filename) + setLocation(Point2D point2d) + getLocation(): Point2D + render() } class ImageProxy { - String name - BitmapImage image - Point2D location + ImageProxy(String name) + setLocation(Point2D point2d) + getLocation(): Point2D + render() } class ImageFactory { + getImage(String name): Image } class Client { + main(String[] args) } Image \u003c|.. BitmapImage : implements Image \u003c|.. ImageProxy : implements ImageFactory --|\u003e ImageProxy : creates Client --\u003e ImageFactory : uses ImageProxy \"1\" --\u003e \"0..1\" BitmapImage : contains SHOW CODE: Dynamic Proxy Java import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; // Point2D class to represent the location of the image class Point2D { private final float x; private final float y; public Point2D(float x, float y) { this.x = x; this.y = y; } @Override public String toString() { return \"Point2D [x=\" + x + \", y=\" + y + \"]\"; } } // Interface implemented by proxy and concrete objects interface Image { void setLocation(Point2D point2d); Point2D getLocation(); void render(); } // Concrete class providing actual functionality (BitmapImage) class BitmapImage implements Image { private Point2D location; private final String name; public BitmapImage(String filename) { // Loads image from file on disk System.out.println(\"Loaded from disk: \" + filename); name = filename; } @Override public void setLocation(Point2D point2d) { location = point2d; } @Override public Point2D getLocation() { return location; } @Override public void render() { // Renders to screen System.out.println(\"Rendered \" + this.name); } } // InvocationHandler to implement proxy behavior class ImageInvocationHandler implements InvocationHandler { private final String filename; private Point2D location; private BitmapImage image; private static final Method setLocationMethod; private static final Method getLocationMethod; private static final Method renderMethod; static { try { setLocationMethod = Image.class.getMethod(\"setLocation\", Point2D.class); getLocationMethod = Image.class.getMethod(\"getLocation\"); renderMethod = Image.class.getMethod(\"render\"); } catch (NoSuchMethodException e) { throw new NoSuchMethodError(e.getMessage()); } } public ImageInvocationHandler(String filename) { this.filename = filename; } @Override public Object invoke(Object proxy, Method method, Object[] args) { System.out.println(\"Invoking method: \" + method.getName()); if (method.equals(setLocationMethod)) { return handleSetLocation(args); } else if (method.equals(getLocationMethod)) { return handleGetLocation(); } else if (method.equals(renderMethod)) { return handleRender(); } return null; } private Object handleRender() { if (image == null) { image = new BitmapImage(filename); if (location != null) { image.setLocation(location); } } image.render(); return null; } private Point2D handleGetLocation() { if (image != null) { return image.getLocation(); } else { return this.location; } } private Object handleSetLocation(Object[] args) { if (image != null) { image.setLocation((Point2D) args[0]); } else { this.location = (Point2D) args[0]; } return null; } } // Factory to provide the proxy object class ImageFactory { public static Image getImage(String name) { return (Image) Proxy.newProxyInstance( ImageFactory.class.getClassLoader(), new Class[]{Image.class}, new ImageInvocationHandler(name) ); } } // Client class to test the proxy pattern public class Client { public static void main(String[] args) { Image img = ImageFactory.getImage(\"A.bmp\"); img.setLocation(new Point2D(-10, 0)); System.out.println(img.getLocation()); System.out.println(\"*****************************\"); img.render(); } } SHOW OUTPUT Output Invoking method: setLocation Invoking method: getLocation Point2D [x=-10.0, y=0.0] ***************************** Invoking method: render Loaded from disk: A.bmp Rendered A.bmp --- title: UML Diagram of Dynamic Proxy Design Pattern --- classDiagram class Image { +setLocation(Point2D point2d) +getLocation(): Point2D +render() } class BitmapImage { -Point2D location -String name +BitmapImage(String filename) +setLocation(Point2D point2d) +getLocation(): Point2D +render() } class ImageInvocationHandler { -String filename -Point2D location -BitmapImage image +ImageInvocationHandler(String filename) +invoke(Object proxy, Method method, Object[] args) -handleRender() -handleGetLocation(): Point2D -handleSetLocation(Object[] args) } class ImageFactory { +getImage(String name): Image } class Client { +main(String[] args) } Image \u003c|.. BitmapImage : implements Image \u003c|.. ImageInvocationHandler : delegates ImageFactory ..\u003e ImageInvocationHandler : creates Client ..\u003e ImageFactory : uses ImageInvocationHandler \"1\" -- \"1\" BitmapImage : image 4. Behavioral Design Patterns Behavioral Design Patterns focus on the communication and interaction between objects or components in a system.\n4.1 Chain of Responsibility The Chain of Responsibility Design Pattern is a behavioral design pattern that allows a request to be passed along a chain of handlers, where each handler either processes the request or passes it along to the next handler in the chain. The request will continue through the chain until it is handled by an appropriate handler or the end of the chain is reached.\nSHOW CODE Java import java.time.LocalDate; import java.time.Period; // Represents a request in our chain of responsibility class LeaveApplication { public enum Type {Sick, PTO, LOP} public enum Status {Pending, Approved, Rejected} private final Type type; private final LocalDate from; private final LocalDate to; private String processedBy; private Status status; public LeaveApplication(Type type, LocalDate from, LocalDate to) { this.type = type; this.from = from; this.to = to; this.status = Status.Pending; } public Type getType() { return type; } public LocalDate getFrom() { return from; } public LocalDate getTo() { return to; } public int getNoOfDays() { return Period.between(from, to).getDays(); } public String getProcessedBy() { return processedBy; } public Status getStatus() { return status; } public void approve(String approvalName) { this.status = Status.Approved; this.processedBy = approvalName; } public void reject(String approvalName) { this.status = Status.Rejected; this.processedBy = approvalName; } public static Builder getBuilder() { return new Builder(); } @Override public String toString() { return type + \" leave for \" + getNoOfDays() + \" day(s) \" + status + \" by \" + processedBy; } // Builder pattern for LeaveApplication public static class Builder { private Type type; private LocalDate from; private LocalDate to; private LeaveApplication application; private Builder() { } public Builder withType(Type type) { this.type = type; return this; } public Builder from(LocalDate from) { this.from = from; return this; } public Builder to(LocalDate to) { this.to = to; return this; } public LeaveApplication build() { this.application = new LeaveApplication(type, from, to); return this.application; } public LeaveApplication getApplication() { return application; } } } // This represents a handler in chain of responsibility interface LeaveApproval { void processLeaveApplication(LeaveApplication application); String getApprovalRole(); } // Abstract handler abstract class Employee implements LeaveApproval { private final String role; private final LeaveApproval successor; public Employee(String role, LeaveApproval successor) { this.role = role; this.successor = successor; } @Override public void processLeaveApplication(LeaveApplication application) { if (!processRequest(application) \u0026\u0026 successor != null) { successor.processLeaveApplication(application); } } protected abstract boolean processRequest(LeaveApplication application); @Override public String getApprovalRole() { return role; } } // A concrete handler: Manager class Manager extends Employee { public Manager(LeaveApproval nextApproval) { super(\"Manager\", nextApproval); } @Override protected boolean processRequest(LeaveApplication application) { switch (application.getType()) { case Sick: application.approve(getApprovalRole()); return true; case PTO: if (application.getNoOfDays() \u003c= 5) { application.approve(getApprovalRole()); return true; } } return false; } } // A concrete handler: ProjectLead class ProjectLead extends Employee { public ProjectLead(LeaveApproval successor) { super(\"Project Lead\", successor); } @Override protected boolean processRequest(LeaveApplication application) { if (application.getType() == LeaveApplication.Type.Sick) { if (application.getNoOfDays() \u003c= 2) { application.approve(getApprovalRole()); return true; } } return false; } } // A concrete handler: Director class Director extends Employee { public Director(LeaveApproval nextApproval) { super(\"Director\", nextApproval); } @Override protected boolean processRequest(LeaveApplication application) { if (application.getType() == LeaveApplication.Type.PTO) { application.approve(getApprovalRole()); return true; } return false; } } // Client class to test the Chain of Responsibility public class Client { public static void main(String[] args) { LeaveApplication application = LeaveApplication.getBuilder() .withType(LeaveApplication.Type.PTO) .from(LocalDate.now()) .to(LocalDate.of(2025, 1, 8)) .build(); System.out.println(application); System.out.println(\"**************************************************\"); LeaveApproval approval = createChain(); approval.processLeaveApplication(application); System.out.println(application); } private static LeaveApproval createChain() { Director director = new Director(null); Manager manager = new Manager(director); ProjectLead lead = new ProjectLead(manager); return lead; } } SHOW OUTPUT Output PTO leave for 8 day(s) Pending by null ************************************************** PTO leave for 8 day(s) Approved by Director --- title: UML Diagram of Chain of Responsibility Design Pattern --- classDiagram class LeaveApproval { +void processLeaveApplication(LeaveApplication) +String getApprovalRole() } class Employee { +String role +LeaveApproval successor +Employee(String, LeaveApproval) +void processLeaveApplication(LeaveApplication) +String getApprovalRole() +protected abstract boolean processRequest(LeaveApplication) } class Manager { +Manager(LeaveApproval) +boolean processRequest(LeaveApplication) } class ProjectLead { +ProjectLead(LeaveApproval) +boolean processRequest(LeaveApplication) } class Director { +Director(LeaveApproval) +boolean processRequest(LeaveApplication) } LeaveApproval \u003c|-- Employee : implements Employee \u003c|-- Manager : extends Employee \u003c|-- ProjectLead : extends Employee \u003c|-- Director : extends Employee *--|\u003e LeaveApproval 4.2 Command The Command Design Pattern is a behavioral design pattern that turns a request into a stand-alone object, allowing the decoupling of the sender of the request from the object that processes the request.\nSHOW CODE Java import java.util.LinkedList; import java.util.List; // Command interface implemented by all concrete command classes interface Command { void execute(); } // Concrete implementation of Command class AddMemberCommand implements Command { private String emailAddress; private String listName; private EWSService receiver; public AddMemberCommand(String email, String listName, EWSService service) { this.emailAddress = email; this.listName = listName; this.receiver = service; } @Override public void execute() { receiver.addMember(emailAddress, listName); } } // Receiver class that performs the actual action class EWSService { // Add a new member to mailing list public void addMember(String contact, String contactGroup) { System.out.println(\"Added \" + contact + \" to \" + contactGroup); } // Remove member from mailing list public void removeMember(String contact, String contactGroup) { System.out.println(\"Removed \" + contact + \" from \" + contactGroup); } } // Invoker class that executes commands on a separate thread class MailTasksRunner implements Runnable { private Thread runner; private List\u0026lt;Command\u0026gt; pendingCommands; private volatile boolean stop; private static final MailTasksRunner RUNNER = new MailTasksRunner(); public static final MailTasksRunner getInstance() { return RUNNER; } private MailTasksRunner() { pendingCommands = new LinkedList\u0026lt;\u0026gt;(); runner = new Thread(this); runner.start(); } // Run method that takes pending commands and executes them @Override public void run() { while (true) { Command cmd = null; synchronized (pendingCommands) { if (pendingCommands.isEmpty()) { try { pendingCommands.wait(); } catch (InterruptedException e) { System.out.println(\"Runner interrupted\"); if (stop) { System.out.println(\"Runner stopping\"); return; } } } cmd = pendingCommands.isEmpty() ? null : pendingCommands.remove(0); } if (cmd == null) { return; } cmd.execute(); } } // Adds a command to the pending commands list for later execution public void addCommand(Command cmd) { synchronized (pendingCommands) { pendingCommands.add(cmd); pendingCommands.notifyAll(); } } // Stops the runner thread public void shutdown() { this.stop = true; this.runner.interrupt(); } } // Client class that demonstrates how the Command pattern works public class Client { public static void main(String[] args) throws InterruptedException { EWSService service = new EWSService(); // Create commands and add them to the runner for execution Command c1 = new AddMemberCommand(\"a@a.com\", \"spam\", service); MailTasksRunner.getInstance().addCommand(c1); Command c2 = new AddMemberCommand(\"b@b\", \"spam\", service); MailTasksRunner.getInstance().addCommand(c2); // Wait for a while to let commands execute Thread.sleep(3000); // Shutdown the runner MailTasksRunner.getInstance().shutdown(); } } --- title: UML Diagram of Command Design Pattern --- classDiagram class Command { +execute() } class AddMemberCommand { -String emailAddress -String listName -EWSService receiver +AddMemberCommand(email: String, listName: String, service: EWSService) +execute() } class EWSService { +addMember(contact: String, contactGroup: String) +removeMember(contact: String, contactGroup: String) } class MailTasksRunner { -Thread runner -List~Command~ pendingCommands -volatile boolean stop -static final MailTasksRunner RUNNER +getInstance(): MailTasksRunner +addCommand(cmd: Command) +shutdown() +run() } class Client { +main(args: String[]) } Command \u003c|-- AddMemberCommand AddMemberCommand --\u003e EWSService : uses MailTasksRunner --\u003e Command : invokes Client --\u003e MailTasksRunner : uses 4.3 Interpreter The Interpreter Design Pattern is a behavioral design pattern used to define a grammatical representation for a language and provide an interpreter to evaluate sentences in that language. It is commonly used to interpret expressions in a simple language or grammar.\nSHOW CODE Java import java.util.ArrayList; import java.util.List; import java.util.Stack; import java.util.StringTokenizer; import java.util.stream.Stream; // User class class User { private List\u0026lt;String\u0026gt; permissions; private String username; public User(String username, String... permissions) { this.username = username; this.permissions = new ArrayList\u0026lt;\u0026gt;(); Stream.of(permissions).forEach(e -\u003e this.permissions.add(e.toLowerCase())); } public List\u0026lt;String\u0026gt; getPermissions() { return permissions; } public String getUsername() { return username; } } // Abstract expression interface PermissionExpression { boolean interpret(User user); } // Terminal expression class Permission implements PermissionExpression { private String permission; public Permission(String permission) { this.permission = permission.toLowerCase(); } @Override public boolean interpret(User user) { return user.getPermissions().contains(permission); } @Override public String toString() { return permission; } } // Non-terminal expression class AndExpression implements PermissionExpression { private PermissionExpression expression1; private PermissionExpression expression2; public AndExpression(PermissionExpression expression1, PermissionExpression expression2) { this.expression1 = expression1; this.expression2 = expression2; } @Override public boolean interpret(User user) { return expression1.interpret(user) \u0026\u0026 expression2.interpret(user); } @Override public String toString() { return expression1 + \" AND \" + expression2; } } // Non-terminal expression class OrExpression implements PermissionExpression { private PermissionExpression expression1; private PermissionExpression expression2; public OrExpression(PermissionExpression one, PermissionExpression two) { this.expression1 = one; this.expression2 = two; } @Override public boolean interpret(User user) { return expression1.interpret(user) || expression2.interpret(user); } @Override public String toString() { return expression1 + \" OR \" + expression2; } } // Non-terminal expression class NotExpression implements PermissionExpression { private PermissionExpression expression; public NotExpression(PermissionExpression expression) { this.expression = expression; } @Override public boolean interpret(User user) { return !expression.interpret(user); } @Override public String toString() { return \"NOT \" + expression; } } // Report class class Report { private String name; private String permission; public Report(String name, String permissions) { this.name = name; this.permission = permissions; } public String getName() { return name; } public String getPermission() { return permission; } } // Parses \u0026 builds abstract syntax tree class ExpressionBuilder { private Stack\u0026lt;PermissionExpression\u0026gt; permissions = new Stack\u0026lt;\u0026gt;(); private Stack\u0026lt;String\u0026gt; operators = new Stack\u0026lt;\u0026gt;(); public PermissionExpression build(Report report) { parse(report.getPermission()); buildExpressions(); if (permissions.size() \u003e 1 || !operators.isEmpty()) { System.out.println(\"ERROR!\"); } return permissions.pop(); } private void parse(String permission) { StringTokenizer tokenizer = new StringTokenizer(permission.toLowerCase()); while (tokenizer.hasMoreTokens()) { String token = tokenizer.nextToken(); switch (token) { case \"and\": operators.push(\"and\"); break; case \"not\": operators.push(\"not\"); break; case \"or\": operators.push(\"or\"); break; default: permissions.push(new Permission(token)); break; } } } private void buildExpressions() { while (!operators.isEmpty()) { String operator = operators.pop(); PermissionExpression perm1; PermissionExpression perm2; PermissionExpression exp; switch (operator) { case \"not\": perm1 = permissions.pop(); exp = new NotExpression(perm1); break; case \"and\": perm1 = permissions.pop(); perm2 = permissions.pop(); exp = new AndExpression(perm1, perm2); break; case \"or\": perm1 = permissions.pop(); perm2 = permissions.pop(); exp = new OrExpression(perm1, perm2); break; default: throw new IllegalArgumentException(\"Unknown operator:\" + operator); } permissions.push(exp); } } } // Client class public class Client { public static void main(String[] args) { Report report1 = new Report(\"Cash flow report\", \"FINANCE_ADMIN OR ADMIN\"); ExpressionBuilder builder = new ExpressionBuilder(); PermissionExpression exp = builder.build(report1); System.out.println(exp); User user1 = new User(\"Dave\", \"USER\"); System.out.println(\"User access report: \" + exp.interpret(user1)); } } --- title: UML Diagram of Interpreter Design Pattern --- classDiagram class PermissionExpression { + interpret(User user): boolean } class Permission { - String permission + Permission(String permission) + interpret(User user): boolean + toString(): String } class AndExpression { - PermissionExpression expression1 - PermissionExpression expression2 + AndExpression(PermissionExpression expression1, PermissionExpression expression2) + interpret(User user): boolean + toString(): String } class OrExpression { - PermissionExpression expression1 - PermissionExpression expression2 + OrExpression(PermissionExpression expression1, PermissionExpression expression2) + interpret(User user): boolean + toString(): String } class NotExpression { - PermissionExpression expression + NotExpression(PermissionExpression expression) + interpret(User user): boolean + toString(): String } class ExpressionBuilder { - Stack~PermissionExpression~ permissions - Stack~String~ operators + build(Report report): PermissionExpression - parse(String permission) - buildExpressions() } class Client { + main(String[] args) } Permission --|\u003e PermissionExpression AndExpression --|\u003e PermissionExpression OrExpression --|\u003e PermissionExpression NotExpression --|\u003e PermissionExpression ExpressionBuilder --\u003e PermissionExpression Client --\u003e ExpressionBuilder 4.4 Mediator 4.5 Iterator 4.6 Momento 4.7 Observer 4.8 State 4.9 Strategy The Strategry Design Pattern is a behavioral design pattern that encapsulates a set of algorithms and allows a client to dynamically choose one at runtime based on the context. This pattern separates the algorithm from the existing code, enabling the addition of new algorithms without modifying the existing code.\nSHOW CODE Java import java.time.LocalDate; import java.util.Collection; import java.util.HashMap; import java.util.Iterator; import java.util.LinkedList; import java.util.Map; // Order class class Order { private final String id; private final LocalDate date; private final Map\u0026lt;String, Double\u0026gt; items = new HashMap\u0026lt;\u0026gt;(); private double total; public Order(String id) { this.id = id; this.date = LocalDate.now(); } public String getId() { return id; } public LocalDate getDate() { return date; } public Map\u0026lt;String, Double\u0026gt; getItems() { return items; } public void addItem(String name, double price) { items.put(name, price); total += price; } public double getTotal() { return total; } public void setTotal(double total) { this.total = total; } } // Strategy Interface interface OrderPrinter { void print(Collection\u0026lt;Order\u0026gt; orders); } // Concrete Strategy 1: Summary Printer class SummaryPrinter implements OrderPrinter { @Override public void print(Collection\u0026lt;Order\u0026gt; orders) { System.out.println(\"*************** Summary Report *************\"); Iterator\u0026lt;Order\u0026gt; iterator = orders.iterator(); double total = 0; for (int i = 1; iterator.hasNext(); i++) { Order order = iterator.next(); System.out.println(i + \". \" + order.getId() + \"\\t\" + order.getDate() + \"\\t\" + order.getItems().size() + \"\\t\" + order.getTotal()); total += order.getTotal(); } System.out.println(\"*******************************************\"); System.out.println(\"\\t\\t\\t\\t Total \" + total); } } // Concrete Strategy 2: Detail Printer class DetailPrinter implements OrderPrinter { @Override public void print(Collection\u0026lt;Order\u0026gt; orders) { System.out.println(\"************* Detail Report ***********\"); Iterator\u0026lt;Order\u0026gt; iter = orders.iterator(); double total = 0; for (int i = 1; iter.hasNext(); i++) { double orderTotal = 0; Order order = iter.next(); System.out.println(i + \". \" + order.getId() + \"\\t\" + order.getDate()); for (Map.Entry\u0026lt;String, Double\u0026gt; entry : order.getItems().entrySet()) { System.out.println(\"\\t\\t\" + entry.getKey() + \"\\t\" + entry.getValue()); orderTotal += entry.getValue(); } System.out.println(\"----------------------------------------\"); System.out.println(\"\\t\\t Total \" + orderTotal); System.out.println(\"----------------------------------------\"); total += orderTotal; } System.out.println(\"----------------------------------------\"); System.out.println(\"\\tGrand Total \" + total); } } // PrintService class for context class PrintService { private final OrderPrinter printer; public PrintService(OrderPrinter printer) { this.printer = printer; } public void printOrders(Collection\u0026lt;Order\u0026gt; orders) { printer.print(orders); } } // Client class to simulate the creation of orders and print them public class Main { private static final LinkedList\u0026lt;Order\u0026gt; orders = new LinkedList\u0026lt;\u0026gt;(); public static void main(String[] args) { createOrders(); // Print all orders using DetailPrinter strategy PrintService service1 = new PrintService(new DetailPrinter()); service1.printOrders(orders); System.out.println(\"\\n\"); // Print all orders using DetailPrinter strategy PrintService service2 = new PrintService(new SummaryPrinter()); service2.printOrders(orders); } private static void createOrders() { Order o = new Order(\"100\"); o.addItem(\"Soda\", 2); o.addItem(\"Chips\", 10); orders.add(o); o = new Order(\"200\"); o.addItem(\"Cake\", 20); o.addItem(\"Cookies\", 5); orders.add(o); o = new Order(\"300\"); o.addItem(\"Burger\", 8); o.addItem(\"Fries\", 5); orders.add(o); } } SHOW OUTPUT Output ************* Detail Report *********** 1. 100\t2024-12-07 Chips\t10.0 Soda\t2.0 ---------------------------------------- Total 12.0 ---------------------------------------- 2. 200\t2024-12-07 Cookies\t5.0 Cake\t20.0 ---------------------------------------- Total 25.0 ---------------------------------------- 3. 300\t2024-12-07 Burger\t8.0 Fries\t5.0 ---------------------------------------- Total 13.0 ---------------------------------------- ---------------------------------------- Grand Total 50.0 *************** Summary Report ************* 1. 100\t2024-12-07\t2\t12.0 2. 200\t2024-12-07\t2\t25.0 3. 300\t2024-12-07\t2\t13.0 ******************************************* Total 50.0 --- title: UML Diagram of Strategy Design Pattern --- classDiagram class Order { +String id +LocalDate date +Map~String, Double~ items +double total +Order(String id) +String getId() +LocalDate getDate() +Map~String, Double~ getItems() +void addItem(String name, double price) +double getTotal() +void setTotal(double total) } class OrderPrinter { +void print(Collection~Order~ orders) } class SummaryPrinter { +void print(Collection~Order~ orders) } class DetailPrinter { +void print(Collection~Order~ orders) } class PrintService { +OrderPrinter printer +PrintService(OrderPrinter printer) +void printOrders(Collection~Order~ orders) } OrderPrinter \u003c|-- SummaryPrinter OrderPrinter \u003c|-- DetailPrinter PrintService *--\u003e OrderPrinter PrintService --\u003e Order 4.10 Template Method 4.11 Visitor 4.12 Null Object ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/design-patterns/1-design-patterns/","summary":"1. Solid Principle 1.1 Single Responsibility Principle A class should have only one reason to change, meaning each class should focus on a single functionality or responsibility.\nSHOW CODE Single Responsibility Principle import java.io.IOException; import java.util.*; import java.util.regex.*; import com.fasterxml.jackson.databind.ObjectMapper; /** * 1. User class is only used to represent entity. * 2. UserValidator class is solely responsible for validating user objects. * 3. Store class is only used to manage user objects storage.","title":"Design Patterns"},{"content":"Introduction to Databases A database is a collection of data that is stored, managed, and accessed electronically. It typically contains one or more tables, which resemble Excel or Google sheets, with data organized into rows and columns. As the number of tables grows, managing the database can become complex, making it essential to design a scalable and maintainable strucutre.\nDatabases can be broadly categorized into two types: Relational database, primarily used for real-time data updates and transactions, and data warehouse, optimized for data analysis and reporting purposes.\nData Modeling Data modeling is the process of creating a conceptual representation of data structures, relationships, and rule to meet business requirements. It serves as a blueprint for designing and managing a database.\nThere are three types of data models: conceptual, logical, and physical. The conceptual data model provides a high-level overview, specifying relationships between objects without technical details. The logical data model refine the conceptual data model by adding more detail, such as fields for each object. The physical data model describe the internal schema of the database, including table structures, storage details, and implementation specifics.\n--- title: Conceptual Data Model --- erDiagram Customer ||--o{ Order : places Order ||--|{ Product : contains --- title: Logical Data Model --- erDiagram Customer { int customerId string name string email } Order { int orderId date orderDate float totalAmount } Product { int productId string productName float price } Customer ||--o{ Order : places Order ||--|{ Product : contains --- title: Physical Data Model --- erDiagram Customer { int customerId PK varchar name varchar email } Order { int orderId PK date orderDate float totalAmount int customerId FK } Product { int productId PK varchar productName decimal price } OrderItem { int orderItemId PK int orderId FK int productId FK int quantity } Customer ||--o{ Order : places Order ||--|{ OrderItem : includes OrderItem ||--|{ Product : contains Example: University Enrollment Management System Entities In database design, an entity is a distinct object that typically represents real-world objects, events, or concepts. Entities are represented as tables in a relational database, and they are similar to classes in object-oriented design. Each row in the table represents an instance of the entity. Each entity has attributes that describe its characteristics. For example, a Student entity may have attributes like student_id, first_name, last_name, and date_of_birth, among others. Entities can be related to one another, and these relationships are often captured using foreign keys or relationship tables, which link entities together based on logical associations. For example, a Student might be linked to a Course through an enrollment relationship.\nIdentifying Entities Identifying entities in database design is a crucial step, as entities form the foundation of a database. A useful approach for identifying entities is to clarify the design objectives and look for nouns in the objective statement. For example, consider the University Enrollment Management System. The objective statement might be:\n\u0026ldquo;The University Enrollment Management System\u0026rdquo; is designed to help a university track enrolled students, the subjects they are taking, and the teachers assigned to those subjects\u0026quot;.\nIn this sentence, the nouns university, student, subject, and teacher are potential entities, as they represent key objects or concepts that the system needs to track.\n--- title: Identifying Entities --- erDiagram UNIVERSITY STUDENT erDiagram TEACHER SUBJECT Defining Attributes In database design, an attribute describes the characteristics of an entity. In a relational database, attributes are typically represented as columns in a table. Defining entity attributes is a crucial step in database design, as it ensures that the entity captures all the necessary details required by the system. When defining attributes, it\u0026rsquo;s important to consider what properties or characteristics the entity possesses.\nFor example, in a University Enrollment Management System, the Student entity might have attributes like first_name, last_name, date_of_birth, and address. After identifying the necessary attributes, the next step is to specify the approapriate data type for each attribute. For instance, attributes like first_name, last_name, and address would typically use the TEXT data type, while the date_of_birth attribute would be defined with the DATE data type.\n--- title: Defining Attributes --- erDiagram UNIVERSITY { string name string address } STUDENT { string first_name string last_name date date_of_birth string address } erDiagram SUBJECT { string subject_name string category string students_enrolled } TEACHER { string first_name string last_name date date_of_birth string address string subject_taught } Normalization Normalization in database design is the process of organizing the attributes of entities and their relationships to reduce data redundency, avoid operational anomalies, and improve data integrity. Normalization involves decomposing a large, complex database into smaller, simpler tables while preserving the relationships between entities. This decomposition follows a set of rules called normal forms. In real-world database design, the three most commonly used normal normal forms are First Normal Form (1NF), Second Normal Form (2NF), and Third Normal Form (3NF).\nFirst Normal Form First Normal Form (1NF) is a property of a relational database table that ensures the table is structured properly. It follows the following conditions:\nEach column must contain atomic values, meaning that the value in a field should be indivisible and not contain sets or lists of values. Each row must be unique, which can be achieved by using a primary key to uniquely identify each record. All values in single column should be of the same data type. A Primary Key is a column (or a set of columns) in a relational database table that uniquely identifies each row in that table. It satisfies the following conditions:\nThe value in the primary key must be unique for each row. The value in the primary key must not be null for any record. The value in the primary key should generally be immutable, meaning it should not change once assigned. When designing tables, assess if any combination of columns can be used to uniquely identify a record. If such a combination exists, those columns can form the primary key. If no suitable combination is found, create a new column to serve as the primary key.\nA primary key can be a set of columns when a single column is not sufficient to uniquely identify a row. For example, in the following table, neither the StudentID nor the CourseID alone can uniquely identify a row, because a student might enroll mutiple courses, and a course can have multiple students. However, the combination of both columns can uniquely identify each enrollment record.\nStudentID CourseID EnrollmentDate 1 CS101 2024-01-01 1 MATH101 2024-01-02 2 CS101 2024-01-03 1NF: Student In the following Student table, there is no single field that can uniquely identify a row. Therefore, it is necessary to add a new field. such as StudentID, to ensure each row has a unique identifier. Additionally, the Address field may contain multiple values, such as unit number, street number, street name, suburb, city, state, country, and postcode. To comply with the First Normal Form (1NF), the Address firld must be divided into multiple separate columns, ensuring that each column contains only atomic values.\n--- title: Violation of 1NF - Student --- erDiagram STUDENT { string first_name string last_name date date_of_birth string address } --- title: Comply with 1NF - Student --- erDiagram STUDENT { number student_id PK string first_name string last_name date date_of_birth number unit_number number street_number string street_name string suburb string city string state string country string postcode } 1NF: Subject --- title: Violation of 1NF - Subject --- erDiagram SUBJECT { string subject_name string category string students_enrolled } --- title: Comply with 1NF - Subject --- erDiagram SUBJECT { number subject_id PK string subject_name string category string students_enrolled } 1NF: Teacher --- title: Violation of 1NF - Teacher --- erDiagram TEACHER { string first_name string last_name date date_of_birth string address string subject_taught } --- title: Comply with 1NF - Teacher --- erDiagram TEACHER { number teacher_id PK string first_name string last_name date date_of_birth number unit_number number street_number string street_name string suburb string city string state string country string postcode string subject_taught } 1NF: University --- title: Violation of 1NF - University --- erDiagram UNIVERSITY { string name string address } --- title: Comply with 1NF - University --- erDiagram UNIVERSITY { number university_id PK string name number unit_number number street_number string street_name string suburb string city string state string country string postcode } Second Normal Form The Second Normal Form (2NF) in database design is a level of normalization that builds upon the First Normal Form (1NF). A table is in 2NF if every non-key attribute is fully functionally dependent on the entire primary key, not just part of it, particularly in tables with composite primary keys (a key made up of two or more columns).\nRelationships Relationship in database design refers to the association between different entities (tables) in a database. It defines how data in one table is related to data in another table, enabling efficient organization and retrival of data. Relationships are established through a foreign key, which is a column in one table that references the primary key of another table. There are four main types of relationships: One-to-One (1:1), One-to-Many (1:N), Many-to-Many (N:M), and Self-Reference.\nIn a One to One relationship, each record in one table is related to exactly one record in another table. For example, consider a Person table and a Passport table, where each person has one unique passport, and each passport is associated with only one person. This type of relationship is relatively rare in real-world database design.\nThe One to Many relationship is the most common type in real-world database design. In a 1:N relationship, one record in a table can be linked to multiple records in another table. For example, in a Department table and an Employee table, one department can have many employees, but each employee blongs to exactly one department. This is a typical relational model for most business applications.\nThe Many-to-Many relationship is common but often requires an intermediary table to properly represent the association. In an N:M relationship, multiple records in one table can be asoociated with multiple records in another table. For instance, in a Student table and a Course table, a student can enroll in many courses, and each course can have many students enrolled. This relationship is typically handled by a joining table, such as Student_Course.\nIn a Self-Referencing relationship, a table is related to itself. In other words, a record in the table is associated with another record in the same table. For example, in an Employee table, each employee has a Manager, and that manager may also have a manager. This type of relationship is useful for representing hierarchical structures, such as organizational charts.\nIn database design, a foreign key is a column that references the primary key of another table. It is used to establish a relationship between two tables, ensuring referential integrity and maintaining consistent data across the database.\n2NF: Subject \u0026amp; Category In the following Subject table, the subject_name is dependent on the primary key subject_id, but the category is not fully dependent on the primary key, which violates 2NF. To resolve this issue, a new Category table should be created with two fields: category_id as the primary key and subject_id as a foreign key. The two tables have a One-to-Many relationship, where each category can have many subjects, while each subject bleongs to exactly one category.\n--- title: Violation of 2NF - Subject --- erDiagram SUBJECT { number subject_id PK string subject_name string category } --- title: Comply with 2NF - Subject --- erDiagram SUBJECT { number subject_id PK string subject_name number category_id FK } CATEGORY { number category_id PK string category_name } CATEGORY ||--|{ SUBJECT : \"\" 2NF: Student \u0026amp; Subject In the following Subject table, the subject_id and students_enrolled create a Many-to-Many relationship. However, relational databases should not represent Many-to-Many relationships directly in s single table. This is because a single table cannot handle multiple instances of related data (such as multiple students enrolled in multiple subjects) within a single field. To resolve this issue, a junction table is introduced. It breaks down the Many-to-Many relationship into two One-to-Many relationships, ensuring data integrity and normalization.\n--- title: Violation of 2NF - Subject --- erDiagram SUBJECT { number subject_id PK string subject_name string students_enrolled } subject_id subject_name students_name 1 Math Alice, Bob, Charlie 2 History David, Emily, Frank, Grace 3 Science Helen, Ian In the above table, the students_enrolled field violates First Normal Form (1NF), which requires each column to contain only atomic values. Additionally, this design leads to data redundancy. For example, if the student Alice enrolls in multiple courses such as Math, History, and Science. her name will be repeated in each row, causing unnecessary duplication of data.\nFurthermore, this design makes data manipulation more complex. For instance, when a student drops a course or a new student enrolls in a course, the list of students in the students_enrolled column must be manually updated, which is error-prone and inefficient.\n--- title: Comply with 2NF - Subject --- erDiagram SUBJECT { number subject_id PK string subject_name } STUDENT { number student_id PK string students_enrolled } ENROLLMENT { number subject_id FK number student_id FK } SUBJECT ||--|{ ENROLLMENT : \"has\" STUDENT ||--|{ ENROLLMENT : \"enrolled in\" Comply with 2NF: Real-World Example 2NF: Teacher --- title: Violation of 2NF - Teacher (subject_taught) --- erDiagram TEACHER { number teacher_id string first_name string last_name date date_of_birth string subject_taught } --- title: Comply with 2NF - Teacher --- erDiagram TEACHER { number teacher_id string first_name string last_name date date_of_birth } SUBJECT { number subject_id PK string subject_name number category_id FK number teacher_id FK } TEACHER ||--|{ SUBJECT : \"teaches\" 2NF: University --- title: Comply with 2NF - UNIVERSITY --- erDiagram UNIVERSITY { number university_id PK string name } SUBJECT { number subject_id PK string subject_name number category_id FK number teacher_id FK number university_id FK } UNIVERSITY ||--|{ SUBJECT : \"\" Third Normal From Third Normal Form (3NF) is a level of normalization that satisfies Second Normal Form (2NF) and eliminates transitive dependencies. In simpler terms, a non-key attribute in a table should not depend on another non-key attrubute. For example, if A $\\rightarrow$ B and B $\\rightarrow$ C, then A $\\rightarrow$ C, which means C should be moved to a separate table to avoid redundency. This process helps reduce data redundency and improves the efficiency of relational databases.\n3NF: Student In the following Student table, the non-key attributes (unit_number, street_number, street_name, suburb, city, state, country, and postcode) are not directly dependent on the primary key student_id; instead, they depend on the student\u0026rsquo;s address. This results in a transitive dependency, which violates 3NF. Furthermore, since multiple students may share the same address, these address attributes will be repeated for each student, leading to data redundency.\n--- title: Violation of 3NF - Student --- erDiagram STUDENT { number student_id PK string first_name string last_name date date_of_birth number unit_number number street_number string street_name string suburb string city string state string country string postcode } --- title: Comply with 3NF - Student --- erDiagram STUDENT { number student_id PK string first_name string last_name date date_of_birth number address_id FK } ADDRESS { number address_id PK number unit_number number street_number string street_name string suburb string city string state string country string postcode } STUDENT ||--|{ ADDRESS : \"\" 3NF: Teacher --- title: Comply with 3NF - Teacher --- erDiagram TEACHER { number teacher_id PK string first_name string last_name date date_of_birth number address_id FK } ADDRESS { number address_id PK number unit_number number street_number string street_name string suburb string city string state string country string postcode } TEACHER ||--|{ ADDRESS : \"\" 3NF: University --- title: Comply with 3NF - University --- erDiagram UNIVERSITY { number university_id PK string name number address_id FK } ADDRESS { number address_id PK number unit_number number street_number string street_name string suburb string city string state string country string postcode } UNIVERSITY ||--|{ ADDRESS : \"\" Design Considerations Determine Data Types \u0026amp; Precision Determining data types and precision in database design is crucial for ensuring optimal storage, performance, and accuracy of data. There are typically three steps to determine the apprpriate data type and precision for a field:\nIdentifying the nature of the field: Determine the type of data the field will store—whether it\u0026rsquo;s numeric, string, or data/time. For example, the student_id field might be of type INT, while the first_time field might of type CHAR or VARCHAR. Choose the smallest sufficient data type: Select the samllest data type that can accommodate the required values. For example, if a field\u0026rsquo;s values range from -128 to 127, use TINYINT instead of INT to optimize performance and storage efficiency. Set precision and scale for numeric values: For numeric fields, it\u0026rsquo;s important to define the precision (total number of digits) and scale (number of digits after the decimal point). For example, a price field should be set to DECIMAL(10,2), which allows for 10 digits in total, with 2 digits after the decimal point. Integrity Constraints Integrity Constraints in database design are rules that ensure the accuracy, consistency, and validity of data. There are several types of integrity constraints, each serving a specific purpose:\nEntity Integrity Entity Integrity ensures that each record in a table is unique and identifiable. This is achieved by setting a column in a table as a primary key. For example, the student_id field must be unique for each record in the Student table.\nCREATE TABLE Student ( student_id INT PRIMARY KEY, first_name VARCHAR(100), last_name VARCHAR(100) ); Referencial Integrity Referencial Integrity ensures that relationships between tables are maintained consistently. Foreign keys enforce this constraint by ensuring that a value in one table corresbonds to a valid value in another table. For example, the student_id field in the Enrollment table serves as a foreign key referencing the primary key student_id in the Student table.\nCREATE TABLE Enrollment ( enrollment_id INT PRIMARY KEY, student_id INT, course_id INT, FOREIGN KEY (student_id) REFERENCES Students(student_id) ); Domain Integrity Domain Integrity ensures that the data entered in a column matches the defined data type, format, and range. This is enforced using data types. default values. and check constraints. For example, the price field should only store positive values.\nCREATE TABLE Product ( product_id INT PRIMARY KEY, product_name VARCHAR(100), price DECIMAL(10, 2) CHECK (price \u0026gt; 0) ); User-Defined Integrity User-defined integrity enforces business rules specific to the application or domain. For instance, in the Enrollment table, the combination of student_id and course_id should be unique to prevent a student from enrolling in the same course more than once.\nCREATE TABLE Enrollment ( enrollment_id INT PRIMARY KEY, student_id INT, course_id INT, UNIQUE (student_id, course_id) ); Null Integrity Null integrity ensures that certain fields cannot store NULL values. This is enforced by defining the column with the NOT NULL constraint. For example, the student_id field in the Student table must not be NULL because it is used to identify each record.\nCREATE TABLE Student ( student_id INT PRIMARY KEY NOT NULL, first_name VARCHAR(100) NOT NULL, last_name VARCHAR(100) NOT NULL ); ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/database/1-database-design/","summary":"Introduction to Databases A database is a collection of data that is stored, managed, and accessed electronically. It typically contains one or more tables, which resemble Excel or Google sheets, with data organized into rows and columns. As the number of tables grows, managing the database can become complex, making it essential to design a scalable and maintainable strucutre.\nDatabases can be broadly categorized into two types: Relational database, primarily used for real-time data updates and transactions, and data warehouse, optimized for data analysis and reporting purposes.","title":"Database Design"},{"content":"Recursion Recursion is a programming technique where a function repeatedly calls itself until it reaches a base case, whcih stops the recursion and allows it to return a result. It is a way of breaking down complex problems into smaller, simpler subproblems that are eaiser to solve.\nHead Recursion Head Recursion is a type of recursion where a function makes its recursive call first, immediately after checking the base case, and performs all other operations only after the recursive call returns.\nSHOW CODE: Head Recursion Head Recursion void printNumbers(int n) { if (n == 0) { return; // Base case } printNumbers(n - 1); // Recursive call printf(\"%d\\n\", n); // Processing after recursion } Call Stack Operation Current Value of n headRecursion(3) Call function 3 headRecursion(2) Call function 2 headRecursion(1) Call function 1 headRecursion(0) Base case, exit 0 Unwinding begins: printf(1) Print 1 1 printf(2) Print 2 2 printf(3) Print 3 3 Tail Recursion Tail Recursion is a type of recursion where a function makes its recursive call as the last operation in its body. with no further operations after the call. This type of recursion can be optimized by the compiler into an iterative loop through tail call optimization (TCO), which help reduce memory consumption by the reusing the stack frame.\nSHOW CODE: Tail Recursion Tail Recursion void tailRecursion(int n) { if (n \u003e 0) { printf(\"%d \", n); // Operation first tailRecursion(n - 1); // Recursive call at the end } } Call Stack Operation Current Value of n tailRecursion(3) Print 3 3 tailRecursion(2) Print 2 2 tailRecursion(1) Print 1 1 tailRecursion(0) Base case, exit 0 Tail recursion is generally perfered for performance when recursion depth is large because it can be optimized into an iterative process.\nSHOW CODE: Tail Recursion Optimization Tail Recursion Optimization void tailRecursionOptimized(int n) { while (n \u003e 0) { printf(\"%d \", n); // Operation first n--; // Decrement n, same as `tailRecursion(n - 1)` } } In the above code, optimized Loop replaces recursion with a loop, ensuring only a single stack frame is used.\nConditions for Tail Recursion: The recursive call must be the last operation in the function, and its result must be immediately returned without any further computation after the call.\nSHOW CODE: Tail Recursive Function Tail Recursive Function // Tail recursive function to calculate factorial int factorialTailRecursion(int n, int accumulator) { if (n == 0) { return accumulator; // Base case: return accumulated result } return factorialTailRecursion(n - 1, accumulator * n); // Recursive call is the last operation } SHOW CODE: Non-tail Recursive Function Non-tail recursive // Non-tail recursive function to calculate factorial int factorialNonTailRecursion(int n) { if (n == 0) { return 1; // Base case } return n * factorialNonTailRecursion(n - 1); // Recursive call is not the last operation } Tree Recursion Tree recursion is a type of recursion in which a function makes multiple recursive calls to itself in its body, it creates a tree-like data structure, as each call can branch into multiple additional calls.\nSHOW CODE C public int fib(int n) { if (n \u003c= 1) { return n; } return fib(n - 1) + fib(n - 2); } Recursion Tree Analysis:\n--- title: Recursion Tree Analysis - fibonacci sequence --- graph TD L0((\"fib\\(5\\)\")) --\u003e L1((\"fib\\(4\\)\")) L0 --\u003e L2((\"fib\\(3\\)\")) L1 --\u003e L3((\"fib\\(3\\)\")) L1 --\u003e L4((\"fib\\(2\\)\")) L2 --\u003e L5((\"fib\\(2\\)\")) L2 --\u003e L6((\"fib\\(1\\)\")) L3 --\u003e L7((\"fib\\(2\\)\")) L3 --\u003e L8((\"fib\\(1\\)\")) L4 --\u003e L9((\"fib\\(1\\)\")) L4 --\u003e L10((\"fib\\(0\\)\")) L5 --\u003e L11((\"fib\\(1\\)\")) L5 --\u003e L12((\"fib\\(0\\)\")) L7 --\u003e L13((\"fib\\(1\\)\")) L7 --\u003e L14((\"fib\\(0\\)\")) Array An array is a data structure that stores a collection of elements of the same type in a fixed-size, continguous block of memory. Arrays can be categorized into two types: static arrays and dynamic arrays.\nA static array has a fixed size that cannot be changed after its declaration. Memory for a static array is allocated at compile time, and its size must be explicitly specified.\nIn contrast, a dynamic array allows its size to be adjusted during runtime, enabling it to grow or shrink as needed. Unlike static arrays, the size of a dynamic array does not need to be specified at the time of declaration, and memory is allocated dynamically from the heap.\nImplementation of Static Arrays Implementation of Dynamic Arrays Compiler\u0026rsquo;s Memory Layout for Arrays The address of an array element is determined at runtime. Array elements are stored in a continguous block of memory, and the compiler calculates each element\u0026rsquo;s address using its index and the size of each element.\n1-Dimentional Array Element Access Formula (0-based index): $\\text{Addr}_{A[i]} = B + i \\times W$\nB: Base Address i: Zero-based Index of Each Element W: Size of Each Element SHOW CODE C #include \u0026lt;stdio.h\u0026gt; int main() { int arr[5] = {10, 20, 30, 40, 50}; for (int i = 0; i \u003c 5; i++) { void *addr_i = (void *) arr + (i * sizeof(int)); printf(\"Element at index %d: %d \\t Address: %p\\n\", i, arr[i], addr_i); } return 0; } SHOW OUTPUT Output Element at index 0: 10 Address: 0x7ff7bb0b7170 Element at index 1: 20 Address: 0x7ff7bb0b7174 Element at index 2: 30 Address: 0x7ff7bb0b7178 Element at index 3: 40 Address: 0x7ff7bb0b717c Element at index 4: 50 Address: 0x7ff7bb0b7180 2-Dimentional Array Element Access Formula (Row Major Order): $\\text{Addr}_{A[i][j]} = \\text{B} + [(i \\times \\text{C}) + j] \\times \\text{W}$\nB: Base Address i: Zero-based Row Index of Each Element j: Zero-based Column Index of Each ELement C: Number of Columns W: Size of Each Element SHOW CODE C #include \u0026lt;stdio.h\u0026gt; int main() { int arr[2][3] = {{1, 2, 3}, {4, 5, 6}}; for (int i = 0; i \u003c 2; i++) { for (int j = 0; j \u003c 3; j++) { void *addr_ij = (void *) \u0026arr + (i * 3 + j) * sizeof(int); printf(\"Element at [%d][%d]: %d, Address: %p\\n\", i, j, arr[i][j], addr_ij); } } return 0; } SHOW OUTPUT Output Element at [0][0]: 1, Address: 0x7ff7b2c64170 Element at [0][1]: 2, Address: 0x7ff7b2c64174 Element at [0][2]: 3, Address: 0x7ff7b2c64178 Element at [1][0]: 4, Address: 0x7ff7b2c6417c Element at [1][1]: 5, Address: 0x7ff7b2c64180 Element at [1][2]: 6, Address: 0x7ff7b2c64184 Why do most compilers use 0-based indexing? Take a 1-dimentional array as an example, the element access formula for a 0-based index is $\\text{Addr}_{A[i]} = B + i \\times W$. This formula requires two operations (multiplication and addition) to access each element in the array.\nIn contract, the formula for 1-based indexing is $\\text{Addr}_{A[i]} = B + (i - 1) \\times W$. This requires three operations (multiplication. subtraction, and addition). Compared to 0-based indexing, 1-based indexing introduces one additional operation, which becomes a significant overhead when dealing with large size arrays.\nString Matrix Linked List Stack Queue A Queue is a linear data structure that follows the First In, First Out (FIFO) principle, meaning elements are added to the back and removed from the front. There are four main types of queues: Simple Queue, Circular Queue, Double-Ended Queue (Deque), and Priority Queue.\nSimple Queue A Simple Queue is a basic type of queue data structure in which elements are added to the back and removed from the front, following the First In, First Out (FIFO) principle.\nImplementation of Simple Queue Array with a single pointer SHOW CODE Java class SimpleQueue { private final int[] queue; private final int capacity; private int rear; public SimpleQueue(int capacity) { this.queue = new int[capacity]; this.capacity = capacity; this.rear = -1; } public boolean isEmpty() { return rear == -1; } private boolean isFull() { return rear == capacity - 1; } public int size() { return rear + 1; } public void enqueue(int element) { if (this.isFull()) { System.out.println(\"Queue is full.\"); } else { rear++; queue[rear] = element; } } public int dequeue() { if (this.isEmpty()) { System.out.println(\"Queue is empty.\"); return -1; } int frontElement = queue[0]; // Shift all elements to the left for (int i = 0; i \u003c rear; i++) { queue[i] = queue[i + 1]; } rear--; return frontElement; } public int peek() { if (this.isEmpty()) { System.out.println(\"Queue is empty.\"); return -1; } return queue[0]; } } public class Main { public static void main(String[] args) { SimpleQueue queue = new SimpleQueue(5); queue.enqueue(10); queue.enqueue(20); queue.enqueue(30); System.out.println(\"Front element: \" + queue.peek()); // Expected: 10 System.out.println(\"Dequeued: \" + queue.dequeue()); // Expected: 10 queue.enqueue(40); queue.enqueue(50); System.out.println(\"Queue size: \" + queue.size()); // Expected: 4 System.out.println(\"Dequeued: \" + queue.dequeue()); // Expected: 20 } } The implementation of a queue using an array with a single pointer (rear) is inefficient for deletion because the remaining elements need to be shifted left after every dequeue operation.\nArray with two pointers SHOW CODE Java class SimpleQueue { private final int[] queue; private final int capacity; private int front; private int rear; public SimpleQueue(int capacity) { this.capacity = capacity; queue = new int[capacity]; this.front = -1; this.rear = -1; } public boolean isEmpty() { return front == -1; } private boolean isFull() { return rear + 1 == capacity; } public int size() { if (this.isEmpty()) { return 0; } return rear - front + 1; } public void enqueue(int element) { if (this.isFull()) { System.out.println(\"Queue is full.\"); } else { // Set front to 0 when the first element is added if (front == -1) { front = 0; } rear++; queue[rear] = element; } } public int dequeue() { if (this.isEmpty()) { System.out.println(\"Queue is empty.\"); return -1; } else { int frontElement = queue[front]; // Reset both pointers to -1 when the queue has only one element if (front == rear) { front = -1; rear = -1; } else { // Move front to the next element front++; } return frontElement; } } public int peek() { if (this.isEmpty()) { System.out.println(\"Queue is empty.\"); return -1; } else { return queue[front]; } } } public class Main { public static void main(String[] args) { SimpleQueue queue = new SimpleQueue(5); queue.enqueue(10); queue.enqueue(20); queue.enqueue(30); System.out.println(\"Front element: \" + queue.peek()); // Expected: 10 System.out.println(\"Dequeued: \" + queue.dequeue()); // Expected: 10 queue.enqueue(40); queue.enqueue(50); System.out.println(\"Queue size: \" + queue.size()); // Expected: 3 System.out.println(\"Dequeued: \" + queue.dequeue()); // Expected: 20 } } Implementing a queue using an array with two pointers (front and rear) is more efficient for deletion compared to using a single pointer (rear), as it eliminates the need to shift elements to the left after each dequeue operation. However, this approach has drawback: the space in front of the front pointer cannot be reused until the array is empty, leading to potential wasted memory.\nLinked List with a pointer SHOW CODE Java class Node { int data; Node next; public Node(int data) { this.data = data; this.next = null; } } class SimpleQueue { private Node front; private int size; public SimpleQueue() { front = null; size = 0; } // Check if the queue is empty public boolean isEmpty() { return size == 0; } // Get the current size of the queue public int size() { return size; } // Display the elements of the queue public void display() { if (isEmpty()) { System.out.println(\"Queue is empty.\"); return; } // Traverse through the queue and print its elements Node temp = front; // Use StringBuilder to efficiently build the string StringBuilder builder = new StringBuilder(); while (temp != null) { builder.append(temp.data).append(\"\u003c-\"); temp = temp.next; } // Remove the last \"\u003c-\" (extra arrow at the end) builder.setLength(builder.length() - 2); System.out.println(builder); } // Add an element to the rear (end) of the queue public void enqueue(int data) { Node node = new Node(data); // If the queue is empty, the new node becomes the front of the queue if (isEmpty()) { front = node; } else { Node temp = front; // Traverse the list to find the last node (rear of the queue) while (temp.next != null) { temp = temp.next; } temp.next = node; // Link the new node at the end of the queue } size++; // Increment the size of the queue } // Remove and return the element from the front of the queue public int dequeue() { if (isEmpty()) { throw new IllegalStateException(\"Queue is empty.\"); } int dequeued = front.data; front = front.next; size--; return dequeued; } // Return the element from the front of the queue without removing it public int peek() { if (isEmpty()) { throw new IllegalStateException(\"Queue is empty.\"); } return front.data; } } public class Main { public static void main(String[] args) { SimpleQueue queue = new SimpleQueue(); // Enqueue some elements into the queue queue.enqueue(10); queue.enqueue(20); queue.enqueue(30); queue.enqueue(40); System.out.println(\"Queue after enqueuing elements:\"); queue.display(); // Display the current state of the queue // Dequeue two elements and print them System.out.println(\"Dequeued: \" + queue.dequeue()); System.out.println(\"Dequeued: \" + queue.dequeue()); System.out.println(\"Queue after dequeuing elements:\"); queue.display(); // Display the queue after dequeuing elements // Peek at the front element without removing it System.out.println(\"Peek front: \" + queue.peek()); // Print the current size of the queue System.out.println(\"Queue size: \" + queue.size()); } } Linked List with two pointers SHOW CODE Java // Node class representing each element in the queue class Node { int data; Node next; public Node(int data) { this.data = data; this.next = null; } } // SimpleQueue class implementing queue operations using a linked list class SimpleQueue { private Node front; private Node rear; private int size; // Constructor to initialize the queue public SimpleQueue() { front = rear = null; size = 0; } // Check if the queue is empty public boolean isEmpty() { return size == 0; } // Get the size of the queue public int size() { return size; } // Display the elements in the queue public void display() { if (isEmpty()) { System.out.println(\"Queue is empty.\"); return; } // Build a string representation of the queue StringBuilder builder = new StringBuilder(); Node temp = front; while (temp != null) { builder.append(temp.data).append(\"\u003c-\"); temp = temp.next; } // Remove the trailing \" \u003c- \" builder.setLength(builder.length() - 2); System.out.println(builder); } // Enqueue: Add an element to the rear of the queue public void enqueue(int data) { Node newNode = new Node(data); // If the queue is empty, both front and rear point to the new node if (isEmpty()) { front = rear = newNode; } else { // Add new node at the end and update the rear pointer rear.next = newNode; rear = newNode; } size++; } // Dequeue: Remove and return the element from the front of the queue public int dequeue() { if (isEmpty()) { throw new IllegalStateException(\"Queue is empty.\"); } // Get the front element and update the front pointer int dequeuedData = front.data; front = front.next; // If the queue becomes empty, reset the rear to null if (front == null) { rear = null; } size--; return dequeuedData; } // Peek: Get the front element without removing it public int peek() { if (isEmpty()) { throw new IllegalStateException(\"Queue is empty.\"); } return front.data; } } // Main class to test the queue implementation public class Main { public static void main(String[] args) { SimpleQueue queue = new SimpleQueue(); // Enqueue elements into the queue queue.enqueue(10); queue.enqueue(20); queue.enqueue(30); queue.enqueue(40); // Display the queue after enqueuing elements System.out.println(\"Queue after enqueuing elements:\"); queue.display(); // Dequeue elements from the queue System.out.println(\"Dequeued: \" + queue.dequeue()); System.out.println(\"Dequeued: \" + queue.dequeue()); // Display the queue after dequeuing elements System.out.println(\"Queue after dequeuing elements:\"); queue.display(); // Peek the front element and show the queue size System.out.println(\"Peek front: \" + queue.peek()); System.out.println(\"Queue size: \" + queue.size()); } } Circular Queue A Circular Queue is a variation of the standard queue data structure that reuses the space freed by dequeue operations by connecting the last position back to the front position. It overcomes the limitation of a simple fixed-size queue, where the space at the front of the queue cannot be reused after dequeueing elements.\nArray Implementation SHOW CODE Java class CircularQueue { private final int[] queue; private int front; private int rear; private final int capacity; private int size; public CircularQueue(int capacity) { this.capacity = capacity; queue = new int[capacity]; front = rear = -1; // Initialize both front and rear as -1 to indicate the queue is empty size = 0; } // Check if the queue is empty public boolean isEmpty() { return size == 0; } // Check is the queue is full public boolean isFull() { return size == capacity; } // Get the current size of the queue public int size() { return size; } // Display the elements of the queue public void display() { if (isEmpty()) { System.out.println(\"Queue is empty.\"); return; } StringBuilder builder = new StringBuilder(); for (int i = 0; i \u003c size; i++) { builder.append(queue[(front + i) % capacity]); if (i != size - 1) { builder.append(\"\u003c-\"); } } System.out.println(builder); } public void enqueue(int data) { if (isFull()) { throw new IllegalStateException(\"Queue is full.\"); } if (isEmpty()) { front = 0; } // Move the rear pointer in a circular manner rear = (rear + 1) % capacity; // Add the data to the rear of the queue queue[rear] = data; // Increase the size size++; } public int dequeue() { if (isEmpty()) { throw new IllegalStateException(\"Queue is empty.\"); } int dequeued = queue[front]; if (front == rear) { // If the queue become empty, reset both front and rear to -1 front = rear = -1; } else { // Move the front pointer in a circular manner front = (front + 1) % capacity; } size--; // Decrease the size return dequeued; } public int peek() { if (isEmpty()) { throw new IllegalStateException(\"Queue is empty.\"); } return queue[front]; } } public class Main { public static void main(String[] args) { CircularQueue queue = new CircularQueue(5); queue.enqueue(10); queue.enqueue(20); queue.enqueue(30); queue.enqueue(40); queue.enqueue(50); System.out.println(\"Queue after enqueuing 5 elements:\"); queue.display(); // Attempt to enqueue an element to a full queue (throws exception) try { queue.enqueue(60); } catch (IllegalStateException e) { System.out.println(e.getMessage()); } // Dequeue two elements System.out.println(\"Dequeued: \" + queue.dequeue()); System.out.println(\"Dequeued: \" + queue.dequeue()); System.out.println(\"Queue after dequeuing 2 elements:\"); queue.display(); // Enqueue two more elements queue.enqueue(60); queue.enqueue(70); System.out.println(\"Queue after enqueuing 2 more elements:\"); queue.display(); // Peek at the front element System.out.println(\"Front element: \" + queue.peek()); // Display the current size of the queue System.out.println(\"Queue size: \" + queue.size()); } } Linked List Implementation SHOW CODE Java class Node { int data; Node next; public Node(int data) { this.data = data; this.next = null; } } class CircularQueue { private Node front; private Node rear; private int size; public CircularQueue() { front = rear = null; size = 0; } // Check if the queue is empty public boolean isEmpty() { return size == 0; } // Get the size of the queue public int size() { return size; } // Display the elements of the queue public void display() { if (isEmpty()) { System.out.println(\"Queue is empty.\"); return; } Node temp = front; StringBuilder builder = new StringBuilder(); do { builder.append(temp.data).append(\"\u003c-\"); temp = temp.next; } while (temp != front); // Loop until reach the front newNode again builder.setLength(builder.length() - 2); System.out.println(builder); } // Add an element to the queue public void enqueue(int data) { Node newNode = new Node(data); // Both front and rear will point to the new node if queue is empty if (isEmpty()) { front = rear = newNode; } else { rear.next = newNode; // Connect the current rear to the new node rear = newNode; // Move the rear to the new node } rear.next = front; // Connect the rear's next to the front size++; } // Remove the front element in the queue public int dequeue() { if (isEmpty()) { throw new IllegalStateException(\"Queue is empty\"); } int dequeued = front.data; // Set both front and rear to null if there is only one element if (front == rear) { front = rear = null; } else { front = front.next; // Move the front node to the next rear.next = front; // Maintain the circular link } size--; return dequeued; } // Get the front element without removing it public int peek() { if (isEmpty()) { throw new IllegalStateException(\"Queue is empty.\"); } return front.data; } } public class Main { public static void main(String[] args) { CircularQueue queue = new CircularQueue(); // Enqueue elements queue.enqueue(10); queue.enqueue(20); queue.enqueue(30); queue.enqueue(40); // Display queue elements System.out.println(\"Queue after enqueuing elements:\"); queue.display(); // Dequeue elements System.out.println(\"Dequeued: \" + queue.dequeue()); System.out.println(\"Dequeued: \" + queue.dequeue()); // Display queue elements after dequeueing System.out.println(\"Queue after dequeuing elements:\"); queue.display(); // Peek front element System.out.println(\"Peek front: \" + queue.peek()); // Display the size of the queue System.out.println(\"Queue size: \" + queue.size()); } } Double Ended Queue Priority Queue Tree Graph A graph is a fundamental data structure used to represent the connections or relationships between entities. It consists of vertices (also called node) and edges (also called arcs). A vertex represents a single entity in the graph, while an edge represents a connection or relationship between two vertices. Edges may have additional properties, such as weight (to indicate the cost or distance of the connection) or direction (to indicate the direction of the relationship).\nTypes of Graph Undirected Graph vs. Directed Graph In an undirected graph, the connection between two vertices is bidrectional. For example, if there is an edge between vertex A and vertex B, traversal is possible from A to B and from B to A. In contrast, in a directed graph, the relationships are one-way. For instance, if there is an edge from vertex A to vertex B, traversal is possible from A to B, but not from B to A unless there is a separate edge in the opposite direction.\nUnweighted Graph vs. Weighted Graph In an unweighted graph, the relationships between vertices have no additional properties, and all edges are treated equally. In contrast, a weighted graph assigns a weight to each node, which can represent attributes such as distance, time, cost, eetc. The weight provides more information about the connection between vertices and is often used in problems like shortest path or network flow.\nCyclic Graph vs. Acyclic Graph A cyclic graph contains at least one cycle, which is a path that starts and ends at the same vertex. In contrast, an acyclic graph doest not contain any cycles. A special case of an acyclic graph is the directed acyclic graph (DAG), which has directed edges and no cycles.\nConnected Graph vs. Disconnected Graph A connected graph is a graph in which there is a path between every pair of vertices. In contrast, a disconnected graph is a graph where at least one pair of vertices is not connected by any path.\nGraph Terminology The degree of a vertex is the number of edges incident to that vertex. In an undirected graph, the degree is simply the number of edges connected to the vertex. In a directed graph, the degree is the sum of the in-degree (number of incoming edges) and the out-degree (number of outgoing edges) of the vertex.\nA path is a sequence of vertices where each consecutive pair of vertices is connected by an edge.\nA cycle is a path that starts and ends at the same vertex, with no repeated vertices except for the starting or ending vertex. For example, in a cycle with $A \\rightarrow B \\rightarrow C \\rightarrow D \\rightarrow A$, the path starts and ends at the same vertex $A$, but each of the other vertices $(B, C, and D)$ is visited exactly once.\nConnectivity refers to whether there exists a path between any pair of vertices in the graph.\nA subgraph is a graph formd by a subset of the vertices and edges of the original graph.\nA component is a subgraph where there is a path between every pair of vertices in that subgraph.\nGraph Representation Adjacency Matrix An Adjacency Matrix ia a 2-dimentional array where each element at position [i][j] represents an edge between vertex i and j. In a weighted graph, the value at position [i][j] stores the weight of the edge between the two vertices. In an unweight graph, the value at position [i][j] typically stores 1 to indicate an edge exists between the vertices, and 0 to indicate no edge exists. The space complexity of an adjacency matrix is $O(V^2)$, where $V$ is the number of vertices, as it requires a matrix of size $V \\times V$ to represent the graph.\nAdjacency List An Adjacency List is a collection of lists, where each position i stores a list of nerighbors of vertex i. In a weighted graph. each element in the list typically represents a pair (neighbor, weight), where neighbor is a vertex connected to i, and weight is the weight of the edge between i and neighbor. The space complexity of an adjacency list is $O(V + E)$, where $V$ is the number of vertices and $E$ is the number of edges. This is because each vertex has a list of neighbors, and the total number of entries in all lists is proportional to the number of edges.\nEdge List An Edge List is a collection of pairs, where each pair (i, j) represents an edge between vertex i and vertex j. In a weighted graph. each element may also include the weight of the edge. typically represented as (i, j, weight). The space complexity of an edge list is $O(E)$, where $E$ is the number of edges, as each edge is stored as a separate entry in the list.\nGraph Traversal Breadth First Search Breadth-First Search (BFS) explores all the neighbors of a vertex before moving on to their neighbors. It proceeds level by level, ensuring that all vertices at a given distance from the starting vertex are visited before moving on to vertices at a greater distance. BFS is commonly used to find the shortest path in an unweighted graph.\nDepth First Search Depth-First Search (DFS) explores as far as possible alone a branch of the graph before backtracking to explore other branches. It follows a path from the starting vertex to a dead end, then retrace its steps and explores alternative paths. DFS is useful for finding all paths between vertices, detecting cycles, or performing topological sorting in directed acyclic graphs (DAGs).\nSpanning Tree A spanning tree is a subset of a graph that includes all the vertices and contains exactly $V - 1$ edges, where $V$ is the number of vertices in the graph. A connected graph can have multiple spanning trees, whereas a disconnected graph does not have a spanning tree because there is at least one pair of vertices that are not connected, making it impossible to form a tree that spans all the vertices.\nMinimum Spanning Tree (MST) A minimum spanning tree is a type of spanning tree that connects all the vertices of a graph with the smallest possible total edge weight, compared to all other possible spanning trees.\nPrim\u0026rsquo;s Algorithm Prim\u0026rsquo;s Algorithm is used to find the minimum spanning tree (MST) that connects all the vertices of a graph without forming a cycle, while minimizing the total edge weight. This algorithm is efficient for solving problems related to undirected, weighted graphs. The algorithm steps are as follows:\nInitialize an inMST array to track the vertices included in the MST, and a priority queue (min-heap) to process the edges with the smallest weight. Select an arbitrary starting vertex. Add all edges connected to this vertex into the priority queue and mark the vertex as included in the inMST array. Extract the edge with the minimum weight from the priority queue. If the destination vertex of this edge is not yet in the inMST array, include it, and add all edges connected to this newly included vertex (whose destination is not in the MST) to the priority queue. Repeat step 3 until all vertices are included in the MST. SHOW CODE Java import java.util.*; /** * @author Signal Yu * @since 2024-12-1 */ class Edge implements Comparable\u0026lt;Edge\u0026gt; { int src; int dest; int weight; public Edge(int src, int dest, int weight) { this.src = src; this.dest = dest; this.weight = weight; } @Override public int compareTo(Edge other) { // Sort edges based on weight return this.weight - other.weight; } } class Graph { int vertices; int edges; List\u0026lt;List\u0026gt;Edge\u0026gt;\u0026gt; adjacencyList; public Graph(int vertices) { this.vertices = vertices; adjacencyList = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c vertices; i++) { adjacencyList.add(new ArrayList\u0026lt;\u0026gt;()); } } void addEdge(int src, int dest, int weight) { // Add edge for undirected graph Edge edge1 = new Edge(src, dest, weight); Edge edge2 = new Edge(dest, src, weight); adjacencyList.get(src).add(edge1); adjacencyList.get(dest).add(edge2); } void primMST() { // Step 1: Initialize an `inMST` array to track the vertices // included in the MST, and a priority queue (min-heap) to // process the edges with the smallest weight. boolean[] inMST = new boolean[vertices]; Queue priorityQ = new PriorityQueue\u003c\u003e(); // Step 2: Select an arbitrary starting vertex. Add all edges // connected to this vertex into the priority queue and mark // the vertex as included in the `inMST` array. int start = 0; for (Edge edge : adjacencyList.get(start)) { priorityQ.offer(edge); } inMST[start] = true; // Step 4: Repeat step 3 until all vertices are included in the MST. while (!priorityQ.isEmpty()) { // Step 3: Extract the edge with the minimum weight from the // priority queue. If the destination vertex of this edge is // not yet in the `inMST` array, include it, and add all edges // connected to this newly included vertex (whose destination // is not in the MST) to the priority queue. Edge edge = priorityQ.poll(); int u = edge.src, v = edge.dest; if (!inMST[v]) { System.out.println(u + \"---[\" + edge.weight + \"]---\" + v); inMST[v] = true; // Add all edges from the newly included vertex (whose destination // is not included in `inMST`) to the priority queue for (Edge nextEdge : adjacencyList.get(v)) { if (!inMST[nextEdge.dest]) { priorityQ.offer(nextEdge); } } } } } } public class Solution { public static void main(String[] args) { int vertices = 4; // Number of vertices in the graph Graph graph = new Graph(vertices); // Create a graph with specified vertices // Add edges to the graph graph.addEdge(0, 1, 10); graph.addEdge(0, 2, 6); graph.addEdge(0, 3, 5); graph.addEdge(1, 3, 15); graph.addEdge(2, 3, 4); // Run Prim's algorithm to construct MST graph.primMST(); } } Sorting Quick Sort The quick sort algorithm follows the divide and conquer paradigm. It selects an element from the array as a pivot and recursively partitions the array into two subarrays based on whether the elements are less than or greater than the pivot. The main steps of the quick sort algorithm generally include: picking a pivot, partitioning, recursively partitioning, and handling the base case.\nPicking a pivot: Select an element from the array to act as the pivot. A common choice is the last element. Partitioning: Rearrange the array such that: All elements smaller than the pivot are placed to its left. All elements greater than or equal to the pivot are placed to its right. Place the pivot in its correct position within the sorted array. Recursively partitioning: Recursively apply the partitioning process to the subarrays created by spliting the array around the pivot. Base case: The subarrays are considered sorted when they contain one or zero elements. SHOW CODE Java class QuickSort { public int[] sortArray(int[] nums) { quickSort(nums, 0, nums.length - 1); return nums; } private void quickSort(int[] nums, int low, int high) { if (low \u003c high) { // int pivot = nums[high]; // Runtime Error: StackOverflowError int pivot = nums[low]; int i = low - 1, j = high + 1; while (i \u003c j) { // Find the element that greater than the pivot while (nums[++i] \u003c pivot) { } // Find the element that less than the pivot while (nums[--j] \u003e pivot) { } if (i \u003c j) { swap(nums, i, j); } } quickSort(nums, low, j); quickSort(nums, j + 1, high); } } private static void swap(int[] nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } } https://www.youtube.com/watch?v=8pL_iAEm0bM 912. Sort an Array SHOW PROBLEM Problem:\nGiven an array of integers nums, sort the array in ascending order and return it.\nYou must solve the problem without using any built-in sorting functions, and the solution must have a time complexity of O(n log n) and the smallest possible space complexity.\nExample 1:\nInput: nums = [5,2,3,1] Output: [1,2,3,5] Explanation: After sorting the array, the positions of some numbers remain unchanged (for example, 2 and 3), while the positions of other numbers are rearranged (for example, 1 and 5). Example 2:\nInput: nums = [5,1,1,2,0,0] Output: [0,0,1,1,2,5] Explanation: The array may contain duplicate values. Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 50,000 -50,000 \u0026lt;= nums[i] \u0026lt;= 50,000 Go to Leetcode 🔗 SHOW CODE Time Limited Expectation Passed class Solution { public int[] sortArray(int[] nums) { // quicksort(nums, 0, nums.length - 1); Arrays.sort(nums); return nums; } private static int partition(int[] nums, int low, int high) { // Select the rightmost element as the pivot int pivot = nums[high]; int i = low - 1; // pointer for the smaller element for (int j = low; j \u003c high; j++) { // If current element is smaller than or equal to the pivot if (nums[j] \u003c= pivot) { i++; swap(nums, i, j); } } // Place the pivot in its correct position swap(nums, i + 1, high); // Return the partition index return i + 1; } private static void swap(int[] nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } private static void quicksort(int[] nums, int low, int high) { if (low \u003c high) { int partitionIndex = partition(nums, low, high); // Recursive sort the left and right subarrays quicksort(nums, low, partitionIndex - 1); quicksort(nums, partitionIndex + 1, high); } } } class Solution { public int[] sortArray(int[] nums) { quickSort(nums, 0, nums.length - 1); return nums; } private void quickSort(int[] nums, int low, int high) { if (low \u003c high) { // int pivot = nums[high]; // Runtime Error: StackOverflowError int pivot = nums[low]; int i = low - 1, j = high + 1; while (i \u003c j) { // Find the element that greater than the pivot while (nums[++i] \u003c pivot) { } // Find the element that less than the pivot while (nums[--j] \u003e pivot) { } if (i \u003c j) { swap(nums, i, j); } } quickSort(nums, low, j); quickSort(nums, j + 1, high); } } private static void swap(int[] nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } } ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/1-data-structure-and-algorithms/","summary":"Recursion Recursion is a programming technique where a function repeatedly calls itself until it reaches a base case, whcih stops the recursion and allows it to return a result. It is a way of breaking down complex problems into smaller, simpler subproblems that are eaiser to solve.\nHead Recursion Head Recursion is a type of recursion where a function makes its recursive call first, immediately after checking the base case, and performs all other operations only after the recursive call returns.","title":"Data Structure \u0026 Algorithms"},{"content":"JUnit assertEquals In JUnit, assertEquals is a method used to check if the expected value and the actual value are equal in unit tests.\nSHOW CODE Java import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class UnitTest { @Test void addition() { Calculator calculator = new Calculator(); int result = calculator.add(1, 1); assertEquals(2, result, \"The result of 1 + 1 should be 2\"); } } assertTure \u0026amp; assertFalse In JUnit, the assertTrue and the assertFalse methods are used to validate boolean expressions in unit tests.\nSHOW CODE Java import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertTrue; public class UnitTest { @Test void testIsOdd() { int n = 5; assertTrue(n % 2 == 1, \"Number should be an odd\"); assertFalse(n % 2 == 0, \"Number should not be an even\"); } } @BeforeEach \u0026amp; @AfterEach In JUnit, the @BeforeEach and @AfterEach annotations are used to specify methods that should run before or after each test method, respectively. These annotations are useful for setting up resources before each test and cleaning up resources after each test.\nSHOW CODE Java import org.junit.jupiter.api.AfterEach; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class UnitTest { private Calculator calculator; @BeforeEach void setup() { calculator = new Calculator(); } @Test void testAddition() { assertEquals(2, calculator.add(1, 1), \"The result of 1 + 1 should be 2.\"); } @AfterEach void teardown() { calculator = null; } } @BeforeAll \u0026amp; @AfterAll In JUnit, the @BeforeAll and @AfterAll annotations are used to specify methods that run once before and after all the test methods in a test class, respectively. These methods are commonly used for expensive setup and cleanup.\nSHOW CODE Java import org.junit.jupiter.api.AfterAll; import org.junit.jupiter.api.BeforeAll; import org.junit.jupiter.api.Test; public class UnitTest { @BeforeAll public static void setUpBeforeClass() { System.out.println(\"Executed before all tests are run.\"); } @AfterAll public static void tearDownAfterClass() { System.out.println(\"Executed after all tests are run.\"); } @Test public void testMethod1() { System.out.println(\"Test 1 executed.\"); } @Test public void testMethod2() { System.out.println(\"Test 2 executed.\"); } } SHOW OUTPUT Output Executed before all tests are run. Test 1 executed. Test 2 executed. Executed after all tests are run. assertArrayEquals \u0026amp; assertNotEquals In JUnit, the assertArrayEquals and assertNotEquals methods are used to check if both arrays are equal in sizeand whether each corresponding element is equal or not. For arrays containing objects, JUnit will use the equals method of the objects for the comparison.\nSHOW CODE Java import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertArrayEquals; import static org.junit.jupiter.api.Assertions.assertNotEquals; public class UnitTest { @Test void testArrayEquality() { int[] expected = {1, 2, 3}; int[] actual = {1, 2, 3}; assertArrayEquals(expected, actual, \"Arrays should be equal\"); String[] expected2 = {\"apple\", \"banana\", \"cherry\"}; String[] actual2 = {\"apple\", \"banana\", \"cherry\"}; // Compare arrays of objects (Strings in this case) assertArrayEquals(expected2, actual2); } @Test void testArrayNotEquality() { int[] expected = {1, 2, 3}; int[] actual = {1, 2, 4}; assertNotEquals(expected, actual, \"Arrays should not be equal\"); } } assertThrows In Junit, the assertThrows is a method used to assert that a specific exception is throwing during the execution of a piece of code.\nSHOW CODE Java import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertThrows; public class UnitTest { @Test void testDivision() { Calculator calculator = new Calculator(); ArithmeticException exception = assertThrows(ArithmeticException.class, () -\u003e { calculator.divide(1, 0); }); assertEquals(\"/ by zero\", exception.getMessage()); } } assertTimeout \u0026amp; assertTimeoutPreemptively In JUnit, the assertTimeout and assertTimeoutPreemptively methods are used to ensure that a unit test finishes within a specified time limit. The key difference between them is that the assertTimeoutPreemptively method will terminate the test as soon as the excution time exceeds the specified limit. In contrast, the assertTimeout method allows the test to complete before checking if the time limit was exceeded.\nSHOW CODE Java import org.junit.jupiter.api.Test; import java.time.Duration; import static org.junit.jupiter.api.Assertions.*; public class UnitTest { @Test void testExecutionWithinTimeoutPreemptively() { assertTimeoutPreemptively(Duration.ofMillis(1000), () -\u003e { // Simulate a task that takes more time than allowed Thread.sleep(1500); // Task that takes more than 1000ms }); } @Test void testExecutionWithinTimeout() { assertTimeout(Duration.ofMillis(1000), () -\u003e { // Simulate a task that takes some time Thread.sleep(500); // Task that takes less than 1000ms }); } } Parameterized Tests In JUnit, Parameterized Tests allow a test to be run with different parameters and expected results, which reduces repetitive code and increases test coverage. Common parameter sources include @ValueSource, which passes a group of values to the test; @CsvSource, which allows passing multiple values separated by commmas; @MethodSource, which generates values dynamically from a method; and @EnumSource, which passes enum constants from an enum class.\nSHOW CODE Java import org.junit.jupiter.params.ParameterizedTest; import org.junit.jupiter.params.provider.CsvSource; import org.junit.jupiter.params.provider.EnumSource; import org.junit.jupiter.params.provider.MethodSource; import org.junit.jupiter.params.provider.ValueSource; import java.util.stream.Stream; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertTrue; public class UnitTest { @ParameterizedTest @ValueSource(strings = {\"apple\", \"banana\", \"cherry\"}) void testWithStringParameter(String fruit) { assertTrue(fruit.length() \u003e 3); } @ParameterizedTest @CsvSource({ \"apple, 5\", \"banana, 6\", \"cherry, 6\" }) void testWithCsvSource(String fruit, int length) { assertEquals(fruit.length(), length); } static Stream\u0026lt;String\u0026gt; stringProvider() { return Stream.of(\"apple\", \"banana\", \"cherry\"); } @ParameterizedTest @MethodSource(\"stringProvider\") void testWithMethodSource(String fruit) { assertTrue(fruit.length() \u003e 3); } enum FRUIT {APPLE, BANANA, CHERRY} @ParameterizedTest @EnumSource(FRUIT.class) void testWithEnumSource(FRUIT fruit) { assertTrue(fruit.name().length() \u003e 3); } } Mockito System Under Test The System Under Test (SUT) refers to the specific part of the software being tested in a given test case. It can range from a single method in unit testing to larger components in integration or system testing based on different context. The SUT is typically isolated using mocking and stubbing to test its behavior independently.\nSHOW CODE Java public class Calculator { public int add(int a, int b) { return a + b; } } public class CalculatorTest { @Test void testAdd() { Calculator calculator = new Calculator(); // SUT int result = calculator.add(2, 3); // The add method is the System Under Test assertEquals(5, result); } } Mocking vs. Stubbing In unit testing, Mocking and Stubbing are used to simulate and control the behavior of external dependencies. Mocking is commonly used for behavior verification, where objects are created to simulate the behavior of real-world components in a controlled manner. On the other hand, Stubbing is typically used to isolate the SUT by controlling the return values or responses from dependencies.\nSHOW CODE: Mocking Java public class Calculator { private Logger logger; public Calculator(Logger logger) { this.logger = logger; } public int add(int a, int b) { int result = a + b; logger.log(\"Addition performed: \" + result); return result; } } @Test void testAdd() { Logger mockLogger = mock(Logger.class); Calculator calculator = new Calculator(mockLogger); calculator.add(2, 3); // Verifying the interaction with the mock: was log method called? verify(mockLogger).log(\"Addition performed: 5\"); } SHOW CODE: Stubbing Java public class Calculator { private DatabaseService databaseService; public Calculator(DatabaseService databaseService) { this.databaseService = databaseService; } public int getProductPrice(int productId) { Product product = databaseService.getProduct(productId); return product.getPrice(); } } @Test void testGetProductPrice() { // Stub the DatabaseService to return a fixed product DatabaseService stubbedService = mock(DatabaseService.class); Product stubProduct = new Product(1, \"Laptop\", 1000); when(stubbedService.getProduct(1)).thenReturn(stubProduct); Calculator calculator = new Calculator(stubbedService); int price = calculator.getProductPrice(1); assertEquals(1000, price); } mock(), when().thenReturn(), verify() In Mockito, the mock() method is used to create a mock object, which allows simulating the behavior of an object without invoking its real methods. The when() method is used to define the behavior of a mock object\u0026rsquo;s method when it is called with specific arguments. The thenReturn() method specifies the return value of a mocked method. The verify() method is used to check whether a specified method on a mock object was called during the test execution.\nSHOW CODE Java import org.junit.jupiter.api.Test; import java.util.List; import static org.junit.jupiter.api.Assertions.assertTrue; import static org.mockito.Mockito.*; public class UnitTest { @Test public void testMockingBehavior() { // Create a mock List object List\u0026lt;String\u0026gt; mockList = mock(List.class); // Specify behavior for when add() is called when(mockList.add(\"Hello\")).thenReturn(true); // Return true when \"Hello\" is added // Call the mock method boolean result = mockList.add(\"Hello\"); // Verify the behavior assertTrue(result); // The add method should return true verify(mockList).add(\"Hello\"); // Verify that add(\"Hello\") was called // Verify that add(\"World\") was never called verify(mockList, never()).add(\"World\"); } } Argument Matchers In Mockito, argument matchers are used to specify conditions for method arguments when stubbing methods. They are commonly used in the when() and thenReturn() methods when the exact method argument is not critical. Some commonly used argument marchers include:\nany(): Matches any argument of the specified type. eq(): Matches a specified argument. anyString(): Matches any argument of type String. anyInt(): Matches any argument of type Integer. isA(): Matches an argument of a specified class type. argThat(): Allows for custom argument matching logic. SHOW CODE Java import org.junit.jupiter.api.Test; import java.util.List; import static org.junit.jupiter.api.Assertions.*; import static org.mockito.ArgumentMatchers.anyInt; import static org.mockito.Mockito.*; public class UnitTest { @Test public void testAnyMatcher() { List mockList = mock(List.class); // Stub behavior using argument matcher when(mockList.get(anyInt())).thenReturn(\"Signal\"); // Verify that any argument passed to get will return \"Signal\" assertEquals(\"Signal\", mockList.get(9)); assertEquals(\"Signal\", mockList.get(999)); } @Test public void testEqMatcher() { Calculator calculator = mock(Calculator.class); when(calculator.add(eq(1), eq(1))).thenReturn(2); assertEquals(2, calculator.add(1, 1)); assertNotEquals(3, calculator.add(1, 1)); } @Test public void testAnyStringMatcher() { // Create a mock List List\u0026lt;String\u0026gt; mockList = mock(List.class); // Stub the method to return \"Hello\" for any string argument when(mockList.contains(anyString())).thenReturn(true); // Verify that the mock returns true for any string passed as an argument assertTrue(mockList.contains(\"Test\")); // Matches any string assertTrue(mockList.contains(\"Hello\")); // Matches any string assertTrue(mockList.contains(\"World\")); // Matches any string } @Test public void testAnyIntMatcher() { // Create a mock List List mockList = mock(List.class); // Stub the method to return \"Found\" for any integer argument when(mockList.get(anyInt())).thenReturn(\"Found\"); // Verify that the mock returns \"Found\" regardless of the argument assertEquals(\"Found\", mockList.get(1)); // Matches any integer assertEquals(\"Found\", mockList.get(999)); // Matches any integer } @Test public void testArgThatMatcher() { // Create a mock List List\u0026lt;String\u0026gt; mockList = mock(List.class); // Use argThat to match arguments that are not null and have length greater than 3 when(mockList.add(argThat(argument -\u003e argument != null \u0026\u0026 argument.length() \u003e 3))) .thenReturn(true); // Verify that the mock behaves correctly assertTrue(mockList.add(\"Hello\")); // Matches: length \u003e 3 assertFalse(mockList.add(\"\")); // Does not match: empty string } } Essential Mockito Annotaitons The key annotations in Mockito are @Mock, @InjectMocks, @ExtendWith, and @Captor. The @Mock annotation is used to create mock objects. The @InjectMocks annotation injects the objects, created with @Mock, into the specified class under test. The @ExtendWith annotation specifies a custom test runner to use when executing the test. The @Captor annotation is used to create an ArgumentCaptor instance, which captures and verifies the arguments passed to mocked methods.\nSHOW CODE Java import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.ExtendWith; import org.mockito.ArgumentCaptor; import org.mockito.Captor; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.junit.jupiter.MockitoExtension; import java.util.List; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.mockito.Mockito.verify; @ExtendWith(MockitoExtension.class) public class UnitTest { @Mock private List\u0026lt;String\u0026gt; mockList; // Mocked dependency @InjectMocks private MyClass myClass; // Class under test @Captor private ArgumentCaptor\u0026lt;String\u0026gt; captor; // Captures arguments passed to the mock @Test void testAddItem() { // Perform the action under test myClass.addItem(\"Test Item\"); // Verify that the mockList's add method was called with the argument \"Test Item\" verify(mockList).add(captor.capture()); // Capture and assert the argument String capturedArgument = captor.getValue(); System.out.println(\"capturedArgument = \" + capturedArgument); // Assert the captured item is correct assertEquals(\"Test Item\", capturedArgument); } static class MyClass { private final List\u0026lt;String\u0026gt; list; public MyClass(List\u0026lt;String\u0026gt; list) { this.list = list; } public void addItem(String item) { list.add(item); } } } Mockit Spy Mockito\u0026rsquo;s spy is a partial mock, typically created using @Spy, where real methods are used by default, and only the specified methods are stubbed.\nSHOW CODE Java import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.ExtendWith; import org.mockito.Mock; import org.mockito.Spy; import org.mockito.junit.jupiter.MockitoExtension; import java.util.ArrayList; import java.util.List; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.mockito.Mockito.doReturn; import static org.mockito.Mockito.verify; @ExtendWith(MockitoExtension.class) public class UnitTest { // Create a spy for the class under test @Spy private MyClass myClass = new MyClass(); // Inject the mock dependency into the class under test @Mock private List\u0026lt;String\u0026gt; mockList; @Test public void testAddItemWithSpy() { // Use the real method to add an item myClass.addItem(\"Test Item\"); // Verify that the mock's addItem method is called with the argument // Fail the test: Actually, there were zero interactions with this mock. verify(mockList).add(\"Test Item\"); // Stub the method for testing doReturn(\"Mocked Response\").when(myClass).getGreeting(); // Now the method getGreeting() will return the mocked response String response = myClass.getGreeting(); System.out.println(response); // Output: Mocked Response // Assert the mocked behavior assertEquals(\"Mocked Response\", response); } // Class under test static class MyClass { private final List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); public void addItem(String item) { list.add(item); } public String getGreeting() { return \"Hello, World!\"; } } } In the above code, the statement verify(mockList).add(\u0026quot;Test Item\u0026quot;); will fail because mockList is a partial mock. By default, real methods are called on a spy object, and since the real method is not stubbed or tracked. the verification cannot succeed.\nMockito and SpringBoot Example SHOW CODE: pom.xml pom.xml \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.4.0\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;dev.signalyu\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springtest\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;springtest\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;springtest\u0026lt;/description\u0026gt; \u0026lt;url/\u0026gt; \u0026lt;licenses\u0026gt; \u0026lt;license/\u0026gt; \u0026lt;/licenses\u0026gt; \u0026lt;developers\u0026gt; \u0026lt;developer/\u0026gt; \u0026lt;/developers\u0026gt; \u0026lt;scm\u0026gt; \u0026lt;connection/\u0026gt; \u0026lt;developerConnection/\u0026gt; \u0026lt;tag/\u0026gt; \u0026lt;url/\u0026gt; \u0026lt;/scm\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;17\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.mockito/mockito-core --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mockito\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mockito-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.14.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-test --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.4.0\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.34\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.springframework.data/spring-data-commons --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.data\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-data-commons\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!--\t\u0026lt;build\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;plugins\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;plugin\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;configuration\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;annotationProcessorPaths\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;path\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;/path\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;/annotationProcessorPaths\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;/configuration\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;/plugin\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;plugin\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;configuration\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;excludes\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;exclude\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;/exclude\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;/excludes\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;/configuration\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;/plugin\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;/plugins\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;/build\u0026gt;--\u0026gt; \u0026lt;/project\u0026gt; SHOW CODE Java import lombok.AllArgsConstructor; import lombok.Data; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.data.repository.CrudRepository; import org.springframework.stereotype.Repository; import org.springframework.stereotype.Service; import org.springframework.test.context.bean.override.mockito.MockitoBean; import org.springframework.test.web.servlet.MockMvc; import org.springframework.test.web.servlet.result.MockMvcResultMatchers; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; import static org.mockito.Mockito.when; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status; @Data class User { private Long id; private String name; } @Repository interface UserRepository extends CrudRepository\u0026lt;User, Long\u0026gt; { } @Service @Data class UserService { @Autowired private final UserRepository userRepository; public String getUserById(Long id) { User user = userRepository.findById(id).orElse(null); return user == null ? \"User not found\" : user.getName(); } } @RestController @AllArgsConstructor class UserController { private final UserService userService; @GetMapping(\"/user/{id}\") public String getUser(@PathVariable Long id) { return userService.getUserById(id); } } @SpringBootTest @AutoConfigureMockMvc public class UnitTest { @Autowired private MockMvc mockMvc; @MockitoBean private UserService userService; @Test public void testGetUser() throws Exception { Long userId = 1L; String mockResponse = \"Signal Yu\"; when(userService.getUserById(userId)).thenReturn(mockResponse); mockMvc.perform(get(\"/user/{id}\", userId)) .andExpect(status().isOk()) .andExpect(MockMvcResultMatchers.content().string(mockResponse)); } } ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/framework-and-tools/framework/backend/unit-testing/1-junit-and-mockito-notes/","summary":"JUnit assertEquals In JUnit, assertEquals is a method used to check if the expected value and the actual value are equal in unit tests.\nSHOW CODE Java import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class UnitTest { @Test void addition() { Calculator calculator = new Calculator(); int result = calculator.add(1, 1); assertEquals(2, result, \"The result of 1 + 1 should be 2\"); } } assertTure \u0026amp; assertFalse In JUnit, the assertTrue and the assertFalse methods are used to validate boolean expressions in unit tests.","title":"Junit \u0026 Mockito Notes"},{"content":"Synchronous Messaging VS. Asynchronous Messaging Synchronous Messaging and Asynchronous Messaging are two commnication paradigms used in distributed systems. In synchronous messaging, the sender will not continue executing until it receives the acknowledged message from the receiver. This paradigm is commonly used in situations that require immediate feedback to continue operations, such as payments or transaction processing.\nThe advantages of this paradigm include ease of implementation and usefulness in situations where immediate feedback is needed. However, the drawbacks are also obvious: it may lead to performance bottlenecks when the receiver is slow or unavailable, and it can also limit scalability.\n--- title: Synchronous Messaging --- sequenceDiagram participant Sender participant MessageBus participant MessageListener Sender-\u003e\u003eMessageBus: MessageBusUtil.sendSynchronousMessage() MessageBus-\u003e\u003eMessageListener: destination.send() MessageListener--\u003e\u003eMessageBus: return response note over Sender: (block and wait) MessageBus--\u003e\u003eSender: return response In asynchronous messaging, the sender doesn\u0026rsquo;t block after sending the message, meaning it can continue processing without waiting for the response from the receiver. It is commonly used in situations where systems can tolerate delays in response, like message notification after a successful payment. Compared to synchronous messaging, asynchronous messaging is more complex to implement. Additionaly, the sender has no guarantee of immediate feedback. It requires extra techniques, such as callback functions or message listeners, to handle the response.\nsequenceDiagram participant Sender participant MessageBus as Message Bus participant MessageListener1 as Message Listener 1 Sender-\u003e\u003eMessageBus: MessageBusUtil.sendMessage() MessageBus-\u003e\u003eMessageListener: destination.send() MessageListener--\u003e\u003eMessageBus: return response Sender-\u003e\u003eSender: (continue with processing) MessageBus--\u003e\u003eSender: return response RabbitMQ Introduction to RabbitMQ RabbitMQ is a message broker that facilitates asynchronous communication between distributed systems. Its working mechnism involves four key components:\nProducer: Responsible for sending messages Exchange: Handles the routing of messages to the appropriate queues. Queue: Stores messages until they are consumed. Consumer: Processes the messages from the queue. --- title: Introduction to RabbitMQ --- graph LR P((P)) --\u003e|send| X{{Exchange}} --\u003e|binding| Q[[Queue]] --\u003e|receive| C((C)) Example: Hello RabbitMQ SHOW CODE Producer Consumer import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import java.nio.charset.StandardCharsets; public class Producer { // Name of the queue where the message will be sent private final static String QUEUE_NAME = \"hello\"; public static void main(String[] argv) throws Exception { // Create a connection factory to configure and connect to RabbitMQ ConnectionFactory factory = new ConnectionFactory(); // Configure RabbitMQ server address (default is localhost) factory.setHost(\"localhost\"); // Configure the port for RabbitMQ (default is 5672) factory.setPort(5672); // Use try-with-resource to automatically close the connection and channel after use try (Connection connection = factory.newConnection(); // Establish a connection to RabbitMQ Channel channel = connection.createChannel()) { // Create a communication channel // Declare a queue with the specified name channel.queueDeclare(QUEUE_NAME, false, false, false, null); String message = \"Hello RabbitMQ!\"; // Publish the message to the queue channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes(StandardCharsets.UTF_8)); System.out.println(\" [P] Sent '\" + message + \"'\"); } } } import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import com.rabbitmq.client.DeliverCallback; import java.nio.charset.StandardCharsets; public class Consumer { private final static String QUEUE_NAME = \"hello\"; public static void main(String[] argv) throws Exception { // Create a connection factory to configure and connect to RabbitMQ ConnectionFactory factory = new ConnectionFactory(); // Configure RabbitMQ server address (default is localhost) factory.setHost(\"localhost\"); // Configure the port for RabbitMQ (default is 5672) factory.setPort(5672); // Establish a connection to RabbitMQ Connection connection = factory.newConnection(); // Create a communication channel Channel channel = connection.createChannel(); // Declare a queue with the specified name channel.queueDeclare(QUEUE_NAME, false, false, false, null); System.out.println(\" [*] Waiting for messages. To exit press CTRL+C\"); // Define the callback function to handle incoming message DeliverCallback deliverCallback = (consumerTag, delivery) -\u003e { // Retrieve the message body and convert it to a string using UTF-8 encoding String message = new String(delivery.getBody(), StandardCharsets.UTF_8); System.out.println(\" [C] Received '\" + message + \"'\"); }; // Start consuming messages from the queue channel.basicConsume(QUEUE_NAME, true, deliverCallback, consumerTag -\u003e { // No action required for cancellation in this example }); } } Message Acknowledgment In RabbitMQ, message acknowledgement is a mechanism that ensures messages have been received and processed successfully. There are two main types of message acknowledgement: auto ack and manual ack.\nIn auto-ack mode, RabbitMQ considers the message acknowledged as soon as it is delieved to the consumer. The consumer does not need to explictly send an acknowledgement. However, this can be risky. If the consumer fails due to a connection issue or channel break, the message may be lost, meaning it hasn\u0026rsquo;t been processed successfully.\nboolean autoAck = true; channel.basicConsume(queueName, autoAck, consumer); In manual ack mode, the consumer must send an acknowledgement back to RabbitMQ once the message has been processed successfully. If RabbitMQ does not receive the acknowledgement from the consumer within a specified time (30 minutes by default), it will redeliver the message to another consumer or the same consumer, depending on the configuration.\n// Acknowledging a message manually boolean autoAck = false; channel.basicConsume(queueName, autoAck, new DefaultConsumer(channel) { @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { String message = new String(body, \u0026#34;UTF-8\u0026#34;); // Process the message here channel.basicAck(envelope.getDeliveryTag(), false); // Acknowledge the message } }); Message Durability In RabbitMQ, message durability refers to the ability to ensure that a message will not be lost in case of a broker failure. It involves saving both the queue and message to disk so they can be recovered after a system restart. To guarantee durability, two key components need to be considered: durable queues and persistent messages.\nWhen a queue is declared as durable, it is saved to disk. The queue will still exist even if the broker fails.\nboolean durable = true; channel.queueDeclare(\u0026#34;myQueue\u0026#34;, durable, false, false, null); To ensure a message\u0026rsquo;s persistence after a broker restart, it must be marked as persistent by setting the delieveryMode to 2 (persistent). This ensures that the message is saved to disk. However, it\u0026rsquo;s important to note that marking a message as persistent does not fully guarantee that it won\u0026rsquo;t be lost. There is still a short window in which RabbitMQ has accepted the message but has not yet saved it to disk. Additionaly, RabbitMQ does not call fsync(2) for every message, meaning it may store the message in cache rather than writing it to disk immediately. Therefore, the durability guerantee is not strong.\n// Publish the message to the queue channel.basicPublish(\u0026#34;\u0026#34;, TASK_QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, // delieveryMode = 2 message.getBytes(\u0026#34;UTF-8\u0026#34;)); Prefetch When a consumer subscribes to a message queue, RabbitMQ begins delivering messages. By default, RabbitMQ uses a Round Robin Dispatching strategy, which evenly distributes messages across multiple consumers. However, if one of the consumers processes tasks slowly, it may lead to message buildup and memory pressure.\nIn RabbitMQ, the prefetch mechnism controls the maximum number of messages a consumer can hold at a time. When the number of messages a consumer holds reaches the prefetch limit, RabbitMQ will stop sending additional messages to that consumer until it acknowledges some of the messages. This mechanism helps prevent message accumulation and reduces memory pressure.\n--- title: Worker Queue - prefetch --- graph LR P((P)) --\u003e|send| Q[[Worker]] --\u003e|prefetch = 1| C1((C1)) Q --\u003e|prefetch = 1| C2((C2)) SHOW CODE Producer Worker import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import com.rabbitmq.client.MessageProperties; public class Producer { private static final String TASK_QUEUE_NAME = \"task_queue\"; public static void main(String[] argv) throws Exception { // Create a connection factory to configure and connect to RabbitMQ ConnectionFactory factory = new ConnectionFactory(); // Configure RabbitMQ server address (default is localhost) factory.setHost(\"localhost\"); // Configure the port for RabbitMQ (default is 5672) factory.setPort(5672); // Use try-with-resource to automatically close the connection and channel after use try (Connection connection = factory.newConnection(); // Establish a connection to RabbitMQ Channel channel = connection.createChannel()) { // Create a communication channel // Declare a queue with the specified name channel.queueDeclare(TASK_QUEUE_NAME, true, false, false, null); String message = \"Hello RabbitMQ!\"; // Publish the message to the queue channel.basicPublish(\"\", TASK_QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes(\"UTF-8\")); System.out.println(\" [P] Sent '\" + message + \"'\"); } } } import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import com.rabbitmq.client.DeliverCallback; public class Worker { // Name of the queue where the message will be sent private static final String TASK_QUEUE_NAME = \"task_queue\"; public static void main(String[] argv) throws Exception { // Create a connection factory to configure and connect to RabbitMQ ConnectionFactory factory = new ConnectionFactory(); // Configure RabbitMQ server address (default is localhost) factory.setHost(\"localhost\"); // Establish a connection to RabbitMQ final Connection connection = factory.newConnection(); // Create a communication channel final Channel channel = connection.createChannel(); // Declare a queue with the specified name channel.queueDeclare(TASK_QUEUE_NAME, true, false, false, null); System.out.println(\" [*] Waiting for messages. To exit press CTRL+C\"); // Specify the prefetch count channel.basicQos(1); // Define a callback to process incoming messages DeliverCallback deliverCallback = (consumerTag, delivery) -\u003e { String message = new String(delivery.getBody(), \"UTF-8\"); System.out.println(\" [C] Received '\" + message + \"'\"); try { try { // Simulate task processing Thread.sleep(1000); } catch (InterruptedException _ignored) { Thread.currentThread().interrupt(); } } finally { // Acknowledge the message after work is completed System.out.println(\" [C] Done\"); channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); } }; // Start consuming messages with manual acknowledgment channel.basicConsume(TASK_QUEUE_NAME, false, deliverCallback, consumerTag -\u003e { }); } } Publish/Subscribe Publish/Subscribe is a communication pattern where a message is sent by a producer to multiple consumers. In RabbitMQ, this pattern is implemented using Exchanges and Queues.\nIn the Publish/Subscribe pattern in RabbitMQ, the producer sends a message to an Exchange, which then routes the message to multiple queues that are bound to it. There are four types of exchanges in RabbitMQ:\nfanout: Routes messages to all queues bound to it, without considering any routing key. direct: Routes messages to queues based on an exact match with the routing key. topic: Routes messages to queues based on pattern matching of the routing key. headers: Routes messages based on the attributes of message headers. Fanout Exchange --- title: Publish/Subscribe - fanout --- graph LR P((P)) --\u003e|send| Ex{{fanout}} --\u003e|binding| Q1[[Q1]] Ex --\u003e|binding| Q2[[Q2]] Q1 --\u003e C1((C1)) Q2 --\u003e C2((C2)) SHOW CODE: Fanout Exchange Publisher Subscriber import com.rabbitmq.client.BuiltinExchangeType; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; public class EmitLog { private static final String EXCHANGE_NAME = \"logs\"; public static void main(String[] argv) throws Exception { // Create a new connection factory to connect to RabbitMQ ConnectionFactory factory = new ConnectionFactory(); // Set the host (default is 'localhost') factory.setHost(\"localhost\"); // Use try-with-resource to ensures automatic resource management try (Connection connection = factory.newConnection(); // Establish a connection Channel channel = connection.createChannel()) { // Create a channel // Declare an exchange of type 'fanout' which sends messages to all bound queues channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT); String message = argv.length \u003c 1 ? \"info: Hello World!\" : String.join(\" \", argv); // Publish the message to the exchange with an empty routing key (for fanout exchange) channel.basicPublish(EXCHANGE_NAME, \"\", null, message.getBytes(\"UTF-8\")); System.out.println(\" [x] Sent '\" + message + \"'\"); } } } import com.rabbitmq.client.*; public class ReceiveLogs { private static final String EXCHANGE_NAME = \"logs\"; public static void main(String[] argv) throws Exception { // Create a new connection factory to connect to RabbitMQ ConnectionFactory factory = new ConnectionFactory(); // Set the host (default is 'localhost') factory.setHost(\"localhost\"); // Establish a connection and create a new channel for communication Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); // Declare the exchange with the same name as in the emitter (logs) and of type 'fanout' channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT); // Bind the queue to the exchange with an empty routing key (for fanout exchange) String queueName = channel.queueDeclare().getQueue(); channel.queueBind(queueName, EXCHANGE_NAME, \"\"); System.out.println(\" [*] Waiting for messages. To exit press CTRL+C\"); // Define the callback function to process incoming messages DeliverCallback deliverCallback = (consumerTag, delivery) -\u003e { String message = new String(delivery.getBody(), \"UTF-8\"); System.out.println(\" [x] Received '\" + message + \"'\"); }; // Consume messages from the queue channel.basicConsume(queueName, true, deliverCallback, consumerTag -\u003e { }); } } Direct Exchange --- title: Publish/Subscribe - direct --- graph LR P((P)) --\u003e|send| Ex{{direct}} --\u003e|error| Q1[[Q1]] Ex --\u003e|info| Q2[[Q2]] Ex --\u003e|warn| Q2[[Q2]] Ex --\u003e|error| Q2[[Q2]] Q1 --\u003e C1((C1)) Q2 --\u003e C2((C2)) SHOW CODE: Direct Exchange Publisher Subscriber import com.rabbitmq.client.BuiltinExchangeType; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; public class EmitLogDirect { private static final String EXCHANGE_NAME = \"direct_logs\"; public static void main(String[] argv) throws Exception { // Create a new connection factory to connect to RabbitMQ ConnectionFactory factory = new ConnectionFactory(); // Set the host (default is 'localhost') factory.setHost(\"localhost\"); //Use try-with-resource for automatic resource management try (Connection connection = factory.newConnection(); // Establish a new connection Channel channel = connection.createChannel()) { // Create a new channel // Declare an exchange with type of 'direct' channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT); // Get the severity level (routing key) from the command-line arguments String severity = getSeverity(argv); // Get the message content from the command-line arguments String message = getMessage(argv); // Publish the message to the exchange with given severity as the routing key channel.basicPublish(EXCHANGE_NAME, severity, null, message.getBytes(\"UTF-8\")); System.out.println(\" [x] Sent '\" + severity + \"':'\" + message + \"'\"); } } private static String getSeverity(String[] strings) { if (strings.length \u003c 1) { return \"info\"; } return strings[0]; } private static String getMessage(String[] strings) { if (strings.length \u003c 2) { return \"Hello World!\"; } return joinStrings(strings, \" \", 1); } private static String joinStrings(String[] strings, String delimiter, int startIndex) { int length = strings.length; if (length == 0) { return \"\"; } if (length \u003c= startIndex) { return \"\"; } StringBuilder words = new StringBuilder(strings[startIndex]); for (int i = startIndex + 1; i \u003c length; i++) { words.append(delimiter).append(strings[i]); } return words.toString(); } } import com.rabbitmq.client.*; public class ReceiveLogsDirect { private static final String EXCHANGE_NAME = \"direct_logs\"; public static void main(String[] argv) throws Exception { // Create a new connection factory to connect to RabbitMQ ConnectionFactory factory = new ConnectionFactory(); // Set the host (default is 'localhost') factory.setHost(\"localhost\"); // Establish a new connection Connection connection = factory.newConnection(); // Create a new channel Channel channel = connection.createChannel(); // Declare a direct exchange, where messages will be routed based on the routing key channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT); String queueName = channel.queueDeclare().getQueue(); // Exit the program if no arguments are passed (no routing keys provided) if (argv.length \u003c 1) { System.err.println(\"Usage: ReceiveLogsDirect [info] [warning] [error]\"); System.exit(1); } for (String severity : argv) { // Bind the queue to the exchange with a specific routing key channel.queueBind(queueName, EXCHANGE_NAME, severity); } System.out.println(\" [*] Waiting for messages. To exit press CTRL+C\"); // Define the callback function for processing the received messages DeliverCallback deliverCallback = (consumerTag, delivery) -\u003e { String message = new String(delivery.getBody(), \"UTF-8\"); System.out.println(\" [x] Received '\" + delivery.getEnvelope().getRoutingKey() + \"':'\" + message + \"'\"); }; // Consume messages from the queue channel.basicConsume(queueName, true, deliverCallback, consumerTag -\u003e { }); } } Topic Exchange In RabbitMQ, the Topic Exchange is a type of exchange that routes messages to queues based on pattern matching of the routing key. The routing key in a topic exchange is typically a string of words separated by dots (.). The routing key can also contain wildcards like * and #. The * wildcard matches exactly one word, while the # wildcard matches zero or more words. Compared to the direct exchange, the topic exchange offers greater flexibility and efiiciency in routing messages to queues based on more complex patterns.\nSHOW CODE: Topic Exchange Publisher Subscriber import com.rabbitmq.client.BuiltinExchangeType; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; public class EmitLogTopic { private static final String EXCHANGE_NAME = \"topic_logs\"; public static void main(String[] argv) throws Exception { // Create a connection factory to connect to RabbitMQ ConnectionFactory factory = new ConnectionFactory(); // Set the host (default is 'localhost') factory.setHost(\"localhost\"); // Use try-with-resource for automatic management try (Connection connection = factory.newConnection(); // Establish a new connection Channel channel = connection.createChannel()) { // Create a new channel // Declare a topic exchange with specified name channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC); String routingKey = getRouting(argv); String message = getMessage(argv); // Publish the message to the exchange channel.basicPublish(EXCHANGE_NAME, routingKey, null, message.getBytes(\"UTF-8\")); System.out.println(\" [x] Sent '\" + routingKey + \"':'\" + message + \"'\"); } } private static String getRouting(String[] strings) { if (strings.length \u003c 1) return \"anonymous.info\"; return strings[0]; } private static String getMessage(String[] strings) { if (strings.length \u003c 2) return \"Hello World!\"; return joinStrings(strings, \" \", 1); } private static String joinStrings(String[] strings, String delimiter, int startIndex) { int length = strings.length; if (length == 0) return \"\"; if (length \u003c startIndex) return \"\"; StringBuilder words = new StringBuilder(strings[startIndex]); for (int i = startIndex + 1; i \u003c length; i++) { words.append(delimiter).append(strings[i]); } return words.toString(); } } import com.rabbitmq.client.*; public class ReceiveLogsTopic { private static final String EXCHANGE_NAME = \"topic_logs\"; public static void main(String[] argv) throws Exception { // Create a new connection factory to connect to RabbitMQ ConnectionFactory factory = new ConnectionFactory(); // Set the host (default is 'localhost') factory.setHost(\"localhost\"); // Establish a new connection Connection connection = factory.newConnection(); // Create a new channel Channel channel = connection.createChannel(); // Declare a topic exchange with the specified name channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC); String queueName = channel.queueDeclare().getQueue(); if (argv.length \u003c 1) { System.err.println(\"Usage: ReceiveLogsTopic [binding_key]...\"); System.exit(1); } for (String bindingKey : argv) { channel.queueBind(queueName, EXCHANGE_NAME, bindingKey); } System.out.println(\" [*] Waiting for messages. To exit press CTRL+C\"); // Define the callback function for process received messages DeliverCallback deliverCallback = (consumerTag, delivery) -\u003e { String message = new String(delivery.getBody(), \"UTF-8\"); System.out.println(\" [x] Received '\" + delivery.getEnvelope().getRoutingKey() + \"':'\" + message + \"'\"); }; // Consume messages from the queue channel.basicConsume(queueName, true, deliverCallback, consumerTag -\u003e { }); } } Reliability: Publisher Publisher Retry Publisher Retry in RabbitMQ refers to the mechanism where the publisher reconnects to RabbitMQ after a network issue. This mechanism improves the likelihood of a successful connection when the network is unstable. However, the retry process is executed in blocking manner, which may lead to performance issues during reconnection. Below are the relavant configurations for application.properties.\nspring.rabbitmq.listener.simple.retry.enabled=false # Whether or not publishing retries are enabled. spring.rabbitmq.listener.simple.retry.initial-interval=1000 # Interval between the first and second attempt to deliver a message. spring.rabbitmq.listener.simple.retry.max-attempts=3 # Maximum number of attempts to deliver a message. spring.rabbitmq.listener.simple.retry.max-interval=10000 # Maximum interval between attempts. spring.rabbitmq.listener.simple.retry.multiplier=1.0 # A multiplier to apply to the previous delivery retry interval. spring.rabbitmq.listener.simple.retry.stateless=true # Whether or not retry is stateless or stateful. Publisher Confirm \u0026amp; Publisher Return RabbitMQ provides two types of message confirmation mechanisms between the publisher and the broker: Publisher Confirm and Publisher Return. The Publisher Confirm mechanism allows the publisher to receive an ack from the broker when the message is successfully delivered to the broker. The Publisher Return mechanism enables the broker to notify the publisher when a message cannot be routed to any queue.\nWhen a message is sent to the broker, if the message type is temporary and can be successfully routed to the specified queue, the broker will return an ack to the publisher. If the message type if durable and the message can be delievered to the queue and successfully saved to disk, the broker will return an ack. Otherwise, the broker will return an nack (negative acknowledgement) to the publisher.\nspring.rabbitmq.publisher-confirms=false # Enable publisher confirms. spring.rabbitmq.publisher-returns=false # Enable publisher returns. The Publisher Confirm mechanism provides two types of confirmation: synchronous mode (simple) and asynchronous mode (correlated). Synchronous mode offers a strict acknowledgement process but may lead to performance issues in high-throughput environments. It is typically used when reliability is the top priority. On the other hand, asynchronous mode improves throughput but requires that the acknowledgement process be handled in the background.\nIt is important to note that using Publisher Confirm and Publisher Return mechanism incurs additional network and system resource costs. Therefore, these mechanisms should be used with caution in production systems. If they must be used, it\u0026rsquo;s recommended to rely on Publisher Confirm only, as routing issues are often caused by business logic problems, and Publisher Return is less commonly needed. Additionally, for messages that are negatively acknowledged (nack), retry them within a limited time window to avoid an infinite retry loop. If retried continue to fail, record the exception logs instead of attempting retries indefinitely.\nReliability: Broker Data Persistency LazyQueue ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/asynchronous-messaging/1-asynchronous-messaging/","summary":"Synchronous Messaging VS. Asynchronous Messaging Synchronous Messaging and Asynchronous Messaging are two commnication paradigms used in distributed systems. In synchronous messaging, the sender will not continue executing until it receives the acknowledged message from the receiver. This paradigm is commonly used in situations that require immediate feedback to continue operations, such as payments or transaction processing.\nThe advantages of this paradigm include ease of implementation and usefulness in situations where immediate feedback is needed.","title":"Asynchronous Messaging"},{"content":"Introduction to DBMS A Database Management System (DBMS) is software that provides an interface for users to interact with databases. It enables the management, storage, and manipulation of data within databases. DBMS can be broadly classified into two main types: Relational DBMS and NoSQL DBMS.\nIn a Relational DBMS, data is stored in structured tables and is manipulated using SQL (Structured Query Language). Examples of relational DBMS inlcude MySQL, Oracle, and PostgreSQL.\nIn a NoSQL DBMS, data is typically unstructured or semi-structured, offering flexibility to handle diverse data types. Examples of NoSQL DBMS include MongoDB and Redis.\nMySQL MySQL is a relational database management system (RDBMS) that uses Structured Query Language (SQL) to interact with databases. It stores data in tables made up of rows and columns, allowing for efficient organization, retrival, and manipulation of data.\nSQL Commands SQL Commands are used to interact with relational databases. These commands can be classified into five types: DDL, DQL, DML, DCL, and TCL.\nSQL Commands DDL (Data Definition Language): Used to define and manage the structure of database instances, such as creating, altering, and deleting tables, and defining constraints. DQL (Data Query Language): Used to retrive data from the database, primarily through the SELECT statement. DML (Data Manipulation Language): Used to manipulate data within tables, such as inserting, updating, and deleting records. DCL (Data Control Language): Used to control access to data, manage user priviledges, and ensure data security. It includes commands like GRANT and REVOKE. TCL (Transaction Control Language): Used to manage transactions, ensuring data consistency. It includes commands like COMMIT, ROLLBACK, and SAVEPOINT. SQL Query Execution Order MySQL Execution Order: In MySQL, the execution order of an SQL query differs from the order in which components (e.g., SELECT, FROM, WHERE) are written in the query. MySQL begins by identifying the tables or views specified in the FROM clause. If there are any JOIN operation, MySQL performs the joins first and applies the ON condition. After completing the join operations, MySQL filters the based on the conditions specified in the WHERE clause.\nIf a GROUP BY clause is present, MySQL groups the rows based on the specified column(s) and then executes any aggregation functions (e.g., SUM(), COUNT(), etc.). Following the grouping, if a HAVING clause is provided, MySQL further filters the grouped results based on the specified condition.\nAfter filtering grouped results, MySQL selects the specified columns in the SELECT clause. If the DISTINCT keyword is used, MySQL removes duplicate rows from the selected result. Once the rows are selected and duplicates are removed, MySQL sorts the result set according to the rules defined in the ORDER BY clause.\nFinally, if a LIMIT or OFFSET clause is included, MySQL limits the number of rows returned, starting from the specified OFFSET.\nSQL Query Execution Order Select Find Customer Referee SHOW PROBLEM Table: Customer\nColumn Name Type id int name varchar referee_id int The id column is the primary key. Each row represents a customer, their name, and the id of the customer who referred them. If a customer wasn\u0026rsquo;t referred by anyone, the referee_id is NULL. Problem:\nFind the names of customers who were not referred by the customer with id = 2.\nThe result can be returned in any order.\nExample:\nInput: Customer table:\nid name referee_id 1 Will NULL 2 Jane NULL 3 Alex 2 4 Bill NULL 5 Zack 1 6 Mark 2 Output:\nname Will Jane Bill Zack Go to Leetcode 🔗 SHOW CODE MySQL SELECT name FROM Customer WHERE referee_id != 2 OR referee_id IS NULL; SHOW NOTES In SQL, NULL is not equal to any value, including 2. Therefore, the condition referee_id != 2 will exclude records where referee_id is NULL, because comparisons with NULL always result in an unknown NULL value, which is neither TRUE nor FALSE. It is crucial to consider the handling of NULL values when working with databases.\nArticle Views I SHOW PROBLEM Table: Views\nColumn Name Type article_id int author_id int viewer_id int view_date date There is no primary key in this table, and the table may contain duplicate rows. Each row indicates that a viewer viewed an article, where the article is written by an author, on a specific date. If author_id and viewer_id are the same, it indicates that the author viewed their own article. Problem:\nWrite a query to find the IDs of authors who have viewed at least one of their own articles.\nReturn the result table sorted by author_id in ascending order.\nExample:\nInput:\nViews table:\narticle_id author_id viewer_id view_date 1 3 5 2019-08-01 1 3 6 2019-08-02 2 7 7 2019-08-01 2 7 6 2019-08-02 4 7 1 2019-07-22 3 4 4 2019-07-21 3 4 4 2019-07-21 Output:\nid 4 7 Go to Leetcode 🔗 SHOW CODE MySQL SELECT DISTINCT author_id AS id FROM Views WHERE author_id = viewer_id ORDER BY id ASC; SHOW NOTES In SQL, the DISTINCT keyword is used to remove duplicate records from the result set, ensuring that only unique values are returned. It is commonly used in scenarios such as aggregating distinct values and ensuring uniqueness in join queries.\n# Aggregating unique values SELECT DISTINCT product_id FROM Order_Items; # Ensuring unique results in join queries SELECT DISTINCT c.customer_id, c.name FROM Customers c JOIN Orders o ON c.customer_id = o.customer_id; Baisc Joins LEFT JOIN: Replace Employee ID With The Unique Identifier In MySQL, LEFT JOIN is used to combine rows from two or more tables based on a related column between them. It returns all rows from the left table and the matching rows from the right table. If there is no match, the result will include NULL values for the column from the right table.\nSHOW PROBLEM Tables:\nEmployees\nColumn Name Type id int name varchar id is the primary key for this table. Each row represents an employee in the company, containing their id and name. EmployeeUNI\nColumn Name Type id int unique_id int (id, unique_id) is the primary key, meaning the combination of id and unique_id is unique across the table. Each row represents an employee\u0026rsquo;s id and their corresponding unique_id in the company. Task:\nWrite a SQL query that returns the unique_id of each employee from the Employees table. If an employee does not have a corresponding unique_id, return NULL for that employee.\nQuery Requirements:\nIf an employee has a unique_id, show it. If an employee does not have a unique_id, return NULL. The result should display the unique_id and the name of each employee. The results can be returned in any order.\nExample:\nInput:\nEmployees table:\nid name 1 Alice 7 Bob 11 Meir 90 Winston 3 Jonathan EmployeeUNI table:\nid unique_id 3 1 11 2 90 3 Output:\nunique_id name NULL Alice NULL Bob 2 Meir 3 Winston 1 Jonathan Explanation:\nAlice and Bob do not have a unique_id, so NULL is shown for both. Meir has a unique_id of 2. Winston has a unique_id of 3. Jonathan has a unique_id of 1. Go to Leetcode 🔗 SHOW CODE MySQL SELECT euni.unique_id, e.name FROM Employees e LEFT JOIN EmployeeUNI euni ON e.id = euni.id; LEFT JOIN: Confirmation Rate SHOW PROBLEM Table: Signups\nColumn Name Type user_id int time_stamp datetime user_id is a unique identifier for each user. Each row represents the signup time for the user identified by user_id. Table: Confirmations\nColumn Name Type user_id int time_stamp datetime action ENUM The primary key is a combination of user_id and time_stamp. user_id is a foreign key referencing the Signups table. action is an ENUM with two possible values: 'confirmed' or 'timeout'. Each row represents a confirmation request made by the user with user_id, indicating whether the confirmation message was confirmed ('confirmed') or timed out ('timeout'). Problem Description\nThe confirmation rate of a user is calculated as the ratio of 'confirmed' actions to the total number of confirmation requests. If a user has not made any confirmation requests, the confirmation rate is 0. The rate should be rounded to two decimal places.\nGoal\nWrite a SQL query to find the confirmation rate for each user.\nReturn the result in any order.\nInput\nSignups table:\nuser_id time_stamp 3 2020-03-21 10:16:13 7 2020-01-04 13:57:59 2 2020-07-29 23:09:44 6 2020-12-09 10:39:37 Confirmations table:\nuser_id time_stamp action 3 2021-01-06 03:30:46 timeout 3 2021-07-14 14:00:00 timeout 7 2021-06-12 11:57:29 confirmed 7 2021-06-13 12:58:28 confirmed 7 2021-06-14 13:59:27 confirmed 2 2021-01-22 00:00:00 confirmed 2 2021-02-28 23:59:59 timeout Output\nuser_id confirmation_rate 6 0.00 3 0.00 7 1.00 2 0.50 Explanation:\nUser 6 did not request any confirmation messages, so their confirmation rate is 0. User 3 made two confirmation requests, but both timed out, so their confirmation rate is 0. User 7 made three requests, and all were confirmed, so their confirmation rate is 1.00. User 2 made two requests: one confirmed and one timed out, so their confirmation rate is 1/2 = 0.50. Go to Leetcode 🔗 SHOW CODE MySQL SELECT user_id, ROUND(IFNULL(SUM(action = 'confirmed') / COUNT(1), 0), 2) AS confirmation_rate FROM SignUps LEFT JOIN Confirmations USING (user_id) GROUP BY 1; SELECT s.user_id, CASE WHEN c.user_id IS NULL THEN 0.00 ELSE ROUND(SUM(CASE WHEN action = 'confirmed' THEN 1 ELSE 0 END) / COUNT(*),2) END AS confirmation_rate FROM Signups s LEFT JOIN Confirmations c ON c.user_id = s.user_id GROUP BY s.user_id SHOW NOTES SUM(action = 'confirmed'): action = 'confirmed' returns 1 for confirmed actions and 0 for 'timeout' action. COUNT(1): Counts the total number of rows. (Use COUNT(*) for counting rows is more clear and idiomatic). LEFT JOIN Confirmations USING (user_id): Joins the Signups table with the Confirmations table on the user_id column. GROUP BY 1: A shorthand for GROUP BY user_id. It groups the results by the first column in the SELECT list, which is user_id in this case. INNER JOIN: Product Sales Analysis I In MySQL, the INNER JOIN is used to combine rows from two or more tables based on a related column between them. It only returns rows where there is a match in all the joined tables.\nSHOW PROBLEM Tables:\nSales\nColumn Name Type sale_id int product_id int year int quantity int price int (sale_id, year) is the primary key, meaning this combination of columns is unique. product_id is a foreign key referencing the Product table. Each row represents a sale of a product identified by product_id in a particular year. The price is per unit of the product. Product\nColumn Name Type product_id int product_name varchar product_id is the primary key for this table. Each row represents a product with its product_name. Task:\nWrite a SQL query to report the product_name, year, and price for each sale in the Sales table.\nQuery Requirements:\nReturn the product_name from the Product table, corresponding to the product_id in the Sales table. Include the year and price from the Sales table for each sale. The result can be returned in any order. Example:\nInput:\nSales table:\nsale_id product_id year quantity price 1 100 2008 10 5000 2 100 2009 12 5000 7 200 2011 15 9000 Product table:\nproduct_id product_name 100 Nokia 200 Apple 300 Samsung Output:\nproduct_name year price Nokia 2008 5000 Nokia 2009 5000 Apple 2011 9000 Explanation:\nFrom sale_id = 1, we can conclude that Nokia was sold for 5000 in 2008. From sale_id = 2, we can conclude that Nokia was sold for 5000 in 2009. From sale_id = 7, we can conclude that Apple was sold for 9000 in 2011. Go to Leetcode 🔗 SHOW CODE MySQL SELECT p.product_name, s.year, s.price FROM Sales s INNER JOIN Product p ON s.product_id = p.product_id; LEFT JOIN: Customer Who Visited but Did Not Make Any Transactions SHOW PROBLEM Table: Visits\nColumn Name Type visit_id int customer_id int visit_id is the unique identifier for each visit. This table contains information about the customers who visited the mall. Table: Transactions\nColumn Name Type transaction_id int visit_id int amount int transaction_id is the unique identifier for each transaction. This table contains information about the transactions made during each visit. Task:\nWrite a SQL query to find the IDs of customers who visited the mall without making any transactions, and count how many times they made these visits.\nThe result should include:\ncustomer_id — the ID of the customer. count_no_trans — the number of visits where no transaction was made. Query Requirements:\nReturn the result sorted in any order. Input:\nVisits table:\nvisit_id customer_id 1 23 2 9 4 30 5 54 6 96 7 54 8 54 Transactions table:\ntransaction_id visit_id amount 2 5 310 3 5 300 9 5 200 12 1 910 13 2 970 Output:\ncustomer_id count_no_trans 54 2 30 1 96 1 Explanation:\nCustomer with id = 23 visited once and made a transaction during the visit with id = 12. Customer with id = 9 visited once and made a transaction during the visit with id = 13. Customer with id = 30 visited once and did not make any transactions. Customer with id = 54 visited three times. During two visits, they did not make any transactions, and during one visit, they made three transactions. Customer with id = 96 visited once and did not make any transactions. In the output, customers with id = 30, id = 96, and id = 54 (for two of their visits) made visits without transactions.\nGo to Leetcode 🔗 SHOW CODE MySQL SELECT v.customer_id, COUNT(v.visit_id) as count_no_trans FROM Visits v LEFT JOIN Transactions t ON v.visit_id = t.visit_id WHERE t.transaction_id IS NULL GROUP BY v.customer_id; SHOW NOTES In the above SQL query, MySQL first identifies the Visits table and performs a LEFT JOIN with the Transactions table based on the condition v.visit_id = t.visit_id. The LEFT JOIN operation combines the two tables and fills NULL in rows where there is no match in the Transactions table. The result looks like this:\nSELECT * FROM Visits v LEFT JOIN Transactions t ON v.visit_id = t.visit_id; visit_id customer_id transaction_id visit_id amount 1 23 12 1 910 2 9 13 2 970 4 30 null null null 5 54 9 5 200 5 54 3 5 300 5 54 2 5 310 6 96 null null null 7 54 null null null 8 54 null null null After joining the tables, MySQL applies the WHERE clause to filter rows where t.transaction_id IS NULL, which means visits without any transactions.\nSELECT * FROM Visits v LEFT JOIN Transactions t ON v.visit_id = t.visit_id WHERE t.transaction_id IS NULL; visit_id customer_id transaction_id visit_id amount 4 30 null null null 6 96 null null null 7 54 null null null 8 54 null null null Next, MySQL groups the filtered rows by customer_id and calculates the number of visits per customer using the COUNT(v.visit_id) function.\nSELECT *, COUNT(v.visit_id) FROM Visits v LEFT JOIN Transactions t ON v.visit_id = t.visit_id WHERE t.transaction_id IS NULL GROUP BY v.customer_id; visit_id customer_id transaction_id visit_id amount COUNT(v.visit_id) 4 30 null null null 1 6 96 null null null 1 7 54 null null null 2 Finally, MySQL selects the desired columns and renames the COUNT(v.visit_id) column using the AS clause.\nSELECT v.customer_id, COUNT(v.visit_id) AS count_no_trans FROM Visits v LEFT JOIN Transactions t ON v.visit_id = t.visit_id WHERE t.transaction_id IS NULL GROUP BY v.customer_id; customer_id count_no_trans 30 1 96 1 54 2 SELF JOIN: Rising Temperature In MySQL, a self join is an operation where a table joins itself. It is commonly used when comparing rows within the same table based on a specific condition or when working with hierarchical data, such as relating employees to their managers.\nSHOW PROBLEM Table: Weather\nColumn Name Type id int recordDate date temperature int id is a column with unique values. There are no duplicate rows for the same recordDate. This table contains information about the temperature on specific dates. Problem Statement\nWrite a solution to find the id of all dates where the temperature is higher compared to the previous day (yesterday).\nReturn\nReturn the result table in any order. Input:\nWeather Table:\nid recordDate temperature 1 2015-01-01 10 2 2015-01-02 25 3 2015-01-03 20 4 2015-01-04 30 Output:\nid 2 4 Explanation:\nOn 2015-01-02, the temperature was higher than the previous day (10 -\u0026gt; 25). On 2015-01-04, the temperature was higher than the previous day (20 -\u0026gt; 30). Go to Leetcode 🔗 SHOW CODE MySQL SELECT w1.id FROM Weather w1 JOIN Weather w2 ON DATE_ADD(w2.recordDate, INTERVAL 1 DAY) = w1.recordDate WHERE w1.temperature \u003e w2.temperature; SHOW NOTES In the above query, the DATE_ADD(w2.recordDate, INTERVAL 1 DAY) = w1.recordDate condition ensures that the recordDate of w1 matches the day following w2\u0026rsquo;s recordDate.\nSELECT * FROM Weather w1 JOIN Weather w2 ON DATE_ADD(w2.recordDate, INTERVAL 1 DAY) = w1.recordDate id recordDate temperature id recordDate temperature 1 2015-01-01 10 2 2015-01-02 25 1 2015-01-01 10 3 2015-01-03 20 2 2015-01-02 25 4 2015-01-04 30 3 2015-01-03 20 4 2015-01-04 30 Result of the Join:\nid recordDate temperature id recordDate temperature 2 2015-01-02 25 1 2015-01-01 10 3 2015-01-03 20 2 2015-01-02 25 4 2015-01-04 30 3 2015-01-03 20 when id equals to 2, 25 \u0026gt; 10, so it is selcted. when id equals to 3, 20 \u0026lt; 25, so it is not selcted. when id equals to 4, 25 \u0026gt; 10, so it is selcted. Therefore, the result will be:\nid 2 4 Example: Relating Employees to Their Managers\nEmployees Table:\nid name manager_id 1 Alice NULL 2 Bob 1 3 Charlie 1 4 David 2 SELECT e1.name AS Employee, e2.name AS Manager FROM Employees e1 JOIN Employees e2 ON e1.manager_id = e2.id; Result of the Join:\nid name manager_id id name manager_id 2 Bob 1 1 Alice NULL 3 Charlie 1 1 Alice NULL 4 David 2 2 Bob 1 Final Result:\nEmployee Manager Bob Alice Charlie Alice David Bob SELF JOIN: Managers with at Least 5 Direct Reports SHOW PROBLEM Problem Description\nTable: Employee\nColumn Name Data Type Description id int Unique identifier for each employee. name varchar Name of the employee. department varchar Department to which the employee belongs. managerId int ID of the employee\u0026rsquo;s manager. If managerId is null, the employee does not have a manager. id is the primary key, ensuring each value is unique. Each row represents an employee, including their name, department, and their manager’s ID. If managerId is null, the employee does not report to any manager. An employee cannot be their own manager. Task\nWrite a query to find the managers who have at least five direct reports.\nReturn the result in any order.\nInput:\nEmployee Table:\nid name department managerId 101 John A null 102 Dan A 101 103 James A 101 104 Amy A 101 105 Anne A 101 106 Ron B 101 Output:\nname John Go to Leetcode 🔗 SHOW CODE MySQL SELECT b.name FROM Employee a JOIN Employee b ON a.managerId = b.id GROUP BY b.id HAVING COUNT(*) \u003e= 5 SHOW NOTES Table: Employee:\nid name department managerId 101 John A null 102 Dan A 101 103 James A 101 104 Amy A 101 105 Anne A 101 106 Ron B 101 Perform a self join, the table becomes:\nSELECT * FROM Employee a JOIN Employee b ON a.managerId = b.id Table: Slef Joined Result:\nid name department managerId id name department managerId 106 Ron B 101 101 John A null 105 Anne A 101 101 John A null 104 Amy A 101 101 John A null 103 James A 101 101 John A null 102 Dan A 101 101 John A null Group the self joined result:\nSELECT * FROM Employee a JOIN Employee b ON a.managerId = b.id GROUP BY b.id Table: Grouped Result:\nid name department managerId id name department managerId 106 Ron B 101 101 John A null Filter grouped result:\nSELECT * FROM Employee a JOIN Employee b ON a.managerId = b.id GROUP BY b.id HAVING COUNT(*) \u0026gt;= 5 Table: Filtered Grouped Result:\nid name department managerId id name department managerId 106 Ron B 101 101 John A null Select the specified column(s):\nSELECT b.name FROM Employee a JOIN Employee b ON a.managerId = b.id GROUP BY b.id HAVING COUNT(*) \u0026gt;= 5 Final Result:\nname John SELF JOIN: Average Time of Process per Machine SHOW PROBLEM Table: Activity\nColumn Name Type machine_id int process_id int activity_type enum timestamp float The table records user activities for machines on a factory website. The combination of (machine_id, process_id, activity_type) is the primary key, ensuring uniqueness in the table. machine_id is the ID of the machine. process_id is the ID of the process running on the machine with ID machine_id. activity_type is an ENUM type with values 'start' and 'end', representing the start and end of a process. timestamp is a float value representing the time (in seconds) the event occurred. The 'start' timestamp is always earlier than the 'end' timestamp for each (machine_id, process_id) pair. It is guaranteed that each (machine_id, process_id) pair has a corresponding 'start' and 'end' timestamp. Problem:\nThere are several machines on a factory website, and each machine runs the same number of processes. Your task is to write a SQL query that calculates the average time each machine takes to complete a process.\nThe time to complete a process is the difference between the 'end' timestamp and the 'start' timestamp. The average time for each machine is calculated by dividing the total time for all processes on that machine by the number of processes. The result should contain the following columns:\nmachine_id — the ID of the machine. processing_time — the average processing time, rounded to 3 decimal places. Input:\nActivity table: |------------|------------|---------------|-----------| | machine_id | process_id | activity_type | timestamp | |------------|------------|---------------|-----------| | 0 | 0 | start | 0.712 | | 0 | 0 | end | 1.520 | | 0 | 1 | start | 3.140 | | 0 | 1 | end | 4.120 | | 1 | 0 | start | 0.550 | | 1 | 0 | end | 1.550 | | 1 | 1 | start | 0.430 | | 1 | 1 | end | 1.420 | | 2 | 0 | start | 4.100 | | 2 | 0 | end | 4.512 | | 2 | 1 | start | 2.500 | | 2 | 1 | end | 5.000 | |------------|------------|---------------|-----------| Output:\n|------------|-----------------| | machine_id | processing_time | |------------|-----------------| | 0 | 0.894 | | 1 | 0.995 | | 2 | 1.456 | |------------|-----------------| Explanation:\nMachine 0:\nProcess 0: End time 1.520, Start time 0.712 → Time taken = 1.520 - 0.712 = 0.808 Process 1: End time 4.120, Start time 3.140 → Time taken = 4.120 - 3.140 = 0.980 Average time = (0.808 + 0.980) / 2 = 0.894 Machine 1:\nProcess 0: End time 1.550, Start time 0.550 → Time taken = 1.550 - 0.550 = 1.000 Process 1: End time 1.420, Start time 0.430 → Time taken = 1.420 - 0.430 = 0.990 Average time = (1.000 + 0.990) / 2 = 0.995 Machine 2:\nProcess 0: End time 4.512, Start time 4.100 → Time taken = 4.512 - 4.100 = 0.412 Process 1: End time 5.000, Start time 2.500 → Time taken = 5.000 - 2.500 = 2.500 Average time = (0.412 + 2.500) / 2 = 1.456 Go to Leetcode 🔗 SHOW CODE MySQL SELECT machine_id, ROUND(AVG(end_time - start_time), 3) AS processing_time FROM ( SELECT a.machine_id, a.process_id, a.timestamp AS start_time, b.timestamp AS end_time FROM Activity a JOIN Activity b ON a.machine_id = b.machine_id AND a.process_id = b.process_id AND a.activity_type = 'start' AND b.activity_type = 'end' ) AS process_times GROUP BY machine_id; SHOW NOTES In the following SQL query, the condition a.activity_type = 'start' and b.activity_type = 'end' ensures that the start and end timestamp are correctly matched for the same process on the same machine.\nSELECT * FROM Activity a JOIN Activity b ON a.machine_id = b.machine_id AND a.process_id = b.process_id AND a.activity_type = \u0026#39;start\u0026#39; AND b.activity_type = \u0026#39;end\u0026#39; Result of the Join:\nmachine_id process_id activity_type timestamp machine_id process_id activity_type timestamp 0 0 start 0.712 0 0 end 1.52 0 1 start 3.14 0 1 end 4.12 1 0 start 0.55 1 0 end 1.55 1 1 start 0.43 1 1 end 1.42 2 0 start 4.1 2 0 end 4.512 2 1 start 2.5 2 1 end 5 The result is selected from of the joined result:\nSELECT machine_id, ROUND(AVG(end_time - start_time), 3) AS processing_time FROM ( SELECT a.machine_id, a.process_id, a.timestamp AS start_time, b.timestamp AS end_time FROM Activity a JOIN Activity b ON a.machine_id = b.machine_id AND a.process_id = b.process_id AND a.activity_type = \u0026#39;start\u0026#39; AND b.activity_type = \u0026#39;end\u0026#39; ) AS process_times GROUP BY machine_id; Final Result:\nmachine_id processing_time 0 0.894 1 0.995 2 1.456 CROSS JOIN: Students and Examinations In MySQL, a CROSS JOIN is a type of join that returns the Cartesian product of two tables. It combines each row from the first table with every row from the second table, without the need for a join condition. For example, consider two tables, Students and Subjects:\nTable 1: Students\nstudent_id student_name 1 Alice 2 Bob Table 2: Subjects\nsubject_name Math Physics When a Cross Join is performed between these two tables, the result will be:\nTable: Result of Cross Join\nstudent_id student_name subject_name 1 Alice Math 1 Alice Physics 2 Bob Math 2 Bob Physics SHOW PROBLEM Table: Students\nColumn Name Type student_id int student_name varchar student_id is the primary key (unique values) for this table. Each row represents a student with their unique ID and name. Table: Subjects\nColumn Name Type subject_name varchar subject_name is the primary key (unique values) for this table. Each row represents the name of a subject offered in the school. Table: Examinations\nColumn Name Type student_id int subject_name varchar There is no primary key for this table, and it may contain duplicates. Each row indicates that a student with student_id attended the exam for the subject subject_name. Every student takes every course from the Subjects table. Task:\nWrite a query to find the number of times each student attended each exam, ordered by student_id and subject_name.\nInput:\nStudents Table:\nstudent_id student_name 1 Alice 2 Bob 13 John 6 Alex Subjects Table:\nsubject_name Math Physics Programming Examinations Table:\nstudent_id subject_name 1 Math 1 Physics 1 Programming 2 Programming 1 Physics 1 Math 13 Math 13 Programming 13 Physics 2 Math 1 Math Output:\nstudent_id student_name subject_name attended_exams 1 Alice Math 3 1 Alice Physics 2 1 Alice Programming 1 2 Bob Math 1 2 Bob Physics 0 2 Bob Programming 1 6 Alex Math 0 6 Alex Physics 0 6 Alex Programming 0 13 John Math 1 13 John Physics 1 13 John Programming 1 Explanation:\nThe result table contains all students and all subjects.\nAlice attended the Math exam 3 times, the Physics exam 2 times, and the Programming exam 1 time. Bob attended the Math exam 1 time, the Programming exam 1 time, and did not attend the Physics exam. Alex did not attend any exams. John attended the Math exam 1 time, the Physics exam 1 time, and the Programming exam 1 time. Go to Leetcode 🔗 SHOW CODE MySQL SELECT s.student_id, s.student_name, sub.subject_name, COUNT(e.student_id) AS attended_exams FROM Students s CROSS JOIN Subjects sub LEFT JOIN Examinations e ON s.student_id = e.student_id AND sub.subject_name = e.subject_name GROUP BY s.student_id, s.student_name, sub.subject_name ORDER BY s.student_id, sub.subject_name; SHOW NOTES Table: Students\nstudent_id student_name 1 Alice 2 Bob 13 John 6 Alex Table: Subjects:\nsubject_name Math Physics Programming When a CROSS JOIN is performed between the Students and Subjects tables, the result will be:\nSELECT * FROM Students s CROSS JOIN Subjects sub Table: Result of Cross Join:\nstudent_id student_name subject_name 1 Alice Programming 1 Alice Physics 1 Alice Math 2 Bob Programming 2 Bob Physics 2 Bob Math 13 John Programming 13 John Physics 13 John Math 6 Alex Programming 6 Alex Physics 6 Alex Math Table: Examniations:\nstudent_id subject_name 1 Math 1 Physics 1 Programming 2 Programming 1 Physics 1 Math 13 Math 13 Programming 13 Physics 2 Math 1 Math Perform a LEFT JOIN on the cross-joined tables with the Examinations table:\nSELECT * FROM Students s CROSS JOIN Subjects sub LEFT JOIN Examinations e ON s.student_id = e.student_id AND sub.subject_name = e.subject_name Table: Left Join Result:\nstudent_id student_name subject_name student_id subject_name 1 Alice Programming 1 Programming 1 Alice Physics 1 Physics 1 Alice Physics 1 Physics 1 Alice Math 1 Math 1 Alice Math 1 Math 1 Alice Math 1 Math 2 Bob Programming 2 Programming 2 Bob Physics null null 2 Bob Math 2 Math 13 John Programming 13 Programming 13 John Physics 13 Physics 13 John Math 13 Math 6 Alex Programming null null 6 Alex Physics null null 6 Alex Math null null After grouping the left joined result and count the e.studentId, the table will look like:\nSELECT *, COUNT(e.student_id) AS attended_exams FROM Students s CROSS JOIN Subjects sub LEFT JOIN Examinations e ON s.student_id = e.student_id AND sub.subject_name = e.subject_name GROUP BY s.student_id, s.student_name, sub.subject_name Table: Grouped Result with Count:\nstudent_id student_name subject_name student_id subject_name attended_exams 1 Alice Programming 1 Programming 1 1 Alice Physics 1 Physics 2 1 Alice Math 1 Math 3 2 Bob Programming 2 Programming 1 2 Bob Physics null null 0 2 Bob Math 2 Math 1 13 John Programming 13 Programming 1 13 John Physics 13 Physics 1 13 John Math 13 Math 1 6 Alex Programming null null 0 6 Alex Physics null null 0 6 Alex Math null null 0 After selecting the specified columns, the result table becomes:\nSELECT s.student_id, s.student_name, sub.subject_name, COUNT(e.student_id) AS attended_exams FROM Students s CROSS JOIN Subjects sub LEFT JOIN Examinations e ON s.student_id = e.student_id AND sub.subject_name = e.subject_name GROUP BY s.student_id, s.student_name, sub.subject_name student_id student_name subject_name attended_exams 1 Alice Programming 1 1 Alice Physics 2 1 Alice Math 3 2 Bob Programming 1 2 Bob Physics 0 2 Bob Math 1 13 John Programming 1 13 John Physics 1 13 John Math 1 6 Alex Programming 0 6 Alex Physics 0 6 Alex Math 0 Sort the selcted table based on the condition s.student_id and sub.subject_name, return the final result:\nTable: Final Result:\nstudent_id student_name subject_name attended_exams 1 Alice Math 3 1 Alice Physics 2 1 Alice Programming 1 2 Bob Math 1 2 Bob Physics 0 2 Bob Programming 1 6 Alex Math 0 6 Alex Physics 0 6 Alex Programming 0 13 John Math 1 13 John Physics 1 13 John Programming 1 Basic Aggregate Functions Average Selling Price SHOW PROBLEM Table: Prices\nColumn Name Type product_id int start_date date end_date date price int The primary key for this table is the combination of (product_id, start_date, end_date), ensuring unique periods for each product. Each row represents the price of a product for a specific period, from start_date to end_date. For each product, no two periods will overlap. Table: UnitsSold\nColumn Name Type product_id int purchase_date date units int This table may contain duplicate rows. Each row represents the date, number of units, and product_id for a product sold on that date. Problem:\nWrite a SQL query to find the average selling price for each product. The average_price should be rounded to two decimal places. If a product does not have any sold units, its average selling price should be considered 0.\nReturn the result table in any order.\nInput:\nPrices table:\nproduct_id start_date end_date price 1 2019-02-17 2019-02-28 5 1 2019-03-01 2019-03-22 20 2 2019-02-01 2019-02-20 15 2 2019-02-21 2019-03-31 30 UnitsSold table:\nproduct_id purchase_date units 1 2019-02-25 100 1 2019-03-01 15 2 2019-02-10 200 2 2019-03-22 30 Output:\nproduct_id average_price 1 6.96 2 16.96 Explanation:\nFor product 1:\nFrom 2019-02-17 to 2019-02-28, 100 units were sold at a price of 5. From 2019-03-01 to 2019-03-22, 15 units were sold at a price of 20. Average price is calculated based on the total price and total units sold. For product 2:\nFrom 2019-02-01 to 2019-02-20, 200 units were sold at a price of 15. From 2019-02-21 to 2019-03-31, 30 units were sold at a price of 30. Average price is calculated based on the total price and total units sold. Go to Leetcode 🔗 SHOW CODE MySQL SELECT p.product_id, ROUND(IFNULL(SUM(price * units) / SUM(units), 0), 2) AS average_price FROM Prices AS p LEFT JOIN UnitsSold AS u ON p.product_id = u.product_id AND purchase_date BETWEEN start_date AND end_date GROUP BY 1; SHOW NOTES: Right Answer MySQL Query Walkthrough:\nTable: Prices\nproduct_id start_date end_date price 1 2019-02-17 2019-02-28 5 1 2019-03-01 2019-03-22 20 2 2019-02-01 2019-02-20 15 2 2019-02-21 2019-03-31 30 3 2019-02-21 2019-03-31 30 Table: UnitsSold\nproduct_id purchase_date units 1 2019-02-25 100 1 2019-03-01 15 2 2019-02-10 200 2 2019-03-22 30 Join the two tables based on the product_id and the purchase_date, where the purchase_date falls between the start_date and the end_date:\nSELECT * FROM Prices AS p LEFT JOIN UnitsSold AS u ON p.product_id = u.product_id AND purchase_date BETWEEN start_date AND end_date; product_id start_date end_date price product_id purchase_date units 1 2019-02-17 2019-02-28 5 1 2019-02-25 100 1 2019-03-01 2019-03-22 20 1 2019-03-01 15 2 2019-02-01 2019-02-20 15 2 2019-02-10 200 2 2019-02-21 2019-03-31 30 2 2019-03-22 30 3 2019-02-21 2019-03-31 30 null null null Group the joined result and then use aggregation functions to calculate the average price:\nSELECT *, ROUND(IFNULL(SUM(price * units) / SUM(units), 0), 2) AS average_price FROM Prices AS p LEFT JOIN UnitsSold AS u ON p.product_id = u.product_id AND purchase_date BETWEEN start_date AND end_date GROUP BY 1; product_id start_date end_date price product_id purchase_date units average_price 1 2019-02-17 2019-02-28 5 1 2019-02-25 100 6.96 2 2019-02-01 2019-02-20 15 2 2019-02-10 200 16.96 3 2019-02-21 2019-03-31 30 null null null 0 Select the desired columns:\nSELECT p.product_id, ROUND(IFNULL(SUM(price * units) / SUM(units), 0), 2) AS average_price FROM Prices AS p LEFT JOIN UnitsSold AS u ON p.product_id = u.product_id AND purchase_date BETWEEN start_date AND end_date GROUP BY 1; product_id average_price 1 6.96 2 16.96 3 0 SHOW NOTES: Wrong Answer # Wrong Answer SELECT p.product_id, ROUND(IFNULL(SUM(price * units) / SUM(units), 0), 2) AS average_price FROM Prices AS p LEFT JOIN UnitsSold AS u ON p.product_id = u.product_id WHERE purchase_date BETWEEN start_date AND end_date GROUP BY 1; Join the two tables based on the condition p.product_id = u.product_id:\nSELECT * FROM Prices AS p LEFT JOIN UnitsSold AS u ON p.product_id = u.product_id; product_id start_date end_date price product_id purchase_date units 1 2019-02-17 2019-02-28 5 1 2019-03-01 15 1 2019-02-17 2019-02-28 5 1 2019-02-25 100 1 2019-03-01 2019-03-22 20 1 2019-03-01 15 1 2019-03-01 2019-03-22 20 1 2019-02-25 100 2 2019-02-01 2019-02-20 15 2 2019-03-22 30 2 2019-02-01 2019-02-20 15 2 2019-02-10 200 2 2019-02-21 2019-03-31 30 2 2019-03-22 30 2 2019-02-21 2019-03-31 30 2 2019-02-10 200 3 2019-02-21 2019-03-31 30 null null null Filter out the rows that do not fall between start_date and end_date:\nSELECT * FROM Prices AS p LEFT JOIN UnitsSold AS u ON p.product_id = u.product_id WHERE purchase_date BETWEEN start_date AND end_date; product_id start_date end_date price product_id purchase_date units 1 2019-02-17 2019-02-28 5 1 2019-02-25 100 1 2019-03-01 2019-03-22 20 1 2019-03-01 15 2 2019-02-01 2019-02-20 15 2 2019-02-10 200 2 2019-02-21 2019-03-31 30 2 2019-03-22 30 Group the filtered result and then use aggregation functions to calculate average price:\nSELECT *, ROUND(IFNULL(SUM(price * units) / SUM(units), 0), 2) AS average_price FROM Prices AS p LEFT JOIN UnitsSold AS u ON p.product_id = u.product_id WHERE purchase_date BETWEEN start_date AND end_date GROUP BY 1; product_id start_date end_date price product_id purchase_date units average_price 1 2019-02-17 2019-02-28 5 1 2019-02-25 100 6.96 2 2019-02-01 2019-02-20 15 2 2019-02-10 200 16.96 Select the desired columns:\nSELECT p.product_id, ROUND(IFNULL(SUM(price * units) / SUM(units), 0), 2) AS average_price FROM Prices AS p LEFT JOIN UnitsSold AS u ON p.product_id = u.product_id WHERE purchase_date BETWEEN start_date AND end_date GROUP BY 1; product_id average_price 1 6.96 2 16.96 The correct answer is:\nproduct_id average_price 1 6.96 2 16.96 3 0 Summary: The LEFT JOIN operation will return NULL results for rows without without matching records in the UnitsSold table. In the condition p.product_id = u.product_id AND purchase_date BETWEEN start_date AND end_date, the date range check is applied during the join operation, while WHERE purchase_date BETWEEN start_date AND end_date is applied after the join operation. The WHERE clause exlcudes rows with NULL values, which means products with no matching sales records (i.e., where purchase_date doesn\u0026rsquo;t match) will be excluded from the result. When grouping the result, no rows containing NULL values remain, leading to an incorrect result (missing product_id = 3 with average_price = 0).\nPercentage of Users Attended a Contest SHOW PROBLEM Table: Users\nColumn Name Type user_id int user_name varchar user_id is the primary key (a unique identifier) for this table. Each row in this table represents a user, with their unique ID and name. Table: Register\nColumn Name Type contest_id int user_id int (contest_id, user_id) is the primary key (a unique combination of columns) for this table. Each row in this table represents the registration of a user in a specific contest. Task\nWrite a solution to calculate the percentage of users registered for each contest, rounded to two decimal places.\nReturn the result table sorted by percentage in descending order. If there is a tie in percentage, order by contest_id in ascending order.\nInput:\nUsers table:\nuser_id user_name 6 Alice 2 Bob 7 Alex Register table:\ncontest_id user_id 215 6 209 2 208 2 210 6 208 6 209 7 209 6 215 7 208 7 210 2 207 2 210 7 Output:\ncontest_id percentage 208 100.0 209 100.0 210 100.0 215 66.67 207 33.33 Explanation:\nContests 208, 209, and 210 had 100% user registration. The results are sorted by contest_id in ascending order. Contest 215 had a registration rate of 66.67%, as Alice and Alex registered, out of a total of three users. Contest 207 had a registration rate of 33.33%, as only Bob registered, out of a total of three users. Go to Leetcode 🔗 SHOW CODE MySQL SELECT contest_id, ROUND(COUNT(user_id) * 100 / (SELECT COUNT(user_id) FROM Users),2) percentage FROM Register a GROUP BY contest_id ORDER BY percentage DESC,contest_id ASC; SHOW NOTES $$ \\text{percentage} = \\frac{\\text{number of users attended in the contest}}{\\text{total number of users}} \\times 100 \\% $$\nCompute the total number of users: SELECT COUNT(user_id) FROM Users Compute the number of users attended in the contest: Group the table based on the column contest_id, then count the number of users in each group. Queries Quality and Percentage SHOW PROBLEM Table: Queries\nColumn Name Type query_name varchar result varchar position int rating int This table may contain duplicate rows. It contains information collected from various queries executed on a database. The position column has a value ranging from 1 to 500. The rating column has a value between 1 and 5. Queries with a rating less than 3 are considered poor queries. Definitions:\nQuery quality: The average of the ratio between the query\u0026rsquo;s rating and its position. Poor query percentage: The percentage of queries with a rating less than 3. Objective: Write a solution to find:\nThe query_name, The quality of each query (rounded to 2 decimal places), The poor_query_percentage for each query (rounded to 2 decimal places). Input: Queries table:\nquery_name result position rating Dog Golden Retriever 1 5 Dog German Shepherd 2 5 Dog Mule 200 1 Cat Shirazi 5 2 Cat Siamese 3 3 Cat Sphynx 7 4 Output:\nquery_name quality poor_query_percentage Dog 2.50 33.33 Cat 0.66 33.33 Explanation:\nDog queries:\nQuality:\n$$ \\left( \\frac{5}{1} + \\frac{5}{2} + \\frac{1}{200} \\right) / 3 = 2.50 $$ Poor query percentage:\n$$ \\frac{1}{3} \\times 100 = 33.33 $$ Cat queries:\nQuality:\n$$ \\left( \\frac{2}{5} + \\frac{3}{3} + \\frac{4}{7} \\right) / 3 = 0.66 $$ Poor query percentage:\n$$ \\frac{1}{3} \\times 100 = 33.33 $$ Go to Leetcode 🔗 SHOW CODE MySQL SELECT query_name, ROUND(AVG(rating / position), 2) AS quality, ROUND(SUM(CASE WHEN rating \u003c 3 THEN 1 ELSE 0 END) / COUNT(*) * 100, 2) AS poor_query_percentage FROM Queries GROUP BY query_name; Monthly Transactions I SHOW PROBLEM Table: Transactions\nColumn Name Type id int country varchar state enum amount int trans_date date id is the primary key of this table. The table stores information about incoming transactions. The state column is an enum with values [\u0026ldquo;approved\u0026rdquo;, \u0026ldquo;declined\u0026rdquo;]. Task:\nFor each month and country, find the following information:\nThe total number of transactions (trans_count). The total amount of all transactions (trans_total_amount). The number of approved transactions (approved_count). The total amount of approved transactions (approved_total_amount). The results should be returned in any order.\nExample Input:\nid country state amount trans_date 121 US approved 1000 2018-12-18 122 US declined 2000 2018-12-19 123 US approved 2000 2019-01-01 124 DE approved 2000 2019-01-07 Example Output:\nmonth country trans_count approved_count trans_total_amount approved_total_amount 2018-12 US 2 1 3000 1000 2019-01 US 1 1 2000 2000 2019-01 DE 1 1 2000 2000 Go to Leetcode 🔗 SHOW CODE MySQL SELECT DATE_FORMAT(trans_date, '%Y-%m') AS month, country, COUNT(*) AS trans_count, SUM(CASE WHEN state = 'approved' THEN 1 ELSE 0 END) AS approved_count, SUM(amount) AS trans_total_amount, SUM(CASE WHEN state = 'approved' THEN amount ELSE 0 END) AS approved_total_amount FROM Transactions GROUP BY month, country; SELECT DATE_FORMAT(trans_date, '%Y-%m') AS month, country, COUNT(*) AS trans_count, COUNT(IF(state = 'approved', 1, NULL)) AS approved_count, SUM(amount) AS trans_total_amount, SUM(IF(state = 'approved', amount, 0)) AS approved_total_amount FROM Transactions GROUP BY month, country; SHOW NOTES The DATE_FORMAT function in SQL is used to format a date into a specific string format. For example, DATE_FORMAT('2024-12-19', '%Y-%m') will output '2024-12', extracting the year and month from the date. The IF function in SQL returns one value if the condition is true and another value if the condition is false. For example, IF(amount \u0026gt; 1000, 1, 0) will return 1 if the amount is greater than 1000, otherwise, it will return 0. The CASE...WHEN...THEN...ELSE...END statement is similar to the switch statement in other programming languages like Java. It works like the IF function, but with the ability to handle multiple conditions. It checks each condition in sequence and returns the corresponding result for the first true condition. Immediate Food Delivery II SHOW PROBLEM Table: Delivery\nColumn Name Type delivery_id int customer_id int order_date date customer_pref_delivery_date date delivery_id is the unique identifier for each delivery. The table contains information about food deliveries, where customers place orders on a specific date and specify a preferred delivery date (either on the same day or later). If the customer_pref_delivery_date is the same as the order_date, the order is considered immediate; otherwise, it is scheduled. The first order of a customer is defined as the one with the earliest order_date. Each customer has exactly one first order. Task:\nFind the percentage of immediate orders among the first orders of all customers, rounded to two decimal places.\nThe result should follow the format shown below:\nExample Input:\ndelivery_id customer_id order_date customer_pref_delivery_date 1 1 2019-08-01 2019-08-02 2 2 2019-08-02 2019-08-02 3 1 2019-08-11 2019-08-12 4 3 2019-08-24 2019-08-24 5 3 2019-08-21 2019-08-22 6 2 2019-08-11 2019-08-13 7 4 2019-08-09 2019-08-09 Example Output:\nimmediate_percentage 50.00 Explanation:\nCustomer 1 has their first order with delivery_id 1, which is scheduled. Customer 2 has their first order with delivery_id 2, which is immediate. Customer 3 has their first order with delivery_id 5, which is scheduled. Customer 4 has their first order with delivery_id 7, which is immediate. Hence, 50% of the first orders are immediate.\nGo to Leetcode 🔗 SHOW CODE MySQL SELECT ROUND((SUM(IF(order_date = customer_pref_delivery_date, 1, 0)) / COUNT(*)) * 100, 2) AS immediate_percentage FROM (SELECT customer_id, MIN(order_date) AS first_order_date FROM Delivery GROUP BY customer_id) AS first_orders INNER JOIN Delivery AS d ON first_orders.customer_id = d.customer_id AND first_orders.first_order_date = d.order_date; Game Play Analysis IV SHOW PROBLEM Table: Activity\nColumn Name Type player_id int device_id int event_date date games_played int The combination of (player_id, event_date) is the primary key of this table, ensuring each player can only log in once per day. This table tracks the activity of players in games, where each record represents a player\u0026rsquo;s login and the number of games played (which could be zero) before logging out on a specific day using a particular device. Task:\nCalculate the fraction of players who logged in again on the day after their first login date. The result should be rounded to two decimal places.\nIn other words, identify the players who logged in on consecutive days starting from their first login date, then divide that count by the total number of players.\nExample Input:\nplayer_id device_id event_date games_played 1 2 2016-03-01 5 1 2 2016-03-02 6 2 3 2017-06-25 1 3 1 2016-03-02 0 3 4 2018-07-03 5 Example Output:\nfraction 0.33 Explanation:\nPlayer 1 logged in on 2016-03-01 and 2016-03-02, meaning they logged in for at least two consecutive days, starting from their first login. Player 2 did not log in again on the day after their first login. Player 3 did not log in on consecutive days, as there was a gap between their logins. Thus, only player 1 satisfies the condition, and the fraction is calculated as 1/3 = 0.33.\nGo to Leetcode 🔗 SHOW CODE MySQL SELECT ROUND( SUM(IF(DATEDIFF(event_date, min_event_date) = 1, 1, 0)) / COUNT(DISTINCT player_id), 2) AS fraction FROM ( SELECT player_id, event_date, MIN(event_date) OVER (PARTITION BY player_id) AS min_event_date FROM activity ) AS activity_with_min_date; SHOW NOTES The DATEDIFF function in MySQL calculates the difference in days between two dates. For example, DATEDIFF('2024-12-30', '2024-12-25') will output 5, indicating there are 5 days between the two dates. The PARTITION BY clause is used in window functions to divide the result ser into partitions (groups) based on a specified column. It applies window functions, such as RANK(), SUM(), ROW_NUMBER(), and others, to each partition. This works similarly to GROUP BY, but unlike GROUP BY, the PARTITION BY clause allows retaining the row-level data while applying the window functions. Input Table: employees\ndepartment_id employee_id salary 101 1 5000 101 2 4000 101 3 6000 102 4 4500 102 5 5500 102 6 4800 SELECT department_id, employee_id, salary, RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) AS salary_rank FROM employees; Output (Result of Query):\ndepartment_id employee_id salary salary_rank 101 3 6000 1 101 1 5000 2 101 2 4000 3 102 5 5500 1 102 6 4800 2 102 4 4500 3 Sorting and Grouping User Activity for the Past 30 Days I SHOW PROBLEM Table: Activity\nColumn Name Type user_id int session_id int activity_date date activity_type enum The activity_type column is an ENUM with values: \u0026lsquo;open_session\u0026rsquo;, \u0026rsquo;end_session\u0026rsquo;, \u0026lsquo;scroll_down\u0026rsquo;, \u0026lsquo;send_message\u0026rsquo;. This table logs user activities for a social media website, where each session is linked to exactly one user. The table may contain duplicate rows. Task:\nYou need to find the count of unique active users per day for the 30-day period ending on 2019-07-27, inclusive. A user is considered active on a particular day if they perform at least one activity on that day.\nExample:\nInput: Activity table\nuser_id session_id activity_date activity_type 1 1 2019-07-20 open_session 1 1 2019-07-20 scroll_down 1 1 2019-07-20 end_session 2 4 2019-07-20 open_session 2 4 2019-07-21 send_message 2 4 2019-07-21 end_session 3 2 2019-07-21 open_session 3 2 2019-07-21 send_message 3 2 2019-07-21 end_session 4 3 2019-06-25 open_session 4 3 2019-06-25 end_session Output:\nday active_users 2019-07-20 2 2019-07-21 2 Explanation:\nOnly the days with active users (those who performed at least one activity) are included in the output. For 2019-07-20, users 1 and 2 were active, and for 2019-07-21, users 2 and 3 were active. Go to Leetcode 🔗 SHOW CODE MySQL SELECT activity_date AS day, COUNT(DISTINCT user_id) AS active_users FROM Activity WHERE activity_date \u003c= '2019-07-27' AND DATEDIFF('2019-07-27', activity_date) \u003c 30 GROUP BY activity_date SELECT activity_date AS day, COUNT(DISTINCT user_id) AS active_users FROM Activity WHERE activity_date \u003c= '2019-07-27' AND activity_date\u003e DATE_SUB('2019-07-27',INTERVAL 30 day) GROUP BY activity_date SHOW NOTES In MySQL, both DATEDIFF and DATE_SUB are used for date calculations. DATEDIFF calculates the difference between two dates, returning the result in days. On the other hand, DATE_SUB is used to subtract a specified time interval (such as days, months, or years) from a given date.\nSELECT DATEDIFF(\u0026#39;2023-12-31\u0026#39;, \u0026#39;2023-01-01\u0026#39;); -- Result: 364 SELECT DATE_SUB(\u0026#39;2023-12-31\u0026#39;, INTERVAL 30 DAY); -- Result: \u0026#39;2023-12-01\u0026#39; SELECT DATE_SUB(\u0026#39;2023-12-31\u0026#39;, INTERVAL 2 MONTH); -- Result: \u0026#39;2023-10-31\u0026#39; Product Sales Analysis III SHOW PROBLEM Table: Sales\nColumn Name Type sale_id int product_id int year int quantity int price int The combination of sale_id and year is the primary key of this table, ensuring each record is unique for a given sale. product_id is a foreign key referencing the Product table. Each row in this table represents a sale of a specific product (product_id) in a given year. The price refers to the price per unit of the product. Table: Product\nColumn Name Type product_id int product_name varchar product_id is the primary key of this table, ensuring unique product identifiers. Each row represents the name of a product associated with the corresponding product_id. Task: Write a query to select the product_id, year, quantity, and price for the first year in which each product was sold.\nReturn the result in any order.\nExample:\nInput: Sales table\nsale_id product_id year quantity price 1 100 2008 10 5000 2 100 2009 12 5000 7 200 2011 15 9000 Product table:\nproduct_id product_name 100 Nokia 200 Apple 300 Samsung Output:\nproduct_id first_year quantity price 100 2008 10 5000 200 2011 15 9000 Explanation:\nFor product_id = 100, the first sale occurred in 2008 with a quantity of 10 and a price of 5000. For product_id = 200, the first sale occurred in 2011 with a quantity of 15 and a price of 9000. The query should return the first sale year for each product, along with the corresponding quantity and price.\nGo to Leetcode 🔗 SHOW CODE MySQL SELECT product_id, year AS first_year, quantity, price FROM Sales WHERE (product_id, year) IN ( SELECT product_id, MIN(year) AS year FROM Sales GROUP BY product_id ); SELECT product_id, first_year, quantity, price FROM ( SELECT product_id, year AS first_year, quantity, price, RANK() OVER (PARTITION BY product_id ORDER BY year) AS row_num FROM Sales ) subquery WHERE row_num = 1; SELECT s.product_id, s.year AS first_year, s.quantity, s.price FROM Sales s JOIN ( SELECT product_id, MIN(year) AS first_year FROM Sales GROUP BY product_id ) first_sale ON s.product_id = first_sale.product_id AND s.year = first_sale.first_year; SHOW NOTES Biggest Single Number SHOW PROBLEM Table: MyNumbers\nColumn Name Type num int This table may contain duplicates (i.e., there is no primary key in the SQL table). Each row contains an integer.\nProblem Description\nA single number is a number that appears only once in the MyNumbers table.\nThe task is to find the largest single number. If there is no single number, return null.\nExample 1:\nInput: MyNumbers table:\nnum 8 8 3 3 1 4 5 6 Output:\nnum 6 Explanation:\nThe single numbers are 1, 4, 5, and 6. Since 6 is the largest single number, we return it.\nExample 2:\nInput: MyNumbers table:\nnum 8 8 7 7 3 3 3 Output:\nnum null Explanation:\nThere are no single numbers in the input table, so we return null.\nGo to Leetcode 🔗 SHOW CODE MySQL SELECT MAX(num) AS num FROM ( SELECT num FROM MyNumbers GROUP BY 1 HAVING COUNT(1) = 1 ) AS t; SELECT IF(COUNT(num) = 1, num, null) AS num FROM MyNumbers GROUP BY num ORDER BY 1 DESC LIMIT 1; Advanced Select \u0026amp; Joins The Number of Employees Which Report to Each Employee SHOW PROBLEM Table: Employees\nColumn Name Type employee_id int name varchar reports_to int age int employee_id is the unique identifier for each employee in the table. This table stores information about employees and the ID of the manager they report to. Some employees may not report to anyone (reports_to is null). A manager is defined as an employee who has at least one other employee reporting to them. Problem Description\nYou are required to write a solution that reports the following information for each manager:\nThe manager\u0026rsquo;s employee_id and name. The number of employees directly reporting to the manager. The average age of these employees, rounded to the nearest integer. The results should be ordered by employee_id.\nExample 1:\nInput:\nEmployees table:\nemployee_id name reports_to age 9 Hercy null 43 6 Alice 9 41 4 Bob 9 36 2 Winston null 37 Output:\nemployee_id name reports_count average_age 9 Hercy 2 39 Explanation:\nHercy manages 2 employees (Alice and Bob). The average age of Alice and Bob is (41 + 36) / 2 = 38.5, which rounds to 39. Example 2:\nInput:\nEmployees table:\nemployee_id name reports_to age 1 Michael null 45 2 Alice 1 38 3 Bob 1 42 4 Charlie 2 34 5 David 2 40 6 Eve 3 37 7 Frank null 50 8 Grace null 48 Output:\nemployee_id name reports_count average_age 1 Michael 2 40 2 Alice 2 37 3 Bob 1 37 Explanation:\nMichael manages Alice and Bob. The average age of Alice and Bob is (38 + 42) / 2 = 40. Alice manages Charlie and David, with an average age of (34 + 40) / 2 = 37. Bob manages Eve, with an average age of 37. Go to Leetcode 🔗 SHOW CODE MySQL SELECT e1.employee_id, e1.name, COUNT(e1.employee_id) AS reports_count, ROUND(AVG(e2.age)) AS average_age FROM Employees e1 INNER JOIN Employees e2 ON e1.employee_id = e2.reports_to GROUP BY e1.employee_id ORDER BY e1.employee_id; Primary Department for Each Employee SHOW PROBLEM Table: Employee\nColumn Name Type employee_id int department_id int primary_flag varchar The combination of (employee_id, department_id) is the primary key for this table, meaning each employee can belong to multiple departments, but each (employee_id, department_id) pair is unique. employee_id: The ID of the employee. department_id: The ID of the department to which the employee belongs. primary_flag: A flag indicating whether the department is the primary department for the employee. It can be one of the following: 'Y': The department is the primary department. 'N': The department is not the primary department. Problem Description\nEmployees may belong to multiple departments, and when they do, they must designate one department as their primary. If an employee belongs to only one department, the primary_flag for that department will be 'N'.\nYou are tasked with reporting the primary department for each employee. If an employee has only one department, report that department as their primary.\nInput:\nEmployee table:\nemployee_id department_id primary_flag 1 1 N 2 1 Y 2 2 N 3 3 N 4 2 N 4 3 Y 4 4 N Output:\nemployee_id department_id 1 1 2 1 3 3 4 3 Explanation:\nFor employee 1, their only department is department 1, so it is reported as their primary department. Employee 2 belongs to two departments (1 and 2). The primary_flag for department 1 is 'Y', so department 1 is their primary department. Employee 3 only belongs to department 3, so it is reported as their primary department. Employee 4 belongs to three departments (2, 3, and 4). The primary_flag for department 3 is 'Y', so department 3 is reported as their primary department. Go to Leetcode 🔗 SHOW CODE sql SELECT employee_id, department_id FROM Employee WHERE primary_flag = 'Y' UNION SELECT employee_id, department_id FROM Employee GROUP BY employee_id HAVING COUNT(1) = 1; SHOW NOTES The UNION operator is used to combine the results of two or more SELECT queries into a single result set. By default, UNION removes duplicate rows, ensuring that the final result contains only distinct records. In contrast, UNION ALL includes all rows, even if they are duplicates. It\u0026rsquo;s important to note that each SELECT statement involved in a UNION operation must contain the same number of columns, and the corresponding columns must have compatable data types.\nTriangle Judgement SHOW PROBLEM Table: Triangle\nColumn Name Type x int y int z int Primary Key: (x, y, z)\nEach row in this table represents the lengths of three line segments. Task:\nDetermine whether the three line segments (x, y, z) from each row can form a triangle.\nReturn the result table in any order, including a column that specifies if the segments form a triangle.\nTriangle Formation Rule:\nThree segments can form a triangle if and only if the following conditions are met:\n$x + y \u0026gt; z$ $x + z \u0026gt; y$ $y + z \u0026gt; x$ Example:\nInput:\n**Triangle table: **\nx y z 13 15 30 10 20 15 Output:\nx y z triangle 13 15 30 No 10 20 15 Yes Go to Leetcode 🔗 SHOW CODE MySQL SELECT *, IF(x + y \u003e z AND x + z \u003e y AND y + z \u003e x, 'Yes', 'No') AS triangle FROM Triangle; SELECT *, CASE WHEN (x + y \u003e z) AND (x + z \u003e y) AND (y + z \u003e x) THEN 'Yes' ELSE 'No' END AS triangle FROM Triangle; Consecutive Numbers SHOW PROBLEM Table: Logs\nColumn Name Type id int num varchar id is the primary key for this table. The id column is an auto-increment column that starts from 1. Problem Statement:\nFind all numbers (num) that appear at least three times consecutively in the table.\nReturn the result table in any order.\nExample:\nInput:\nLogs table:\nid num 1 1 2 1 3 1 4 2 5 1 6 2 7 2 Output:\nConsecutiveNums 1 Explanation:\nThe number 1 is the only value that appears at least three times consecutively in the table.\nGo to Leetcode 🔗 SHOW CODE MySQL SELECT DISTINCT l1.num AS ConsecutiveNums FROM Logs l1 JOIN Logs l2 ON l1.id = l2.id - 1 JOIN Logs l3 ON l2.id = l3.id - 1 WHERE l1.num = l2.num AND l2.num = l3.num; SELECT DISTINCT l2.num AS ConsecutiveNums FROM Logs AS l1 JOIN Logs AS l2 ON l1.id = l2.id - 1 AND l1.num = l2.num JOIN Logs AS l3 ON l2.id = l3.id - 1 AND l2.num = l3.num; Product Price at a Given Date SHOW PROBLEM Table: Products\nColumn Name Type product_id int new_price int change_date date (product_id, change_date) is the primary key (a combination of columns with unique values) of this table. Each row indicates that the price of a product was changed to a new price on a specific date. Problem Statement\nWrite a query to find the prices of all products on 2019-08-16. Assume the price of all products before any change is 10.\nReturn the result in any order.\nExample:\nInput:\nProducts table:\nproduct_id new_price change_date 1 20 2019-08-14 2 50 2019-08-14 1 30 2019-08-15 1 35 2019-08-16 2 65 2019-08-17 3 20 2019-08-18 Output:\nproduct_id price 2 50 1 35 3 10 Go to Leetcode 🔗 SHOW CODE MySQL WITH T AS (SELECT DISTINCT product_id FROM Products), P AS ( SELECT product_id, new_price AS price FROM Products WHERE (product_id, change_date) IN ( SELECT product_id, MAX(change_date) AS change_date FROM Products WHERE change_date \u003c= '2019-08-16' GROUP BY 1 ) ) SELECT product_id, IFNULL(price, 10) AS price FROM T LEFT JOIN P USING (product_id); WITH P AS ( SELECT p1.product_id, new_price, change_date FROM ( SELECT DISTINCT product_id FROM Products ) AS p1 LEFT JOIN Products AS p2 ON p1.product_id = p2.product_id AND p2.change_date \u003c= '2019-08-16' ), T AS ( SELECT *, RANK() OVER ( PARTITION BY product_id ORDER BY change_date DESC ) AS rk FROM P ) SELECT product_id, IFNULL(new_price, 10) AS price FROM T WHERE rk = 1; SHOW NOTES Last Person to Fit in the Bus SHOW PROBLEM Table: Queue\nColumn Name Type person_id int person_name varchar weight int turn int The person_id column contains unique values. This table holds information about people waiting to board a bus. The person_id and turn columns contain values from 1 to n, where n is the number of rows in the table. The turn column determines the order in which people will board the bus. A turn value of 1 indicates the first person to board, and turn = n indicates the last person to board. The weight column represents the person’s weight in kilograms. The bus has a weight limit of 1000 kilograms, so some people may not be able to board if the total weight exceeds this limit. The goal is to identify the name of the last person who can board the bus without exceeding the weight limit.\nOnly one person can board the bus at any given time, based on their turn. Input:\nQueue table:\nperson_id person_name weight turn 5 Alice 250 1 4 Bob 175 5 3 Alex 350 2 6 John Cena 400 3 1 Winston 500 6 2 Marie 200 4 Output:\nperson_name John Cena Explanation:\nThe following table shows the order in which people board the bus, ordered by the turn column for simplicity:\nTurn person_id person_name weight Total Weight 1 5 Alice 250 250 2 3 Alex 350 600 3 6 John Cena 400 1000 4 2 Marie 200 1200 5 4 Bob 175 ___ 6 1 Winston 500 ___ John Cena is the last person who can board the bus without exceeding the weight limit of 1000 kilograms.\nGo to Leetcode 🔗 SHOW CODE MySQL WITH T AS ( SELECT person_name, SUM(weight) OVER (ORDER BY turn) AS acumulated_weight FROM Queue ) SELECT person_name FROM T WHERE acumulated_weight \u003c= 1000 ORDER BY acumulated_weight DESC LIMIT 1; Count Salary Categories SHOW PROBLEM Table: Accounts\nColumn Name Type account_id int income int The account_id column is the primary key, meaning it contains unique values for each row. Each row represents the monthly income of a specific bank account. Task:\nWrite a solution to calculate the number of bank accounts in each salary category. The salary categories are defined as:\n\u0026ldquo;Low Salary\u0026rdquo;: Salaries strictly less than $20,000. \u0026ldquo;Average Salary\u0026rdquo;: Salaries in the inclusive range [$20,000, $50,000]. \u0026ldquo;High Salary\u0026rdquo;: Salaries strictly greater than $50,000. The result table should contain all three categories. If no accounts fall into a category, return 0 for that category.\nThe result can be returned in any order.\nInput:\nAccounts table:\naccount_id income 3 108939 2 12747 8 87709 6 91796 Output:\ncategory accounts_count Low Salary 1 Average Salary 0 High Salary 3 Explanation:\nLow Salary: Account 2 has an income of $12,747, which is below $20,000. Average Salary: There are no accounts with an income between $20,000 and $50,000. High Salary: Accounts 3, 6, and 8 have incomes above $50,000. Go to Leetcode 🔗 SHOW CODE MySQL WITH S AS ( SELECT 'Low Salary' AS category UNION SELECT 'Average Salary' UNION SELECT 'High Salary' ), T AS ( SELECT CASE WHEN income \u003c 20000 THEN 'Low Salary' WHEN income \u003e 50000 THEN 'High Salary' ELSE 'Average Salary' END AS category, COUNT(1) AS accounts_count FROM Accounts GROUP BY category ) SELECT category, IFNULL(accounts_count, 0) AS accounts_count FROM S LEFT JOIN T USING (category); Subqueries Exchange Seats SHOW PROBLEM Table: Seat\nColumn Name Type id int student varchar id is the primary key for this table. Each row represents a student\u0026rsquo;s name and their seat ID. The id starts from 1 and increases consecutively. Problem Description:\nWrite a query to swap the seat IDs of every two consecutive students in the Seat table. If the number of students is odd, the last student\u0026rsquo;s seat ID should remain unchanged.\nThe result should be ordered by the id column in ascending order.\nInput:\nSeat table:\nid student 1 Abbot 2 Doris 3 Emerson 4 Green 5 Jeames Output:\nid student 1 Doris 2 Abbot 3 Green 4 Emerson 5 Jeames Explanation:\nThe students Abbot and Doris swap places, as well as Emerson and Green. Since there are an odd number of students, Jeames\u0026rsquo;s seat remains unchanged. Go to Leetcode 🔗 SHOW CODE MySQL SELECT CASE WHEN id % 2 = 1 AND id \u003c (SELECT MAX(id) FROM Seat) THEN id + 1 WHEN id % 2 = 0 THEN id - 1 ELSE id END AS id, student FROM Seat ORDER BY id; Movie Rating SHOW PROBLEM Table: Movies\nColumn Name Type movie_id int title varchar movie_id is the primary key (column with unique values) for this table. title is the name of the movie.\nTable: Users\nColumn Name Type user_id int name varchar user_id is the primary key (column with unique values) for this table. The column \u0026rsquo;name\u0026rsquo; has unique values.\nTable: MovieRating\nColumn Name Type movie_id int user_id int rating int created_at date (movie_id, user_id) is the primary key (column with unique values) for this table. This table contains the rating of a movie by a user in their review. created_at is the user\u0026rsquo;s review date.\nProblem:\nFind the name of the user who has rated the greatest number of movies. In case of a tie, return the lexicographically smaller user name. Find the movie name with the highest average rating in February 2020. In case of a tie, return the lexicographically smaller movie name. Result format:\nThe result should contain two columns:\nresults – containing the user name with the greatest number of movie ratings. results – containing the movie name with the highest average rating in February 2020. Input:\nMovies table:\nmovie_id title 1 Avengers 2 Frozen 2 3 Joker Users table:\nuser_id name 1 Daniel 2 Monica 3 Maria 4 James MovieRating table:\nmovie_id user_id rating created_at 1 1 3 2020-01-12 1 2 4 2020-02-11 1 3 2 2020-02-12 1 4 1 2020-01-01 2 1 5 2020-02-17 2 2 2 2020-02-01 2 3 2 2020-03-01 3 1 3 2020-02-22 3 2 4 2020-02-25 Output:\nresults Daniel Frozen 2 Explanation:\nDaniel and Monica have rated 3 movies (\u0026ldquo;Avengers\u0026rdquo;, \u0026ldquo;Frozen 2\u0026rdquo; and \u0026ldquo;Joker\u0026rdquo;), but Daniel is lexicographically smaller. \u0026ldquo;Frozen 2\u0026rdquo; and \u0026ldquo;Joker\u0026rdquo; both have an average rating of 3.5 in February, but \u0026ldquo;Frozen 2\u0026rdquo; is lexicographically smaller. Go to Leetcode 🔗 SHOW CODE MySQL ( SELECT name AS results FROM Users JOIN MovieRating USING (user_id) GROUP BY user_id ORDER BY COUNT(1) DESC, name LIMIT 1 ) UNION ALL ( SELECT title FROM MovieRating JOIN Movies USING (movie_id) WHERE DATE_FORMAT(created_at, '%Y-%m') = '2020-02' GROUP BY movie_id ORDER BY AVG(rating) DESC, title LIMIT 1 ); Index In MySQL, an index is a database structure that improves the speed of data retrival operations on a table. Indexes are created on one or more columns of a table and allow the database to quickly locate data without scanning the entire table. Indexes are typically implemented using data structures, with the B+ tree being the most common.\nThere are four main types of indexes in MySQL: primary index, unique index, ordinary index, and full-text index.\nA primary index is a unique index that identifies each row in a table. It is automatically created when a primary key is defined. A unique index ensures that all values in the indexed columns(s) are unique. An ordinary index improves query performance but does not enforce uniqueness. A full-text index is used for full-text searches on text-based columns. SHOW CODE SQL -- Primary Index CREATE TABLE employees ( id INT PRIMARY KEY, -- Primary index name VARCHAR(100) ); -- Unique Index CREATE UNIQUE INDEX idx_email ON employees(email); -- Ordinary Index CREATE INDEX idx_name ON employees(name); -- Full Text Index CREATE FULLTEXT INDEX idx_description ON products(description); SELECT * FROM products WHERE MATCH(description) AGAINST('database'); Clustered Index vs. Secondary Index In MySQL, indexes can be categorized into two types: clustered index and secondary index.\nA clustered index determines the physical order of data rows in a table. The table data is stored in the order of the clustered index. A secondary index does not affect the physical order of data rows in a table. Instead, it stores a separate structure that points to the actual data rows. Clustered Index vs. Secondary Index SHOW CODE SQL CREATE TABLE employees ( id INT PRIMARY KEY, -- Clustered index name VARCHAR(100), salary DECIMAL(10, 2), INDEX idx_name (name) -- Secondary index ); Back-to-Table Queries SQL Performance Analysis:\nSQL Execution Frequency Slow Query Log show profiles explain Stored Procedure A stored procedure is a precompiled SQL code block that is stored in a database and can be executed repeatedly. It is particularly useful in scenarios involving complex SQL logic, as it helps streamline operations, improve performance, and enhance code reusability.\nSHOW CODE SQL -- Create a Stored Procedure: DELIMITER // CREATE PROCEDURE get_all_users() BEGIN SELECT * FROM users; END // DELIMITER ; -- Call a Procedure**: CALL get_all_users(); -- List all procedures show procedure status where db = 'mydatabase'; -- View the specific stored procedure show create procedure get_all_users; -- Delete a Stored Procedure: drop procedure get_all_users; Variables Variables in MySQL can be categorized into four types based on their scope: global, session, user-defined, and local.\nGlobal variables and session variables are used to control server behavior. Global variables affect all sessions connected to the server. Session variables apply only to the current session. User-defined variables are defined within a session and persist until the session ends. Local variables are used within stored procedures and have a scope limited to the procedure in which they are declared. SHOW CODE SQL # Global Variables SET GLOBAL max_connections = 200; -- Session Variables SET SESSION sql_mode = 'STRICT_TRANS_TABLES'; -- User-Defined Variables SET @my_var = 100; SELECT @my_var; -- Local Variables DELIMITER // CREATE PROCEDURE test_proc() BEGIN DECLARE my_local_var INT DEFAULT 10; SELECT my_local_var; END // DELIMITER ; Control Flow Statements MySQL supports various control flow statements, including IF, CASE...WHEN, WHILE, REPEAT, and LOOP.\nSHOW CODE SQL # IF statement DELIMITER // CREATE PROCEDURE check_salary(IN emp_id INT) BEGIN DECLARE emp_salary INT; SELECT salary INTO emp_salary FROM employees WHERE id = emp_id; IF emp_salary \u003e 5000 THEN SELECT 'High Salary'; ELSEIF emp_salary BETWEEN 3000 AND 5000 THEN SELECT 'Medium Salary'; ELSE SELECT 'Low Salary'; END IF; END // DELIMITER ; -- CASE WHEN statement DELIMITER // CREATE PROCEDURE check_grade(IN marks INT) BEGIN DECLARE grade CHAR(1); CASE WHEN marks \u003e= 90 THEN SET grade = 'A'; WHEN marks \u003e= 80 THEN SET grade = 'B'; WHEN marks \u003e= 70 THEN SET grade = 'C'; ELSE SET grade = 'F'; END CASE; SELECT grade; END // DELIMITER ; -- WHILE DELIMITER // CREATE PROCEDURE count_down() BEGIN DECLARE x INT DEFAULT 5; WHILE x \u003e 0 DO SELECT x; SET x = x - 1; END WHILE; END // DELIMITER ; -- REPEAT (similar to do...while in Java) DELIMITER // CREATE PROCEDURE repeat_example() BEGIN DECLARE x INT DEFAULT 1; REPEAT SELECT x; SET x = x + 1; UNTIL x \u003e 5 END REPEAT; END // DELIMITER ; -- LOOP (Use an explicit LEAVE to exit) DELIMITER // CREATE PROCEDURE loop_example() BEGIN DECLARE x INT DEFAULT 1; my_loop: LOOP SELECT x; SET x = x + 1; IF x \u003e 5 THEN LEAVE my_loop; END IF; END LOOP; END // DELIMITER ; Curosor and Handler In MySQL, a cursor is a database object that enables row-by-row processing of a result set. On the other hand, a handler is used to manage exceptions or errors that may occur during execution. Cursors and handlers are commonly used in stored procedures when dealing with result sets that contain multiple rows and require row-by-row processing.\nSHOW CODE SQL DELIMITER // CREATE PROCEDURE fetch_salaries() BEGIN DECLARE done INT DEFAULT 0; DECLARE emp_name VARCHAR(100); DECLARE emp_salary INT; DECLARE emp_cursor CURSOR FOR SELECT name, salary FROM employees; DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1; OPEN emp_cursor; read_loop: LOOP FETCH emp_cursor INTO emp_name, emp_salary; IF done THEN LEAVE read_loop; END IF; SELECT emp_name, emp_salary; END LOOP; CLOSE emp_cursor; END // DELIMITER ; Trigger In MySQL, a trigger is a data object that automatically executes a specified set of sql statements before or after certain events occurred, such as INSERT, UPDATE, or DELETE. It is commonly used in audit logging. MySQL only supports row-level trigger, meaning a trigger is activated FOR EACH ROW affected by INSERT, UPDATE, or DELETE operation.\nSHOW CODE SQL -- Create a trigger CREATE TRIGGER before_employee_update BEFORE UPDATE ON employees FOR EACH ROW BEGIN INSERT INTO audit_log (employee_id, action, change_date) VALUES (OLD.id, 'UPDATE', NOW()); END; -- View triggers SHOW TRIGGERS; SHOW TRIGGERS FROM database_name; -- Delete a trigger DROP TRIGGER IF EXISTS before_employee_update; Locking In MySQL, locking is a mechanism used to control database access, ensuring data integrity and consistency when multiple sessions interact with the databases. MySQL supports three main types of locks: global-level locks, table-level locks, and low-level locks.\nGlobal-Level Lock The global-level lock is a coarse-grained lock that blocks the entire database. It is commonly used during operations like data backups. Due to its coarse granularity, any updates to the database are blocked while the lock is active. Additionally, when the global lock is in place, secondary databases cannot read the binary log (binlog) from the primary database, leading to replication delays between the primary and secondary databases.\nFor InnoDB tables, it is generally recommended to use the --single-transaction option during data backups. This approach ensures data consistency without acquiring a global read lock, allowing updates to continue uninterrupted.\nSHOW CODE SQL -- From mysql client FLUSH TABLES WITH READ LOCK; -- From bash mysqldump -u username -p --single-transaction database_name \u003e backup.sql UNLOCK TABLES; Table-Level Lock The table-level lock is a mechanism that locks an entire table to control database access when multiple sessions interact with the database. There are three main types of table-level locks: table locks, metadata locks, and intention locks.\nTable locks include read locks and write locks: When a session acquires a read lock, other sessions can also read data but cannot modify it. When a session acquire a write lock, other sessions cannot read or write data from the locked table. Metadata lock is a type of lock that protects the structure of a database object when it is being accessed or modified by a session. It it automatically managed by MySQL. There are two main types of metadata locks: shared metadata locks and exclusive metadata locks. Shared metadata locks include SHARED_READ and SHARED_WRITE locks. These are acquired by queries, modification, or transactions. A SHARED_READ lock allows other sessions to read the locked data. A SHARED_WRITE lock allows other sessions to read but not modify the locked data. The exclusive metadata lock is acquired by operations that modify the table\u0026rsquo;s structure, such as ALTER TABLE. It prevents other sessions from accessing the table until the operation completes. An intention lock is a type of lock used by the InnoDB storage engine to indicate a transaction\u0026rsquo;s intention to acquire row-level locks at a finer granularity. It works in conjunction with row-level locks, helping to avoid confilicts between transactions that might lock the same table at different levels (e.g., table-level vs. row-level locks). There are two main types of intention locks: Intention Shared Lock (IS) and Intention Exclusive Lock (IX). The Intention Shared Lock (IS) indicates that a transaction intends to place shared wor-level locks on some rows in the table. It allows other transactions to acquire IS locks or table-level shared locks but blocks table-level exclusive locks. The Intention Exclusive Lock (IX) indicates that a transaction intends to place exlcusive row-level locks on some rows in the table. It allows other transactions to acquire IS locks but blocks table-level shared locks and table-level exclusive locks. Lock Type IS IX S X IS ✅ ✅ ✅ ❌ IX ✅ ✅ ❌ ❌ S (Shared) ✅ ❌ ✅ ❌ X (Exclusive) ❌ ❌ ❌ ❌ SHOW CODE TABLE LOCK META DATA LOCK INTENTION LOCK --- TABLE LOCK --- -- Read lock LOCK TABLES sales READ; SELECT * FROM sales WHERE sale_date = '2023-10-01'; UNLOCK TABLES; -- Write lock LOCK TABLES products WRITE; UPDATE products SET price = price * 1.1; UNLOCK TABLES; --- META DATA LOCK --- -- Session 1 starts a transaction and reads from a table START TRANSACTION; SELECT * FROM employees; -- Session 2 attempts to alter the table ALTER TABLE employees ADD COLUMN salary DECIMAL(10, 2); -- Session 2 will block until Session 1 releases its shared metadata lock -- Session 1 starts an `ALTER TABLE` operation ALTER TABLE employees ADD COLUMN department VARCHAR(50); -- session 2 attempts to query the table SELECT * FROM employees; -- Session 2 will block until Session 1 comoletes the `ALTER TABLE` operation --- INTENSION LOCK --- -- Transaction A -- Transaction A acquires an Intention Shared Lock (IS) on the employees table. -- It then acquires a Shared Row-Level Lock (S) on the row with id = 1. START TRANSACTION; SELECT * FROM employees WHERE id = 1 LOCK IN SHARE MODE; -- Transaction B -- Transaction B acquires an Intention Exclusive Lock (IX) on the employees table. -- It then acquires an Exclusive Row-Level Lock (X) on the row with id = 2. START TRANSACTION; UPDATE employees SET salary = 65000 WHERE id = 2; -- Transaction C -- Transaction C attempts to acquire an Exclusive Table-Level Lock (X) on the employees table. -- It will block until Transaction A and Transaction B release their locks. ALTER TABLE employees ADD COLUMN department VARCHAR(50); Row-Level Lock In MySQL, a row-level lock is a fine-grained locking mechanism that locks individual rows instead of the entire table. There are two main types of row-level locks: Shared Lock and Exclusive Lock.\nA Shared Lock allows other transactions to read the same row but prevents them from modifying it. An **Exclusive Lock prevents other transactions from reading or modifying the same row until the lock is released. Row-level locks are supported by the InnoDB storage engine to ensure data consistency and integrity. They are automatically acquired and released based on the transaction\u0026rsquo;s operations.\nSHOW CODE Shared Lock Exclusive Lock -- Transaction A reads a row with a shared lock START TRANSACTION; SELECT * FROM employees WHERE id = 1 LOCK IN SHARE MODE; -- Transaction B can also reads the same row START TRANSACTION; SELECT * FROM employees WHERE id = 1 LOCK IN SHARE MODE; -- Transaction C cannot modify the same row until the lock is released START TRANSACTION; UPDATE employees SET salary = 55000 WHERE id = 1; -- Blocks -- Transaction A updates a row with an exclusive lock START TRANSACTION; UPDATE employees SET salary = 55000 WHERE id = 1; -- Transaction B cannot read or modify the same row until the lock is released START TRANSACTION; SELECT * FROM employees WHERE id = 1 LOCK IN SHARE MODE; -- Blocks InnoDB provides additional locking mechanisms, such as gap locks and next-key locks, to ensure data consistency and integrity and prevent issues like phantom reads. By default, InnoDB operates at the REPEATABLE READ isolation level, where it uses next-key locks for searches and index scans to avoid phantom reads.\nA gap lock locks the intervals between rows in an index, preventing new rows from being inserted into those gaps. It does not lock the rows themselves but rather the gaps between them. The primary purpose of a gap lock is to prevent other transactions from inseting data into the blocked gap. Gap locks are coexistent, meaning they do not block other transactions from locking the same gap. A next-key lock is a combination of a row lock and a gap lock. It locks both the row and the gap before it. SHOW CODE employees table Gap Lock Next-key Lock | id | name | salary | |-----|-----------|---------| | 1 | John Doe | 50000 | | 3 | Jane Smith| 60000 | | 5 | Alice Lee | 55000 | SELECT * FROM employees WHERE id BETWEEN 2 AND 4 FOR UPDATE; -- The gap lock will be placed on the interval (1, 3) and (3, 5) SELECT * FROM employees WHERE id = 3 FOR UPDATE; -- The next-key lock will be placed on the row with id = 3 and the gap (1, 3) ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/database/2-database-management-system/","summary":"Introduction to DBMS A Database Management System (DBMS) is software that provides an interface for users to interact with databases. It enables the management, storage, and manipulation of data within databases. DBMS can be broadly classified into two main types: Relational DBMS and NoSQL DBMS.\nIn a Relational DBMS, data is stored in structured tables and is manipulated using SQL (Structured Query Language). Examples of relational DBMS inlcude MySQL, Oracle, and PostgreSQL.","title":"Database Management Systems"},{"content":"Introduction to Multithreading Program, Process, and Thread A program is a static set of instructions that stores on a disk. A process is an instance of a program that is currently being executed by the operating system. A thread is a small unit of process that can be scheduled and executed by the operating system. In simpler terms, a program is the code, a process is the excution of the code, a thread is a unit of execution within a process. Their relationships are illustrated in the following image:\nProgram, Process, and Thread Thread Life Cycle Within Concurrency A thread goes through various states in its life cycle, from creation to its termination. The life cycle of a thread typically includes five states: New, Runnable, Running, Blocked/Waiting, and Terminated.\nNew: This refers to the state where a thread instance is created but has not yet started running. In Java, this is commonly achieved by using new Thread(). Runnable: This refers to the state where a thread instance is ready to run but is waiting for CPU time. In Java, this is commonly achieved by ivoking start() on the thread instance. Running: This is refers to the state where the thread instance is actively executing its task. Blocked/Waiting: This refers to the state where a thread instance is waiting for other threads to complete their tasks, or it is waiting for a particular condition to be met. Terminated: This refers to the state where the thread instance has completed its task and has exited. Thread Life Cycle Within Concurrency Fork/Join Model The Fork/Join Model is an effective strategy commonly used in scenarios where a task can be recursively divided into multiple smaller, independent subtasks. This strategy typically involves the following steps:\nThe process begins with a single master thread. When it encounters a task that can be broken down into smaller subtasks, the master thread forks (spawns) multiple subsidiary threads, each of which takes on a portion of the task.\nOnce the subsidiary threads have completed their respective tasks, they join back with the master thread. Joining involves terminating the subsidiary threads and consolidating their results into the master thread. Afterward, the master thread continues its execution.\nFork/Join Model SHOW CODE Java import java.util.Arrays; import java.util.concurrent.RecursiveTask; import java.util.concurrent.ForkJoinPool; public class Solution { // RecursiveTask to compute the sum of a part of an array static class SumTask extends RecursiveTask { private final int[] array; private final int start; private final int end; // Threshold for splitting the task into smaller subtasks private static final int THRESHOLD = 1000; public SumTask(int[] array, int start, int end) { this.array = array; this.start = start; this.end = end; } @Override protected Long compute() { // If the task is small enough, calculate the sum directly if (end - start \u003c= THRESHOLD) { long sum = 0; for (int i = start; i \u003c end; i++) { sum += array[i]; } return sum; } // Otherwise, split the task into two subtasks int middle = (start + end) / 2; SumTask leftTask = new SumTask(array, start, middle); SumTask rightTask = new SumTask(array, middle, end); // Fork the subtasks leftTask.fork(); rightTask.fork(); // Join the results of the subtasks long leftResult = leftTask.join(); long rightResult = rightTask.join(); // Combine the results and return return leftResult + rightResult; } } public static void main(String[] args) { int[] array = new int[10000]; // Initialize all elements to 1 Arrays.fill(array, 1); // Create a ForkJoinPool to execute the tasks ForkJoinPool pool = new ForkJoinPool(); // Submit the task to the ForkJoinPool SumTask task = new SumTask(array, 0, array.length); long result = pool.invoke(task); System.out.println(\"Sum: \" + result); // Output the result } } SHOW OUTPUT Output Sum: 10000 Critical Section \u0026amp; Race Condition Critical Section refers to a portion of a program where shared resources are accessed and modified. A Race Condition occurs when the program\u0026rsquo;s behavior depends on the non-deterministic execution order of threads. Since multiple threads can access a critical section concurrently, it is essential to synchronize their access to avoid data inconsistency.\nFor example, suppose there are four threads trying to read a value of 20 from memory. Each thread increments the value by 1 and writes it back to memory. Without synchronization mechanisms, after all threads complete their writes, the final value might be 21 instead of the expected 24. This leads to an unexpected outcome, as illustrated below.\nCritical Section \u0026amp; Race Condition To resolve this issue, access to the critical section must be exclusive. This is commonly achieved by using mutexes, read/write locks, semaphores, conditional variables or barriers to ensure that only one thread can modify the shared resource at a time.\nSynchronization Mechanisms Synchronization Mechanisms are rules used to coordinate the execution of threads in a program, ensuring safe access to shared resources. These mechanisms can be primarily classified into five types: Mutexes, Read/Write Locks, Semaphores, Conditional Variables, and Barriers.\nMutex Mechanism The mutex mechanism ensures that only one thread can access the critical section at a time. Other threads will be blocked until the mutex is released. The key logic behind the mutex mechanism is as follows:\nLock lock = new ReentrantLock(); lock.lock(); // Acquire the lock try { // Critical section code } finally { lock.unlock(); // Release the lock } Mutex Mechanism SHOW CODE Java public class Mutex { private static int counter = 0; private static final Object lock = new Object(); public static void runExperiment(String experimentName, Runnable task) { counter = 0; Thread t1 = new Thread(task); Thread t2 = new Thread(task); t1.start(); t2.start(); try { t1.join(); t2.join(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"Final counter value \" + experimentName + \": \" + counter + \"\"); } public static void incrementCounterWithMutex() { for (int i = 0; i \u003c 100; i++) { synchronized (lock) { int temp = counter; try { Thread.sleep(1); // Sleep for 1 millisecond } catch (InterruptedException e) { e.printStackTrace(); } counter = temp + 1; } } } public static void incrementCounterNoMutex() { for (int i = 0; i \u003c 100; i++) { int temp = counter; try { Thread.sleep(1); // Sleep for 1 millisecond } catch (InterruptedException e) { e.printStackTrace(); } counter = temp + 1; } } public static void main(String[] args) { runExperiment(\"With Mutex Experiment\", Mutex::incrementCounterWithMutex); runExperiment(\"No Mutex Experiment\", Mutex::incrementCounterNoMutex); } } SHOW OUTPUT Output Final counter value With Mutex Experiment: 200 Final counter value No Mutex Experiment: 100 Read/Write Lock Mechanism The Read/Write Lock Mechanism allows threads read the shared resources concurrently, but ensures exclusive access for write operations. This mechanism is useful in scenarios where there are many read operations and fewer write operations, such as caching systems or databases. The key logic behind the read/write lock mechanism is as follows:\nReadWriteLock rwLock = new ReentrantReadWriteLock(); rwLock.readLock().lock(); // Acquire read lock try { // Read operation } finally { rwLock.readLock().unlock(); // Release read lock } rwLock.writeLock().lock(); // Acquire write lock try { // Write operation } finally { rwLock.writeLock().unlock(); // Release write lock } Under the Read/Write Lock mechanism, multiple threads can access the critical section simultaneously without blocking each other. When a writer thread is accessing the critical section, other writer threads and reader threads are blocked. Similarly, when a reader thread is accessing the critical section, the writer thread is blocked.\nRead/Write Lock Mechanism SHOW CODE Java import java.util.ArrayList; import java.util.List; import java.util.concurrent.locks.ReentrantReadWriteLock; public class ReadWriteLock { private static volatile int counter = 0; private static final int TARGET_VALUE = 1000; private static final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(); public static int incrementValue() { lock.writeLock().lock(); try { Thread.sleep(1); if (counter \u003c TARGET_VALUE) { counter++; } } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.writeLock().unlock(); } return counter; } public static int readValue() { lock.readLock().lock(); try { Thread.sleep(1); return counter; } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.readLock().unlock(); } return 0; } public static void main(String[] args) { long start = System.currentTimeMillis(); List readers = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u003c 8; i++) { readers.add(new Thread(() -\u003e { while (readValue() \u003c TARGET_VALUE) { try { Thread.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } } })); } List writers = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u003c 2; i++) { writers.add(new Thread(() -\u003e { while (incrementValue() \u003c TARGET_VALUE) { try { Thread.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } } })); } readers.forEach(Thread::start); writers.forEach(Thread::start); readers.forEach(t -\u003e { try { t.join(); } catch (InterruptedException e) { e.printStackTrace(); } }); writers.forEach(t -\u003e { try { t.join(); } catch (InterruptedException e) { e.printStackTrace(); } }); long end = System.currentTimeMillis(); System.out.println(\"Time taken: \" + (end - start) / 1000.0 + \" seconds\"); } } SHOW OUTPUT Output Time taken: 1.787 seconds In the above code, the readValue method uses a read lock, allowing multiple reader threads to access the counter (critical section) simultaneously without blocking each other. If the method used a write lock instead of a read lock, the execution time would be higher. This is because when a writer thread is accessing the counter, all other threads would be blocked.\npublic static int readValue() { // lock.readLock().lock(); lock.writeLock().lock(); try { Thread.sleep(1); return counter; } catch (InterruptedException e) { e.printStackTrace(); } finally { // lock.readLock().unlock(); lock.writeLock().unlock(); } return 0; } Time taken: 6.793 seconds # Use write lock Semaphore Mechanism The Semaphore mechanism uses an integer to manage a set of permits, allowing multiple threads to access shared resources simultaneously, but only up to a predetermined limit. There are two types of semaphores: Binary Semaphore and Counting Semaphore.\nBinary Semaphore: Similar to a mutex, it operates with two states (0 and 1), ensuring mutual exclusion in critical sections. Counting Semaphore: Allows a count greater than 1, permitting multiple threads to access shared resources concurrently, as long as the permit limit is not exceeded. Semaphores are useful in controlling access to a pool of resources, such as limiting the number of threads that can access a database connection or a server. The key logic behind the semaphore mechanism is as follows:\nSemaphore semaphore = new Semaphore(3); // Allow 3 threads at once semaphore.acquire(); // Acquire a permit try { // Critical section code } finally { semaphore.release(); // Release a permit } Semaphore Mechanism SHOW CODE Java import java.util.concurrent.Semaphore; import java.util.concurrent.atomic.AtomicInteger; public class SemaphoreTest { // Global shared resource // AtomicInteger allows multiple threads to read/write value of counter without requiring synchronization private static final AtomicInteger counter = new AtomicInteger(0); // Semaphore with a count of 5 private static final Semaphore semaphore = new Semaphore(5); private static final int TARGET_VALUE = 5000; public static void main(String[] args) { long startTime = System.currentTimeMillis(); Thread[] workers = new Thread[10]; for (int i = 0; i \u003c workers.length; i++) { workers[i] = new Thread(SemaphoreTest::worker); workers[i].start(); } for (Thread worker : workers) { try { worker.join(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); System.out.println(\"Thread was interrupted\"); } } long endTime = System.currentTimeMillis(); System.out.println(\"Time taken: \" + (endTime - startTime) / 1000.0 + \" seconds\"); } private static void worker() { while (true) { try { semaphore.acquire(); // Acquire the semaphore if (counter.get() \u003e= TARGET_VALUE) { break; } counter.incrementAndGet(); // Atomically increments the counter Thread.sleep(1); // Simulate work } catch (InterruptedException e) { Thread.currentThread().interrupt(); System.out.println(\"Thread was interrupted\"); } finally { semaphore.release(); // Release the semaphore } } } } Conditional Variable Mechanism The Conditional Variable Mechanism allows a thread to suspend its execution until other threads signal that a certain condition has been met. It is often used in conjunction with mutexes to implement synchronization patterns, such as the producer-consumer pattern.\nIn this mechanism, a thread can wait on a condition variable until it is notified by other threads that the condition has been satisfied. When the condition is fulfilled, one or more threads can be signaled to wake up and proceed. Condition variables are commonly used in scenarios like the producer-consumer problem, where one thread produces data and another consumes it, with both threads needing to wait for each other under specific conditions.\nThe key logic behind the Conditional Variable Mechanism is as follows:\nsynchronized (lock) { while (!condition) { lock.wait(); // Wait until condition is true } // Proceed with critical section } synchronized (lock) { condition = true; lock.notify(); // Notify waiting threads } Conditional Variable Mechanism SHOW CODE Wait \u0026amp; Notify Busy Waiting public class ConditionalVariable { private static final Object mutex = new Object(); private static int sharedNumber; private static boolean ready = false; public static void producer() { synchronized (mutex) { sharedNumber = 9; // Producing a number ready = true; System.out.println(\"Producer has produced the number: \" + sharedNumber); mutex.notify(); // Notify the consumer } } public static void consumer() { synchronized (mutex) { while (!ready) { try { mutex.wait(); // Wait until the number is ready } catch (InterruptedException e) { Thread.currentThread().interrupt(); System.out.println(\"Consumer thread was interrupted.\"); } } System.out.println(\"Consumer has consumed the number: \" + sharedNumber); } } public static void main(String[] args) { Thread producerThread = new Thread(ConditionalVariable::producer); Thread consumerThread = new Thread(ConditionalVariable::consumer); producerThread.start(); consumerThread.start(); try { producerThread.join(); consumerThread.join(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); System.out.println(\"Main thread was interrupted.\"); } } } public class Solution { private static final Object mutex = new Object(); private static int sharedNumber; private static boolean ready = false; private static void producer() { synchronized (mutex) { sharedNumber = 9; // Producing a number ready = true; System.out.println(\"Producer has produced the number: \" + sharedNumber); } } private static void consumer() { // Busy waiting loop while (true) { synchronized (mutex) { if (ready) { System.out.println(\"Consumer has consumed the number: \" + sharedNumber); break; } } try { Thread.sleep(1); // Sleep for a short time } catch (InterruptedException e) { Thread.currentThread().interrupt(); System.out.println(\"Thread was interrupted\"); } } } public static void main(String[] args) { Thread producerThread = new Thread(Solution::producer); Thread consumerThread = new Thread(Solution::consumer); producerThread.start(); consumerThread.start(); try { producerThread.join(); consumerThread.join(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); System.out.println(\"Main thread was interrupted\"); } } } Barrier Mechanism The Barrier Mechanism allows threads to wait for each other at a specified point in their execution. It ensures that threads cannot proceed to the subsequent code until all threads have reached the barrier, as illustrated in the following image.\nBarrier Mechanism Barrier Mechanism are useful in parallel algorithms where multiple threads need to work in phases, and the next phase cannot begin until all threads complete the current one.\nThe key logic behind this mechanism is as follows:\nCyclicBarrier barrier = new CyclicBarrier(4, new Runnable() { public void run() { System.out.println(\u0026#34;All threads reached the barrier!\u0026#34;); } }); // Threads: barrier.await(); // Wait at the barrier SHOW CODE Java import java.util.concurrent.CyclicBarrier; class Barriers { private static final CyclicBarrier barrier = new CyclicBarrier(2, () -\u003e System.out.println(\"All threads have reached the barrier. Continue execution.\")); public static void main(String[] args) { Thread t1 = new Thread(Barriers::work); Thread t2 = new Thread(Barriers::work); // Start both threads. t1.start(); t2.start(); } private static void work() { System.out.println(\"Thread \" + Thread.currentThread().getName() + \" is waiting at the barrier\"); try { // Wait for the specified number of threads (2 in this case) to reach the barrier. barrier.await(); System.out.println(\"Thread \" + Thread.currentThread().getName() + \" is released\"); } catch (Exception e) { // Handle exceptions, if any. } } } SHOW OUTPUT Output Thread Thread-0 is waiting at the barrier Thread Thread-1 is waiting at the barrier All threads have reached the barrier. Continue execution. Thread Thread-1 is released Thread Thread-0 is released Thread Creation In Java Extending Thread Class SHOW CODE Java class MyThread extends Thread { @Override public void run() { System.out.println(this.getName() + \" is running.\"); } } public class Main { public static void main(String[] args) { MyThread myThread = new MyThread(); myThread.setName(\"MYTHREAD-0\"); myThread.start(); } } Implementing Runnable Interface SHOW CODE Java public class Main { public static void main(String[] args) { Thread thread = new Thread(() -\u003e System.out.println(Thread.currentThread().getName() + \" is running.\")); thread.start(); } } //class MyRunnable implements Runnable { // @Override // public void run() { // System.out.println(\"Thread is running\"); // } //} // //public class Main { // public static void main(String[] args) { // Thread thread = new Thread(new MyRunnable()); // thread.start(); // Starts a new thread // } //} Using the Callable Interface SHOW CODE Java import java.util.concurrent.*; public class Main { public static void main(String[] args) throws Exception { ExecutorService executor = Executors.newSingleThreadExecutor(); Future\u0026lt;String\u0026gt; future = executor.submit(() -\u003e Thread.currentThread().getName() + \" is running.\"); System.out.println(future.get()); executor.shutdown(); } } class MyCallable implements Callable\u0026lt;String\u0026gt; { // @Override // public String call() { // return \"Thread executed\"; // } //} // //public class Main { // public static void main(String[] args) throws Exception { // ExecutorService executor = Executors.newSingleThreadExecutor(); // Future\u0026lt;String\u0026gt; future = executor.submit(new MyCallable()); // System.out.println(future.get()); // Retrieves the result // executor.shutdown(); // } //} Using Executors SHOW CODE Java import java.util.concurrent.*; public class Main { public static void main(String[] args) { ExecutorService executor = Executors.newFixedThreadPool(2); Runnable task1 = () -\u003e System.out.println(Thread.currentThread().getName() + \" executed\"); Runnable task2 = () -\u003e System.out.println(Thread.currentThread().getName() + \" executed\"); executor.execute(task1); executor.execute(task2); executor.shutdown(); } } Thread Termination In Java Using a flag SHOW CODE Java class Task implements Runnable { // Use volatile to ensure visibility between thread private volatile boolean running = true; @Override public void run() { while (running) { System.out.println(\"Thread is running.\"); try { Thread.sleep(1000); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } System.out.println(\"Thread is stopping.\"); } public void stop() { running = false; } } public class Main { public static void main(String[] args) throws InterruptedException { Task task = new Task(); Thread thread = new Thread(task); thread.start(); Thread.sleep(3000); // Allow thread to run for a while task.stop(); // Signal thread to stop } } Interrupting a Thread SHOW CODE Java public class Main { public static void main(String[] args) throws InterruptedException { Thread thread = new Thread(() -\u003e { try { while (!Thread.currentThread().isInterrupted()) { System.out.println(\"Thread is running\"); Thread.sleep(1000); } } catch (InterruptedException e) { System.out.println(\"Thread is interrupted\"); } }); thread.start(); Thread.sleep(3000); // Allow thread to run for a while thread.interrupt(); // Interrupt the thread } } Daemon Threads A daemon thread in Java is a low-priority thread that runs in the background, typically handling tasks such as garbage collection or other housekeeping operations. The JVM terminates when all non-daemon threads have completed execution, even if daemon threads are still active. To create a daemon thread, the setDaemon(true) method is used on a Thread object before it is started.\nSHOW CODE Java public class Main { public static void main(String[] args) { Thread daemonThread = new Thread(() -\u003e { while (true) { System.out.println(\"Daemon thread is running\"); try { Thread.sleep(1000); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } }); daemonThread.setDaemon(true); // Mark as daemon daemonThread.start(); System.out.println(\"Main thread is ending\"); } } SHOW OUTPUT Output Main thread is ending Daemon thread is running Performance Optimization When it comes to multithreading, performance optimization typically focuses on two key areas: latency reduction and throughput improvement.\nLatency reduction refers to minimizing the time it takes to complete a single task, measured in time units. This is often achieved by breaking a task into smaller subtasks that can be executed concurrently by multiple threads.\nThroughput, on the other hand, measures the number of tasks completed within a specific time frame, typically expressed as tasks / time unit. Throughput improvement is commonly achieved by utilizing thread pooling, which reduces the overhead of creating and destroying threads for each task.\nSHOW CODE: Latency Reduction Java import javax.imageio.ImageIO; import java.awt.image.BufferedImage; import java.io.File; import java.io.IOException; import java.util.ArrayList; import java.util.List; public class Main { private static final String SOURCE_FILE = \"src/main/resources/1-flower.jpg\"; private static final String DESTINATION_FILE = \"./out/1-flower.jpg\"; public static void main(String[] args) throws IOException { BufferedImage originalImage = ImageIO.read(new File(SOURCE_FILE)); BufferedImage resultImage = new BufferedImage(originalImage.getWidth(), originalImage.getHeight(), BufferedImage.TYPE_INT_RGB); long startTime = System.currentTimeMillis(); // recolorSingleThreaded(originalImage, resultImage); int numberOfThreads = 1; recolorMultithreaded(originalImage, resultImage, numberOfThreads); long endTime = System.currentTimeMillis(); long duration = endTime - startTime; File outputFile = new File(DESTINATION_FILE); File parentDir = outputFile.getParentFile(); if (parentDir != null \u0026\u0026 !parentDir.exists()) { parentDir.mkdirs(); // Create the directory if it doesn't exist } ImageIO.write(resultImage, \"jpeg\", outputFile); System.out.println(\"duration = \" + duration); } public static void recolorMultithreaded(BufferedImage originalImage, BufferedImage resultImage, int numberOfThreads) { List\u0026lt;Thread\u0026gt; threads = new ArrayList\u0026lt;\u0026gt;(); int width = originalImage.getWidth(); int height = originalImage.getHeight() / numberOfThreads; for(int i = 0; i \u003c numberOfThreads ; i++) { final int threadMultiplier = i; Thread thread = new Thread(() -\u003e { int xOrigin = 0 ; int yOrigin = height * threadMultiplier; recolorImage(originalImage, resultImage, xOrigin, yOrigin, width, height); }); threads.add(thread); } for(Thread thread : threads) { thread.start(); } for(Thread thread : threads) { try { thread.join(); } catch (InterruptedException e) { } } } private static void recolorSingleThreaded(BufferedImage originalImage, BufferedImage resultImage) { recolorImage(originalImage, resultImage, 0, 0, originalImage.getWidth(), originalImage.getHeight()); } private static void recolorImage(BufferedImage originalImage, BufferedImage resultImage, int leftCorner, int topCorner, int width, int height) { for (int x = leftCorner; x \u003c leftCorner + width \u0026\u0026 x \u003c originalImage.getWidth(); x++) { for (int y = topCorner; y \u003c topCorner + height \u0026\u0026 y \u003c originalImage.getHeight(); y++) { recolorPixel(originalImage, resultImage, x, y); } } } private static void recolorPixel(BufferedImage originalImage, BufferedImage resultImage, int x, int y) { int rgb = originalImage.getRGB(x, y); int red = getRed(rgb); int green = getGreen(rgb); int blue = getBlue(rgb); int newRed; int newGreen; int newBlue; if (isShadeOfGray(red, green, blue)) { newRed = Math.min(255, red + 10); newGreen = Math.max(0, green - 80); newBlue = Math.max(0, blue - 20); } else { newRed = red; newGreen = green; newBlue = blue; } int newRGB = createRGBFromColors(newRed, newGreen, newBlue); setRGB(resultImage, x, y, newRGB); } public static void setRGB(BufferedImage image, int x, int y, int rgb) { image.getRaster().setDataElements(x, y, image.getColorModel().getDataElements(rgb, null)); } public static boolean isShadeOfGray(int red, int green, int blue) { return Math.abs(red - green) \u003c 30 \u0026\u0026 Math.abs(red - blue) \u003c 30 \u0026\u0026 Math.abs(green - blue) \u003c 30; } public static int createRGBFromColors(int red, int green, int blue) { int rgb = 0; rgb |= blue; rgb |= green \u003c\u003c 8; rgb |= red \u003c\u003c 16; rgb |= 0xFF000000; return rgb; } public static int getRed(int rgb) { return (rgb \u0026 0x00FF0000) \u003e\u003e 16; } public static int getGreen(int rgb) { return (rgb \u0026 0x0000FF00) \u003e\u003e 8; } public static int getBlue(int rgb) { return rgb \u0026 0x000000FF; } } SHOW IMAGE: BEFORE PROCESSING SHOW IMAGE: AFTER PROCESSING Single Threaded VS. Multithreaded SHOW CODE: Throughput vs. Threads Throughput vs. Threads import com.sun.net.httpserver.HttpExchange; import com.sun.net.httpserver.HttpHandler; import com.sun.net.httpserver.HttpServer; import java.io.IOException; import java.io.OutputStream; import java.net.InetSocketAddress; import java.nio.file.Files; import java.nio.file.Paths; import java.util.concurrent.Executor; import java.util.concurrent.Executors; public class ThroughputHttpServer { private static final String INPUT_FILE = \"./resources/war_and_peace.txt\"; private static final int NUMBER_OF_THREADS = 8; public static void main(String[] args) throws IOException { String text = new String(Files.readAllBytes(Paths.get(INPUT_FILE))); startServer(text); } public static void startServer(String text) throws IOException { HttpServer server = HttpServer.create(new InetSocketAddress(8000), 0); server.createContext(\"/search\", new WordCountHandler(text)); Executor executor = Executors.newFixedThreadPool(NUMBER_OF_THREADS); server.setExecutor(executor); server.start(); } private static class WordCountHandler implements HttpHandler { private String text; public WordCountHandler(String text) { this.text = text; } @Override public void handle(HttpExchange httpExchange) throws IOException { String query = httpExchange.getRequestURI().getQuery(); String[] keyValue = query.split(\"=\"); String action = keyValue[0]; String word = keyValue[1]; if (!action.equals(\"word\")) { httpExchange.sendResponseHeaders(400, 0); return; } long count = countWord(word); byte[] response = Long.toString(count).getBytes(); httpExchange.sendResponseHeaders(200, response.length); OutputStream outputStream = httpExchange.getResponseBody(); outputStream.write(response); outputStream.close(); } private long countWord(String word) { long count = 0; int index = 0; while (index \u003e= 0) { index = text.indexOf(word, index); if (index \u003e= 0) { count++; index++; } } return count; } } } SHOW IMAGE: Throughput VS. Threads Problems Linear Search with Finding One Occurrence SHOW PROBLEM Problem Statement:\nThe input consists of a large array (or list) of elements and a target value to search for. The goal is to utilize multiple threads to divide the search space and concurrently search for the target value, ultimately returning the index of the first occurrence of the target or -1 indicating that the target is not present.\nRequirements:\nMultithreading: Divide the array into multiple segments, with each thread searching a specific segment of the array. Each thread should operate independently and search its assigned segment. Return First Occurrence: Once the target value is found by any thread, it should return the index of the first occurrence, and other threads should stop searching. Constraints:\nThe array can be large (millions of elements). The number of threads used should be adjustable. The target value may appear multiple times in the array, but only the index of the first occurrence should be returned. SHOW CODE Java public class Solution { private static final int SIZE = 280000; private static final int NUM_THREADS = 4; private static final Object mtx = new Object(); // Mutex for controlling access to foundIndex private static volatile int foundIndex = -1; private static void linearSearch(int threadId, int[] arr, int key) { int chunkSize = arr.length / NUM_THREADS; int start = threadId * chunkSize; int end = (threadId == NUM_THREADS - 1) ? arr.length : start + chunkSize; for (int i = start; i \u003c end; ++i) { // Early exit if foundIndex is set by another thread synchronized (mtx) { if (foundIndex != -1) { break; } } if (arr[i] == key) { synchronized (mtx) { if (foundIndex == -1) { foundIndex = i; break; // Exit after setting foundIndex } } } } } public static void main(String[] args) { // Fill array with random numbers between 0-99 int[] arr = new int[SIZE]; for (int i = 0; i \u003c SIZE; ++i) { arr[i] = (int) (Math.random() * 100); } Thread[] threads = new Thread[NUM_THREADS]; int key = 9; for (int i = 0; i \u003c NUM_THREADS; ++i) { final int threadId = i; threads[i] = new Thread(() -\u003e linearSearch(threadId, arr, key)); threads[i].start(); } for (Thread thread : threads) { try { thread.join(); } catch (InterruptedException e) { e.printStackTrace(); } } if (foundIndex == -1) { System.out.println(\"Element not found in the array.\"); } else { System.out.println(\"Element found at index: \" + foundIndex); } } } Linear Search for All Occurrences SHOW PROBLEM Problem Statement:\nThe input consists of a large array (or list) of elements and a target value to search for. The goal is to utilize multiple threads to divide the search space and concurrently search for the target value, ultimately returning the index of all occurrences of the target or an empty list indicating that the target is not present.\nRequirements:\nMultithreading: Divide the array into multiple segments, with each thread searching a specific segment of the array. Each thread should operate independently and search its assigned segment. Return All Occurrences: Once the target value is found, the thread should store the index. All threads should continue searching, and their results (all indices of the target’s occurrences) should be combined and returned. Constraints:\nThe array can be large (millions of elements). The number of threads used should be adjustable. The target value may appear multiple times in the array, and all indices where the target is found should be returned. SHOW CODE Java import java.util.ArrayList; import java.util.List; import java.util.Random; public class Solution { private static final int SIZE = 4000; private static final int NUM_THREADS = 4; // Mutex for controlling access to foundPlaces private static final Object lockObj = new Object(); private static List\u0026lt;Integer\u0026gt; foundPlaces = new ArrayList\u0026lt;\u0026gt;(); private static void linearSearch(int threadId, int[] arr, int key) { int chunkSize = arr.length / NUM_THREADS; int start = threadId * chunkSize; int end = (threadId == NUM_THREADS - 1) ? arr.length : start + chunkSize; for (int i = start; i \u003c end; ++i) { if (arr[i] == key) { synchronized (lockObj) { // Lock when modifying foundPlaces foundPlaces.add(i); // Append the index to foundPlaces } } } } public static void main(String[] args) { // Create an array and fill it with random numbers between 0 and 99 int[] arr = new int[SIZE]; Random random = new Random(); for (int i = 0; i \u003c SIZE; ++i) { arr[i] = random.nextInt(100); } Thread[] threads = new Thread[NUM_THREADS]; // List to hold the threads int key = 9; // Element to find // Start the threads for (int i = 0; i \u003c NUM_THREADS; ++i) { final int threadId = i; threads[i] = new Thread(() -\u003e linearSearch(threadId, arr, key)); threads[i].start(); } // Join the threads with the main thread for (Thread thread : threads) { try { thread.join(); } catch (InterruptedException e) { e.printStackTrace(); } } // Display the result if (foundPlaces.isEmpty()) { System.out.println(\"Element not found in the array.\"); } else { System.out.print(\"Element found at indices: \"); synchronized (lockObj) { // Lock when reading from foundPlaces for (int index : foundPlaces) { System.out.print(index + \" \"); } } System.out.println(); } } } SHOW NOTES The synchonization block can be removed when reading values from foundPlaces, as no threads modify the foundPlaces after the join() method is called.\n// Display the result if (foundPlaces.isEmpty()) { System.out.println(\u0026#34;Element not found in the array.\u0026#34;); } else { System.out.print(\u0026#34;Element found at indices: \u0026#34;); // No need for synchronization here, as no threads are modifying foundPlaces now // synchronized (lockObj) { // Lock when reading from foundPlaces for (int index : foundPlaces) { System.out.print(index + \u0026#34; \u0026#34;); } // } System.out.println(); } Linear Search with Indices and Occurrences SHOW PROBLEM Problem Statement:\nYou are given a large array (or list) of elements and a target value to search for. Your task is to implement a linear search that finds all occurrences of the target value in the array using multiple threads. Each thread should search a specific segment of the array, and the results (indices where the target is found) should be stored in a shared collection (e.g., a list). Additionally, a shared variable should keep track of the count of occurrences of the target value.\nRequirements:\nMultithreading: Divide the array into equal segments based on the number of threads. Each thread should independently search its assigned segment for the target value. The number of threads should be adjustable to optimize performance depending on the size of the array. Return: A list of integers representing the indices of all occurrences of the target value. An integer representing the total count of occurrences of the target value. Constraints:\nThe array can be very large, potentially containing millions of elements. The number of threads used should be adjustable, allowing the program to scale with the size of the array and the system\u0026rsquo;s available resources. The target value may appear multiple times, and all occurrences should be included in the final result. SHOW CODE Java import java.util.ArrayList; import java.util.List; import java.util.Random; public class Solution { private static final int SIZE = 4000; private static final int NUM_THREADS = 4; private static final List\u0026lt;Integer\u0026gt; foundIndices = new ArrayList\u0026lt;\u0026gt;(); // Shared list to store the indices of all occurrences private static int occurrencesCount = 0; // Shared variable to store the count of occurrences private static final Object indicesLock = new Object(); // Lock for synchronizing access to foundIndices private static final Object countLock = new Object(); // Lock for synchronizing access to occurrencesCount // Function executed by each thread to search for indices and occurrences private static void searchIndicesOccurrences(int threadId, int[] arr, int key) { int chunkSize = arr.length / NUM_THREADS; int start = threadId * chunkSize; int end = (threadId == NUM_THREADS - 1) ? arr.length : start + chunkSize; List\u0026lt;Integer\u0026gt; localIndices = new ArrayList\u0026lt;\u0026gt;(); int localCount = 0; for (int i = start; i \u003c end; ++i) { if (arr[i] == key) { localIndices.add(i); localCount++; } } if (!localIndices.isEmpty()) { synchronized (indicesLock) { foundIndices.addAll(localIndices); } } if (localCount \u003e 0) { synchronized (countLock) { occurrencesCount += localCount; } } } public static void main(String[] args) { // Create an array and fill it with random numbers between 0 and 99 int[] arr = new int[SIZE]; Random random = new Random(); for (int i = 0; i \u003c SIZE; ++i) { arr[i] = random.nextInt(100); } Thread[] threads = new Thread[NUM_THREADS]; // Array of threads int key = 9; // Element to find // Start the threads for (int i = 0; i \u003c NUM_THREADS; ++i) { int threadId = i; threads[i] = new Thread(() -\u003e searchIndicesOccurrences(threadId, arr, key)); threads[i].start(); } // Wait for all threads to complete for (Thread thread : threads) { try { thread.join(); } catch (InterruptedException e) { e.printStackTrace(); } } // Output the results if (foundIndices.isEmpty()) { System.out.println(\"Element not found in the array.\"); } else { System.out.print(\"Element found \" + occurrencesCount + \" times at indices: \"); for (int index : foundIndices) { System.out.print(index + \" \"); } System.out.println(); } } } Min/Max/Sum SHOW PROBLEM Problem Statement:\nThe input consists of a large array (or list) of elements. The goal is to efficiently calculate the minimum, maximum, and sum of elements in the array using multithreading. The array is divided into multiple segments, with each thread processing a specific segment. The threads will then return partial results (minimum, maximum, and sum for their respective segments), which will be combined to compute the final values for the entire array.\nRequirements:\nMultithreading: Divide the array into multiple segments, with each thread processing a specific portion of the array. Each thread should independently compute the minimum, maximum, and sum for its assigned segment.\nCombine Results: Once each thread has finished processing, their partial results (min, max, and sum for the segment) should be combined to compute the final minimum, maximum, and sum for the entire array.\nEfficiency: The program should use multithreading to optimize the processing time, especially when dealing with large arrays containing millions of elements. The number of threads should be adjustable for optimal performance.\nConstraints:\nThe array can be large (millions of elements).\nThe number of threads used should be adjustable based on the size of the array and the system’s capabilities.\nThe array can contain both positive and negative numbers, and the minimum, maximum, and sum should be computed accurately, including for arrays with all negative values.\nSHOW CODE Java import java.util.Random; public class Solution { private static final int DATA_SIZE = 100; private static final int NUMBER_OF_THREADS = 4; private static int[] data = new int[DATA_SIZE]; private static int[] threadResultsSum = new int[NUMBER_OF_THREADS]; private static int[] threadResultsMin = new int[NUMBER_OF_THREADS]; private static int[] threadResultsMax = new int[NUMBER_OF_THREADS]; public static void main(String[] args) throws InterruptedException { // Initialize data array Random random = new Random(); for (int i = 0; i \u003c DATA_SIZE; i++) { data[i] = random.nextInt(500); } Thread[] threads = new Thread[NUMBER_OF_THREADS * 3]; // Start threads for sum, min, and max calculations for (int i = 0; i \u003c NUMBER_OF_THREADS; i++) { final int threadId = i; final int start = threadId * (DATA_SIZE / NUMBER_OF_THREADS); final int end = (threadId + 1) * (DATA_SIZE / NUMBER_OF_THREADS); threads[threadId] = new Thread(() -\u003e threadedSum(threadId, start, end)); threads[threadId + NUMBER_OF_THREADS] = new Thread(() -\u003e threadedMin(threadId, start, end)); threads[threadId + NUMBER_OF_THREADS * 2] = new Thread(() -\u003e threadedMax(threadId, start, end)); threads[threadId].start(); threads[threadId + NUMBER_OF_THREADS].start(); threads[threadId + NUMBER_OF_THREADS * 2].start(); } // Wait for threads to finish for (Thread thread : threads) { thread.join(); } // Aggregate results from threads int totalSum = 0; for (int sum : threadResultsSum) { totalSum += sum; } int min = Integer.MAX_VALUE; for (int minResult : threadResultsMin) { min = Math.min(min, minResult); } int max = Integer.MIN_VALUE; for (int maxResult : threadResultsMax) { max = Math.max(max, maxResult); } System.out.println(\"Sum is \" + totalSum); System.out.println(\"Min is \" + min); System.out.println(\"Max is \" + max); } private static void threadedSum(int threadId, int start, int end) { int sum = 0; for (int i = start; i \u003c end; i++) { sum += data[i]; } threadResultsSum[threadId] = sum; } private static void threadedMin(int threadId, int start, int end) { int min = Integer.MAX_VALUE; for (int i = start; i \u003c end; i++) { min = Math.min(min, data[i]); } threadResultsMin[threadId] = min; } private static void threadedMax(int threadId, int start, int end) { int max = Integer.MIN_VALUE; for (int i = start; i \u003c end; i++) { max = Math.max(max, data[i]); } threadResultsMax[threadId] = max; } } Pi Calculation SHOW PROBLEM Problem Statement\nThe problem is to estimate the value of Pi using the Monte Carlo simulation method. In this method, we randomly generate points within a square and check how many of these points fall inside a circle inscribed within the square. The ratio of points inside the circle to the total points generated provides an approximation of Pi.\nRequirements:\nRandom Point Generation:\nGenerate a large number of random points within a square. The square should have side lengths of 2 (i.e., points with coordinates ranging from -1 to 1 on both the x and y axes). Each point has coordinates $(x, y)$, where $x$ and $y$ are randomly generated floating-point values between -1 and 1. Circle Inside the Square:\nA circle is inscribed within the square, with a radius of 1 and centered at the origin (0, 0). A point $(x, y)$ lies inside the circle if the following condition is true: $$ x^2 + y^2 \\leq 1 $$ Monte Carlo Estimation of Pi:\nCount how many of the generated points fall inside the circle. The ratio of the points inside the circle to the total number of points can be used to estimate Pi. Specifically, the approximation of Pi is given by: $$ \\pi \\approx 4 \\times \\frac{\\text{points inside the circle}}{\\text{total number of points}} $$ Multithreading:\nTo speed up the simulation, divide the task of generating points and checking whether they lie inside the circle into multiple threads. Each thread should be responsible for generating a subset of points and counting how many fall inside the circle. Once all threads finish their work, their results should be combined to compute the final approximation of Pi. Output:\nReturn the estimated value of Pi based on the simulation. Constraints:\nThe number of points to generate can be very large (millions of points). The number of threads used should be adjustable. The accuracy of the approximation improves with more points, but the simulation should be efficient enough to handle large numbers of points and multiple threads. SHOW CODE Java import java.util.Random; public class Solution { private static final int NUM_THREADS = 10; private static final int NUMBER_OF_TOSSES = 100000000; private static int[] results = new int[NUM_THREADS]; public static void main(String[] args) throws InterruptedException { Thread[] threads = new Thread[NUM_THREADS]; for (int i = 0; i \u003c NUM_THREADS; i++) { final int threadId = i; threads[i] = new Thread(() -\u003e { Random rand = new Random(); int start = threadId * NUMBER_OF_TOSSES / NUM_THREADS; int end = (threadId + 1) * NUMBER_OF_TOSSES / NUM_THREADS; int count_in_circle = 0; for (int j = start; j \u003c end; j++) { double x = rand.nextDouble() * 2 - 1; // Random x in range [-1, 1] double y = rand.nextDouble() * 2 - 1; // Random y in range [-1, 1] if (x * x + y * y \u003c= 1) { // If point is inside the circle count_in_circle++; } } results[threadId] = count_in_circle; }); threads[i].start(); } for (Thread thread : threads) { thread.join(); } // Compute final estimate of Pi int total_inside = 0; for (int result : results) { total_inside += result; } double pi_estimate = 4.0 * total_inside / NUMBER_OF_TOSSES; System.out.println(\"PI = \" + pi_estimate); } } SHOW NOTES Introduction to Monte Carlo Estimation of $\\pi$\nSuppose a square with a circle inscribed inside it, as shown in the image below. The circle has a radius of $r$, and the square has side length $2r$. The area of the circle is $A_{\\text{circle}} = \\pi r^2$, and the area of the square is $A_{\\text{square}} = (2r)^2 = 4r^2$\nThe ratio of the area of the circle to the area of the square is $$ \\frac{A_{\\text{circle}}}{A_{\\text{square}}} = \\frac{\\pi r^2}{4 r^2} = \\frac{\\pi}{4} $$\nTherefore, the value of $\\pi$ can be estimated by the formula:\n$$ \\pi \\approx 4 \\times \\frac{\\text{Number of points inside the circle}}{\\text{Total number of points inside the square}} $$\nVisulization:\nJUC CompletableFuture Future Interface The Future interface in Java defines several methods for managing asynchronous tasks, such as retriving the execution result, canceling a task, and checking if a task has been canceled or completed. It includes four commonly used methods: get(), isDone(), cancel(), and isCancelled().\nThe get() mthod retrives the result of computation. Note: If the computation is not yet complete, this method will block until the result is available. The isDone() method checks whether the computation has finished executing. The cancel() method attempts to cancel the task execution. The isCancelled() method checks if the task has been canceled before completion. The FutureTask class is a concrete implementation of the Future interface. It implements both the Runnable and Future interfaces, allowing it to be executed by a thread while also returning a result. Its constructor takes a Callable\u0026lt;V\u0026gt;, enabling the task to return a value. The class diagram is shown below: The Future combined with a thread pool enhances execution performance efficiently. However, its drarback lies in the get() method, which is blocking, and the isDone() method, whose polling behavior consumes CPU resources.\nSHOW CODE FutureGetBlocking FutureIsDonePolling import java.util.concurrent.ExecutionException; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Future; class Main { public static void main(String[] args) throws ExecutionException, InterruptedException { ExecutorService executor = Executors.newSingleThreadExecutor(); Future\u0026lt;String\u0026gt; future = executor.submit(() -\u003e { Thread.sleep(3000); // Simulate a long running task return \"Task Completed\"; }); System.out.println(\"Waiting for result...\"); // Block the main thread until the result is available String result = future.get(); System.out.println(\"Result: \" + result); executor.shutdown(); } } import java.util.concurrent.ExecutionException; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Future; class Main { public static void main(String[] args) throws ExecutionException, InterruptedException { ExecutorService executor = Executors.newSingleThreadExecutor(); Future\u0026lt;String\u0026gt; future = executor.submit(() -\u003e { Thread.sleep(3000); // Simulate a long-running task return \"Task Completed\"; }); // Busy-waiting, consuming CPU cycles while (!future.isDone()) { System.out.println(\"Checking if task is done...\"); Thread.sleep(100); // Reducing CPU usage slightly, but still inefficient } System.out.println(\"Result: \" + future.get()); executor.shutdown(); } } CompletableFuture The CompletableFuture implements both the Future and CompletionStage interfaces. The CompletionStage represents a computation step that can be completed asynchronously. Unlike Future, CompletableFuture provides advanced mechanisms for handling asynchronous tasks, including non-blocking execution, method chaining, exception handling, combining futures, and thread pool customization.\nNon-blocking Execution: Unlike Future.get(), whcih blocks until the result is available, CompletableFuture enables asynchronous execution without blocking the main thread. Chaining Supports method chaining with thenApply, thenCompose, and thenRun to process results sequently. Exception Handling: Provides exceptionally and handle methods to gracefully handle errors. Combining Futures: Supports combining multiple futures using thenCombine, allOf, and anyOf for parallel execution. Thread Pool Customization: Allows executing tasks in a custom thread pool for better resource management. SHOW CODE Without Blocking Chaining Tasks ExceptionHandling CombiningFutures import java.util.concurrent.*; class Main { public static void main(String[] args) throws ExecutionException, InterruptedException { CompletableFuture\u0026lt;Void\u0026gt; future = CompletableFuture.runAsync(() -\u003e { try { Thread.sleep(2000); System.out.println(\"Task executed in a separate thread\"); } catch (InterruptedException e) { e.printStackTrace(); } }); System.out.println(\"Main thread is not blocked.\"); future.join(); } } import java.util.concurrent.*; class Main { public static void main(String[] args) throws ExecutionException, InterruptedException { CompletableFuture\u0026lt;String\u0026gt; future = CompletableFuture.supplyAsync(() -\u003e \"Hello\") .thenApply(result -\u003e result + \", World!\") .thenApply(String::toUpperCase); System.out.println(future.join()); // Output: HELLO, WORLD! } } import java.util.concurrent.*; class Main { public static void main(String[] args) throws ExecutionException, InterruptedException { CompletableFuture\u0026lt;String\u0026gt; future = CompletableFuture.supplyAsync(() -\u003e { if (true) { throw new RuntimeException(\"Something went wrong!\"); } return \"Success\"; }).exceptionally(ex -\u003e \"Recovered from: \" + ex.getMessage()); // Recovered from: java.lang.RuntimeException: Something went wrong! System.out.println(future.join()); } } import java.util.concurrent.*; class Main { public static void main(String[] args) throws ExecutionException, InterruptedException { CompletableFuture\u0026lt;String\u0026gt; future1 = CompletableFuture.supplyAsync(() -\u003e \"Task 1\"); CompletableFuture\u0026lt;String\u0026gt; future2 = CompletableFuture.supplyAsync(() -\u003e \"Task 2\"); CompletableFuture\u0026lt;String\u0026gt; future3 = CompletableFuture.supplyAsync(() -\u003e \"Task 3\"); CompletableFuture allFutures = CompletableFuture.allOf(future1, future2, future3); // Retrieve results from individual futures String result1 = future1.get(); String result2 = future2.get(); String result3 = future3.get(); System.out.println(result1); System.out.println(result2); System.out.println(result3); allFutures.join(); // Wait for all tasks to complete System.out.println(\"All tasks completed!\"); } } The advantage of CompletableFuture is that when an asynchronous task completes, it automatically invokes the callback method. Once the main thread sets up the callback, it no longer needs to monitor the asynchronous task, and allows execution to proceed in sequence. Additionally, if the asynchronous task fails, it automatically triggers the corresponding error-handling method.\nBy default, CompletableFuture.supplyAsync() and runAsync() utilize the ForkJoinPool.commonPool(), a shared thread pool based on the ForkJoin framework. To use a custom thread pool, you need to provide a custom Executor when calling these methods.\nSHOW CODE ForkJoinPool.commonPool() Custom Thread Pool import java.util.concurrent.*; class Main { public static void main(String[] args) throws ExecutionException, InterruptedException { CompletableFuture.runAsync(() -\u003e { // Running in: ForkJoinPool.commonPool-worker-1 System.out.println(\"Running in: \" + Thread.currentThread().getName()); }); // Sleep to allow async task to execute try { Thread.sleep(100); } catch (InterruptedException e) { } } } import java.util.concurrent.*; class Main { public static void main(String[] args) throws ExecutionException, InterruptedException { ExecutorService executor = Executors.newFixedThreadPool(5); CompletableFuture.runAsync(() -\u003e // Custom pool: pool-1-thread-1 System.out.println(\"Custom pool: \" + Thread.currentThread().getName()), executor); } } The main difference between CompletableFuture.get() and CompletableFuture.join() is exception handling. get() throws checked exceptions (ExecutionException, InterruptedException), requiring explicit handling, while join() throws an unchecked CompletionException, eliminating the need for explicit exception handling.\nThe main differences between thenRun(), thenAccept(), and thenApply are\nthenRun() runs a task after previous stage completes, but does not take its result as input. thenAccept() runs a task after previous stage completes and consumes its result. thenApply() runs a task after previous stage completes and transform its result. CompletableFuture.supplyAsync(() -\u0026gt; \u0026#34;Task Completed\u0026#34;) .thenRun(() -\u0026gt; System.out.println(\u0026#34;Follow-up action executed!\u0026#34;)); CompletableFuture.supplyAsync(() -\u0026gt; \u0026#34;Hello, World!\u0026#34;) .thenAccept(result -\u0026gt; System.out.println(\u0026#34;Result: \u0026#34; + result)); CompletableFuture\u0026lt;String\u0026gt; future = CompletableFuture.supplyAsync(() -\u0026gt; \u0026#34;Hello\u0026#34;) .thenApply(result -\u0026gt; result + \u0026#34;, World!\u0026#34;); System.out.println(future.join()); // Output: Hello, World! Method Takes Previous Result? Returns a Value? Use Case thenRun ❌ No ❌ No (Void) Just run a task after completion thenAccept ✅ Yes ❌ No (Void) Consume the result without returning a new one thenApply ✅ Yes ✅ Yes (R) Transform the result and return a new value Java Locks Optimistic Lock vs. Pessimistic Lock Optimistic Lock assumes minimal contention, allowing multiple threads to read and write data concurrently. Instead of using locks, it relies on versioning or CAS (Compare-And-Swap) to detect conflicts during updates. If a conflict is detected (i.e., another thread has modified the data), the operation is retried. It is particularly effective in high-read, low-write scenarios.\nSHOW CODE Use versioning in SQL Use CAS in Java # Use versioning in SQL UPDATE products SET stock = stock - 1, version = version + 1 WHERE id = 1 AND version = 5; import java.util.concurrent.*; import java.util.concurrent.atomic.AtomicInteger; class Main { public static void main(String[] args) throws ExecutionException, InterruptedException { AtomicInteger count = new AtomicInteger(0); int expectedValue, newValue; do { expectedValue = count.get(); newValue = expectedValue + 1; } while (!count.compareAndSet(expectedValue, newValue)); System.out.println(\"Updated Count: \" + count.get()); } } Pessimistic Lock assumes high contention and prevents concurrent modification by blocking the resource. Other threads must wait until the lock is released. It is suitable for high-write, low-read scenerios. In Java, the synchronized and ReentrantLock are implementations of pessimistic lock.\nSHOW CODE synchronized ReentrantLock class PessimisticLockExample { private int count = 0; public synchronized void increment() { count++; } } import java.util.concurrent.locks.ReentrantLock; public class PessimisticLockExample { private int count = 0; private final ReentrantLock lock = new ReentrantLock(); public void increment() { lock.lock(); try { count++; } finally { lock.unlock(); } } } synchronized Related Problems SHOW CODE Java class Phone { public synchronized void sendEmail() { System.out.println(\"send email\"); } public synchronized void sendSMS() { System.out.println(\"send SMS\"); } } class Main { public static void main(String[] args) { Phone phone = new Phone(); new Thread(() -\u003e { phone.sendEmail(); }, \"A\").start(); // Ensure thread A starts first try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -\u003e { phone.sendSMS(); }, \"B\").start(); } } The above code first outputs send email, followed by send SMS. This happens because both sendEmail() and sendSMS() are synchronized methods that lock the same object. As a result, the thread that acquires the lock first executes first, while other threads must wait until the lock is released.\nSHOW CODE Java class Phone { public synchronized void sendEmail() { try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"send email\"); } public synchronized void sendSMS() { System.out.println(\"send SMS\"); } } class Main { public static void main(String[] args) { Phone phone = new Phone(); new Thread(() -\u003e { phone.sendEmail(); }, \"A\").start(); // Ensure thread A starts first try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -\u003e { phone.sendSMS(); }, \"B\").start(); } } The above code first outputs send email, followed by send SMS. This happens because both sendEmail() and sendSMS() are synchronized methods that lock the same object and executes sleep() method doesn\u0026rsquo;t release a lock. Therefore, the thread that acquires the lock first executes first, while other threads must wait until the lock is released.\nSHOW CODE Java class Phone { public synchronized void sendEmail() { try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"send email\"); } public synchronized void sendSMS() { System.out.println(\"send SMS\"); } public void hello() { System.out.println(\"hello\"); } } class Main { public static void main(String[] args) { Phone phone = new Phone(); new Thread(phone::sendEmail, \"A\").start(); // Ensure thread A starts first try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -\u003e { phone.hello(); }, \"B\").start(); } } The above code outputs hello immediately, followed by send email. This is because the hello() method is not synchronized and does not require a lock, allowing it to execute without waiting.\nSHOW CODE Java import java.util.concurrent.TimeUnit; class Phone { public synchronized void sendEmail() { try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"send email\"); } public synchronized void sendSMS() { System.out.println(\"send SMS\"); } } class Main { public static void main(String[] args) { Phone phone1 = new Phone(); Phone phone2 = new Phone(); new Thread(() -\u003e { phone1.sendEmail(); }, \"A\").start(); // Ensure thread A starts first try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -\u003e { phone2.sendSMS(); }, \"B\").start(); } } The above code outputs send SMS first, followed by send email. This happens because the synchronized keyword locks the object instances (phone1 and phone2), not the class itself. Since phone1 and phone2 are different objects, their locks do not interfere with each other.\nIn this case, Thread A starts first and acquires the lock on phone1, but sleep for 3 seconds inside the sendEmail() method. Meanwhile, Thread B starts shortly after and acquires the lock on phone2. Since Thread B does not need to wait for Thread A to release its lock (as they operate on different objects), it executes sendSMS() immediately. As a result, Thread B outputs send SMS first, while Thread A outputs send email after its sleep period ends.\nSHOW CODE Java import java.util.concurrent.TimeUnit; class Phone { public static synchronized void sendEmail() { try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"send email\"); } public static synchronized void sendSMS() { System.out.println(\"send SMS\"); } } class Main { public static void main(String[] args) { Phone phone = new Phone(); new Thread(() -\u003e { phone.sendEmail(); }, \"A\").start(); // Ensure thread A starts first try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -\u003e { phone.sendSMS(); }, \"B\").start(); } } The above code outputs send email first, followed by send SMS. This happens because the static synchronized keyword locks the Phone.class object, not individual instances of the class. Since both methods (sendEmail and send SMS) are static synchronized, they share the same lock on the Phone.class object. As a result, their execution is sequential.\nSHOW CODE Java import java.util.concurrent.TimeUnit; class Phone { public static synchronized void sendEmail() { try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"send email\"); } public static synchronized void sendSMS() { System.out.println(\"send SMS\"); } } class Main { public static void main(String[] args) { Phone phone1 = new Phone(); Phone phone2 = new Phone(); new Thread(() -\u003e { phone1.sendEmail(); }, \"A\").start(); // Ensure thread A starts first try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -\u003e { phone2.sendSMS(); }, \"B\").start(); } } The above code outputs send email first, followed by send SMS. Even though there are two different objects (phone1 and phone2), the static synchronized keyword locks the Phone.class object, not the individual instances. This means that both sendEmail() and sendSMS() share the same lock at the class level, ensuring sequential execution.\nSHOW CODE Java import java.util.concurrent.TimeUnit; class Phone { public static synchronized void sendEmail() { try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"send email\"); } public synchronized void sendSMS() { System.out.println(\"send SMS\"); } } class Main { public static void main(String[] args) { Phone phone = new Phone(); new Thread(() -\u003e { phone.sendEmail(); }, \"A\").start(); // Ensure thread A starts first try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -\u003e { phone.sendSMS(); }, \"B\").start(); } } The above code outputs send SMS first, followed by send email. This happens because the synchronized keyword locks individual object instance, while static synchronized locks the class-level object. In this case, sendSMS() locks the phone object, and sendEmail() locks the Phone.class object. Since these locks are independent, Thread B does not need to wait for Thread A to release its lock. As a result, send SMS is printed first, while send email is printed after the 3-second sleep.\nSHOW CODE Java import java.util.concurrent.TimeUnit; class Phone { public static synchronized void sendEmail() { try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"send email\"); } public static synchronized void sendSMS() { System.out.println(\"send SMS\"); } public void hello() { System.out.println(\"hello\"); } } class Main { public static void main(String[] args) { Phone phone1 = new Phone(); Phone phone2 = new Phone(); new Thread(() -\u003e { phone1.sendEmail(); }, \"A\").start(); // Ensure thread A starts first try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -\u003e { phone2.hello(); phone2.sendSMS(); }, \"B\").start(); } } The above code outputs hello first, followed by send email and send SMS. This is because sendEmail() and sendSMS() are both static synchronized, meaning they lock the Phone.class object, enforcing sequential execution. In contrast, the hello() method is a regular method that does not require a lock, allowing it to execute immediately.\nsynchronized Byte Code Analysis SHOW CODE Source Code Source Code class Main { private final Object mtx = new Object(); public void f() { synchronized (mtx) { System.out.println(\"hello...\"); } } } public void f(); Code: 0: aload_0 1: getfield #7 // Field mtx:Ljava/lang/Object; 4: dup 5: astore_1 🌟 6: monitorenter 7: getstatic #13 // Field java/lang/System.out:Ljava/io/PrintStream; 10: ldc #19 // String hello... 12: invokevirtual #21 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 15: aload_1 🌟 16: monitorexit 17: goto 25 20: astore_2 21: aload_1 🌟 22: monitorexit 23: aload_2 24: athrow 25: return From the above bytecode, the synchronized block translates into monitorenter and monitorexit instructions. The lock is acquired before entering the block and released before exiting. The second monitorexit ensures that the lock is properly released if an exception occurs, as shown in the following code:\nSHOW CODE Source Code Byte Code class Main { private final Object mtx = new Object(); public void f() { synchronized (mtx) { System.out.println(\"hello...\"); throw new RuntimeException(\"Exception occurred\"); } } } public void f(); Code: 0: aload_0 1: getfield #7 // Field mtx:Ljava/lang/Object; 4: dup 5: astore_1 🌟 6: monitorenter 7: getstatic #13 // Field java/lang/System.out:Ljava/io/PrintStream; 10: ldc #19 // String hello... 12: invokevirtual #21 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 15: new #27 // class java/lang/RuntimeException 18: dup 19: ldc #29 // String Exception occurred 21: invokespecial #31 // Method java/lang/RuntimeException.\"\u0026lt;init\u0026gt;\":(Ljava/lang/String;)V 24: athrow 25: astore_2 26: aload_1 🌟 27: monitorexit 28: aload_2 29: athrow SHOW CODE Source Code Byte Code class Main { public synchronized void f() { System.out.println(\"hello...\"); } public static synchronized void m() { System.out.println(\"HELLO...\"); } } public synchronized void f(); descriptor: ()V flags: (0x0021) ACC_PUBLIC, 🌟ACC_SYNCHRONIZED🌟 Code: stack=2, locals=1, args_size=1 0: getstatic #7 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #13 // String hello... 5: invokevirtual #15 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LineNumberTable: line 3: 0 line 4: 8 public static synchronized void m(); descriptor: ()V flags: (0x0029) ACC_PUBLIC, 🌟ACC_STATIC, ACC_SYNCHRONIZED🌟 Code: stack=2, locals=0, args_size=0 0: getstatic #7 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #21 // String HELLO... 5: invokevirtual #15 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LineNumberTable: line 7: 0 line 8: 8 From the above bytecode, the JVM checks if the ACC_SYNCHRONIZED flag is set. If the flag is present, the thread acquires the appropriate monitor lock before executing the method. For instance methods, the lock is acquired on the object instance (this), while for static methods, the lock is acquired on the class object (e.g., Main.class). After the method completes execution, the thread releases the lock. The ACC_STATIC flag is used to determine whether the method is static, which in turn determines whether the lock is applied at the class level or the instance level.\nWhy any object in Java can be a lock?\nAny object in Java can be a lock because every object has an intrinsic monitor lock managed by the JVM. The ObjectMonitor structure is part of the JVM\u0026rsquo;s implementation of this mechanism, tracking details like the lock owner, EntryList, etc. For example, when a thread calls synchronized(obj), the JVM checks the ObjectMonitor associated with obj. If the lock is available, the thread acquires it and sets itself as the owner. If the lock is held by another thread, the current thread waits in the EntryList. When the lock is released, the JVM wakes up a waiting thread (if any) to acquire the lock.\nObjectMonitor() { _header = NULL; _count = 0; _waiters = 0; _recursions = 0; _object = NULL; _owner = NULL; _MailSet = NULL; _MailSetLock = 0; _Responsible = NULL; _succ = NULL; _cxq = NULL; FreeNext = NULL; _EntryList = NULL; _SpinFreq = 0; _SpinClock = 0; OwnerIsThread = 0; _previous_owner_tid = 0; } Fair Lock vs. Unfair Lock In Java, locks can be calssified into fair locks and unfair locks based on their approach to thread scheduling. A fair lock ensures that threads acquire the lock in the exact order they requested it, following a first-come, first-served priciple. While this prevents thread starvation, it incurs additional overhead to maintain the order of threads. On the other hand, an unfair lock does not guarantee any specific order for thread access. A thread can acquire the lock even if it arrived later than others. This eliminates the need to maintain a strict order, improving efficiency, but it may result in thread starvation, where some threads could wait indefinitely for access.\nSHOW CODE Java import java.util.concurrent.locks.ReentrantLock; public class Main { private static final ReentrantLock unfairLock = new ReentrantLock(); // Unfair lock private static final ReentrantLock fairLock = new ReentrantLock(true); // Fair lock public static void main(String[] args) { System.out.print(\"Testing Unfair Lock: \"); testLock(unfairLock); System.out.print(\"Testing Fair Lock: \"); testLock(fairLock); } private static void testLock(ReentrantLock lock) { long startTime = System.currentTimeMillis(); Runnable task = () -\u003e { for (int i = 0; i \u003c 10000; i++) { lock.lock(); try { // Simulate work } finally { lock.unlock(); } } }; Thread[] threads = new Thread[10]; for (int i = 0; i \u003c threads.length; i++) { threads[i] = new Thread(task); threads[i].start(); } for (Thread thread : threads) { try { thread.join(); } catch (InterruptedException e) { e.printStackTrace(); } } long endTime = System.currentTimeMillis(); System.out.println(\"Time taken: \" + (endTime - startTime) + \" ms\"); } } SHOW OUTPUT Output Testing Unfair Lock: Time taken: 11 ms Testing Fair Lock: Time taken: 560 ms Recursive Lock A recursive lock in Java allows a thread to acquire the same lock multiple times without causing a deadlock. It is particularly useful in scenarios where a thread holding a lock calls another method or enters a synchronized block that requires the same lock. By default, the synchronized keyword and ReentrantLock class support recursive locking mechanism.\nThe recursive lock maintains a hold count, which tracks how many times a thread has acquired the lock. Each time the thread acquires the lock, the hold count is incremented, and it is decremented when the lock is released. The lock is fully released only when the hold count reaches zero.\nUnder the hood, when the monitorenter command is executed, the JVM checks the MonitorObject\u0026rsquo;s _count field. If _count is zero, it means the lock is not held by any other thread. In this case, the JVM sets the _owner field to the current thread and increments the _count. If _count is not zero and the _owner is the current thread, the JVM increments the _count (indicating reentrancy). Otherwise, if the lock is held by another thread, the current thread must wait until the lock is released (i.e., _count reaches zero).\nWhen the monitorexit command is executed, the JVM decrements the _count. Once _count reaches zero, the lock is considered fully released, and the _owner field is cleared, allowing other threads to acquire the lock.\nSHOW CODE Java import java.util.concurrent.locks.ReentrantLock; public class Main { private static final ReentrantLock lock = new ReentrantLock(); public static void main(String[] args) { recursiveMethod(3); } public static void recursiveMethod(int count) { lock.lock(); // Acquire the lock try { System.out.println(Thread.currentThread().getName() + \" acquired the lock. Hold count: \" + lock.getHoldCount()); if (count \u003e 0) { recursiveMethod(count - 1); // Recursive call } } finally { lock.unlock(); // Release the lock System.out.println(Thread.currentThread().getName() + \" released the lock. Hold count: \" + lock.getHoldCount()); } } } SHOW OUTPUT Output main acquired the lock. Hold count: 1 main acquired the lock. Hold count: 2 main acquired the lock. Hold count: 3 main acquired the lock. Hold count: 4 main released the lock. Hold count: 3 main released the lock. Hold count: 2 main released the lock. Hold count: 1 main released the lock. Hold count: 0 Deadlock A deadlock is a situation where two or more threads are permanently blcoked, each waiting for a resource held by another, preventing further progress. For a deadlock to occur, four conditions must be met simultaneously: mutual exclusion, hold and wait, no preemption, and circular wait.\nMutual Exclusion: A resource must be non-sharable, meaning only one thread can use it at a time. Hold and Wait: A thread holding at least one resource must be waiting to acquire additional resources held by other threads. No Preemption: Resources cannot be forcibly taken from a thread; they must be released voluntarily. Circular Wait: A circular chain of two or more threads must exist, where each thread is waiting for a resource held by the next in the chain. To detect a deadlock in Java, use the jps command to get the process ID, then run jstack process_id to analyze thread states and identify deadlocks.\nSHOW CODE Deadlock Detecting a Deadlock public class Main { private static final Object lock1 = new Object(); private static final Object lock2 = new Object(); public static void main(String[] args) { Thread thread1 = new Thread(() -\u003e { synchronized (lock1) { System.out.println(\"Thread 1: Holding lock 1...\"); try { Thread.sleep(100); // Simulate work } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"Thread 1: Waiting for lock 2...\"); synchronized (lock2) { System.out.println(\"Thread 1: Acquired lock 2!\"); } } }); Thread thread2 = new Thread(() -\u003e { synchronized (lock2) { System.out.println(\"Thread 2: Holding lock 2...\"); try { Thread.sleep(100); // Simulate work } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"Thread 2: Waiting for lock 1...\"); synchronized (lock1) { System.out.println(\"Thread 2: Acquired lock 1!\"); } } }); thread1.start(); thread2.start(); } } $ jps 76995 Launcher 76996 Main 77127 Jps 2327 Main -------------- $ jstack 76996 \"Thread-0\": at dev.signalyu.warmup.Main.lambda$main$0(Main.java:18) 🌟 - waiting to lock \u003c0x000000070ffce280\u003e (a java.lang.Object) 🌟 - locked \u003c0x000000070ffce270\u003e (a java.lang.Object) at dev.signalyu.warmup.Main$$Lambda$14/0x000000012d001208.run(Unknown Source) at java.lang.Thread.run(java.base@17.0.9/Thread.java:842) \"Thread-1\": at dev.signalyu.warmup.Main.lambda$main$1(Main.java:33) 🌟 - waiting to lock \u003c0x000000070ffce270\u003e (a java.lang.Object) 🌟 - locked \u003c0x000000070ffce280\u003e (a java.lang.Object) at dev.signalyu.warmup.Main$$Lambda$15/0x000000012d001428.run(Unknown Source) at java.lang.Thread.run(java.base@17.0.9/Thread.java:842) Found 1 deadlock. 🌟 Thread Interruption In Java, thread interruption is a mechanism that allows one thread to signal another to stop its execution. The three common approaches to interrupt a thread are using a volatile flag, an AtomicBoolean, or the interrupt() method.\nSHOW CODE volatile AtomicBoolean interrupt() import java.util.concurrent.TimeUnit; public class Main { private static volatile boolean isStop = false; public static void main(String[] args) { new Thread(() -\u003e { while (!isStop) { try { TimeUnit.MILLISECONDS.sleep(500); System.out.println(\"isStop: \" + isStop); } catch (InterruptedException e) { throw new RuntimeException(e); } } System.out.println(\"isStop --\u003e \" + isStop); }, \"t1\").start(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } // Signal threads to stop new Thread(() -\u003e { isStop = true; }, \"t2\").start(); } } import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicBoolean; public class Main { private static final AtomicBoolean atomicBoolean = new AtomicBoolean(false); public static void main(String[] args) { new Thread(() -\u003e { while (!atomicBoolean.get()) { try { TimeUnit.MILLISECONDS.sleep(500); } catch (InterruptedException e) { throw new RuntimeException(e); } System.out.println(\"Atomic Boolean: \" + atomicBoolean); } System.out.println(\"Atomic Boolean --\u003e \" + atomicBoolean); }, \"t1\").start(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } // Signal threads to stop new Thread(() -\u003e { atomicBoolean.set(true); }, \"t2\").start(); } } public class Main { private static volatile boolean isStop = false; public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { while (!Thread.currentThread().isInterrupted()) { System.out.println(\"Is interrupted: \" + Thread.currentThread().isInterrupted()); } System.out.println(\"Is interrupted --\u003e \" + Thread.currentThread().isInterrupted()); }, \"t1\"); t1.start(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } // Signal threads to stop new Thread(() -\u003e { t1.interrupt(); }, \"t2\").start(); } } SHOW OUTPUT volatile AtomicBoolean interrupt() isStop: false isStop: true isStop --\u003e true Atomic Boolean: false Atomic Boolean: true Atomic Boolean --\u003e true ...... Is interrupted: false Is interrupted: false Is interrupted: false Is interrupted --\u003e true The common methods for managing thread interruption in Java include interrupt(), interrupted(), and isInterrupted():\ninterrupt(): An instance method that sets the thread\u0026rsquo;s interrupted status to true. It does not forcibly stop the thread. If the thread is blocked (e.g., in sleep(), wait(), or join()), it throws an InterruptedException. interrupted(): A static method that checks if the current thread has been interrupted. If it has, the method resets the interrupted status to false. isInterrupted(): An instance method that checks if the thread has been interrupted without resetting its interrupted status. What\u0026rsquo;s the following code output?\nSHOW CODE (Wrong Interruption) Java import java.util.concurrent.TimeUnit; public class Main { public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { while (true) { if (Thread.currentThread().isInterrupted()) { System.out.println(\"isInterrupted --\u003e true\"); break; } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"INTERRUPTED...\"); } }, \"t1\"); t1.start(); try { TimeUnit.SECONDS.sleep(3); // Sleep 3 seconds } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -\u003e { t1.interrupt(); // Set interrupted status of thread 't1' to true }, \"t2\").start(); } } SHOW OUTPUT (Wrong Interruption) Output INTERRUPTED... INTERRUPTED... java.lang.InterruptedException: sleep interrupted at java.base/java.lang.Thread.sleep(Native Method) at dev.signalyu.warmup.Main.lambda$main$0(Main.java:14) at java.base/java.lang.Thread.run(Thread.java:842) INTERRUPTED... INTERRUPTED... ...... When a thread is interrupted while blocked, the blocking method throws an InterruptedException and clears the interrupted status.\nSHOW CODE (Correct Interruption) Java import java.util.concurrent.TimeUnit; public class Main { public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { while (true) { if (Thread.currentThread().isInterrupted()) { System.out.println(\"isInterrupted --\u003e true\"); break; } try { Thread.sleep(1000); } catch (InterruptedException e) { Thread.currentThread().interrupt(); // 🌟🌟🌟 Restore its interrupted status 🌟🌟🌟 e.printStackTrace(); } System.out.println(\"INTERRUPTED...\"); } }, \"t1\"); t1.start(); try { TimeUnit.SECONDS.sleep(3); // Sleep 3 seconds } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -\u003e { t1.interrupt(); // Set interrupted status of thread 't1' to true }, \"t2\").start(); } } SHOW OUTPUT (Correct Interruption) Output INTERRUPTED... INTERRUPTED... java.lang.InterruptedException: sleep interrupted at java.base/java.lang.Thread.sleep(Native Method) at dev.signalyu.warmup.Main.lambda$main$0(Main.java:14) at java.base/java.lang.Thread.run(Thread.java:842) INTERRUPTED... isInterrupted --\u003e true After restoring the thread\u0026rsquo;s interrupted status by adding Thread.currentThread().interrupt();, it exits the while loop gracefully.\nLockSupport wait()/nofity() related problems There are two common issues when using wait() and notify() in Java:\nSynchronization Requirement: Both wait() and notify() must be called within a synchronized block or method. This is because these methods rely on the object\u0026rsquo;s intrinsic lock (monitor). If they are called outside a synchronized context, the program will throw an IllegalMonitorStateException. Missed Notifications: If notify() is called before wait(), the notification will be missed, and the thread calling wait() may block indefinitely. This happens because notify() does not have any effect if no thread is currently waiting on the object\u0026rsquo;s monitor. SHOW CODE Synchronization Requirement Missed Notifications public class Main { private static final Object lock = new Object(); public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { // synchronized (lock) { try { System.out.println(\"Thread 1 is waiting...\"); lock.wait(); // Thread 1 waits } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"Thread 1 is resumed.\"); // } }); Thread t2 = new Thread(() -\u003e { // synchronized (lock) { System.out.println(\"Thread 2 is notifying...\"); lock.notify(); // Thread 2 notifies // } }); t1.start(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } t2.start(); } } public class Main { private static final Object lock = new Object(); public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } // Acquire the lock after 1 second, notify() executes first synchronized (lock) { try { System.out.println(\"Thread 1 is waiting...\"); lock.wait(); // Thread 1 waits } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"Thread 1 is resumed.\"); } }); Thread t2 = new Thread(() -\u003e { synchronized (lock) { System.out.println(\"Thread 2 is notifying...\"); lock.notify(); // Thread 2 notifies } }); t1.start(); t2.start(); } } SHOW OUTPUT Synchronization Requirement Missed Notifications Thread 1 is waiting... Exception in thread \"Thread-0\" java.lang.IllegalMonitorStateException: current thread is not owner at java.base/java.lang.Object.wait(Native Method) at java.base/java.lang.Object.wait(Object.java:338) at dev.signalyu.warmup.Main.lambda$main$0(Main.java:11) at java.base/java.lang.Thread.run(Thread.java:842) Thread 2 is notifying... Exception in thread \"Thread-1\" java.lang.IllegalMonitorStateException: current thread is not owner at java.base/java.lang.Object.notify(Native Method) at dev.signalyu.warmup.Main.lambda$main$1(Main.java:22) at java.base/java.lang.Thread.run(Thread.java:842) Thread 2 is notifying... Thread 1 is waiting... // WAIT INDEFINITELY await()/signal() related problems Similar to wait()/notify(), when using await()/signal() from the Condition interface, the thread must hold the associated lock. If the lock is not held, the program will throw an IllegalMonitorStateException. Additionally, if signal() is called before await(), the notification will be missed, and the thread calling await() may wait indefinitely. To avoid this, always use a loop to recheck the condition after waking up from await(). This ensures that thread only proceeds when the condition is truly met, even if a spurious wakeup occurs or notification is missed.\nSHOW CODE Synchronization Requirement Missed Notifications import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.ReentrantLock; public class Main { private static final ReentrantLock lock = new ReentrantLock(); private static final Condition condition = lock.newCondition(); public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { // lock.lock(); try { System.out.println(\"Thread 1 is waiting...\"); condition.await(); // Thread 1 waits System.out.println(\"Thread 1 is resumed.\"); } catch (InterruptedException e) { e.printStackTrace(); } finally { // lock.unlock(); } }); Thread t2 = new Thread(() -\u003e { // lock.lock(); try { System.out.println(\"Thread 2 is signaling...\"); condition.signal(); // Thread 2 signals } finally { // lock.unlock(); } }); t1.start(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } t2.start(); } } import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.ReentrantLock; public class Main { private static final ReentrantLock lock = new ReentrantLock(); private static final Condition condition = lock.newCondition(); public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } // Acquire the lock after 1 second, signal() executes first lock.lock(); try { System.out.println(\"Thread 1 is waiting...\"); condition.await(); // Thread 1 waits System.out.println(\"Thread 1 is resumed.\"); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } }); Thread t2 = new Thread(() -\u003e { lock.lock(); try { System.out.println(\"Thread 2 is signaling...\"); condition.signal(); // Thread 2 signals } finally { lock.unlock(); } }); t1.start(); t2.start(); } } SHOW OUTPUT Synchronization Requirement Missed Notifications Thread 1 is waiting... Exception in thread \"Thread-0\" java.lang.IllegalMonitorStateException at java.base/java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.enableWait(AbstractQueuedSynchronizer.java:1516) at java.base/java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1611) at dev.signalyu.warmup.Main.lambda$main$0(Main.java:15) at java.base/java.lang.Thread.run(Thread.java:842) Thread 2 is signaling... Exception in thread \"Thread-1\" java.lang.IllegalMonitorStateException at java.base/java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.signal(AbstractQueuedSynchronizer.java:1473) at dev.signalyu.warmup.Main.lambda$main$1(Main.java:28) at java.base/java.lang.Thread.run(Thread.java:842) Thread 2 is signaling... Thread 1 is waiting... // WAIT INDEFINITELY LockSupport: park()/unpark(Thread) LockSupport is a utility class in Java that provides a low-level mechanism for thread synchronization. Unlike synchronized blocks or explicit Lock objects, LockSupport does not require explicit locking and unblocking. Instead, it operates using a permit mechanism, which makes it more flexible and lightweight. The most commonly used methods in LockSupport are park() and unpark(Thread). The park() method blocks the current thread if the permit is unavailable, while the unpark(Thread) method makes the permit available for a specific thread, unblocking if it was parked.\nThe key points about LockSupport include:\nThe permit is a binary semaphore, meaning it can either be available or unavailable. If a permit is available when park() is called, the thread continues execution without blocking. If no permit is available, the thread blocks until one is made available via unpark(). Unlike synchronized and Lock, LockSupport does not suffer from spurious wakeups. This means that a thread will only unblock when explicitly unparked, providing more predictable behavior compared to wait()/notify() or await()/signal(). The unpark(Thread) method targets a specific thread, making it more precise than notify() or signal(), which wake up any waiting thread. SHOW CODE park()/unpark(Thread) wait()/notify() await()/signal() import java.util.concurrent.locks.LockSupport; public class Main { public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { System.out.println(\"Thread 1 is parking...\"); LockSupport.park(); // Thread 1 parks System.out.println(\"Thread 1 is unparked.\"); }); Thread t2 = new Thread(() -\u003e { System.out.println(\"Thread 2 is unparking Thread 1...\"); LockSupport.unpark(t1); // Thread 2 unparks Thread 1 }); t1.start(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } t2.start(); } } public class Main { private static final Object lock = new Object(); public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { synchronized (lock) { try { System.out.println(\"Thread 1 is waiting...\"); lock.wait(); // Thread 1 waits } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"Thread 1 is resumed.\"); } }); Thread t2 = new Thread(() -\u003e { synchronized (lock) { System.out.println(\"Thread 2 is notifying...\"); lock.notify(); // Thread 2 notifies } }); t1.start(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } t2.start(); } } import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.ReentrantLock; public class Main { private static final ReentrantLock lock = new ReentrantLock(); private static final Condition condition = lock.newCondition(); public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { lock.lock(); try { System.out.println(\"Thread 1 is waiting...\"); condition.await(); // Thread 1 waits System.out.println(\"Thread 1 is resumed.\"); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } }); Thread t2 = new Thread(() -\u003e { lock.lock(); try { System.out.println(\"Thread 2 is signaling...\"); condition.signal(); // Thread 2 signals } finally { lock.unlock(); } }); t1.start(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } t2.start(); } } SHOW OUTPUT park()/unpark(Thread) wait()/notify() await()/signal() Thread 1 is parking... Thread 2 is unparking Thread 1... Thread 1 is unparked. Thread 1 is waiting... Thread 2 is notifying... Thread 1 is resumed. Thread 1 is waiting... Thread 2 is signaling... Thread 1 is resumed. Java Memory Model The Java Memory Model (JMM) is a specification that governs how threads interact with memory in a multi-threaded environment. It establishes rules that determine how and when change made by one thread to shared variables become visible to other threads, ensuring consistency and predictability in concurrent execution.\nJMM classifies memory into two types: Main Memory and Working Memory. Main Memory is the central storage where all variables, including instance fields, static fields, and array elements, reside. Working Memory, on the other hand, is a thread\u0026rsquo;s local memory that holds copies of variables it accesses. Threads do not interact with main memory directly; instead, they load variables into their working memory and write back updates when necessary. A fundamental concept in JMM is the happens-before relationship, which defines the order of operations between threads to maintain memory consistency. If one action happens-before another, the effects of the first action are guaranteed to be visible to the second. Examples include:\nA write to a volatile variable happens-before every subsequent read of that variable. Unlocking a monitor happens-before the next lock on the same monitor. The key characteristics of JMM include Atomicity, Visibility, and Ordering.\nAtomicity: Certain operations, such as reads and writes to volatile variables, are atomic, meaning they execute as indivisible units. Visibility: Changes made by one thread to shared variables are guaranteed to be seen by other threads under proper synchronization mechanisms. Ordering: JMM defines strict rules for instruction ordering, but without synchronization, the JVM may reorder instructions for optimization, potentially causing unpredictable behavior in a multi-threaded environment. happens-before The happens-before relationship in the Java Memory Model (JMM) establishes rules that dictate the ordering and visibility of actions in multithreaded programs. It ensures that certain operations performed in one thread become predictably visible to another, preventing issues like instruction reordering and inconsistent data access. Below are the eight key priciples of the happens-before relationship:\nProgram Order Rule: Within a single thread, actions occur in program order. For example, earlier statements happen-before later ones. int a = 10; // Happens-before int b = a + 5; // This sees the updated value of `a` Monitor Lock Rule: An unlock (unlock()) on a monitor lock happens-before any subsequent lock (lock()) on the same monitor. synchronized (lock) { sharedVar = 10; // Happens-before the next lock } synchronized (lock) { System.out.println(sharedVar); // Guaranteed to see updated value } Volatile Variable Rule: A write to a volatile variable happens-before any subsequent read of that same variable. private volatile boolean flag = false; flag = true; // Happens-before the next read System.out.println(flag); // Guaranteed to see true Thread Start Rule: A call to Thread.start() on a new thread happens-before any actions in that thread. Thread t = new Thread(() -\u0026gt; System.out.println(\u0026#34;Running\u0026#34;)); t.start(); // Happens-before the thread executes the print statement Thread Termination Rule: All actions in a thread happen-before other threads detecting its termination. In other words, after a thread terminates, all its actions are visible to the thread that joins it. Thread t = new Thread(() -\u0026gt; counter = 100); t.start(); t.join(); // Ensures all writes in t happen-before main thread continues System.out.println(counter); // Guaranteed to see 100 A call to Thread.interrupt() happens-before the interrupted thread detects the interruption via isInterrupted() or InterruptedException. Thread t = new Thread(() -\u0026gt; { while (!Thread.currentThread().isInterrupted()) { // Looping until interrupted } }); t.start(); t.interrupt(); // Happens-before the thread detects the interruption Final Field Rule: Writes to final fields in a constructor happen-before the object is seen by any other thread. class Example { final int x; Example() { x = 42; // Happens-before any other thread sees this object } } If action A happens-before action B, and action B happens-before action C, then action A happens-before action C. volatile int a = 0; a = 1; // A happens-before B (write to volatile) int b = a; // B happens-before C (read from volatile) volatile ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/multithreading-and-concurrency/1-multithreading-and-concurrency/","summary":"Introduction to Multithreading Program, Process, and Thread A program is a static set of instructions that stores on a disk. A process is an instance of a program that is currently being executed by the operating system. A thread is a small unit of process that can be scheduled and executed by the operating system. In simpler terms, a program is the code, a process is the excution of the code, a thread is a unit of execution within a process.","title":"Multithreading \u0026 Concurrency"},{"content":"Introduction to System Design SHOW CONTENTS System Design is the process of defining the architecture, components, modules, interfaces, and data for a system to fulfill specific business requirements, while ensuring scalability, maintainability, and performance.\nLoad Balancing SHOW CONTENTS In System Design, Load Balancing refers to the practice of distributing incoming network traffic or workload across multiple servers or resources to optimize resource use and ensure high availability.\nTo fullly leverage scalability and redundency, load balancing can occur at different layers: between user and the web server, between web server and an internal platform serve, between internal platform server and database as illustrated in the following image:\nThe typical process of load balancing involves the following steps:\nThe load balancer recerves a request from the client. The load balancer evaluates the request and routes it to a server based on the chosen load balancing algorithm. The selected server or resource processes the request and sends the response back to the load balancer. The load balancer receives the response and forwards it to the client. Load Balancing Algorithms SHOW CONTENTS A load balancing algorithm is a method used by a load balancer to determine how an incoming request should be distributed across multiple servers. Commonly used load balancing algorithms include Round Robin, Least Connections, Weight Round Robin, Weighted Least Connections, IP Hash, Least Response Time, Random, and Least Bandwidth.\nRound Robin SHOW CONTENTS The Round Robin algorithm distributes requests evenly across multiple servers in a circular manner. This algorithm does not consider the current load or capabilities of each server. It is commonly used in environments where servers have similar capacity and performance, or in applications where each request can be handled independently.\nLeast Connections SHOW CONTENTS The Least Connections algorithm distributes requests to servers with the fewest active connections. It takes into account the server\u0026rsquo;s current workload, helping to prevent any single server from becoming overwhelmed. This algorithm is particularly useful in scenerios where traffic or workload is unpredictable, servers have varying capabilities, or maintaining session state is important.\nWeighted Round Robin SHOW CONTENTS The Weighted Round Robin algorithm is an enhanced version of Round Robin, where each server is assigned a weight based on its capability and workload. Servers with higher weights process more requests, helping to prevent overloading less powerful servers. This algorithm is ideal for scenarios where servers have varying processing abilities, such as in a database cluster, where nodes with higher processing power can handle more queries.\nWeighted Least Connections SHOW CONTENTS The Weighted Least Connections algorithm is a combination of the Least Connections and the Weighted Round Robin algorithms. It takes into account the number of active connections of each server and the weight assigned to a server based on its capability. Requests are routed to servers based on the load factor, which is commonly calculated using the formular: the number of active connections of a server divided by its weight.\n$$ \\text{Load Factor} = \\frac{\\text{Number of Active Connections}}{\\text{Weight of the Server}} $$\nIP Hash SHOW CONTENTS The IP Hash algorithm routes requests to servers based on a hash of the client\u0026rsquo;s IP address. The load balancer applies a hash function to the client\u0026rsquo;s IP address to calculate the hash value, which is then used to determined which server will handle the current request. If the distribution of client IP addresses is uneven, some servers may receive more requests than others, leading to an imbalanced load. This algorithm is ideal for scenarios where maintaining state is important, such as online shopping carts or user sessions.\nLeast Response Time SHOW CONTENTS The Least Response Time algorithm routes incoming requests to the server with the lowest response time, ensuring efficient resource utilization and optimal client experience. It is ideal for scenerios where low latancy and fast response times are crucial, such as online gaming and financial trading.\nRandom SHOW CONTENTS The Random load balancing algorithm routes incoming requests to servers randomly. It is commonly used in scenarios where the load is relatively uniform and the servers have similar capabilities.\nLeast Bandwidth SHOW CONTENTS The Least Bandwidth algorithm routes incoming requests to the server that is consuming the least amount of bandwidth. It is ideal for applications with high bandwidth usage, such as vedio streaming, file downloads, and large file transfers.\nRedundent Load Balancers SHOW CONTENTS The Single Point of Failure (SPOF) refers to any component in a system or infrastructure that, if it fails, causes the entire system or a significant portion of it to become unavailable. For instance, if a load balancer is responsible for routing all incoming requests to servers, its faulure would result in the entire system or application becoming inoperable. To mitigate this risk, redundent load balancers can be deployed.\nFor example, in an active-passive setup, two load balancers are used, where both are capable of routing traffic and detecting failures. The active load balancer handles all incoming requests, and if it fails, the passive load balancer takes over to ditribute requests, ensuring continuous availability. This approach helps prevent the system from being dependent on a single point of failure, as illustrated in the following diagram.\nAPI Gateway SHOW CONTENTS An API Gateway is a server-side component that acts as a central entry point for clients to access as a collection of microservices. It receives client requests, forwards them to the appropriate microservice, and then returns the response from the server to the client. The API Gateway is responsible for various tasks, such as request routing, authentication, rate limiting.\nThe key difference between an API Gateway and a load balancer lies in their core functions. An API Gateway focuses on routing requests to specific microservices. In contrast, a Load Balancer is responsible for distributing incoming traffic across multiple backend servers. Additionally, while an API Gateway typically deals with requests that target specific APIs identified by unique URLs, a load balancer generally handles requests directed to a single, well-known IP address, distributing those requests to one of serveral backend servers based on load-balancing algorithms.\nKey Characteristics of Distributed System Scalability SHOW CONTENTS Scalability refers to a system\u0026rsquo;s ability to handle increasing workloads. In system design, there are two primary types of scaling: horizontal and vertical. Horizontal scaling involves adding more machines to distribute the load across multiple servers, while vertical scaling typically involves upgrading the hardware of a single machine.\nAvailability SHOW CONTENTS In system design, availability refers to the ability of a system to remain operational even in the face of faulures or high demand. Factors that affect availability include redundency, failover mechanisms, and load balancing. Redundency involves duplicating critical components to ensure that if one fails, another can take over. Failover mechanisms refer to the ability to quickly switch to a backup system during failure. Load balancing distributes requests across multiple servers to prevent any single point from becoming overwhelmed.\nIn distributed systems, there is often a trade-off between availability and consistency. The three common types of consistency models are strong, weak, and eventual consistency. The strong consistency model ensure that all replicas have the same data at all times, which can reduce availability and performance. The weak consistency model allows for temporary inconsistencies between replicas, offering improved availability and performance. The eventual consistency model guarantees that all replicas will eventually converge to the same data, balancing consistency and availability over time.\nMonitoring SHOW CONTENTS Monitoring in distributed systems is crucial for identifying issues and ensuring the overall health of the system. It typically involves four key components: metrics collection, distributed tracing, logging, and anomaly detection.\nMetrics collection involves gathering and analyzing key performance indicators such as latency, throughput, error rates, and resource utilization. This helps identify performance bottlenecks, potential issues, and areas for optimization. Common tools for metrics collection inculde Prometheus, Graphite, and InfluxDB.\nDistributed tracing is a technique for tracking and analyzing requests as they pass through various services, helping identify issues within specific services. Common tools for distributed tracing include Zipkin.\nLogging refers to the collection, centralization, and analysis of logs from all services in a distributed system. It provides valuable insights into system behavior, aiding in debugging and troubleshooting. Tools like the ELK Stack (Elasticsearch, Logstash, Kibana) are used for logging.\nAnomaly detection involves monitoring for unusual behaviors or patterns and notifying the appropriate team when such events occur. Tools like Grafana can be used for anomaly detection in distributed systems.\nCaching Introduction to Caching SHOW CONTENTS In system design, caching is a high-speed storage layer positioned between the application and the original data source, such as a database or a remote web service. The primary goal of caching is to minimize access to the original data source, thereby improving application performance. Caching can be implemented in various forms, including in-memory caching, disk caching, database caching, and CDN caching:\nIn-memory caching stores data directly in the computer\u0026rsquo;s memory, offering faster access than disk storage. Disk caching stores data on disk, which is slower than memory but faster than fetching data from an external source. Database caching stores data within the database itself, reducing the need to access external storage systems. CDN caching stores data on a distributed network of servers, minimizing latency when accessing data from remote locations. Here are some key caching terms:\nCache Hit: Occurs when the requested data is found in the cache. Cache Miss: Happens when the requested data is not found in the cache, requiring a fetch from the original data source. Cache Eviction: The process of removing data from the cache, often to make room for new data based on a predefined cache eviction policy. Cache Staleness: Refers to the situation where the cached data is outdated compared to the original data source. Here are some of the most common types of caching:\nCaching Replacement Policies SHOW CONTENTS When caching data becomes outdated, it should be removed. Therefore, specifying a cache replacement policy is crucial when implementing caching. Common cache replacement policies include: LRU (Least Recently Used), LFU (Least Frequently Used), FIFO (First In, First Out), and Random Replacement.\nLRU (Least Recently Used) removes the least recently accessed data when the cache becomes full. It ensures that data that have been accessed more recently are more likely to be accessed again in the future. LFU (Least Frequently Used) removes the least frequently accessed data when the cache is full. It ensures that data that have been accessed more frequently are more likely to be accessed again in the futrue. FIFO (First In, First Out) removes the oldest data when the cache becomes full. It assumes that the oldest data are least likely to be accessed in the future. Random Replacement removes random data when the cache is full. This policy can be useful when the data access pattern is unpredictable. Cache Invalidation SHOW CONTENTS Cache Invalidation is the process of marking data in the cache as stale or directly removing it from the cache, ensuring that the cache doesn\u0026rsquo;t serve outdated or incorrect data. Common cache invalidation schemes include write-through cache, write-around cache, write-back cache, and write-behind cache.\nWrite-Through Cache: In a write-through scheme, data is written to both the cache and the data store simultaneously. This ensures that the cached always serves the most up-to-date data, but it introduces latency, as each write operation must be performed twice before the data is returned. Write-Around Cache: In a write-around scheme, data is directly written to the underlying data store, bypassing the cache. This prevents the cache from becoming flooded with less frequently accessed data, while ensuring that the data store always holds the most recent data. However, this can result in a cache miss when requesting data that was recently written. Write-Back Cache: In a write-back scheme, data is written only to the cache, and the write operation is immediately confirmed. The data is written to the data store only when the cached data is evicted. This ensures low latency and high throughput but may lead to data loss in the event of a crash, as the data is stored only in the cache. Write-Behind Cache: Similar to the write-back scheme, the write-behind cache writes data to the underlying store after a specified delay. The key difference is that in a write-back cache, data is only written to the data store when necessary (e.g., upon eviction). In contrast, in a write-behind cache, data is written to the data store at regular intervals. Here are some of the most commonly used cache invalidation methods:\nPurge: The purge method removes cached data immediately. When a purge request is received, the cached data is deleted, and the next time the key is requested, the cache fetches a fresh copy from the original data store, stores it, and returns it. Refresh: The refresh method updates the cached data with the latest data from the original data store. This ensures the cache always holds the most up-to-date data. Ban: The ban method blocks access to certain cached data. When a ban command is issued, the key is added to a ban list. From then on, every request is checked against the ban list. If the requested resource matches an invalidation rule, the cache treats it as stale, fetches a fresh copy from the original data store, and updates the cache. Unlike purge, which removes the cache entry immediately, ban simply marks the entry as stale, and the data remains in the cache until it is evicted. Time To Live (TTL) Expiration: This method involves setting a time-to-live (TTL) value for cached data. Once the TTL expires, the data is considered stale. When a request is made, the cache checks the TTL of the cached data and serves it only if if hasn\u0026rsquo;t expired. If expired, the cache fetches the fresh copy from the original data store and returns it. Stale-While-Revalidate: This method serves the cached data to the client immediately when a request is received. Meanwhile, the cache asynchronously updates itself with the latest version of the data from the original data store. This approach ensures a qucik response, even if the cached data is slightly outdated, and is commonly used in CDN caching. Cache Read Strategies SHOW CONTENTS Cache read strategies define how the cache behaves when a cache miss occurs. The most common cache read strategies are read-through and read-aside.\nIn a read-through cache strategy, the cache is responsible for fetching fresh data from the original data store when a cache miss occurs. If the requested data is not found in the cache, the cache automatically retrives the data from the data store, stores it in the cache, and returns it to the client. In a read-aside cache strategy, the application first requests the data from the cache. If the data is found, the cached data is used. However, if the data is not found, the application fetches the data from the underlying data store, updates the cache with the retrived data, and then uses it. Cache Coherence and Cache Consistence SHOW CONTENTS Cache coherence refers to the consistency of data stored in multiple caches that are part of the same system, particularly in multi-core systems. In a distributed system, each cache may store a local copy of shared data. When one cache modifies its copy, all other caches holding a copy of that data must be updated or invalidated to maintain consistency. The most common protocols for achieving cache coherence are write-invalidate and write-update.\nWrite-Invalidate: When a cache writes to its copy of shared data, it broadcasts a message to all other caches, invalidating their copies. When another cache needs the updated data, it fetches the new data from memory or from the cache that made the update. Write-Update: When a cache writes to its copy of shared data, it broadcasts a message to all other caches, prompting them to update their local copies accordingly. Cache consistency focuses on maintaining the consistency of data between the cache and the original data source. Cache consistency models define the rules governing how data is updated and accessed in a distributed system with multiple caches. These models vary in terms of their strictness, and include strict consistency, sequential consistency, casual consistency, and eventual consistency.\nStrict Consistency: In a strict consistency model, any write to a data item is immediately visible to all caches. While this ensures data is always up-to-date, it may lead to performance issues due to the significant synchronization overhead required. Sequential Consistency: In a sequential consistency model, all operations on data items must appear in a specific, sequential order across all caches. This model ensures a predictable order of operations but may not guarantee the exact real-time visibility of changes. Casual Consistency: In a casual consistency model, operations that are casually related (e.g., one operation depends on the outcome of another) are guaranteed to appear in order across multiple caches. Operations that are not casually related can occur in any order. This model strikes a balance between on consistency and performance. Eventual Consistency: In an eventual consistency model, updates to a data item will eventually propagate to all caches, but there is no guarantee regarding the order or timing of these updates. This model offers the best performance but the weakest consistency guarantees, making it ideal for distributed systems where performance and scalability are prioritized over strict consistency. Caching Challenges SHOW CONTENTS The main cache-related issues include Thundering Herd, Cache Penetration, Cache Stampede, and Cache Pollution.\nThundering Herd: This problem arises when a popular piece of data expires, leading to a sundden surge of requests to the original server, resulting in performance degradation. Solutions include staggered expiration times, cache locking, or background updates before expiration.\nCache Penetration: This occurs when multiple requests for non-existent data bypass the cache, querying the original data store directly. Solutions include negative caching (caching \u0026ldquo;not found\u0026rdquo; responses) or using a Bloom Filter to check the existence of data before querying the cache.\nCache Stampede: This happens when multiple requests for the same data arrive after cache expires, causing a heavy load on the original data source. Solutions typically involve request coalescing (letting on request fetch the data while others wait) or implementing a read-through cache, where the cache itself fetches missing data. Cache Pollution: This occurs when less frequently accessed data displaces more frequently accessed data, reducing cache hit rates. To mitigate cache pollution, eviction policies such as LRU (Least Recently Used) or LFU (Least Frequently Used) can be implemented.\nData Partitioning SHOW CONTENTS In system design, data partitioning is a technique used to break large datasets into smaller, more manageable units called partitions. Each partition is independent and contains a subset of the overall data. Common data partitioning methods include horizontal partitioning and vertical partitioning.\nHorizontal partitioning, also known as sharding, involves dividing a database into multiple shards, with each shard containing a subset of rows. These shards are typically stored on different database servers, allowing for parallel processing and improving query execution times. Vertical partitioning divides a database into multiple partitions based on columns, with each partition containing a subset of the columns. This technique is commonly used when some fields are accessed more frequently than others, optimizing performance for specific queries. Data sharding splits table horizontally, here are some common sharding techniques.\nRange-Based Sharding: Data is divided based on a specific range, such as numeric ranges or dates. For example, an e-commerce platform may partition the order table by order date. Hash-Based Sharding: Data is partitioned by applying a hash function to a partition key. The hash value determines which shard will store the data. Directory-Based Sharding: Data is partitioned based on a lookup table that tracks which shard contains which data. Geographical Sharding: Data is divided based on geographical locations, such as countries or regions. Hybrid-Based Sharding: A combination of multiple sharding strategies to optimize system performance. Proxy SHOW CONTENTS A proxy is an intermediary server or software that sits between the client and the internet, typically used for tasks like filtering, caching, or security checks. Proxies can consolidate multiple client requests into a single request, a process known as collapsed forwarding. For instance, if multiple clients request the same resource, the proxy can cache the resource and serve it to those clients without having to forward the request to the origin server each time. There are two main types of proxies: forward proxy and reverse proxy.\nA forward proxy acts on behalf of the client, hiding its identity by forwarding requests from the client to the server. It is often used to mask the client’s IP address, bypass geo-restrictions, or cache content for faster access.\nA reverse proxy, on the other hand, acts on behalf of the server, intercepting incoming requests from clients and directing them to the appropriate backend server. This type of proxy is commonly used for load balancing, caching, and enhancing security by hiding the backend server details from clients.\nReplication SHOW CONTENTS Replication Methods SHOW CONTENTS CAP Theorem SHOW CONTENTS Database Federation SHOW CONTENTS Security SHOW CONTENTS Distributed Messaging System SHOW CONTENTS Distributed File System SHOW CONTENTS Misc Concepts Bloom Filters SHOW CONTENTS Long-Polling, WebSockets, and Server-Sent Events SHOW CONTENTS Quorum SHOW CONTENTS Heartbeat SHOW CONTENTS Leader and Follower SHOW CONTENTS Message Queues vs. Service Bus SHOW CONTENTS Stateful vs. Stateless Architecture SHOW CONTENTS Event-Driven vs. Polling Architecture SHOW CONTENTS ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/system-design/1-system-design/","summary":"Introduction to System Design SHOW CONTENTS System Design is the process of defining the architecture, components, modules, interfaces, and data for a system to fulfill specific business requirements, while ensuring scalability, maintainability, and performance.\nLoad Balancing SHOW CONTENTS In System Design, Load Balancing refers to the practice of distributing incoming network traffic or workload across multiple servers or resources to optimize resource use and ensure high availability.\nTo fullly leverage scalability and redundency, load balancing can occur at different layers: between user and the web server, between web server and an internal platform serve, between internal platform server and database as illustrated in the following image:","title":"System Design"},{"content":"1. Introduction to Linux SHOW CONTENTS Open Source refers to software whose source code is freely available to the public for anyone to view, modify, and distribute. It encourages coolaboration, transparency, and community-driven improvements.\nOpen Source Licenses are legal agreements that define how software can be used, modified, and distributed. There are two main types of Copyleft and Permissive.\nCopyleft licenses require that any modified versions of the software also be open source, under the same terms as the original. Popular examples include the GPL (GNU General Public License) and AGPL (Affero GPL). Permissive licenses are more relaxed, allowing users to modify, distribute, and even close-source the software if desired. Well-known examples of permissive licenses include the MIT License, Apache License 2.0, and BSD License (Berkeley Software Distribution). The differences between Fedora, CentOS Stream, and Red Hat Enterprise Linux (RHEL) are primarily based on their release cycles, stability, and target audiences. Fedora is a cutting-edge distribution that always features the latest software and technologies, making it ideal for developers and enthusiasts who want to experience the newest features. CentOS Stream serves as a rolling preview of future RHEL versions, acting as a middle ground between Fedora and RHEL. Finally, RHEL is the most stable and secure option, designed for enterprise environments that require long-term support and paid services. RHEL is commonly used in production systems that demand reliability and robust commercial support. 2. Manage Files From the Command Line Linux File System Hierarchy SHOW CONTENTS The Linux File System Hierarchy defines the directory structure and directory contents in Linux-based operating systems. It stores all files which organized into a single incerted tree structure.\nHere’s an overview of the key directories in the Linux file system hierarchy:\nLocation Purpose /boot Files to start the boot process. /dev Special device files that the system uses to access hardware. /etc System-specific configuration files. /home Home directory, where regular users store their data and configuration files. /root Home directory for the administrative superuser, root. /run Runtime data for processes that started since the last boot. This data includes process ID files and lock files. The contents of this directory are re-created on reboot. This directory consolidates the /var/run and /var/lock directories from earlier versions of Red Hat Enterprise Linux. /tmp A world-writable space for temporary files. Files that are not accessed, changed, or modified for 10 days are deleted from this directory automatically. The /var/tmp directory is also a temporary directory, in which files that are not accessed, changed, or modified in more than 30 days are deleted automatically. /usr Installed software, shared libraries, including files, and read-only program data. Significant subdirectories include: /usr/bin: User commands; /usr/sbin: System administration commands; /usr/local: Locally customized software /var System-specific variable data that should persist between boots. Files that dynamically change, such as databases, cache directories, log files, printer-spooled documents, and website content, might be found under /var. static, dynamic(variable), persistent, runtime: Static content remains unchanged until explicitly edited or reconfigured; Dynamic (Variable) content might be modified or appended by active processes; Persistent content remains after a reboot, such as configuration settings; Runtime content from a process or from the system is deleted on reboot.\nCommon Directory and File Management Commands SHOW CONTENTS pwd: Prints the current working directory (path) to the terminal. cd: Changes the current working directory to the home directory of the current user. cd -: Changes the directory to the previous directory. cd ../..: Moves up two levels in the directory structure. cd ..: Moves up one level in the directory structure (to the parent directory). ls -l: Lists files and directories in the current directory in long format, showing details such as permissions, owner, group, size, and last modification time. ls -al: Lists all files (including hidden files) in the current directory in long format. ls -lR: Lists files and directories recursively in the current directory and all its subdirectories, in long format. ls -l file*.txt: Lists files that start with the word file and end with .txt. cp hello.py HELLO.py: Copies the file hello.py to HELLO.py. The original file remains unchanged. mv -v hello.py HELLO.py: Moves (or renames) the file hello.py to HELLO.py. The -v option prints verbose output showing the operation. rm HELLO.py: Removes (deletes) the file HELLO.py. Be careful, as this is a permanent deletion. mkdir HOME: Creates a new directory named HOME in the current directory. rmdir HOME: Removes an empty directory named HOME. If the directory contains any files, it cannot be removed with rmdir. Create Links Between Files SHOW CONTENTS In Linux, there are two types of links that can be created for files: hard links and soft links. A hard link is a direct reference to the data of a file. It creates another name for an existing file, pointing directly to the file\u0026rsquo;s inode (the underlying data structure that holds the file\u0026rsquo;s metadata and data.) A soft link, on the other hand, is a reference to the original file\u0026rsquo;s path, rather than directly pointing to the file\u0026rsquo;s inode.\nHard links that reference the same file share the same inode struct with the link count, access permissions, user and group ownership, time stamps, and file content. Therefore, when any of this information is changed for one hard link, the changes are reflected in all other hard links pointing to the same file.\nCommands for creating links between files are as follows:\nln file.txt file_link.txt # Create a hard link ls -i file.txt file_link.txt # Show the inode number for both files ln -s file.txt file_soft.txt # Create a soft link ls -l file_soft.txt # Check if the soft link work (file_soft.txt -\u0026gt; file.txt) 3 Get Help Using man Command SHOW CONTENTS The man command in Linux is used to display the manual pages for various commands, programs, system calls, etc. The man pages are divided into 9 sections: executable programs or shell commands, system calls, library calls, special files, file formats and conventions, games, miscellaneous, system administration commands, and kernel routines (non standard).\nExecutable programs or shell commands: Commands executed by regular users (e.g., ls, cp). System calls: Functions that the kernel provides for programs to interact with the system (e.g., open, read). Library calls: Functions that can be used in programs written in C and other languages (e.g., printf). Special files: Usually found in /dev(e.g., /dev/sda). File formats and conventions: Descriptions of file formats (e.g., /etc/passwd). Games: Information about games available on the system. Miscellaneous: including macro packages and conventions (e.g. man(7), groff(7)). System administration commands: Commands for system administrators (e.g., useradd, systemctl). Kernel routines: Non standard The most common way to use man command including:\nman open or man open.3: Displays the manual page for the open command. (open exists in Section 2 (System Calls) and Section 3 (Library Functions), man open display the System Call documentation while man open.3 display the Library Function manual.) man -f ls: Displays a brief description of the ls command, equivalent to whatis ls. man -k ls: Searches the manual page database for the term ls, equivalent to apropos ls. Note that before running man -f ls or man -k ls, it is important to ensure that the mandb database has been built. This can be done by running sudo mandb.\n4. I/O Redirection \u0026amp; Pipelines I/O Redirection SHOW CONTENTS A process reads input and writes output. By default, it reads input from the keyboard and sends its output to the terminal window. Processes use numbered channels called file descriptors to manage input and output. Every process starts with at least three file descriptors:\nStandard Input (channel 0): Reads input from the keyboard. Standard Output (channel 1): Sends normal output to the terminal. Standard Error (channel 2): Sends error messages to the terminal. Number Channel Name Description Default Connection Usage 0 stdin Standard input Keyboard Read only 1 stdout Standard output Terminal Write only 2 stderr Standard error Terminal Write only 3+ filename Other files None Read/write or both By default, a process takes input from the keyboard and displays its output on the terminal. Redirection refers to changing the default input or output of a command. The following table summarizes the different types of redirection available:\nUsage Explanation Vitulization \u0026gt; file Redirect stdout to overwrite a file \u0026gt;\u0026gt; file Redirect stdout ot append to a file 2\u0026gt; file Redirect stderr to overwrite a file 2\u0026gt; /dev/null Discard stderr error messages by redirecting them to /dev/null \u0026gt; file 2\u0026gt;\u0026amp;1 or \u0026amp;\u0026gt; file Redirect stdout and stderr to overwrite the same file \u0026gt;\u0026gt; file 2\u0026gt;\u0026amp;1 or \u0026amp;\u0026gt;\u0026gt; file Redirect stdout and stderr to append the same file sort \u0026lt; file \u0026gt; sorted_file Redirects the stdin to a file and redirect stdout to overwrite a different file It is important to note that the order of redirection operations is crucial. For example:\nThe command \u0026gt; output.log 2\u0026gt;\u0026amp;1 redirects both standard output and standard error messages to the same file, output.log. On the other hand, 2\u0026gt;\u0026amp;1 \u0026gt; output.log redirects standard error messages to the default standard output (the terminal), and then redirects only the standard output to output.log. Additionally, the command \u0026gt; output.log 2\u0026gt;\u0026amp;1 can be shortened to \u0026amp;\u0026gt; output.log. However, it is important to note that \u0026amp;\u0026gt; is not standardized and may not be implemented in all shells.\nPipelines SHOW CONTENTS A pipeline is a sequence of one or more commands that are connected by the vertical bar character (|). In a pipeline, the standard output of one command is passed directly as the standard input to the next command.\nThe main difference between pipelines and I/O redirection lies in how they handle data. I/O redirection refers to sending standard output to a file or receiving standard input from a file. In contrast, pipelines are used to send the standard output of one process directly to the standard input of another process.\nThe following are some commonly used pipeline examples:\ncat file.txt | grep \u0026quot;pattern\u0026quot;: Searches for patterns within text. cat file.txt | sort: Sorts the lines of text in a specified order (alphabetically by default). cat file.txt | wc -l: Counts the number of lines in a file. cat file.txt | tee output.txt: Outputs the content of a file to both the terminal and a specified file. find / -name \u0026quot;passwd\u0026quot; 2\u0026gt;\u0026amp;1 | less: find / -name \u0026quot;passwd\u0026quot;: Searches for a file or directory named passwd starting from the root directory (/). 2\u0026gt;\u0026amp;1: Redirects standard error (file descriptor 2) to standard output (file descriptor 1). This ensures that any error messages, such as permission denials, are also passed along with the normal output. | less: Pipes the combined output (standard output and error messages) into the less command. 5. Bash Environment Configuration SHOW CONTENTS When Bash starts, several initialization scripts are executed to configure the shell environment, with the specific scripts depending on whether the shell is interactive, non-interactive, login, or non-login. An interactive shell allows users to enter commands directly, while a non-interactive shell runs in the background. A login shell is invoked when a user logs in via terminal or SSH, while non-login shell is opened from an existing session, like when launching a terminal in a GUI.\nFor interactive login shells, the environment is configured by the /etc/profile and ~/.bash_profile files, which also source /etc/bashrc and ~/.bashrc respectively. For interactive non-login shells, only /etc/bashrc and ~/.bashrc are used. System-wide configurations are stored in /etc/profile and /etc/bashrc, while user-specific configurations are in ~/.bash_profile and ~/.bashrc.\n6. Manage Local Users and Groups User \u0026amp; Group Concepts SHOW CONTENTS A user is an individual account created on a Linux system that can own files, execute commands, and interact with the system. User details are typically stored in the /etc/passwd file, where each line represents a user account with specific information like username, UID, home directory, and default shell.\nIn Linux, there are three primary types of users:\nSuperuser: The superuser account is responsible for administering the system. Its name is root with a UID of 0. It has full system access. System User: These accounts are used by processes or daemons that provide system services (e.g., web servers, databases). System users are non-privileged and are created to isolate and secure the services they support. Regular User: The regular user is the typical user who do not have root priviledges and have limited access to the system. A group is a collection of users that can be assigned a common set of permissions. The group details are typically stored in etc/group, which contains information about group names, GIDs, and the list of users that belong to each group.\nIn Linux, there two main types of group: the primary group and the secondary group.\nPrimary Group: The primary group is the default group assigned to a user. It is used as the group ownership for files and directories the user creates. By default, a user’s primary group often shares the same name as the username. Secondary Groups: These are additional groups to which a user can belong. Secondary groups provide users with access to shared resources or enable them to perform tasks that require specific group-level permissions. Gain Superuser Access SHOW CONTENTS In RHEL 9, to switch from a regular user to a superuser (root), the su command is used. To switch back from the root account to a regular user, the command su - user_name can be used, or alternatively, typing exit will return to the previous user account.\nIf a regular user is not in the sudoers file, an error message such as \u0026quot;user_name is not in the sudoers file. This incident will be reported.\u0026quot; will appear when trying to run a command with sudo. To enable full sudo access for a specific user, switch to the root account and then add the line user_name ALL=(ALL) ALL to the /etc/sudoers file. Similarly, to provide users in a specific group full sudo access, the line %group_name ALL=(ALL) ALL should be added.\nIt’s important to use the visudo command to edit the /etc/sudoers file, as it performs syntax checks to avoid errors that could lock out users from using sudo.\nManage Local User Accounts SHOW CONTENTS To create a user, use the useradd command. When executing useradd user_name, it creates the user\u0026rsquo;s home directory, sets up the account information, and generates a private group for the user named user_name. The default configuration for creating a new user is defined in the /etc/login.defs file. Note that at this point, the user account does not have a valid password set, so the user cannot log in until a password is assigned. To set a password for the user, the passwd command should be used. To delete a user, the userdel command is used. The userdel user_name command removes the user_name from the /etc/passwd file but leaves the user\u0026rsquo;s home directory intact. If it is necessary to delete the home directory as well, the userdel -r user_name option should be used. It’s important to note that when deleting a user without the -r option, the files owned by the user will be left with an unassigned UID. If a new account is later assigned to the same UID, that account will inherit the old user\u0026rsquo;s files, which poses a security risk. For this reason, many organizations prefer to lock user accounts instead of deleting them, in accordance with security policies.\nManage Local Group Accounts SHOW CONTENTS The commands for managing local group accounts include groupadd, groupmod, and groupdel.\ngroupadd: This command is used to create a new group. By default, it assigns the next available GID from the range specified by the GID_MIN and GID_MAX variables in the /etc/login.defs file. groupmod: This command is used to modify an existing group, such as changing its group name or GID. groupdel: This command is used to delete an existing group. However, it\u0026rsquo;s important to note that the primary group of an existing user cannot be removed. Here are some commonly used commands for managing local group accounts:\ngroupadd -g group_id group_name: Creates a new group with a specified GID. groupmod -n old_group_name new_group_name: Renames an existing group from old_group_name to new_group_name. groupmod -g group_id group_name: Changes the GID of an existing group (group_name) to a specified group id. usermod -aG group_name user_name: Adds a user (user_name) to an additional group (group_name) without removing the user from their existing groups. The -aG option ensures the user is appended to the group list rather than replacing the existing group memberships. newgrp group_name: Changes the current group to the named group. groupdel group_name: Deletes the specified group (group_name). Note that the primary group of any existing users cannot be deleted. Manage User Passwords SHOW CONTENTS In Linux, /etc/passwd and /etc/shadow are critical system files that store user account information and password data, repectively. The /etc/passwd file contains basic information about user accounts on the system, while the /etc/shadow file is used to store encrypted user password information, as well as other related data such as password expiration and account locking details.\nHere is the breakdown of the line from /etc/shadow:\nThe chage command is used to configure password aging parameters for user accounts, allowing administrators to manage password expiration, warning periods, and other related settings (as shown in the following image).\nMin Days (Minimum Days Between Password Changes): The minimum days (default is 0) parameter specifies the minimum number of days that must pass before a user can change their password after setting it for the first time or after a password change. For example, if min days is set to 7, then after changing their password, the user will not be able to change it again until 7 days have passed. Max Days (Maximum Days Between Password Changes): The maximum days (default is 99999) parameter defines the maximum number of days that a user is allowed to use the current password. After this period, the user will be required to change the password. For example, If max days is set to 30, the user must change their password every 30 days. After 30 days, they will be prompted to change it. Warn Days (Warning Period Before Password Expiration): The warn days (default is 7) parameter specifies how many days before the password expires the user will be warned to change their password. The warning is displayed when the user logs in. For example, If warn days is set to 7, the user will receive a warning 7 days before the password expiration. Expiration Date/Inactivity Days: The expiration date (default is None) specifies the date when the user’s account will be locked. If the inactivity days is set to 0, the account will be locked immediately after the expiration date. The inactivity days parameter (default is 7) defines the grace period after a password expires during which the user can still log in. During this period, the user is required to change the expired password using the passwd command before the account is locked. If the password is not changed within this grace period, the account will be locked. For example, if the expiration date is set to 2024-12-01 and the inactivity days is set to 7, the user can continue logging in until 2024-12-08. After 2024-12-08, the user’s account will be locked, and contact with an administrator will be necessary to reactivate the account. Below are some commonly used chage commands:\nchage -E $(date -d \u0026quot;+30 days\u0026quot; +%F) user_name: This command sets the expiration date of a user\u0026rsquo;s account to 30 days from the current date. chage -d 0 user_name: This command forces the user to change their password immediately. There are common scenarios where user access needs to be restricted, such as temporarily blocking a user or disabling access for a former employee. Below are some common methods for restricting user access.\nHere are the descriptions for the mentioned commands:\nusermod -L user_name: This command locks the user account by disabling the password. It works by placing an exclamation mark (!) in front of the password hash in the /etc/shadow file, preventing the user from logging in. usermod -L -e 2024-12-31 user_name: This command locks the user account and also sets an expiration date for the account. usermod -s /sbin/nologin user_name: This command changes the login shell for the user to /sbin/nologin, which prevents the user from logging in interactively. It\u0026rsquo;s important to note that this command does not prevent all types of access. Users may still be able to authenticate and upload or retrieve files through applications like file transfer programs or mail clients, as long as the user knows the password. 7. Control Access to Files File System Permissions Concepts SHOW CONTENTS In Linux, file system permissions control the access and actions that users can perform on files and directories. These permissions help manage security and determine who can read (r), write (w), or execute (x) a file. Permissions are typically displayed in a 10-character string, such as -rwxr-xr--. The 10 characters consist of a file type and three sets of permissions (User, Group, and Others):\nThe first character in the file permission string represents the file type. Common file types include - for regular files, d for directories, l for symbolic links, c for character device files, b for block device files, p for named pipe files, and s for local socket files.\nThe first set represents the user (owner) permissions. The second set represents the group permissions. The third set represents the others (everyone else) permissions. Each set of permissions is made up of three characters, corresponding to read (r), write (w), and execute (x). For example, rwx indicates full permissions (read, write, execute) and r-- stands for read-only permissions.\nManage File System Permissions SHOW CONTENTS The chmod command is used to modify file system permissions for files and directories. The standard syntax is chmod [options] mode file_or_directory_name. The mode can be specified in either symbolic mode (e.g., r, w, x) or numeric mode (e.g., 755, 644). In numeric mode, permissions are represented by a three-digit number, where each digit corresponds to a set of permissions for the user, group, and others. Each permission is assigned a value: 4 for read, 2 for write, and 1 for execute. The sum of these values determines the permissions for each set. Below are some commonly used commands for changing file system permissions:\nchmod 755 file: Grants read, write, and execute permissions to the user, and read and execute permissions to the group and others. chmod 644 file: Grants read and write permissions to the user, and read-only permissions to the group and others. chmod +x file: Adds execute permission for all user categories (user, group, and others). chmod -x file: Removes execute permission for all user categories. chmod u+x file: Adds execute permission for the user (owner) only. chmod g-w file: Removes write permission from the group. chmod o+r file: Grants read permission to others. To change the user or group ownership of a file or directory in Linux, the chown command is used. Only the root user can change the ownership of a file. However, both the file\u0026rsquo;s owner and the root user can modify the file\u0026rsquo;s group ownership. While the root user can assign file ownership to any group, regular users can change the group ownership of a file only if they are members of the target group. Below are some commonly used commands for changing the user or group ownership of a file or directory.\nchown user_name file_name: Changes the owner of a file or directory to the specified user_name. chown user_name:group_name file_name: Changes both the owner and the group of a file or directory. chown :group_name file_name: Changes only the group ownership of the file or directory. chown -R user_name directory_name: Recursively changes the ownership of files and directories within the specified directory. chgrp group_name file_name: Changes only the group ownership of a file or directory to the specified group_name. chgrp -R group_name directory_name: Recursively changes the group ownership of files and directories within the specified directory. Sepcial Permissions \u0026amp; Default Permissions SHOW CONTENTS In Linux, special file permissions provide advanced control over file and directory access. These permissions include setuid, setgid, and the sticky bit.\nsetuid: This permission is represented with s in the user permission set. When set on an executable file, it allows the program to be executed with the privileges of the file owner (usually root) rather than the privileges of the user running the file. For example, the file /usr/bin/passwd is owned by the root user, but it can be executed by a regular user without sudo because it has the setuid permission in the user permission set (-rwsr-xr-x. 1 root root 32648 Aug 10 2021 /usr/bin/passwd). setgid (Group ID): This permission is represented with s in the group permission set. When applied to a file, it causes the program to run with the group privileges of the file\u0026rsquo;s group. For directories, it ensures that files created within the directory will inherit the directory\u0026rsquo;s group rather than the user\u0026rsquo;s group. For example, the file /usr/bin/locate (-rwx--s--x. 1 root slocate 41032 Aug 10 2021 /usr/bin/locate) has the setgid permission in the group permission set, allowing it to run with the group privileges of the file\u0026rsquo;s group. Similarly, the directory /run/log/journal (drwxr-sr-x+ 3 root systemd-journal 60 Apr 15 09:44 /run/log/journal/) has the setgid permission in the group permission set. This ensures that files created within the directory will inherit the systemd-journal group. sticky bit: This permission is represented with t in the others\u0026rsquo; permission set. When applied to a directory, it allows only the file owner to delete or modify their files, preventing other users from tampering with them. For example, the directory /tmp (drwxrwxrwt. 20 root root 4096 Apr 17 08:32 /tmp) has the sticky bit set in the others\u0026rsquo; permission set. This ensures that a user can only modify or delete the files in the /tmp directory that they own. In Linux, when a file or directory is created, its default permission is determined by the combination of the initial permission and the umask (user file creation mask). By default, files are created with initial permissions of 0666 (-rw-rw-rw-), and directories with 0777 (drwxrwxrwx). The umask defines which permission bits should be removed from these initial values, Typically, the default umask is 0022. This value can be modified in /etc/bashrc. For example, if the umask is set to 0022, a newly created file will have permissions 0644 (-rw-r--r--) because 0666 - 0022 = 0644. Similarly, a newly created directory will have permissions 0755 (drwxr-xr-x) because 0777 - 0022 = 0755.\n8. Monitor \u0026amp; Manage Linux Processes Process Life Cycle \u0026amp; States SHOW CONTENTS A process is a running instance of an executable program. Once created, a process includes several key components: an address space for allocated memory, security properties such as ownership and privileges, one or more execution threads for running code, and a process state that reflects its current status.\nThe environment of a process contains important contextual information, including local and global variables, the current scheduling context, and system resources like file descriptors and network ports that are assigned to the process.\nA new process is typically created when an existing parent process duplicates its own address space through a mechanism called a process fork. The resulting child process is assigned a unique Process ID (PID) for identification and security purposes. The child process also records the Parent Process ID (PPID) as part of its environment. On systems like Red Hat, all processes ultimately descend from the first system process, systemd.\nThrough the fork operation, the child process inherits the parent’s security credentials, file descriptors, resource privileges, environment variables, and program code. Once forked, the child process can continue running the same code or replace it with its own program logic using an exec family function.\nTypically, after creating a child process, the parent process enters a waiting state, pausing its own execution until the child finishes. When the child process exits, it releases its resources, but its process table entry remains temporarily as a zombie process. Once the parent receives a termination signal from the child, it performs cleanup by removing the zombie entry from the process table, freeing the last of the child’s resources, and then resumes its own execution.\nIn Linux, every process moves through a series of well-defined states during its lifecycle. The following image and table describe Linux process states in detail.\nTASK_INTERRUPTIBLE: TASK_UNINTERRUPTIBLE: TASK_KILLABLE: TASK_REPORT_IDLE: Flags TASK_UNINTERRUPTIBLE and TASK_NOLOAD are set. Similar to TASK_KILLABLE, also a subset of state D. It accepts fatal signals.\nName Flag Kernel-defined state name and description Running R TASK_RUNNING: The process is either executing on a CPU or waiting to run. The process can be executing user routines or kernel routines (system calls), or be queued and ready when in the Running (or Runnable) state. Sleeping S TASK_INTERRUPTIBLE: The process is waiting for some condition: a hardware request, system resource access, or signal. When an event or signal satisfies the condition, the process returns to Running. D TASK_UNINTERRUPTIBLE: This process is also sleeping, but unlike S state, does not respond to signals. Used only when process interruption might cause an unpredictable device state. K TASK_KILLABLE: Identical to the uninterruptible D state, but modified to allow a waiting task to respond to the signal that it should be killed (exit completely). Utilities frequently display Killable processes as D state. I TASK_REPORT_IDLE: A subset of state D. The kernel does not count these processes when calculating load average. Used for kernel threads. Flags TASK_UNINTERRUPTIBLE and TASK_NOLOAD are set. Similar to TASK_KILLABLE, also a subset of state D. It accepts fatal signals. Stopped T TASK_STOPPED: The process is stopped (suspended), usually by being signaled by a user or another process. The process can be continued (resumed) by another signal to return to running. T TASK_TRACED: A process that is being debugged is also temporarily stopped and shares the same T state flag. Zombie Z EXIT_ZOMBIE: A child process signals to its parent as it exits. All resources except for the process identity (PID) are released. X EXIT_DEAD: When the parent cleans up (reaps) the remaining child process structure, the process is now released completely. This state cannot be observed in process-listing utilities. In Linux, the ps and top commands are commonly used to inspect processes. The ps command displays information about active processes and is typically used to capture a snapshot of the processes running at a specific moment. In contrast, the top command provides a real-time, dynamic view of system processes, continuously updating to show CPU usage, memory usage, uptime, load average, and resource consumption for each process.\nControl Jobs SHOW CONTENTS In Linux, a job refers to a command or a group of commands initiated from a terminal by a user. Jobs can run in two modes: as a foreground job or a background job. A foreground job occupies the terminal until it completes, while a background job runs independently, allowing the terminal to remain available for other tasks. For example, executing vim file.txt starts a foreground job, which holds the terminal until the editor is closed. Running sleep 300 \u0026amp; starts a background job, allowing the terminal to remain usable while the command runs for 300 seconds in th e background.\nA process is a running instance of a program. When a job is initiated, one or more processes are created to perform the assigned tasks. For example, typing ls -l creates a new process to handle the application.\nA pipeline is a sequence of commands connected by the | operator, where the output of one command is passed directly as input to the next. For example, the command ps aux | grep nginx | sort forms a pipeline involving three separate processes working in succession. In this case, a pipeline runs as one job, but each part is a separate process.\nA session is a collection of processes initiated from a single user login. The first process created in a session is known as the session leader. For example, when a user logs in to a server via ssh user_name@ip_address, the shell process (bash, zsh, etc.) acts as the session leader. All jobs and processes started from that terminal belong to the same session.\nIn Linux, job control allows management of multiple jobs (commands or processes) within a single terminal session. Job control makes it possible to pause, resume, move jobs between the foreground and background, or terminate them. Below are the common-use commands for job control:\nCtrl + Z: Suspends the current foreground job and puts it into the background in a stopped state. bg: Resumes a suspended job in the background. fg: Brings a background job back to the foreground. jobs: Lists all jobs associated with the current terminal session, showing each job’s ID and status (e.g., running, stopped). In the output, a + next to a job ID denotes the current default job, which is the target of any bg or fg command issued without a %jobID. A - marks the previous job, which will become the default once the current default job completes or is removed. For example: [1] Running sleep 100 \u0026amp; [2] Running sleep 100 \u0026amp; [3]- Running sleep 100 \u0026amp; [4]+ Running sleep 100 \u0026amp; kill %job_number: Sends a signal (default is SIGTERM) to terminate a job, identified by its job number. Ctrl + C: Terminates a foreground job. Kill Processes SHOW CONTENTS In Linux, processes can be terminated using signals. A signal is a software interrupt that is delivered to a process. The following table describes common signals.\nSignal Number Description SIGTERM 15 Graceful termination (default) SIGKILL 9 Forcefully kill (non-catchable) SIGINT 2 Interrupt from keyboard (Ctrl+C) SIGHUP 1 Hang up / restart daemon SIGSTOP 19 Stop (pause) a process SIGCONT 18 Resume a stopped process Note that while signal numbers may vary across different Linux hardware platforms, signal names and their meanings remain consistent. It is generally recommended to use signal names rather than numbers when sending signals. Additionally, Red Hat advises sending SIGTERM first to allow the process to terminate gracefully, followed by SIGINT if necessary. If both signals fail, SIGKILL should be used as a last resort. The SIGKILL signal cannot be caught or ignored, and it forcibly terminates the process without giving it an opportunity to perform any self-cleanup.\nHere are some commonly used commands related to terminating processes:\nkill PID: Sends the SIGTERM signal to the specified process, requesting it to terminate gracefully. kill -SIGKILL PID: Sends the SIGKILL signal to forcefully terminate the specified process immediately (cannot be caught or ignored). killall process_name: Sends SIGTERM to all processes matching the given name, attempting a graceful termination. killall -SIGKILL process_name: Sends SIGKILL to all processes matching the given name, forcing termination. pgrep process_name: Searches for processes matching the given name and returns their PIDs. pgrep -u user_name process_name: Searches for processes with the specified name owned by a specific user. pkill process_name: Sends SIGTERM to all processes matching the given name, similar to killall. pkill -SIGKILL process_name: Sends SIGKILL to all processes matching the given name, forcing termination. pkill -u user_name: Sends a signal to all processes owned by the specified user. pstree -p: Displays the process tree with PIDs included. pstree -u: Displays the process tree with associated user names. In real-world scenarios, system administrators can forcibly terminate a user\u0026rsquo;s session to log them out. The following example demonstrates this process:\nwho -u # Lists all active user sessions along with their associated PIDs. pkill -t pts/0 # Sends SIGTERM (default) to processes attached to terminal pts/0. pkill -SIGINT -t pts/0 # If necessary, sends SIGINT to the same terminal. pkill -SIGKILL -t pts/0 # As a last resort, sends SIGKILL to forcefully terminate the session. Monitor Process Activity SHOW CONTENTS In Linux, the load average indicates the system\u0026rsquo;s workload over a period of time, measuring how many processes are either actively running or waiting to be executed by the CPU. The load average is typically represented by three numbers, corresponding to the system load over the past 1, 5, and 15 minutes. A load average of 1.0 per CPU is considered fully utilized, meaning that each CPU is handling one process at a time. For example, if a system has 2 CPUs, a load average of 2.0 would mean that the system is fully utilized. To inspect the number of CPUs in the system, the lscpu command can be used.\nFor instance, if a system has 2 CPUs and the uptime command returns:\n20:41:31 up 5:29, 3 users, load average: 3.32, 1.90, 0.32 The load average for the last minute is 3.32, which means the total load on the system is 3.32. With 2 CPUs, the per-CPU load average for the last minute is 1.66 (3.32 ÷ 2). This suggests the system is overloaded since the per-CPU load exceeds 1.0. The load average for the last 5 minutes is 1.90, and the per-CPU load average for this period is 0.95 (1.90 ÷ 2), indicating that the system is closer to optimal usage during this time. The load average for the last 15 minutes is 0.30, and the per-CPU load average is 0.16 (0.32 ÷ 2), suggesting the system is underutilized. 9. Control Services \u0026amp; Daemons SHOW CONTENTS In Linux, systemd daemon is the system and service mamager repsonsible for initializing the system during boot and managing processes throughout the machine\u0026rsquo;s lifetime. It handles the startup sequence, maintains service states, sepervises processes, and managees logging and dependencies.\nsystemd uses the concept of units to manage and control system resources. A unit represents a single object that systemd knows how to manage, such as a service, a device, a mount point, or a socket.\nEach unit is defined by a unit file, which describes how systemd should handle it — including how to start, stop, reload, and manage dependencies. Unit files are typically stored in directories like /usr/lib/systemd/system/ or /etc/systemd/system/.\nUnits are categorized by type, and the type is reflected in the file extension. Common unit types include:\n.service: for system services (e.g., nginx.service) .socket: for socket activation .target: for grouping units into milestones or states (like multi-user.target, graphical.target) .mount: for filesystem mount points .timer: for time-based activation, like a cron replacement .device: for hardware devices .path: for path-based activation To interact with systemd, the systemctl is used. It allows administrators to manage services, check system states, enable or disable services at boot, and control system targets. Here are some commonly used commands:\nsystemctl status nginx: Displays the status of the nginx service. systemctl start nginx: Starts the nginx service. systemctl stop nginx: Stops the nginx service. systemctl restart nginx: Restarts the nginx service. systemctl enable nginx: Configures nginx to start automatically at boot. systemctl disable nginx: Disables automatic start at boot for nginx. systemctl reload-or-restart nginx: Reload the configuration if supported; otherwise, restart the service. systemctl is-enabled nginx: Check if the service is enabled to start at boot. systemctl is-active nginx: Check if the service is currently running. systemctl list-dependencies nginx: List the dependencies of the service. systemctl mask sendmail.service: Mask the service to prevent it from being started. systemctl unmask sendmail.service: Unmask the service to allow it to be started again. systemctl list-units --type=service: Lists all active services. systemctl reboot: Reboots the system. systemctl poweroff: Powers off the machine. 10. Configure \u0026amp; Secure SSH SHOW CONTENTS SSH (Secure Shell) is a protocol used to securely access and manage remote systems over an unsecured network. It provides encrypted communication between a client and a server, allowing for secure login, command execution, and file transfer. Here are common SSH usage examples:\nssh user@host: Connect to a remote server using the specified user account. ssh user@host command: Execute a command on the remote server without opening an interactive shell. SSH also allows passwordless login to a remote server by using a pair of cryptographic keys: A private key and a public key. A private key is kept on the client machine while the public key is stored on the remote server in ~/.ssh/authorized_keys. When connecting, the server uses the public key to verify the client\u0026rsquo;s private key. If the key match, the connection is granted without prompting for a paasword. To enable this feature, following the following steps:\nssh-keygen -t rsa -b 4096 -C \u0026quot;RHEL 9 ON Virtual Machine\u0026quot;: Generate a key pair on the client. ssh-copy-id user_name@ip_address: Copy the public key to the remote server. ssh user_name@ip_address: Connect to the server. The default configuration of the SSH server works well for many use cases. To apply custom settings (e.g., disable remote login as root), edit the /etc/ssh/sshd_config file, modify the field PermitRootLogin to no. After modifying the configuration, apply the changes by running systemctl reload ssh.\n11. Analyze \u0026amp; Store Logs System Log Architecture SHOW CONTENTS In Red Hat Enterprise Linux, the standard logging system is based on the Syslog protocol, and the systemd-journald and rsyslog services are responsible for handling syslog messages.\nThe systemd-journald service forms the core of the operating system\u0026rsquo;s event logging architecture. It collects event messages from multiple sources, such as the system kernel, output from the early stages of the boot process, standard output and standard error from daemons, and Syslog events. systemd-journald restructures these logs into a standard format and writes them into a structured, indexed system journal. By default, this journal is stored in a file system that does not persist across reboots.\nOn the other hand, the rsyslog service reads syslog messages that systemd-journald receives from the journal as they arrive. It then processes the syslog events and records them to log files or forwards them to other services according to its configuration. The rsyslog service sorts and writes syslog messages to log files in the /var/log directory, which are persistent across reboots. This directory not only contains syslog message files but also log files from other services on the system. Below is a list of some useful log files located in the /var/log directory:\nLog File Description /var/log/messages Logs most system messages, including general syslog messages. Exceptions include authentication-related messages, email processing, scheduled job execution, and debug information. /var/log/secure Logs security-related messages, including authentication events and user access information. /var/log/maillog Logs messages related to the mail server, including both mail delivery and other mail-related operations. /var/log/cron Logs messages related to the execution of scheduled jobs (cron jobs). /var/log/boot.log Logs non-syslog console messages related to system startup and boot processes. Review Syslog Files SHOW CONTENTS In Linux, each log message is categorized by facility (which subsystem produces the message) and priority (the message\u0026rsquo;s severity). The following table lists the standard syslog facilities.\nCode Facility Description 0 kern Kernel messages 1 user User-level messages 2 mail Mail system messages 3 daemon System daemons messages 4 auth Authentication and security messages 5 syslog Internal syslog messages 6 lpr Printer messages 7 news Network new messages 8 uucp UUCP protocol messages 9 cron Clock daemon messages 10 authpriv Non-system authorization messages 11 ftp FTP protocol messages 16-23 local0 to local7 Custom local messages The following table lists the standard syslog priorities in descending order.\nCode Priority Description 0 emerg System is unusable 1 alert Action must be taken immediately 2 crit Critical condition 3 err Non-critical error condition 4 warning Warning condition 5 notice Normal but significant event 6 info Informational event 7 debug Debugging-level message The rsyslog service uses the facility and priority of log messages to determine how to handle them. Rules configure this facility and priority in the /etc/rsyslog.conf file and in any file in the /etc/rsyslog.d directory with the .conf extension.\nTo prevent log files from consuming too much disk space, Linux uses log rotation, a utility that automatically handles the archiving, compressing, and deletion of old log files. A scheduled job runs the logrotate command daily to check if any log files need to be rotated. When a log file is rotated, it is renamed with an extension indicating the rotation date. For example, the old /var/log/messages file might be renamed to /var/log/messages-20250419 when it is rotated on April 19, 2025. After rotations, typically over four weeks, the oldest log files are discarded to free up disk space.\nThe tail -f command in Linux is commonly used for monitoring log files in real time. It allows users to continuously view the latest entries being added to a log file, which is especially useful for monitoring system events and troubleshooting. Here is a sample example:\ntail -f /var/log/secure # In the first terminal ssh signalyu999@ip_address # In the second terminal The logger command sends messages to the rsyslog service, which is useful for testing changes to the rsyslog configuration. By default, it logs messages with the user facility and notice priority (user.notice), unless specified otherwise using the -p option. For example, to send a message to the rsyslog service and have it recorded in the /var/log/boot.log log file, the following logger command can be used:\n# /etc/rsyslog.conf # Save boot messages also to boot.log # local7.* /var/log/boot.log logger -p local7.notice \u0026#34;Log entry created on host\u0026#34; # TEST # 1. In the first terminal: tail -f /var/log/boot.log # 2. In the second terminal: logger -p local7.notice \u0026#34;Log entry created on host\u0026#34; Review System Journal Entries SHOW CONTENTS The systemd-journald service stores log data in a structured, indexed binary file called the journal. To retrieve log messages from the journal, the journalctl command is used. Below are some commonly used commands:\njournalctl --since \u0026quot;2025-04-18\u0026quot; --until \u0026quot;2025-04-19\u0026quot;: Shows logs from April 18, 2025, to April 19, 2025. journalctl --since \u0026quot;today\u0026quot;: Displays logs from the current day (since midnight). journalctl --since \u0026quot;-1 hour\u0026quot;: Shows logs from the last hour. journalctl --since \u0026quot;-10 minutes\u0026quot;: Displays logs from the last 10 minutes. journalctl -n 50: Shows the last 50 log entries. journalctl -u sshd: Displays logs related to the sshd service (SSH daemon). journalctl -f: Continuously shows the latest log entries in real-time. journalctl -p err: Filters and shows logs with \u0026ldquo;error\u0026rdquo; priority or higher. journalctl _PID=1234: Shows logs related to the process with PID 1234. journalctl _SYSTEMD_UNIT=sshd.service: Displays logs related to the sshd.service systemd unit. journalctl -b: Shows logs from the current boot session. Preserve the System Journal SHOW CONTENTS The systemd-journald service stores log data in a structured, indexed binary format known as the system journal. By default, Red Hat Enterprise Linux 9 stores the system journal in the /run/log directory, and the system clears the system journal after a reboot. To change this behavior and retain logs across reboots, the Storage parameter in the /etc/systemd/journald.conf file can be set to persistent. After modifying the configuration, the systemd-journald service must be restarted for the changes to take effect.\nThe Storage parameter has four options:\npersistent: Stores journals in the /var/log/journal directory, ensuring logs persist across reboots. If the /var/log/journal directory does not exist, the systemd-journald service creates it automatically. volatile: Stores journals in the volatile /run/log/journal directory. These logs are lost upon reboot. auto: If the /var/log/journal directory exists, logs are stored persistently. If the directory does not exist, volatile storage is used. This is the default behavior of the Storage parameter. none: Disables journal storage entirely, meaning no logs are stored. Maintain Accute Time SHOW CONTENTS In Linux, maintaining accurate system time is crucial for tasks such as logging, scheduling, and ensuring syschronization across different systems. Time syschronization is typically achieved through the use of the NTP (Network Time Protocol). The NTP is a standard way for machines to provide and obtain correct time information over the internet.\nMaintaing accurate time commonly involves two commands: tzselect and timedatectl. The tzslect command is an interactive utility used to select a time zone on Linux systems. It guides users through a series of prompts to set the time zone by selecting regions and cities form a list. It is helpful when users do not know the exact time zone string. The timedatectl command is provided by systemd to manage time and time zone settings on Linux systems. It allows users to query and set the system\u0026rsquo;s time, date, and time zone, as well as synchronize the system clock with NTP. Here are some common sample examples of timedatectl:\ntimedatectl status: Displays the current time zone, NTP status, and system time information. sudo timedatectl set-time \u0026quot;YYYY-MM-DD HH:MM:SS\u0026quot;: Sets the system date and time manually. sudo timedatectl set-timezone \u0026lt;timezone\u0026gt;: Changes the system\u0026rsquo;s time zone. timedatectl list-timezones: Lists all available time zones. sudo timedatectl set-ntp true: Enables NTP (Network Time Protocol) synchronization. sudo timedatectl set-ntp false: Disables NTP synchronization. sudo timedatectl set-local-rtc true: Sets the system clock to local time (RTC). sudo timedatectl set-local-rtc false: Sets the system clock to UTC (coordinated universal time). timedatectl show: Displays detailed information about the time and date settings. The chrond service keeps on track the usually inaccurate local Real-Time-Clock (RTC) by synchronizing it to the configured NTP servers. If network connectivity is unavailable, it calculates the RTC drift and stores the data in a file specified by the driftfile parameter in the /etc/chrony.conf configuration file. By default, chronyd uses servers from the NTP Pool Project but can be configured to use different servers for isolated networks. NTP servers are categorized by their stratum, with stratum 0 being a reference clock and higher strata representing servers that sync with other NTP servers. In the configuration file, servers and peers are defined, with the server being one stratum above the local server and peers at the same level. The iburst option is recommended for faster and more accurate initial synchronization.\n12. Manage Networking Networking Related Commands SHOW CONTENTS ip: A versatile tool for managing network interfaces, routing, and tunneling. ip addr pr ip a: Show IP addresses assigned to all interfaces. ip addr add 192.168.1.100/24 dev eth0: Assign an IP address to an interface. ip link or ip l: Show network interfaces and their status. ip link set eth0 up: Enable (bring up) a network interface. ip link set eth0 down: Disable (bring down) a network interface. ip route or ip r: Display the current routing table. ip route add 192.168.2.0/24 via 192.168.1.1: Add a static route. ip route del 192.168.2.0/24: Delete a route. ip neigh: Show the ARP table (neighbor cache). ss: A utility to investigate sockets. It is used for displaying information about network connections, listening ports, etc. ss: Display all established sockets and connections. ss -t: Show only TCP connections. ss -u: Show only UDP connections. ss -l: Show listening sockets. ss -tunlp: Show TCP/UDP listening ports with process info (-p). ss -s: Display a summary of socket statistics. ss -t state established: Show established TCP connections. ss -an: Show all sockets (listening and non-listening) in numeric format. ss -o state established: Show established connections with timers. ping: A tool used to test network connectivity between the client and the remote host by sending ICMP echo requests. ping baidu.com traceroute: A tool to trace the path packets take to reach a network destination, showing each hop along the way. traceroute \u0026lt;hostname/IP\u0026gt;: Trace the route packets take to reach the target host. traceroute -n \u0026lt;hostname/IP\u0026gt;: Show IP addresses only, skip hostname resolution (faster). traceroute -m 20 \u0026lt;hostname/IP\u0026gt;: Set maximum number of hops to 20. traceroute -p 80 \u0026lt;hostname/IP\u0026gt;: Use destination port 80 (helpful for testing web servers). traceroute -I \u0026lt;hostname/IP\u0026gt;: Use ICMP ECHO instead of UDP packets. traceroute -T \u0026lt;hostname/IP\u0026gt;: Use TCP SYN packets instead of UDP (helpful for firewalled networks). tracepath: A simpler version of traceroute that shows the path packets take to a destination but also provides information about packet loss and latency along the way. tracepath \u0026lt;hostname/IP\u0026gt;: Trace the path to a destination, showing each network hop along the way. tracepath -n \u0026lt;hostname/IP\u0026gt;: Display IP addresses only, skip reverse DNS lookup (faster). tracepath6 \u0026lt;hostname/IP\u0026gt;: Use IPv6 to trace the route to the target. host: A simple DNS lookup tool that resolves domain names to IP addresses. host \u0026lt;domain\u0026gt;: Resolve a domain name to its IP address. dig: A DNS lookup tool that queries the Domain Name System (DNS) for information about hostnames, IP addresses, and other DNS records. dig \u0026lt;domain\u0026gt;: Query the default DNS records (usually A records) for a domain. nmcli: A command-line interface for NetworkManager, used for manageing network connections and settings, such as configuring interfaces, VPNs, and Wi-Fi. nmcli device status or dev con status: Show the status of all network interfaces. nmcli connection show or nmcli con show: List all saved network connections. nmcli connection up \u0026lt;connection-name\u0026gt;: Activate a network connection. nmcli connection down \u0026lt;connection-name\u0026gt;: Deactivate a network connection. nmcli device connect \u0026lt;device\u0026gt;: Connect a network device. nmcli device disconnect \u0026lt;device\u0026gt;: Disconnect a network device. getent: A command used to query various system databases, including DNS, password, group, and hosts. It is useful for retriving information that\u0026rsquo;s typically stored in files like /etc/hosts or through services like DNS. getent hosts \u0026lt;hostname\u0026gt;: Resolve a hostname to its IP address (similar to host or nslookup). getent services \u0026lt;service\u0026gt;: Lookup port and protocol for a service (e.g., getent services ssh). getent protocols: List network protocols. getent passwd: List all user account entries from /etc/passwd or configured name service. getent passwd \u0026lt;username\u0026gt;: Query information for a specific user. getent group: List all group entries from /etc/group or configured name service. getent group \u0026lt;groupname\u0026gt;: Query information for a specific group. Configure Network SHOW CONTENTS In RHEL 9, the network can be configured through file-based settings by creating a .nmconnection file in the /etc/NetworkManager/system-connections directory. After editing the configuration, set the file permissions to restrict access to the root user for security. Update the /etc/resolv.conf file to specify DNS servers. Once the configuration is complete, reload the NetworkManager connection profiles to apply the changes. If autoconnect is set to false, manually bring the connection up.\nvim /etc/NetworkManager/system-connections/ens160-static.nmconnection: Open or create the network configuration file for editing. Edit the configuration file as below: [connection] id=ens160 uuid=62b7fd25-b5d9-3cae-8156-bc455c45b046 type=ethernet autoconnect-priority=-999 interface-name=ens160-static timestamp=1744708123 [ethernet] [ipv4] method=manual address1=192.168.254.138/24 gateway=192.168.254.2 ignore-auto-dns=true [ipv6] addr-gen-mode=eui64 method=auto [proxy] chown root:root /etc/NetworkManager/system-connections/ens160-static.nmconnection: Set the file owner and group to root. chmod 600 /etc/NetworkManager/system-connections/ens160-static.nmconnection: Restrict permissions so only the root user can read and modify the file. vim /etc/resolv.conf: Edit the configuration file as below: # Generated by NetworkManager nameserver 8.8.8.8 nameserver 8.8.4.4 nmcli con reload: Reload NetworkManager connection profiles to apply changes. nmcli con up ens160-static: Bring the ens160-static connection up manually (required if autoconnect is disabled). 13. Archive \u0026amp; Transfer Files Manage Compressed tar Files SHOW CONTENTS An archive is a single file that stores multiple files and directories, often used for creating backups or simplifying file transfers across a network. On Linux, the tar utility is commonly used to create, manage, and extract archives. Below are some frequently used commands:\ntar -cvf archive.tar file1 file2: Archives multiple files into a single uncompressed .tar file. tar -xvf archive.tar file1 file2 -C ./archives/: Extracts specific files from an uncompressed .tar archive to the ./archives/ directory. tar -czvf archive.tar.gz file1 file2: Creates a compressed .tar.gz archive from multiple files using gzip compression. tar -xzvf archive.tar.gz file1 file2 -C ./archives/: Extracts specific files from a .tar.gz compressed archive to the ./archives/ directory. tar -cjvf archive.tar.bz2 file1 file2: Creates a compressed .tar.bz2 archive using bzip2 compression. tar -xjvf archive.tar.bz2 file1 file2 -C ./archives/: Extracts specific files from a .tar.bz2 compressed archive to the ./archives/ directory. tar -cJvf archive.tar.xz file1 file2: Creates a compressed .tar.xz archive using xz compression. tar -xJvf archive.tar.xz file1 file2 -C ./archives/: Extracts specific files from a .tar.xz compressed archive to the ./archives/ directory. Transfer Files Using sftp SHOW CONTENTS To securely transfer files between systems, use the sftp command. Below are some commonly used sftp commands:\nsftp user_name@ip_address:/home/user_name/remote_file: Connect to the server and directly fetch a remote file to the local. sftp user_name@ip_address: Connect to the remote server via SFTP. help: Display a list of available SFTP commands. pwd: Show the current remote working directory. lpwd: Show the current local working directory. ls: List files in the remote directory. lls: List files in the local directory. cd: Change the remote directory. lcd: Change the local directory. put: Upload a file from local to remote. put -r: Recursively upload an entire directory. mput: Upload multiple files matching a pattern. get -r: Recursively download an entire remote directory. mget: Download multiple files matching a pattern. bye: Exit the SFTP session. Synchronize File Using rsync SHOW CONTENTS rsync is a fast and versatile command-line tool for copying and synchronizing files locally and remotely. It only transfers the differences between source and destination, saving time and bandwidth. Below are some commonly used rsync commands:\nrsync -avz source/ destination/: synchronize files/directories locally with compression and verbose output. rsync -avh /local/path/ /destination/path/: sync local directories with human-readable file sizes. rsync -avz /local/path/ user@remote:/remote/path/: upload files from local to remote server over SSH. rsync -avz user@remote:/remote/path/ /local/path/: download files from remote server to local machine. rsync -avz --delete /local/path/ user@remote:/remote/path/: sync local to remote and delete files on remote that don’t exist locally. rsync -avz -e ssh /local/path/ user@remote:/remote/path/: sync files over SSH, explicitly specifying the SSH protocol. 14. Install \u0026amp; Update Software Packages Change Repository Mirror SHOW CONTENTS By default, Red Hat Enterprise Linux (RHEL) 9 uses the official repository as its software source. To replace it with the Alibaba Cloud CentOS Stream mirror, follow these steps:\nOpen the redhat.repo file and disable the BaseOS and AppStream repositories by changing enabled=1 to enabled=0: sudo vim /etc/yum.repos.d/redhat.repo BaseOS and AppStream are two key repositories used in Red Hat-based Linux to organize and manage system software and applications. The BaseOS contains the essential operating system components, such as the kernel, system libraries, and core utilities. While the AppStream contains additional software packages that are not esssential for the base system but are needed for specific applications and use cases. Create a new repository file named aliyun.repo and add the following configuration: [AppStream] name = Aliyun Centos Stream - AppStream baseurl = https://mirrors.aliyun.com/centos-stream/9-stream/AppStream/x86_64/os/ enabled = 1 gpgcheck = 0 [BaseOS] name = Aliyun Centos Stream - BaseOS baseurl = http://mirrors.aliyun.com/centos-stream/9-stream/BaseOS/x86_64/os/ enabled = 1 gpgcheck = 0 Clean the existing DNF cache to remove outdated metadata: sudo dnf clean all Rebuild the repository cache to ensure the new mirror is loaded: sudo dnf makecache Note: If the transaction test fails when running sudo dnf update (for example, due to package conflicts), the issue can be temporarily avoided by excluding the conflicting packages:\nsudo dnf update --exclude=openssl* This allows the update process to complete for other packages while the conflict is handled separately.\nInstall \u0026amp; Update Software Packages with dnf SHOW CONTENTS DNF (Dandified YUM) is the default package manager for RPM-based Linux distributions such as Fedora, CentOS, and RHEL. While DNF offers improved performance and new features over YUM, its commands are largely functionally identical. For backward compatibility, YUM commands still exist as symbolic links to DNF. Below are some basic dnf commands:\ndnf install \u0026lt;package\u0026gt;: Installs the specified package. dnf update: Updates all installed packages to their latest versions. dnf remove \u0026lt;package\u0026gt;: Removes the specified package from the system. dnf search \u0026lt;package\u0026gt;: Searches for a package by name or description. dnf list installed: Lists all installed packages on the system. dnf list \u0026lt;package\u0026gt;: Lists detailed information about the specified package. dnf info \u0026lt;package\u0026gt;: Provides detailed information about the specified package (e.g., version, repository, dependencies). dnf upgrade: Upgrades all installed packages to the latest versions, including kernel updates. dnf clean all: Cleans up the local repository cache to free up disk space. dnf makecache: Forces DNF to refresh and rebuild the metadata cache. The dnf command also has the concept of groups. A package group is a collection of related software packages that can be installed or removed together. Here are some common dnf group commands:\ndnf group list: Lists all available package groups, including those that are installed and those that can be installed from repositories. dnf group list installed: Lists only the package groups that are currently installed on the system. dnf group info \u0026lt;group_name\u0026gt;: Displays detailed information about a specific package group, including the list of packages that belong to that group. dnf group install \u0026lt;group_name\u0026gt;: Installs all packages within a specified group, allowing you to easily install related software at once. dnf group remove \u0026lt;group_name\u0026gt;: Removes all packages in a specified group from the system. dnf group update \u0026lt;group_name\u0026gt;: Updates all the packages in the specified group to their latest available versions. dnf group upgrade \u0026lt;group_name\u0026gt;: Upgrades all the packages in the specified group, including dependencies and related packages. Transaction History refers to the record of package transactions, such as installations, removals, and updates. The dnf history command allows you to view past actions taken by DNF and revert to previous states when necessary. Below are some common dnf history commands:\ndnf history: Lists all past transactions, showing details such as transaction ID, date, action (install, remove, update), and affected packages. dnf history info \u0026lt;transaction_id\u0026gt;: Displays detailed information about a specific transaction, including the packages that were installed, removed, or updated. dnf history undo \u0026lt;transaction_id\u0026gt;: Reverts the changes made in a specific transaction, such as undoing the installation or removal of packages. dnf history rollback \u0026lt;transaction_id\u0026gt;: Restores the system to the state it was in immediately after a specified transaction, undoing all changes made since that transaction. dnf history reset: Clears the transaction history, removing all past transaction records from the system. DNF Modularity is a feature of the DNF package manager that enables users to install different versions of software packages within a single distribution. Key concepts of DNF Modularity includes Modules, Streams, and Profiles.\nModules A module is a collection of related packages that can be installed or removed together, and each module can have multiple streams (versions) of a package. Streams: Streams represent different versions or variants of a module. For example, a module for python may have different streams for python3.6, python3.8, etc. Profiles: Profiles are predefined sets of packages that can be installed as part of a module. A profile could include a minimal installation or a development environment for a specific stream. Here are some common dnf module commands: dnf module list: Lists all available modules and their streams. dnf module enable \u0026lt;module_name\u0026gt;: Enables a module, allowing the installation of its packages. dnf module disable \u0026lt;module_name\u0026gt;: Disables a module, preventing its packages from being installed. dnf module install \u0026lt;module_name\u0026gt;: Installs a module and its packages, using the default stream unless specified. dnf module info \u0026lt;module_name\u0026gt;: Shows detailed information about a module, including its streams and profiles. dnf module update \u0026lt;module_name\u0026gt;: Updates a module and its packages to the latest available versions. dnf module provides \u0026lt;package_name\u0026gt;: Displays which module provdies a specific package. 15. Access Linux File System Disk Partition SHOW CONTENTS A file system is a method of organizing and storing data on storage devices. It defines how data is stored, retrieved, and managed. To examine the file system on Linux, the df command provides an overview of disk space usage, while the du command offers detailed information about the disk usage of a specific file or directory. Here are some useful commands:\ndf -h: Displays disk space usage in a human-readable format. df -T: Displays the file system type along with disk space usage. du -h \u0026lt;directory_name\u0026gt;: Displays disk usage for a specific directory in a human-readable format. du -sh: Displays the total disk usage of the current directory in a human-readable format. du -sh \u0026lt;directory_name\u0026gt;: Displays the total disk usage for a specified directory in a human-readable format. Common file systems include ext4, NTFS, and XFS. To access the contents of a file system, it must be mounted to an empty directory, known as the mount point.\nTypically, the entire storage device is not formatted into a single file system; instead, it is divided into several partitions. Each partition is considered a block device in its own right. For example:\nThe first partition on the first SATA-attached storage is /dev/sda1. The second partition on the same device is /dev/sda2. The second partition on the second device is /dev/sdb2. The third partition on the third SATA-attached storage is /dev/sdc3, and so on. To mount a file system manually, follow these steps:\nIdentify Block Devices: Use the lsblk command to identify available block devices. (Use fdisk for partition manipulation when needed.) Create a Mount Point: Create an empty directory (mount point) using the mkdir command. Mount the Device: Use the sudo mount \u0026lt;device_name\u0026gt; \u0026lt;mount_point\u0026gt; command to mount the file system. Verify the Mount: Use the df command to verify the mount operation. Here’s an example of device mounting:\n# 1. Use lsblk to get the block device name lsblk # 2. Create a mount point mkdir /mnt/data # 3. Mount the device sudo mount /dev/sdb1 /mnt/data # 4. Verify the mount operation df -h Note that file systems are automatically unmounted when the system shuts down or reboots. To ensure a file system is mounted at boot, edit the /etc/fstab file and add the following line:\n/dev/sdb1 /mnt/data ext4 defaults 0 0 To unmount a device, ensure all processes related to it are terminated, then use the umount command:\numount /mnt/data Locate File on the System SHOW CONTENTS To locate a file on a Linux system, commonly used commands include find, locate, which, and whereis.\nThe find command searches for files in real time by parsing the file system hierarchy. Here are some commonly used find examples:\nfind /home -name \u0026quot;myfile.txt\u0026quot;: Searches for a file named myfile.txt in the /home directory. find / -name \u0026quot;*.log\u0026quot;: Searches for all .log files starting from the root directory. find / -iname \u0026quot;*message*\u0026quot;: Searches for files that contain the word \u0026ldquo;message\u0026rdquo; (case-insensitive) in their names, starting from the root directory /. find /home -name \u0026quot;*.txt\u0026quot; -size +1M: Finds .txt files larger than 1MB in the /home directory. find /home -name \u0026quot;*.txt\u0026quot; -size -1G: Finds .txt files smaller than 1GB in the /home directory. The locate command searches a pre-generated index of file names and paths, making it much faster than find. However, it may not reflect recent changes in the file system until the index is updated. To update the database, use the updatedb command. Below are common locate examples:\nsudo updatedb # Updates the locate database locate file.txt # Searches for the file \u0026#34;file.txt\u0026#34; The which command locates executables in the directories listed in the $PATH environment variable. It is useful for determining the location of a command or executable. For example:\nwhich python # Finds the path of the python executable The whereis command is used to locate the binary, source, and manual page files associated with a command. It is commonly used to search for documentation and related files. For example:\nwhereis python # Finds binary, source, and man page for python 16. Schedule Future Tasks Schedule a User Job SHOW CONTENTS To schedule a deferred user job, the at command and the cron system can be used. The at command is suitable for one-time deferred tasks, while the cron system is better for recurring tasks.\nThe at command schedules a one-time deferred task to run at a specific time in the future. To view pending jobs, use the atq command. When there is a need to cancel or remove a scheduled job, use the atrm command along with the job ID, which can be obtained from the atq command. Below is an example of using at command:\necho \u0026#34;date \u0026gt;\u0026gt; ~/myjob.txt\u0026#34; | at now +1 minute For recurring tasks, use the crontab command. Below is an example of scheduling a job to run every day at 3 AM:\ncrontab -e 0 3 * * * date \u0026gt;\u0026gt; ~/myjob.txt # Schedule at 3 AM every day Schedule a System Job SHOW CONTENTS To schedule a system job, it is necessary to edit the /etc/crontab file or create a custom cron job file inside the /etc/cron.d/ directory. (Note that files in /etc/cron.d/ are not executable by default; to make them executable, run chmod +x file_name.) The shell scripts executed by these job entries are typically located in directories such as /etc/cron.hourly/, /etc/cron.daily/, etc. Below are some common examples of scheduling system jobs:\n# 1. Create a script named hourly_job.sh in /etc/cron.hourly/ sudo vim /etc/cron.hourly/hourly_job.sh # 2. Add the following content to the script #!/bin/bash echo \u0026#34;Hourly job executed at $(date)\u0026#34; \u0026gt;\u0026gt; /var/log/hourly_job.log # 3. Make the script executable sudo chmod +x /etc/cron.hourly/hourly_job.sh Anacron is used for scheduling tasks that should run periodically but not necessarily at fixed times. It ensures that a missed job is executed as soon as possible after the system starts up. Below is an sample example:\n# period delay job-identifier command # 1 5 dailybackup /usr/local/bin/backup.sh # Run a daily backup at system start (5 minutes after boot) 1 5 dailybackup /usr/local/bin/backup.sh Systemd timers provide a more flexible way of scheduling tasks on Linux systems. They integrate with the systemd service manager, which makes them more powerful and capable of handling advanced scenarios. A systemd timer works by triggering a systemd service at specific intervals. It uses two components: Timer Unit and Service Unit.\nTimer Unit: Defines when the task will be executed. Service Unit: Defines the actual task to be run. Below is an example:\n# 1. Create a service file sudo vim /etc/systemd/system/myjob.service # 2. Add the following content to the file [Unit] Description=Run my scheduled task [Service] Type=oneshot # The service runs a one-time task ExecStart=/usr/local/bin/myscript.sh # Specifies the command to execute # 3. Create a timer unit sudo vim /etc/systemd/system/myjob.timer # 4. Add the following content to the file [Unit] Description=Run my job every day at 3 AM [Timer] OnCalendar=daily # Schedules the task to run once a day Persistent=true # Ensures that if the system is off during the scheduled time, the task will run once the system boots up. [Install] WantedBy=timers.target # 5. Reload the systemd sudo systemctl daemon-reload # 6. Enable and start the timer sudo systemctl enable myjob.timer sudo systemctl start myjob.timer Manage Temporary Files SHOW CONTENTS systemd-tmpfiles is a utility provided by systemd that allows for automatic management of temporary files and directories on Linux systems. It is primarily used to clean up temporary files, manage file permissions, and enforce file creation rules. systemd-tmpfiles works based on configuration files located in /etc/tmpfiles.d/, /usr/lib/tmpfiles.d/, and /run/tmpfiles.d/. Below is an example of automatic clean up:\n# 1. Create a configuration file sudo vim /etc/tmpfiles.d/temp_cleanup.conf # 2. Add the following content to the file # Type Path Mode UID GID Age Argument # Remove any .log files in /tmp that are older than 7 days. f /tmp/*.log 0644 root root 7d - # Remove empty directories in /tmp older than 7 days. d /tmp/ 1777 root root 7d - # 3. Create a system timer for automatic cleanup sudo vim /etc/systemd/system/tmpfiles-cleanup.timer # 4. Add the following content to the file [Unit] Description=Automatic cleanup of temporary files [Timer] # Run 1 hour after boot, then once every day OnBootSec=1h OnUnitActiveSec=1d Unit=systemd-tmpfiles-clean.service [Install] WantedBy=timers.target # 5. Create the service unit for systemd-tmpfiles cleanup sudo vim /etc/systemd/system/systemd-tmpfiles-clean.service # 6. Add the following content [Unit] Description=Cleanup temporary files using systemd-tmpfiles [Service] Type=oneshot ExecStart=/usr/bin/systemd-tmpfiles --clean # 7. Reload the systemd sudo systemctl daemon-reload # 8. Enable and start the timer sudo systemctl enable tmpfiles-cleanup.timer sudo systemctl start tmpfiles-cleanup.timer 17. Tune System Performance Adjust Tuning Profiles SHOW CONTENTS The tuned utility is used to statically and dynamically adjust a system’s configuration and optimize its performance based on different use cases, such as improving I/O performance, network throughput, and power saving.\nStatic tuning configures predefined kernel parameters in a profile that the tuned daemon applies at runtime. These kernel parameters are set for overall performance expectations, but they do not change in response to system activity. Dynamic tuning allows the tuned daemon to monitor system activity and adjust settings based on runtime behavior changes. By default, dynamic tuning is disabled. To enable it, simply change the dynamic_tuning variable in the /etc/tuned/tuned-main.conf configuration file. When enabled, tuned periodically monitors the system and adjusts the tuning settings according to the observed behavior. The frequency of updates can be controlled by modifying the update_interval variable in the same configuration file (in seconds between updates). The tuned utility provides several predefined profiles and allows for the creation of custom profiles to optimize a system’s behavior for specific workloads, such as servers, laptops, or high-performance environments. Below are some common commands for managing profiles:\ntuned-adm active: Show the currently active profile. tuned-adm list: List all available profiles. tuned-adm profile_info: Show information about the active profile. tuned-adm profile_info \u0026lt;profile_name\u0026gt;: Show information about a specific profile. tuned-adm profile \u0026lt;profile_name\u0026gt;: Apply a specific tuning profile. tuned-adm recommend: Recommend an optimal profile based on the system\u0026rsquo;s current usage. tuned-adm off: Disable tuned and stop dynamic tuning. Influence Process Scheduling SHOW CONTENTS In Linux, process priorities determine the order in which processes are scheduled to run on the CPU. The scheduling policy and nice value are key factors in how the operating system manages process execution.\nCommon scheduling policies include SCHED_NORMAL/SCHED_OTHER, SCHED_FIFO, and SCHED_RR.\nSCHED_NORMAL/SCHED_OTHER (TS): This is the default policy used for most processes, where tasks are scheduled based on their priority and time-sharing behavior. SCHED_FIFO (FF): A real-time policy where processes are executed in a first-in, first-out manner. It gives higher priority to processes with lower numerical values, without time slicing. SCHED_RR (RR): Each process gets a fixed time slice before the next one is executed, providing better responsiveness. The nice value (default is 0) is an integer that can range from -20 (highest priority, maps to a 0 in the top command) to +19 (lowest priority, maps to a 39 in the top command). It allows users to influence the priority of a process, where a lower nice value gives the process higher priority in CPU scheduling. A higher nice value lowers the priority. To view the nice value of a running process, use the ps or top command. In top, the nice value is displayed under the NI column. Below is an example of using ps:\nps -eo pid,comm,ni,cls --sort=-ni By default, when a process starts from the command line, it inherits its nice value from the shell process (default value is 0). To start a new process with a specific nice value, use the nice command. Here are some examples:\nnice sleep 60 \u0026amp; # Start a new process with the default nice value (0) nice -n 15 sleep 60 \u0026amp; # Start a new process with a nice value of 15 To adjust the nice value of an existing process, use the renice command. The renice command allows users to change the nice value of a running process. Unprivileged users may only increase the nice value (lower the priority), up to a maximum of 19. Privileged users can both increase and decrease the nice value, with a minimum of -20. It is available to modify the nice value of a process from the interactive interface of top by pressing r, entering the process ID, and then specifying the new nice value. Below is an example of using renice:\nrenice -n 18 1997 # Change the nice value of the process with PID 1997 to 18 18. Manage SELinux Security Change the SELinux Environment Mode SHOW CONTENTS SELinux (Security-Enhanced Linux) is a security module for the Linux kernel that provides a mechanism for enforcing access control security policies. It ensures resource access is controlled at a granular level. Unlike traditional file permissions, which control file access for specific users or groups, SELinux prevents even authorized users with access to a file from using it for unintended purposes. SELinux operates based on application-specific policies, such as the targeted policy, which precisely defines the allowed actions and access for each binary executable, configuration file, and data file used by an application.\nSELinux policies are security rules that define how specific processes can access files, directories, and ports. Each resource entity—such as a file, process, directory, or port—has a label called an SELinux context, which can be viewed using -Z option in many commands. Each SELinux context consists of four fields: user, role, type, and security level.\nUser: Specifies the SELinux user associated with the resource. Role: Defines the role assigned to the resource, determining the permitted actions within the system. Type: Specifies the type or category of the resource, which is used for defining access controls. Security level: Indicates the security classification or sensitivity level of the resource. For example, a web server process runs with the httpd_t type context. By default, files and directories in the /var/www/html/ directory have the httpd_sys_content_t type context A web server can access the httpd_sys_content_t labeled files, but has no rules to allow access to files for other services, such as mysqld_db_t labeled files.\nSELinux supports three operational modes: enforcing, permissive, and disabled.\nEnforcing: SELinux is actively enforcing security policies. blocking any unauthorized access based on the policy. Permissive: SELinux logs any policy violations but does not block the access. This mode is helpful for testing and troubleshooting applications and rules. Disabled: SELinux is completely turned off. (Note that starting in Red Hat Enterprise Linux 9, SELinux can be fully disabled only by using the selinux=0 kernel parameter at boot.) To change the SELinux mode, the setenforce command can be used, or the /etc/selinux/config file can be edited. It is recommended to reboot the system after making changes. To enable or disable SELinux, pass selinux=1 or selinux=0 respectively during system boot. Below are some examples of how to change the SELinux mode using commands:\ngetenforce # Displays the current SELinux mode setenforce enforcing # Sets SELinux to enforcing mode setenforce 1 # Equivalent to setenforce enforcing Control SELinux File Contexts SHOW CONTENTS By default, SELinux labels files based on policies defined in the /etc/selinux/targeted/contexts/files/ directory. When creating a new file, it inherits the same label as its parent directory unless a specific label is applied. If a file is copied, its context will change, as copying a file creates a new inode. However, moving a file does not change its context, because moving a file only updates the inode\u0026rsquo;s filename without altering the inode itself. To preserve the context while copying, the -p or --preserved=context option can be used. For moving files, the -Z option is used to explicitly change the SELinux context. Below is an example:\nls /tmp # system_u:object_r:tmp_t:s0 /tmp touch /tmp/file1 /tmp/file2 /tmp/file3 ls -Z /tmp/file* # unconfined_u:object_r:user_tmp_t:s0 /tmp/file1 # unconfined_u:object_r:user_tmp_t:s0 /tmp/file2 # unconfined_u:object_r:user_tmp_t:s0 /tmp/file3 ls -Zd ~/ # unconfined_u:object_r:user_home_dir_t:s0 /home/signalyu999/ cp /tmp/file1 ~/ mv /tmp/file2 ~/ mv -Z /tmp/file3 ~/ ls -Z ~/file* # unconfined_u:object_r:user_home_t:s0 /home/signalyu999/file1 # unconfined_u:object_r:user_tmp_t:s0 /home/signalyu999/file2 # unconfined_u:object_r:user_home_t:s0 /home/signalyu999/file3 To change the SELinux context, three commands—semanage fcontext, restorecon, and chcon—are commonly used:\nsemanage fcontext: This command defines custom SELinux context rules for files or directories. It is often used to assign a specific context to files when they are created or moved to a particular location. restorecon: This command applies the SELinux context based on the rules defined by semanage fcontext. It restores the SELinux context of the file or directory to the predefined context. chcon: This command changes the SELinux context of a file or directory temporarily. Unlike semanage, which alters permanent rules, chcon applies the context change on a temporary basis and can be overwritten by restorecon. # Define a custom SELinux context for files in /home/signalyu999/test sudo semanage fcontext -a -t tmp_t \u0026#34;/home/signalyu999/test(/.*)?\u0026#34; mkdir ~/test # Before applying ls -Zd ~/test # unconfined_u:object_r:user_home_t:s0 /home/signalyu999/test cd test/ touch file1.txt ls -Z file1.txt # unconfined_u:object_r:user_home_t:s0 file1.txt # Apply the custom SELinux context rule using restorecon restorecon -v ~/test # After applying ls -Zd ~/test # unconfined_u:object_r:tmp_t:s0 /home/signalyu999/test ls -Zd file1.txt unconfined_u:object_r:user_home_t:s0 file1.txt touch file2.txt ls -Z file2.txt # unconfined_u:object_r:user_tmp_t:s0 file2.txt # Temporarily change the SELinux context using chcon sudo chcon -t user_home_t ~/test ls -Zd ~/test # unconfined_u:object_r:user_home_t:s0 /home/signalyu999/test touch file3.txt ls -Z file3.txt # unconfined_u:object_r:user_home_t:s0 file3.txt # Restore the original SELinux context with restorecon restorecon -v ~/test ls -Zd ~/test # unconfined_u:object_r:tmp_t:s0 /home/signalyu999/test ls -Z file* # unconfined_u:object_r:user_home_t:s0 file1.txt # unconfined_u:object_r:user_home_t:s0 file3.txt # unconfined_u:object_r:user_tmp_t:s0 file2.txt sudo semanage fcontext -l | grep \u0026#34;/home/signalyu999\u0026#34; /home/signalyu999/test(/.*)? all files system_u:object_r:tmp_t:s0 restorecon -Rv ~/test # Relabeled /home/signalyu999/test/file1.txt from unconfined_u:object_r:user_home_t:s0 to unconfined_u:object_r:tmp_t:s0 # Relabeled /home/signalyu999/test/file2.txt from unconfined_u:object_r:user_tmp_t:s0 to unconfined_u:object_r:tmp_t:s0 # Relabeled /home/signalyu999/test/file3.txt from unconfined_u:object_r:user_home_t:s0 to unconfined_u:object_r:tmp_t:s0 ls -Z file* # unconfined_u:object_r:tmp_t:s0 file1.txt # unconfined_u:object_r:tmp_t:s0 file3.txt # unconfined_u:object_r:tmp_t:s0 file2.txt rm -r ~/test # Delete the custom context rule sudo semanage fcontext -d \u0026#34;/home/signalyu999/test(/.*)?\u0026#34; Adjust SELinux with Booleans SHOW CONTENTS SELinux Booleans are runtime tunable parameters that control specific aspects of SELinux behavior. They allow administrators to enable or disable certain security features without altering the underlying SELinux policies. Some common SELinux booleans include:\nhttpd_can_network_connect: Enable it to allow Apache to access external resources over the network. httpd_enable_homedirs: Enable it to allow Apache to serve content from user home directories. allow_execmem: Enable it to allow executable memory mapping. selinuxuser_execheap: Enable it to allow SELinux users to execute files with low-security contexts. samba_enable_home_dirs: Enable it to allow Samba to share user home directories. To manage SELinux booleans, the following commands are commonly used: getsebool, setsebool, and semanage boolean. Below is an example of how to check and change SELinux boolean values:\n# List all SELinux booleans related to \u0026#34;httpd_enable_\u0026#34; getsebool -a | grep \u0026#34;httpd_enable_\u0026#34; # httpd_enable_cgi --\u0026gt; on # httpd_enable_ftp_server --\u0026gt; off # httpd_enable_homedirs --\u0026gt; off # Check the current state of a specific boolean getsebool httpd_enable_homedirs # httpd_enable_homedirs --\u0026gt; off # Use semanage to view the details of a specific boolean sudo semanage boolean -l | grep httpd_enable_homedirs # httpd_enable_homedirs (off, off) Allow httpd to enable homedirs # Change the value of a boolean (without the -P flag, the changes will only persist until the system is rebooted) sudo setsebool httpd_enable_homedirs on # Use semanage again to confirm the change sudo semanage boolean -l | grep httpd_enable_homedirs # httpd_enable_homedirs (on, off) Allow httpd to enable homedirs # Make the change persistent across reboots sudo setsebool -P httpd_enable_homedirs on # Check the persistent state of all SELinux booleans sudo semanage boolean -l -C # SELinux boolean State Default Description # httpd_enable_homedirs (on, on) Allow httpd to enable homedirs # ... sudo setsebool -P httpd_enable_homedirs off Investigate and Resolve SELinux Issues SHOW CONTENTS When SELinux denies an action, it logs an AVC (Access Vector Cache) message to the /var/log/audit/audit.log file. Additionally, a summary of the AVC event is sent to /var/log/messages. These logs provide valuable information to diagnose SELinux-related issues. Here are some common steps to troubleshoot SELinux issues:\nView SELinux Logs: The first step in troubleshooting SELinux issues is to check the SELinux logs for AVC denials. This can be done using the following command: sudo grep AVC /var/log/audit/audit.log | audit2why Check and Set SELinux Booleans: The second step is to permit SELinux behavior by setting SELinux Booleans. To list the current SELinux booleans and search for a specific one (e.g., related to HTTPD), use the following command: getsebool -a | grep httpd If a boolean needs to be modified, for example, enabling Apache to read user content, use the setsebool command with the -P option to make the change persistent:\nsudo setsebool -P httpd_read_user_content 1 Check File and Directory Contexts: The third step is to check the context of a file or directory as incorrect or missing contexts can result in access denials. This can be done using the following command: ls -Z /path/to/file If the context is incorrect, it can be fixed using the semanage fcontext command to define the correct context or restorecon to apply the default context based on the current policies:\nsudo restorecon -v /path/to/file Below is a simple example:\nsudo systemctl start httpd echo \u0026#34;\u0026lt;h1\u0026gt;HELLO\u0026lt;/h1\u0026gt;\u0026#34; \u0026gt;\u0026gt; ~/index.html sudo mv ~/index.html /var/www/html/ curl http://localhost/index.html # \u0026lt;!DOCTYPE HTML PUBLIC \u0026#34;-//IETF//DTD HTML 2.0//EN\u0026#34;\u0026gt; # \u0026lt;html\u0026gt;\u0026lt;head\u0026gt; # \u0026lt;title\u0026gt;404 Not Found\u0026lt;/title\u0026gt; # \u0026lt;/head\u0026gt;\u0026lt;body\u0026gt; # \u0026lt;h1\u0026gt;Not Found\u0026lt;/h1\u0026gt; # \u0026lt;p\u0026gt;The requested URL was not found on this server.\u0026lt;/p\u0026gt; # \u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; # Check the SELinux audit logs for AVC denials related to the \u0026#34;httpd\u0026#34; process sudo grep AVC /var/log/audit/audit.log | audit2why # type=AVC msg=audit(1746191992.345:5086): avc: denied { read } for pid=84172 comm=\u0026#34;httpd\u0026#34; name=\u0026#34;index.html\u0026#34; dev=\u0026#34;dm-0\u0026#34; ino=34324608 scontext=system_u:system_r:httpd_t:s0 tcontext=unconfined_u:object_r:user_home_t:s0 tclass=file permissive=0 # Was caused by: # The boolean httpd_read_user_content was set incorrectly. # Description: # Allow httpd to read user content # Allow access by executing: # # setsebool -P httpd_read_user_content 1 sudo setsebool -P httpd_read_user_content 1 curl http://localhost/index.html # \u0026lt;h1\u0026gt;HELLO\u0026lt;/h1\u0026gt; 19. Manage Basic Storage Add Partitions, File Systems, and Persistent Mounts SHOW CONTENTS Disk partitioning is the process of dividing a computer\u0026rsquo;s storage device into separate, independent sections called partitions. Each partition acts like an individual disk, allowing it to be formatted with a specific file system and used for various purposes, such as system files, user data, or backups. There are two main disk partitioning schemes: MBR (Master Boot Record) and GPT (GUID Partition Table).\nMBR (Master Boot Record): MBR is an older partitioning scheme that is commonly used in BIOS-based systems. It stores partitioning information in the first sector of the disk, known as the master boot record. This sector contains both the bootloader (a small program that helps the system load the operating system) and the partition table, which holds the details about each partition. MBR supports a maximum of four primary partitions and is limited to disks up to 2 TB in size. GPT (GUID Partition Table): GPT is a newer partitioning scheme designed as part of the UEFI (Unified Extensible Firmware Interface) standard. GPT overcomes the limitations of MBR by using two partition tables: a primary GPT header located at the beginning of the disk and a backup GPT header stored at the end of the disk. This redundancy ensures protection in case the primary GPT header is damaged. GPT supports up to 128 partitions by default and can handle disks as large as 9.4 ZB. Below is an real-world example of disk partitioning:\n# 1. Shutdown the VMware machine and add the new disk device. # 2. Use parted to manage the partitions on /dev/sdb (the new disk). sudo parted /dev/sdb # 3. Create a new partition table (GPT or MSDOS). GPT is recommended for modern systems. (parted) mklabel gpt # Or use \u0026#34;msdos\u0026#34; for older systems. # 4. Create a new primary partition (parted) mkpart # partition name: app-data # file system type: ext4 # start: 0% # end: 50% # 5. Print the partition information to verify the partition layout. (parted) print # 6. Ensure the system create the associated device file in the /dev directory udevadm settle # 7. Format the partition sudo mkfs.ext4 /dev/sdb1 # 8. Create a mounting point and mount the newly created partition sudo mkdir /mnt/mydata sudo mount /dev/sdb1 /mnt/mydata # 9. Use blkid to get the UUID of the new partition. sudo blkid /dev/sdb1 # /dev/sdb1: UUID=\u0026#34;98c3694b-5a44-4729-bc14-2987562754cd\u0026#34; TYPE=\u0026#34;ext4\u0026#34; PARTLABEL=\u0026#34;app-data\u0026#34; PARTUUID=\u0026#34;4c737002-504a-4206-adda-737270fc083e\u0026#34; # 10. Edit the /etc/fstab sudo vim /etc/fstab # UUID=98c3694b-5a44-4729-bc14-2987562754cd /mnt/mydata ext4 defaults 0 2 # UUID: Universally Unique Identifier # defaults: include auto mount option # /mnt/mydata: mounting point # ext4: file system # 0: dump (back up option), 0 = no backup (default), 1 = enable backup # 0: fsck (file system checking), 0 = do not check, 1 = check first (usually for root), 2 = check after root (for other file systems) # 11. After editing /etc/fstab, mount all filesystems as specified in /etc/fstab. sudo mount -a # 12. Use the df command to check that the partition is correctly mounted. df -h # 13. Register new configuraation sudo systemctl daemon-reload Below is a real-world example of removing a partition:\n# 1. Ensure the partition is not mounted sudo umount /dev/sdb1 # 2. Check if it is mounted df -h # 3. Delete the partition in parted parted /dev/sdb (parted) print (parted) rm 1 # 4. Edit the /etc/fstab file Manage Swap Space SHOW CONTENTS Swap space is a portion of the disk that is used as virtual memory when the system\u0026rsquo;s physical RAM is full. It allows the operating system to move inactive pages from RAM to disk, free up memory for active processes.\nWhen creating swap partitions, administrators should size the swap space based on the memory workload on the system. Below is a practical guide line:\nRAM Size Swap (No Hibernation) Swap (With Hibernation) \u0026lt; 2 GB Twice the RAM Three times the RAM 2–8 GB Same as RAM Twice the RAM 8–64 GB At least 4 GB 1.5 times the RAM \u0026gt; 64 GB At least 4 GB Hibernation is not recommended Below is an real-world example of creating swap partition:\n# 1. Open parted to manage the new disk parted /dev/sdc # 2. Create a GPT partition table (parted) mklabel gpt # 3. Create a new partition (parted) mkpart # partition name: swap1 # file system type: linux-swap # start: 0% # end: 100% # 4. Ensure the system create the associated device file in the /dev directory udevadm settle # 5. Format the new partition as swap space mkswap /dev/sdc1 # 6. Activate the swap space immediately swapon /dev/sdc1 # 7. Get the UUID of the swap partition blkid /dev/sdc1 # /dev/sdc1: UUID=\u0026#34;e2d9fbc3-65dc-4427-8051-c07dcc043866\u0026#34; TYPE=\u0026#34;swap\u0026#34; PARTLABEL=\u0026#34;swap1\u0026#34; PARTUUID=\u0026#34;4f0f1298-cf05-4440-856f-534d69aeeccc\u0026#34; # 8. Edit fstab to enable swap at boot sudo vim /etc/fstab # UUID=e2d9fbc3-65dc-4427-8051-c07dcc043866 none swap defaults 0 0 # Add the following line for default swap: # UUID=e2d9fbc3-65dc-4427-8051-c07dcc043866 none swap defaults 0 0 # Or set a custom priority: # UUID=e2d9fbc3-65dc-4427-8051-c07dcc043866 none swap pri=10 0 0 # 9. Reload systemd config (optional if fstab changed) sudo systemctl daemon-reload # 10. Display swap space priorities swapon --show Below is a real-world example of removing a swap partition:\n# 1. Turn off swap sudo swapoff /dev/sdc1 # 2. Verify whether a swap is off swapon --summary # 3. Remove the partition in parted parted /dev/sdc1 (parted) print (parted) rm [number] # 4. Edit the /etc/fstab file 20. Manage Storage Stack Create and Extend Logical Volumes SHOW CONTENTS Logical Volume Manager (LVM) is a system for managing disk storage in Linux that adds a layer of abstraction between physical storage devices and file systems. It allows multiple physical volumes to be combined into a single volume group, enabling more flexible and efficient storage allocation. The key components of LVM include: Physical Devices (PD), Physical Volumes (PV), Volume Groups (VG), and Logical Volumes (LV).\n📦 Physical Devices: These are actual hardware devices or virtual disks (e.g., /dev/sda, /dev/sdb). 💽 Physical Volumes (PV): Physical devices that have been initialized for LVM using pvcreate. 🧱 Volume Groups (VG): Collections of one or more physical volumes, combined into a single logical storage pool. Created using vgcreate. 📂 Logical Volumes (LV): Flexible storage units carved out from volume groups, created using lvcreate. Creating a logical volume involves creating physical device partitions, physical volumes, and volume groups. Below is an example:\n# 1. Prepare physical devices parted /dev/sdb (parted) mklabel gpt (parted) mkpart primary 1MiB 50% (parted) set 1 lvm on parted /dev/sdc (parted) mklabel gpt (parted) mkpart primary 50% 100% (parted) set 1 lvm on udevadm settle # 2. Create Physical volumes pvcreate /dev/sdb1 /dev/sdc1 # Physical volume \u0026#34;/dev/sdb1\u0026#34; successfully created. # Physical volume \u0026#34;/dev/sdc1\u0026#34; successfully created. # 3. Create volume groups vgcreate vg01 /dev/sdb1 /dev/sdc1 # Volume group \u0026#34;vg01\u0026#34; successfully created # 4. Create a logical volume lvcreate -n lv01 -L 100G vg01 # Logical volume \u0026#34;lv01\u0026#34; created. # 5. Format the logical volume mkfs.ext4 /dev/vg01/lv01 # 6. Edit the /etc/fstab file blkid /dev/vg01/lv01 # /dev/vg01/lv01: UUID=\u0026#34;87a466b5-4b94-4881-8398-4ec3f91544f1\u0026#34; TYPE=\u0026#34;ext4\u0026#34; vim /etc/fstab # UUID=87a466b5-4b94-4881-8398-4ec3f91544f1 /mnt/app-data ext4 defaults 0 0 # 7. Mount the logical volume to /mnt/app-data mount /dev/vg01/lv01 /mnt/app-data # 7. Verify whether if the logical volume is mounted df -h Below is an example of removing logical volumes, volume groups, and physical volumes:\n# 1. Unmount the file system and remove any /etc/fstab entries associated with it umount /mnt/app-data vim /etc/fstab # Remove any entries with the file system # 2. Back up the data before removing cp -r /mnt/app-data ~/backup/volume-data # 3. Remove the logical volume lvremove /dev/vg01/lv01 # 4. Remove the volume group vgremove vg01 # 5. Remove the physical volumes pvremove /dev/sdb1 /dev/sdc1 Here are some commonly used command of LVM:\npvdisplay /dev/sdb1: Displays detailed information about the physical volume /dev/sdb1. vgdisplay vg01: Shows information about the volume group vg01. lvdisplay /dev/vg01/lv01: Displays details of the logical volume lv01 under volume group vg01. Extend a volume group size: # Prepare the physical device parted /dev/sdb (parted) mklabel gpt # Set GPT partition table (parted) mkpart primary 50% 100% # Create partition in the second half of the disk (parted) set 3 lvm on # Mark it as an LVM partition udevadm settle # Wait for partition events to settle pvcreate /dev/sdb3 # Initialize as a physical volume vgextend vg01 /dev/sdb3 # Extend volume group vg01 with the new PV Extend a logical volume size: lvextend -L +500M /dev/vg01/lv01 # Increase LV size by 500MB xfs_growfs /mnt/app-data/ # For XFS file system (online grow only) resize2fs /dev/vg01/lv01 # For ext2/3/4 file systems (supports online/offline grow/shrink) Extend swap space logical volume: swapoff -v /dev/vg01/swap # Disable swap before resizing lvextend -L +300M /dev/vg01/swap # Extend swap by 300MB mkswap /dev/vg01/swap # Reformat as swap swapon /dev/vg01/swap # Re-enable swap Manage Layered Storage SHOW CONTENTS ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/linux/1-red-hat-enterprise-linux/","summary":"1. Introduction to Linux SHOW CONTENTS Open Source refers to software whose source code is freely available to the public for anyone to view, modify, and distribute. It encourages coolaboration, transparency, and community-driven improvements.\nOpen Source Licenses are legal agreements that define how software can be used, modified, and distributed. There are two main types of Copyleft and Permissive.\nCopyleft licenses require that any modified versions of the software also be open source, under the same terms as the original.","title":"Red Hat Enterprise Linux"},{"content":"Introduction to Docker SHOW CONTENTS Docker was developed to address the challenges of software deployment across various environments by providing a lightweight, consistent, and portable solution. Prior to Docker, developers often faced issues like \u0026ldquo;it works on my machine, but not in production,\u0026rdquo; caused by inconsistencies in dependencies, libraries, and configurations. Docker resolves this by containerizing applications, ensuring they run uniformly across any infrastructure. Its primary goal is to simplify development, testing, and deployment by encapsulating applications and their dependencies into isolated, reproducible containers. These containers are user-space instances that package code, runtime, system tools, and libraries, ensuring consistency across environments.\nThe key difference between Docker and Virtual Machines (VMs) lies in their architecture. VMs emulate entire hardware stacks, requiring a full operating system for each instance, which results in significant overhead. In contrast, Docker uses containers that share the host OS kernel, offering a more lightweight and efficient solution by isolating applications at the process level. Docker has three core components: images, containers, and registries. Images are read-only templates that contain application code and dependencies. Containers are runnable instances of these images; they are isolated, lightweight, and ephemeral. Registries are repositories that store and share Docker images. Docker Architecture SHOW CONTENTS Docker follows a Client/Server (C/S) architecture with a loosely coupled backend where various components perform specific functions. The basic workflow of Docker is as follows: Docker Client: The user interacts with the Docker Client, which communicates with the Docker Daemon to send requests. Docker Daemon: This is the core component of Docker\u0026rsquo;s architecture. It provides the Docker Server functionality, enabling it to accept requests from the Docker Client. Docker Engine: The Docker Engine executes a series of internal tasks. Each task is represented as a \u0026ldquo;Job.\u0026rdquo; Job Execution: Each Job performs a specific function, such as building an image, starting a container, or managing storage. Graph Driver: If a Job requires a container image, the Engine fetches it from a Docker Registry. The Graph driver stores the downloaded image as a Graph (a layered filesystem) and manages its dependencies. Network Creation: When a network environment needs to be created for Docker, the Network Driver is used to create and configure the network for Docker containers. Resource Management and Execution: If Docker needs to limit resources or execute user commands within containers, the Exec Driver is responsible for completing these operations. Libcontainer: Libcontainer is an independent container management package. Both the Network Driver and the Exec Driver rely on Libcontainer to perform specific container management operations. Common Docker Commands Basic Commands SHOW CONTENTS Start/Stop/Restart Docker: sudo systemctl start docker sudo systemctl stop docker sudo systemctl restart docker View Docker Status: sudo systemctl status docker View Docker Info: docker info View Docker Help Documentation: docker --help View Docker Version: docker -v Docker Image Commands SHOW CONTENTS Search for a Docker Image: docker search \u0026lt;image_name\u0026gt; docker search nginx Pull a Docker Image: docker pull \u0026lt;image_name\u0026gt; docker pull nginx List Docker Images: docker images docker image ls Inspect a Docker Image: docker inspect \u0026lt;image_name_or_id\u0026gt; docker inspect nginx Tag a Docker Image: docker tag \u0026lt;image_id_or_name\u0026gt; \u0026lt;new_image_name\u0026gt;:\u0026lt;new_tag\u0026gt; docker tag nginx:latest nginx:1.27.4 Remove a Docker Image: docker rmi \u0026lt;image_name_or_id\u0026gt; docker rmi nignx:1.27.4 Build a Docker Image: docker build -t \u0026lt;image_name\u0026gt;:\u0026lt;tag\u0026gt; \u0026lt;path_to_dockerfile\u0026gt; docker build -t myapp:latest . Save a Docker Image to a File: docker save -o \u0026lt;output_file_name\u0026gt;.tar \u0026lt;image_name\u0026gt;:\u0026lt;tag\u0026gt; docker save -o myapp.tar myapp:latest Load a Docker Image from a File: docker load -i \u0026lt;file_name\u0026gt;.tar docker load -i myapp.tar Prune Unused Docker Images: docker image prune docker image prune -a Docker Container Commands SHOW CONTENTS docker run: Create and start a new container docker run -it -p 8080:8080 --name tomcat9 tomcat:9-jre17 /bin/bash: Start a new container from the tomcat:9-jre17 image, name it tomcat9, map port 8080 inside the container to port 8080 on the host, and open an interactive bash shell inside the container. docker ps: List all currently running containers docker ps: List containers that are currently running. docker ps -a: List all containers. docker start \u0026lt;container_id_or_name\u0026gt;: Start a stopped container docker start my_container: Start a container with the name my_container. docker restart \u0026lt;container_id_or_name\u0026gt;: Restart a container docker restart my_container: Restart the container named my_container. docker stop \u0026lt;container_id_or_name\u0026gt;: Stop a running container docker stop my_container: Stop the container named my_container. docker kill \u0026lt;container_id_or_name\u0026gt;: Force stop a running container docker kill my_container: Force stop the container named my_container. docker rm \u0026lt;container_id_or_name\u0026gt;: Remove a stopped container docker rm my_container: Remove the container named my_container after it has stopped. docker run -d \u0026lt;container_id_or_name\u0026gt;: Start a container in detached mode (background) docker run -d nginx: Run the Nginx container in the background. docker logs \u0026lt;container_id_or_name\u0026gt;: View logs of a container docker logs my_container: View logs for the container named my_container. docker top \u0026lt;container_id_or_name\u0026gt;: View the running processes inside a container docker top my_container: Display the processes running inside my_container. docker inspect \u0026lt;container_id_or_name\u0026gt;: Get detailed information about a container docker inspect my_container: Show detailed metadata about the container named my_container. docker exec -it \u0026lt;container_id_or_name\u0026gt; \u0026lt;command\u0026gt;: Execute a command inside a running container (interactive mode) docker exec -it my_container bash: Open an interactive bash shell inside my_container. exit: Exit from an interactive session inside a container exit: Exit the interactive shell of the container and return to the host. docker cp \u0026lt;container_id_or_name\u0026gt;:\u0026lt;path_in_container\u0026gt; \u0026lt;path_on_host\u0026gt;: Copy files from a container to the host docker cp my_container:/app/file.txt /host/directory/: Copy file.txt from the container to the host. Docker Images SHOW CONTENTS A Docker image is a read-only template used to create containers. It is composed of several layers stacked on top of each other, with each layer representing a snapshot of the filesystem at a specific point in time. These snapshots capture modifications made by Docker instructions (such as installing a package, copying files, or modifying configurations). Layers are created during the execution of commands in a Dockerfile or when using a pre-existing image to build a new one.\nDocker leverages UnionFS to efficiently manage these layers, allowing it to present a unified view of the container\u0026rsquo;s filesystem. This approach helps optimize storage and performance, as common layers can be shared across different images. Here is a simple example of creating an image using a Dockerfile:\nFROM ubuntu # This layer contains the base Ubuntu image RUN apt-get update # This layer contains the updated package list COPY . /app # This layer contains the application files copied into /app CMD [\u0026#34;python\u0026#34;, \u0026#34;/app/app.py\u0026#34;] # This layer contains the command to run the application when the container starts Docker provides the docker commit command, which allows creating a new image based on the changes made to a running container. It is similar to taking a snapshot of the container\u0026rsquo;s current state. Below is a real-world example:\n# Run a container from a base image docker run -it ubuntu /bin/bash # Make changes inside the container apt-get update apt-get install -y vim # Commit the container to create a new image docker commit \u0026lt;container_id\u0026gt; my-ubuntu-image Docker Volumes SHOW CONTENTS A Docker volume is a persistent storage mechanism designed to store data outside of a container\u0026rsquo;s filesystem. Volumes are stored on the host machine and can be shared and reused across multiple containers. They are particularly useful for overcoming the ephemeral nature of container filesystems, ensuring that data persists even when containers are stopped, removed, or replaced. Below are some example use cases:\n# Create a named volume (stored in /var/lib/docker/volumes/mysql_data on the host) docker volume create mysql_data # Run a MySQL container, mounting the volume to store data persistently (default is rw for read-write) docker run -d --name mysql1 -v mysql_data:/var/lib/mysql mysql # Run a container with a read-only volume mount, preventing modifications to the config files docker run -d --name myapp -v /tmp/config:/app/config:ro myapp # Use --volumes-from to mount the volume from mysql1 into mysql2, sharing data between the containers docker run -d --volumes-from mysql1 --name mysql2 mysql Installing Software in Docker Search Image Versions SHOW CONTENTS vim ~/.bashrc: # Search docker image versions dkr_image_versions() { # Usage: dkr_image_versions \u0026lt;image_name\u0026gt; [limit] # Fetches version tags from Docker Hub for a given image, sorted by version number # Default shows all versions, optional limit controls output count local image_name=$1 local limit=${2:-0} # Default 0 (show all), if not provided # Validate input if [ -z \u0026#34;$image_name\u0026#34; ]; then echo \u0026#34;Error: Image name not specified\u0026#34; \u0026gt;\u0026amp;2 echo \u0026#34;Usage: dkr_image_versions \u0026lt;image_name\u0026gt; [limit]\u0026#34; \u0026gt;\u0026amp;2 return 1 fi # Fetch and process versions versions=$(curl -s \u0026#34;https://hub.docker.com/v2/repositories/library/$ {image_name}/tags/?page_size=100\u0026#34; | \\ jq -r \u0026#39;.results[].name\u0026#39; | \\ grep -E \u0026#39;^[0-9]+\\.*\u0026#39; | \\ sort -rV) # Reverse version sort (newest first) # Handle empty results if [ -z \u0026#34;$versions\u0026#34; ]; then echo \u0026#34;No version tags found for image: ${image_name}\u0026#34; \u0026gt;\u0026amp;2 return 1 fi # Apply limit if specified if [ \u0026#34;$limit\u0026#34; -gt 0 ]; then echo \u0026#34;$versions\u0026#34; | head -n \u0026#34;$limit\u0026#34; else echo \u0026#34;$versions\u0026#34; fi } source ~/.bashrc dkr_image_versions ubuntu [number] Tomcat SHOW CONTENTS Run the Tomcat container with interactive shell: docker run -p 8080:8080 --name tomcat2 -it tomcat:9-jre17 /bin/bash Remove the webapps directory: rm -r webapps Rename webapps.dist to webapps: mv webapps.dist webapps Start Tomcat in the background: ./bin/catalina.sh run \u0026amp; Open port 8080 in the firewall: sudo firewall-cmd --permanent --add-port=8080/tcp Reload the firewall configuration to apply changes: sudo firewall-cmd --reload MySQL SHOW CONTENTS Create Volumes for Log, Data, and Config: docker volume create mysql_data # Volume for MySQL data docker volume create mysql_log # Volume for MySQL logs docker volume create mysql_conf # Volume for MySQL configuration Run MySQL Container with Volumes: docker run -d \\ --name mysql \\ -e MYSQL_ROOT_PASSWORD=my-secret-pw \\ -p 3306:3306 \\ -v mysql_data:/var/lib/mysql \\ -v mysql_log:/var/log/mysql \\ -v mysql_conf:/etc/mysql/conf.d \\ mysql:latest Configure MySQL (Optional) # Optional: Copy custom config file to the volume cp my.cnf /var/lib/docker/volumes/mysql_conf/ Access MySQL: docker exec -it mysql mysql -u root -p Redis SHOW CONTENTS Create named Docker volumes: docker volume create redis_conf docker volume create redis_data Edit the Redis config file /var/lib/docker/volumes/redis_conf/redis.conf: # /app/redis/redis.conf requirepass yourpassword # bind 127.0.0.1 ← comment this out daemonize no # ensure Redis runs in foreground Start the Redis container: docker run -d \\ --name redis7 \\ --privileged=true \\ -p 6379:6379 \\ -v redis_conf:/etc/redis \\ -v redis_data:/data \\ redis:7.4.3 redis-server /etc/redis/redis.conf ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/devops/docker/1-docker/","summary":"Introduction to Docker SHOW CONTENTS Docker was developed to address the challenges of software deployment across various environments by providing a lightweight, consistent, and portable solution. Prior to Docker, developers often faced issues like \u0026ldquo;it works on my machine, but not in production,\u0026rdquo; caused by inconsistencies in dependencies, libraries, and configurations. Docker resolves this by containerizing applications, ensuring they run uniformly across any infrastructure. Its primary goal is to simplify development, testing, and deployment by encapsulating applications and their dependencies into isolated, reproducible containers.","title":"Docker"},{"content":"Japanese 1 Your browser does not support the audio element. SHOW NOTES 食料を買うためにお店に行きます。（I will go to the store to buy some food.） 遅れるのは良くない。（It is not good to be late.） 私は日本に行ったことがあります。（I have been to Japan before.） これを手伝（てつだ）ってくれますか？（Can you help me with this?） この店は安くておいしい、だからおすすめです。（This store is cheap and delicious, therefore it is recommended.） 母は、私に勉強しなさいと言いました。（My mother told me to study. ） 鍵はテーブルの上にあることに気がつきました。（I realized that I left my keys on the table.） 雨が止んだら、公園に行きます。（I will go to the park if it stops raining.） 辛い食べ物は食べられない。（I can\u0026rsquo;t eat spicy food.） この本は面白いように見える。（This book looks interesting.） 彼は私に部屋を掃除させました。（He made me clean the room.） 授業中は注意深く聞かなければなりません。（You must listen carefully in class.） 明日やるので、あなたはやらなくてもいいです。（I\u0026rsquo;ll do it tomorrow, so it\u0026rsquo;s not necessary for you to do it.） 2 Your browser does not support the audio element. SHOW NOTES 彼女は新しい家に引っ越すそうだ。(I heard that she is moving to a new house.) 彼女は宿題をしたばかりだ。(She just finished her homework.) 時間があったら、手伝っていただけますか？(If you have time, could you help me?) 映画を見たらどうですか。(Why don’t you go to the movies?) 彼にはパーティに一緒に来てほしい。(I want him to come with me to the party.) 窓を開けていただけませんか。(Could you please open the window?) これをしてあげる。(I\u0026rsquo;ll do this for you.) 昼ご飯を食べているところだ。(I\u0026rsquo;m in the middle of eating lunch.) 彼は日本語を2年間勉強している。(He has been studying Japanese for two years.) もっと日本語を話してみてください。(Please try speaking in Japanese more often.) 3 Your browser does not support the audio element. SHOW NOTES この仕事を今日中に終わらせることにした。（I decided to finish this work by the end of today.） 雨が降った場合は、ピクニックを中止します。（In the event of rain, we will cancel the picnic.） このボタンを押すだけで、全ての設定が完了します。（Just by pressing this button, all settings will be completed.） 会議が始まると、彼は突然質問を出した。（As the meeting started, he suddenly asked a question.） 子どもは遊びたがっている。（The child seems to want to play.） この花は良い匂（にお）いがする。（This flower smells good.） そんなに簡単に成功するはずがない。（It’s impossible to succeed that easily.） 彼は今どこにいるのかしら？（I wonder where he is now.） 彼はすごく疲れているみたいだ。（He seems to be really tired.） 歩きながら電話をしている。（I am talking on the phone while walking.） 4 Your browser does not support the audio element. SHOW NOTES 彼女は自分の間違いに気がついた。（She realized her mistake.） この問題は解きにくい。（This problem is difficult to solve.） 勉強のために毎日図書館に行くのに、今日は行けなかった。（I go to the library every day for studying, but I couldn’t go today.） 彼はまるで映画の主人公のように見える。（He looks like the protagonist of a movie.） 彼女は女優のような美しさを持っている。（She has the beauty like an actress.） 会議は1ヶ月おきに行われます。（The meetings are held every month.） 疲れているのに、彼は最後まで頑張った。（Although he was tired, he worked hard until the end.） 日本語が話せる。（I can speak Japanese.） 今日は暑いらしいですね。（It seems like it’s hot today.） 私はその映画を見られなかった。（I couldn’t watch that movie.） 彼は先生に褒められた。（He was praised by the teacher.） 先生は私たちに宿題をさせた。（The teacher made us do homework.） 彼は上司に遅くまで働かせられた。（He was forced to work late by his boss.） さすがプロの選手、すごいプレーだった。（As expected from a professional player, that was an amazing play.） お金が100円しかない。（I only have 100 yen.） 5 Your browser does not support the audio element. SHOW NOTES 彼は旅行に行きたがっている。（He wants to go on a trip.） これからも日本語を勉強していきます。（From now on, I will keep studying Japanese.） 昼ごはんを食べたばかりなので、もうお腹が空いていません。（I just ate lunch, so I’m not hungry yet.） 今出発するところです。（I am about to leave now.） 今レポートを書いているところです。（I am in the middle of writing the report.） もっと早く寝たらどうですか？（Why don’t you go to bed earlier?） 後で使うためにこの資料を取っておきます。（I will keep this document for later use.） 彼女にプレゼントを買ってあげた。（I bought her a present.） 彼は私に車を貸してくれる。（He is lending me his car.） 明日早く来てほしい。（I want you to come early tomorrow.） 財布を忘れてしまった。（I accidentally forgot my wallet.） 彼が来ないということを聞いた。（I heard that he isn’t coming.） この方法は最も簡単だといってもいい。（You could say this method is the easiest.） 彼は明日来るときいた。（I heard that he is coming tomorrow.） ","permalink":"https://signalyu.github.io/posts/3-humanities/personal-growth/practice/area-for-improvement/japanese/1-area-for-improvement/","summary":"Japanese 1 Your browser does not support the audio element. SHOW NOTES 食料を買うためにお店に行きます。（I will go to the store to buy some food.） 遅れるのは良くない。（It is not good to be late.） 私は日本に行ったことがあります。（I have been to Japan before.） これを手伝（てつだ）ってくれますか？（Can you help me with this?） この店は安くておいしい、だからおすすめです。（This store is cheap and delicious, therefore it is recommended.） 母は、私に勉強しなさいと言いました。（My mother told me to study. ） 鍵はテーブルの上にあることに気がつきました。（I realized that I left my keys on the table.） 雨が止んだら、公園に行きます。（I will go to the park if it stops raining.","title":"Areas For Improvement"},{"content":"Function Function arguments refer to data passed to the function. In python, there four main types of arguments: positional arguments, keyword arguments, default arguments, and variable length arguments.\nPositional arguments are passed to a function in a specific order, and the values are assigned to parameters based on their position. Keyword arguments are passed to a function by explicitly specifying the parameter name. Any keyword arguments must be put after the last positional argument. A default argument allows a function to accept values for parameters that are not provided by the caller. If no argument is passed for a parameter with a default value, the default will be used. Any default arguments must be put after the last positional argument. Variable length arguments allow a function to accept any number of positional arguments. *args accepts all arguments into a tuple, while **kwargs accepts all arguments into a dictionary. SHOW CODE Python def function_arguments(a, b=2, *args, c=3, **kwargs): print(f\"a: {a}, b: {b}, args: {args}, c: {c}, kwargs: {kwargs}\") function_arguments(1, 1997, 9, 99, 999, name=\"Signal\", age=27) SHOW OUTPUT Output a: 1, b: 1997, args: (9, 99, 999), c: 3, kwargs: {'name': 'Signal', 'age': 27} In Python, functions always return a value, if no return is specified, they return None.\nSHOW CODE Python def check_even(num): if num % 2 == 0: return True # No else clause, so returns None if odd print(check_even(3)) # None In Python, a variable defined outside a function is accessible within the function\u0026rsquo;s body, but only for reading its value. If a value is assigned to the variable inside the function, a new local variable with the same name is created, and the external variable remains unchanged.\nSHOW CODE Python Python x = 1 def fun(): print(x) fun() # 1 x = 1 def fun(): x = 2 print(x) fun() # 2 To modify a variable defined outside a function, the global keyword can be used, extending the variable\u0026rsquo;s scope into the function and allowing both reading and modification.\nSHOW CODE Python x = 1 def fun(): global x x = 2 print(x) print(x) # 1 fun() # 2 print(x) # 2 For function arguments, if the argument is a list, modifying the parameter itself doesn\u0026rsquo;t affect the original list, but modifying the list\u0026rsquo;s contents will affect the original list.\nSHOW CODE Python Python def fun(list_1): print(\"Before modification...\") print(f\"list_1: {list_1}\") print(f\"list_2: {list_2}\") list_1 = [0, 0] # Modify the parameter itself print(\"After modification...\") print(f\"list_1: {list_1}\") print(f\"list_2: {list_2}\") list_2 = [1, 2] fun(list_2) print(f\"Outside the funtion: list_2 = {list_2}\") ######################### Output ######################### Before modification... list_1: [1, 2] list_2: [1, 2] After modification... list_1: [0, 0] list_2: [1, 2] Outside the function: list_2 = [1, 2] ########################################################## ##################### Memory Diagram ##################### +-----------+ +--------+ +-----------+ | list_2 | ----\u003e | [1, 2] | \u003c---- | list_1 | +-----------+ +--------+ +-----------+ ############### Executing list_1 = [0, 0] ################ +-----------+ +--------+ | list_2 | ----\u003e | [1, 2] | +-----------+ +--------+ +-----------+ +--------+ | list_1 | ----\u003e | [0, 0] | +-----------+ +--------+ ########################################################## def fun(list_1): print(\"Before modification...\") print(f\"list_1: {list_1}\") print(f\"list_2: {list_2}\") list_1[0] = 999 # Modify the list's content print(\"After modification...\") print(f\"list_1: {list_1}\") print(f\"list_2: {list_2}\") list_2 = [1, 2] fun(list_2) print(f\"Outside the function: list_2 = {list_2}\") ######################### Output ######################### Before modification... list_1: [1, 2] list_2: [1, 2] After modification... list_1: [999, 2] list_2: [999, 2] Outside the funtion: list_2 = [999, 2] ########################################################## ##################### Memory Diagram ##################### +-----------+ +--------+ +-----------+ | list_2 | ----\u003e | [1, 2] | \u003c---- | list_1 | +-----------+ +--------+ +-----------+ ############### Executing list_1[0] = 999 ################ +-----------+ +----------+ +-----------+ | list_2 | ----\u003e | [999, 2] | \u003c---- | list_1 | +-----------+ +----------+ +-----------+ ########################################################## Operators Floor division // rounds down the result of the division, truncating any fractional part. For example, -6 // 4 outputs -2. Left-sided binding refers to the way operators or expressions are evaluated from left to right. Most operators evaluate left-to-right. For example, 9 % 6 % 2 returns 1. Right-sided binding refers to expressions where the evaluation happens from right to left. The exponentiation operator (**) and the chained assignment evaluate right-to-left. Compound assignment operators allow performing an operation and then assign the result of it to a variable in a single step. For example, the expression a /= 2 * 3 evaluates 2 * 3 to 6, and then performs a = a / 6 that returns 1.0. List When assinging a list to a new variable, both variables reference the same list object in memory, meaning modifying one variable affects the other because they point to the same data.\nSHOW CODE Python list_1 = [\"A\", \"B\", \"C\"] list_2 = list_1 list_3 = list_2 ###################### Memory Diagram ##################### +-----------+ +-----------------+ +-----------+ | list_1 | ----\u003e | [\"A\", \"B\", \"C\"] | \u003c---- | list_2 | +-----------+ +-----------------+ +-----------+ ^ | +-----------+ | list_3 | +-----------+ ########################################################### del list_1[0] ################### Memory Diagram ################### +-----------+ +------------+ +-----------+ | list_1 | ----\u003e | [\"B\", \"C\"] | \u003c---- | list_2 | +-----------+ +------------+ +-----------+ ^ | +-----------+ | list_3 | +-----------+ ###################################################### del list_2 ####### Memory Diagram ########### +-----------+ +------------+ | list_1 | ----\u003e | [\"B\", \"C\"] | +-----------+ +------------+ ^ | +-----------+ | list_3 | +-----------+ ################################## print(list_3) # [\"B\", \"C\"] To copy the contents of the original list, slicing is commonly used.\nSHOW CODE Python list_1 = [\"A\", \"B\", \"C\"] list_2 = list_1[:] list_3 = list_2[:] ############ Memory Diagram ########### +-----------+ +-----------------+ | list_1 | ----\u003e | [\"A\", \"B\", \"C\"] | +-----------+ +-----------------+ +-----------+ +-----------------+ | list_2 | ----\u003e | [\"A\", \"B\", \"C\"] | +-----------+ +-----------------+ +-----------+ +-----------------+ | list_3 | ----\u003e | [\"A\", \"B\", \"C\"] | +-----------+ +-----------------+ ####################################### del list_1[0] ############ Memory Diagram ########### +-----------+ +-----------------+ | list_1 | ----\u003e | [\"B\", \"C\"] | +-----------+ +-----------------+ +-----------+ +-----------------+ | list_2 | ----\u003e | [\"A\", \"B\", \"C\"] | +-----------+ +-----------------+ +-----------+ +-----------------+ | list_3 | ----\u003e | [\"A\", \"B\", \"C\"] | +-----------+ +-----------------+ ####################################### del list_2[0] ############ Memory Diagram ########### +-----------+ +-----------------+ | list_1 | ----\u003e | [\"B\", \"C\"] | +-----------+ +-----------------+ +-----------+ +-----------------+ | list_2 | ----\u003e | [\"B\", \"C\"] | +-----------+ +-----------------+ +-----------+ +-----------------+ | list_3 | ----\u003e | [\"A\", \"B\", \"C\"] | +-----------+ +-----------------+ ####################################### print(list_3) # [\"A\", \"B\", \"C\"] List comprehension in Python provides a concise way to create lists by applying an expression to each item in an iterable and optionally filtering items based on a condition. It is typically faster than using loops for constructing lists.\nSHOW CODE Python # [expression for item in iterable if condition] squares = [x**2 for x in range(10) if x % 2 == 0] print(squares) # [0, 4, 16, 36, 64] Tuple \u0026amp; Dictionary Tuples are immutable sequences. A tuple with a single item must have a trailing comma (tup = (5, )) to differentiate it from a regular parentheses-enclosed expression.\nTuple unpacking allows extracting elements of a tuple into variables. The number of variables must match the number of elements in the tuple.\nSHOW CODE Python sides = (1, 2, 2) a, b, c = sides print(a, b, c) # 1 2 2 Dictionaries are mutable and unordered collections of key-value pairs. In Python 3.6x, dictionaries have become ordered by default, meaning the order of item is preserved based on the order of insertion.\nKeys in a dictionary must be of a type that is immutable (e.g., strings, numbers, or tuples). Mutable types like lists or dictionaries themselves cannot be used as dictionary keys.\nSHOW CODE Python valid = {('a', 'b'): 'tuple_key'} # OK invalid = {['a', 'b']: 'list_key'} # TypeError ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/programming/python/1-python-programming/","summary":"Function Function arguments refer to data passed to the function. In python, there four main types of arguments: positional arguments, keyword arguments, default arguments, and variable length arguments.\nPositional arguments are passed to a function in a specific order, and the values are assigned to parameters based on their position. Keyword arguments are passed to a function by explicitly specifying the parameter name. Any keyword arguments must be put after the last positional argument.","title":"Python Programming"},{"content":"1. Introduction to CCNA Exam Exam Topics CCNA Exam Topics Exam Instructions Cisco Exam Tutorial Question Types YOU CAN\u0026rsquo;T GO BACK AFTER ANSWERING OR SKIPPING A QUESTION.\nCCNA Question Types Online Testing A PRIVATE and QUITE place for AT LEAST 2 HOURS must be needed.\nOnline Testing Cisco Packet Tracer Installation Cisco Packet Tracer Installation (Login First) Schduling and Taking the Exam Scheduling And Taking the Exam Exam Prep: Binary Game Binary Game 2. Network Devices Network Devices Local Area Network (LAN): A network that connects computers and devices within a limited geographical area, such as a home, office, or school. Wide Area Network (WAN): A network that spans a large geographical area, often connecting multiple LANs. Computer Network: A system of interconnected computers and devices that communicate and share resources. Node: Any device connected to a network, such as a computer, printer, or phone. Resources: Assets shared over a network, including hardware (e.g., printers, storage) and software (e.g., applications, files). Client-Server: A network model where clients request services or resources from servers. Switches Devices provide connectivity between devices in a local area network (LAN). Routers: Devices that provide connectivity between LANs or external network. Wireless Router: A device that provides wireless connectivity to a network, allowing devices to connect without physical cables. Network Firewall: A security system that monitors and controls incoming and outgoing network traffic based on predefined security rules, protecting against unauthorized access. 3. Cables, Connectors, and Ports Ethernet: A widely used wired networking technology that connects devices in a LAN using cables such as twisted pair or fiber optics. It follows standards like IEEE 802.3. IEEE (Institude of Electrical and Electronics Engineers): An organization that defines networking standards, including Ethernet (IEEE 802.3) and Wi-Fi (IEEE 802.11). Unshilded Twisted Pair (UTP) Cables: A type of Ethernet cable with twisted copper wire pairs that reduce electromagnetic interference (EMI). Common categories include Cat5e, Cat6e, and Cat6a. Shielded Twisted Pair (STP) Cables: A type of Ethernet cable that includes additional shieding to protect against electromagnetic interference (EMI) and crosstalk (an interference caused by signal leakage between adjacent cables or wire pairs in a network). UTP Cables vs. STP Cables Electromagnetic Interference (EMI): Disruptions in signal transmission caused by external electromagnetic sources, such as power lines or other electronic devices. Shielded cables (STP) help reduce EMI. 8 Position 8 Contact (8P8C) Connector: The standard modular connector used for Ethernet cables, often incorrectly called an RJ45 connector. 8P8C vs. RJ45 Fiber Optic Cables: High-speed network cables that use light instead of electrical signals, offering faster speeds and resistance to EMI. Fiber Optic Cable Structure Single Mode Fiber (SMF): A fiber optic cable type designed for long-distance transimission using a single light beam, reducing signal loss and allowing for higher speeds. Multimode Fiber (MMF): A fiber optic cable type that carries multiple light beams, suitable for shorter distances due to higher dispersion. Single Mode vs. Multimode 4. Networking Models Networking models are conceptual models that define how different layers of a network should interact to achieve communication between devices. The two most common models are the OSI Model and the TCP/IP Model.\nThe OSI Reference Model The OSI (Open Systems Interconnection) Model is a conceptual framework that divides network communication into seven layers. These layers are the Physical Layer, Data Link Layer, Network Layer, Transport Layer, Session Layer, Presentation Layer, and Application Layer. Each layer has a specific function and interacts with adjacent layers to ensure smooth and efficient data transmission.\nPhysical Layer: Transmits raw bits over a physical medium (e.g., cables). Data Link Layer: Handles data frames and ensures error-free transmission between adjacent nodes (e.g., MAC addresses, switches). Network Layer: Determines the best path for data and handles addressing and routing (e.g., IP addresses, routers). Transport Layer: Ensures reliable data transfer with error correction and flow control (e.g., TCP, UDP). Session Layer: Manages and controls communication sessions between applications. Presentation Layer: Converts data formats for compatibility (e.g., encryption, compression). Application Layer: Provides network services directly to applications (e.g., HTTP, FTP, SMTP). OSI Reference Model OSI Reference Model The TCP/IP Model The TCP/IP Model (Transmission Control Protocol/Internet Protocol) is a practical framework used for internet communication. It consists of four layers: the Network Interface Layer, Internet Layer, Transport Layer, and Application Layer.\nNetwork Interface Layer: Handles physical data transmission over a network medium. It is equivalent to the Physical and Data Link Layers of the OSI model. Internet Layer: Routes packets across networks using IP addresses, similar to the Network Layer in the OSI model. Transport Layer: Ensures reliable (TCP) or fast (UDP) data delivery between devices, corresponding to the Transport Layer in the OSI model. Application Layer: Supports network applications and protocols like HTTP, FTP, and SMTP. It combines the functions of the Application, Presentation, and Session Layers in the OSI model. TCP/IP Model The 5-Layer Network Model The 5-Layer Network Model is a simplified version of the OSI Reference Model, commonly used to understand networking concepts. It merges the Session, Presentation, and Application Layers of the OSI model into a single Application Layer. Below is the diagram illustrating this model:\nThe 5-Layer Network Model Key Notes In networking, adjacent layer interaction refers to the communication and collaboration between two neighboring layers in a networking model. Each layer provides service to the layer above it and relies on the layer below it to perform its functions. 5. The Cisco ISO CLI EXEC, Privileged EXEC, and Global Configuration Modes In Cisco devices (such as routers and switches), there are three main modes that allow interaction with the device: EXEC, Privileged EXEC, and Global Configuration modes.\nEXEC, Privileged EXEC, and Global Configuration Modes EXEC Mode: This is the initial mode when first logging into a Cisco device. It provides basic access to the device and allows running simple monitoring and diagnostic commands. Privileged EXEC Mode: This mode provides more advanced commands to view detailed information about the device. To enter Privileged EXEC Mode, type enable from EXEC Mode. To exit Privileged EXEC Mode, type disable to return to EXEC Mode. Global Configuration Mode: This mode allows modification of the system configuration. To Global Configuration Mode, type configure terminal or conf t (shorthand). To return to Privileged EXEC Mode, type end or exit. 6. Ethernet LAN Switching Ethernet Frame Format An Ethernet frame is the fundamental unit of data transmission in Ethernet networks. It is used to encapsulate and transmit data over a Local Area Network (LAN). The Ethernet frame format is defined by the IEEE 802.3 standard and consists of several fields. Here is a detailed breakdown of the Ethernet frame format:\nEthernet Frame Format Preamble (7 bytes): A series f alternating 1s and 0s used for synchonization. SFD (Start Frame Delimiter, 1 byte): Uses a one byte bit pattern (10101011) to mark the end of the preamble and the start of the actual data. Destination MAC Address (6 bytes): The MAC address of the device receiving the frame. Source MAC Address (6 bytes): The MAC address of the device sending the frame. EtherType/Length (2 bytes): Indicates the type of protocol (e.g., IPv4, ARP) or the length of the payload. Payload/Data (46 - 1500 bytes): The actual data being transmitted, such as an IP packet or other protocol data. FCS (Frame Check Sequence, 4 bytes): A 32-bit CRC (Cyclic Redundency Check) for error detection. Note that the Ethernet header includes the Destination MAC Address, Source MAC Address, and Type/Length fields. It does not include the Preamble and Start Frame Delimiter (SFD) fields. The Ethernet trailer only includes the Frame Check Sequence (FCS) field.\nMAC Address A MAC address (Media Access Control Address) is a unique identifier assigned to a network interface controller (NIC) for communication on a network. It is a 6-byte address, typically represented in hexadecimal format. The MAC address is divided into two parts: OUI (Organizationally Unique Identifier) and NIC (Network Interface Controller) Specific. The OUI is assigned by the IEEE to identify the manufacturer or vendor of the device, while the NIC Specific part is assigned by the manufacturer to uniquely identify the network interface device.\nMAC Address Format Frame Switching In computer networks, switches help forward data by using a MAC (Media Access Control) address table. This table stores the MAC addresses of devices connected to the switch and the ports through which those devices are connected.\nWhen a switch receives a data frame, it checks the source MAC address in the frame. The switch then adds the MAC address to its MAC address table and associates it with the port from which the frame arrived. This process is called MAC address learning, and the MAC addresses added in this way are called dynamic MAC addresses.\nTo keep the MAC address table up-to-date, the switch uses MAC address aging. If the switch doesn\u0026rsquo;t receive a frame from a particular MAC address for five minutes, it removes that MAC address from the table. This helps avoid outdated or unnecessary entries.\nSwitches handle two types of frames: unicast and unknown unicast. A unicast frame is addressed to a specific device. If the switch knows the destination device\u0026rsquo;s MAC address, it forwards the frame to the correct port. This is called a known unicast frame. If the switch doesn\u0026rsquo;t know the destination MAC address, it treats the frame as an unknown unicast frame. In this case, the switch sends the frame to all its ports, except the one it received the frame on, in an attempt to reach the correct device. This is called flooding.\nHere are some common commands for managing MAC address table:\nshow mac address-table: Shows all learned MAC addresses. clear mac address-table dynamic: Deletes all dynamic MAC addresses. clear mac address-table dynamic address \u0026lt;mac-address\u0026gt;: Removes a specific MAC address. clear mac address-table dynamic interface \u0026lt;interface-name\u0026gt;: Clears MAC addresses on a specific port. ARP (Address Resolution Protocol) The Address Resolution Protocol (ARP) helps devices find the MAC addresses of another when they only know its IP address.\nARP works through two key messages: the ARP request and the ARP reply.\nARP Request: A device sends a broadcast message to FFFF.FFFF.FFFF, and asks \u0026ldquo;who has this IP address? Tell me your MAC address!\u0026rdquo; Since the ARP Request is a broadcast, the switch floods it to all devices in the same boradcast domain. ARP Reply: The device with the matching IP responds with its MAC address in a unicast message. A broadcast domain is a group of devices that receive each other\u0026rsquo;s broadcast messages. If multiple switches are connected, all devices on those switches are in the same broadcast domain.\nTo avoid sending ARP requests every time they communicate, devices store IP-to-MAC mappings in an ARP table. This table keeps entries for a short time before refreshing them.\nPing Ping is a widely used utility that helps test the connectivity between two devices on a network. It is part of the Internet Control Message Protocol (ICMP) and is a critical tool for diagnosing network issues and ensuring that devices can communicate with each other.\nPing is part of ICMP (Internet Control Message Protocol) and uses two messages:\nICMP Echo Request: The sender asks, \u0026ldquo;Are you there?\u0026rdquo; by sending a unicast message to the target device. ICMP Echo Reply: If the destination device is reachable, it responds with a unicast message confirming connectivity. Ping is commonly used for troubleshooting network connectivity issues. To use ping, simple type ping \u0026lt;ip-address\u0026gt;.\n7. IPv4 IPv4 Header Format IPv4 Header Format The IPv4 header format consists of several fields that help rout the packet from the source to the destination. Here\u0026rsquo;s a breakdown of the IPv4 header structure:\nVersion: Specifies the version of the IP protocol. For IPv4, the value is 4. IHL (Internet Header Length): Specifies the length of the header in 32-bit words. The minimum value is 5, which corresponds to a 20-byte header. Type of Service (ToS): Defines the priority or quality of service (delay, throughput, reliability) for the packet. Total Length: Specifies the entire packet size (header + data) in bytes. Identification: A unique identifier for the packet, used for reassembling fragmented packets. Flags: Used for fragmentation control. It has the following fields: Bit 0 (Reserved): Must be 0. Bit 1 (DF - Don\u0026rsquo;t Fragment): If set, fragmentation is disabled. Bit 2 (MF - More Fragments): If set more fragments follow. Fragmentation Offset: Specifies the position of the fragment\u0026rsquo;s data in the original packet. It is used for reassembling fragmented packets. TTL (Time To Live): Specifies the maximum number of hops the packet can traverse before being discarded. Decrease by 1 at each hop. Protocol: Specifies the protocol used in the data portion of the IP packet, such as: 1 for ICMP 6 for TCP 17 for UDP Header Checksum: A checksum value used for error-checking the header to ensure it has not been corrupted. Source IP Address: The IP address of the source of the packet. Destination IP Address: The IP address of the intended destination of the packet. Options: Optional fields for additional settings, such as security, timestamp, and routing information. Requires padding to align to 32 bits. IPv4 Addressing IPv4 addresses are 32-bit numbers that identify devices on a network. They are written in dotted decimal notation (e.g., 192.168.1.1), divided into four groups of 8 bits called octets. An IPv4 addresss is split into two parts: the network portion and the host portion.\nNetwork Portion: This part identifies the network where a device belongs. All devices in the same network share the same network portion. Host Portion: This part identifies the specific device in the network. Each device has a unique host portion. The network portion is usually indicated with a prefix (e.g., /24), which shows how many bits are used for the network. Alternatively, a netmask (e.g., 255.255.255.0) can also define the network portion. A netmask uses 1s for the network part and 0s for the host part.\nThe IP addresses can be categorized into three types: Network Address, Broadcast Address, and Usable Addresses.\nNetwork Address: The first address in a network (host portion is all 0s). It identifies the network and can\u0026rsquo;t be assigned to a device. Broadcast Address: The last address in a network (host portion is all 1s). It\u0026rsquo;s used to send messages to all devices in the network. However, to send a message to all hosts on the local network, the address 255.255.255.255 is usually used. Usable Addresses: These are the addresses that can be assigned to devices. The number of usable addresses is calculated as $2^y - 2$, where $y$ is the number of bits in the host portion. Subtracting 2 accounts for the exclusion of the network address and the broadcast address. IPv4 addresses can be organized into five classes: A, B, C, D, and E.\nClassful IPv4 Addresses Class A: For large networks. (First octet: 0-127, uses a /8 prefix) Class B: For medium-sized networks. (First octet: 128-191, uses a /16 prefix) Class C: For small networks. (First octet: 192-233, uses /24 prefix) Class D: For multicast addresses. Class E: For experimental purposes. Note that the classful addressing are obsolete, most modern networks use classless addressing (e.g., 192.168.1.0/28).\nConfiguring IPv4 Addresses On a Router Routers use interfaces with IPv4 addresses to commnunicate between networks. Here are some common use commands:\nshow ip interface brief: Shows a summary of interface statuses and their IP addresses. show ip interface [interface-name]: Shows detailed settings for a specific interface. no shutdown: Enables an interface (router interfaces are turned off by default.) ip address [ip-address] [netmask]: Assigns an IP address and a subnet mask to the interface. 8. Routing \u0026amp; Switch Interfaces ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/computer-networking/1-ccna/","summary":"1. Introduction to CCNA Exam Exam Topics CCNA Exam Topics Exam Instructions Cisco Exam Tutorial Question Types YOU CAN\u0026rsquo;T GO BACK AFTER ANSWERING OR SKIPPING A QUESTION.\nCCNA Question Types Online Testing A PRIVATE and QUITE place for AT LEAST 2 HOURS must be needed.\nOnline Testing Cisco Packet Tracer Installation Cisco Packet Tracer Installation (Login First) Schduling and Taking the Exam Scheduling And Taking the Exam Exam Prep: Binary Game Binary Game 2.","title":"Cisco Certified Networking Associate (CCNA)"},{"content":"リスニング 音楽 ブルー・ライト・ヨコハマ Your browser does not support the audio element. 歌詞見せて 街（まち『き』）の灯（あか）りが　とてもきれいね\nThe city lights are so beautiful\n城市的灯光如此美丽\nヨコハマ　ブルー・ライト・ヨコハマ\nYokohama, Blue Light Yokohama\n横滨，蓝色之光横滨\nあなたと二人　幸せよ\nWith you, I\u0026rsquo;m so happy\n与你在一起 多么幸福\nいつものように　愛のことばを\nAs always, whisper words of love\n像往常一样 请对我说爱的蜜语\nヨコハマ　ブルー・ライト・ヨコハマ\nYokohama, Blue Light Yokohama\n横滨，蓝色之光横滨\n私にください　あなたから\nPlease say them to me, my darling\n请对我说 亲爱的\n歩いても　歩いても\nNo matter how far we walk\n无论走多远\n小舟（こぶね）（）のように　わたしはゆれて\nI sway like a little boat\n我像小船般摇曳\nゆれて　あなたの腕の中\nSwaying in your arms\n摇曳在你怀中\n足音（あしおと）だけが　ついて来るのよ\nOnly our footsteps follow us\n唯有脚步声相随\nヨコハマ　ブルー・ライト・ヨコハマ\nYokohama, Blue Light Yokohama\n横滨，蓝色之光横滨\nやさしいくちづけ　もういちど\nGive me your tender kiss once more\n请再给我一个温柔的吻\n歩いても　歩いても\nNo matter how far we walk\n无论走多远\n小舟（こぶね）のように　わたしはゆれて\nI sway like a little boat\n我像小船般摇曳\nゆれて　あなたの腕の中\nSwaying in your arms\n摇曳在你怀中\nあなたの好きな　タバコの香（かお）り\nThe scent of your favorite tobacco\n你喜爱的烟草香气\nヨコハマ　ブルー・ライト・ヨコハマ\nYokohama, Blue Light Yokohama\n横滨，蓝色之光横滨\n二人の世界　いつまでも\nMay our world last forever\n愿我们的世界永存\nありがとう　あなた Your browser does not support the audio element. 歌詞見せて 私のせいなら　許してください\nPlease forgive me if it\u0026rsquo;s my fault\n如果是我的错，请原谅我\nあなたをこんなに　苦しめたことを\nFor causing you so much pain\n让我让你如此痛苦\n私のことなど　これきり忘れて\nForget about me from now on\n从今以后，忘记我吧\n明るい陽なたを　歩いてほしい\nI want you to walk in the bright sunlight\n我希望你能走在明媚的阳光下\n枯葉がひとつずつこぼれるたびに\nEvery time a dry leaf falls\n每当枯叶一片片飘落\n悲しいお別れ近づいてます\nThe sad farewell is approaching\n悲伤的告别即将到来\n泣いたり笑ったり　けんかをしたり\nCrying, laughing, and fighting\n哭泣、笑声、争吵\nあなたといるかぎり素直になれました\nAs long as I was with you, I could be honest\n只要和你在一起，我就能变得真诚\n”ありがとうあなた”\nThank you, you\n谢谢你\nあとどのくらい　愛されますか\nHow much longer will I be loved?\n我还能被爱多久？\nあとどのくらい　生きられますか\nHow much longer can I live?\n我还能活多久？\n私のせいなら　許してください\nPlease forgive me if it\u0026rsquo;s my fault\n如果是我的错，请原谅我\nあなたを知らずに傷つけたことを\nFor hurting you without knowing you\n无意中伤害了你\n私はひとりで　どうにかなるから\nI can manage alone\n我可以一个人应付\nいい人かならず　みつけてほしい\nI want you to find a good person\n我希望你能找到一个好人\n小石をひとつずつならべるように\nLike arranging small stones one by one\n就像一个个地排放小石头\nいろんな想い出数えています\nI am counting various memories\n我在数着各种回忆\n人から愛される　幸福の意味\nThe meaning of happiness is being loved by others\n幸福的意义是被人爱\nあなたは手をとって教えてくれました\nYou took my hand and taught me\n你牵着我的手教我\n”ありがとうあなた”\nThank you, you\n谢谢你\nあとどのくらい　愛されますか\nHow much longer will I be loved?\n我还能被爱多久？\nあとどのくらい　生きられますか\nHow much longer can I live?\n我还能活多久？\nさようならの向う側 Your browser does not support the audio element. 歌詞見せて 何億（おく）光年（こうねん）　輝（かがや）く星（ほし）にも　寿命（じゅみょう）があると\nEven stars shining billions of light years away have a lifespan\n即使是闪烁着亿万光年的星星也有寿命\n教えてくれたのは　あなたでした\nIt was you who taught me\n是你教给我的\n季節ごとに咲（さく）　一輪（りん）の花に　無限（むげん）の命（いのち）\nIn each season, a single flower blooms with infinite life\n每个季节里，开出的一朵花有着无限的生命\n知らせてくれたのも　あなたでした\nIt was you who told me\n是你告诉我的\nLast song for you\nLast song for you\n約束（やくそく）なしの　お別れです\nA farewell without promises\n没有约定的告别\nLast song for you\nLast song for you\n今度はいつと言えません\nI cannot say when we\u0026rsquo;ll meet again\n我无法说何时再见\nあなたの燃（も）える手　あなたの口づけ\nYour burning hands, your kiss\n你燃烧的手，你的吻\nあなたのぬくもり　あなたのすべてを\nYour warmth, your everything\n你的温暖，你的一切\nきっと　私　忘れません\nI will surely never forget\n我一定不会忘记\n後姿（すがた）　みないで下さい\nPlease don’t look at my back\n请不要看我的背影\nThank you for your kindness\nThank you for your tenderness\nThank you for your smile\nThank you for your love\nThank you for your everything\nさよならのかわりに\nInstead of saying goodbye\n代替告别的话\n眠（ねむ）れないほどに　思い惑（まど）う日々（ひび）　熱い言葉（ことば）で\nDays filled with confusion that kept me awake, supported by your passionate words\n日复一日的困惑，无法入睡，你的热情话语给了我支持\n支（ささ）えてくれたのは　あなたでした\nIt was you who supported me\n是你一直在支持我\n時として一人　くじけそうになる　心（こころ）に夢（ゆめ）を\nSometimes I was alone and felt like giving up, but you gave me dreams in my heart\n有时我一个人，感觉要崩溃，你给了我心中的梦想\n与（あた）えてくれたのも　あなたでした\nIt was you who gave it to me\n是你给我的\nLast song for you\nLast song for you\n涙（なみだ）をかくし　お別（わか）れです\nI hide my tears and say goodbye\n掩饰泪水，告别\nLast song for you\nLast song for you\nいつものように　さり気なく\nAs usual, casually\n像往常一样，悄无声息\nあなたの呼びかけ　あなたの喝采（かっさい）\nYour calls, your applause\n你呼唤的声音，你的掌声\nあなたのやさしさ　あなたのすべてを\nYour kindness, your everything\n你的温柔，你的一切\nきっと　私　忘れません\nI will surely never forget\n我一定不会忘记\n後姿（すがた）　みないでゆきます\nI’ll walk away without looking at your back\n我将离开，不回头\nThank you for your kindness\nThank you for your tenderness\nThank you for your smile\nThank you for your love\nThank you for your everything\nさよならのかわりに\nInstead of saying goodbye\n代替告别的话\nさよならのかわりに\nInstead of saying goodbye\n代替告别的话\nさよならのかわりに\nInstead of saying goodbye\n代替告别的话\nいのちの理由 Your browser does not support the audio element. 歌詞見せて 私が生（う）まれてきた訳（わけ）は\nThe reason I was born\n我出生的原因是\n父と母とに出会うため\nTo meet my father and mother\n为了遇见我的父母\n私が生まれてきた訳（わけ）は\nThe reason I was born\n我出生的原因是\nきょうだいたちに出会うため\nTo meet my siblings\n为了遇见我的兄弟姐妹\n私が生まれてきた訳（わけ）は\nThe reason I was born\n我出生的原因是\n友達みんなに出会うため\nTo meet all my friends\n为了遇见我的所有朋友\n私が生まれてきた訳（わけ）は\nThe reason I was born\n我出生的原因是\n愛（いと）しいあなたに出会うため\nTo meet you, my beloved\n为了遇见你，我的挚爱\n春来（く）れば 花自（おの）ずから咲（さ）くように\nWhen spring comes, flowers naturally bloom\n春天来临时，花朵自然而然地绽放\n秋くれば　葉（は）は自（おの）ずから散（ち）るように\nWhen autumn comes, the leaves naturally fall\n秋天来临时，树叶自然而然地飘落\nしあわせになるために\nTo become happy\n为了获得幸福\n誰もが生（う）まれてきたんだよ\nEveryone was born for this reason\n每个人都是为了这个原因而诞生\n悲（かな）しみの花の後（あと）からは\nAfter the flower of sadness\n悲伤之花之后\n喜（よろこ）びの実（み）が実（みの）るように\nThe fruit of joy will grow\n喜悦的果实将会成熟\n私が生まれてきた訳（わけ）は\nThe reason I was born\n我出生的原因是\n何処（どこ）かの誰かを傷（きず）つけて\nTo hurt someone somewhere\n为了伤害某个地方的某个人\n私が生まれてきた訳（わけ）は\nThe reason I was born\n我出生的原因是\n何処（どこ）かの誰かに傷（きず）ついて\nTo be hurt by someone somewhere\n为了被某个地方的某个人伤害\n私が生まれてきた訳（わけ）は\nThe reason I was born\n我出生的原因是\n何処（どこ）かの誰かに救（すく）われて\nTo be saved by someone somewhere\n为了被某个地方的某个人拯救\n私が生まれてきた訳は\nThe reason I was born\n我出生的原因是\n何処かの誰かを救（すく）うため\nTo save someone somewhere\n为了拯救某个地方的某个人\n夜が来て 闇（やみ）自（おの）ずから染み（しみ）るよう\nWhen night comes, the darkness naturally spreads\n夜幕降临，黑暗自然而然地扩散\n朝が来て 光（ひかり）自（おの）ずから照ら（てら）すよう\nWhen morning comes, the light naturally shines\n早晨到来，光明自然而然地照亮\nしあわせになるために\nTo become happy\n为了获得幸福\n誰もが生（い）きているんだよ\nEveryone is living for this reason\n每个人都在为此活着\n悲（かな）しみの海の向こうから\nFrom across the sea of sadness\n从悲伤之海的彼岸\n喜（よろこ）びが満（み）ちて来るように\nJoy will come flowing\n喜悦的潮水将会涌来\n私が生まれてきた訳は\nThe reason I was born\n我出生的原因是\n愛（いと）しいあなたに出会うため\nTo meet you, my beloved\n为了遇见你，我的挚爱\n私が生まれてきた訳は\nThe reason I was born\n我出生的原因是\n愛しいあなたを護（まも）るため\nTo protect you, my beloved\n为了守护你，我的挚爱\nキミとミタイセカイ Your browser does not support the audio element. 歌詞見せて ねぇ、まだ　あの日のまま\nHey, still, as it was that day\n嘿，依然如那一天\nねえ、今も、運（うん）命（めい）と願いたい\nHey, even now, I want to wish it’s fate\n嘿，现在，我依然希望这是命运\n幸せを描（えが）くはずだったミライ　霞（かす）んでいく、、、\nThe future that was supposed to paint happiness is fading\u0026hellip;\n本应描绘幸福的未来正逐渐模糊\u0026hellip;\nイロノナイセカイ\nA world without color\n没有色彩的世界\n僕の生（い）きる意味さえ分からなくなって、、\nI’ve even lost the meaning of my life\u0026hellip;\n连我活着的意义都变得不清楚\u0026hellip;\n時を戻（もど）して、声を聞かせて、\nTurn back time, let me hear your voice\n把时间倒流，让我听到你的声音\n教えて、僕らの愛（あい）を　I want\nTell me, about our love, I want\n告诉我，关于我们的爱，我想知道\nもう一度、、\nOnce again\u0026hellip;\n再一次\u0026hellip;\n本の気持ちまで失（うしな）って\nLosing even the real feelings\n连真实的感情也失去了\n満（み）たされたい幸せって何か？って\nWhat is happiness that I want to be fulfilled?\n什么是我想要填补的幸福？\nすれ違う表（ひょう）情（じょう）の向こう\nBeyond the expressions we pass by\n我们错身而过的表情背后\n僕とキミが描（えが）いていたストーリー\nThe story that you and I had been drawing\n你我曾一起描绘的故事\nキミトミタイセカイ\nA world I want to see with you\n我想和你一起看到的世界\nきっと目を覚（さ）ます頃（ころ）に　ナミダ溢（あふ）れて、、\nSurely, when I wake up, tears will overflow\u0026hellip;\n当我醒来时，眼泪一定会溢出\u0026hellip;\n寄（よ）り添（そ）うコトバ\nWords to stay close\n彼此依偎的话语\n「愛しているよ」\n\u0026ldquo;I love you\u0026rdquo;\n“我爱你”\nボクから伝（つた）えたい、、\nI want to convey it to you\u0026hellip;\n我想要传达给你\u0026hellip;\n愛を、、愛をもう一度\nLove\u0026hellip; love, once more\n爱\u0026hellip; 爱，再一次\nOH\nOH\n哦\n時を戻（もど）して　声を聴かせて\nTurn back time, let me hear your voice\n把时间倒流，让我听到你的声音\nOH\nOH\n哦\n虹 Your browser does not support the audio element. SHOW CONTENTS やさしくなりたい Your browser does not support the audio element. 歌詞見せて 地球儀を回して　世界100周旅行 Spinning the globe, traveling the world a hundred times 转动地球仪，环游世界一百圈\nキミがはしゃいでいる　まぶしい瞳で You’re all excited, with dazzling eyes 你欢快地跳跃着，眼睛闪闪发光\n光のうしろ側　忍び寄る影法師 Behind the light, a creeping shadow approaches 光明背后，潜伏着悄悄靠近的影子\nなつかしの昨日は　いま雨の中に Yesterday we long for is now in the rain 令人怀念的昨天，如今在雨中飘落\nやさしくなりたい　やさしくなりたい I want to be gentle, I want to be kind 我想变得温柔，我想变得善良\n自分ばかりじゃ　虚しさばかりじゃ Only thinking of myself brings only emptiness 只顾自己，只会感到空虚\n愛なき時代に　生まれたわけじゃない We weren’t born in an era without love 我们并不是生于无爱的时代\nキミといきたい　キミを笑わせたい I want to live with you, I want to make you smile 我想和你一起生活，让你开心地笑\n愛なき時代に　生まれたわけじゃない We weren’t born in an era without love 我们并不是生于无爱的时代\n強くなりたい　やさしくなりたい I want to be strong, I want to be kind 我想变得坚强，也想变得温柔\nサイコロ転がして　1の目が出たけれど I rolled the dice and got a one 掷出骰子，点数是1\n双六の文字には　「ふりだしに戻る」 But the board says, “Back to start” 但双六游戏的格子上写着“回到起点”\nキミはきっと言うだろう　「あなたらしいわね」と You’d probably say, “That’s just like you” 你一定会笑着说：“真像你的风格”\n「1つ進めたのなら　よかったじゃないの!」 “If you moved forward even once, isn’t that great?” “能前进一步，不是很好吗？”\nおぉ 強くなりたい　強くなりたい Oh, I want to be strong, I want to be strong 哦，我想变得坚强，我想变得强大\n我慢ばかりじゃ　誤魔化しばかりじゃ Always enduring is just self-deception 一味忍耐，只是在自欺欺人\n愛なき時代に　生まれたわけじゃない We weren’t born in an era without love 我们并不是生于无爱的时代\nキミに会いたい　キミに会いたい I want to see you, I want to see you 我想见你，我想见你\n愛なき時代に　生まれたわけじゃない We weren’t born in an era without love 我们并不是生于无爱的时代\n強くなりたい　やさしくなりたい I want to be strong, I want to be kind 我想变得坚强，也想变得温柔\nウウ オーイェ Ooh Oh yeah 呜呜 哦耶\n地球儀を回して　世界100周 Spin the globe, a hundred laps around the world 转动地球仪，环游世界一百圈\nボクらで回そう　待ってておくれ　イェ Let’s spin it ourselves, just wait for me, yeah 让我们一起转动它，请等我一下，耶\n愛なき時代に　生まれたわけじゃない We weren’t born in an era without love 我们并不是生于无爱的时代\nキミに会いたい　キミを笑わせたい I want to see you, I want to make you smile 我想见你，让你开心地笑\n愛なき時代に　生まれたわけじゃない We weren’t born in an era without love 我们并不是生于无爱的时代\n強くなりたい　やさしくなりたい I want to be strong, I want to be kind 我想变得坚强，也想变得温柔\n愛なき時代に　生きてるわけじゃない We’re not living in a loveless time 我们并不是生活在无爱的时代\n手を繋ぎたい　やさしくなりたい I want to hold your hand, I want to be kind 我想牵起你的手，想要变得温柔\nウウ オーイェ Ooh oh yeah 呜呜 哦耶\nウウー イェ Ooh yeah 呜呜 耶\nイェ イェ イェ ウウー Yeah yeah yeah ooh 耶耶耶 呜呜\n文法 １−５ Your browser does not support the audio element. SHOW NOTES だげ：だげ is used to express that something is the only thing. これだけください。（Just this one, please.） お酒が飲めません、ダイエットコーラだけ飲みます。（I can\u0026rsquo;t drink wine, I only drink diet coke.） だろう：だろう is often used to show a guess or assumption. It\u0026rsquo;s a more casual form of でしょう. 彼は来るでしょう。（He will probably come.） 彼女は10年も韓国に住んでいるので韓国語は上手だろう。（She has been living in Korea for 10 years, so she\u0026rsquo;s probably good at Korean.） でしょう：でしょう is used to express probability or expectation. 彼は忙しいでしょう。（He is probably busy.） 日本人が晩ごはんによく食べるものは寿司でしょう。（Japanese people probably eat sushi a lot for dinner.） が：が is a conjunction used to introduce a contrast or contradiction. It is used between two clauses to show contrast. 新しいパソコンを買いたいが、お金がない。（I want to buy a new computer, but I have no money.） 行きたいが、時間がない。（I want to go, but I don\u0026rsquo;t have time.） がある：がある is used to express the existence of something, particularly for inanimate objects or abstract things. その町には古いお城がある。（There is an old castle in that town.） 公園に大きな木がある。（There is a big tree in the park.） ６−１０ Your browser does not support the audio element. SHOW NOTES ほうがいい：ほうがいい is used to suggest that something is the better choice or the more advisable action. 早く寝たほうがいい。（It\u0026rsquo;d be better to go to bed early.） 願書（がんしょ）を早く送るほうがいいですよ。（You should better send your application form quickly.） けれども：けれども is used to contrast two ideas. It can be shortened to けど or けれど in casual speech. 今日は忙しいけれども、手伝います。（I\u0026rsquo;m busy today, but I\u0026rsquo;ll help.） 雨が降っているけど、出かけなければならない。（It\u0026rsquo;s raining, but I have to go out.） くらい/ぐらい：くらい/ぐらい is used to indicate an approximate amount or degree of something. ２時間くらいかかると思います。（I think it will take about two hours.） ここから新高円寺駅まで歩いでどのくらいかかりますか？（How long does it take to walk from here to Shinkoenji station?） 前に：前に is used to indicate that something happened or should happen before another action. 寝る前に薬を飲んでください。（Please take the medicine before you go to bed.） 出発する前に確認してください。（Please check before you depart.） ませんか：ませんか is a polite way to invite someone to do something or to suggest an action. お茶を飲みませんか？（Won\u0026rsquo;t you have some tea?） 明日東京ディズニーランドに行くませんか。（Won\u0026rsquo;t you go to Tokyo Disneyland tomorrow?） １１−１５ Your browser does not support the audio element. SHOW NOTES な：な is a casual or firm way to tell someone not to do something. It\u0026rsquo;s often used in commands or warnings. ここにいるな！（Don\u0026rsquo;t enter here!） 俺の息子を虐（いじ）めるな！（Don\u0026rsquo;t bully my son!） ないでください：ないでください is a polite way to ask someone not to do something. 写真を撮らないでください。（Please don\u0026rsquo;t take photos.） ここでタバコを吸わないでください。（Please don\u0026rsquo;t smoke here.） なる：なる means \u0026ldquo;to become\u0026rdquo; and is used when something changes into a different state. 日本語が上手なりました。（I became good at Japanese.） １５時間も寝たので、頭が痛くなった。（I slept for 15 hours so I have a headache.） に行く：に行く is used when going somewhere to do something. It\u0026rsquo;s commonly used to express purpose. コンビニへパンを買いに行きます。（I\u0026rsquo;m going to the convenience store to buy bread.） 薪（まき）を集（あつ）めに行こう！（Let\u0026rsquo;s go pick up firewood!） にする：にする means to decide on something, it\u0026rsquo;s commonly used when making a choice. どれにしますか？（Which one will you choose?） 僕はコーヒーにします。（I\u0026rsquo;ll have coffee.） １６−２０ Your browser does not support the audio element. SHOW NOTES のが上手：のが上手 is used to express being good at something. 私は料理を作るのが上手です。（I\u0026rsquo;m good at cooking.） 彼はピアノを弾くのが上手だ。（He\u0026rsquo;s good at playing the piano.） のが下手：のが下手 is used to express being bad at something. 私はスポーツをするのが下手です。（I\u0026rsquo;m bad at sports.） 私は絵を描くのがすごく下手です。（I\u0026rsquo;m terrible at painting.） すぎる：すぎる is used to express that something is too much or excessive. It is attached to the stem of an adjective or verb to indicate that something goes beyond what is normal or acceptable. この料理は辛すぎる。（This food is too spicy.） その鞄は高すぎるから、買えない。（I can\u0026rsquo;t buy that bag because it\u0026rsquo;s too expensive.） たことがある：たことがある is used to express that you have done something before. 日本に行ったことがあります。（I have been to Japan before.） 寿司を食べたことがありますか？（Have you ever eaten sushi?） てもいい：てもいい is used to give permission or to say that is okay to do something. ここで写真を撮ってもいいですか？（Is it okay to take photos here?） この本を借りてもいいですか？（Can I borrow this book?） ２１−２５ Your browser does not support the audio element. SHOW NOTES てから：てから is used to express that one action happens after another. ご飯を食べてから勉強します。（I will study after eating.） 家に帰ってから電話をかけます。（I will make a call after I get home.） てはいけない：てはいけない is used to indicate that something is forbidden. ここて写真を撮ってはいけません。（You must not take pictures here.） 嘘をついてはいけない。（You must not tell lies.） つもりだ：つもりだ is used to indicate a plan or intention to do something. 今夜は早く寝るつもりです。（I plan to sleep early tonight.） 週末に映画を見に行くつもりだ。（I plan to go watch a movie this weekend.） より〜方が〜：より〜方が〜 is used to compare two things, indicating that one thing is more than the other in some way. この本の方があの本より面白い。（This book is more interesting than that book.） 英語より日本語の方が難しいと思う。（I think Japanese is more difficult than English.） あまり〜ない：あまり〜ない is used to express that something is not very much or not very often. It\u0026rsquo;s typically used with negative verbs to indicate a low frequency or degree of something. 鶏肉はあまり好きじゃないです。（I don\u0026rsquo;t like chicken very much.） 私はあまり映画を見ない。（I don\u0026rsquo;t watch movies very often.） ２６−３０ Your browser does not support the audio element. SHOW NOTES ば：ば is used to indicate a conditional situation, meaning \u0026ldquo;if\u0026hellip;then.\u0026rdquo; For る-verbs, drop る and add れば; for う-verbs, change the last syllable to the corresponding え-column sound and add ば; For い-adjective, drop the い and add ければ; For noun or な-adjectives, add であれば. 雨が降れば、行きません。（If it rains, I won\u0026rsquo;t go.） もっと勉強すれば、合格するでしょう。（If you study more, you will probably pass.） ばあい（場合）は：ばあい（場合）は is used to describe a situation or condition, especially when considering what happens in certain circumstances. It\u0026rsquo;s similar to \u0026ldquo;in the event of\u0026rdquo; or \u0026ldquo;if\u0026rdquo; in English. 急な用事がある場合は、連絡してください。（In the event of an emergency, please contact me.） 天気が悪い場合は、外に出ない方がいいです。（If the weather is bad, it\u0026rsquo;s better not to go outside.） だけて：だけて is used to express that something is possible just by doing or simply by doing something. It emphasizes that the action alone is enough to achieve the result. このボタンを押（お）すだけで、機械が動（うご）きます。（Just by pressing this button, the machine will start.） 彼は笑（わら）うだけで、みんなを幸せにします。（Just by smilling, he makes everyone happy.） 出（だ）す：出（だ）す is used to indicate that something suddenly begins or appears. It can also be used for starting an action unexpectedly or without warning. 彼女は怒（おこ）り出した。（She suddenly got angry.） 彼は急に走り出した。（He suddenly started running.） でも：でも is used to give a suggestion in a casual way. It\u0026rsquo;s used to list examples when you\u0026rsquo;re not sure or to make a suggestion about a possible action. 映画でも見ませんか？（How about watching a movie or something?） コーヒーでも飲みましょうか？（Shall we drink coffee or something?） ３１−３５ Your browser does not support the audio element. SHOW NOTES でございます：でございます is a polite form of です. 私はサラリーマンでございます。（I am a salaryman.） こちらは私の友人でございます。（This is my friend.） がる：がる is used when talking about someone\u0026rsquo;s feelings, emotions, or desires. It is attached to the stem of an adjective to indicate that someone else appears to feel or shows signs of that emotion. 彼は怖がっているようです。（He seems to be scared.） 子供はおもちゃを欲しがっている。（The child seems to want a toy.） がする：がする is used when perceiving something through five senses (taste, smell, hearing, etc.). 何かの音がする。（I hear some sound.） このスープは苦い味がする。（This soup tastes bitter.） 始める：始める is used to express the beginning of an action. 明日からダイエットを始める予定です。（I plan to start dieting from tomorrow.） 生け花（いけばな）を習（なら）い始めて、もう半年経った。（It\u0026rsquo;s been half a year since I started learning flower arrangement.） はず（筈）がない：はず（筈）がない is used to express that something is impossible or cannot possibly be the case. そんな難しい問題は小学生ができるはずがない。（There\u0026rsquo;s no way an elementary school student can answer such a difficult question.） 彼女はそんなことをするはずがない。（There\u0026rsquo;s no way she would do such a thing.） ３６−４０ Your browser does not support the audio element. SHOW NOTES 必要：必要 means \u0026ldquo;necessary\u0026rdquo; or \u0026ldquo;need\u0026rdquo;. It\u0026rsquo;s used to describe something that is required or essential. この手続（てつづ）きは必要です。（This procedure is necessary.） あなたには助（たす）けが必要です。（You need help.） 必要がある：必要がある means \u0026ldquo;it is necessary to\u0026rdquo; or \u0026ldquo;there is a need to\u0026rdquo;. It\u0026rsquo;s used when talking about something that is required or essential. 彼と話す必要がありますか？（Is it necessary to talk to him?） 報告書を提出する必要がある。（It is necessary to submit the report.） いらっしゃる：いらっしゃる is a polite version of the verbs いる, 来る, and 行く. It is a polite way to express the idea of someone else\u0026rsquo;s presence, arrival, and departure. 先生がいらっしゃいました。（The teacher has arrived.） 今日は何時にいらっしゃいますか？（What time will you come today?） いたす：いたす is a polite version of する, and it\u0026rsquo;s often used in customer service, business, and formal speech. この仕事は私がいたします。（I\u0026rsquo;ll do this job.） 荷物は私が来週の月曜日にお届（とど）けいたします。（I\u0026rsquo;ll send the luggages next Monday.） かどうか：かどうか is used to express \u0026ldquo;whether or not\u0026rdquo; something happens or is the case. It\u0026rsquo;s used when someone unsures about something and want to ask about or talk about the uncertainty. 彼が来るかどうか分からない。（I don\u0026rsquo;t know whether or not he will come.） それが本当かどうか教えてください。（Please tell me whether or not that is true.） ４１−４５ Your browser does not support the audio element. SHOW NOTES かい：かい is a casual way of turning a sentence into a yes/no question. It\u0026rsquo;s commonly used in informal scenarios. 君はこの仕事を好きかい？（Do you like this job?） 心配事（しんぱいごと）があるのかい？（Anything worrying you?） かもしれない：かもしれない is used to express possibility or uncertainty. 雨が降るかもしれない。（It might rain.） これは難しいかもしれません。（This might be difficult.） 方：方 is used to indicate how to do something or to give directions on how to do something. It\u0026rsquo;s often used with verbs to explain the way of doing something. この料理の作り方を知りたい。（I want to know how to make this dish.） 彼はピアノの弾き方を教えています。（He is teaching how to play the piano.） かしら：かしら is a feminine and somewhat casual expression used to convey a sense of wondering or uncertainty. It\u0026rsquo;s often used when the speaker is unsure or curious about something. It is mainly used by women, but can also used in certain contexts by men in informal speech. 明日天気はどうかしら。（I wonder what the weather will be like tomorrow.） これで大丈夫かしら。（I wonder if this is okay.） ことができる：ことができる is used to express ability or possibility and means \u0026ldquo;can\u0026rdquo; or \u0026ldquo;be able to\u0026rdquo; in English. 日本語を話すことができる。（I can speak Japanese.） 明日早く起きることができない。（I can\u0026rsquo;t wake up early tomorrow.） ４６−５０ Your browser does not support the audio element. SHOW NOTES までに：までに is used to indicate a deadline or the latest time by which something must be done. 夜10時までに帰ります。（I will return home by 10 PM.） レポートを金曜日までに提出してください。（Please submit the report by Friday.） みたい：みたい is used to say that something looks like, seems like, or resembles something else. 彼は子供みたいです。（He\u0026rsquo;s like a child.） 雨が降るみたいよ。（It looks like it\u0026rsquo;s going to rain.） など is used to list examples or suggest that there are other similar things not explicitly mentioned. It means \u0026ldquo;such as,\u0026rdquo; \u0026ldquo;things like,\u0026rdquo; or \u0026ldquo;etc.\u0026rdquo; 寿司やラーメンなど好きです。（I like sushi, ramen and things like that.） 果物はリンゴやバナナなど好きです。（I like fruits such as apple and banana.） ながら：ながら is used to indicate two actions happening at the same time. 音楽を聞きながら勉強します。（I study while listening to music.） 彼はテレビを見ながらご飯を食べている。（He is eating while watching TV.） ないで：ないで is used to indicate doing something without another action happening. 宿題をしないで寝ました。（I went to sleep without doing my homework.） 傘を持たないで出かけた。（I went out without bringing an umbrella.） ５１−５５ Your browser does not support the audio element. SHOW NOTES なければいけない/なければならない：なければいけない/なければならない are used to express that something is necessary or that someone must do something. 早く起きなければいけない。（I must wake up early.） 宿題を終わらせなければならない。（I have to finish my homework.） なくてはいけない/なくてはならない：なくてはいけない/なくてはならない are used to express that something is necessary or that someone must do something. このレポートを提出しなくてはいけない。（I must submit this report.） パソコンを修理しなくてはならない。（I have to fix the computer.） なくてもいい：なくてもいい is used to express that something is not necessary or that someone doesn\u0026rsquo;t have to do something. 遅くまで勉強しなくてもいい。（You don\u0026rsquo;t have to study until late.） 今日は仕事に行かなくてもいい。（You don\u0026rsquo;t have to go to work today.） なら：なら is used to express conditional situations, similar to \u0026ldquo;if\u0026rdquo; in English. It can also imply a situation where something will happen or be true under certain conditions. 行くなら、早く行った方がいいよ。（If you are going, you should go early.） その話なら、知っている。（As for that story, I know it.） なさい：なさい is a polite imperative used to give an order or instruction. It is often used by adults when giving commands to chindren or subordinates. 早く寝なさい。（Go to bed early.） 野菜も食べなさい。（Eat your vegetables too!） ５６−６０ Your browser does not support the audio element. SHOW NOTES なさる：なさる is the polite version of する. お飲み物は何になさいますか？（What would you like to drink?） 先生は何をお話しなさっていますか？（What is the teacher talking about?） に気がつく：に気がつく means \u0026ldquo;to notice\u0026rdquo; pr \u0026ldquo;to realize\u0026rdquo; something. It is used when someone becomes aware of something that they hadn\u0026rsquo;t noticed before. 彼のミスに気がついた。（I noticed his mistake.） 日本に来てから、自分の日本語が上達していることに気がついた。（After coming to Japan, I realized that my Japanese was improving.） にくい：にくい indicates that something is difficult to do. この漢字は覚えにくい。（This kanji is hard to remember.） 彼の話し方は聞きにくい。（His way of speaking is hard to understand.） に見える：に見える is used to describe how something appears or looks like based on its appearance. 彼は若く見える。（He looks young.） この料理は美味しく見えるけど、あまり美味しくない。（This dish looks delicious, but it\u0026rsquo;s not very tasty.） の中で：の中で is used to indicate something inside a place. この三つの中で、どれが一番好きですか？（Among these three, which do you like the most?） クラスの中で、彼が一番背が高い。（Among the class, he is the tallest.） ６１−６５ Your browser does not support the audio element. SHOW NOTES のに：のに is used to indicate a reason or purpose, similar to \u0026ldquo;for the purpose of\u0026rdquo; in English. 旅行に行くのにお金がかかる。（It costs money to go on a trip.） 日本語を話すのに練習が必要です。（You need to practice to speak Japanese.） のように/のような：のように/のような are used to compare something to another thing, meaning \u0026ldquo;like\u0026rdquo; or \u0026ldquo;similar to\u0026rdquo;.　のように is used with verbs or adjectives while のような is used with nouns. 彼女は天使のように優しい。（She is as kind as an angel.） あなたのような人は珍しい。（A person like you is rare.） おきに：おきに is used to express repetition of an event at regular intervals, such as \u0026ldquo;every\u0026rdquo; in English. ２時間おきに休憩を取る。（Take a break every two hours.） 一週間おきに会議を開きます。（We hold meetings every week.） のに：のに is used to express contradiction or contrast. It means \u0026ldquo;although\u0026rdquo; or \u0026ldquo;in spite of\u0026rdquo;, often leading to an outcome that is unexpected or goes against the initial expectation. 彼は日本に住んでいるのに、全然日本語が話せない。（Although he lives in Japan, he can\u0026rsquo;t speak Japanese at all.） あんなに勉強するしたのに、テストに合格しなかった。（Even though I studied so much, I didn\u0026rsquo;t pass the test.） 終わる：終わる means \u0026ldquo;to finish\u0026rdquo; or \u0026ldquo;to end\u0026rdquo;, used when something is completed or comes to an end. 授業が終わった。（The class ended.） 仕事が終わるのが楽しみだ。（I\u0026rsquo;m looking forward to finish work.） ６６−７０ Your browser does not support the audio element. SHOW NOTES られる：られる is used to express the ability to do something. 日本語が話せられますか？（Can you speak Japanese?） ピアノが弾ける。（I can play the piano.） らしい：らしい is used to express a sense of hearsay or something that seems like or appears to be based on indirect information or impression. あの人はとても優しいらしい。（That person seems to be very kind.） 彼女は旅行に行くらしいです。（I heard that she\u0026rsquo;s going on a trip.） さ：さ is a nominalizer used to turn an adjective into a noun. It converts the quality or state expressed by the adjective into a concept or thing. 富士山の高さは３７７６メートルだ。（Mount Fuji\u0026rsquo;s height is 3776 meters.） 彼女の優しさに感動した。（I was moved by her kindness.） られる：られる can also be used to express the passive voice, meaning that the subject of the sentence is the receipient of an action rather than the one performing it. 私は先生に褒められた。（I was praised by the teacher.） この本は多くの人に読まれている。（This book is being read by many people.） させる：させる is the causative form, meaning \u0026ldquo;to make\u0026rdquo; someone do something. It expresses the idea of forcing or allowing someone to perform an action. 母は私に掃除させる。（My mother makes me do the cleaning.） 先生は学生に宿題をさせる。（The teacher makes the students do homework.） ７１−７５ Your browser does not support the audio element. SHOW NOTES させられる：させられる is the passive causative form, meaning \u0026ldquo;to be made to do something\u0026rdquo; or \u0026ldquo;to be forced to do something\u0026rdquo;. It is used to express that someone is forced or made to perform an action by someone else. 毎日残業させられる。（I\u0026rsquo;m made to work overtime every day.） 子供の時、嫌いな野菜を食べさせられだ。（As a child, I was made to eat vegetables I hated.） さすが：さすが is used to express admiration or to indicate that something or someone is worthy of praise or recognition, just as expected. It\u0026rsquo;s used when the result or behavior is exactly what one would expect from the person or thing in question. さすがプロだね。（As expected of a professional!） さすが日本の料理は美味しい。（As expected, Japanese food is delicious.） しか〜ない：しか〜ない means \u0026ldquo;only\u0026rdquo; or \u0026ldquo;nothing but\u0026rdquo;. It is used to emphasize a limitation or a small quantity of something. １００円しか持っていない。（I only have 100 yen.） この店にはケーキしかない。（This shop only has cake.） し〜し：し〜し is used to like multiple reasons or actions, similar to \u0026ldquo;and\u0026rdquo; in English. 彼女は親切だし、頭もいいし、頼りにしている。（She\u0026rsquo;s kind, smart, and I rely on her.） この映画は面白い、感動的だし、みんなにおすすめだ。（This movie is interesting, emotional, and I recommend it to everyone.） そんなに：そんなに is used to refer to something that is \u0026ldquo;like that\u0026rdquo; or \u0026ldquo;so much\u0026rdquo;. It can be used to indicate a large extent or degree of something, usually negative in tone. そんなに急がなくてもいいよ。（You don\u0026rsquo;t need to hurry so much.） そんなにたくさん食べるの？（Are you going to eat that much?） ７６−８０ Your browser does not support the audio element. SHOW NOTES それでも：それでも is used to express a contradiction or unexpected continuation of an action or situation despite the circumstances. It means \u0026ldquo;but still\u0026rdquo; or \u0026ldquo;and yet\u0026rdquo; in English. 雨が降っている。それでも、彼は外に出た。（It\u0026rsquo;s raining, but still, he went outside.） お金が足りない。それでも、旅行に行きたい。（I don\u0026rsquo;t have enough money. And yet, I want to go on a trip.） そうだ：そうだ is used to report hearsay or something heard from others. It can be used to confirm something that have been seen or heard. It\u0026rsquo;s similar to saying \u0026ldquo;I heard that\u0026rdquo; or \u0026ldquo;It seems that\u0026rdquo; in English. 明日は雨が降るそうだ。（I heard that it will rain tomorrow.） あの店のケーキは美味しいそうだ。（I heard that the cake at that shop is delicious.） たばかり：たばかり is used to indicate that something just happened or was just completed. It\u0026rsquo;s used to describe a recent action. 彼は家に帰ったばかりだ。（He just got home.） 私は昼ご飯を食べたばかりだ。（I just ate lunch.） たがる：たがる is used to express that someone else wants to do something. It\u0026rsquo;s often used when talking about other people\u0026rsquo;s desires. 彼は映画に行きたがっている。（He wants to go to the movie.） 彼女は新しい服を買いたがっている。（She wants to buy new clothes.） たら：たら is a conditional form that means \u0026ldquo;if\u0026rdquo; or \u0026ldquo;when\u0026rdquo;. It is used to express a condition or hypothetical situation. It can also mean \u0026ldquo;after doing\u0026rdquo; when the action is completed. もしお金があったら、旅行に行きたい。（If I had money, I would want to go on a trip.） 終わったら、帰ってもいいですか。（Can I go home after I finish?） ８１−８５ Your browser does not support the audio element. SHOW NOTES たらどうですか：たらどうですか is used to give a suggestion or advice to someone. It means \u0026ldquo;Why don\u0026rsquo;t you\u0026hellip;?\u0026rdquo; or \u0026ldquo;How about\u0026hellip;?\u0026rdquo; in English. It is a way to encourage someone to take a certain action. もっと休んだらどうですか。（Why don\u0026rsquo;t you rest more?） それを試してみたらどうですか。（Why don\u0026rsquo;t you try that?） たり〜たり：たり〜たり is used to list multiple actions or states, indicating that the speaker is talking about things that happen intermittently or alternately. 週末は映画を見たり、友達と遊んだりします。（On weekends, I watch movies and hang out with friends.） 夏休みには海に行ったり、山に登ったりしました。（During summer vacation, I went to the beach and climbed mountains.） たところ：たところ is used to indicate that something has just happened or just finished. It often emphasizes that the action was completed recently. 今昼ごはんを食べたところです。（I just finished eating lunch.） 彼はテストを終えたところです。（He just finished the test.） てあげる：てあげる is used when doing something for someone else, often to be helpful or show kindness. It\u0026rsquo;s used in situations where the speaker is performing an action for the benefit of someone else. 彼に本を貸してあげる。（I\u0026rsquo;ll lend him a book.） 私はあなたにその問題を説明してあげます。（I\u0026rsquo;ll explain the problem to you.） てほしい：てほしい is used to express that you want or need someone to do something. It shows a desire for someone to perform an action, often related to the speaker\u0026rsquo;s own wishes. 私に手伝ってほしい。（I want you to help me.） 彼女には元気になってほしい。（I want her to get better.） ８６−９０ Your browser does not support the audio element. SHOW NOTES ていく：ていく is used when an action begins now and continues into the future, or when something moves away from the speaker\u0026rsquo;s point of view. これからも日本語を勉強していきます。（From now on, I will keep studying Japanese.） 子供達は走って行った。（The children ran off.） ているところ：ているところ is used to describe that someone is right in the middle of doing something. 今昼ごはんを食べているところです。（I\u0026rsquo;m in the middle of eating lunch right now.） レポートを書いているところだった。（I was just writing the report.） ていただけませんか：ていただけませんか is a polite way to make a request, similar to \u0026ldquo;Could you please\u0026hellip;?\u0026rdquo; in English. これを見ていただけませんか。（Could you please look at this?） もう一度説明していただけませんか。（Could you please explain that one more time?） てくれる：てくれる is used when someone does something beneficial for the speaker. 母がセーターを編んでくれました。（My mother knitted me a sweater.） 友達が空港まで送ってくれた。（My friend drove me to the airport.） てくる：てくる is used to describe an action coming toward the speaker, a change or development over time, or an action/state that has continued up until the present. わかってきました。（It\u0026rsquo;s becoming clear.） 最近寒くなってきましたね。（It\u0026rsquo;s been getting colder lately.） ９１−９５ Your browser does not support the audio element. SHOW NOTES てみる：てみる is used to express trying out or attempting an action to see how it works, often implying the result is uncertain or the action is experimental. 新しいレストランに行ってみる。（I\u0026rsquo;ll try going to the new restaurant.） この方法を試してみてください。（Please try this method.） てもらう：てもらう is used when someone does something for the speaker, often implying a favor or request. The focus is on receiving the action done by someone else. 先生に教えてもらった。（I got the teacher to teach me.） 友達に手伝ってもらいました。（I got my friend to help me.） ておく：ておく is used to indicate that an action will be done in preparation for something, or to indicate that an action is done in advance to be ready for a future situation. 明日の会議のために資料を作っておきます。（I will prepare the materials in advance for tomorrow\u0026rsquo;s meeting.） 出かける前にお金を置いておく。（I\u0026rsquo;ll leave the money here before going out.） てしまう：てしまう is used when doing something unintentionally or finishing an action completely. 宿題を忘れてしまった。（I accidentally forgot my homework.） 本を全部読んでしまった。（I finished reading the whole book.） てよかった：てよかった is used to express relief, happiness, or gratitude for something that has already happened. It reflects a positive outcome or a favorable result. 傘を持ってきてよかった。（I\u0026rsquo;m glad I brought an umbrella.） あなたに会えてよかった。（I\u0026rsquo;m glad I could meet you.） ９６−１００ Your browser does not support the audio element. SHOW NOTES ということ：ということ is used to turn a statement or action into a noun, often referring to the content of the sentence. 彼が来ないということを聞きました。（I heard that he won\u0026rsquo;t come.） 日本に行くということはとても楽しみです。（The fact that I will go to Japan is very exciting.） といってもいい：といってもいい is used to suggest that something is valid or acceptable way to express something. これは簡単だといってもいいです。（You could say this is easy.） 彼はプロフェッショナルだといってもいいでしょう。（You might say he is a professional.） とか〜とか：とか〜とか is used to list examples of things, usually with the implication that there are more examples not explicitly mentioned. It can be translated as \u0026ldquo;such as\u0026rdquo; or \u0026ldquo;among other things.\u0026rdquo; 映画とか音楽とかが好きです。（I like things such as movies and music.） 休日は映画を見るとか、買い物するとかしています。（On holidays I do things like watching movies and shopping.） ときいた：ときいた is used to report something that was heard from another person, typically in casual or indirect speech. This expression can be used when sharing information learned from someone else. 彼がもうすぐ帰ると聞いた。（I heard that he is going home soon.） 明日雨が降ると聞いたんですが、本当ですか。（I heard it will rain tomorrow, is that true?） ところ：ところ is used to express that something is about to happen, indicating that an action is just about to start or is on the verge of happening. It can also be used in the past tense to show that something was just about to happen at a certain moment. 食事を始めるところです。（We\u0026rsquo;re about to start eating.） テレビを見ているところに電話がかかってきた。（Just when I was watching TV, the phone rang.） １０１ SHOW NOTES In Japanese, verbs are categorized into three groups based on their conjugation patterns. Group 1(五段動詞, ごだんどうし) verbs end in a u sound, such as 書く (to write) and 話す (to speak). Group 2 (一段動詞, いちだんどうし) verbs end in \u0026ldquo;ru\u0026rdquo; and the preceding vowel is either from the i or e row, such as 食べる (to eat) and 見る (to see). Group 3 (不規則動詞, ふきそくどうし) consists of irregular verbs, including する (to do) and 来る (to come). To form the ます-form of Japanese verbs, the conjugation rules differ depending on the verb group. For Group 1(五段動詞, ごだんどうし) verbs, the final u sound is replaced with the corresponding i sound followed by ます. For example, 書く (to write) becomes 書きます (to write, polite). For Group 2 (一段動詞, いちだんどうし) verbs, which end in ru, simply drop the ru and add ます. For example, 食べる (to eat) becomes 食べます (to eat, polite). For Group 3 (不規則動詞, ふきそくどうし) irregular verbs, する (to do) becomes します (to do, polite), and 来る (to come) becomes 来ます (to come, polite). To form the て-form of Japanese verbs, the conjunction rules differ depend on the verb group. For Group 1(五段動詞, ごだんどうし) verbs, the final sound of the verb is replaced with a specific pattern: verbs ending in く become いて (e.g., 書く → 書いて, an exception for 行く『行って』), ぐ becomes いで (e.g., 泳ぐ → 泳いで), and verbs ending in う, つ, or る become って (e.g., 買う → 買って, 待つ → 待って, 帰る → 帰って). For verbs ending in ぬ, ぶ, or む, the final sound changes to んで (e.g., 死ぬ → 死んで, 遊ぶ → 遊んで, 読む → 読んで). For Group 2 (一段動詞, いちだんどうし) verbs, which end in ru, the ru is dropped and replaced with て. For example, 食べる (to eat) becomes 食べて (eating). For Group 3 (不規則動詞, ふきそくどうし) irregular verbs, する (to do) becomes して (doing), and 来る (to come) becomes 来て (coming). To form the た-form of Japanese verbs, the conjunction rules differ depend on the verb group. For Group 1(五段動詞, ごだんどうし) verbs, the final sound of the verb is replaced with a specific pattern: verbs ending in く become いた (e.g., 書く → 書いた), ぐ becomes いだ (e.g., 泳ぐ → 泳いだ), and verbs ending in う, つ, or る become った (e.g., 買う → 買った, 待つ → 待った, 帰る → 帰った). For verbs ending in ぬ, ぶ, or む, the final sound changes to んだ (e.g., 死ぬ → 死んだ, 遊ぶ → 遊んだ, 読む → 読んだ). For Group 2 (一段動詞, いちだんどうし) verbs, the \u0026ldquo;ru\u0026rdquo; ending is dropped, and ta is added directly. For example, 食べる (to eat) becomes 食べた (ate) and 見る (to see) becomes 見た (saw). For Group 3 (不規則動詞, ふきそくどうし) irregular verbs, する (to do) becomes した (did), and 来る (to come) becomes 来た (came). To form the ない-form of Japanese verbs, the conjugation rules vary depending on the verb group. For Group 1(五段動詞, ごだんどうし) verbs, the final u sound is replaced with the corresponding a sound, followed by ない. For example, 書く (kaku) becomes 書かない (to not write). An exception is the verb ある (to exist, for inanimate objects), which becomes ない (does not exist). For Group 2 (一段動詞, いちだんどうし) verbs, the ru is droupped and ない is added directly, such as 食べる (to eat) becomeing 食べない (to not eat). For Group 3 (不規則動詞, ふきそくどうし) irregular verbs, する (to do) becomes しない (to not do), and　来る (to come) becomes 来ない (to not come). To form the potential form of Japanese verbs, the conjugation rules differ by verb group. For Group 1(五段動詞, ごだんどうし) verbs, the final u sound is replaced with the corresponding e sound, followed by る. For example, 書く (to write) becomes 書ける (can write). For Group 2 (一段動詞, いちだんどうし) verbs, the ru is dropped and られる is added, such as 食べる (to eat) becoming 食べられる (can eat). For Group 3 (不規則動詞, ふきそくどうし) irregular verbs, する (to do) becomes できる (can do), and 来る (to come) becomes 来られる (can come). To form the imperative form of Japanese verbs, the conjugation rules vary depending on the verb group. For Group 1(五段動詞, ごだんどうし) verbs, the final u sound is replaced with the corresponding e sound. For example, 書く (to write) becomes 書け (write!). For Group 2 (一段動詞, いちだんどうし) verbs, the ru is dropped and ろ and よ is added, such as 食べる (to eat) becoming 食べろ (eat!). For Group 3 (不規則動詞, ふきそくどうし) irregular verbs, する (to do)　becomes しろ or せよ (do!), and 来る (to come) becomes 来い (come!) To form the volitional form (intended action or suggestion) of Japanese verbs, the conjugation rules depend on the verb group. For Group 1(五段動詞, ごだんどうし) verbs, the final u sound is replaced with the corresponding o sound, followed by う. For example, 書く (to write) becomes 書こう (let\u0026rsquo;s write). For Group 2 (一段動詞, いちだんどうし) verbs, the ru is dropped and よう is added, such as 食べる　(to eat) becoming 食べよう (let\u0026rsquo;s eat). For Group 3 (不規則動詞, ふきそくどうし) irregular verbs, する (to do) becomes しよう (let\u0026rsquo;s do), and 来る (to come) becomes こよう (let\u0026rsquo;s come). Here are the top 30 most commonly used verbs:\nVerb (Infinitive) Polite Form (ます) Te-Form Past Tense (た) Negative (ない) Potential (できる) Imperative (Command) Volitional (Intentional) 行く (いく, to go) 行きます 行って 行った 行かない 行ける 行け 行こう 話す (はなす, to speak) 話します 話して 話した 話さない 話せる 話せ 話そう 聞く (きく, to listen) 聞きます 聞いて 聞いた 聞かない 聞ける 聞け 聞こう 書く (かく, to write) 書きます 書いて 書いた 書かない 書ける 書け 書こう 読む (よむ, to read) 読みます 読んで 読んだ 読まない 読める 読め 読もう 飲む (のむ, to drink) 飲みます 飲んで 飲んだ 飲まない 飲める 飲め 飲もう 買う (かう, to buy) 買います 買って 買った 買わない 買える 買え 買おう 会う (あう, to meet) 会います 会って 会った 会わない 会える 会え 会おう 待つ (まつ, to wait) 待ちます 待って 待った 待たない 待てる 待て 待とう 立つ (たつ, to stand) 立ちます 立って 立った 立たない 立てる 立て 立とう 遊ぶ (あそぶ, to play) 遊びます 遊んで 遊んだ 遊ばない 遊べる 遊べ 遊ぼう 帰る (かえる, to return) 帰ります 帰って 帰った 帰らない 帰れる 帰れ 帰ろう 死ぬ (しぬ, to die) 死にます 死んで 死んだ 死なない 死ねる 死ね 死のう 飛ぶ (とぶ, to fly) 飛びます 飛んで 飛んだ 飛ばない 飛べる 飛べ 飛ぼう 呼ぶ (よぶ, to call) 呼びます 呼んで 呼んだ 呼ばない 呼べる 呼べ 呼ぼう 泳ぐ (およぐ, to swim) 泳ぎます 泳いで 泳いだ 泳がない 泳げる 泳げ 泳ごう 急ぐ (いそぐ, to hurry) 急ぎます 急いで 急いだ 急がない 急げる 急げ 急ごう 笑う (わらう, to laugh) 笑います 笑って 笑った 笑わない 笑える 笑え 笑おう 洗う (あらう, to wash) 洗います 洗って 洗った 洗わない 洗える 洗え 洗おう 歌う (うたう, to sing) 歌います 歌って 歌った 歌わない 歌える 歌え 歌おう 食べる (たべる, to eat) 食べます 食べて 食べた 食べない 食べられる 食べろ/食べよ 食べよう 見る (みる, to see/look) 見ます 見て 見た 見ない 見られる 見ろ/見よ 見よう 寝る (ねる, to sleep) 寝ます 寝て 寝た 寝ない 寝られる 寝ろ/寝よ 寝よう 起きる (おきる, to wake up) 起きます 起きて 起きた 起きない 起きられる 起きろ/起きよ 起きよう 教える (おしえる, to teach) 教えます 教えて 教えた 教えない 教えられる 教えろ/教えよ 教えよう 出る (でる, to go out) 出ます 出て 出た 出ない 出られる 出ろ/出よ 出よう 着る (きる, to wear) 着ます 着て 着た 着ない 着られる 着ろ/着よ 着よう 借りる (かりる, to borrow) 借ります 借りて 借りた 借りない 借りられる 借りろ/借りよ 借りよう 降りる (おりる, to get off) 降ります 降りて 降りた 降りない 降りられる 降りろ/降りよ 降りよう 閉める (しめる, to close) 閉めます 閉めて 閉めた 閉めない 閉められる 閉めろ/閉めよ 閉めよう Your browser does not support the audio element. SHOW CONTENTS 彼は毎日、学校に行く。（He goes to school every day.） 明日、私は京都に行きます。（Tomorrow, I will go to Kyoto.） この道をまっすぐ行って、右に曲がってください。（Go straight on this road, then turn right.） 彼女は日本語で話すことができる。（She can speak Japanese.） 会議で詳しく話します。（I will talk in detail at the meeting.） 何か問題があれば、すぐに話して下さい。（If you have any problems, please speak up immediately.） 毎日、日記を書く。（I write in my diary every day.） このレポートを明日までに書きます。（I will write this report by tomorrow.） ノートに名前を書いてください。（Please write your name in the notebook.） 彼は海で泳ぐのが好きだ。（He likes to swim in the sea.） 夏休みに海で泳ぎます。（I will swim in the sea during summer vacation.） プールで泳いでから、シャワーを浴びます。（After swimming in the pool, I will take a shower.） 週末に新しい本を買う予定だ。（I plan to buy a new book this weekend.） 昨日、オンラインで服を買いました。（I bought clothes online yesterday.） スーパーで牛乳を買ってきてください。（Please buy some milk at the supermarket.） 彼を駅で待つつもりだ。（I intend to wait for him at the station.） ここで少し待ちます。（I will wait here for a while.） ちょっと待っていてください。（Please wait a moment.） 学校が終わったら、家に帰る。（After school is over, I will go home.） もうすぐ仕事が終わるので、家に帰ります。（Work is almost over, so I will go home.） 友達の家に行って、すぐに帰ってきた。（I went to my friend\u0026rsquo;s house and came back right away.） 毎朝、新聞を読むことにしている。（I make it a habit to read the newspaper every morning.） 彼女はよく小説を読みます。（She often reads novels.） 本を読んでから、映画を見に行こう。（Let\u0026rsquo;s read a book, then go watch a movie.） あなたをケパと呼ぶことにします。（I will call you \u0026lsquo;Kepa.\u0026rsquo;） 私は先生を呼びます。（I will call the teacher.） その名前を呼んでください。（Please call that name.） あの小さな花は死ぬかもしれない。（That small flower might die.） 老犬が静かに死にました。（The old dog passed away peacefully.） 彼は戦争で死んでしまった。（He died in the war.） 彼は部屋を出るとき、ドアを閉めました。（He closed the door when he left the room.） 彼女は駅で電車を出ます。（She will take the train at the station.） ちょっと出てくるから、待っていて。（I\u0026rsquo;ll step out for a moment, so please wait.） 新しいシャツを着ると気分が良くなる。（I feel good when I wear a new shirt.） 今日、きれいなドレスを着ます。（I will wear a beautiful dress today.） そのドレスを着て、パーティーに行きます。（I will wear that dress and go to the party.） １０６−１１０ Your browser does not support the audio element. SHOW CONTENTS と見える: と見える is used to indicate that something appears to be a certain way based on what the speaker perceives. It is similar to saying \u0026ldquo;it seems\u0026rdquo; or \u0026ldquo;it looks like\u0026rdquo; in English. 彼は疲れていると見える。（He appears to be tired.） この料理は美味しいと見える。（This dish seems to be delicious.） 続ける: 続ける is used to express the act of continuing an action, or to keep doing something without stopping. 雨が降り続けている。（The rain continues to fall.） 走り続けるのは大変だ。（It’s difficult to continue running.） やすい: やすい is used to describe something that is easy to do or likely to happen. It can also express something that has a tendency to occur. この本は読みやすい。（This book is easy to read.） 冬は風邪を引きやすい。（It\u0026rsquo;s easy to catch colds in winter.） 予定だ: 予定だ is used to indicate a plan or schedule for the future. It can also show that something is expected to happen. 明日会議がある予定だ。（There is a meeting scheduled for tomorrow.） 私は午後に出かける予定です。（I plan to go out in the afternoon.） ようになる: ようになる describes a change of state or a process that leads to something becoming possible or feasible. It often implies that something was difficult or impossible at first, but now it has beome possible. 日本語が話せるようになった。（I can now speak Japanese.） 車を運転できるようになりたい。（I want to be able to drive a car.） １１１−１１５ Your browser does not support the audio element. SHOW CONTENTS ようにする: ようにする is used to indicate that someone tries to do something or makes an effort to achieve a certain goal. It emphasizes the intention or effort involved. 毎日運動するようにしています。（I try to exercise every day.） 夜（よ）更（ふ）かししないようにしてください。（Please try not to stay up late.） ば〜ほど: ば〜ほど is used to show that as one thing increases, the other thing also increases. It\u0026rsquo;s often used for comparisons where one action or state leads to a proportional change in another. 勉強すればするほど上手になります。（The more you study, the better you become.） 値段が高ければ高いほど品（ひん）質（しつ）がいい。（The higher the price, the better the quality.） ばいい: ばいい is used to give advice or suggest that something would be good, appropriate or advisable. It implies a suggestion for what someone should do. どうすればいいですか？（What should I do?） この問題を解（かい）決（けつ）すればいいですね。（It would be good if we solve this problem.） ばかり: ばかり is used to express that something is just happening or that only a particular thing is being done, often with a nuance of repetition or focus on a single activity. It can also indicate that something has recently happened. 彼は食べてばかりです。（He’s just eating all the time.） 彼はゲームばかりしている。（He does nothing but play games.） ばかりだ: ばかりだ expresses the idea that something is continuing or gradually increasing. It can also imply that the situation is getting worse or progressing in a certain direction. 問題は悪化（あっか）してばかりだ。（The problem is only getting worse.） 状（じょう）況（きょう）は悪（わる）くなるばかりだ。（The situation keeps getting worse.） １１６−１２０ Your browser does not support the audio element. SHOW CONTENTS ばかりでなく: ばかりでなく is used to indicate that something is not only true but also includes something else. 彼は日本語ばかりでなく、英語も話せます。（He can speak not only Japanese, but also English.） この店は安いばかりでなく、品（ひん）質（しつ）もいいです。（This shop is not only cheap, but also has good quality.） ばかりに: ばかりに indicates that something happened because of a certain reason, usually with a negative or unintended consequence. It\u0026rsquo;s similar to \u0026ldquo;because of\u0026rdquo; or \u0026ldquo;on account of\u0026rdquo; in English. 遅（ち）刻（こく）したばかりに、会議に参（さん）加（か）できなかった。（Because I was late, I couldn’t participate in the meeting.） お金が足（た）りないばかりに、旅行を諦（あきら）めた。（I gave up on the trip because I didn’t have enough money.） ばよかった: ばよかった expresses regret or something the speaker should have done in the past, but didn\u0026rsquo;t. It implies that it would have been better if the action had been taken. もっと勉強すればよかった。（I should have studied more.） 傘を持って行けばよかった。（I should have brought an umbrella.） べき: べき is used to express a recommendation or a strong suggestion that something should be done. It\u0026rsquo;s often used to express what is the right or proper thing to do. 約束は守（まも）るべきだ。（You should keep promises.） もっと早く知らせるべきだった。（I should have informed you earlier.） べきではない: べきではない is used to express prohibition or something that should not be done. 他人の秘密を漏（も）らすべきではない。（You must not reveal others\u0026rsquo; secrets.） こんな時間に電話するべきではなかった。（I shouldn\u0026rsquo;t have called at this hour.） １２１−１２５ Your browser does not support the audio element. SHOW CONTENTS 別に〜ない: 別に〜ない is used to express that something is not particularly the case or does not stand out. It is often used to downplay something or to indicate a lack of interest or emphasis. 別に興（きょう）味（み）ない。（I\u0026rsquo;m not particularly interested.） 別に困（こま）っていないよ。（I\u0026rsquo;m not really in trouble.） だらけ: だらけ is used to describe a situation where something is full of or covered in something, usually in a negative or excessive sense. この文（ぶん）章（しょう）は間（ま）違（ちが）いだらけだ。（This document is full of mistakes.） 彼の部屋は漫画だらけだ。（His room is full of comics.） どころか: どころか is used to indicate that something is far from what is expected, or anything but what was presumed. It often has a stronger contrast to the previous idea. お金がないどころか、借金がある。（I don’t just not have money, I have debt.） 彼女は忙しいどころか、余裕もある。（She is not just busy, she actually has some free time.） どんなに〜ても: どんなに〜ても is used to indicate that no matter how much or how difficult something is, the result is unaffected. It expresses no matter how something is done or how something turns out. どんなに努（ど）力（りょく）しても、結果（けっか）が出ない。（No matter how hard I try, I don’t see any results.） どんなに美味しくても、食べ過ぎは良くない。（No matter how delicious it is, eating too much is not good.） ふりをする: ふりをする is used when someone pretends to be something or act as if they are in a certain way. It indicates acting as if without truly being or doing it. 彼は知らないふりをしていた。（He was pretending not to know.） 泣（な）いていないふりをするのは難しい。（It’s hard to pretend you’re not crying.） １２６−１３０ Your browser does not support the audio element. SHOW CONTENTS がち: がち indicates that someone tends to or is prone to doing something, usually in a negative or unwanted sense. It implies a tendency to do something frequently or habitually. 彼は遅（ち）刻（こく）しがちだ。（He tends to be late.） 冬は風邪を引きがちになる。（People tend to catch colds in winter.） がたい: がたい indicates that something is difficult or hard to do, often because it’s emotionally or mentally challenging, not just physically. 彼の気持ちを理（り）解（かい）しがたい。（It’s hard to understand his feelings.） この問題は解（と）きがたい。（This problem is hard to solve.） 気味: 気味 is used to indicate something seems like or has a certain tendency or feeling about it. It’s often used when something appears to have a certain quality. 彼は疲れ気味だ。（He looks a bit tired.） 最近、体（たい）調（ちょう）が悪い気味だ。（I’ve been feeling a little unwell recently.） はず（筈）だ: はず（筈）だ expresses expectation or assumption. It is used when something is believed to be true based on reasoning or logic. It can be translated as \u0026ldquo;it must be\u0026rdquo; or \u0026ldquo;it should be.\u0026rdquo; 彼はもう到（とう）着（ちゃく）しているはずだ。（He should have already arrived.） この問題は簡単なはずだ。（This problem must be easy.） ほど: ほど is used to indicate a comparison or degree. It can imply the more something happens, the more something else will happen. 練習するほど上手になる。（The more you practice, the better you\u0026rsquo;ll get.） 努（ど）力（りょく）すればするほど、成（せい）功（こう）が近（ちか）づく。（The more you try, the closer success gets.） １３１−１３５ Your browser does not support the audio element. SHOW CONTENTS ほど: ほど is used to compare two things and say that one is not as much as the other. It emphasizes that something does not reach or is not equal to the extent or degree of the other. 彼ほど優しくない人はいない。（There is no one as kind as him.） 彼女は思ったほど背が高くなかった。（She wasn\u0026rsquo;t as tall as I thought.） いくら〜ても: いくら〜ても is used to indicate no matter how much or however something is done, implying that the result or situation will remain the same regardless of the extent. いくら頑張っても、結果は変わらない。（No matter how hard I try, the result won’t change.） いくら説明しても理解してくれない。（No matter how much I explain, they don\u0026rsquo;t understand.） 一方だ: 一方だ is used to describe a situation where something is continuing or becoming more and more in a certain direction. It often conveys that the situation is steadily increasing or changing. 物価は上がる一方だ。（The prices continue to rise.） 彼の態度は悪くなる一方だ。（His attitude is getting worse and worse.） 一方で: 一方で is used to present two contrasting ideas or to show that there are two sides to a situation, like \u0026ldquo;on one hand\u0026rdquo; and \u0026ldquo;on the other hand\u0026rdquo;. この計画には賛成する人が多い一方で、反対する人もいる。（On one hand, there are many people who support this plan, but on the other hand, there are also those who oppose it.） 日本は便利な国である一方で、物価が高い。（On one hand, Japan is a convenient country, but on the other hand, the cost of living is high.） かけ: かけ is used to indicate that something is half-done or not yet finished. It shows that an action or process is in progress or incomplete. 食べかけのパンを置いておいた。（I left the half-eaten bread.） 映画を見かけて、途中で寝てしまった。（I started watching the movie, but I fell asleep in the middle.） １３６−１４０ Your browser does not support the audio element. SHOW CONTENTS からいうと: からいうと is used to refer to a specific perspective or point of view. It shows the basis or reasoning from which something is being considered or judged. 経済の観点からいうと、この政策（せいさく）は良くない。（In terms of the economy, this policy is not good.） 彼の立（たち）場（ば）からいうと、それは仕（し）方（かた）がない。（From his point of view, that\u0026rsquo;s unavoidable.） 代わりに: 代わりに is used to indicate that one thing is being substituted for another or someone is doing something in place of someone else. 母の代わりに料理を作った。（I cooked instead of my mother.） 私はレポートを書く代わりに、プレゼンテーションをしました。（Instead of writing a report, I did a presentation.） っけ: っけ is used to ask for confirmation or to remind oneself of something forgotten. 明日は休みだっけ？（Is tomorrow a holiday?） この映画、いつ公（こう）開（かい）されたっけ？（When was this movie released?） 決して〜ない: 決して〜ない emphasizes a strong negation, meaning \u0026ldquo;never\u0026rdquo; or \u0026ldquo;by no means\u0026rdquo;. It is used when something want to strongly deny or refuse something. 決して諦めてはいけない。（You must never give up.） 決して嘘をついてはいけません。（You must never lie.） 切る: 切る express the idea of completing an action fully or doing it to the end. It emphasizes that the action was done thoroughly or with determination. 仕事をやり切る自信がある。（I\u0026rsquo;m confident I can completely finish the work.） その問題は解決し切った。（The problem has been completely solved.） １４１−１４５ Your browser does not support the audio element. SHOW CONTENTS 切れない: 切れない implies that something is too much to complete, or too difficult to finish. It emphasizes an inability to finish or complete something due to its magnitude or difficulty. この仕事は多すぎて、終わり切れない。（There is so much work that I can’t finish it.） この量の仕事は一日でやり切れない。（I can\u0026rsquo;t possibly finish this amount of work in one day.） きり: きり is used to indicate that something is only or just what is being stated, implying nothing more. It emphasizes a limited amount or the singularity of something. 100円きり持っていない。（I only have 100 yen.） 彼女とは去年会ったきりだ。（I haven\u0026rsquo;t seen her since last year.） こそ: こそ is used to emphasize the word or phrase it follows. It can often mean \u0026ldquo;for sure\u0026rdquo; or \u0026ldquo;precisely\u0026rdquo; to highlight the importance of the preceding item. It gives a sense of \u0026ldquo;only because\u0026rdquo; or \u0026ldquo;exactly because.\u0026rdquo; それこそが私が言いたいことだ。（That is precisely what I wanted to say.） あなたこそ、真実を知っている。（You are the one who knows the truth.） こと: こと can be used to express something that must be done or that it is important to do. It\u0026rsquo;s often used with a verb in its dictionary form and is commonly seen in instructions or advice. 日本語を勉強することが必要です。（It is necessary to study Japanese.） 早く帰ることを忘れないでください。（Please don’t forget to go home early.） ことだ: ことだ is used to give strong advice or a suggestion. It is used to indicate something that should be done or is recommended. It’s often used in suggestions or imperatives. 健康になりたければ、運動することだ。（If you want to be healthy, you should exercise.） 上手になりたければ、毎日練習することです。（If you want to get better, you should practice every day.） １４６−１５０ Your browser does not support the audio element. SHOW CONTENTS ことがある: ことがある is used to indicate that there are occasions or instances when something happens. It refers to the fact that something sometimes or occasionally occurs. 彼はたまに遅刻することがある。（There are times when he is late.） 時々、何もしたくないことがある。（There are times when I don\u0026rsquo;t feel like doing anything.） ことか: ことか is used to express exaggeration or strong emotion. It is often used to convey surprise, amazement, or frustration about something, meaning \u0026ldquo;how [adjective]!,\u0026rdquo; \u0026ldquo;what [adjective]!\u0026rdquo; or \u0026ldquo;how much [something]!\u0026rdquo; どれだけ疲れたことか！（How tired I am!） どんなに嬉しかったことか。（How happy I was!） ことから: ことから is used to explain or deduce something from a fact or based on the circumstances. It indicates the reason or cause behind an action or situation. 彼の顔を見ることから、彼が悲しんでいることがわかる。（From looking at his face, I can tell that he is sad.） この町は桜が多いことから、桜町と名（な）付（ず）けられた。（This town was named \u0026lsquo;Sakuramachi\u0026rsquo; from the fact that it has many cherry trees.） ことに: ことに is used to emphasize or specify a particular situation or action that is notable or remarkable. It’s often used in contexts where something is particularly important or especially noteworthy. 驚（おどろ）いたことに、彼は私の昔の友達だった。（To my surprise, he was my old friend.） 残念なことに、そのコンサートは中止になった。（Unfortunately, the concert was canceled.） ことになる: ことになる indicates that something has been decided or has come to be in the past or by some external force. It is often used when talking about a situation that has been finalized or determined, often without the speaker’s direct control. この会議は来週開（かい）催（さい）されることになった。（It has been decided that this meeting will be held next week.） この学校では制服を着ることになっている。（It\u0026rsquo;s the rule that students wear uniforms at this school.） １５１−１５５ Your browser does not support the audio element. SHOW CONTENTS ことにする: ことにする is used to indicate that a decision has been made about something. It implies a conscious choice or resolution to do something. 旅行に行くことにした。（I decided to go on a trip.） 今度の週末は家で過ごすことにします。（I’ve decided to spend this weekend at home.） ことはない: ことはない is used to indicate that there is no necessity, or there is no need to do something. It can also imply that something is not likely to happen. そんなに心配することはない。（There is no need to worry that much.） こんな事故は起こることはないと思っていた。（I thought such an accident would never happen.） くらい: くらい is used to show the extent of something, or to describe something that is so extreme or intense that it leads to a specific outcome. 彼は怒るくらいなら、黙（だま）っていたほうがいいよ。（If he’s going to get that angry, it would be better to stay silent.） この問題は簡単すぎて、誰でも解けるくらいだ。（This problem is so easy that anyone can solve it.） くせに: くせに is used to indicate that something happens despite the circumstances or expectation. It’s similar to saying \u0026ldquo;even though\u0026rdquo; or \u0026ldquo;although\u0026rdquo; in English, but it carries a slightly critical or sarcastic tone. 彼はお金がないくせに、高いレストランに行こうと言った。（Even though he has no money, he suggested going to an expensive restaurant.） あの人は英語ができるくせに、全然話さない。（Even though that person can speak English, they never talk.） まま: まま is used to indicate that something is left in its current state or condition, without change. It can imply that something remains unchanged or continues as is. テレビをつけたまま寝てしまった。（I fell asleep with the TV on.） 靴を履（は）いたままで部屋に入（はい）らないでください。（Please don’t enter the room with your shoes on.） １５６−１６０ Your browser does not support the audio element. SHOW CONTENTS まるで: まるで indicates that something appears or feels as though it is a certain way, often used in comparisons. 今日はまるで冬のようだ。（Today is just like winter.） 彼の話はまるで嘘のようだ。（His story sounds almost like a lie.） めったに〜ない: めったに〜ない express that something rarely happens or is uncommon. It suggests a low frequency of the action. 彼はめったに映画を見ない。（Movies are rarely watched.） 彼はめったに怒らない。（He hardly ever gets angry.） もの: When もの placed at the end of a sentence, it gives a reason or an explanation for something, similar to saying \u0026ldquo;because\u0026rdquo; or \u0026ldquo;it\u0026rsquo;s because\u0026rdquo;. It may also imply excuses or justifications. 遅れたのは、電車が遅れたものです。（The reason for being late is because the train was delayed.） 今日は行けないんだ。用事があるもの。（Can\u0026rsquo;t go today because of something to do.） ものだ: ものだ expresses habit or something that was typically done in the past, as well as what is natural or expected in a given situation. 子供のころ、よく公園で遊んだものだ。（In childhood, it was common to play in the park.） 先生の話はよく聞くものだ。（One should listen carefully to teachers.） もしかしたら: もしかしたら expresses possibility or uncertainty, used to suggest something is unlikely but still possible. もしかしたら明日は雪が降るかも。（Perhaps it might snow tomorrow.） もしかしたら彼はもう着いているかもしれない。（He might have already arrived.） １６１−１６５ Your browser does not support the audio element. SHOW CONTENTS 向き: 向き indicates that something is suitable, appropriate, or designed for a particular purpose, group, or person. このソファは小さな部屋向きです。（This sofa is suitable for small rooms.） このスニーカーはランニング向きではない。（These sneakers are not suitable for running.） 向け: 向け expresses that something is intended for, targeted at, or designed for a specific group, purpose, or use. It often focuses on a target audience or a specific use case. この車は家庭向けではない。（This car is not intended for family use.） これは外国人向けの日本語教材です。（This is Japanese language material for foreigners.） ながらも: ながらも is used to connect two contrasting clauses, meaning \u0026ldquo;despite\u0026rdquo;, \u0026ldquo;although\u0026rdquo;, or \u0026ldquo;even though\u0026rdquo;. It shows that one action or state exists despite the other. 初心者ながらも、彼はすぐに上達した。（Even though he was a beginner, he improved quickly.） 難しいながらも、この問題を解決した。（Although it was difficult, I solved the problem.） ないことはない: ないことはない is used to indicate that something is possible or can be done, though it may be difficult or unlikely. It expresses a negative possibility, meaning that it is not impossible to do something. 難しいが、できないことはない。（It is difficult, but not impossible.） お金があれば、行かないことはない。（If you have the money, there is no reason not to go.） なんか/なんて: なんか/なんて is used to refer to things like or such as, often in a casual or informal context. It can also be used to downplay or show disdain for something, implying that it’s not important or not worth considering. お寿司なんかが食べたい。（I want to eat something like sushi.） 私なんてまだまだです。（Someone like me still has a long way to go.） １６６−１７０ Your browser does not support the audio element. SHOW CONTENTS なぜなら: なぜなら is used to explain the reason behind something. It can be translated as \u0026ldquo;because\u0026rdquo; or \u0026ldquo;the reason is\u0026rdquo;. It is often used when giving an explanation or justification. 今日は学校を休んだ。なぜなら、風邪をひいているからだ。（I skipped school today. The reason is that I have a cold.） 彼は忙しい。なぜなら、仕事がたくさんあるからだ。（He is busy because he has a lot of work.） んだって: んだって is an informal expression that is used to report what one has heard or to express second-hand information. It is equivalent to saying \u0026ldquo;I hear that\u0026rdquo; or \u0026ldquo;I was told\u0026rdquo;. 彼は来ないんだって。（I hear that he’s not coming.） 彼女は引っ越すんだって。（I hear that she’s moving.） に違いない: に違いない is used to express certainty about something, translating as \u0026ldquo;I\u0026rsquo;m sure\u0026rdquo; or \u0026ldquo;there’s no doubt that\u0026rdquo;. It is used when the speaker is certain or believes strongly about something. あの店はおいしい料理を出すに違いない。（That restaurant must serve delicious food.） 彼女は試験に合格するに違いない。（There’s no doubt that she will pass the exam.） にかけて: にかけて refers to a period of time or something that continues throughout a duration. It can mean \u0026ldquo;over the course of\u0026rdquo; or \u0026ldquo;throughout\u0026rdquo;. It\u0026rsquo;s also used to indicate an area of expertise or focus. 一週間にかけて、全力で勉強した。（I studied with all my might over the course of a week.） 今月にかけて暑い日が続くでしょう。（The hot weather will likely continue through this month.） に関する: に関する means \u0026ldquo;related to\u0026rdquo;, \u0026ldquo;concerning\u0026rdquo;, or \u0026ldquo;about\u0026rdquo;. It is often used in formal contexts to indicate the subject or topic of a discussion, study, or work. 彼は経済に関する専門家だ。（He is an expert in economics.） 環境問題に関する研究が進んでいる。（Research related to environmental issues is progressing.） １７１−１７５ Your browser does not support the audio element. SHOW CONTENTS にかわって: にかわって is used when talking about doing something on behalf of someone else or instead of someone. It can be translated as \u0026ldquo;on behalf of\u0026rdquo; or \u0026ldquo;instead of\u0026rdquo;. 社長にかわって、私が挨（あい）拶（さつ）をさせていただきます。（On behalf of the president, I will give the greeting.） 母にかわって、弟がその仕事を手伝った。（Instead of my mother, my younger brother helped with the work.） に比べて: に比べて is used to compare two things, often to indicate how one thing is different from or superior/inferior to another. It translates as \u0026ldquo;compared to\u0026rdquo; or \u0026ldquo;in comparison to\u0026rdquo;. 去年に比べて、今年の売上（うりあげ）はかなり増えた。（Compared to last year, this year’s sales have increased significantly.） 日本に比べて、アメリカの生活費は高い。（Compared to Japan, the cost of living in the United States is higher.） において/における: において/における are used to indicate a place, situation, or context where something is happening. において is a more formal or written expression, and における is used to modify nouns. 教（きょう）育（いく）において、平（びょう）等（どう）は重（じゅう）要（よう）なテーマです。（In education, equality is an important topic.） 経済における問題について話し合いが行（おこな）われた。（A discussion was held regarding the issue in the economy.） にしては: にしては is used to express that something is unexpected or contrary to expectations, considering a specific standard or situation. It translates as \u0026ldquo;for\u0026rdquo;, \u0026ldquo;considering it\u0026rsquo;s\u0026rdquo;, or \u0026ldquo;given that\u0026rdquo;. 彼は初心者にしては、ピアノが上手だ。（For a beginner, he plays the piano very well.） この料理は家庭料理にしては、とてもおいしい。（Considering it’s homemade, this dish is very delicious.） にしても: にしても is used to indicate that something remains true or doesn’t change even under certain conditions. It translates to \u0026ldquo;even if\u0026rdquo;, \u0026ldquo;even though\u0026rdquo;, or \u0026ldquo;no matter how\u0026rdquo;. どんなに忙しくても、健康には気をつけなければならない。（Even if I’m busy, I must take care of my health.） 子供にしても、これはひどい行（こう）為（い）だ。（Even for a child, this is terrible behavior.） １７６−１８０ Your browser does not support the audio element. SHOW CONTENTS に対して: に対して is used to show a contrast or direction in relation to something or someone. It can be translated as \u0026ldquo;in contrast to\u0026rdquo;, \u0026ldquo;while\u0026rdquo;, or \u0026ldquo;in regard to\u0026rdquo;. 彼の意見に対して、私は賛成できません。（In contrast to his opinion, I cannot agree.） 私は仕事に対して真（しん）剣（けん）に取り組んでいます。（I am working seriously in regard to my job.） にとって: にとって is used to indicate how something is perceived or understood by someone. It translates to \u0026ldquo;to\u0026rdquo;, \u0026ldquo;for\u0026rdquo;, or \u0026ldquo;concerning\u0026rdquo;. 彼女にとって一番大切なものは家族だ。（The most important thing for her is family.） この薬は子供にとって危（き）険（けん）だ。（This medicine is dangerous for children.） について: について is used to refer to something that is about or concerning a particular topic. It translates as \u0026ldquo;concerning\u0026rdquo;, \u0026ldquo;regarding\u0026rdquo;, or \u0026ldquo;about\u0026rdquo;. 彼は日本の歴（れき）史（し）について本を書いている。（He is writing a book about Japanese history.） 環境問題についての意識が高まってきている。（Awareness regarding environmental issues is increasing.） につれて: につれて is used to indicate that as one thing changes, another thing changes in response. It can be translated as \u0026ldquo;as\u0026hellip;then\u0026rdquo; or \u0026ldquo;with\u0026rdquo;. 年を取るにつれて、健康が大切だと感じるようになった。（As I got older, I began to feel that health is important.） 経済が発展（はってん）するにつれて、生活水（すい）準（じゅん）が向（こう）上（じょう）した。（As the economy developed, the standard of living improved.） によると/によれば: によると/によれば is used to indicate that the information or statement is based on a particular source, report, or authority. It translates as \u0026ldquo;according to\u0026rdquo;. 天気予（よ）報（ほう）によると、明日は雨が降るそうです。（According to the weather forecast, it’s going to rain tomorrow.） 先生によれば、試験は来週だそうだ。（According to the teacher, the exam is next week.） １８１−１８５ Your browser does not support the audio element. SHOW CONTENTS によって/による: によって/による indicates the means, cause, or reason for an action or event. It can be translated as \u0026ldquo;by means of\u0026rdquo;, \u0026ldquo;due to\u0026rdquo;, or \u0026ldquo;because of\u0026rdquo;. 国によって習慣が違う。（Customs differ depending on the country.） この建物は有名な建築家によって設計された。（This building was designed by a famous architect.） の間に: の間に is used to indicate that something occurs during a period of time or while another event is happening. 彼は旅行の間にたくさんの写真を撮った。（He took a lot of photos during his trip.） 勉強の間に音楽を聴くことが好きです。（I like listening to music while studying.） を始め: を始め is used to list examples or to indicate the starting point of something. It translates as \u0026ldquo;for example\u0026rdquo; or \u0026ldquo;starting with\u0026rdquo;. 校長先生を始め、多くの先生方が見（けん）学（がく）に来られた。（The principal, along with many teachers, came to observe.） 会議には中国をはじめ、アジアの国々が参加した。（China and other Asian countries participated in the conference.） おかげで: おかげで is used to indicate that something positive happened because of someone\u0026rsquo;s actions or a particular circumstance. It translates to \u0026ldquo;thanks to\u0026rdquo; or \u0026ldquo;because of\u0026rdquo;. 毎日練習したおかげで上手になった。（Thanks to daily practice, I\u0026rsquo;ve improved.） 両親のおかげで日本へ留学することができた。（Thanks to my parents I was able to study in Japan.） っぱなし: っぱなし indicates that something is left in a particular state, often in an unfinished or uncompleted way. It can be translated as \u0026ldquo;leaving something on\u0026rdquo;, \u0026ldquo;leaving something still in use\u0026rdquo;. ドアが開けっぱなしだよ。（The door has been left open.） 部屋を出るときに電気をつけっぱなしにしないでください。（Please don\u0026rsquo;t leave the light on when you leave the room.） １８６−１９０ Your browser does not support the audio element. SHOW CONTENTS っぽい: The suffix っぽい is used to indicate that something resembles or has the characteristics of something else. It can be translated as \u0026ldquo;-ish\u0026rdquo;, \u0026ldquo;-like\u0026rdquo;, or \u0026ldquo;having the quality of\u0026rdquo;. 彼は子供っぽい性格だ。（He has a childish personality.） このデザインは昔っぽい感じがします。（This design has an old-fashioned (retro) feel.） さえ: さえ is used to emphasize something extreme or something that should be the least likely to happen. It translates to \u0026ldquo;even\u0026rdquo; or \u0026ldquo;only\u0026rdquo; in English. その問題は子供さえ解ける。（Even a child can solve that problem.） わたしは忙しくて、散歩する暇さえない。（I\u0026rsquo;m so busy that I don’t even have time to go for a walk.） さえ〜ば: さえ〜ば indicates that if a certain condition is met, then something else will be possible or will happen. お金さえあれば、旅行に行けるのに。（If only I had money, I could go on a trip.） 健康さえあれば、何でもできる。（As long as I am healthy, I can do anything.） 最中に: 最中に is used to indicate that something is happening in the middle of or during another event or activity. 彼は話している最中に、突然に立ち上がった。（He suddenly stood up in the middle of speaking.） 掃除をしている最中に、友達が訪ねてきました。（A friend came over while I was cleaning.） せいで: せいで is used to indicate that something happened because of an unfortunate situation or reason. It often carries a negative or unwanted implication, similar to \u0026ldquo;because of\u0026rdquo; or \u0026ldquo;due to\u0026rdquo; in English. 彼のせいで、私の計（けい）画（かく）が台（だい）無（な）しになった。（Because of him, my plan was ruined.） 交（こう）通（つう）渋（じゅう）滞（たい）のせいで、遅刻しました。（I was late because of the traffic jam.） １９１−１９５ Your browser does not support the audio element. SHOW CONTENTS 次第（しだい）: 次第（しだい） indicates that something will happen as soon as or depending on a certain condition. It often implies that the action is immediate or follows closely after the condition is met. こちらの準備が整（ととの）い次第、お知らせいたします。（I will notify you as soon as the preparations are ready.） 成功するかどうかは努力次第だ。（Whether you succeed depends on your effort.） しかない: しかない is used to show that there is only one option or no choice but to do something. It indicates a situation where no alternatives are available. これを試すしかない。（I have no choice but to try this.） 諦（あきら）めるしかない状（じょう）況（きょう）だ。（It\u0026rsquo;s a situation where we have no choice but to give up.） その結果: その結果 is used to show the result or consequence of something. It’s similar to saying \u0026ldquo;as a result\u0026rdquo; or \u0026ldquo;because of that\u0026rdquo; in English. 遅刻した。その結果、会議に間に合わなかった。（I was late. As a result, I couldn\u0026rsquo;t make it to the meeting.） 勉強をしなかった。その結果、試験に落ちた。（I didn’t study. As a result, I failed the exam.） そうもない: そうもない is used to indicate that something is very unlikely or hardly likely to happen. It suggests doubt or pessimism regarding a situation. こんなに雨が降っては、試合はできそうもない。（With such much rain, the game seems very unlikely to happen.） 今日は天気が良くないので、ピクニックに行けそうもない。（The weather isn’t good today, so it seems unlikely that we can go on the picnic.） たびに: たびに indicates that something happens every time or whenever a particular event or action occurs. It suggests repetition or habitual action. この店に来るたびに、新しい商品が入っている。（Every time I come to this shop, there are new products.） 旅行に行くたびに、写真を撮るのが楽しみだ。（I look forward to taking pictures every time I go on a trip.） １９６−２００ Your browser does not support the audio element. SHOW CONTENTS ために: ために is used to indicate purpose or goal. It shows that something is done in order to achieve a specific goal, or for the sake of something. 健康のために、毎日運動しています。（I exercise every day for my health.） 環境を守（まも）るために、リサイクルを始めました。（I started recycling for the sake of protecting the environment.） たらいい/といい: たらいい/といい is used to express a wish, hope, or suggestion. It implies that it would be good if something happens. 早く寝たらいいよ。（It would be good if you went to bed early.） 早く治（なお）ればいいな。（I hope you get better soon.） ために: ために can also indicates cause or reason for an event or situation. It shows that something happened because of a certain cause. 事故のために、電車が遅れました。（The train was delayed because of an accident.） 彼の助（たす）けのために、この問題が解決しました。（This problem was solved because of his help.） たとえ〜ても: たとえ〜ても is used to show concession. It means even if something happens, or even if something is true, the outcome will still be as expected or desired. たとえ雨が降っても、試合は行（おこな）われます。（Even if it rains, the match will go ahead.） たとえどんなに難しくても、諦めません。（Even if it\u0026rsquo;s very difficult, I won’t give up.） たとたん: たとたん is used to indicate that something happened immediately or just after another action. It expresses that once one event occurred, another followed immediately after. ドアを開けたとたん、犬が飛び出した。（As soon as I opened the door, the dog jumped out.） 彼はその話を聞いたとたんに怒り出した。（As soon as he heard that story, he got angry.） ２０１−２０５ Your browser does not support the audio element. SHOW CONTENTS てごらん: てごらん is a polite expression used to suggest that someone try doing something or look at something. It is often used when offering advice or encouragement. この本を読んでごらん。（Please try reading this book.） ここに書いてあることを見てごらん。（Look at what’s written here.） て初めて: て初めて indicates that something happened only after a certain action or event. It is used to show that the result occurred after completing a specific condition or action. 日本に行って初めて、本当の日本の文化を理解した。（Only after going to Japan did I truly understand the real culture of Japan.） 試験を受けて初めて、自分の弱点に気づいた。（Only after taking the exam did I realize my weaknesses.） てもかまわない: てもかまわない is used to express that it doesn’t matter whether something happens or not, or it’s okay to do something. この席に座ってもかまわない。（It doesn’t matter if you sit here.） 手伝ってもかまわないですか？（Is it okay if I help?） といっても: といっても is used to indicate that, although something is said or considered, there is some limitation or exception to it. 日本語ができるといっても、まだまだ勉強しないといけません。（Although I can speak Japanese, I still need to study more.） お金はあるといっても、無（む）駄（だ）遣（づか）いはできません。（Even if you have money, you cannot waste it.） という: という is used to explain what something is called or named. It is often used to introduce a definition, a title, or a phrase. これは「さくら」という花です。（This is a flower called \u0026lsquo;sakura\u0026rsquo;.） 私が行く予定の町（ちょう）は「京都」というところです。（The town I’m planning to visit is called Kyoto.） ２０６−２１０ Your browser does not support the audio element. SHOW CONTENTS ということだ: ということだ is used to report what someone has heard or what is said about something. It is often used to convey information from a third party or to summarize something that has been explained. 彼は来週日本に行くということだ。（I\u0026rsquo;ve heard that he is going to Japan next week.） 新しい店がオープンするということだ。（I’ve heard that a new store is opening.） というのは: というのは is used to define, explain, or elaborate on something. It’s used when someone is about to provide clarification or details. 遅刻したというのは、交通渋滞に巻（ま）き込（こ）まれたからだ。（The reason I was late is that I was stuck in traffic.） それは「未来予（よ）測（そく）」というのは難しいからだ。（This is because “predicting the future” is difficult.） というと: というと is used when bringing up or introducing a topic, often when talking about something that is closely related to what has been mentioned before. It is similar to \u0026ldquo;speaking of\u0026rdquo;. 映画というと、最近見た映画がすごく面白かった。（Speaking of movies, the one I watched recently was really interesting.） 勉強というと、最近全（まった）くしていない。（Speaking of studying, I haven’t done any recently.） というより: というより is used to express a preference or contrast, often meaning \u0026ldquo;rather than\u0026rdquo; or \u0026ldquo;more like.\u0026rdquo; It indicates that the first option is less appropriate or accurate than the second. 彼は先生というより、友達みたいな存在だ。（He is more like a friend than a teacher.） この映画は感動的というより、面白いです。（This movie is more interesting than emotional.） ところで: ところで is used when changing the topic or introducing a new topic. It is similar to \u0026ldquo;by the way\u0026rdquo; in English, often used to casually bring up something unrelated to the previous discussion. ところで、今度の週末は何をする予定ですか？（By the way, what are you planning to do this weekend?） ところで、彼女の名前を知っていますか？（By the way, do you know her name?） ２１１−２１５ Your browser does not support the audio element. SHOW CONTENTS ところが: ところが is used to introduce a contrast or unexpected development. It’s often used when something contrary to what was expected happens, similar to \u0026ldquo;however\u0026rdquo; or \u0026ldquo;even though.\u0026rdquo; 天気予報では晴れると言っていたところが、実際は雨が降った。（Even though the weather forecast said it would be sunny, it actually rained.） 彼はとても優しい人だと思っていたところが、実は冷たい一面もあった。（Even though I thought he was a very kind person, he actually had a cold side.） とおり: とおり is used to indicate that something is being done in the same way or exactly as described or expected. It can mean \u0026ldquo;according to,\u0026rdquo; \u0026ldquo;just like,\u0026rdquo; or \u0026ldquo;in the way.\u0026rdquo; あなたが言ったとおりに、問題は解決しました。（As you said, the problem was solved.） 彼女は私が教えたとおりに料理を作った。（She made the food just as I taught her.） としたら/とすれば: としたら/とすれば is used to talk about a hypothesis or assumption. It’s similar to saying \u0026ldquo;if it were the case that\u0026rdquo; or \u0026ldquo;if we assume.\u0026rdquo; もし彼が来るとしたら、すぐに知らせてください。（If it were the case that he is coming, please let me know immediately.） この問題を解決するとすれば、時間がもっとかかるだろう。（If we assume that this problem will be solved, it would likely take more time.） として: として is used to indicate the role or capacity in which someone is acting or something is being considered. 留学生として日本に来た。（I came to Japan as an international student.） 私は先生として、この学校で働いています。（I am working at this school as a teacher.） とは限（かぎ）らない: とは限らない is used to express that something is not always true or not necessarily the case. It’s used to counter assumptions or expectations. お金があれば幸せだとは限らない。（Having money does not necessarily mean happiness.） 日本人が皆寿司が好きだとは限らない。（Not all Japanese people necessarily like sushi.） ２１６−２２０ Your browser does not support the audio element. SHOW CONTENTS ついでに: ついでに is used when performing one action while or in addition to another. It suggests that an additional task is done during or after the main task, often as a side or incidental activity. 買い物のついでに、郵便局にも寄ってきた。（While shopping, I stopped by the post office.） 仕事のついでに、スーパーに寄ってください。（Please stop by the supermarket after work.） つまり: つまり is to rephrase or clarify a previous statement in simpler or more direct terms. It offers an explanation in a clearer way. 彼はとても忙しい、つまり、今は会えない。（He’s very busy, in other words, he can’t meet right now.） 私は明日から旅行に行く、つまり、来週の月曜日に戻る予定だ。（I’m going on a trip starting tomorrow, that is to say, I plan to return next Monday.） と共（とも）に: と共（とも）に indicates that something happens alongside or in conjunction with something else. This expression highlights that two actions or events occur at the same time or in close association. 彼と共に働くことになった。（I ended up working together with him.） 家族と共に暮（く）らしている。（I live together with my family.） うちに: うちに indicates that an action occurs before a change or while something is in progress. It suggests the idea of doing something while the situation is still ongoing or before conditions change. 熱いうちに食べてください。（Please eat it while it\u0026rsquo;s hot.） 暗くならないうちに帰りましょう。（Let\u0026rsquo;s go home before it gets dark.） 上で: 上で indicates that one action is performed after or upon completing another action. It shows a sequence where one event follows another. 必要な書類を揃（そろ）えた上で、提出してください。（Please submit them after gathering the necessary documents.） 会議の上で、その問題を話し合うつもりです。（We plan to discuss the issue after the meeting.） ２２１−２２５ Your browser does not support the audio element. SHOW CONTENTS わけだ: わけだ indicates that something is naturally the case or understandable based on the context. It can also explain the reason behind something. 彼はよく勉強しているから、合格したわけだ。（He studied hard, so it’s no wonder he passed.） 今日は晴れているから、みんな出かけるわけだ。（It\u0026rsquo;s sunny today, so that\u0026rsquo;s why everyone is going out.） わけではない: わけではない is used to deny a certain assumption or implication, indicating that something is not necessarily true or doesn\u0026rsquo;t mean what might have been assumed. お金があれば幸せだというわけではない。（It’s not the case that having money means happiness.） 彼が遅れたのは、彼のせいというわけではない。（It is not his fault that he was late.） わけがない: わけがない indicates strong certainty that something is impossible, implausible, or untrue. It expresses a firm belief that a particular situation or outcome cannot happen. 彼がそんなことをするわけがない。（There’s no way he would do something like that.） こんなに簡単な問題が解けないわけがない。（There’s no way I can’t solve such an easy problem.） わけにいかない: わけにいかない is used when expressing that something is not possible, often due to moral, social, or personal reasons. It implies that one cannot do something, usually because of a sense of obligation or restriction. 今日は忙しいから、出かけるわけにいかない。（I\u0026rsquo;m too busy today to go out.） 彼にそんなことを言うわけにいかない。（I can\u0026rsquo;t say that to him.） わりに: わりに is used to indicate that something is unexpected or surprising in comparison to what was assumed. It implies a contrast between the expected result and the actual one. このレストランは高いわりに、味は普通だった。（This restaurant was expensive, but the taste was average.） このパソコンは安いわりに性（せい）能（のう）がいい。（This computer has good performance for a low price.） ２２６−２３０ Your browser does not support the audio element. SHOW CONTENTS ような気がする: ような気がする is used to describe a vague sense, intuition, or feeling about something, even if it’s not based on concrete evidence. It suggests uncertainty but is often used when someone has a gut feeling or guess. 今日は雨が降りそうな気がする。（I have a feeling that it’s going to rain today.） 彼はもうすぐ来るような気がする。（I think he’s about to arrive soon.） ように: ように indicates purpose or reason, meaning that something is done in order to achieve a specific goal or result. It’s used with verbs to explain the intention behind an action. 健康のために、毎日運動をするようにしています。（I try to exercise every day in order to stay healthy.） 彼に見えるように、ライトをつけておいてください。（Please turn on the lights so that he can see.） ようとする: ようとする indicates an attempt to do something or being on the verge of doing it. It can suggest that one is in the process of trying or attempting something, but it might not be completed. ドアを開けようとしたが、鍵がかかっていた。（I tried to open the door, but it was locked.） 彼は今、出かけようとしています。（He is about to leave now.） ようとしない: ようとしない indicates that someone is not making an effort or not trying to do something, even though they could. It suggests a lack of intention or effort. 彼は全然勉強しようとしない。（He doesn\u0026rsquo;t try to study at all.） 子供が野菜を食べようとしない。（The child refuses to eat vegetables.） ずに: ずに is the negative form of て-form used to indicate that something was done without a certain action or behavior. It’s the equivalent of saying \u0026ldquo;without doing something.\u0026rdquo; 何も言わずに部屋を出た。（He left the room without saying anything.） 朝ご飯を食べずに学校へ行った。（I went to school without eating breakfast.） ２３１−２３５ Your browser does not support the audio element. SHOW CONTENTS ずにはいられない: ずにはいられない is used when someone cannot stop themselves from doing something, whether it’s an action or a feeling. It expresses an irresistible urge or compulsion to do something. 彼の話を聞くと、笑（わら）わずにはいられない。（When I hear his stories, I can\u0026rsquo;t help but laugh.） その映画は感動的で、涙（なみだ）を流（なが）さずにはいられなかった。（The movie was so emotional that I couldn’t help but cry.） あるいは: あるいは is used to present an alternative or possibility, similar to saying “or” or \u0026ldquo;perhaps\u0026rdquo; in English. It can also suggest a choice between two or more things. 会議は午後1時、あるいは午後2時に開始される予定です。（The meeting is scheduled to start either at 1 PM or 2 PM.） 明日会うか、あるいは電話するか決めよう。（Let’s decide whether we’ll meet tomorrow or maybe just call.） ぶりに: ぶりに is used to indicate something happening for the first time in a certain period. It expresses a sense of recurrence after a long gap or delay. 彼に会うのは10年ぶりだ。（It’s the first time in 10 years that I’ve met him.） 一週間ぶりに晴れの日になった。（It\u0026rsquo;s sunny for the first time in a week.） ちっとも〜ない: ちっとも〜ない is used to emphasize that something is not true at all or in the least. It adds emphasis to a negative statement. ちっとも勉強しなかったので、試験は全然できなかった。（I didn’t study at all, so I couldn’t do the exam in the least.） ちっとも面白くない映画だった。（It was not an interesting movie at all.） だけあって: だけあって is used to show that something is expected or understandable because of the qualities or circumstances surrounding it. It highlights a cause-and-effect relationship. 彼はプロのシェフだけあって、料理がとても上手だ。（Being a professional chef, it’s no surprise that he’s really good at cooking.） 学生だけあって、アルバイトをしている人が多い。（Since they’re students, it’s not surprising that many of them work part-time.） 語彙 1 Your browser does not support the audio element. SHOW CONTENTS 愛嬌 (あいきょう): charm, amiability 彼女は自然な愛嬌があって、みんなに好かれる。 (She has natural charm and is liked by everyone.) 足踏み (あしぶみ): stamping one\u0026rsquo;s feet, staying in place (without progress) 進（しん）捗（ちょく）がなくて、足踏みしているような気がする。 (I feel like we’re just stamping our feet without making any progress.) アタック: attack, approach (often used in sports or in a figurative sense) 彼は試合で積極（せっきょく）的にアタックを仕（し）掛（か）けた。 (He actively attacked during the match.) アフターケア: aftercare, follow-up care 退（たい）院（いん）後のアフターケアをしっかりと行うことが大切だ。 (It’s important to provide proper aftercare after being discharged from the hospital.) 絵画（かいが）: painting, artwork この美術館には有名な絵画がたくさん展（てん）示（じ）されている。 (This museum has many famous paintings on display.) 後始末（あとしまつ）: cleanup, finishing up パーティーが終わった後の後始末は私の仕事だ。 (Cleaning up after the party is my job.) 過ち（あやまち）: mistake, error 彼は過ちを犯（おか）してしまったことを悔（く）いている。 (He regrets making the mistake.) 言いそびれる (いいそびれる): to fail to say, to forget to say 大切なことを言いそびれてしまった。 (I forgot to say something important.) 行き違う (いきちがう): to miss each other, to misunderstand 私たちは駅で行き違いになった。 (We missed each other at the station.) 遺跡 (いせき): ruins, archaeological site 古（こ）代（だい）の遺跡を訪（おとず）れるのが好きだ。 (I enjoy visiting ancient ruins.) 一大事 (いちだいじ): a major event, a serious matter それは一大事だから、慎（しん）重（ちょう）に考（かんが）えなければならない。 (It’s a major event, so we need to think carefully.) 一切 (いっさい): everything, all (often used in a negative sense to mean \u0026ldquo;nothing\u0026rdquo;) 彼は一切の連絡を絶（た）った。 (He cut off all contact.) 未だ (いまだ): still, yet 未だに彼女とは連絡が取れていない。 (I still haven’t been able to get in touch with her.) 癒す (いやす): to heal, to soothe 彼の言葉は私を癒してくれた。 (His words soothed me.) 居留守 (いるす): pretending not to be home, feigning ignorance 彼は電話に出るのを避（さ）けるために居留守を使っている。 (He’s pretending not to be home to avoid answering the phone.) 青二才 (あおにさい): inexperienced young person, naïve まだ青二才だと言われた。 (I was told I’m still an inexperienced young person.) 打ち明ける (うちあける): to confide in, to reveal (one’s feelings or a secret) 彼に秘密を打ち明けることに決めた。 (I decided to confide in him about my secret.) 打ち切る (うちきる): to terminate, to discontinue 会議は予定より早く打ち切られた。 (The meeting was cut short earlier than planned.) 上がり (あがり): rise, income, finishing (in a certain context, such as a performance) 彼は上がりの収（しゅう）入（にゅう）で生（せい）活（かつ）している。 (He lives off his earnings.) あらかじめ (あらかじめ): in advance, beforehand あらかじめ予定を立てておいたほうがいい。 (It’s better to make plans in advance.) 2 Your browser does not support the audio element. SHOW CONTENTS 打ち解ける (うちとける): to open up, to become friendly 彼とはすぐに打ち解けて、友達になった。 (I opened up to him quickly and became friends.) 促す (うながす): to encourage, to prompt 先生は生徒にもっと勉強するように促した。 (The teacher encouraged the students to study more.) 麗しい (うるわしい): beautiful, lovely 彼女は麗しい笑（え）顔（がお）でみんなを魅（み）了（りょう）した。 (She captivated everyone with her beautiful smile.) 会釈 (えしゃく): a slight bow, a greeting gesture 彼は通りすがりに会釈をしてくれた。 (He gave me a slight bow as he passed by.) 縁起 (えんぎ): omen, auspice, good luck この日が結婚式の日として選ばれたのは、縁起が良いとされているからだ。 (This day was chosen for the wedding because it’s considered to be a good omen.) 行き当たりばったり (いきあたりばったり): haphazard, impromptu 旅行の計画を行き当たりばったりで決めるのは、あまり良くない。 (It’s not a good idea to make travel plans haphazardly.) 致し方ない (いたしがたない): inevitable, can’t be helped 事故で遅れたのは致し方ない。 (It can’t be helped that I was late because of the accident.) 愛しい (いとしい): dear, beloved, precious 愛しい人との時間が最も幸せだ。 (Time spent with my beloved is the happiest.) 円安 (えんやす): yen depreciation, weak yen 円安が進んで、輸（ゆ）入（にゅう）品（ひん）が高くなった。 (The depreciation of the yen has led to higher import prices.) 老いる (おいる): to grow old, to age 彼は年を取っても心は老いていない。 (Even as he ages, his heart remains young.) 押し込む (おしこむ): to push into, to shove in 荷物を車のトランクに押し込んだ。 (I shoved the luggage into the car trunk.) 営む (いとなむ): to manage, to run (a business or activity) 彼は小さなレストランを営んでいる。 (He runs a small restaurant.) 一括 (いっかつ, ikkatsu): all together, in bulk 注文は一括でまとめて出してもらえますか？ (Could you submit the order all at once?) 一気に (いっきに): all at once, in one go その問題を一気に解決した。 (I solved the problem all at once.) 回路 (かいろ, kairo): circuit, path (in electronics) 電気回路をチェックしてみてください。 (Please check the electrical circuit.) 意欲 (いよく): will, desire, motivation 彼は仕事に対する意欲が非常に高い。 (He has very high motivation for his work.) 対応 (たいおう): response, dealing with (a situation) クレームへの対応が遅れたことを謝（しゃ）罪（ざい）した。 (I apologized for the delay in responding to the complaint.) 日付 (ひづけ): date この書類に日付を記（き）入（にゅう）してください。 (Please fill in the date on this document.) 書式 (しょしき): format, style 彼は報告書の書式に従（したが）ってレポートを提出した。 (He submitted the report following the required format.) 単位 (たんい): unit, credit (in education) この科（か）目（もく）は3単位です。 (This course is worth 3 credits.) 3 Your browser does not support the audio element. SHOW CONTENTS 隠蔽 (いんぺい): concealment, cover-up 彼は問題を隠蔽しようとしたが、すぐに発覚（はっかく）した。 (He tried to conceal the issue, but it was quickly uncovered.) 〜交う (〜こう): to mix, to mingle (used with verbs to indicate reciprocal actions) 彼らはよく議（ぎ）論（ろん）を交（まじ）えて意見を交（こう）換（かん）する。 (They often mix in discussions and exchange opinions.) 掲げる (かかげる): to raise, to carry (a flag or a cause), to display 会社の目（もく）標（ひょう）を掲げて、全員で取り組んでいる。 (We have raised the company’s goals and are working on them as a team.) 転寝 (うたたね): nap, dozing off 午後の会議の前に転寝をしてリフレッシュした。 (I took a nap before the afternoon meeting to refresh myself.) 移り変わり (うつりかわり): change, transition (often used for seasons or life stages) この地（ち）域（いき）では季節の移り変わりが美しい。 (The transition of seasons is beautiful in this area.) 格上げ (かくあげ): promotion, elevation to a higher rank 彼は昇（しょう）進（しん）して格上げされた。 (He was promoted and elevated to a higher position.) 嵩む (かさむ): to pile up, to increase in volume or cost 経（けい）費（ひ）が嵩んで、予（よ）算（さん）をオーバーしてしまった。 (The expenses piled up, and we exceeded the budget.) 過疎 (かそ, kaso): depopulation, rural decline この村は過疎化（か）が進んで、人（じん）口（こう）が減（げん）少（しょう）している。 (This village is experiencing depopulation, and the population is decreasing.) 器 (うつわ): container, vessel, capacity (both literal and figurative) 彼は大きな器を持っている人だ。 (He is a person with great capacity.) エキストラ (ekisutora): extra (in movies, plays, etc.) 彼は映画でエキストラとして出演した。 (He appeared as an extra in the movie.) 演壇 (えんだん): podium, stage for a speech 彼は演壇で演（えん）説（ぜつ）を行（おこな）った。 (He gave a speech from the podium.) 遠方 (えんぽう): distant place, faraway 遠方から来た友人と久（ひさ）しぶりに再（さい）会（かい）した。 (I reunited with an old friend who came from a distant place.) 肩書き (かたがき): title, honorific 彼は役（やく）職（しょく）に関（かか）わらず、肩書きにとらわれない。 (He doesn’t get caught up in titles, regardless of his position.) 金槌 (かなづち): hammer, or a person who cannot swim 彼は金槌なので、泳ぐのが苦（にが）手（て）だ。 (He’s a poor swimmer, so he struggles with swimming.) 旺盛 (おうせい): vigorous, enthusiastic, lively 彼は旺盛な食（しょく）欲（よく）を持っている。 (He has a vigorous appetite.) 大台 (おおだい): a major milestone or benchmark (often used for numbers like income, age, etc.) 今年、年（ねん）収（しゅう）が大台の1,000万円を超（こ）えた。 (This year, my income exceeded the major milestone of 10 million yen.) 簡潔 (かんけつ): concise, simple and clear 彼は簡潔に要（よう）点（てん）をまとめて説明した。 (He explained the point clearly and concisely.) 奥深い (おくふかい): profound, deep 彼の考えはとても奥深く、理解するのが難しい。 (His thoughts are profound and difficult to understand.) 暦法 (れきほう): calendar system その国は独（どく）自（じ）の暦法を使（し）用（よう）している。 (That country uses its own calendar system.) 基準 (きじゅん): standard, criterion この製（せい）品（ひん）は国（こく）際（さい）的（てき）な基準を満（み）たしている。 (This product meets international standards.) 4 Your browser does not support the audio element. SHOW CONTENTS 押し切る (おしきる): to force through, to push through (against resistance) 彼は反対意見を押し切って、その提案を通した。 (He pushed through his proposal despite the opposition.) 脅かす (おどかす): to threaten, to intimidate 彼は脅かして自分の意見を押し通そうとした。 (He tried to force his opinion through by threatening.) 冠婚葬祭 (かんこんそうさい): ceremonial occasions (weddings, funerals, etc.) 日本では冠婚葬祭が非常に重（じゅう）要（よう）視（し）されている。 (In Japan, ceremonial occasions such as weddings, funerals, etc., are highly valued.) 閑静 (かんせい): quiet, peaceful (used for neighborhoods or places) この住（じゅう）宅（たく）街（がい）は閑静で、静かな生活が送れる。 (This residential area is quiet, and you can enjoy a peaceful life.) 親心 (おやごころ): parental feelings, a parent’s love 親心から子どもの未来を心配するのは当（とう）然（ぜん）だ。 (It’s natural for parents to worry about their children’s future out of parental love.) 海峡 (かいきょう): strait (a narrow body of water between two land masses) その島は広い海峡を挟（はさ）んで隣の国と繋（つな）がっている。 (The island is connected to the neighboring country across a wide strait.) 完走 (かんそう): finishing a race, completing a course マラソンを完走することが目（もく）標（ひょう）だった。 (My goal was to finish the marathon.) 帰京 (ききょう): returning to Tokyo 長い出張（しゅっちょう）を終えて、帰京した。 (After a long business trip, I returned to Tokyo.) 基金 (ききん): fund (usually for a specific purpose) このプロジェクトには、政（せい）府（ふ）からの基金が支（し）援（えん）されている。 (This project is supported by a government fund.) 確信 (かくしん): conviction, certainty 彼は自分の成（せい）功（こう）に対して確信を持っている。 (He has confidence in his success.) 格段 (かくだん): particularly, greatly (often used to emphasize something superior) この新しいモデルは格段に性（せい）能（のう）が向上している。 (This new model has improved performance significantly.) 過激 (かげき): radical, extreme 彼の過激な意見は賛（さん）否（ぴ）を呼んだ。 (His extreme opinions sparked both support and opposition.) 過酷 (かこく): harsh, severe 過酷な環（かん）境（きょう）で働くことは精（せい）神（しん）的にも肉（にく）体（たい）的にも辛（づら）い。 (Working in harsh conditions is tough both mentally and physically.) 気触れる (かぶれる): to develop a rash or skin irritation; to be overly influenced (often negatively) by something (e.g., ideas, trends) その植（しょく）物（ぶつ）に触（ふ）れて気触れた。 (I touched that plant and got a rash.) 新しい思（し）想（そう）に気触れて、極（きょく）端（たん）な行（こう）動（どう）をとるようになった。 (He became overly influenced by the new ideology and started acting radically.) 関節 (かんせつ): joint (in the body) 関節が痛くなってきたので、運動を控（ひか）えることにした。 (My joints started hurting, so I decided to hold back on exercising.) 甲板 (かんぱん): deck (of a ship) 甲板に出て、海の景（けし）色（き）を楽しんだ。 (I went out on the deck to enjoy the view of the sea.) 漢方薬 (かんぽうやく): Chinese medicine 漢方薬は自然の成（せい）分（ぶん）を使った治（ち）療（りょう）法（ほう）として人気がある。 (Chinese medicine is popular as a treatment using natural ingredients.) 関与 (かんよ): involvement, participation 彼はその問題には関与していないと明（めい）言（げん）した。 (He stated clearly that he was not involved in the issue.) 季刊 (きかん): quarterly (publication) この雑誌は季刊で発行（はっこう）されている。 (This magazine is published quarterly.) 記載 (きさい): description, entry (writing down information) 申（もうし）込（こみ）書（しょ）に必要な情報を記載してください。 (Please write down the necessary information on the application form.) 5 Your browser does not support the audio element. SHOW CONTENTS 決まり悪い (きまりわるい): embarrassed, uncomfortable 彼は決まり悪そうに黙（だま）っていた。 (He remained silent, looking embarrassed.) 華奢 (きゃしゃ): delicate, fragile 彼女は華奢な体（たい）型（けい）で、歩き方も優（ゆう）雅（が）だ。 (She has a delicate figure, and her way of walking is graceful.) 驚異的 (きょういてき): phenomenal, miraculous 彼の能力は驚異的で、誰も彼には勝（か）てない。 (His ability is phenomenal, and no one can beat him.) 強硬 (きょうこう): firm, strong-willed (used for attitudes, measures) 彼は強硬な態（たい）度（ど）で交（こう）渉（しょう）を進（すす）めた。 (He proceeded with the negotiations in a firm manner.) 凝固 (ぎょうこ): solidification, freezing 液（えき）体（たい）は冷（れい）却（きゃく）されて凝固した。 (The liquid was cooled and solidified.) 切り抜ける (きりぬける): to get through, to escape from 彼は困（こん）難（なん）な状況をうまく切り抜けた。 (He managed to get through the difficult situation.) 拒否 (きょひ): rejection, refusal 彼は提案を拒否した。 (He rejected the proposal.) 空間 (くうかん): space, room (physical or abstract) 部屋に空間が広く取られていて、快（かい）適（てき）だった。 (The room had ample space, making it comfortable.) 苦渋 (くじゅう): distress, anguish (often used for making difficult decisions) 彼は苦渋の選（せん）択（たく）を迫（せま）られた。 (He was forced to make a difficult choice.) 明け暮れる (あけくれる): to spend all day (doing something), to be absorbed in 彼は毎日仕事に明け暮れている。 (He spends every day absorbed in work.) あざ笑う (あざわらう, azawarau): to mock, to ridicule 彼は失敗（しっぱい）した相（あい）手（て）をあざ笑（わら）った。 (He mocked the person who failed.) 圧倒 (あっとう): overwhelming, overpowering その試合で彼は相（あい）手（て）を圧倒した。 (He overwhelmed his opponent in the match.) アットホーム: homely, comfortable (atmosphere) このカフェはアットホームな雰（ふん）囲（い）気（き）が魅力だ。 (This café has a homely atmosphere, which is its charm.) アルファベット: alphabet 英語のアルファベットは26文字から成（な）る。 (The English alphabet consists of 26 letters.) 家出 (いえで): running away from home 彼は家出して、どこかに行ってしまった。 (He ran away from home and went somewhere.) 異議 (いぎ): objection, dissent 彼はその決定（けってい）に異議を唱（とな）えた。 (He raised an objection to the decision.) 一同 (いちどう): all present, everyone 会議には一同が集（あつ）まった。 (Everyone gathered for the meeting.) 今更 (いまさら): at this late stage, now after all this time 今更謝（あやま）っても遅すぎる。 (It\u0026rsquo;s too late to apologize now.) うつ伏せ (うつぶせ): lying face down 彼は床（ゆか）にうつ伏せになって寝ていた。 (He was lying face down on the floor.) 差出人 (さしだしにん): sender (of a letter or package) 差出人の名前が書かれていなかった。 (The sender\u0026rsquo;s name wasn\u0026rsquo;t written.) 6 Your browser does not support the audio element. SHOW CONTENTS 埋め込む (うめこむ): to embed, to implant 彼は新しい技（ぎ）術（じゅつ）をシステムに埋め込む作（さ）業（ぎょう）をした。 (He worked on embedding the new technology into the system.) 運賃 (うんちん): fare (transportation) バスの運賃は250円です。 (The bus fare is 250 yen.) 英字 (えいじ): English letters この書類には英字が多く使われている。 (This document uses a lot of English letters.) 映写 (えいしゃ): projection (of a film or image) 映写機で映画を映（うつ）し出（だ）す準備が整（ととの）った。 (The projector was ready to display the movie.) 抉る (えぐる): to gouge, to dig out 彼の言葉は心を抉るような痛みを与（あた）えた。 (His words caused a painful feeling as if gouging my heart.) 負う (おう): to bear, to take on (a responsibility, a wound) 彼は大きな責任を負っている。 (He bears a great responsibility.) 横行 (おうこう): rampant, widespread (usually used for something negative) 汚（お）職（しょく）が横行している。 (Corruption is rampant.) 王者 (おうじゃ): king, champion 彼は何度も王者の座（ざ）に輝（かがや）いた。 (He has been crowned champion multiple times.) 往診 (おうしん): house call (by a doctor) 医師は往診に出かけた。 (The doctor went on a house call.) 遅番 (おそばん): late shift (work schedule) 今日は遅番なので、午後から働く予定です。 (I’m on the late shift today, so I plan to work in the afternoon.) 脅す (おどす): to threaten, to intimidate 彼は脅して金を要（よう）求（きゅう）した。 (He threatened and demanded money.) 帯びる (おびる): to carry, to take on (a characteristic or role) 彼は重い使命を帯びて、この地に来た。 (He came here carrying a heavy mission.) 面影 (おもかげ): appearance, traces (of a person, or the past) 戦（せん）災（さい）を免（まぬが）れたこの建物には、往（おう）時（じ）の繁（はん）栄（えい）の面影が残（のこ）る。(This surviving pre-war building retains traces of its past prosperity.) 重み (おもみ): weight, seriousness その問題には重みがあり、慎（しん）重（ちょう）に対（たい）処（しょ）しなければならない。 (The issue carries weight, and we must handle it carefully.) 趣 (おもむき): taste, charm, elegance (in a cultural or artistic sense) この町（ちょう）には昔ながらの趣が残（のこ）っている。 (This town retains the charm of the old days.) オリジナル: original 彼はオリジナルのレシピを考（こう）案（あん）した。 (He created an original recipe.) 解除 (かいじょ): cancellation, removal (of a restriction or ban) 監（かん）禁（きん）状（じょう）態（たい）からの解除が決まった。 (The decision to lift the confinement has been made.) 開拓 (かいたく): development, pioneering 新しい市（し）場（じょう）を開拓することが目（もく）標（ひょう）だ。 (The goal is to develop new markets.) 取引 (とりひき): transaction, deal 国（こく）際（さい）取引においては為（かわ）替（せ）リスクを考（こう）慮（りょ）しなければならない。(In international transactions, exchange rate risks must be considered.) 珍しい (めずらしい): rare, unusual 今日は珍しい花が咲（さ）いている。 (A rare flower is blooming today.) 7 Your browser does not support the audio element. SHOW CONTENTS 改良 (かいりょう): improvement, refinement この製（せい）品（ひん）は改良され、より使いやすくなった。 (This product has been improved and is now more user-friendly.) 省みる (かえりみる): to reflect on, to look back on 彼は自分の過（あやま）ちを省みることができた。 (He was able to reflect on his mistakes.) 確たる (かくたる): certain, definite 彼には確たる証（しょう）拠（こ）がある。 (He has definite evidence.) 確保 (かくほ): securing, ensuring 安（あん）全（ぜん）を確（かく）保（ほ）するために新しい手（て）順（じゅん）が必要だ。 (New procedures are necessary to ensure safety.) 架け橋 (かけはし): bridge (in a metaphorical sense, e.g., between people or cultures) この交（こう）流（りゅう）プログラムは両（りょう）国（こく）の理（り）解（かい）の架け橋となることを目（め）指（ざ）している。(This exchange program aims to be a bridge for mutual understanding between the two countries.) 掠る (かする): to graze, to skim 車が壁を掠って傷（きず）がついた。 (The car grazed the wall and got scratched.) かわるがわる: in turn, alternately 彼らはかわるがわる質問をした。 (They took turns asking questions.) 勧告 (かんこく): recommendation, advice (official) 政府は環境保（ほ）護（ご）のための勧告を出した。 (The government issued a recommendation for environmental protection.) 勘定 (かんじょう): calculation, account (e.g., bill or balance) 最（さい）後（ご）に勘定を払（はら）って店を出た。 (I paid the bill and left the store.) 起源 (きげん): origin, source この伝（でん）統（とう）は古（こ）代（だい）日本の起源を持つ。 (This tradition has its origins in ancient Japan.) 軋む (きしむ): to creak, to squeak 古いドアが軋む音がした。 (I heard the creaking sound of the old door.) 既婚 (きこん): married 彼は既婚者だ。 (He is married.) 気風 (きふう): spirit, temper, character (of a place or group) この町には独（どく）特（とく）な気風がある。 (This town has a unique spirit.) 救済 (きゅうさい): relief, rescue 災（さい）害（がい）時には迅（じん）速（そく）な救（きゅう）済（さい）活（かつ）動（どう）が求（もと）められる。 (During disasters, swift relief efforts are required.) 業界 (ぎょうかい): industry, business sector IT業界は急（きゅう）速（そく）に成（せい）長（ちょう）している。 (The IT industry is growing rapidly.) 義理堅い (ぎりがたい): dutiful, loyal 彼は義理堅く、誰に対しても誠（せい）実（じつ）だ。 (He is loyal and sincere to everyone.) 煌く (きらめく): to sparkle, to glitter 星（ほし）が夜（よ）空（ぞら）に煌いていた。 (The stars were sparkling in the night sky.) 疑惑 (ぎわく): suspicion, doubt 彼に関（かん）する疑惑が広がっている。 (Suspicion about him is spreading.) 空き巣 (あきす): burglar, house break-in 空き巣が家に入った形（けい）跡（せき）があった。 (There were signs that a burglar had broken into the house.) 緊密 (きんみつ): close, tight (relationship, connection) 彼らは緊密な協（きょう）力（りょく）関（かん）係（けい）を築（きず）いている。 (They have built a close cooperative relationship.) 8 Your browser does not support the audio element. SHOW CONTENTS 足跡 (あしあと): footprint, trace 砂（すな）浜（はま）に足跡が残っていた。 (There were footprints left on the beach.) あやふや: vague, unclear 彼の答（こた）えはあやふやで、信（しん）頼（らい）できなかった。 (His answer was vague and unreliable.) 霰 (あられ): hail 霰が降ってきて、車の窓が音を立てた。 (Hail started to fall, making a sound on the car window.) 暗雲 (あんうん): dark clouds, omen 空（そら）に暗雲が立（た）ち込（こ）めてきた。 (Dark clouds began to gather in the sky.) 萎縮 (いしゅく): shrink, wither, atrophy 厳（きび）しい上（じょう）司（し）の前で萎縮してしまい、思ったことが言えなかった。(I shrunk back in front of my strict boss and couldn\u0026rsquo;t say what I wanted.) 長（ちょう）期（き）間（かん）の運動不（ふ）足（そく）は筋（きん）肉（にく）の萎縮を引き起こす可（か）能（のう）性（せい）がある。(Long periods of lack of exercise can lead to muscle atrophy.) 異端児 (いたんじ): maverick, heretic 彼はクラスの異端児として知られている。 (He is known as the maverick of the class.) 一目 (いちもく): glance, a look 一目で彼がどこにいるか分かった。 (I knew where he was with just one glance.) 未だに (いまだに): still, even now 未だにその問題は解決していない。 (The problem has still not been solved.) ウイークデー: weekday 彼はウイークデーに忙しく働いている。 (He works hard during the weekdays.) ウエット: sentimental 彼のウエットな性格が、時々仕事の判（はん）断（だん）に影（えい）響（きょう）を与（あた）える。(His emotional personality sometimes affects his work decisions.) 受け止める (うけとめる): to catch, to accept 彼女はその知らせを冷（れい）静（せい）に受け止めた。 (She calmly accepted the news.) 疑わしい (うたがわしい): suspicious, doubtful 彼の証（しょう）言（げん）は疑わしいとされている。 (His testimony is considered suspicious.) 内気 (うちき): shy, introverted 彼はとても内気な性格だ。 (He has a very shy personality.) 空ろ (うつろ): vacant, hollow 事件後、彼女の目は空ろになり、以（い）前（ぜん）の明るさは失（うしな）われた。(After the incident, her eyes became hollow, losing their former brightness.) 概ね (おおむね): generally, in general 概ねこの計画はうまくいくはずだ。 (Generally, this plan should work well.) お返し (おかえし): return (of favor or gift) 彼からのプレゼントのお返しを考えている。 (I am thinking about how to return the favor for the gift he gave me.) 怠る (おこたる): to neglect, to be lazy 仕事を怠ると、後で大きな問題になることがある。 (Neglecting your work can lead to major problems later.) 納める (おさめる): to pay, to submit 税（ぜい）金（きん）を納める期（き）限（げん）は今月末だ。 (The deadline for paying taxes is at the end of this month.) 押し付けがましい (おしつけがましい): overbearing, imposing 彼の押し付けがましいアドバイスにはうんざりしている。(I\u0026rsquo;m tired of his pushy advice.) 惜しむ (おしむ): to regret, to be reluctant (about something) 彼女はお金を惜しんで、旅行をキャンセルした。 (She was reluctant to spend the money and canceled the trip.) 9 Your browser does not support the audio element. SHOW CONTENTS 夥しい (おびただしい): numerous, vast その部屋には夥しい数（かず）の本が積（つ）まれていた。 (The room was piled high with a vast number of books.) 覚束ない (おぼつかない): uncertain, unreliable 彼の返（へん）事（じ）は覚束なく、何を考えているのか分からなかった。 (His response was uncertain, and I couldn\u0026rsquo;t figure out what he was thinking.) 及ぶ (およぶ): to reach, to extend to その問題は全（ぜん）社（しゃ）に及ぶ影（えい）響（きょう）を及ぼす可（か）能（のう）性（せい）がある。 (The issue could potentially have an impact that extends across the entire company.) 折り返す (おりかえす): to turn back, to return 電車は終（しゅう）点（てん）で折り返し、再（ふたた）び発車（はっしゃ）した。(The train turned back at the terminal and departed again.) 愚か (おろか): foolish, absurd 彼の愚かな行動には驚（おどろ）かされた。 (I was shocked by his foolish behavior.) 快諾 (かいだく): enthusiastic consent, glad agreement 彼は快諾して、新しいプロジェクトに参加することになった。 (He gladly agreed and joined the new project.) 改定 (かいてい): revision, amendment 法（ほう）律（りつ）の改定が来月から施（し）行（こう）される。 (The revision of the law will be enforced starting next month.) 垣間見る (かいまみる): to glimpse, to catch a glimpse of 彼は窓から外を垣間見た。 (He caught a glimpse of the outside through the window.) 屈める (かがめる): to bend, to stoop 彼は低（ひく）いドアを通るために屈（かが）めなければならなかった。 (He had to bend down to pass through the low door.) 学芸 (がくげい): arts, liberal arts 彼は学芸の分（ぶん）野（や）で優（すぐ）れた才（さい）能（のう）を持っている。 (He has exceptional talent in the field of the liberal arts.) 隠れ家 (かくれが): hideout, retreat この町には静かな隠れ家がいくつかある。 (There are a few quiet retreats in this town.) 加工 (かこう): processing, manufacturing この工（こう）場（じょう）では金（きん）属（ぞく）の加（か）工（こう）を行（おこな）っている。 (This factory is involved in metal processing.) カムバック: comeback 彼のカムバックは多くのファンを喜（よろこ）ばせた。 (His comeback delighted many fans.) 火力 (かりょく, karyoku): firepower 戦（せん）車（しゃ）はその火力で敵（てき）を圧倒（あっとう）した。 (The tank overwhelmed the enemy with its firepower.) 簡易 (かんい): simple, easy これは簡易な手（て）順（じゅん）で解決できる問題だ。 (This is a problem that can be solved with simple steps.) 眼科 (がんか): ophthalmology, eye doctor 眼科に行って、目の検（けん）査（さ）を受けた。 (I went to the ophthalmologist to have my eyes checked.) かんかん: furious, angry 彼はかんかんに怒っていた。 (He was furious.) 着飾る (きかざる): to dress up, to adorn 彼女はパーティーに着飾って出かけた。 (She dressed up for the party and went out.) 戯曲 (ぎきょく): play, drama 彼は戯曲を書いて、舞（ぶ）台（たい）に出（しゅつ）演（えん）した。 (He wrote a play and performed in it.) 応答 (おうとう): response, reply 彼からの応答を待っている。 (I am waiting for a response from him.) 10 Your browser does not support the audio element. SHOW CONTENTS 機構 (きこう): organization, mechanism この大学には、さまざまな学（がく）術（じゅつ）機構が存在しています。(This university has various academic organizations.) この機構は、効（こう）率（りつ）的な作（さ）業（ぎょう）を支（ささ）えるために設計された。 (This mechanism was designed to support efficient work.) 記述 (きじゅつ): description, writing 彼のレポートには詳（しょう）細（さい）な記述が含（ふく）まれていた。 (His report contained detailed descriptions.) 気品 (きひん): elegance, dignity 彼女は気品に満（み）ちた態（たい）度（ど）で部屋に入ってきた。 (She entered the room with an air of elegance.) 生真面目 (きまじめ): serious, earnest 彼は生真面目で、冗（じょう）談（だん）を言うことが少（すく）ない。 (He is very earnest and rarely cracks jokes.) 逆上 (ぎゃくじょう): rage, frenzy 彼は逆上して、冷（れい）静（せい）さを失（うしな）った。 (He became enraged and lost his composure.) 急騰 (きゅうとう): sharp rise, surge 株（かぶ）価（か）は急騰し、多くの投（とう）資（し）家（か）が驚（おどろ）いた。 (The stock price surged, and many investors were surprised.) 相容れない (あいいれない): incompatible, irreconcilable 彼らの意見は相容れないものだった。 (Their opinions were irreconcilable.) 愛くるしい (あいくるしい): adorable, charming その小さな犬はとても愛くるしかった。 (The small dog was incredibly adorable.) あえて: daringly, boldly あえてその問題を指（し）摘（てき）する必要があった。 (It was necessary to boldly point out that issue.) 赤らむ (あからむ): to redden, to flush 彼は恥（は）ずかしくて顔が赤らんだ。 (He blushed because he was embarrassed.) 朝飯前 (あさめしまえ): piece of cake, easy task この問題は朝飯前の簡単なものだ。 (This problem is a piece of cake.) 当たり (あたり): hit, success, chance 新商品が当たりをとり、売（うり）上（あげ）は前（ぜん）年（ねん）比150%になった。(The new product was a hit, achieving 150% of previous year\u0026rsquo;s sales.) その投（とう）資（し）は大きな当たりだった。 (That investment was a huge success.) 扱い (あつかい): treatment, handling 彼の扱いには注意が必要だ。 (He requires careful handling.) 甘口 (あまくち): sweet (flavor), mild 彼は甘口のワインが好きだ。 (He likes sweet wines.) 案じる (あんじる): to be concerned, to worry 彼女は私の健康を案じている。 (She is concerned about my health.) 意気込み (いきごみ): enthusiasm, eagerness 彼の意気込みには感（かん）心（しん）した。 (I was impressed by his enthusiasm.) 痛手 (いたで): blow, setback その事故は会社にとって大きな痛手だった。 (The accident was a significant setback for the company.) 悼む (いたむ): to mourn, to grieve 彼の死を悼む人々（ひとびと）が集（あつ）まった。 (People gathered to mourn his death.) 著しい (いちじるしい): remarkable, significant 彼の成（せい）績（せき）は著しく向（こう）上（じょう）した。 (His performance improved significantly.) 接続 (せつぞく): connection, linking このシステムの接続は非（ひ）常（じょう）に重（じゅう）要（よう）だ。 (The connection of this system is extremely important.) 11 Your browser does not support the audio element. SHOW CONTENTS 無効 (むこう): invalid, disabled このリンクは現（げん）在（ざい）無効になっています。 (This link is currently invalid.) 視聴 (しちょう): viewing, watching 昨日は映画をオンラインで視聴した。 (I watched a movie online yesterday.) 元に戻す（もとにもどす）：To restore/return something to its original state 誤（あやま）って削（さく）除（じょ）したファイルを「元に戻す」機（き）能（のう）で復（ふく）元（げん）した。(I restored accidentally deleted files using the \u0026ldquo;Undo\u0026rdquo; function.) 確立 (かくりつ): establishment 安全な通（つう）信（しん）が確立されました。 (A secure connection has been established.) 実行 (じっこう): execution, implementation プログラムを実行（じっこう）するには、まず設定（せってい）が必要です。 (To execute the program, you need to configure it first.) 迷惑 (めいわく): nuisance, trouble 迷惑メールが大（たい）量（りょう）に届（とど）いた。 (I received a lot of spam emails.) 位置 (いち): position, location ファイルの保（ほ）存（ぞん）位置を指（し）定（てい）してください。 (Please specify the file\u0026rsquo;s save location.) 貼り付け (はりつけ): paste (text or object) コピーした内（ない）容（よう）をこの欄（らん）に貼り付けてください。 (Paste the copied content into this field.) 公開 (こうかい): release, publish 新しいアプリが昨日公開された。 (The new app was released yesterday.) 挿入 (そうにゅう): insertion 図（ず）を文（ぶん）書（しょ）に挿入してください。 (Insert the image into the document.) トークン: token (authentication or security) ログインにはトークンが必要です。 (A token is required for login.) 拡張 (かくちょう): extension, expansion このソフトには拡張機（き）能（のう）があります。 (This software has extension features.) 入力 (にゅうりょく): input パスワードを入力してください。 (Please enter your password.) 一覧 (いちらん): list, summary 商（しょう）品（ひん）の一覧を表（ひょう）示（じ）します。 (Display the product list.) 集中 (しゅうちゅう): concentration, focus 今は仕事に集中したい。 (I want to concentrate on my work now.) 端末 (たんまつ): device, terminal この端末では支（し）払（はら）いができません。 (Payment cannot be made on this device.) 不正 (ふせい): illegality, unauthorized この端末での不（ふ）正（せい）アクセスが確（かく）認（にん）されました。（Unauthorized access was detected on this terminal.） 領収書 (りょうしゅうしょ): receipt 会（かい）計（けい）の際（さい）に領収書をもらった。 (I received a receipt at checkout.) 承認 (しょうにん): approval, authorization 管（かん）理（り）者（しゃ）の承認が必要です。 (Administrator approval is required.) 受領 (じゅりょう): receipt (of goods, documents, etc.) 書（しょ）類（るい）の受領を確（かく）認（にん）しました。 (I confirmed the receipt of the documents.) 12 Your browser does not support the audio element. SHOW CONTENTS 一連 (いちれん): a series, a sequence 一連の事件について調（ちょう）査（さ）が行（おこな）われている。(An investigation is being conducted into the series of incidents.) 違和感 (いわかん): sense of discomfort, unease 彼の話し方に少し違和感を覚（おぼ）えた。(I felt a bit of discomfort with the way he spoke.) 運用 (うんよう): operation, practical use 新しいシステムの運用が始まった。(The operation of the new system has begun.) 婉曲 (えんきょく): euphemistic, indirect 彼は婉曲な表（ひょう）現（げん）で断（ことわ）った。(He declined in an indirect way.) 応急 (おうきゅう): emergency, temporary 応急処（しょ）置（ち）を施（ほどこ）した後（あと）、病院へ運（はこ）ばれた。(After giving emergency treatment, they were taken to the hospital.) 大物 (おおもの): big shot, important person あの政治家は政（せい）界（かい）の大物だ。(That politician is a big figure in the political world.) 送り状 (おくりじょう): invoice, delivery note 商品と一緒に送り状を同（どう）封（ふう）してください。(Please include the delivery note with the goods.) お袋 (おふくろ): (my) mother (colloquial) 久しぶりにお袋の料理が食べたい。(I want to eat my mom’s cooking—it’s been a while.) 解剖 (かいぼう): dissection, autopsy 死（し）因（いん）を調（しら）べるために解剖が行（おこな）われた。(An autopsy was conducted to determine the cause of death.) 皆無 (かいむ): nonexistent, none at all 経（けい）験（けん）は皆無ですが、やる気はあります。(I have no experience, but I’m highly motivated.) 掻き回す (かきまわす): stir up, disturb スープをよく掻（か）き回（まわ）してください。(Please stir the soup well.) 拡散 (かくさん): diffusion, spread SNSで情（じょう）報（ほう）が急（きゅう）速（そく）に拡散した。(The information spread rapidly on social media.) 構え (かまえ): stance, posture, readiness 彼は戦（たたか）う構えを見せた。(He took a fighting stance.) 辛うじて (かろうじて): barely, narrowly 辛うじて終電に間に合った。(I barely caught the last train.) 完結 (かんけつ): conclusion, completion シリーズがついに完結した。(The series finally concluded.) 刊行 (かんこう): publication, issue 新しい辞（じ）典（てん）が来月刊行される。(The new dictionary will be published next month.) 話し合い (はなしあい): discussion, negotiation 両（りょう）者（しゃ）の話し合いは平（へい）行（こう）線（せん）のままだった。(The discussion between the two parties remained deadlocked.) 尊重 (そんちょう): respect, esteem 相手の意見を尊重すべきだ。(We should respect the other person’s opinion.) 事象 (じしょう): event, phenomenon 自然界の事象には不（ふ）思（し）議（ぎ）なものが多い。(There are many mysterious phenomena in nature.) 以下 (いか): below, less than 彼の成（せい）績（せき）は平（へい）均（きん）以下だった。(His grades were below average.) 13 Your browser does not support the audio element. SHOW CONTENTS 簡素 (かんそ): simplicity, plainness 彼の家は簡素だが、とても居（い）心（ごこ）地（ち）がよい。(His house is simple, but very comfortable.) 気さく (きさく): friendly, open-hearted 彼女はとても気さくで、初（しょ）対（たい）面（めん）でも話しやすい。(She’s very friendly and easy to talk to, even for the first time.) 鍛える (きたえる): to train, to forge 体を鍛えるために毎日ジムに通っている。(I go to the gym every day to train my body.) 技能 (ぎのう): skill, technical ability 技能を身（み）につければ、就（しゅう）職（しょく）に有（ゆう）利（り）になる。(Acquiring skills makes it easier to get a job.) 規範 (きはん): standard, norm 社会の規範に従（したが）うことが求（もと）められる。(You are expected to follow the norms of society.) 起伏 (きふく): ups and downs, undulation 起伏の多い人（じん）生（せい）だったが、後（こう）悔（かい）はない。(My life has had many ups and downs, but I have no regrets.) 窮屈 (きゅうくつ): tight, cramped, constrained この靴は窮屈で長く歩けない。(These shoes are too tight to walk in for long.) 競合 (きょうごう): competition, rivalry 他（た）社（しゃ）との競合が激（はげ）しくなっている。(The competition with other companies is intensifying.) 相次ぐ (あいつぐ): to happen one after another 事故が相次いで発生（はっせい）した。(Accidents occurred one after another.) 悪どい (あくどい): vicious, malicious, dishonest 彼のやり方はあまりにも悪どい。(His methods are far too malicious.) 圧迫 (あっぱく): pressure, oppression 胸（むね）に圧迫感を感じたら、すぐに病院へ。(If you feel pressure in your chest, go to the hospital immediately.) 言い張る (いいはる): to insist, to assert 彼は自分が正しいと最後まで言い張（は）った。(He insisted he was right until the very end.) 家路 (いえじ): the road home 家路を急（いそ）いでいたら、突（とつ）然（ぜん）雨が降ってきた。(While hurrying home, it suddenly started to rain.) 意地 (いじ): stubbornness, willpower 意地を張（は）らずに素（す）直（なお）に謝（あやま）るべきだ。(You should stop being stubborn and just apologize.) 委託 (いたく): entrustment, outsourcing 業（ぎょう）務（む）の一（いち）部（ぶ）を外（がい）部（ぶ）に委託した。(Part of the work was outsourced.) 痛める (いためる): to injure, to hurt 無（む）理（り）に走って膝（ひざ）を痛めてしまった。(I hurt my knee by running too hard.) 卑しい (いやしい): greedy, vulgar, lowly お金に卑しい人とは付き合いたくない。(I don\u0026rsquo;t want to associate with someone who\u0026rsquo;s greedy for money.) 慰留 (いりゅう): persuasion to stay, urging not to resign 上（じょう）司（し）から慰留されたが、退（たい）職（しょく）を決（けつ）意（い）した。(Though my boss urged me to stay, I decided to resign.) 色合い (いろあい): shade, hue, color tone この絵は優しい色合いで癒（いや）される。(This painting has soothing colors and is comforting.) 通常 (つうじょう): normal, usual 通常は9時に開（かい）店（てん）します。(It usually opens at 9 o\u0026rsquo;clock.) 14 Your browser does not support the audio element. SHOW CONTENTS 後ろ盾 (うしろだて): backing, support, patron 彼には有（ゆう）力（りょく）な後ろ盾がいる。(He has powerful backing.) 梅干 (うめぼし): pickled plum お弁当に梅干が入っている。(There’s a pickled plum in the lunchbox.) 円滑 (えんかつ): smooth, harmonious 会議は円滑に進（しん）行（こう）した。(The meeting went smoothly.) 横転 (おうてん, ōten): overturn, rollover トラックが横転して通行止めになった。(A truck overturned, blocking traffic.) 大幅 (おおはば): significant, drastic 売上が大幅に増（ぞう）加（か）した。(Sales increased significantly.) 大まか (おおまか): rough, approximate 大まかな計画を立てた。(We made a rough plan.) 重苦しい (おもくるしい): oppressive, heavy (atmosphere) 部屋の空気が重苦しかった。(The atmosphere in the room was heavy.) 改行 (かいぎょう): line break 文を読みやすくするために改行した。(I inserted line breaks to make the text easier to read.) 回送 (かいそう): out-of-service (vehicle); forwarding このバスは回送中です。(This bus is in transit.) 回覧 (かいらん): circulation (of documents, etc.) 書類を部（ぶ）署（しょ）内（ない）で回覧してください。(Please circulate the document within the department.) 駆け足 (かけあし): running; quick pace 駅まで駆け足で向かった。(I ran to the station.) 肩代わり (かたがわり): taking over someone\u0026rsquo;s debt/responsibility 親が借金を肩代わりした。(The parents took over the debt.) 稼働 (かどう): operation, working (of machinery, etc.) 工場は24時間稼働している。(The factory operates 24 hours a day.) 軽んじる (かろんじる): to belittle, to make light of 規（き）則（そく）を軽んじてはいけない。(You shouldn’t take the rules lightly.) 緩和 (かんわ): easing, relaxation, mitigation 規制（きせい）が緩和された。(The regulations were eased.) 気合 (きあい): fighting spirit, motivation 試合前に気合を入れた。(I psyched myself up before the match.) 伴う (ともなう): to accompany, to entail リスクを伴う決（けつ）断（だん）だった。(It was a decision that involved risk.) 力 (ちから): power, strength 彼の力を借りて問題を解決した。(I solved the problem with his help.) 論理 (ろんり): logic, reasoning 彼の話には論理が通っている。(His argument is logically sound.) 読み書き (よみかき): reading and writing 読み書きの能力を伸（の）ばす。(Develop your reading and writing skills.) 15 Your browser does not support the audio element. SHOW CONTENTS 絆 (きずな): bond, emotional connection 家族の絆はとても強い。 (The bond within the family is very strong.) 強烈 (きょうれつ): intense, strong 強烈な印（いん）象（しょう）を受けた。(I got a strong impression.) 極端 (きょくたん): extreme 彼の意見は極端すぎる。(His opinion is too extreme.) 亀裂 (きれつ): crack, rift 壁に亀裂が入っている。(There’s a crack in the wall.) 切り（きり）: end, limit, cut-off この仕事はきりがない。(This work has no end.) 究める (きわめる): to master, to investigate thoroughly 技（ぎ）術（じゅつ）を究めるのは難しい。(It’s difficult to master a skill.) 形成 (けいせい): formation チームの形成には時間がかかる。(It takes time to form a team.) 形勢 (けいせい): situation, condition (esp. in competition or battle) 試合の形勢が逆（ぎゃく）転（てん）した。(The tide of the game has turned.) 桁 (けた): digit, column 彼の収入は桁違いだ。(His income is on a completely different level.) 権力 (けんりょく): power, authority 彼は絶（ぜつ）大（だい）な権力を持っている。(He holds immense power.) 高額 (こうがく, kōgaku): high amount (money) 高額な商品の購（こう）入（にゅう）には注意が必要だ。(Be cautious when purchasing expensive items.) 構想 (こうそう): concept, vision, plan 新しいビルの構想が発表（はっぴょう）された。(The vision for the new building was announced.) 光沢 (こうたく): gloss, shine, luster この布（ぬの）には美しい光沢がある。(This fabric has a beautiful sheen.) 工程 (こうてい): process, stage of work 製造工程を見学した。(We toured the manufacturing process.) 構内 (こうない): premises, grounds (esp. school, station) 駅構内は混（こん）雑（ざつ）している。(The station premises are crowded.) 効用 (こうよう): usefulness, benefit, effect この薬には即（そっ）効（こう）性（せい）の効用がある。(This medicine has immediate benefits.) 公用 (こうよう): official business, government use 公用車で移（い）動（どう）した。(He traveled in an official vehicle.) 相性 (あいしょう): compatibility, affinity 二人の相性は抜（ばつ）群（ぐん）だ。(Their compatibility is excellent.) 割合 (わりあい): ratio, proportion 若（わか）者（もの）の割合が増（ふ）えている。(The proportion of young people is increasing.) 即時 (そくじ): immediate, instantly 彼は即時に対応した。(He responded immediately.) 16 Your browser does not support the audio element. SHOW CONTENTS あっけない: unsatisfying, disappointing, too quick (end) 試合はあっけない結（けつ）末（まつ）だった。(The match ended in an unsatisfying way.) 後回し (あとまわし): postponement, putting off 宿題を後（あと）回（まわ）しにして遊んだ。(I postponed my homework and played.) 誂える (あつらえる): to order, to have something made to order スーツを誂えた。(I had a suit made to order.) 合わす (あわす): to match, to combine (colloquial/formal of 合わせる) 力（ちから）を合わして頑（がん）張（ば）ろう。(Let’s join forces and do our best.) 暗示 (あんじ): hint, suggestion, implication 彼の言葉には暗示が含(ふく)まれていた。(His words contained a hint.) 言い分 (いいぶん): one\u0026rsquo;s say, argument, point of view 彼の言い分にも一（いち）理（り）ある。(His argument also makes some sense.) 憤り (いきどおり): indignation, anger 彼は不（ふ）当（とう）な扱（あつか）いに深い憤りを感じていた。(He felt deep indignation at the unfair treatment.) 幾多 (いくた): many, numerous 幾多の困難を乗り越えた。(He overcame many hardships.) 依然 (いぜん): still, as yet 問題は依然として解決していない。(The problem remains unsolved.) 痛ましい (いたましい): pitiful, heartbreaking 痛ましい事故が起きた。(A heartbreaking accident occurred.) 至れり尽くせり (いたれりつくせり): perfect service, thoroughly attentive 至れり尽くせりのサービスだった。(The service was perfect and thorough.) 労わる (いたわる): to care for, to be kind to 高（こう）齢（れい）者（しゃ）を労わる気持ちが大切だ。(It’s important to care for the elderly.) 一概に (いちがいに): categorically, indiscriminately それを一概に悪いとは言えない。(You can’t categorically say it’s bad.) 一か八か (いちかばちか): hit or miss, sink or swim 一か八かで試験を受けた。(I took the exam as a gamble.) 偽る (いつわる): to lie, to deceive 年齢を偽った。(He lied about his age.) 嫌味 (いやみ): sarcasm, unpleasantness 彼の嫌味な言い方に腹（はら）が立つ。(His sarcastic tone makes me angry.) 後ろめたい (うしろめたい): guilty, feeling uneasy 嘘をついたことが後ろめたい。(I feel guilty about lying.) 厚い (あつい): thick, deep (emotionally), warm-hearted 友（ゆう）情（じょう）が厚い。(Their friendship is deep.) 飴 (あめ): candy 子供に飴をあげた。(I gave candy to the child.) 田舎 (いなか): countryside, rural area 夏休みに田舎へ帰る。(I go back to the countryside during summer vacation.) 17 Your browser does not support the audio element. SHOW CONTENTS 打ち消し (うちけし): negation, denial 彼はその噂（うわさ）を打ち消した。(He denied the rumor.) 埋め立てる (うめたてる): to reclaim land, to fill in 海を埋め立てて新しい町を作った。(They reclaimed land from the sea to build a new town.) 運営 (うんえい): management, operation 学（がく）園（えん）祭（さい）の運営は学生が担（たん）当（とう）する。(The students are responsible for managing the school festival.) エキゾチック: exotic 彼女はエキゾチックな魅力を持っている。(She has an exotic charm.) 円高 (えんだか): appreciation of the yen 円高で輸（ゆ）出（しゅつ）企業は苦（くる）しんでいる。(Export companies are struggling due to the strong yen.) 大らか (おおらか): generous, broad-minded 彼は大らかな性（せい）格（かく）で、細（こま）かいことは気にしない。(He is generous and doesn’t worry about small things.) 臆病 (おくびょう): cowardly, timid 臆病で発（はつ）言（げん）できなかった。(I was too timid to speak.) 推し進める (おしすすめる): to press forward, to advance 政府は改（かい）革（かく）を推し進めている。(The government is pushing reforms forward.) 億劫 (おっくう): troublesome, tiresome 外（がい）出（しゅつ）するのが億劫だ。(Going out feels like a bother.) 思わしい (おもわしい): satisfactory, favorable 手（しゅ）術（じゅつ）後（ご）の経（けい）過（か）は思わしくない。(The recovery after surgery is not favorable.) 親兄弟 (おやきょうだい): one\u0026rsquo;s parents and siblings 親兄弟に心配をかけたくない。(I don’t want to worry my family.) 外貨 (がいか): foreign currency 海（かい）外（がい）旅行前に外貨を両（りょう）替（がえ）する。（Exchange foreign currency before traveling abroad.） 該当 (がいとう): relevant, applicable 該当する項（こう）目（もく）をチェックしてください。(Please check the applicable items.) 輝かしい (かがやかしい): brilliant, glorious 彼は輝かしい経（けい）歴（れき）を持っている。(He has a brilliant career.) 画策 (かくさく): scheme, planning (often strategic) 政（せい）権（けん）奪（だっ）取（しゅ）を画策している。(He is scheming to take power.) 格別 (かくべつ): exceptional, particularly 格別な対（たい）応（おう）に感謝します。(Thank you for your exceptional service.) 叶う (かなう): to come true, to be realized 長（なが）年（ねん）の夢が叶った。(A long-held dream came true.) 合点 (がってん): understanding, agreement (colloquial) 合点がいかない説明だ。(That explanation doesn’t make sense to me.) 祝う (いわう): to celebrate 結婚を祝うパーティーが開（ひら）かれた。(A party was held to celebrate the wedding.) 薄い (うすい): thin, weak (in color, flavor, etc.) このスープは味（あじ）が薄（うす）い。(This soup is bland.) 18 Your browser does not support the audio element. SHOW CONTENTS 兼ね備える (かねそなえる): to possess both, to combine 彼は知（ち）性（せい）とユーモアを兼ね備えている。(He possesses both intelligence and humor.) 構える (かまえる): to set up, to prepare, to adopt a posture 店を構える夢がある。(I have a dream of setting up my own shop.) 絡む (からむ): to entangle, to get involved 糸（いと）が絡んでしまった。(The threads got tangled.) 慣性 (かんせい): inertia 慣性の法（ほう）則（そく）に従（したが）って物（ぶっ）体（たい）は動（うご）き続（つづ）ける。(Objects continue to move due to the law of inertia.) 元年 (がんねん): first year (of an era) 平（へい）成（せい）元年に生まれた。(I was born in the first year of the Heisei era.) 完璧 (かんぺき): perfect, flawless 彼のプレゼンは完（かん）璧（ぺき）だった。(His presentation was perfect.) 勧誘 (かんゆう): solicitation, invitation クラブ活（かつ）動（どう）に勧誘された。(I was invited to join a club.) 規格 (きかく): standard, norm この部（ぶ）品（ひん）は国（こく）際（さい）規（き）格（かく）に合（あ）っている。(This part meets international standards.) 競う (きそう): to compete 両チームは優（ゆう）勝（しょう）を競っている。(The two teams are competing for the championship.) 強行 (きょうこう): enforcement, pushing through (by force) 法（ほう）案（あん）が強行採（さい）決（けつ）された。(The bill was forcibly passed.) 業績 (ぎょうせき): achievement, performance 昨（さく）年（ねん）の業績が大きく伸（の）びた。(Last year’s performance improved significantly.) 局限 (きょくげん): limitation, restriction 話（わ）題（だい）を一つに局限して議（ぎ）論（ろん）する。(Let’s limit the discussion to one topic.) 切れる (きれる): to cut, to run out, to be sharp, to lose temper この包（ほう）丁（ちょう）はよく切（き）れる。(This knife cuts well.) 極めて (きわめて): extremely これは極（きわ）めて重（じゅう）要（よう）な問題だ。(This is an extremely important issue.) 均衡 (きんこう): balance, equilibrium 力（ちから）の均衡が崩（くず）れた。(The balance of power has collapsed.) 相方 (あいかた): partner (esp. in comedy or work) 相方と息（いき）が合（あ）っている。(I’m in sync with my partner.) 諦め (あきらめ): resignation, giving up 諦めの早さが成功を遠（とお）ざける。(Giving up easily keeps success away.) 鮮やか (あざやか): vivid, brilliant, skillful 鮮やかな手さばきに驚（おどろ）いた。(I was amazed by the skillful hand movements.) 足がかり (あしがかり): foothold, starting point 彼の紹介が足がかりとなった。(His introduction served as a foothold.) 扱い (あつかい): treatment, handling VIPとしての扱いを受けた。(I was treated as a VIP.) 19 Your browser does not support the audio element. SHOW CONTENTS 歩む (あゆむ): to walk, to go through (life, path) 彼は苦（く）難（なん）の道（みち）を歩んできた。(He has walked a path full of hardships.) 居座る (いすわる): to remain, to stay without leaving 客が遅くまで居座った。(The guests stayed too long.) 依存 (いそん / いぞん): dependence, reliance スマホへの依存が問題になっている。(Dependence on smartphones is becoming a problem.) 一眼レフ (いちがんレフ): single-lens reflex camera (SLR) 一眼レフで風（ふう）景（けい）を撮（さつ）影（えい）するのが好きだ。(I enjoy taking landscape photos with my SLR.) 一抹 (いちまつ): a touch, a hint (usually of emotion or feeling) 一抹の不（ふう）安（あん）がよぎった。(A touch of anxiety crossed my mind.) 一様 (いちよう): uniform, equal, same 一様に意見を述（の）べた。(Everyone gave their opinion in the same way.) 逸材 (いつざい): outstanding talent チームに逸材が加（くわ）わった。(An outstanding talent joined the team.) 嫌がらせ (いやがらせ): harassment 彼は職（しょ）場（くば）で嫌がらせを受けている。(He is being harassed at work.) 受け入れる (うけいれる): to accept, to receive 彼の謝（しゃ）罪（ざい）を受け入れた。(I accepted his apology.) 後ろ向き (うしろむき): backward-looking, negative, passive 後ろ向きな考（かんが）え方（かた）はやめよう。(Let’s stop thinking negatively.) 打ち込む (うちこむ): to be devoted to, to shoot/strike into 研（けん）究（きゅう）に打ち込んでいる。(I’m deeply devoted to research.) 潤う (うるおう): to be moist, to enrich 雨で田（た）畑（はた）が潤った。(The rain enriched the fields.) 運搬 (うんぱん): transportation, carriage 荷物の運搬を頼まれた。(I was asked to transport the luggage.) エッセー: essay 旅行についてのエッセーを書く。(I’ll write an essay about my trip.) 得手 (えて): forte, strong point 英語は彼の得手だ。(English is his strong point.) 演出 (えんしゅつ): production, direction (in a play, event) 舞（ぶ）台（たい）の演（えん）出（しゅつ）が素晴らしかった。(The stage direction was amazing.) 大方 (おおかた): mostly, probably 大方の予（よ）想（そう）通りだった。(It was as most people expected.) 大御所 (おおごしょ): veteran, authority, great figure 音楽界の大御所に会った。(I met a veteran in the music world.) 遅らせる (おくらせる): to delay, to postpone 出（しゅっ）発（ぱつ）を一時間遅らせた。(We delayed the departure by one hour.) お手上げ (おてあげ): at one’s wit’s end, giving up この問題は難しすぎてお手上げだ。(This problem is too hard—I give up.) 20 SHOW CONTENTS 自ずと (おのずと): naturally, automatically 努力すれば結果は自ずと現れる。(If you work hard, the results will naturally follow.) 思いやり (おもいやり): compassion, consideration 彼は思いやりのある人だ。(He is a compassionate person.) 赴く (おもむく): to go toward, to proceed to 現場に赴いた。(I went to the site.) 改悪 (かいあく): deterioration (due to revision), change for the worse 新制度は改悪だと言われている。(The new system is said to be a step backward.) 概要 (がいよう): summary, outline 計画の概要を説明してください。(Please explain the outline of the plan.) 覚醒剤 (かくせいざい): stimulant (often illegal drugs) 覚醒剤の所持で逮捕された。(He was arrested for possessing stimulants.) 仮説 (かせつ): hypothesis 仮説を立てて実験を行う。(Form a hypothesis and conduct an experiment.) 頑な (かたくな): stubborn, obstinate 彼は頑なに意見を変えなかった。(He stubbornly refused to change his opinion.) 勝ち組 (かちぐみ): winners (in society) 勝ち組として成功を収めた。(He succeeded as part of the winning group.) 叶える (かなえる): to grant (a wish), to fulfill 夢を叶えるために努力する。(Work hard to make your dreams come true.) 活発 (かっぱつ): active, lively 子供たちは活発に遊んでいる。(The children are playing actively.) 過密 (かみつ): overcrowded, dense 都市部は過密状態にある。(Urban areas are overcrowded.) 駆られる (かられる): to be driven by (emotion, desire) 好奇心に駆られて質問した。(Driven by curiosity, I asked.) 完工 (かんこう): completion of construction ビルは今月完工予定だ。(The building is scheduled for completion this month.) 聞き逃す (ききのがす): to fail to catch (what someone said) 名前を聞き逃してしまった。(I missed hearing the name.) 気質 (きしつ): temperament, disposition 彼は職人気質だ。(He has the temperament of an artisan.) 寄贈 (きそう / きぞう): donation, presentation (usually of goods) 学校にピアノを寄贈した。(A piano was donated to the school.) 生まれる (うまれる): to be born 彼は東京で生まれた。(He was born in Tokyo.) 上着 (うわぎ): jacket, coat 上着を脱いでください。(Please take off your jacket.) 絵葉書 (えはがき): picture postcard 旅行先から絵葉書を送った。(I sent a picture postcard from my trip.) 21 SHOW CONTENTS 気まぐれ (きまぐれ): whim, capriciousness 彼の気まぐれには振り回される。(I\u0026rsquo;m always at the mercy of his whims.) 嗅覚 (きゅうかく): sense of smell, intuition 犬は人間よりもはるかに鋭い嗅覚を持っている。(Dogs have a far superior sense of smell than humans.) 脚立 (きゃたつ): stepladder 蛍光灯を替えるために脚立を使った。(I used a stepladder to change the fluorescent light.) キャリア: career; carrier (context-dependent) 彼女はキャリアウーマンとして成功している。(She has succeeded as a career woman.) 愛顧 (あいこ): patronage, favor いつもご愛顧ありがとうございます。(Thank you for your continued patronage.) 愛想 (あいそ / あいそう): friendliness, sociability 彼女は誰にでも愛想がいい。(She\u0026rsquo;s friendly to everyone.) 朝方 (あさがた): early morning 朝方に雨が降ったようだ。(It seems it rained in the early morning.) 仇 (あだ): foe, enemy; revenge 父の仇を討つ。(Avenge my father\u0026rsquo;s death.) 圧勝 (あっしょう): overwhelming victory チームは圧勝で決勝に進んだ。(The team advanced to the finals with an overwhelming victory.) 案の定 (あんのじょう): just as expected 案の定、彼は遅刻した。(As expected, he was late.) 息抜き (いきぬき): breather, relaxation 息抜きに散歩した。(I went for a walk to take a break.) 異動 (いどう): job transfer 来月、本社に異動することになった。(I will be transferred to the head office next month.) 今にして (いまにして): only now, in hindsight 今にして思えば、あれが分かれ道だった。(Looking back now, that was the turning point.) 嫌気 (いやけ): disgust, weariness 勉強に嫌気が差した。(I got sick of studying.) 受け継ぐ (うけつぐ): to inherit, to succeed 家業を受け継いだ。(I inherited the family business.) 請け合う (うけあう): to guarantee, to assure 成功は私が請け合います。(I guarantee the success.) 埋める (うめる): to fill, to bury 穴を埋めた。(I filled the hole.) 紆余曲折 (うよきょくせつ): twists and turns, complications 紆余曲折を経て成功した。(I succeeded after many twists and turns.) 縁起物 (えんぎもの): good luck charm 招き猫は縁起物として人気がある。(Maneki-neko is popular as a lucky charm.) 追い出す (おいだす): to expel, to drive out 部屋から追い出された。(I was driven out of the room.) 22 SHOW CONTENTS 大筋 (おおすじ): outline, general gist 話の大筋は理解できた。(I understood the general gist of the story.) 大空 (おおぞら): the sky, vast sky 大空に飛行機雲が伸びている。(A contrail stretches across the vast sky.) 冒す (おかす): to brave (danger), to risk 命を冒してまで助けようとした。(He risked his life to save them.) 階層 (かいそう): hierarchy, class, layer 社会の階層構造について学ぶ。(We learn about the hierarchical structure of society.) 介入 (かいにゅう): intervention 政府が市場に介入した。(The government intervened in the market.) 概念 (がいねん): concept, notion 自由という概念は人によって異なる。(The concept of freedom differs by person.) 顔負け (かおまけ): being put to shame 彼の料理の腕前はプロも顔負けだ。(His cooking skills put even professionals to shame.) 屈む (かがむ): to crouch, to bend down 子供が地面に屈んで遊んでいた。(The child was crouching and playing on the ground.) 隔日 (かくじつ): every other day 隔日でごみを回収する。(Garbage is collected every other day.) 託ける (かこつける): to use as an excuse 忙しさに託けて連絡を怠った。(I neglected to contact them, using busyness as an excuse.) 活性化 (かっせいか): revitalization, activation 地域経済の活性化が求められている。(Revitalization of the local economy is needed.) 加味 (かみ): to take into account, to add (ingredients, factors) 諸事情を加味して判断する。(I judge after taking all circumstances into account.) 慣習 (かんしゅう): custom, convention 昔の慣習が今も残っている。(Old customs still remain today.) 感性 (かんせい): sensitivity, sensibility 芸術に対する感性が豊かだ。(She has a rich sensibility for art.) 勘当 (かんどう): disowning, being cut off (from a family) 父に勘当されて家を出た。(I was disowned by my father and left home.) 慣用 (かんよう): common usage, customary 慣用表現を覚えると会話が自然になる。(Learning idiomatic expressions makes conversation more natural.) 気兼ね (きがね): hesitation, constraint 気兼ねせずにくつろいでください。(Please relax without hesitation.) 貫禄 (かんろく): presence, dignity 部長は貫禄がある。(The department manager has an air of authority.) 淡い (あわい): pale, faint, fleeting 淡いピンクの花が咲いていた。(Pale pink flowers were blooming.) 生きる (いきる): to live 何のために生きるのかを考える。(I think about what I live for.) 23 SHOW CONTENTS 決まって (きまって): always, without fail 彼は決まって朝7時に起きる。(He always wakes up at 7 a.m.) 決まり文句 (きまりもんく): set phrase, cliché 「頑張ってね」はよくある決まり文句だ。(“Do your best” is a common cliché.) 気味悪い (きみわるい): creepy, eerie 気味悪い音が聞こえた。(I heard a creepy sound.) 気難しい (きむずかしい): hard to please, moody 祖父は気難しい性格だ。(My grandfather is hard to please.) 究明 (きゅうめい): investigation, clarification 事故の原因を究明する。(We investigate the cause of the accident.) 器量 (きりょう): looks, ability, talent 彼女は器量も性格も良い。(She has both looks and a good personality.) 煌びやか (きらびやか): dazzling, glittering 煌びやかな衣装を身にまとう。(She wears a dazzling costume.) 区切り (くぎり): division, end, punctuation ここで一つの区切りをつけよう。(Let’s make a break here.) 傾斜 (けいしゃ): slope, tilt, inclination 傾斜のある道を登る。(We climb a sloped road.) 景品 (けいひん): prize, giveaway 抽選で景品が当たった。(I won a prize in a lottery.) 原告 (げんこく): plaintiff 原告は損害賠償を求めている。(The plaintiff is seeking compensation.) 皇居 (こうきょ): Imperial Palace 観光で皇居を訪れた。(We visited the Imperial Palace as tourists.) 香辛料 (こうしんりょう): spices 香辛料をたっぷり使った料理だ。(This dish uses a lot of spices.) 厚生 (こうせい): welfare, public health 厚生労働省は健康促進を呼びかけている。(The Ministry of Health, Labour and Welfare is promoting public health.) 合弁 (ごうべん): joint venture 外国企業と合弁会社を設立した。(We established a joint venture with a foreign company.) 志 (こころざし): will, ambition, aspiration 志を高く持つことが大切だ。(It’s important to have high aspirations.) 後日 (ごじつ): at a later date 後日、詳しく説明します。(I will explain in detail at a later date.) 拗れる (こじれる): to become complicated, to get worse 話が拗れて交渉が中断した。(The discussion got complicated and negotiations broke off.) 懲りる (こりる): to learn one’s lesson, to be discouraged by 失敗に懲りて次は慎重にした。(I learned from my failure and was more cautious next time.) 根源 (こんげん): root, source, origin 問題の根源を探る。(We search for the root of the problem.) 24 SHOW CONTENTS 相手取る (あいてどる): to sue, to take someone to court 会社は顧客を相手取って訴訟を起こした。(The company sued the customer.) 合間 (あいま): interval, break, spare moment 勉強の合間に散歩した。(I took a walk during a break from studying.) 明かす (あかす): to reveal, to disclose 秘密を明かしてしまった。(I ended up revealing the secret.) 悪徳 (あくとく): immorality, unethical behavior 悪徳商法に注意してください。(Be careful of unethical business practices.) 垢 (あか): dirt, grime, dead skin お風呂に入って垢を落とした。(I took a bath and scrubbed off the grime.) あっさり: easily, lightly, without fuss 彼は試合にあっさり負けた。(He lost the match easily.) 味わい (あじわい): flavor, taste, charm この料理は深い味わいがある。(This dish has a rich flavor.) 褪せる (あせる): to fade (color), to lose brilliance 日に当たって色が褪せた。(The color faded in the sun.) 危なげない (あぶなげない): safe-looking, steady 危なげない運転で安心した。(His steady driving reassured me.) 穴埋め (あなうめ): filling in, gap-filling 穴埋め問題を解いてください。(Please solve the fill-in-the-blank questions.) 斡旋 (あっせん): mediation, arrangement 求人の斡旋を受けた。(I received a job placement referral.) 跡継ぎ (あとつぎ): heir, successor 跡継ぎとして会社を継いだ。(I took over the company as the successor.) 油絵 (あぶらえ): oil painting 趣味で油絵を描いている。(I paint oil paintings as a hobby.) あらかた: mostly, almost all 仕事はあらかた終わった。(The work is mostly done.) 雨足 (あまあし): intensity of rainfall 雨足が強くなってきた。(The rain is getting heavier.) 安静 (あんせい): rest, staying quiet しばらく安静が必要です。(You need to rest for a while.) 当て (あて): aim, expectation, reliance この計画に当てはない。(There’s no specific aim for this plan.) 行き先 (いきさき): destination 行き先を教えてください。(Please tell me your destination.) 幾つか (いくつか): several, a few 幾つかの案を提示した。(I presented several proposals.) 石 (いし): stone, rock 庭に大きな石がある。(There is a large stone in the garden.) 25 SHOW CONTENTS 移行 (いこう): transition, switch 新しいシステムへの移行が進んでいる。(The transition to the new system is underway.) 雨具 (あまぐ): rain gear 念のために雨具を持って行こう。(Let’s bring rain gear just in case.) 今や (いまや): now (emphasizing contrast with the past) 彼は今や有名な俳優だ。(He is now a famous actor.) 操る (あやつる): to manipulate, to operate 彼は数カ国語を自由に操る。(He fluently speaks several languages.) 入り用 (いりよう): need, necessity, expense 今月は何かと入り用が多い。(There are many expenses this month.) 危ぶむ (あやぶむ): to fear, to have doubts 彼の成功は危ぶまれていた。(His success was in doubt.) 内幕 (うちまく): inside story, behind-the-scenes 事件の内幕が暴かれた。(The inside story of the case was revealed.) 荒らす (あらす): to devastate, to damage 泥棒が部屋を荒らしていった。(The thief ransacked the room.) 疎い (うとい): unfamiliar, ignorant 私は政治に疎いです。(I’m not familiar with politics.) 荒っぽい (あらっぽい): rough, violent 荒っぽい言葉は控えましょう。(Let’s avoid rough language.) 威嚇 (いかく): threat, intimidation 犬が威嚇して吠えている。(The dog is barking threateningly.) 閲覧 (えつらん): viewing, inspection 書類は自由に閲覧できます。(You may freely view the documents.) 育成 (いくせい): training, nurturing 若手社員の育成に力を入れている。(We are focusing on training young employees.) 潔い (いさぎよい): gracious, manly, without regret 彼は潔く負けを認めた。(He admitted defeat graciously.) 追い込む (おいこむ): to corner, to drive into 彼を絶体絶命の状況に追い込んだ。(He was driven into a desperate situation.) 衣装 (いしょう): costume, outfit 舞台の衣装がとても豪華だった。(The stage costumes were very elaborate.) 大柄 (おおがら): large build, large pattern 彼は大柄な体格をしている。(He has a large build.) 移植 (いしょく): transplant, implantation 臓器移植の手術が行われた。(An organ transplant operation was performed.) 至る (いたる): to reach (a stage or place) 合意に至るまで長い議論があった。(There were long discussions before reaching an agreement.) 従兄弟 (いとこ): cousin (male) 従兄弟と夏休みに遊んだ。(I played with my cousin during summer vacation.) 26 SHOW CONTENTS 大げさ (おおげさ): exaggerated, dramatic 彼はいつも話を大げさにする。(He always exaggerates things.) 挑む (いどむ): to challenge, to take on 彼は世界記録に挑んだ。(He challenged the world record.) 親孝行 (おやこうこう): filial piety, being a good son/daughter 親孝行したいときに親はなし。(When you want to be filial, your parents are no longer there.) 請け負う (うけおう): to undertake, to contract その仕事は私が請け負います。(I’ll take on that job.) 温和 (おんわ): mild, gentle 彼は温和な性格の持ち主だ。(He has a gentle personality.) 腕前 (うでまえ): skill, ability 彼の料理の腕前はプロ並みだ。(His cooking skills are like a pro\u0026rsquo;s.) カウンセラー: counselor 学校にはカウンセラーが常駐している。(There is a counselor stationed at the school.) 鵜呑み (うのみ): swallowing whole (literally or figuratively), accepting without question 噂を鵜呑みにしてはいけない。(You shouldn\u0026rsquo;t take rumors at face value.) かき乱す (かきみだす): to disturb, to throw into confusion 彼の発言が会議をかき乱した。(His comment disrupted the meeting.) 上向く (うわむく): to improve, to look up 景気が上向いてきた。(The economy has started to look up.) 箇条書き (かじょうがき): itemization, bullet points 意見を箇条書きでまとめてください。(Please list your opinions in bullet points.) 横着 (おうちゃく): laziness, cheekiness 横着しないでちゃんとやりなさい。(Stop being lazy and do it properly.) 合致 (がっち): agreement, conformity 彼の証言は事実と合致している。(His testimony matches the facts.) 陥る (おちいる): to fall into (a trap, condition) パニックに陥るな。(Don’t fall into panic.) 敵う (かなう): to match, to compete with; to be possible 彼には敵わない。(I can’t match him.) 今日は暑くて敵わない。(It’s unbearably hot today.) 自ずから (おのずから): naturally, of itself 努力すれば自ずから道は開ける。(If you work hard, the path will naturally open.) 醸し出す (かもしだす): to create (a mood, atmosphere) 落ち着いた雰囲気を醸し出している。(It creates a calm atmosphere.) 思惑 (おもわく): expectation, intention, speculation 彼の思惑が外れた。(His expectations were off.) 涸れる (かれる): to dry up, to run out 井戸が涸れてしまった。(The well has dried up.) 換算 (かんさん): conversion, calculation 外貨を円に換算する。(Convert foreign currency into yen.) 27 SHOW CONTENTS 概説 (がいせつ): general overview, outline 歴史の概説を読む。(Read an overview of history.) 気心 (きごころ): temperament, nature 彼とは気心が知れている。(We understand each other well.) 快楽 (かいらく): pleasure, delight 快楽を追い求める。(Pursue pleasure.) 議事堂 (ぎじどう): parliament building, assembly hall 議事堂の前でデモが行われた。(A protest took place in front of the parliament building.) 機種 (きしゅ): model (of a machine, esp. electronics) 新しいスマホの機種を選ぶ。(Choose a new phone model.) 犠牲 (ぎせい): sacrifice, victim 自分の時間を犠牲にして働く。(Sacrifice one\u0026rsquo;s time for work.) 相次いで（あいついで）: one after the other; successively 有名企業の不祥事が相次いで明らかになった。（A series of scandals involving well-known companies came to light.） 希薄 (きはく): thin, weak (e.g., atmosphere, emotion) 彼は責任感が希薄だ。(He has a weak sense of responsibility.) 課する (かする): to impose (a tax, duty, task) 重い税を課される。(Be burdened with heavy taxes.) 協調 (きょうちょう): cooperation, coordination チームの協調が必要だ。(Team coordination is necessary.) 形作る (かたちづくる): to form, to shape 考え方が人格を形作る。(Thinking forms personality.) 挫ける (くじける): to be disheartened, to lose heart 失敗しても挫けるな。(Don’t lose heart even if you fail.) 合併 (がっぺい): merger, amalgamation ２つの会社が合併した。(The two companies merged.) 屈指 (くっし): leading, preeminent 彼は屈指のプレーヤーだ。(He’s one of the top players.) 花粉 (かふん): pollen 花粉アレルギーがひどい。(I have severe pollen allergies.) 屈する (くっする): to yield, to give in 圧力に屈しない。(Don’t give in to pressure.) 頑固 (がんこ): stubborn 彼は本当に頑固だ。(He’s really stubborn.) 敬遠 (けいえん): keeping at a distance, avoidance 難しい話題は敬遠されがちだ。(Difficult topics tend to be avoided.) 完備 (かんび): fully equipped このホテルは設備が完備している。(This hotel is fully equipped.) 蹴飛ばす (けとばす): to kick away, to kick hard ボールを蹴飛ばした。(Kicked the ball away.) 28 SHOW CONTENTS 飢饉 (ききん): famine 昔、この地域は大きな飢饉に見舞われた。(This region suffered a great famine in the past.) 下落 (げらく): decline, fall (in price or value) 株価が急激に下落した。(Stock prices dropped sharply.) 減益 (げんえき): decrease in profit 不景気の影響で減益となった。(Due to the recession, profits decreased.) 気障 (きざ): affected, pretentious 彼の話し方は少し気障だと思う。(I think his way of speaking is a bit pretentious.) 権限 (けんげん): authority, jurisdiction この決定は課長の権限を超えている。(This decision exceeds the manager\u0026rsquo;s authority.) 気性 (きしょう): temperament, disposition 彼は気性が激しいので、注意が必要だ。(He has a fiery temper, so be cautious.) 築く (きずく): to build, to establish 二人は信頼関係を築いてきた。(They have built a relationship of trust.) 健勝 (けんしょう): good health (formal) ご健勝のこととお喜び申し上げます。(I am pleased to hear you are in good health.) 帰省 (きせい): returning home (especially for holidays) 正月には実家に帰省する予定です。(I plan to return home for New Year’s.) 検証 (けんしょう): verification, inspection 実験結果を検証する必要がある。(We need to verify the experiment results.) 気立て (きだて): disposition, nature (especially good) 彼女はとても気立てのいい人だ。(She is a very kind-hearted person.) 窮乏 (きゅうぼう): poverty, destitution 戦後、多くの人が窮乏生活を送った。(Many people lived in poverty after the war.) 急落 (きゅうらく): sudden fall (in prices, etc.) 円の価値が急落した。(The value of the yen fell suddenly.) 倹約 (けんやく): frugality, thrift 倹約して生活費を抑えている。(I’m being frugal to cut down on living expenses.) 教職 (きょうしょく): teaching profession 教職に就くことが夢だった。(It was my dream to become a teacher.) 去就 (きょしゅう): one’s course of action, position 彼の去就が注目されている。(Everyone is watching his next move.) 後援 (こうえん): support, sponsorship このイベントは市の後援を受けている。(This event is supported by the city.) 講習 (こうしゅう): course, training session 新人向けの講習を受けた。(I attended a training session for new employees.) 相席 (あいせき): sharing a table with someone (usually a stranger) 混雑していたので、相席させられた。(It was crowded, so I had to share a table.) 祈る (いのる): to pray, to wish あなたの成功を心から祈っています。(I sincerely wish for your success.) 29 SHOW CONTENTS 悪者 (わるもの): villain, bad person 映画の中で彼は悪者の役を演じた。(He played the role of a villain in the movie.) 朝市 (あさいち): morning market 日曜日に朝市で野菜を買った。(I bought vegetables at the morning market on Sunday.) 足場 (あしば): foothold, scaffold, foundation 工事現場ではしっかりと足場が組まれていた。(A sturdy scaffold was built at the construction site.) 値する (あたいする): to be worth, to deserve その勇気は賞賛に値する。(That courage deserves praise.) 粗筋 (あらすじ): outline, summary, plot 映画の粗筋を簡単に説明してください。(Please briefly explain the plot of the movie.) 遺棄 (いき): abandonment, desertion 公園で遺棄された動物が見つかった。(An abandoned animal was found in the park.) 経緯 (けいい): details, circumstances, sequence of events 問題が起きた経緯を説明してください。(Please explain how the problem occurred.) 意向 (いこう): intention, idea 上司の意向に従って計画を変更した。(We changed the plan according to the boss’s intentions.) 炒める (いためる): to stir-fry 野菜を油で炒めてください。(Please stir-fry the vegetables in oil.) 一面 (いちめん): one side, one aspect 彼の優しい一面を初めて見た。(I saw his gentle side for the first time.) 一見 (いっけん): at first glance 一見簡単そうに見えるが、実は難しい。(It looks easy at first glance, but it’s actually hard.) 陰湿 (いんしつ): gloomy, malicious, insidious 陰湿ないじめが問題になっている。(Malicious bullying is becoming a serious problem.) 受け身 (うけみ): passive attitude; passive voice 彼はいつも受け身な態度を取る。(He always takes a passive attitude.) 裏返し (うらがえし): inside out, upside down シャツが裏返しになっているよ。(Your shirt is inside out.) 上役 (うわやく): superior, boss 上役の許可を得る必要がある。(You need your superior’s approval.) 会得 (えとく): mastery, understanding 長年の努力で技術を会得した。(I mastered the skill through years of effort.) 縁談 (えんだん): marriage proposal, marriage arrangement 両親が縁談を進めている。(My parents are arranging a marriage.) 押し付ける (おしつける): to force on someone, to push onto 自分の意見を他人に押し付けないで。(Don’t force your opinion on others.) 糸 (いと): thread, string 針に糸を通した。(I threaded the needle.) 伺う (うかがう): to ask, to inquire (humble); to visit (humble) 明日、お宅に伺ってもよろしいでしょうか。(May I visit your home tomorrow?) 30 SHOW CONTENTS お節介 (おせっかい): meddling, nosiness 彼の親切は時にお節介に感じる。(His kindness sometimes feels like meddling.) 落ち度 (おちど): fault, mistake 私にも落ち度があったと認めます。(I admit that I was also at fault.) お供 (おとも): companion, attendance 彼女は社長のお供をして出張に行った。(She accompanied the president on a business trip.) 怯える (おびえる): to be frightened, to be scared 雷の音に犬が怯えている。(The dog is frightened by the sound of thunder.) 親方 (おやかた): master, boss (in crafts, sumo, etc.) 親方から技術を学んだ。(I learned the craft from my master.) 織る (おる): to weave 美しい布を手で織る。(Weave beautiful cloth by hand.) 介護 (かいご): nursing care 高齢の母を介護している。(I’m taking care of my elderly mother.) 害する (がいする): to harm, to damage 健康を害する恐れがある。(It may harm your health.) 快晴 (かいせい): clear weather 今日は快晴で気持ちがいい。(It’s clear and feels great today.) 買い求める (かいもとめる): to purchase, to buy お土産を駅で買い求めた。(I bought souvenirs at the station.) 顔立ち (かおだち): facial features 彼女は整った顔立ちをしている。(She has well-balanced facial features.) 格差 (かくさ): disparity, gap 所得の格差が拡大している。(The income gap is widening.) 革新 (かくしん): innovation, reform 技術革新が進んでいる。(Technological innovation is advancing.) 過敏 (かびん): hypersensitive, overly sensitive 花粉に過敏な人が多い。(Many people are hypersensitive to pollen.) 交わす (かわす): to exchange (greetings, promises, etc.) 笑顔であいさつを交わした。(We exchanged greetings with a smile.) 勘ぐる (かんぐる): to suspect, to imagine (usually bad things) 彼の行動を勘ぐってしまう。(I can’t help but suspect his behavior.) 肝心 (かんじん): essential, crucial 肝心なときにミスをした。(I made a mistake at a crucial moment.) 感電 (かんでん): electric shock 感電しないように注意してください。(Be careful not to get an electric shock.) 受付係 (うけつけがかり): receptionist 受付係が来客を案内した。(The receptionist guided the visitor.) 植える (うえる): to plant 庭に花を植えた。(I planted flowers in the garden.) 31 SHOW CONTENTS 幹部 (かんぶ): executive, management 彼は会社の幹部に昇進した。(He was promoted to an executive position.) 肝要 (かんよう): essential, vital 冷静さを保つことが肝要だ。(Staying calm is essential.) 還暦 (かんれき): 60th birthday 父の還暦を家族で祝った。(We celebrated my father\u0026rsquo;s 60th birthday.) 気遣う (きづかう): to worry about, to care for 母はいつも私の体調を気遣ってくれる。(My mother always cares about my health.) 享受 (きょうじゅ): enjoyment, receiving (a benefit) 私たちは自由を享受している。(We enjoy our freedom.) 矯正 (きょうせい): correction, therapy (e.g., orthodontic or behavioral) 歯並びを矯正している。(I’m getting my teeth straightened.) 仰天 (ぎょうてん): being greatly surprised そのニュースに仰天した。(I was shocked by the news.) 気力 (きりょく): willpower, energy 疲れて気力が出ない。(I’m so tired I have no willpower.) 均質 (きんしつ): uniformity, homogeneity 均質な製品を作ることが求められる。(Producing uniform products is required.) 括る (くくる): to tie up, to categorize まとめて一つに括る。(Tie everything into one bundle.) 口ずさむ (くちずさむ): to hum, to sing to oneself 好きな曲を口ずさむ。(I hum my favorite song.) 朽ちる (くちる): to rot, to decay 木が朽ちて倒れた。(The tree decayed and fell.) 青写真 (あおじゃしん): blueprint, plan 将来の青写真を描く。(Draw up a blueprint for the future.) 欺く (あざむく): to deceive, to trick 人を欺いてはいけない。(You shouldn’t deceive people.) 焦る (あせる): to panic, to be in a hurry 試験前に焦ってしまった。(I panicked before the exam.) あながち: not necessarily (with negative), not entirely 彼の意見もあながち間違いではない。(His opinion isn\u0026rsquo;t entirely wrong.) 誤る (あやまる): to make a mistake 判断を誤ってしまった。(I made the wrong decision.) 植える (うえる): to plant 春に花を植える予定だ。(I plan to plant flowers in spring.) 兎 (うさぎ): rabbit 兎は跳ねるのが得意だ。(Rabbits are good at hopping.) 動く (うごく): to move 機械が動かなくなった。(The machine stopped moving.) 32 SHOW CONTENTS あり方 (ありかた): way of being, how things should be 社会のあるべきあり方について議論する。(We discuss how society should ideally function.) 暗殺 (あんさつ): assassination その政治家は暗殺の危険にさらされていた。(The politician was at risk of assassination.) 安楽死 (あんらくし): euthanasia 安楽死の是非については議論が分かれる。(Opinions are divided on the ethics of euthanasia.) 粋 (いき/すい): chic, stylish, refined 粋な着こなしに憧れる。(I admire stylish outfits.) 弄る (いじる): to fiddle with, to tamper with スマホを弄って時間を潰す。(I kill time by fiddling with my smartphone.) 移籍 (いせき): transfer (e.g., of a player, employee) 有名な選手が海外チームに移籍した。(The famous player transferred to an overseas team.) いそいそ: cheerfully, excitedly 彼はいそいそと出かけていった。(He went out cheerfully.) 一心 (いっしん): wholeheartedly, with single-minded focus 一心に勉強に取り組む。(I study with complete focus.) 命取り (いのちとり): fatal blow, cause of ruin 小さなミスが命取りになることもある。(A small mistake can sometimes be fatal.) 嫌らしい (いやらしい): unpleasant, lewd, nasty 嫌らしい視線を感じた。(I felt a creepy gaze.) 異論 (いろん): different opinion, objection その案には異論がある。(I have objections to that proposal.) 入り (いり): income, arrival, flow 今日の店の入りは上々だ。(The customer turnout today is great.) 飲用 (いんよう): drinking (usage) この水は飲用できません。(This water is not safe for drinking.) エキス: extract, essence ハーブのエキスが入っている化粧品。(Cosmetics containing herbal extracts.) 憂える (うれえる): to worry about, to grieve 将来を憂える声が多い。(Many people worry about the future.) 横領 (おうりょう): embezzlement 社員が会社の資金を横領した。(An employee embezzled company funds.) オーソドックス: orthodox, traditional オーソドックスなスタイルで勝負する。(I compete with a traditional style.) 移す (うつす): to transfer, to move, to infect 本社を大阪から東京に移す。(Move the head office from Osaka to Tokyo.) 内側 (うちがわ): inside, inner part 靴の内側に名前を書いておく。(Write your name inside the shoes.) 写す (うつす): to copy, to photograph ノートを写させてもらった。(I was allowed to copy the notes.) 33 SHOW CONTENTS 驕る (おごる): to be arrogant 成功したからといって驕ってはいけない。 (You shouldn\u0026rsquo;t get arrogant just because you succeeded.) 煽てる (おだてる): to flatter, to egg on 子供を煽てて歌わせた。 (I flattered the child into singing.) 思う存分 (おもうぞんぶん): to one\u0026rsquo;s heart\u0026rsquo;s content 思う存分楽しんでください。 (Please enjoy yourself to your heart\u0026rsquo;s content.) 介抱 (かいほう): nursing, care 怪我人を丁寧に介抱した。 (He carefully nursed the injured person.) 姦しい (かしましい): noisy, clamorous 教室が姦しい女子たちで騒がしかった。 (The classroom was noisy with loud girls.) 仮に (かりに): supposing, temporarily 仮に彼が来なかったらどうする？ (Supposing he doesn\u0026rsquo;t come, what will we do?) 寛容 (かんよう): tolerance, broad-mindedness 彼は失敗に対して寛容だった。 (He was tolerant of mistakes.) 元来 (がんらい): originally, by nature 彼は元来真面目な性格だ。 (He is serious by nature.) 陥落 (かんらく): fall (of a city, etc.), surrender 城は一晩で陥落した。 (The castle fell in one night.) 危害 (きがい): harm, injury 動物に危害を加えてはいけない。 (You must not harm animals.) 軌道 (きどう): orbit, track 計画がようやく軌道に乗った。 (The plan finally got on track.) 凶作 (きょうさく): bad harvest 今年は凶作で米が高くなる。 (This year’s bad harvest will raise rice prices.) 郷愁 (きょうしゅう): nostalgia 故郷の歌に郷愁を感じた。 (I felt nostalgic hearing the song from my hometown.) 境地 (きょうち): state of mind, mental state 彼は悟りの境地に達した。 (He reached a state of enlightenment.) 秋晴れ (あきばれ): clear autumn weather 秋晴れの空が広がっていた。 (A clear autumn sky spread out above.) 暴く (あばく): to expose, to uncover 彼の嘘が暴かれた。 (His lie was exposed.) 改まる (あらたまる): to be renewed, to be formal 彼の態度が急に改まった。 (His attitude suddenly became formal.) 裏 (うら): back, reverse side 紙の裏にメモが書いてあった。 (There was a note written on the back of the paper.) 羨ましい (うらやましい): envious, jealous 彼の才能が羨ましい。 (I’m envious of his talent.) 植わる (うわる): to be planted 庭には桜の木が植わっている。 (Cherry trees are planted in the garden.) 34 SHOW CONTENTS 言い渡す (いいわたす): to sentence, to declare 裁判官は被告に有罪判決を言い渡した。 (The judge declared the defendant guilty.) 行き詰まる (いきづまる): to reach an impasse, to get stuck 交渉が行き詰まってしまった。 (The negotiations came to a standstill.) 憩い (いこい): rest, relaxation 公園は市民の憩いの場だ。 (The park is a place of rest for the citizens.) 板挟み (いたばさみ): caught in the middle 親と上司の間で板挟みになっている。 (I’m caught between my parents and my boss.) 一番乗り (いちばんのり): first to arrive 会場に一番乗りしたのは彼だった。 (He was the first to arrive at the venue.) 迂回 (うかい): detour 工事中なので迂回してください。 (Please take a detour due to construction.) 右折 (うせつ): right turn 次の交差点で右折してください。 (Please turn right at the next intersection.) 内訳 (うちわけ): breakdown, itemization 支出の内訳を示してください。 (Please show the breakdown of expenses.) 俯く (うつむく): to look down, to cast one\u0026rsquo;s eyes downward 彼女は恥ずかしそうに俯いた。 (She looked down shyly.) 浮気 (うわき): cheating, unfaithfulness 彼は浮気が原因で離婚した。 (He got divorced due to cheating.) 獲物 (えもの): prey, catch 猟師は大きな獲物を仕留めた。 (The hunter caught big prey.) 炎症 (えんしょう): inflammation 傷口が炎症を起こしている。 (The wound is inflamed.) 演じる (えんじる): to perform, to play a role 彼は映画で主人公を演じた。 (He played the lead role in the movie.) 円満 (えんまん): harmonious, amicable 二人は円満に別れた。 (They parted ways amicably.) 大口 (おおぐち): large order, big mouth 会社は大口の注文を受けた。 (The company received a large order.) 押し出す (おしだす): to push out, to project 彼はアイデアを強く押し出した。 (He strongly pushed his idea.) オペラ: opera 昨夜、素晴らしいオペラを観た。 (I watched a wonderful opera last night.) 思い付き (おもいつき): idea, inspiration 彼の計画は単なる思い付きに過ぎない。 (His plan is just a spur-of-the-moment idea.) 折 (おり): occasion, time またの折にお会いしましょう。 (Let’s meet again on another occasion.) 売れる (うれる): to sell well この商品は非常によく売れている。 (This product is selling very well.) 35 SHOW CONTENTS 改修 (かいしゅう): renovation, repair 古いビルを全面的に改修した。 (The old building was completely renovated.) 外泊 (がいはく): staying out overnight 昨日は友達の家に外泊した。 (I stayed over at a friend\u0026rsquo;s house last night.) 回避 (かいひ): avoidance 危険を回避するために別のルートを選んだ。 (We chose a different route to avoid danger.) 核家族 (かくかぞく): nuclear family 日本では核家族化が進んでいる。 (Nuclear families are increasing in Japan.) 掛け (かけ): on credit, hanging 彼は食事代を掛けで払った。 (He paid for the meal on credit.) 霞む (かすむ): to become hazy, to be blurred 山が霧で霞んで見えない。 (The mountain is hidden in the mist.) 傍ら (かたわら): beside, while doing something 勉強の傍らアルバイトをしている。 (I work part-time while studying.) 画期的 (かっきてき): groundbreaking, revolutionary それは画期的な発明だった。 (It was a groundbreaking invention.) 加盟 (かめい): affiliation, joining (an organization) 日本はその条約に加盟している。 (Japan is a member of that treaty.) 閑古鳥が鳴く (かんこどりがなく): to be deserted, no customers 平日の昼間は店に閑古鳥が鳴いている。 (The shop is deserted during weekday afternoons.) 頑丈 (がんじょう): sturdy, solid この机はとても頑丈だ。 (This desk is very sturdy.) 慣例 (かんれい): custom, convention 慣例に従って式が行われた。 (The ceremony followed customary practices.) 木耳 (きくらげ): wood ear mushroom 中華料理によく木耳が使われる。 (Wood ear mushrooms are often used in Chinese cuisine.) 規制 (きせい): regulation 政府は新しい規制を導入した。 (The government introduced new regulations.) 既成 (きせい): established 既成の概念にとらわれない。 (Not bound by established ideas.) 機転 (きてん): quick thinking 彼の機転で事故を防げた。 (His quick thinking prevented the accident.) 決め付ける (きめつける): to assume, to label 最初から犯人と決め付けないで。 (Don’t assume he’s the culprit from the beginning.) 規約 (きやく): rules, agreement 規約に違反すると罰せられる。 (You’ll be penalized if you violate the rules.) 海老 (えび): shrimp 海老の天ぷらが好きだ。 (I like shrimp tempura.) 偉い (えらい): admirable, great 彼は本当に偉い人だ。 (He is truly a great person.) 36 SHOW CONTENTS 共存 (きょうぞん): coexistence 人間と自然が共存する社会を目指す。 (We aim for a society where humans and nature coexist.) 強敵 (きょうてき): formidable enemy 決勝戦の相手は強敵だ。 (The opponent in the final is a formidable enemy.) 吟味 (ぎんみ): scrutiny, close examination 材料を吟味して料理を作る。 (I carefully select ingredients to cook.) 挫く (くじく): to sprain, to discourage 転んで足首を挫いた。 (I sprained my ankle when I fell.) 口コミ (くちこみ): word of mouth 口コミで人気が広まった。 (It became popular through word of mouth.) 間柄 (あいだがら): relationship 二人は親しい間柄だ。 (They have a close relationship.) 相槌 (あいづち): responses during conversation 相手の話には相槌を打つのが礼儀だ。 (It\u0026rsquo;s polite to give responses during the conversation.) 仰ぐ (あおぐ): to look up, to seek (guidance) 空を仰ぐと星が輝いていた。 (When I looked up, the stars were shining.) 商い (あきない): business, trade 父は長年商いをしてきた。 (My father has been in business for many years.) 浅ましい (あさましい): wretched, shameful 浅ましい行為に失望した。 (I was disappointed by such shameful behavior.) 与る (あずかる): to be given (a role, honor, etc.) 栄誉に与り光栄です。 (I’m honored to receive such recognition.) 甘える (あまえる): to depend on, to behave like a spoiled child 親に甘えてばかりはいられない。 (I can’t keep relying on my parents.) 宛てる (あてる): to address (a letter) 彼に宛てて手紙を書いた。 (I wrote a letter addressed to him.) 暗算 (あんざん): mental arithmetic 暗算で答えを出す。 (I calculate the answer in my head.) 遺憾 (いかん): regretful, unfortunate 遺憾な結果となった。 (It turned out to be an unfortunate result.) 意気込む (いきごむ): to be enthusiastic 彼は意気込んで試合に臨んだ。 (He faced the match with great enthusiasm.) 異見 (いけん): dissenting opinion 異見を述べる勇気も必要だ。 (You also need courage to express dissent.) いささか: a little, somewhat その説明はいささか不十分だ。 (That explanation is somewhat lacking.) 移住 (いじゅう): migration, relocation 都会から地方へ移住する人が増えている。 (More people are relocating from cities to rural areas.) 至って (いたって): extremely, very 彼は至って真面目な人だ。 (He is an extremely serious person.) 37 SHOW CONTENTS 稲光 (いなびかり): lightning 夜空に稲光が走った。 (Lightning flashed across the night sky.) 迂闊 (うかつ): careless, thoughtless 迂闊にもパスワードを忘れた。 (I carelessly forgot my password.) 受ける (うける): to receive, to undergo 試験を受ける予定です。 (I plan to take the exam.) 打ち破る (うちやぶる): to break through, to defeat ライバルチームを打ち破った。 (We defeated the rival team.) 生まれつき (うまれつき): by nature, since birth 彼は生まれつき目が悪い。 (He has had poor eyesight since birth.) 上書き (うわがき): overwriting ファイルを上書き保存した。 (I saved the file by overwriting it.) 運行 (うんこう): operation (of vehicles) 電車は通常通り運行している。 (The train is operating as usual.) 運送 (うんそう): transport, shipping 荷物は翌日運送される。 (The package will be shipped the next day.) 侵す (おかす): to invade, to violate 他人の権利を侵してはならない。 (You must not violate others\u0026rsquo; rights.) 押さえ込む (おさえこむ): to suppress, to contain 火事を初期のうちに押さえ込んだ。 (The fire was contained in its early stage.) 幼馴染 (おさななじみ): childhood friend 幼馴染と再会した。 (I reunited with my childhood friend.) 衰える (おとろえる): to weaken, to decline 体力が衰えてきた。 (My physical strength has declined.) 折り返し (おりかえし): by return, shortly 折り返し電話します。 (I’ll call you back shortly.) 改革 (かいかく): reform 教育制度の改革が進んでいる。 (Education system reforms are underway.) 階級 (かいきゅう): social class, rank 昔は階級によって差別があった。 (There used to be discrimination based on class.) 改訂 (かいてい): revision 教科書が改訂された。 (The textbook has been revised.) 果敢 (かかん): resolute, bold 果敢な挑戦を続ける。 (He continues to make bold challenges.) 楽団 (がくだん): musical band, orchestra 地元の楽団が演奏会を開いた。 (The local orchestra held a concert.) 横断 (おうだん): crossing 横断歩道を渡るときは注意して。 (Be careful when crossing the pedestrian crossing.) お祝い (おいわい): celebration 昇進のお祝いをする。 (We’ll celebrate the promotion.) 38 SHOW CONTENTS 囲う (かこう): to enclose, to fence in 庭を高い塀で囲う。 (Enclose the garden with a high fence.) 嵩張る (かさばる): to be bulky この荷物は嵩張って持ち運びにくい。 (This luggage is bulky and hard to carry.) 河川 (かせん): rivers この地域は多くの河川に囲まれている。 (This area is surrounded by many rivers.) 花粉症 (かふんしょう): hay fever 春になると花粉症がひどくなる。 (My hay fever gets worse in the spring.) 過保護 (かほご): overprotection 過保護に育てると自立しにくくなる。 (Overprotective parenting makes independence harder.) 慣行 (かんこう): custom, practice 業界の慣行に従って進める。 (Proceed according to industry practices.) 関知 (かんち): involvement, concern その件については関知していない。 (I have no involvement in that matter.) 観点 (かんてん): point of view 環境の観点から考える必要がある。 (We need to consider it from an environmental perspective.) 感無量 (かんむりょう): deeply moved 卒業式で感無量になった。 (I was deeply moved at the graduation ceremony.) 兆し (きざし): sign, indication 景気回復の兆しが見えてきた。 (Signs of economic recovery are emerging.) 期日 (きじつ): due date, fixed date 期日までに提出してください。 (Please submit it by the due date.) 気まずい (きまずい): awkward, uneasy 言い争いの後、気まずい雰囲気になった。 (Things got awkward after the argument.) 虐待 (ぎゃくたい): abuse 子供への虐待は絶対に許されない。 (Child abuse is absolutely unacceptable.) 休止 (きゅうし): suspension, pause 工事は一時休止された。 (The construction was temporarily suspended.) 脅迫 (きょうはく): threat, blackmail 脅迫のメールが届いた。 (I received a threatening email.) 漁村 (ぎょそん): fishing village 漁村で新鮮な魚を味わった。 (I enjoyed fresh fish in the fishing village.) 許容 (きょよう): tolerance, acceptance 誤差の範囲を許容する。 (Accept the margin of error.) 仰向け (あおむけ): face up 仰向けに寝転んだ。 (I lay down facing up.) 憧れる (あこがれる): to long for, to admire 海外での生活に憧れている。 (I long for life abroad.) 遠慮 (えんりょ): restraint, reserve 遠慮せずに食べてください。 (Please help yourself without hesitation.) 39 SHOW CONTENTS 浅はか (あさはか): shallow, thoughtless 浅はかな考えで行動して後悔した。 (I acted on a thoughtless idea and regretted it.) 合わせて (あわせて): in total, in addition 商品代と送料を合わせて5,000円です。 (The product and shipping cost 5,000 yen in total.) 言いよどむ (いいよどむ): to hesitate to say 質問に対して彼は言いよどんだ。 (He hesitated to answer the question.) 一変 (いっぺん): complete change 天気が一変して雨になった。 (The weather changed completely and it started raining.) 陰気 (いんき): gloomy, melancholic 陰気な雰囲気の部屋だった。 (It was a room with a gloomy atmosphere.) ウイルス: virus このソフトはウイルスに感染している。 (This software is infected with a virus.) 打ち上げ (うちあげ): launch, party ロケットの打ち上げが成功した。 (The rocket launch was successful.) 恭しい (うやうやしい): respectful, reverent 彼は恭しい態度で頭を下げた。 (He bowed with a respectful attitude.) 液晶 (えきしょう): liquid crystal 液晶画面が割れてしまった。 (The LCD screen got cracked.) 憂い (うれい): grief, anxiety 彼の顔には深い憂いがあった。 (There was deep sorrow on his face.) 大手 (おおて): major company 彼は大手企業に就職した。 (He got a job at a major company.) 厳か (おごそか): solemn, austere 結婚式は厳かな雰囲気で行われた。 (The wedding was held in a solemn atmosphere.) 押し上げる (おしあげる): to push up, to raise 強風が波を押し上げた。 (The strong wind pushed up the waves.) 外観 (がいかん): exterior, appearance 建物の外観が美しい。 (The building\u0026rsquo;s exterior is beautiful.) 会心 (かいしん): satisfying, triumphant 会心の笑みを浮かべた。 (He showed a satisfied smile.) 海賊版 (かいぞくばん): pirated edition 海賊版の映画を買うのは違法だ。 (Buying pirated movies is illegal.) 賭ける (かける): to bet, to wager 彼は勝負にすべてを賭けた。 (He bet everything on the match.) 片思い (かたおもい): unrequited love 彼女への片思いを続けている。 (He continues his unrequited love for her.) 演奏 (えんそう): performance (musical) ピアノの演奏が始まった。 (The piano performance began.) 大型 (おおがた): large-size 大型のトラックが通った。 (A large truck passed by.) 40 SHOW CONTENTS 適う (かなう): to suit, to conform, to fulfill この靴は私の足にぴったり適う。 (These shoes fit my feet perfectly.) 庇う (かばう): to protect, to defend 彼は妹を庇って叱られた。 (He got scolded for defending his younger sister.) がんがん: pounding (head), noisily 頭ががんがんして集中できない。 (My head is pounding and I can\u0026rsquo;t concentrate.) 完勝 (かんしょう): complete victory 我がチームは相手に完勝した。 (Our team won a complete victory over the opponent.) 感触 (かんしょく): texture, feel, impression この布の感触がとてもいい。 (This fabric feels very nice.) 芳しい (かんばしい): fragrant, favorable (often used in the negative) 彼の評判はあまり芳しくない。 (His reputation isn\u0026rsquo;t very favorable.) 簡略 (かんりゃく): simplification, brevity 手続きは簡略に行われた。 (The procedure was carried out in a simplified manner.) 規定 (きてい): regulation, rule 試験の時間は規定で決められている。 (The exam time is set by regulation.) 脚本 (きゃくほん): script, screenplay 映画の脚本を自分で書いた。 (I wrote the movie\u0026rsquo;s script myself.) 求人 (きゅうじん): job offer, recruitment 新聞に多くの求人広告がある。 (There are many job advertisements in the newspaper.) 強制 (きょうせい): coercion, enforcement 参加は強制ではありません。 (Participation is not mandatory.) 教論 (きょうろん): teaching staff, instructor 教論として大学で働いている。 (He works at a university as a teaching staff member.) 極力 (きょくりょく): to the utmost, as much as possible 極力ミスを避けたい。 (I want to avoid mistakes as much as possible.) 拒絶 (きょぜつ): refusal, rejection 彼女は申し出を拒絶した。 (She rejected the offer.) 義理 (ぎり): duty, sense of obligation 義理で結婚式に出席した。 (I attended the wedding out of obligation.) 拠点 (きょてん): base of operations 東京を拠点に活動している。 (I operate out of Tokyo.) 軽快 (けいかい): light, nimble, cheerful 軽快な足取りで歩いた。 (He walked with light steps.) 掲載 (けいさい): publication, insertion (in print) その記事は新聞に掲載された。 (The article was published in the newspaper.) 軽蔑 (けいべつ): contempt, scorn 嘘をつく人は軽蔑される。 (People who lie are despised.) 屋上 (おくじょう): rooftop 屋上から夜景が見える。 (You can see the night view from the rooftop.) 41 SHOW CONTENTS 経理 (けいり): accounting 経理部が毎月の収支を管理している。 (The accounting department manages the monthly income and expenses.) 欠如 (けつじょ): lack, absence 彼の発言には思いやりが欠如していた。 (His remarks lacked compassion.) 言動 (げんどう): speech and behavior 彼の言動が問題になった。 (His speech and behavior became an issue.) 合議 (ごうぎ): consultation, conference 重い決定は合議によってなされる。 (Serious decisions are made through consultation.) 個々 (ここ): individual, each 問題を個々に分析する。 (Analyze each problem individually.) 衣替え (ころもがえ): seasonal wardrobe change 春になると衣替えの季節だ。 (Spring is the season to change clothes.) 根性 (こんじょう): willpower, guts 彼には根性がある。 (He has a lot of grit.) 偽造 (ぎぞう): forgery 偽造パスポートが見つかった。 (A forged passport was found.) 気取る (きどる): to put on airs, to be pretentious 彼は気取っていて話しかけにくい。 (He\u0026rsquo;s so pretentious it\u0026rsquo;s hard to talk to him.) 急減 (きゅうげん): sharp decrease 売上が急減した。 (Sales plummeted.) 旧知 (きゅうち): old acquaintance 彼とは旧知の仲だ。 (We’re old acquaintances.) 興じる (きょうじる): to amuse oneself, to enjoy 子供たちはゲームに興じていた。 (The children were absorbed in their game.) 協定 (きょうてい): agreement, pact 両国は貿易協定を結んだ。 (The two countries signed a trade agreement.) 切り替える (きりかえる): to switch, to change over 気持ちを切り替えて次に進もう。 (Let’s switch gears and move on.) 食い違い (くいちがい): discrepancy, disagreement 二人の証言に食い違いがある。 (There’s a discrepancy between the two testimonies.) 経歴 (けいれき): career, personal history 彼の経歴は素晴らしい。 (His career background is impressive.) 結束 (けっそく): unity, solidarity チームの結束が勝利を呼んだ。 (Team unity brought victory.) 大幅 (おおはば): large scale, significant 大幅な値下げがあった。 (There was a significant price reduction.) 大通り (おおどおり): main street, avenue 大通りに面したレストランです。 (The restaurant faces the main street.) 42 SHOW CONTENTS 欠損 (けっそん): loss, shortage, defect この部品は一部が欠損している。 (This part is partially defective.) 現行 (げんこう): current, existing 現行の法律では禁止されている。 (It\u0026rsquo;s prohibited under the current law.) 元首 (げんしゅ): head of state 元首が国民に向けて声明を出した。 (The head of state issued a statement to the nation.) 厳密 (げんみつ): strict, precise 厳密に言えば、それは正しくない。 (Strictly speaking, that\u0026rsquo;s not correct.) 克明 (こくめい): detailed, faithful 克明な記録が残っている。 (There is a detailed record remaining.) 快い (こころよい): pleasant, agreeable 快い音楽が流れている。 (Pleasant music is playing.) 越し (ごし): across, over (used as a suffix) 窓越しに彼の姿が見えた。 (I saw him through the window.) 粉々 (こなごな): in pieces, shattered 皿が床に落ちて粉々になった。 (The plate fell to the floor and shattered.) この方 (このかた): since then, all this time 上京してこの方、忙しい日々が続いている。 (I\u0026rsquo;ve been busy every day since moving to Tokyo.) 細心 (さいしん): meticulous, utmost care 細心の注意を払って作業する。 (Work with meticulous care.) 差し入れ (さしいれ): provisions, supplies (often as a treat) 友人が果物を差し入れてくれた。 (A friend brought me some fruit as a treat.) 試案 (しあん): draft proposal 新制度についての試案を提出した。 (I submitted a draft proposal for the new system.) 自営 (じえい): self-employment 自営でカフェを経営している。 (I run a café as a self-employed person.) 下地 (したじ): foundation, groundwork この化粧品は化粧の下地に最適です。 (This cosmetic is ideal as a makeup base.) 手芸 (しゅげい): handicrafts, needlework 手芸が趣味で、刺繍をよくする。 (My hobby is handicrafts, especially embroidery.) 愛用 (あいよう): habitual use, favorite item このバッグは長年愛用している。 (I\u0026rsquo;ve used this bag for years.) 相変わらず (あいかわらず): as usual, the same as ever 彼は相変わらず元気そうだ。 (He seems as lively as ever.) 相槌 (あいづち): backchanneling, response during a conversation 会話中にうまく相槌を打つことが大切だ。 (It\u0026rsquo;s important to respond appropriately during conversations.) 合図 (あいず): signal, cue スタートの合図で走り出した。 (I started running at the signal.) お菜 (おかず): side dish ご飯とお菜のバランスが大事だ。 (The balance between rice and side dishes is important.) SHOW CONTENTS SHOW CONTENTS SHOW CONTENTS SHOW CONTENTS SHOW CONTENTS SHOW CONTENTS SHOW CONTENTS SHOW CONTENTS SHOW CONTENTS SHOW CONTENTS SHOW CONTENTS SHOW CONTENTS SHOW CONTENTS SHOW CONTENTS SHOW CONTENTS SHOW CONTENTS SHOW CONTENTS SHOW CONTENTS SHOW CONTENTS SHOW CONTENTS SHOW CONTENTS SHOW CONTENTS SHOW CONTENTS SHOW CONTENTS SHOW CONTENTS SHOW CONTENTS SHOW CONTENTS SHOW CONTENTS SHOW CONTENTS SHOW CONTENTS 読解 １、日本の寿司の種類と作り方 SHOW CONTENTS 今日有名な寿司屋に行きました、沢山の寿司食べました。日本の寿司には、沢山の種類があります。代表的な物は、握り寿司、ちらし寿司、巻き寿司、稲荷寿司、箱寿司、そして回転寿司です。これらの寿司は、それぞれ異なる材料と作り方を使います。\nToday, I went to a famous sushi restaurant and ate a lot of sushi. Japanese sushi has many varieties. The most representative types are nigiri sushi, chirashi sushi, maki sushi, inari sushi, oshi sushi (pressed sushi), and kaiten sushi (conveyor belt sushi). Each of these sushi types uses different ingredients and preparation methods.\nYour browser does not support the audio element. SHOW NOTES 沢山（たくさん）：a lot 種類（しゅるい）：variety, kind, type, category 代表的（だいひょうてき）：representitive 握り寿司（にぎりすし）：Nigiri-zushi is the most common type of sushi. It consists of a small mound of vinegared rice topped with a slice of fish or other seafood. ちらし寿司（ちらしずし）：Chirashi means \u0026ldquo;scattered,\u0026rdquo; and this sushi is made by scattering sushi ingredients, such as fish, vegetables, and egg over a bowl of sushi rice. 巻き寿司（まきずし）：Maki-zushi refers to sushi that\u0026rsquo;s rolled in sheet of nori (seaweed) with rice, fish, and vegetables inside. The roll is then sliced into bite-sized pieces. 稲荷寿司（いなりずし）：Inari-zushi consists of vinegared rice stuffed inside a pocket of sweet, marinated tofu skin called \u0026ldquo;aburaage\u0026rdquo;. It\u0026rsquo;s often served as a snack or appetizer. 箱寿司（はこずし）：Oshi-zushi is a type of pressed sushi from the Kansai region. The ingredients (fish, vegetables, and rice) are arranged in a box and then pressed together to form a compact, rectangular shape. It\u0026rsquo;s sliced into blocks for serving. 回転寿司（かいてんずし）：Kaiten-zushi is a style of sushi restaurant where plates of sushi are placed on a rotating conveyor belt. Customers can pick the plates they want as they pass by. それぞれ：each, respectively 異なる（ことなる）：to be different, to vary 材料（ざいりょう）：materials, ingredients 作り方（つくりかた）：way of making SHOW CONTENTS まず、握り寿司は、小さなお米を手で握る方法で作ります。その上に新鮮な魚介類、例えばマグロやサーモン、鯛、烏賊などが乗せられます。海苔やわさびが付け合わせとして使われることもあります。お米は、特別な方法で炊く必要があります。炊き立てのお米に酢を混ぜて、寿司の材料と合わせます。\nFirst, nigiri sushi is made by hand-pressing small portions of vinegared rice. On top of the rice, fresh seafood such as tuna, salmon, sea bream, or squid is placed. Sometimes, nori (seaweed) or wasabi is added as a garnish. The rice must be prepared in a specific way—freshly steamed rice is mixed with vinegar and then paired with the sushi toppings.\nYour browser does not support the audio element. SHOW NOTES お米（おこめ）：rice 握る（にぎる）：to grasp, to clutch 魚介類（ぎょかいるい）：marine products, seafood 例えば（たとえば）：for example, e.g. 鮪（マグロ）：tuna　サーモン：salmon　鯛（たい）：sea bream　烏賊（いか）：squid 乗せられ（のせられ）：place on 海苔（のり）：Nori 山葵（わさび）：Wasabi 付け合わせ（つけあわせ）：garnish 特別（とくべつ）：special, particular 方法（ほうほう）：method, way 炊く（たく）：to cook 炊き立て（たきたて）：freshly boiled (rice), steaming 酢（す）：vinegar 混ぜ（まぜ）：to mix, to stir 合わせます（あわせます）：to mix, to combine SHOW CONTENTS 次に、ちらし寿司は、寿司のお米の上にたくさんの魚介類を散らして作ります。イクラや海胆、蛸や帆立もよく使われます。この寿司は見た目がとてもきれいで、食べるのが楽しいです。\nNext, chirashi sushi is made by artfully scattering various seafood over sushi rice. Ingredients like salmon roe (ikura), sea urchin (uni), octopus, and scallops are commonly used. This sushi is visually stunning and makes for a delightful eating experience.\nYour browser does not support the audio element. SHOW NOTES 散らし（ちらし）：scattering イクラ：salted salmon roe 海胆（うに）：sea urchin 蛸（たこ）：octopus 帆立（ほたて）：Japanese scallop 見た目（みため）：appearance, look SHOW CONTENTS 巻き寿司は、海苔の上にお米と魚介類を乗せ、巻くことで作ります。中に胡麻やわかめを入れることもあります。\nMaki sushi is made by placing rice and seafood on nori seaweed and rolling it tightly. Sesame seeds or wakame seaweed are sometimes added inside for extra flavor and texture.\nYour browser does not support the audio element. SHOW NOTES 巻く（まく）：to roll 胡麻（ごま）：sesame seeds 若布（わかめ）：若布 is a type of edible seaweed commonly used in Japanese cuisine. It is often found in dishes such as miso soup, seaweed salad, ramen, and sushi. SHOW CONTENTS また、稲荷寿司は、甘く味付けされた油揚げにお米を詰めたものです。箱寿司は、特に関西地方で人気があり、箱に詰めたお米と魚を固めることで作ります。\nInari sushi features sweetly seasoned fried tofu pouches stuffed with vinegared rice. Oshi sushi (pressed sushi), particularly popular in the Kansai region, is made by compacting layers of rice and fish in a wooden mold.\nYour browser does not support the audio element. SHOW NOTES 味付けされた（あじつけされた）：seasoned (flavor). 油揚げ（あぶらあげ）: deep-frying 詰めた（つめた）：to stuff into, to fill 関西（かんさい）：Kansai (関西) is a region in Japan that includes major cities such as 大阪（Osaka）, 京都（Kyoto）, 神戸（Kobe）, 奈良（Nara）, and 和歌山（Wakayama）. 地方（ちほう）：district, region 固める（かためる）：to press firmly, to solidify. SHOW CONTENTS 回転寿司は、レストランでよく見かけます。回るコンベアの上に様々な寿司が乗っていて、食べたいものを選ぶことができます。\nKaiten-zushi (conveyor belt sushi) is commonly seen in Japanese restaurants. Various sushi plates travel on a rotating conveyor belt, allowing customers to pick whatever they desire.\nYour browser does not support the audio element. SHOW NOTES 回る（まわる）：to turn, to rotate コンベア：conveyor 様々（さまざま）：various 選ぶ（えらぶ）：to choose, to select, to pick out SHOW CONTENTS 寿司に使う材料は、魚だけでなく、昆布や生姜（ガリ）もあります。塩っぱい味や酸っぱい味、そして甘味がバランスよく組み合わさるのが寿司の魅力です。わさびや胡椒でちょっとした辛さを加えることもあります。\nIngredients for sushi include not only fish, but also kelp and ginger (gari). Sushi is a well-balanced combination of salty, sour, and sweet flavors. Wasabi and pepper are sometimes used to add a little spiciness.\nYour browser does not support the audio element. SHOW NOTES 昆布（こんぶ）：kelp 生姜（しょうが）：ginner ガリ：sliced ginger prepared in vinegar (served with sushi); pickled ginger. バランス：balance 組み合わさる（くみあわさる）：to fit together, to combine 魅力（みりょく）：charm, appeal 胡椒（こしょう）：pepper ちょっとした（一寸した）：a touch of, a slight amount of 辛さ（つらさ）：spiciness 加える（くわえる）：to add SHOW CONTENTS 寿司を作る方法は、とてもシンプルですが、どれも新鮮な材料が大事です。最初に材料を準備し、混ぜることや飾ることが大切です。できあがると、どれも美味しいお寿司が完成します。\nThe methods for making sushi are quite simple, but fresh ingredients are essential. First, you prepare the components—mixing and arranging them carefully. When done right, the result is always delicious sushi.\nYour browser does not support the audio element. SHOW NOTES シンプル：simple 大事（だいじ）：important 最初（さいしょ）：beginning 準備（じゅんび）：preparation 飾る（かざる）：to decorate 大切（たいせつ）：important できあがると（出来上がると）：to be completed 完成（かんせい）：completion; perfection ","permalink":"https://signalyu.github.io/posts/3-humanities/languages/japanese/1-jlpt-n1/","summary":"リスニング 音楽 ブルー・ライト・ヨコハマ Your browser does not support the audio element. 歌詞見せて 街（まち『き』）の灯（あか）りが　とてもきれいね\nThe city lights are so beautiful\n城市的灯光如此美丽\nヨコハマ　ブルー・ライト・ヨコハマ\nYokohama, Blue Light Yokohama\n横滨，蓝色之光横滨\nあなたと二人　幸せよ\nWith you, I\u0026rsquo;m so happy\n与你在一起 多么幸福\nいつものように　愛のことばを\nAs always, whisper words of love\n像往常一样 请对我说爱的蜜语\nヨコハマ　ブルー・ライト・ヨコハマ\nYokohama, Blue Light Yokohama\n横滨，蓝色之光横滨\n私にください　あなたから\nPlease say them to me, my darling\n请对我说 亲爱的\n歩いても　歩いても\nNo matter how far we walk","title":"Japanese-Language Proficiency Test — N1"},{"content":"1. Order Food in Restaurant https://youtu.be/_izDbJ45Q5I SHOW NOTES I'm still working on it. This sentence expresses that an action is ongoing and not yet completed. It also suggests that more time is needed to finish it. Did you finish reading? — I\u0026rsquo;m still working on it. Did you fix my car? — I\u0026rsquo;m still working on it. Coke and Fries This refers to a popular combination of fast food: Coca-cola and French Fries. Complimentary This word is used to describe something that is free of charge or offered as a gift. For example: The hotel offers complimentary breakfast. (The breakfast is free of charge.) I'll go with This phrase means to choose or select something from available options. For example: I\u0026rsquo;ll go with pizza. (Pizza is the chosen option over others.) Grab This word means to qucikly take hold of something or pick something up in a hurry. For example: On your way home, can you grab some milk? Wait for me, please. I need to grab my coat. Let\u0026rsquo;s grab a cup of coffee. 2. Calling in Sick https://youtu.be/UCtpnO9r7pQ SHOW NOTES I'm feeling quite ill today. This phrase indicates that the person is experiencing discomfort or sickness. I'm coming down with the flu. This sentence means the person is starting to get sick with the flu. \u0026ldquo;Coming down with\u0026rdquo; is an informal way to say that someone is begining to show symptoms of disease. Calling in sick This phrase is commonly used to notify the employer by phone or email that the person will be absent due to illness. I was hoping to take the day off. This sentence means that the person wants to have a break from work for the day, usually because of personal reasons or illness. 3. Describe Someone\u0026rsquo;s Appearance https://youtu.be/KRysx-guzlw SHOW NOTES Description of Someone's Appearance: He\u0026rsquo;s good looking, he\u0026rsquo;s quite tall, around 6'1. He\u0026rsquo;s in his early 30s, and he get the most beautiful dark brown eyes. Heard is the past tense of the verb hear, which means to listen or become aware of something through the sense of hearing. I heard you\u0026rsquo;re dating a new guy. Julie told me she heard that you\u0026rsquo;re pregnant. What! You got fired? I heard that you quit. Fill me in This phrase means to provide someone with the details or information about something, especially if they missed out on it. For example: Can you fill me in on what happened during the meeting? Career path refers to the direction of someone\u0026rsquo;s career over time. It\u0026rsquo;s the journey someone follows in their professional life. For example: She\u0026rsquo;s thinking about changing her career path and moving into marketing. Goodlooking is used to describe someone who is attractive. It\u0026rsquo;s more natural than handsome. Hot is an informal term used to describe someone who is very attractive, typically in a physical or sexual way. However, it\u0026rsquo;s important to note that it is not always appropriate to use it directly when describing someone, as it can be considered somewhat impolite. It is more commonly used among friends or in casual settings as a comment or compliment. 4. Road Trip https://youtu.be/X8ch6GxkG7I SHOW NOTES Munchies refers to snacks or small amounts of food, often eaten casually or between meals. Fill up the tank means to fill the gas tank of a car with fuel. It\u0026rsquo;s often used when someone is getting ready to drive somewhere. A Pit Stop originally refers to a quick stop made by race cars during a race or refuel or change tires. In everyday language, it can refer to any quick stop made during a journey, such as for food, a bathroom break, etc. For example: Let\u0026rsquo;s make a pit stop for some coffee before we continue driving. We've got all our bases covered. This phrase means that all possible situations or needs have been thought about and planned for. For example: Don\u0026rsquo;t worry about the trip, we\u0026rsquo;ve got all our bases covered. We\u0026rsquo;ve got all our bases covered in case the Hurricane hits. Okay, I have my keys, wallet and passport, looks like I have all my bases covered. Let's get ... This is a common expression used to start something or make it happen. It can be used in many contexts, such as starting a project, meal, or activity. For example: I have a chicken, so let\u0026rsquo;s get cooking. This house is really scary, let\u0026rsquo;s get out of here. I have another meeting in 20 minutes, so let\u0026rsquo;s get down to business. Are we ready to go? This is a question asking if everything is prepared and if it\u0026rsquo;s time to start or leave. It\u0026rsquo;s often used when you\u0026rsquo;re about to start a trip, a task, or an activity. For example: Are we ready to go? The car is packed! It's all set. This means that everything is prepared or ready to go. It suggests that no further work is needed and everything is in order. For example: Don\u0026rsquo;t worry about the meeting, it\u0026rsquo;s all set. 5. Computer Viruses https://youtu.be/1Ic3G-KyEzQ SHOW NOTES Froze refers to something especially a computer or software that suddenly stopped responding and is no longer working, For example: My computer froze when I was trying to open the file. Infected file refers to a file on a computer that has been corrupted or infected by a virus or malware. Up to date means that something is current, recent, and has the latest information or updates. For example: I need to buy a new computer, because mine isn\u0026rsquo;t up to date. I can\u0026rsquo;t find the street, are you sure this map is up to date. Sarah has just finished the reports and all the information is up to date. I'll be right... It is an informal way to describe someone will return or be ready very soon. For example: Can you help me with my computer. — I\u0026rsquo;ll be right there. Come downstairs, dinner is ready. — I\u0026rsquo;ll be right down. Hurry up! I need to use the bathroom. — I\u0026rsquo;ll be right out. It turns out that This phrase is used to reveal a surprising or unexpected result or discovery. It often introduces new information. For example: Frank didn\u0026rsquo;t come to work today, and it turns out that he was sick. I\u0026rsquo;ve been feeling really sick recently, it turns out that I\u0026rsquo;m pregnant. It's acting up again. When something \u0026ldquo;acts up,\u0026rdquo; it means it\u0026rsquo;s behaving in an unusual or malfunctioning way. It is commonly used to describe a technical problem. For example: Oh great! That stupid computer froze again, that\u0026rsquo;s the third time today. 6. Embarrassing Situation https://youtu.be/yFAepMyEIWM SHOW NOTES In a bit of a hurry This phrase means that someone need to do something quickly. For example: Can you drive fast, I\u0026rsquo;m in a bit of a hurry. I can\u0026rsquo;t talk right now, I\u0026rsquo;m in a bit of a hurry. I\u0026rsquo;m in a bit of a hurry, so I\u0026rsquo;ll check these files later. Slipped my mind This means that someone forgot something unintentionally. For example: I\u0026rsquo;m sorry I forgot to respond to your email, it just slipped my mind. I meant to call you but it completely slipped my mind. Don\u0026rsquo;t you know what day is it today? — Oh, it\u0026rsquo;s your birthday. It completely slipped my mind. around here This refers to the local area or the place where someone is currently. For example: Are there any good restaurants around here? Is there a bank around here? Extention: Los Angeles is a great city, I used to live around there. terrible with This means someone is not good at something. For example, You\u0026rsquo;re terrible with numbers, you can\u0026rsquo;t even remember your own telephone number. I\u0026rsquo;m teribble with directions, I\u0026rsquo;m always getting lost. I\u0026rsquo;m teribble with faces, I can never remember what people look like. how's it going? This sentence is a casual, native way to greet someone. For example, How\u0026rsquo;s it going? Everything is going well. 7. Watch a Movie https://youtu.be/8LwCV7IHgss SHOW NOTES inconsiderate This word describes someone who is thoughtless or doesn\u0026rsquo;t consider how their actions affect others. For example: It was inconsiderate of him to interrupt during the meeting. keep it down This phrase is used to ask someone to lower the volume or make less noise. For example: I\u0026rsquo;m trying to study, do you mind keeping it down? not such a big deal This phrase is used to suggest that something is not as important or serious as it may seem. For example: Don\u0026rsquo;t worry about the mistake; it\u0026rsquo;s not such a big deal. I can\u0026rsquo;t get these files to you by tomorrow. — It\u0026rsquo;s OK, it\u0026rsquo;s not such a big deal. switch it off This means to turn something off, usually referring to electronics or devices. For example: Please switch it off when you\u0026rsquo;re done using the computer. can't hear a thing This phrase means that it is so noisy that it is impossible to hear anything clearly. For example: What? This music is too loud, I can\u0026rsquo;t hear a thing. Do you mind... This is a polite way to ask if someone is okay with something or if something would be a problem. For example: Do you mind holding my coat for me? I forgot my wallet. Do you mind paying for dinner? Do you mind turning off your phone? 8. In Debt https://youtu.be/QHeOq0D4zjU SHOW NOTES recession refers to a period of economic decline when businesses slow down and unemployment rises. For example: The country is going through a recession, and many people are losing their jobs. mortgagerefers to a loan taken out to buy property, where the property itself serves as collateral until the loan is paid off. For example: He has a mortgage on his house, and he\u0026rsquo;s paying it off monthly. hit me pretty hard This phrase means something had a strong, negative impact on someone emotionally or financially. For example: My divorce hit me pretty hard, I\u0026rsquo;m so depressed. This cold hit me pretty hard, I\u0026rsquo;ve been in bed for a week. The news of Fluffy\u0026rsquo;s death hit me pretty hard, I\u0026rsquo;ve been crying for days. what can I do for you: This is a polite way to ask how to help someone or what they need. I'm sorry to trouble you This is a polite way of apologizing for causing inconvenience or bothering someone. For example: Can I trouble you for a moment, I just need you to sign this form for me. I\u0026rsquo;m sorry to trouble you, but may I go home early today. Can I trouble you for a pen, mine is not working anymore. On top of all that This phrase is commonly used to add something additional to make things worse, but it can also be used in positive things. For example: Today I lost my job, my car got stolen, and on top of all that, my girl friend broke up with me. Today was a really great day, it was my birthday and all my friends came to visit me, and on top of all that, I received a surprising gift! 9. In a Rush https://youtu.be/DjgpFzIWCRs SHOW NOTES step on it This phrase means to go faster or speed up, especially when driving or in a hurry. For example: We\u0026rsquo;re running late, step on it. have a fit This means to become very angry, upset, or emotional about something. For example: Jeez, you don\u0026rsquo;t need to have a fit, nothing is going to happen if we\u0026rsquo;re five minutes late. My boss is going to have a fit if I don\u0026rsquo;t finish this on time. I almost had a fit when my boss told me I had to work this weekend. cut through means to go through a path that helps save time or provides a shortcut, often through an area that isn\u0026rsquo;t typically a main route. For example: I\u0026rsquo;ll cut through the park to get to the other side of the neighborhood faster. make a left/right/U-turn: These are driving directions. For example: Make a left at the light, then a right at the next stop sign. I missed my exit. I need to make a U-turn. are you nuts This is a casual, humorous, shocked way to ask if someone is crazy or acting irrationally. For example: You want to get married now? Are you nuts? You only met her 3 weeks ago. Are you nuts? I\u0026rsquo;m not going to cheat on the exam, what if I get caught? Let's take a side street/Wilson Avenue/the freeway These phases are used to suggest an alternative route or road. For example: The main road is too congested. Let\u0026rsquo;s take a side street to avoid the traffic. We can get there faster if we take Wilson Avenue. Let\u0026rsquo;s take the freeway to avoid getting stuck in traffic. 10. Visiting the Eye Doctor https://youtu.be/lJLgLQWmpBI SHOW NOTES 2020 vision refers to the normal vision in United States. It\u0026rsquo;s often used to indicate perfect or ideal eyesight. Far-sighted/Near-sighted Far-sighted refers to hyperopia, a condition where distant objects are clear, but nearby objects appear blurry. People with this condition have difficulty seeing things close up. Near-sighted refers to myopia, a condition where nearby objects are clear, but distant objects appear blurry. People with this condition have trouble seeing things far away. make out means to be able to see or understand something, especially when it is difficult to do so. For example: I can barely make out the words on the sign. If you look carefully , you almost make out a few of the stars in the sky. Can you see what\u0026rsquo;s written on the sign there — No, I can\u0026rsquo;t quite make it out. Blind as a bat is a fugurative expression used to describe someone who has very poor vision or is unable to see well. What seems to be the problem/matter/trouble These are used to ask what the issue or difficulty is. What seems to be the problem? (asking about a difficulty or issue) What seems to be the matter? (asking about what is troubling someone) What seems to be the trouble? (asking about a specific difficulty or issue) head on/in/out/up are informal expressions that typically refer to moving or going in a certain direction. head on in: It’s getting late; let’s head on in. head on out: We’ll head on out after lunch. head on up: We’re going to head on up to the second floor. 11. Scheduling an Appointment https://youtu.be/E8vH3YpcFfg SHOW NOTES double check means to verify or check something again to make sure it is correct or accurate. For example: I\u0026rsquo;ll double check my schedule to make sure I\u0026rsquo;m free tomorrow. scheduled means that something has been planned or arranged to happen at a specific time. For example: I have a meeting scheduled for 2 PM. booked solid means that all available time slots are taken, and there are no open appointments or spaces left. For example: I can\u0026rsquo;t get a hotel room, they\u0026rsquo;re booked solid until after the New Year. I\u0026rsquo;m pretty sorry there are no seats available on this flight, we booked solid over the Christmas holidays. Sorry, I can\u0026rsquo;t meet you today, I\u0026rsquo;m booked solid. Sentence Collecting: Appointment: I\u0026rsquo;m calling to arrange an appointment with Ms Mcneely. Please book an appointment for next week. Please schedule an appointment for next week. Dialogue: A: How\u0026rsquo;s Thursday? Does she have any time available then? B: Unfortunately, she\u0026rsquo;s booked solid on Thursday. How does next Monday work for you? A: Actually, I\u0026rsquo;ve got something scheduled on Monday. Can she do Tuesday? B: Let me see, sure, Tuesday\u0026rsquo;s perfect. 12. Going Out to Eat https://youtu.be/VpsxLnJ52ME SHOW NOTES food poisoning refers to an illness caused by consuming food or drink that is contaminated with harmful bacteria, viruses, or toxins. For example: I think I have food poisoning from the salad I ate yesterday. allergic refers to having an allergy, which is an immunue system reaction to certain substances, such as food, pollen, or pet dander. For example: She is allegic to peanuts, so she has to be careful about what she eats. check out This phrase usually means to look at or examine something, or visit a place. For example: Have you been to new cafe next door. — Yeah, I checked it out yesterday, the food was great. I\u0026rsquo;m going to check out that new shopping mall this weekend. bistro refers to a small, casual restaurant or cafe, often offering simple, home-style meals. For example: We went to a charming bistro for dinner last night. not all that crazy about is an informal expression that means not very interested in or not particularly fond of something. Do you want to go shopping with me tomorrow? — I\u0026rsquo;m not all that crazy about shopping, I don\u0026rsquo;t like spending money. I\u0026rsquo;m not all that crazy about Jazz music. Can I change this song? in the mood for This expression means desiring or wanting something at a particular moment, usually referring to food or activities. For example: We always eat hamburgers for dinner, I\u0026rsquo;m in the mood for something different. Let\u0026rsquo;s watch movie. How about Texas Chainsaw Massacre. — I\u0026rsquo;m not in the mood for a horrible movie. Sentence Collecting Ask Suggestions Do you have any suggestions? Do you have any ideas? Do you have any thoughts? Giving Suggestions I\u0026rsquo;d recommend giving it a try. You\u0026rsquo;ve gotta give them a try. You could give them a try. 13. Cancelling an Appointment https://youtu.be/lcZA5FeM2_I SHOW NOTES reschedule means to change the time or date of an event or appointment to a later time. For example: We need to reschedule the meeting for next week. postpone means to delay or push something to a later time, often with a specific future date in mind. For example: The concert was postponed due to the rain. can't make it is a casual way of saying that attending or participating in an event or meeting is not possible. For example: I\u0026rsquo;m sorry, I can\u0026rsquo;t make it to the party tonight. this thing came up This phrase is used to explain that something unexpected or urgent has happened, preventing attendence or participation in a planned activity. I\u0026rsquo;m sorry that I\u0026rsquo;m late this thing came up at work, and I had to stay to take care of it. I can\u0026rsquo;t talk right now, something came up. The meeting at 3 PM had to be rescheduled because this thing came up at work. Sentence Collecting What\u0026rsquo;s up? — Not much./Nothing. 14. Asking for More Time https://youtu.be/IKm6ceWu1IU SHOW NOTES press kit refers to a collection of materials, such as photos, press releases, or information about a company, product, or event, that is given to journalists or media for publicity purpose. deadline/extension deadline is the final date by which something must be completed or submitted. For example: The deadline for the report is Friday at 5 PM. extension is an extra period of time given to complete something after the original deadline. For example: She requested an extension on the project deadline. ran into means to unexpectedly meet someone or experience something, usually a problem. For example: We ran into a storm on our way home. If you\u0026rsquo;re not careful now, you\u0026rsquo;re going to run into a lot of problems later. I ran into some trouble with my computer. I've been meaning to... This is used to express an intention to do something that has not yet been done. For example: I\u0026rsquo;m sorry I haven\u0026rsquo;t called you yet, I\u0026rsquo;ve been meaning to but I\u0026rsquo;ve been busy. I\u0026rsquo;ve been meaning to tell you but John quit yesterday. I\u0026rsquo;ve been meaning to see that film for a while. beyond my control refers to something that cannot be influenced or changed by the person, usually an event or situation. For example: The delay was beyond my control because of the weather. put this off means to delay or postpone something to a later time. For example: I\u0026rsquo;ve been putting off this project for a week, and it\u0026rsquo;s due tomorrow. Can we put off our meeting till next week, I\u0026rsquo;m too busy right now. I\u0026rsquo;ve been putting off my email all day, and now I have 50 messages to respond to. 15. Complimentary Upgrade https://youtu.be/vJlvav_HThc SHOW NOTES under the name refers to something that is registered or listed in someone\u0026rsquo;s name. For example: Do you have a reservation under the name Smith? mix up means to confuse or mistake one thing for another. For example: There was a mix up at the airport, and my bags were sent to Antarctica. I\u0026rsquo;m sorry sir, there\u0026rsquo;s been a terrible mix up with giving you the wrong baby. overlooked means more reservations or tickets have been sold than there is capacity to accommodate. For example: The hotel was overbooked, and they didn\u0026rsquo;t have a room for us when we arrived. complimentary upgrade refers to a free improvement. For example: We received a complimentary upgrade to a presidential suite at the hotel. 16. Cutting in Line https://youtu.be/79cfTb94tHU SHOW NOTES there's no way... This phrase is used to express that something is impossible to happen. For example: There\u0026rsquo;s no way I can have those reports finished today. The stadium is so crowded that there\u0026rsquo;s no way we\u0026rsquo;ll find a seat. Do you think Michael\u0026rsquo;s gonna buy that house? — There\u0026rsquo;s no way he has enough money to buy it. cut in line means to move ahead of others in a line or queue, usually in an unfair or rude manner. For example: Excuse me, I\u0026rsquo;m really late, can I cut in line, please? I hate it when people cut in line at the bank, it\u0026rsquo;s so rude. I think it\u0026rsquo;s okay when a pregnant woman cuts in line. sue me is a casual or somewhat sarcastic expression used to suggest that someone is free to take legal action, often when the speaker does not care about the consequences. It can also be used humorously when someone is being accused of something. For example: I forgot your birthday. Sue me! (Used in a joking way) 17. Wedding Day https://youtu.be/MCtwK8KGtBk SHOW NOTES it's about time. is commonly used to express that something finally happens after a long wait. For example: Dinner\u0026rsquo;s ready. — It\u0026rsquo;s about time, I\u0026rsquo;m starving. Guess what. I finally got a job. — It\u0026rsquo;s about time, you\u0026rsquo;ve been unemployeed for two years. We\u0026rsquo;re almost there, just a couple more minutes. — It\u0026rsquo;s about time, we\u0026rsquo;ve been driving for 12 hours. bridesmaids are women who are chosen to assist the bride on her wedding day. flower girl is a young girl who walks down the aisle before the bride, scattering flower petals. ring bearer is a young boy who carries the wedding rings down the aisle. gorgeous is a uni-sex adjective, it can be used to describe both people and things. For example: She looks gorgeous in that dress. The sunset was absolutely gorgeous. Common Mistake Wrong: Let\u0026rsquo;s marry. Right: Let\u0026rsquo;s get married. Flower Girl \u0026amp; Ring Bearer 18. Asking for Time Off https://youtu.be/Ds5zwyfLyqI SHOW NOTES notice refers to the information that gived someone in advance about something, often referring to leaving a job or ending an agreement. For example: If you want to quit your job, make sure you give enough notice, you\u0026rsquo;ll need to tell us four weeks in advance. You didn\u0026rsquo;t give me enough notice about this project, I didn\u0026rsquo;t have enough time to finish it. Sentence Collecting: Do you have a sec/second/minute? — Sure, what can I do for you? Would you be okay with that? — I\u0026rsquo;m fine with that. Are you alright with that? / Will you Ok with this? I was just wondering/thinking/hoping... is more polite than I want to... 19. Hiring an Assistant https://youtu.be/JZFIdKbnZCU SHOW NOTES understaffed means that there are not enough employees or workers to handle the work or tasks. For example: Our team is understaffed right now, so we need to delay the project deadline. the timing is just not right means that it\u0026rsquo;s not the right moment or situation to do something. For example: I was gonna sell my house, but the timing is just not right. Honey, I think we should have a baby. — The timing is just not right. weight off my shoulders phrase means feeling relieved from stress or worry. After I finished my final exam, it felt like a weight was off my shoulders. give me a hand is an informal way of asking for help. For example: Can you give me a hand with these boxes. Neil, I\u0026rsquo;ll need you to give me a hand with the sales reports. Let me give you a hand with your suitcase. keep our costs down means to reduce or control expenses. We need to keep our costs down if we want to make a profit this quarter. 20. Bargain https://youtu.be/I4ivQUabfyo SHOW NOTES bargain refers to a good deal or something you buy at a lower price than usual. It can also refer to negotiating for a better price. For example: I found a great bargain on these shoes—they were 50% off! price range refers to the range of prices within which something is available, or the amount someone is willing to pay. For example: I\u0026rsquo;m looking for a new phone, but my price range is between $200 and $400. shop around means to look at different stores or options to compare prices before making a purchase. For example: Before you buy that jacket, shop around and see if you can find a better deal at another store. Can you give me a better deal? This is a request for a lower price or a better offer, often used during negotiations. For example: I really like this shirt, but it\u0026rsquo;s too expensive. Can you give me a better deal? Can you give me a better price on this car, I really don\u0026rsquo;t have that much money. That's still more than I wanted to spend. This is commonly used in situations where the price is still too high even after trying to negotiate or considering different options. For example: I know the dress is on sale, but that\u0026rsquo;s still more than I wanted to spend. That's my last offer This is commonly used in situations where the final price someone is willing to accept; no further negotiations will be made. For example: I can\u0026rsquo;t go lower than $500 for the laptop. That\u0026rsquo;s my last offer. 21. Watching Basketball https://youtu.be/O-BvPcJfX1w SHOW NOTES foul refers to a violation of the rules in a sport, usually resulting in a penalty. For example: He committed a foul by pushing the opponent during the game. ref is short for referee, refers to an official who oversees a game or match to enforce the rules. For example: The ref called a foul on that play because the defender hit the shooter. free throw refers to a shot taken from the free-throw line without any defense, usually awarded after a foul. For example: She made both of her free throws after the foul was committed. make the shot means to successfully score by getting the ball into the hoop or goal. For example: If Gretzky make a shot, they\u0026rsquo;re gonna win the Stanley Cup. 3-pointer refers to a basketball shot taken from beyond the three-point line, worth three points if successful. For example: He hit a 3-pointer to tie the game in the final seconds. travel refers to a vilation in basketball where a player takes too many steps without dribbling the ball. For example: The ref called a travel because the player took five steps without dribbling. beer run informally refers to going to get beer, usually in a group or as part of a social activity. For example: We\u0026rsquo;re running out of drinks—time for a beer run. screw up means to make a mistake or do something badly, often in a way that causes problems or difficulties. For example: Jill, you really screwed up this time, you\u0026rsquo;re fired. This game is important, if you screw it up again, we\u0026rsquo;re out of the finals. I\u0026rsquo;m sorry, I know I screwed up, will you forgive me? 22. Ending a Relationship https://youtu.be/HjXbEHvwskM SHOW NOTES get a hold of means to contact or reach someone. For example: I tried calling her all day, but I couldn\u0026rsquo;t get a hold of her. stood me up means to fail to meet someone as planned, especially when they were expecting you. For example: I waited for an hour, but she stood me up and never showed. priority refers to something that is considered more important to be done or dealt with first. For example: Getting the report finished is my top priority today. heading is commonly used to express the future direction, outcome, or progress. For example: I don\u0026rsquo;t know where our relationship is heading. Where is this bus heading? Where is this project heading? Do you have any idea...? This is commonly used to ask if someone knows or has any information about something. For example: You forgot my birthday. Do you have any idea how angry I am? Julie kiss my borfriend, does she have any idea how mean that was? I just broke up with my boyfriend, don\u0026rsquo;t you have any idea how sad I am? I've heard it all before. This phrase is used when someone is tired of hearing the same things or excuses. For example: You say you\u0026rsquo;ll change, but I\u0026rsquo;ve heard it all before. I\u0026rsquo;m not buying it. 23. New Year\u0026rsquo;s Resolution https://youtu.be/I9k50oVZPHA SHOW NOTES transform means to change something completely in appearance, form, or nature, often for the better. For example: She used to be shy, but the experience completely transformed her. stuffed means to be very full, especially after eating too much. For example: I ate so much pizza, I\u0026rsquo;m completely stuffed! stick to it means to continue with something especially when it\u0026rsquo;s difficult. For example: I can\u0026rsquo;t solve this math problem. — Stick to it. I\u0026rsquo;m sure you\u0026rsquo;ll get it. I mean it. This phrase emphasizes seriousness in what someone is saying. For example: If you don\u0026rsquo;t finish your homework by tonight, there will be consequences. I mean it! cut out means to remove something entirely. For example: It\u0026rsquo;s time for me to focus on my work, I\u0026rsquo;m going to cut out everything else from my life. You have to cut out the salt and carbon from your diet, no more chips, no more French fries, no more popcorn. 24. Ordering Pizza https://youtu.be/yaeLbz_NK4U SHOW NOTES pepperoni is a type of spicy Italian sausage made from cured pork and beef, often used as a topping for pizza. olives are small, oval-shaped fruits that are typically green or black. They are often used in salads, pasta dishes, or as pizza toppings. martini is a classic cocktail typically made with gin and vermouth, garnished with an olive or a twist of lemon peel. thick crust / thin crust Thick crust is soft and doughy, while thin crust is crispy and light. ham is a type of cured or smoked meat, often made from the thigh of a pig. It is commonly used as a topping for pizzas or in sandwiches. Regina Margarita is a variation of the famous Margherita pizza, typically with tomato, mozzarella, and basil, but may also include other toppings or slightly different variations depending on the restaurant. This is Marty speaking. This is a way to introduce oneself on the phone, letting the other person know who is speaking. For example: Hello, this is Marty speaking. How can I help you? 2 for 1 special is a promotional offer where customers get two items for the price of one. This is commonly seen in restaurants, stores, or fast-food promotions. 25. Receptionist https://youtu.be/sgxrbqyGonE SHOW NOTES May I take your name? This is a polite way of asking for someone\u0026rsquo;s name, typically when answering the phone or greeting someone in an office or service setting. Miss Stevens will be with you momentarily. This is a polite way to inform someone that Miss Stevens will arrive or be ready to speak with them shortly. For example: Please take a seat. Miss Stevens will be with you momentarily. Miss Stenvens is ready for you now. This is used to inform someone that the person they are waiting to see is now available to meet them. For example: Miss Stevens is ready for you now. Please follow me. I'll show you to her office. This is used to guide someone to another person\u0026rsquo;s office or location. For example: Please follow me. I\u0026rsquo;ll show you to her office. right this way is a polite way of directing someone to go in a certain direction. watch your step is a cautionary phrase used to warn someone to be careful of their footing, often when walking on uneven ground or stairs. 26. Swimming https://youtu.be/kGopb2awYiM SHOW NOTES anchor the boat means to secure a boat in place by dropping an anchor into the water, preventing it from drifting. For example: We need to anchor the boat before we go swimming. doggy padding is a simple swimming stroke where the swimmer uses a paddling motion with their arms and legs, similar to how a dog swims. It is often used by beginners as it\u0026rsquo;s an easy and natural way to stay afloat. breaststroke is a swimming stroke where the swimmer moves their arms in a half-circle motion while pulling their legs in a frog-like kick. backstroke is a swimming stroke done on the back, where the swimmer alternates arm strokes in a circular motion while kicking their legs. take a dip means to go into the water for a quick swim. For example: It\u0026rsquo;s such a hot day; let\u0026rsquo;s take a dip in the pool to cool off. for a little while means for a short period of time. I\u0026rsquo;m going to take a dip for little while before the sunset. 27. Eggs Preparation https://youtu.be/e-z7jc3B4zg SHOW NOTES picky means being very selective or particular, especially when it comes to food, preferences, or choices. He\u0026rsquo;s really picky about his food—he doesn\u0026rsquo;t like vegetables. yolk/egg white yolk is the yellow part of an egg, which is surrounded by the egg white. egg white is the clear part of an egg that surrounds the yolk sunny side up is a way of cooking eggs where the egg is fried on one side only, leaving the yolk exposed and not flipped. soft/hard boiled eggs soft boiled egg is an egg that has been boiled for a short time, resulting in a runny yolk and slightly firm white. hard boiled egg is an egg that has been boiled for a longer period, making both the yolk and white firm. eggs and soldiers is a British dish where soft-boiled eggs are served with strips of toast (called soldiers) for dipping into the yolk. I feel like... This is often used to express a desire, mood, or inclination to do something. I feel like baking. I feel like eating pizza. drives me crazy means to cause frustration or annoyance, often in a way that is hard to ignore. This music is driving me crazy, turn it down. Don\u0026rsquo;t leave garbage in my car, it drives me crazy. Your mom is driving me crazy, she keeps calling me. 28. At the Bar https://youtu.be/l-IL4mtzye0 SHOW NOTES on tap refers to beverages, especially beer, that are available from a keg. When something is \u0026ldquo;on tap\u0026rdquo;, it means that it\u0026rsquo;s being served from a tap at a bar or restaurant. happy hour refers a time when drinks and appetizers are sold at discounted, usually in the late afternoon or early evening. a special refers to a discounted item, usually in a restaurant or bar. Today\u0026rsquo;s special is a burger and fries for only $5. pint is a unit of measurement for liquids, commonly for beer. a pint = 473 milliliters appetizer is a small dish served before the main course to stimulate appetite. Nachos /ˈnɑːtʃoʊz/ is a popular snack made from tortilla chips covered with melted cheese and often topped with things like salsa, guacamole, sour cream, etc. Heineken /ˈhaɪnɪkən/ is a popular brand of beer originally from the Netherlands. Budweiser /ˈbʌdˌwaɪzər/ is a well-known American beer brand. Mozzarella /ˌmɑːtsəˈrɛlə/ is an Italian cheese that is soft, white, and commonly used in salads, pizzas, and pasta dishes. how/what about are used to suggest or inquire about something. What about these dirty clothes, you said you would wash them days ago. What about going to the mall instead. I\u0026rsquo;m tired of going to the movies. How about we go to the new restaurant tonight? 29. Fingers https://youtu.be/y-eo1VNedcQ SHOW NOTES pinky, ring finger, middle finger, index finger, thumb pinky: The smallest finger. ring finger: The fourth finger, typically where a ring is worn. middle finger: The third finger, located in the center of the hand. index finger: The second finger, next to the thumb, often used for pointing. thumb: The first and thickest finger, opposable to the other fingers, making grasping objects easier. may this ring be blessed This phrase refers to a wish or prayer for the ring to be blessed or sactified, often said during a wedding ceremony. abide in peace This phrase means to live or remain in peace, suggesting calmness and harmony. with this ring, I thee wed This is a traditional phrase spoken during a wedding ceremony, where one person declares their intention to marry the other by placing a ring on their finger. wear it as a symbol of our love and commitment This phrase explains that the ring represents the love and promise made between two people in marriage. 30. Math https://youtu.be/8uLJQnZROyI SHOW NOTES teacher's pet refers to a student who is overly favored by the teacher, often because they try to please the teacher. It common have a negative connotation, implying that the student is trying too hard to gain the teacher\u0026rsquo;s approval. scuk up means someone who is overly flattering someone, usually a person in power, like a teacher or boss, in an insincere way to gain favor. smarty pants is a playful or teasing way to describe someone who is very clever or shows off their intelligence, often in a way that annoys others. know-it-all refers to a person who believes they know everything. It\u0026rsquo;s usually used in negative or sarcastic way to describe someone who is seen as arrogant about their knowledge. 31. Sci-fi https://youtu.be/hdcGDXFFiq4 SHOW NOTES blaster is a type of weapon, often seen in science fiction or action movies. break through means to make progress or succeed after overcoming obstacles, which can refer to physical barriers like wall, or more abstract challenges like tough problems. After 15 minutes, the workers broke through the wall, and rescued everyone from the fire. He is such a good player, he broke through the entire defense. They are breaking through our impenetrable wall. settle this means to solve a disagreement or issue. It can be used when there\u0026rsquo;s need to come to a final decision or conclusion about something. I\u0026rsquo;m fed up with arguing about this, let\u0026rsquo;s just settle the argument once and for all. tractor beam is a concept from science fiction, usually referring to a powerful beam used to pull or attract objects toward a spacecraft. no longer be means that something is no longer happening, or someone is no longer in a particular role. I\u0026rsquo;ll no longer be your boyfriend. know nothing of This phrase is often used to express that someone is ignorant or uninformed about a topic. You think you can understand what I\u0026rsquo;m going through, but you know nothing of the struggles I\u0026rsquo;ve faced. once and for all means to finally resolve or finish something, often in a definitive or conclusive way. He claims that his photographs prove once and for all that UFOs do exist. I told him once and for all that I don\u0026rsquo;t want to be his girlfriend anymore. 32. Barber Shop/Hair Salon https://youtu.be/l4jdN_P3UjE SHOW NOTES trim means to cut something or small adjustments, usually to hair. silky is commonly used to describe hair that very soft and smooth to touch. shiny is used to describe something that has a bright, smooth surface, such as shiny hair or a shiny car. grow out means to let something, such as hair or nails, become longer naturally without cutting them. sideburn is the strip of hair that grows along the sides of the face, in front of the ears. take a little off the top is commonly used when someone wants to trim a small amount of hair from the top part of their head. nothing too fancy means something is simple, not elaborate, or not showing off. don't just stand there is used to tell people to take action instead of staying still or doing nothing. Don\u0026rsquo;t just stand there, help me take these boxes into the house. The house is on fire, don\u0026rsquo;t just stand there, call the fire department. look like a million buck means to look very attractive, stylish, or impressive. It\u0026rsquo;s a compliment often used when someone is well-dressed or appears confident and radiant. Mullet is a hairstyle where the front of the hair is short, and the back is left long. It bacame popular in the 1980s. Hockey Hair is a term for a hairstyle similar to the mullet, often associated with hockey players. It’s characterized by long hair in the back and shorter hair in the front. Afro refers to a hairstyle where the hair is naturally grown out and styled into a rounded shape, often associated with African heritage. Mohawk is a hairstyle where the hair is shaved or very short on the sides, with a strip of longer hair running from the front to the back of the head. Flat Top is a hairstyle where the hair is cut short on the sides and top, creating a flat, even surface. crew cut is very short and simple style where the hair on the sides and top is cut short and uniform in length. Dreadlocks is a hairstyle where the hair is matted or twisted into long, rope like strands. It is often associated with various cultures, especially in the Caribbean and African communities. 33. Pharmacy/Drug Store/Chemist https://youtu.be/5J2cwx5gHUI SHOW NOTES price check refers to checking the price of an item, usually at a store or supermarket. Can you do a price check on this shirt? I\u0026rsquo;m not sure if it\u0026rsquo;s on sale. capsule is a medication enclosed in a soft or hard shell, usually made of gelatin. tablet is a solid form of medication that is typically swallowed. overdose means to take more than the recommended or safe amount of a drug. eyedrops means a liquid medication that is applied to the eyes. Prozac is a brand name for the medication fluoxetine, which is used to treat depression, anxiety, and other disorders. be sure means to be certain about something. Be sure not to forget your unbrella, it\u0026rsquo;s raining today. hang on generally means to wait for a short time or hold something tightly. wait: Hang on, I\u0026rsquo;ll be right there. hold: Hang on to the railing while going down the stairs. 34. Baseball https://youtu.be/Uc1GjEKoPZI SHOW NOTES national anthem is a patriotic song officially recognized by a country, often sing at the begining of public events like sports games. hymn is a religous song, typically sing during religious ceremonies or services. pitcher is a player in baseball who throws the ball to the batter from the pitcher\u0026rsquo;s mound. outfielder is a player in baseball who is positioned in the outfield (the area fartest from the home plate) and is responsible for catching fly balls and making throws back to the infield. line drive is a type of hit in baseball where the ball is hit sharply and traight, usually at a low angle. scrambling refers to a player in baseball quickly and awkwardly to avoid being tagged or to regain control of the ball. inning is a division of a baseball game where both teams have a chance to bat and field. The game went into extra innings, and the home team won in the 12th inning. up to bat refers to the player who is currently batting or next in line to the bat in a baseball game. It\u0026rsquo;s your turn, you\u0026rsquo;re up to bat now. strike one refers to a term used in baseball when the batter misses a pitched ball, or doesn\u0026rsquo;t swing at a ball that\u0026rsquo;s in the strike zone. curve ball is a type of pitch in baseball that curves or breaks as it approaches the batter, making it harder to hit. Also used figuratively to mean something unexpected. The pitcher threw a curve ball, and the batter couldn\u0026rsquo;t hit it. My boss threw me a curve ball today, so I have to stay and work late. hit a home run A home run is a term from baseball that refers to a hit in which the batter hits the ball out of the playing field, typically over the outfield fence, without it being caught. In a figurative sense, it means achieving a significant success or accomplishing something exceptionally well. Great job on that sales presentation, you really hit home run. Our sales team hit a home run this month by doubling our revenue. 35. Confess Love https://youtu.be/74FmjXrg0t8 SHOW NOTES here's the thing is used to introduce something important or to explain a situation. Here\u0026rsquo;s the thing, we need to leave in 10 minutes if we want to catch the train. I can't take it anymore is used when someone feels overwhelmed, frustrated, or exhausted by a situation and can no longer handle it. The man next door has been so loud, I can\u0026rsquo;t take it anymore. My boss always yells at me, I can\u0026rsquo;t take it anymore. I can\u0026rsquo;t take it anymore, I\u0026rsquo;m going to quit. are you serious is similar to really, it\u0026rsquo;s often used when something is surprising, unbelievable, or hard to believe. Are you serious? You just won the lottery?! have the guts means having the courage to do something difficult, dangerous, or challenging. I don\u0026rsquo;t think I have the guts to go skydiving. I don\u0026rsquo;t have the guts to give a speech. I\u0026rsquo;ve never had the guts to say no to my boss. just for the two of us means something is meant for only two people, often implying exclusivity or intimacy. I booked a small table at the restaurant, just for the two of us. give me a shot means to give someone a chance to try or attempt something. I know I can do this drawing better, just give me a shot. The HR manager wasn\u0026rsquo;t going to hire me, but he decided to give me a shot. 36. Back In 1950 https://youtu.be/9Ox9lC_Jbuk SHOW NOTES A Sock Hop is a type of informal dance event that was popular in the 1950s and 1960s. A Sadie Hawkins Dance is a type of dance where girls ask the boys to be their dates, instead of the traditional way where boys ask girls. I'm swell is an old-fashioned, informal way of saying \u0026ldquo;I\u0026rsquo;m doing great\u0026rdquo; or \u0026ldquo;I\u0026rsquo;m fine.\u0026rdquo; It was popular in the 1930s and 1940s. How are you feeling today?—I\u0026rsquo;m swell. cool it means to relax or calm down, especially if someone is getting overly excited or angry. It\u0026rsquo;s a way to tell someone to take it easy. Just cool it. Now is not the right time to get angry. You need to cool it and stop yelling at me. knuckle sandwich is a humorous or exaggerated way of referring to a punch in the face. It\u0026rsquo;s a playful way of saying someone might get hit. If you keep talking like that, you might end up with a knuckle sandwich! pipsqueak is a playful term or slightly insulting term for someone who is small or weak, often used for children or someone who\u0026rsquo;s being annoying in a harmless way. Stop being such a pipsqueak and help me carry these boxes. It'll be blast means that something is going to be a lot of fun or exciting. Don\u0026rsquo;t worry, the party\u0026rsquo;s going to be a blast. have my eyes on means to be interested in or focused on something, whether it\u0026rsquo;s a person, a goal, or an object. I\u0026rsquo;ve had my eyes on that new phone for a while. ease off means to reduce the intensity, pressure, or effort being applied to something or someone. It’s used when someone is doing something too forcefully, and you suggest they should stop being so intense or give more space. You\u0026rsquo;re pushing Susie too much, you need to ease off a bit. You need to ease off the junk food. Matt is putting so much pressure on me these days, I wish he would ease off. Scok Hop Sadie Hawkins Dance 37. Back In 1970 https://youtu.be/lJqo8PYZbBc SHOW NOTES roller rink ia a place where people go to skate. A roller skate is a type of skate with four wheels arranged in two rows, like a small car\u0026rsquo;s wheels. A roller blade is a type of skate with wheels arranged in a single line. groovy is a slang term from the 1960s-70s meaning \u0026ldquo;cool\u0026rdquo; or \u0026ldquo;awesome\u0026rdquo;. far out ia slang term in 1970s meaning \u0026ldquo;amazing\u0026rdquo; or \u0026ldquo;incredible\u0026rdquo;. foxy is used to describe someone as very attractive or sexy. mellow out means to relax or calm down. You need to mellow out after a stressful day. right on is a phrase showing aggrement or excitement, similar to saying \u0026ldquo;exactly\u0026rdquo; or \u0026ldquo;that\u0026rsquo;s great\u0026rdquo;. Right on, you got a high score, that\u0026rsquo;s amazing. gravy is a slang for something extra good or easy, like a bonus. This raise was gravy on top of the promotion. to book is a casual way to say \u0026ldquo;leave quickly\u0026rdquo; or \u0026ldquo;run away\u0026rdquo;. We need to book before it gets too late. how's it hanging is a casual way of saying \u0026ldquo;how are you?\u0026rdquo; chat her up is a british slang phrase meaning to start a conversation with someone, usually flirting. hit someone up is a casual way to say \u0026ldquo;contact someone\u0026rdquo;, often to ask for something, either by calling, texting, or meeting. Can you believe Patrick, he came up to me a month ago, and tried to hit me up for some money. When I was a kid, I used to always hit my dead up for lunch money. This is the last time I lend you money, don\u0026rsquo;t even try to hit me up for more. grab some grub is a casual phrase meaning \u0026ldquo;get something to eat.\u0026rdquo; Grub is a slang term for food. Let\u0026rsquo;s grab some grub before the movie. ","permalink":"https://signalyu.github.io/posts/3-humanities/languages/english/1-learning-english-with-podcasts/","summary":"1. Order Food in Restaurant https://youtu.be/_izDbJ45Q5I SHOW NOTES I'm still working on it. This sentence expresses that an action is ongoing and not yet completed. It also suggests that more time is needed to finish it. Did you finish reading? — I\u0026rsquo;m still working on it. Did you fix my car? — I\u0026rsquo;m still working on it. Coke and Fries This refers to a popular combination of fast food: Coca-cola and French Fries.","title":"Learning English With Podcasts"},{"content":"IDEA Postfix Completion Postfix completion allows writing code faster by adding expressions after a variable or value. It can be customized to suit specific coding needs.\n\u0026#34;Hello\u0026#34;.var → String s = \u0026#34;Hello\u0026#34;; Live Templates Live Templates are predefined code snippets that can be inserted quickly using a shortcut. It can be customized to suit specific coding needs.\nsout → System.out.println(); Keyboard Shortcuts Show Hint: Alt + Enter Show Parameter Info: Ctrl + P Surround with Selected Code Block: Ctrl + Alt + J Start a New Line: Shift + Enter Start a New Line Before Current: Ctrl + Alt + Enter Show Live Template: Ctrl + J Rename in Batch: Shift + F6 Extract Method: Ctrl + Alt + M Override Methods: Ctrl + O Implement Methods: Ctrl + I Optimize Imports: Ctrl + Alt + O View Source Code: Ctrl + N → Ctrl + F12 Go to Previous Edit Location: Ctrl + Alt + ← Go to Next Edit Location: Ctrl + Alt + → Show Inheritance Tree: Ctrl + H Show Quick Documentation: Ctrl + Q Show UML Diagram: Ctrl + Alt + U Go to Specified Line: Ctrl + G → Enter line number Go to Variable Definition: Ctrl + Alt + B Expand Code Block: Ctrl + Shift + + Collapse Code Block: Ctrl + Shift + - Debug Method Breakpoints Field Breakpoints Conditional Breakpoints Thread Debug Custom Data Views Config Tomcat Create Maven Java Project Create Maven Java Web Maven Introduction to Maven Maven is a build automation and project management tool primarily used for Java projects. It follows the concept of Project Object Model (POM), which is defined in an XML file (pom.xml) at the root of the project.\nsettings.xml Configuration SHOW CODE settings.xml ./ ├── bin/ │ ├── m2.conf │ ├── mvn* │ ├── mvn.cmd │ ├── mvnDebug* │ ├── mvnDebug.cmd │ └── mvnyjp* ├── boot/ │ ├── plexus-classworlds-2.7.0.jar │ └── plexus-classworlds.license ├── conf/ │ ├── logging/ │ │ └── simplelogger.properties │ ├── settings.xml # CUSTOMIZE DEFAULT BEHAVIOR IN THIS FILE │ └── toolchains.xml ├── ... The settings.xml file in Maven is typically used to customize the default behavior according to user needs. Common modifications include configuring repository locations, setting up mirrors, and defining profiles.\nSHOW CODE: Configuring Repository Location Configuring Repository Location \u0026lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: ${user.home}/.m2/repository \u0026lt;localRepository\u0026gt;/path/to/local/repo\u0026lt;/localRepository\u0026gt; --\u0026gt; \u0026lt;localRepository\u0026gt;/Users/signalfish/maven-repository\u0026lt;/localRepository\u0026gt; SHOW CODE: Setting Up Mirrors Setting Up Mirrors \u0026lt;mirrors\u0026gt; \u0026lt;!-- mirror | Specifies a repository mirror site to use instead of a given repository. The repository that | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used | for inheritance and direct lookup purposes, and must be unique across the set of mirrors. | \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;mirrorId\u0026lt;/id\u0026gt; \u0026lt;mirrorOf\u0026gt;repositoryId\u0026lt;/mirrorOf\u0026gt; \u0026lt;name\u0026gt;Human Readable Name for this Mirror.\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://my.repository.com/repo/path\u0026lt;/url\u0026gt; \u0026lt;/mirror\u0026gt; --\u0026gt; \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;alimaven\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;aliyun maven\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://maven.aliyun.com/nexus/content/groups/public/\u0026lt;/url\u0026gt; \u0026lt;mirrorOf\u0026gt;central\u0026lt;/mirrorOf\u0026gt; \u0026lt;/mirror\u0026gt; \u0026lt;/mirrors\u0026gt; SHOW CODE: Defining Profiles Defining Profiles \u0026lt;profiles\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;env-dev\u0026lt;/id\u0026gt; \u0026lt;activation\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;target-env\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;dev\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/activation\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;tomcatPath\u0026gt;/path/to/tomcat/instance\u0026lt;/tomcatPath\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/profile\u0026gt; --\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;jdk-1.8\u0026lt;/id\u0026gt; \u0026lt;activation\u0026gt; \u0026lt;activeByDefault\u0026gt;true\u0026lt;/activeByDefault\u0026gt; \u0026lt;jdk\u0026gt;1.8\u0026lt;/jdk\u0026gt; \u0026lt;/activation\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;1.8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;1.8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;maven.compiler.compilerVersion\u0026gt;1.8\u0026lt;/maven.compiler.compilerVersion\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;jdk-17\u0026lt;/id\u0026gt; \u0026lt;activation\u0026gt; \u0026lt;activeByDefault\u0026gt;true\u0026lt;/activeByDefault\u0026gt; \u0026lt;jdk\u0026gt;17\u0026lt;/jdk\u0026gt; \u0026lt;/activation\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;17\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;17\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;maven.compiler.compilerVersion\u0026gt;17\u0026lt;/maven.compiler.compilerVersion\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/profiles\u0026gt; GAVP In Maven, GAVP refers to four key components that are used to uniquely identify and describe an artifact (e.g., WAR, JAR, or POM) in a Maven repository.\nG stands for GroupID, which represents the organization or group responsible for the artifact. It typically follows the reverse domain name convention, such as \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; or \u0026lt;groupId\u0026gt;dev.signalyu\u0026lt;/groupId\u0026gt;. A stands for ArtifactID, which identifies the specific artifact within the group. It usually matches the project name or module name, such as \u0026lt;artifactId\u0026gt;my-app\u0026lt;/artifactId\u0026gt;. V stands for Version, which specifies the version of the artifact, such as \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt;. P stands for Packaging, which specifies the type of artifact. It tells Maven what kind of output to expect from the project, such as a JAR file for a library or a WAR file for a web application, such as \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt;. Common Maven Commands mvn compile: Compiles the source code of the project. mvn test: Compiles the source code, runs unit tests, and reports the results. mvn package: Compiles the source code, runs unit tests, and packages the compiled code into desired artifact. mvn clean: Removes the previously compiled files and generated artifacts. mvn install: Compiles the source code, runs unit tests, packages the compiled code into an artifact, and installs it into local Maven repository. mvn deploy: Compiles the source code, runs unit tests, packages the compiled code into an artifact, and deploys the artifact to a remote repository. Maven Dependency Download Failure When Maven fails to download dependencies, follow these steps to resolve the issue:\nCheck the network connection: Ensure a stable internet connection. If an internal network is used, verify the mirror configuration in settings.xml to ensure it\u0026rsquo;s correctly set up. Verify the dependency version: Double-check the version of the dependency specified in pom.xml. Clean the local repository: If the previous steps don\u0026rsquo;t resolve the issue, try cleaning the local Maven repository or deleting the specific dependency directory in the repository. Invalidate caches in the IDE: In IntelliJ IDEA, navigate to File -\u0026gt; Invalidate Caches to clear any cached information that might be causing issues. Then, restart the IntelliJ IDEA. Dependency Inheritence In Maven, dependency inheritance refers to the ability to inherit dependencies from a parent project. This feature enables better management of dependencies in multi-module projects, where a child module can inherit dependency configurations from the parent POM.\nSHOW CODE Parent POM Child POM \u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;parent-project\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; \u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;child-project1\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;child-project2\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.12\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- These dependencies can be inherited by child projects --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.commons\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-lang3\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.12.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; \u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;parent-project\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;relativePath\u0026gt;../pom.xml\u0026lt;/relativePath\u0026gt; \u0026lt;!-- Path to the parent POM --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;artifactId\u0026gt;child-project1\u0026lt;/artifactId\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- Child module can use the dependency inherited from the parent --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-core\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; In the above code, The spring-core dependency is inherited from the parent, and the version is automatically resolved by Maven from the parent’s dependencyManagement section. The commons-lang3 dependency from the parent is also inherited, but does not need to be re-declared in the child POM.\nThe difference between dependencyManagement and dependencies is that dependencies directly add dependencies to the project build, meaning they are included in the project\u0026rsquo;s final artifact. On the other hand, dependencyManagement specifies the version and configuration of dependencies for inheritance in child modules, without directly adding them to the project build.\nGit Backend Development Microservices Architecture Class Design Features Read Base Attribute ER Diagram SHOW CODE Java @RestController @RequestMapping(value = \u0026quot;/api/album\u0026quot;) public class BaseCategoryApiController { @Autowired BaseCategoryService baseCategoryService; @GetMapping(\u0026quot;/category/findAttribute/{category1Id}\u0026quot;) public Result\u0026lt;List\u0026lt;BaseAttribute\u0026gt;\u0026gt; getAttributeByCategory1Id(@PathVariable @Min(1) Long category1Id) { List\u0026lt;BaseAttribute\u0026gt; list = baseCategoryService.getAttributeByCategory1Id(category1Id); return Result.ok(list); } } public interface BaseCategoryService extends IService\u0026lt;BaseCategory1\u0026gt; { List\u0026lt;BaseAttribute\u0026gt; getAttributeByCategory1Id(Long category1Id); } public class BaseCategoryServiceImpl extends ServiceImpl\u0026lt;BaseCategory1Mapper, BaseCategory1\u0026gt; implements BaseCategoryService { @Autowired private BaseAttributeMapper baseAttributeMapper; public List\u0026lt;BaseAttribute\u0026gt; getAttributeByCategory1Id(Long category1Id) { return baseAttributeMapper.getAttributeByCategory1Id(category1Id); } } @Mapper public interface BaseAttributeMapper extends BaseMapper\u0026lt;BaseAttribute\u0026gt; { List\u0026lt;BaseAttribute\u0026gt; getAttributeByCategory1Id(@Param(\u0026quot;category1Id\u0026quot;) Long category1Id); } \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026quot;-//mybatis.org//DTD Mapper 3.0//EN\u0026quot; \u0026quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026quot; \u0026gt; \u0026lt;mapper namespace=\u0026quot;dev.signalyu.tingshu.album.mapper.BaseAttributeMapper\u0026quot;\u0026gt; \u0026lt;resultMap id=\u0026quot;baseAttributeMap\u0026quot; type=\u0026quot;dev.signalyu.tingshu.model.album.BaseAttribute\u0026quot; autoMapping=\u0026quot;true\u0026quot;\u0026gt; \u0026lt;id column=\u0026quot;id\u0026quot; property=\u0026quot;id\u0026quot; /\u0026gt; \u0026lt;collection property=\u0026quot;attributeValueList\u0026quot; ofType=\u0026quot;dev.signalyu.tingshu.model.album.BaseAttributeValue\u0026quot; autoMapping=\u0026quot;true\u0026quot;\u0026gt; \u0026lt;id column=\u0026quot;base_attribute_value_id\u0026quot; property=\u0026quot;id\u0026quot; /\u0026gt; \u0026lt;/collection\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026quot;getAttributeByCategory1Id\u0026quot; resultMap=\u0026quot;baseAttributeMap\u0026quot;\u0026gt; select ba.id, ba.category1_id, ba.attribute_name, bav.id as base_attribute_value_id, bav.value_name from base_attribute as ba left join base_attribute_value bav on ba.id = bav.attribute_id where category1_id = #{category1Id} and ba.is_deleted = 0; \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; @Data @TableName(\u0026quot;base_attribute\u0026quot;) public class BaseAttribute extends BaseEntity { private static final long serialVersionUID = 1L; @Schema(description = \u0026quot;Category 1 ID\u0026quot;) @TableField(\u0026quot;category1_id\u0026quot;) private Long category1Id; @Schema(description = \u0026quot;Attribute display name\u0026quot;) @TableField(\u0026quot;attribute_name\u0026quot;) private String attributeName; @TableField(exist = false) private List\u0026lt;BaseAttributeValue\u0026gt; attributeValueList; } @Data @TableName(\"base_attribute_value\") public class BaseAttributeValue extends BaseEntity { private static final long serialVersionUID = 1L; @Schema(description = \"Attribute ID\") @TableField(\"attribute_id\") private Long attributeId; @Schema(description = \"Attribute value name\") @TableField(\"value_name\") private String valueName; } SHOW RESULT SET id category1_id attribute_name base_attribute_value_id value_name 1 2 Audiobook Type 1 Male-oriented Novels 1 2 Audiobook Type 2 Female-oriented Novels 2 2 Payment Type 3 Paid 2 2 Payment Type 4 Free SHOW NOTES Architecture Flow: Controller → BaseCategoryService (Interface) → BaseCategoryServiceImpl (Implementation) → Uses: - baseMapper (for BaseCategory1 CRUD) - baseAttributeMapper (for custom queries) namespace: The namespace defines the Java interface that the XML mapper is associated with. It is used to uniquely identify the mapper in the context of MyBatis. In the above code, dev.signalyu.tingshu.album.mapper.BaseAttributeMapper represents the fully qualified name of the Java interface that the mapper belongs to. This means that the methods declared in the interface BaseAttributeMapper will use the SQL statements defined in the XML file. resultMap/collection/autoMapping: The resultMap is used to define how the result set from a query is mapped to Java objects. The collection element is used to map a collection of objects (e.g., List, Set) that are related to the main object being mapped. The autoMapping attribute tells MyBatis to automatically map the fields of the result set to the properties of the Java object. In the above code, The id=\u0026quot;baseAttributeMap\u0026quot; defines a mapping for BaseAttribute class, where the columns of the result set are mapped to the fields of the BaseAttribute class. The column=\u0026quot;id\u0026quot; in result set maps to the property=\u0026quot;id\u0026quot; field in BaseAttribute. The column=\u0026quot;base_attribute_value_id\u0026quot; inside the collection tag maps to the property=\u0026quot;id\u0026quot; field in BaseAttributeValue. The select statement inside the mapper doesn\u0026rsquo;t query attribute_id field. When mybatis performs mapping, the attributeId in BaseAttributeValue objects will be null. Update ER Diagram: album_info \u0026amp; album_stat SHOW CODE Java @RestController @RequestMapping(\u0026quot;api/album\u0026quot;) public class AlbumInfoApiController { @Autowired private AlbumInfoService albumInfoService; @PostMapping(\u0026quot;/albumInfo/saveAlbumInfo\u0026quot;) public Result saveAlbumInfo(@RequestBody @Validated AlbumInfoVo albumInfoVo){ Long userId = AuthContextHolder.getUserId(); albumInfoService.saveAlbumInfo(userId, albumInfoVo); return Result.ok(); } } public interface AlbumInfoService extends IService\u0026lt;AlbumInfo\u0026gt; { void saveAlbumInfo(Long userId, AlbumInfoVo albumInfoVo); void saveAlbumStat(Long albumId, String statType, int statNum); } @Service public class AlbumInfoServiceImpl extends ServiceImpl\u0026lt;AlbumInfoMapper, AlbumInfo\u0026gt; implements AlbumInfoService { @Autowired private AlbumInfoMapper albumInfoMapper; @Autowired private AlbumAttributeValueMapper albumAttributeValueMapper; @Autowired private AlbumStatMapper albumStatMapper; @Override @Transactional(rollbackFor = Exception.class) public void saveAlbumInfo(Long userId, AlbumInfoVo albumInfoVo) { AlbumInfo albumInfo = BeanUtil.copyProperties(albumInfoVo, AlbumInfo.class); albumInfo.setUserId(userId); albumInfo.setIncludeTrackCount(0); albumInfo.setIsFinished(\u0026quot;0\u0026quot;); albumInfo.setTracksForFree(5); albumInfo.setStatus(SystemConstant.ALBUM_STATUS_PASS); albumInfoMapper.insert(albumInfo); Long albumId = albumInfo.getId(); List\u0026lt;AlbumAttributeValueVo\u0026gt; albumAttributeValueVoList = albumInfoVo.getAlbumAttributeValueVoList(); if (CollectionUtil.isNotEmpty(albumAttributeValueVoList)) { for (AlbumAttributeValueVo albumAttributeValueVo : albumAttributeValueVoList) { AlbumAttributeValue albumAttributeValue = BeanUtil.copyProperties(albumAttributeValueVo, AlbumAttributeValue.class); albumAttributeValue.setAlbumId(albumId); albumAttributeValueMapper.insert(albumAttributeValue); } } this.saveAlbumStat(albumId, SystemConstant.ALBUM_STAT_PLAY, 0); this.saveAlbumStat(albumId, SystemConstant.ALBUM_STAT_SUBSCRIBE, 0); this.saveAlbumStat(albumId, SystemConstant.ALBUM_STAT_BUY, 0); this.saveAlbumStat(albumId, SystemConstant.ALBUM_STAT_COMMENT, 0); } @Override public void saveAlbumStat(Long albumId, String statType, int statNum) { AlbumStat albumStat = new AlbumStat(); albumStat.setAlbumId(albumId); albumStat.setStatType(statType); albumStat.setStatNum(statNum); albumStatMapper.insert(albumStat); } } SHOW NOTES public interface AlbumInfoService extends IService\u0026lt;AlbumInfo\u0026gt; {} public class ServiceImpl\u0026lt;M extends BaseMapper\u0026lt;T\u0026gt;, T\u0026gt; implements IService\u0026lt;T\u0026gt; {} public interface BaseMapper\u0026lt;T\u0026gt; extends Mapper\u0026lt;T\u0026gt; {} public interface AlbumInfoMapper extends BaseMapper\u0026lt;AlbumInfo\u0026gt; {} public interface AlbumAttributeValueMapper extends BaseMapper\u0026lt;AlbumAttributeValue\u0026gt; {} public interface AlbumStatMapper extends BaseMapper\u0026lt;AlbumStat\u0026gt; {} public class AlbumInfoServiceImpl extends ServiceImpl\u0026lt;AlbumInfoMapper, AlbumInfo\u0026gt; implements AlbumInfoService { // ... albumInfoMapper.insert(albumInfo); // ... albumAttributeValueMapper.insert(albumAttributeValue); // ... albumStatMapper.insert(albumStat); } The BaseMapper\u0026lt;T\u0026gt; interface provides ready-to-use database operations, eliminating the need for a mapper.xml file. As a result, the three mappers—albumInfoMapper, albumAttributeValueMapper, and albumStatMapper—can utilize the insert method without the need to write a mapper.xml file.\nDelete Using Views Views are useful in several scenarios, including when complex queries are frequently used or when providing controlled access to specific data for security purposes.\nCategory ER Diagram SHOW CODE SQL CREATE OR REPLACE VIEW base_category_view AS SELECT bc3.id, bc1.id category1_id, bc1.name category1_name, bc2.id category2_id, bc2.name category2_name, bc3.id category3_id, bc3.name category3_name, bc3.is_deleted, bc3.create_time, bc3.update_time FROM base_category1 bc1 LEFT JOIN base_category2 bc2 ON bc2.category1_id = bc1.id LEFT JOIN base_category3 bc3 ON bc3.category2_id = bc2.id; -- Basic query SELECT * FROM base_category_view; -- Filtered query SELECT category1_name, category2_name, category3_name FROM base_category_view WHERE is_deleted = 0; Grouping Show Data category1_id category1_name category2_id category2_name category3_id category3_name 1 Music 101 Music Effects 1001 Hypnotic Music 1 Music 101 Music Effects 1002 Relaxation Music 1 Music 101 Music Effects 1003 Energizing Music 1 Music 101 Music Effects 1004 Prenatal Music 1 Music 101 Music Effects 1005 Workout Music 1 Music 101 Music Effects 1006 Leisure Music 1 Music 102 Course Guidance 1007 Sleep Assistance Guide 1 Music 102 Course Guidance 1008 Relaxation Guide 1 Music 102 Course Guidance 1009 Focus Guide 1 Music 102 Course Guidance 1010 Children Sleep Guide 1 Music 102 Course Guidance 1011 Other 1 Music 103 Host Music Show 1012 Classic Music Recommendation 1 Music 103 Host Music Show 1013 Hot Song Roundup 1 Music 103 Host Music Show 1014 Cover Songs 1 Music 103 Host Music Show 1015 Music Education 1 Music 103 Host Music Show 1016 Music Stories 2 Audiobook 104 Male Frequency Novels 1018 Military Novels 2 Audiobook 104 Male Frequency Novels 1019 Sports Novels 2 Audiobook 104 Male Frequency Novels 1020 Alternate Dimensions 2 Audiobook 104 Male Frequency Novels 1021 Fantasy 2 Audiobook 104 Male Frequency Novels 1022 Suspense \u0026amp; Paranormal 2 Audiobook 104 Male Frequency Novels 1023 Martial Arts 2 Audiobook 104 Male Frequency Novels 1024 Urban 2 Audiobook 104 Male Frequency Novels 1025 Immortal Heroes 2 Audiobook 104 Male Frequency Novels 1026 Fantasy Fiction 2 Audiobook 104 Male Frequency Novels 1027 Historical Novels 2 Audiobook 104 Male Frequency Novels 1028 Game Novels 2 Audiobook 104 Male Frequency Novels 1029 Science Fiction 2 Audiobook 105 Female Frequency Novels 1030 Fantasy Romance 2 Audiobook 105 Female Frequency Novels 1031 Romantic Youth 2 Audiobook 105 Female Frequency Novels 1032 Modern Romance 2 Audiobook 105 Female Frequency Novels 1033 Ancient Romance SHOW CODE Java Json @RestController @RequestMapping(value = \u0026quot;/api/album\u0026quot;) public class BaseCategoryApiController { @Autowired private BaseCategoryService baseCategoryService; @GetMapping(\u0026quot;/category/getBaseCategoryList\u0026quot;) public Result\u0026lt;List\u0026lt;JSONObject\u0026gt;\u0026gt; getBaseCategoryList() { List\u0026lt;JSONObject\u0026gt; list = baseCategoryService.getBaseCategoryList(); return Result.ok(list); } } public interface BaseCategoryService extends IService\u0026lt;BaseCategory1\u0026gt; { List\u0026lt;JSONObject\u0026gt; getBaseCategoryList(); } @Service public class BaseCategoryServiceImpl extends ServiceImpl\u0026lt;BaseCategory1Mapper, BaseCategory1\u0026gt; implements BaseCategoryService { @Autowired private BaseCategory1Mapper baseCategory1Mapper; @Autowired private BaseCategory2Mapper baseCategory2Mapper; @Autowired private BaseCategory3Mapper baseCategory3Mapper; @Autowired private BaseCategoryViewMapper baseCategoryViewMapper; @Override public List\u0026lt;JSONObject\u0026gt; getBaseCategoryList() { // Create target collection List\u0026lt;JSONObject\u0026gt; allList = new ArrayList\u0026lt;\u0026gt;(); // Query all category data from view List\u0026lt;BaseCategoryView\u0026gt; allCategoryList = baseCategoryViewMapper.selectList(null); // Process level 1 categories - group by level 1 category ID // Using Stream to group into Map where key=level1Id, value=list of categories Map\u0026lt;Long, List\u0026lt;BaseCategoryView\u0026gt;\u0026gt; category1Map = allCategoryList.stream() .collect(Collectors.groupingBy(BaseCategoryView::getCategory1Id)); if (CollectionUtil.isNotEmpty(category1Map)) { for (Map.Entry\u0026lt;Long, List\u0026lt;BaseCategoryView\u0026gt;\u0026gt; entry1 : category1Map.entrySet()) { // Process each level 1 category Long category1Id = entry1.getKey(); String category1Name = entry1.getValue().get(0).getCategory1Name(); // Build level 1 category JSON object JSONObject jsonObject1 = new JSONObject(); jsonObject1.put(\u0026quot;categoryId\u0026quot;, category1Id); jsonObject1.put(\u0026quot;categoryName\u0026quot;, category1Name); // Process level 2 categories within current level 1 category Map\u0026lt;Long, List\u0026lt;BaseCategoryView\u0026gt;\u0026gt; category2Map = entry1.getValue().stream() .collect(Collectors.groupingBy(BaseCategoryView::getCategory2Id)); if (CollectionUtil.isNotEmpty(category2Map)) { List\u0026lt;JSONObject\u0026gt; jsonObject2List = new ArrayList\u0026lt;\u0026gt;(); for (Map.Entry\u0026lt;Long, List\u0026lt;BaseCategoryView\u0026gt;\u0026gt; entry2 : category2Map.entrySet()) { // Get level 2 category ID and name Long category2Id = entry2.getKey(); String category2Name = entry2.getValue().get(0).getCategory2Name(); // Build level 2 category JSON object JSONObject jsonObject2 = new JSONObject(); jsonObject2.put(\u0026quot;categoryId\u0026quot;, category2Id); jsonObject2.put(\u0026quot;categoryName\u0026quot;, category2Name); // Process level 3 categories within current level 2 category List\u0026lt;JSONObject\u0026gt; jsonObject3List = new ArrayList\u0026lt;\u0026gt;(); for (BaseCategoryView baseCategoryView : entry2.getValue()) { // Get level 3 category ID and name Long category3Id = baseCategoryView.getCategory3Id(); String category3Name = baseCategoryView.getCategory3Name(); // Build level 3 category JSON object JSONObject jsonObject3 = new JSONObject(); jsonObject3.put(\u0026quot;categoryId\u0026quot;, category3Id); jsonObject3.put(\u0026quot;categoryName\u0026quot;, category3Name); jsonObject3List.add(jsonObject3); } // Add level 3 categories to level 2 object's \u0026quot;categoryChild\u0026quot; jsonObject2.put(\u0026quot;categoryChild\u0026quot;, jsonObject3List); jsonObject2List.add(jsonObject2); } // Add level 2 categories to level 1 object's \u0026quot;categoryChild\u0026quot; jsonObject1.put(\u0026quot;categoryChild\u0026quot;, jsonObject2List); } // Add level 1 category to final result list allList.add(jsonObject1); } } return allList; } } @Mapper public interface BaseCategoryViewMapper extends BaseMapper\u0026lt;BaseCategoryView\u0026gt; { } [ { \"categoryName\": \"Music\", \"categoryId\": 1, \"categoryChild\": [ { \"categoryName\": \"Music \u0026 Sound Effects\", \"categoryId\": 101, \"categoryChild\": [ {\"categoryName\": \"Hypnotic Music\", \"categoryId\": 1001}, {\"categoryName\": \"Relaxation Music\", \"categoryId\": 1002}, {\"categoryName\": \"Energizing Music\", \"categoryId\": 1003}, {\"categoryName\": \"Prenatal Music\", \"categoryId\": 1004}, {\"categoryName\": \"Workout Music\", \"categoryId\": 1005}, {\"categoryName\": \"Leisure Music\", \"categoryId\": 1006} ] }, { \"categoryName\": \"Guided Courses\", \"categoryId\": 102, \"categoryChild\": [ {\"categoryName\": \"Sleep Guidance\", \"categoryId\": 1007}, {\"categoryName\": \"Relaxation Guidance\", \"categoryId\": 1008}, {\"categoryName\": \"Focus Guidance\", \"categoryId\": 1009}, {\"categoryName\": \"Children's Sleep Guidance\", \"categoryId\": 1010}, {\"categoryName\": \"Others\", \"categoryId\": 1011} ] }, { \"categoryName\": \"Host Music Programs\", \"categoryId\": 103, \"categoryChild\": [ {\"categoryName\": \"Classic Music Recommendations\", \"categoryId\": 1012}, {\"categoryName\": \"Hot Songs Highlights\", \"categoryId\": 1013}, {\"categoryName\": \"Song Covers\", \"categoryId\": 1014}, {\"categoryName\": \"Music Lessons\", \"categoryId\": 1015}, {\"categoryName\": \"Music Stories\", \"categoryId\": 1016} ] } ] }, { \"categoryName\": \"Audiobooks\", \"categoryId\": 2, \"categoryChild\": [ { \"categoryName\": \"Male-Oriented Fiction\", \"categoryId\": 104, \"categoryChild\": [ {\"categoryName\": \"Military Fiction\", \"categoryId\": 1018}, {\"categoryName\": \"Sports Fiction\", \"categoryId\": 1019}, {\"categoryName\": \"N-Dimensional\", \"categoryId\": 1020}, {\"categoryName\": \"Fantasy\", \"categoryId\": 1021}, {\"categoryName\": \"Suspense \u0026 Supernatural\", \"categoryId\": 1022}, {\"categoryName\": \"Martial Arts\", \"categoryId\": 1023}, {\"categoryName\": \"Urban Fiction\", \"categoryId\": 1024}, {\"categoryName\": \"Xianxia\", \"categoryId\": 1025}, {\"categoryName\": \"Xuanhuan\", \"categoryId\": 1026}, {\"categoryName\": \"Historical Fiction\", \"categoryId\": 1027}, {\"categoryName\": \"Gaming Fiction\", \"categoryId\": 1028}, {\"categoryName\": \"Science Fiction\", \"categoryId\": 1029} ] }, { \"categoryName\": \"Female-Oriented Fiction\", \"categoryId\": 105, \"categoryChild\": [ {\"categoryName\": \"Fantasy Romance\", \"categoryId\": 1030}, {\"categoryName\": \"Youth Romance\", \"categoryId\": 1031}, {\"categoryName\": \"Modern Romance\", \"categoryId\": 1032}, {\"categoryName\": \"Historical Romance\", \"categoryId\": 1033} ] } ] } ] Paging Query, Dynamic Query, Row-to-Column Transformation ER Diagram: album_info \u0026amp; album_stat SHOW DATA SETS album_info Table: id album_title cover_url include_track_count create_time 1 Night Piano Melodies https://imagev2...xxx.png 55 2023-04-04 09:05:02 2 Classic Gramophone https://imagev2...yyy.png 55 2023-04-04 09:05:27 album_stat Table: album_id stat_type stat_num 1 0401 1 1 0402 0 1 0403 0 1 0404 999 2 0401 1 2 0402 0 2 0403 0 2 0404 0 SHOW CODE Java @RestController @RequestMapping(\u0026quot;api/album\u0026quot;) public class AlbumInfoApiController { @PostMapping(\u0026quot;/albumInfo/findUserAlbumPage/{page}/{limit}\u0026quot;) @TingshuLogin public Result\u0026lt;Page\u0026lt;AlbumListVo\u0026gt;\u0026gt; getUserAlbumPage(@RequestBody AlbumInfoQuery albumInfoQuery, @PathVariable int page, @PathVariable int limit) { // Get user ID and set it to query object Long userId = AuthContextHolder.getUserId(); albumInfoQuery.setUserId(userId); // Use MyBatisPlus pagination at controller level Page\u0026lt;AlbumListVo\u0026gt; pageInfo = new Page\u0026lt;\u0026gt;(page, limit); pageInfo = albumInfoService.getUserAlbumPage(pageInfo, albumInfoQuery); return Result.ok(pageInfo); } } public interface AlbumInfoService extends IService\u0026lt;AlbumInfo\u0026gt; { Page\u0026lt;AlbumListVo\u0026gt; getUserAlbumPage(Page\u0026lt;AlbumListVo\u0026gt; pageInfo, AlbumInfoQuery albumInfoQuery); } @Service public class AlbumInfoServiceImpl extends ServiceImpl\u0026lt;AlbumInfoMapper, AlbumInfo\u0026gt; implements AlbumInfoService { @Override public Page\u0026lt;AlbumListVo\u0026gt; getUserAlbumPage(Page\u0026lt;AlbumListVo\u0026gt; pageInfo, AlbumInfoQuery albumInfoQuery) { return albumInfoMapper.getUserAlbumPage(pageInfo, albumInfoQuery); } } @Mapper public interface AlbumInfoMapper extends BaseMapper\u0026lt;AlbumInfo\u0026gt; { Page\u0026lt;AlbumListVo\u0026gt; getUserAlbumPage(Page\u0026lt;AlbumListVo\u0026gt; pageInfo, @Param(\u0026quot;vo\u0026quot;) AlbumInfoQuery albumInfoQuery); } \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026quot;-//mybatis.org//DTD Mapper 3.0//EN\u0026quot; \u0026quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026quot; \u0026gt; \u0026lt;mapper namespace=\u0026quot;dev.signalyu.tingshu.album.mapper.AlbumInfoMapper\u0026quot;\u0026gt; \u0026lt;select id=\u0026quot;getUserAlbumPage\u0026quot; resultType=\u0026quot;dev.signalyu.tingshu.vo.album.AlbumListVo\u0026quot;\u0026gt; select ai.id albumId, ai.album_title, ai.cover_url, ai.include_track_count, ai.create_time, max(if(stat.stat_type = '0401', stat_num, 0)) playStatNum, max(if(stat.stat_type = '0402', stat_num, 0)) subscribeStatNum, max(if(stat.stat_type = '0403', stat_num, 0)) buyStatNum, max(if(stat.stat_type = '0404', stat_num, 0)) commentStatNum from album_info ai inner join album_stat stat on stat.album_id = ai.id \u0026lt;where\u0026gt; \u0026lt;if test=\u0026quot;vo.userId != null\u0026quot;\u0026gt; ai.user_id = #{vo.userId} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026quot;vo.status != null and vo.status != ''\u0026quot;\u0026gt; and ai.status = #{vo.status} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026quot;vo.albumTitle != null and vo.albumTitle != ''\u0026quot;\u0026gt; and ai.album_title like concat('%', #{vo.albumTitle} ,'%') \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; and ai.is_deleted = 0 group by ai.id order by ai.id desc \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; SHOW RESULT SETS Result Sets: albumId album_title cover_url include_track_count create_time playStatNum subscribeStatNum buyStatNum commentStatNum 1 Night Piano Melodies https://imagev2...xxx.png 55 2023-04-04 09:05:02 1 0 0 999 2 Classic Gramophone https://imagev2...yyy.png 55 2023-04-04 09:05:27 1 0 0 0 SHOW NOTES MyBatis-Plus dynamically modifies SQL statements for pagination using the PaginationInnerInterceptor. The standard implementation flow is as follows: // Configuration Setup @Configuration @MapperScan(\u0026#34;dev.signalyu.tingshu.*.mapper\u0026#34;) public class MybatisPlusConfig { @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); // Add pagination interceptor with MySQL dialect interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; } } // Pagination Query Execution public class AlbumInfoApiController { Page\u0026lt;AlbumListVo\u0026gt; pageInfo = new Page\u0026lt;\u0026gt;(page, limit); pageInfo = albumInfoService.getUserAlbumPage(pageInfo, albumInfoQuery); } public interface AlbumInfoService extends IService\u0026lt;AlbumInfo\u0026gt; { Page\u0026lt;AlbumListVo\u0026gt; getUserAlbumPage(Page\u0026lt;AlbumListVo\u0026gt; pageInfo, AlbumInfoQuery albumInfoQuery); } public class AlbumInfoServiceImpl extends ServiceImpl\u0026lt;AlbumInfoMapper, AlbumInfo\u0026gt; implements AlbumInfoService { @Override public Page\u0026lt;AlbumListVo\u0026gt; getUserAlbumPage(Page\u0026lt;AlbumListVo\u0026gt; pageInfo, AlbumInfoQuery albumInfoQuery) { return albumInfoMapper.getUserAlbumPage(pageInfo, albumInfoQuery); } } public interface AlbumInfoMapper extends BaseMapper\u0026lt;AlbumInfo\u0026gt; { Page\u0026lt;AlbumListVo\u0026gt; getUserAlbumPage(Page\u0026lt;AlbumListVo\u0026gt; pageInfo, @Param(\u0026#34;vo\u0026#34;) AlbumInfoQuery albumInfoQuery); } Dynamic Query in MyBatis and MyBatisPlus --- MyBatis --- \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;vo.userId != null\u0026#34;\u0026gt; ai.user_id = #{vo.userId} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;vo.status != null and vo.status != \u0026#39;\u0026#39;\u0026#34;\u0026gt; and ai.status = #{vo.status} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;vo.albumTitle != null and vo.albumTitle != \u0026#39;\u0026#39;\u0026#34;\u0026gt; and ai.album_title like concat(\u0026#39;%\u0026#39;, #{vo.albumTitle} ,\u0026#39;%\u0026#39;) \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; --- MyBatisPlus --- QueryWrapper\u0026lt;AlbumInfo\u0026gt; queryWrapper = new QueryWrapper\u0026lt;\u0026gt;(); // \u0026#34;vo\u0026#34; represents an object of AlbumInfoQuery class queryWrapper.eq(vo.getUserId() != null, \u0026#34;user_id\u0026#34;, vo.getUserId()) .eq(vo.getStatus() != null \u0026amp;\u0026amp; !vo.getStatus().isEmpty(), \u0026#34;status\u0026#34;, vo.getStatus()) .like(vo.getAlbumTitle() != null \u0026amp;\u0026amp; !vo.getAlbumTitle().isEmpty(), \u0026#34;album_title\u0026#34;, vo.getAlbumTitle()) .eq(\u0026#34;is_deleted\u0026#34;, 0) .orderByDesc(\u0026#34;id\u0026#34;); albumInfoService.list(queryWrapper); Row-to-Column Transformation --- Use MAX() and IF() --- select ai.id AS albumId, ai.album_title, ai.cover_url, ai.include_track_count, ai.create_time, --- Even though IF() returns only one value (0 or stat_type), --- --- it is necessary to use an aggregate function like MAX() to --- --- ensure proper behavior in the GROUP BY clause --- max(if(stat.stat_type = \u0026#39;0401\u0026#39;, stat_num, 0)) playStatNum, max(if(stat.stat_type = \u0026#39;0402\u0026#39;, stat_num, 0)) subscribeStatNum, max(if(stat.stat_type = \u0026#39;0403\u0026#39;, stat_num, 0)) buyStatNum, max(if(stat.stat_type = \u0026#39;0404\u0026#39;, stat_num, 0)) commentStatNum from album_info ai inner join album_stat stat on stat.album_id = ai.id group by ai.id; --- Use MAX() and CASE...WHEN --- SELECT ai.id AS albumId, ai.album_title, ai.cover_url, ai.include_track_count, ai.create_time, --- Even though IF() returns only one value (0 or stat_type), --- --- it is necessary to use an aggregate function like MAX() to --- --- ensure proper behavior in the GROUP BY clause --- MAX(CASE WHEN stat.stat_type = \u0026#39;0401\u0026#39; THEN stat.stat_num ELSE 0 END) AS playStatNum, MAX(CASE WHEN stat.stat_type = \u0026#39;0402\u0026#39; THEN stat.stat_num ELSE 0 END) AS subscribeStatNum, MAX(CASE WHEN stat.stat_type = \u0026#39;0403\u0026#39; THEN stat.stat_num ELSE 0 END) AS buyStatNum, MAX(CASE WHEN stat.stat_type = \u0026#39;0404\u0026#39; THEN stat.stat_num ELSE 0 END) AS commentStatNum FROM album_info ai INNER JOIN album_stat stat ON stat.album_id = ai.id GROUP BY ai.id, ai.album_title, ai.cover_url, ai.include_track_count, ai.create_time; --- Use GROUP_CONCAT() and IF() --- SELECT ai.id AS albumId, ai.album_title, ai.cover_url, ai.include_track_count, ai.create_time, GROUP_CONCAT(IF(stat.stat_type = \u0026#39;0401\u0026#39;, stat.stat_num, 0) ORDER BY stat.stat_type) AS playStatNum, GROUP_CONCAT(IF(stat.stat_type = \u0026#39;0402\u0026#39;, stat.stat_num, 0) ORDER BY stat.stat_type) AS subscribeStatNum, GROUP_CONCAT(IF(stat.stat_type = \u0026#39;0403\u0026#39;, stat.stat_num, 0) ORDER BY stat.stat_type) AS buyStatNum, GROUP_CONCAT(IF(stat.stat_type = \u0026#39;0404\u0026#39;, stat.stat_num, 0) ORDER BY stat.stat_type) AS commentStatNum FROM album_info ai INNER JOIN album_stat stat ON stat.album_id = ai.id GROUP BY ai.id; It is important to note that when performing row-to-column transformation, applying an aggregate function such as MAX() or GROUP_CONCAT() is necessary. Otherwise, MySQL will raise an exception similar to \u0026ldquo;nonaggregated column is not functionally dependent on columns in GROUP BY clause.\u0026rdquo; For example, running the following query will result in an error message like: SELECT list is not in GROUP BY clause and contains nonaggregated column 'tingshu_album.stat.stat_type' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by.\nSELECT ai.id AS albumId, ai.album_title, ai.cover_url, ai.include_track_count, ai.create_time, if(stat.stat_type = \u0026#39;0401\u0026#39;, stat_num, 0) AS playStatNum, if(stat.stat_type = \u0026#39;0402\u0026#39;, stat_num, 0) AS subscribeStatNum, if(stat.stat_type = \u0026#39;0403\u0026#39;, stat_num, 0) AS buyStatNum, if(stat.stat_type = \u0026#39;0404\u0026#39;, stat_num, 0) AS commentStatNum FROM album_info ai INNER JOIN album_stat stat ON stat.album_id = ai.id GROUP BY ai.id; Database Caching ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/development-manual/1-development-manual/","summary":"IDEA Postfix Completion Postfix completion allows writing code faster by adding expressions after a variable or value. It can be customized to suit specific coding needs.\n\u0026#34;Hello\u0026#34;.var → String s = \u0026#34;Hello\u0026#34;; Live Templates Live Templates are predefined code snippets that can be inserted quickly using a shortcut. It can be customized to suit specific coding needs.\nsout → System.out.println(); Keyboard Shortcuts Show Hint: Alt + Enter Show Parameter Info: Ctrl + P Surround with Selected Code Block: Ctrl + Alt + J Start a New Line: Shift + Enter Start a New Line Before Current: Ctrl + Alt + Enter Show Live Template: Ctrl + J Rename in Batch: Shift + F6 Extract Method: Ctrl + Alt + M Override Methods: Ctrl + O Implement Methods: Ctrl + I Optimize Imports: Ctrl + Alt + O View Source Code: Ctrl + N → Ctrl + F12 Go to Previous Edit Location: Ctrl + Alt + ← Go to Next Edit Location: Ctrl + Alt + → Show Inheritance Tree: Ctrl + H Show Quick Documentation: Ctrl + Q Show UML Diagram: Ctrl + Alt + U Go to Specified Line: Ctrl + G → Enter line number Go to Variable Definition: Ctrl + Alt + B Expand Code Block: Ctrl + Shift + + Collapse Code Block: Ctrl + Shift + - Debug Method Breakpoints Field Breakpoints Conditional Breakpoints Thread Debug Custom Data Views Config Tomcat Create Maven Java Project Create Maven Java Web Maven Introduction to Maven Maven is a build automation and project management tool primarily used for Java projects.","title":"Development Manual"},{"content":"Core Concepts Loose Coupling Loose Coupling is a design principle that aims to reduce the dependencies between components within a system.\nInversion of Control (IoC) Inversion of Control is a design principle where the control of object creation and lifecycle management is transferred from the application code to an external container or framework.\nDependency Injection (DI) Dependency Injection is a design pattern commonly used in object-oriented programming, where the dependecies of a class are provided externally rather than being created within the class itself.\nBeans Beans are objects that are managed by the Spring framework.\nContainer A Spring Container is responsible for managing the life cycle, configuration, and dependencies injection of the beans in a Spring Application.\nLife Cycle of Beans Beans are objects that are managed by the Spring framework. Bean Definition includes configuration meta data required by the Spring container to create and manage the bean. Bean Configurations can be provided in various way, including XML configuration files, annotations, and Java-based configuration. Bean Instantiation $\\rightarrow$ Population of Properties $\\rightarrow$ Initialization $\\rightarrow$ Ready for Use $\\rightarrow$ Destruction The Difference between instantiation and initiation?\nInstantiation occurs when a new keyword is used to create an object. It focus on constructing the object\u0026rsquo;s structure and allocating memory. In contrast, initialization focus on assigning values to the object\u0026rsquo;s fields and setting up its initial state after instantiation.\nConstructor Injection \u0026amp; Setter Injection \u0026amp; Field Injection Constructor Injection Constructor Injection in Spring is a type of dependency injection where the Spring framework provides the required dependency to a class by invoking its constructor. Since dependencies are supplied via the constructor, they cannot be changed after object creation \u0026ndash; promoting immutability. However, this approach may cause circular dependency issues if two or more beans depend on each other in a circular manner.\nSHOW CODE Java @Component public class ServiceA { private final RepositoryA repositoryA; // Constructor injection @Autowired public ServiceA(RepositoryA repositoryA) { this.repositoryA = repositoryA; } } Setter Injection Setter Injection in Spring is a form of dependency injection where the Spring framework injects dependencies into a bean by calling the bean\u0026rsquo;s setter method. This approach is flexible and commonly used to inject optional dependencies or when the dependency might change after the object is initialized.\nSHOW CODE Java @Component public class ServiceB { private RepositoryB repositoryB; // Setter injection @Autowired public void setRepositoryB(RepositoryB repositoryB) { this.repositoryB = repositoryB; } } Field Injection Field Injection in Spring is a form of dependency injection where the Spring framework directly injects dependencies into a class\u0026rsquo;s fields. Like constructor injection, the dependencies remain immutable after being injected. Under the hood. Spring uses reflection to assign values to private fields.\nSHOW CODE Java @Component public class ServiceC { @Autowired private RepositoryC repositoryC; public void performAction() { repositoryC.doSomething(); } } @Component \u0026amp; @ComponentScan The @Component annotation in Spring is used to mark a class as spring-managed bean, allowing Spring to detect and register it as a bean in the application context. The @ComponentScan annotation is used to specify base packages that Spring should scan for @Component-annotated during configuration.\nSHOW CODE Java package com.example.myapp @Component public class MyService { public void performTask() { System.out.println(\"Task performed!\"); } } @Configuration @ComponentScan(basePackages = \"com.example.myapp\") public class AppConfig { } @Value \u0026amp; @Autowired \u0026amp; @Qualifier @Value The @Value annotation is used to inject values into fields, mathod parameters, and constructor arguments.\nSHOW CODE Java // Injects literal values @Value(\"Hello, World!\") private String message; // Injects from a properties file app.name=MySpringApp @Value(\"${app.name}\") private String appName; // Injects default values @Value(\"${app.version:1.0.0}\") private String appVersion; // Injects expression @Value(\"#{T(java.lang.Math).random() * 100}\") private double randomValue; @Autowired The @Autowired annotation is used for automatic dependency injection. It allows Spring resolve and inject the required bean into a class automatically by type.\nSHOW CODE Java // Field Injection @Component public class ServiceA { @Autowired private RepositoryA repositoryA; public void performTask() { repositoryA.doSomething(); } } // Setter Injection @Component public class ServiceB { private RepositoryB repositoryB; @Autowired public void setRepositoryB(RepositoryB repositoryB) { this.repositoryB = repositoryB; } } // Constructor Injection @Component public class ServiceB { private RepositoryB repositoryB; @Autowired public void setRepositoryB(RepositoryB repositoryB) { this.repositoryB = repositoryB; } } @Qualifier The @Qualifier annotation in Spring is used for resolve ambiguities when multiple beans of the same type are available in the application context.\nSHOW CODE Java @Component(\"repositoryImpl1\") public class RepositoryImpl1 implements Repository {} @Component(\"repositoryImpl2\") public class RepositoryImpl2 implements Repository {} @Component public class Service { @Autowired @Qualifier(\"repositoryImpl2\") private Repository repository; } Components of Spring Boot Spring Boot Starter: Simplifies dependency management by building commonly used dependencies, reducing the need for manual configuration.\nAuto Configuration: Automatically configures Spring Boot application beans and settings based on the libraries on the classpath, eliminating the need for extensive configuration in application.properties or XML files.\nSpring Boot Atuator: Provides production-ready features like monitoring, metrics, and health checks to ensure better application insights and management.\nEmbedded Server: Includes servers like Tomcat and Jetty, allowing applications to run as standalone programs, simplifying development and deployment.\nSpring Boot DevTools: A collection of tools that enhance the development experience by enabling features like hot reload and live reload for faster feedback.\nSpring Boot Auto Configuration Spring Boot looks for classes annotated with @Configuration and examines the dependencies in the classpath. The @Configuration annotation triggers the logic that looks for @Bean declarations within the class and registers those beans to be managed by the Spring container.\nIn a Spring Boot application, the main method typically calls the SpringApplication.run() method. This method takes the main application class (e.g., XXXApplication.class) as a parameter. The XXXAplication class is annotated with @SpringBootApplication which includes three key annotations: @SpringBootConfiguration, @EnableAutoConfiguration, and @ComponentScan.\n@SpringBootConfiguration is an alias for @Configurition. It indicates that the class contains Spring bean definitions, and Spring Boot will scan it for @Bean declarations.\n@EnableAutoConfiguration annotation tells Spring Boot to enable its auto-configuration mechanism. It looks for the file AutoConfiguration.imports inside the spring-boot-autoconfigure.jar dependency, which lists auto-configuration classes. Spring Boot automatically imports and executes every class that has the AutoConfiguration name at the end of the class name.\n# META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration org.springframework.boot.autoconfigure.aop.AopAutoConfiguration org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration ... @ComponentScan annotation tells Spring Boot to scan for Spring components (such as @Component, @Service, @Repository, etc.) in the specified packages or the entire classpath. By default, it scans from the package of the class that contains the annotation. To specify a different base package, the basePackages parameter can be set, like this:\n@ComponentScan(basePackages = {\u0026#34;com.mycompany\u0026#34;}) Common Annotations @Component vs. @Bean The @Component annotation is applied to a class to mark it as a bean managed by the Spring container. There are several specialized variants of this annotation: @Controller (for web controllers), @Service (for service layer components), and @Repository (for DAO layer components). In contrast, the @Bean annotation is used to mark a method within a class annotated with @Configuration, indicating that the method should return an object to be managed by the Spring container. This apporpach provides more control over bean creation and configuration, allowing for more explicit customization of the bean.\nSHOW CODE Java // Spring will detect UserService during classpath // scanning and manage it as a bean. @Component public class UserService { public String getUser() { return \"User\"; } } @Configuration public class AppConfig { @Bean public UserService userService() { // Explicitly creating and returning the bean return new UserService(); } } @ResposeBody The @ResponseBody annotation in Spring is used to indicate that a method\u0026rsquo;s return value should be written directly to the HTTP response body, rather than being treated as a view name, which is the default behavior in traditional Spring MVC controllers. The return value is automatically serialized into a format like JSON or XML, typically using Jackson, depending on the request\u0026rsquo;s Accept header.\nSHOW CODE Java @Controller public class MyRestController { @RequestMapping(\"/user\") @ResponseBody public User getUser() { return new User(\"John\", \"Doe\"); } } public class User { private String firstName; private String lastName; // Constructor, getters, and setters } In the above code, the User object will be automatically serialized into JSON format by Jackson when returned from the getUser() method. The @ResponseBody annotation ensures that the method\u0026rsquo;s return value is written directly to the HTTP response body, and Jackson handles the conversion to JSON.\n@Controller vs. @RestController The @Controller annotation is used to declare a class as a controller in Spring MVC. By default, methods within a @Controller-annotated class return a view name (e.g., home.jsp). If a method needs to return a value directly (such as JSON or XML), it should be annotated with @ResponseBody. In contrast, the @RestController annotation is a specialized version of @Controller used to define a controller for RESTful web services. It combines @Controller and @ResponseBody, meaning that the methods in a RestController-annotated class automatically return values written directly to the HTTP response body. This response is typically serialized into JSON or XML format by Jackson.\nSHOW CODE Java @Controller public class WebController { @RequestMapping(\"/home\") public String home() { return \"home\"; // returns home.jsp } } @Controller public class MyController { @RequestMapping(\"/greeting\") @ResponseBody public String greeting() { return \"Hello, World!\"; // The return value is written directly to the response body } } @RestController public class UserController { @RequestMapping(\"/api/user\") public User getUser() { return new User(\"Alice\", \"Smith\"); } } public class User { private String firstName; private String lastName; // Constructor, getters, and setters } @RequestBody, @RequestParam, @PathVariable The @RequestBody annotation is used to bind the body of an HTTP request to a method parameter. It is typically used with HTTP methods like POST, PUT, or PATCH to send data in formats such as JSON or XML. Spring automatically deserializes the request body into an obejct using a message converter, liek Jakson.\nSHOW CODE Java @RestController public class UserController { @PostMapping(\"/user\") public ResponseEntity\u0026lt;String\u0026gt; createUser(@RequestBody User user) { // User is automatically deserialized from the JSON request body return ResponseEntity.ok(\"User created: \" + user.getName()); } } The @RequestParam annotation binds a query parameter or form data to a method parameter. It is commonly used in GET or POST requests to retrive single query parameters. The annotation has optional attributes such as required (to specify if the parameter is mandatory) and defaultValue (to provide a default value when the parameter is absent).\nSHOW CODE Java @RestController public class SearchController { @GetMapping(\"/search\") public ResponseEntity\u0026lt;String\u0026gt; search(@RequestParam String query, @RequestParam(defaultValue = \"10\") int limit) { // query: the search term from the query string // limit: the number of results (defaults to 10 if not provided) return ResponseEntity.ok(\"Searching for: \" + query + \", Limit: \" + limit); } } The @PathVariable annotation binds a URL path variable to a method parameter, commonly used in RESTful web service to capture dynamic segments in the URL. For example, int the URL /user/{id}, the {id} part is dynamic, and the value of {id} will be extracted and passed to the method parameter.\nSHOW CODE Java @RestController public class UserController { // Regular expression to match both with and without the path variable @GetMapping(\"/user/{id:[a-zA-Z0-9]*}\") public ResponseEntity\u0026lt;String\u0026gt; getUser(@PathVariable(required = false) String id) { if (id == null) { return ResponseEntity.ok(\"Default User\"); } return ResponseEntity.ok(\"User ID: \" + id); } } Transformation between Object and Spring In Spring Boot, the transformation between objects and JSON is handled by the Jackson library which allows for easy serialization (converting an object to JSON) and deserialization (converting JSON to an object).\nSHOW CODE Java // When a controller returns an object, Spring Boot automatically // converts it to JSON @RestController public class UserController { @GetMapping(\"/user\") public User getUser() { return new User(1, \"John Doe\", \"john.doe@example.com\"); } } // When accessed via /user, the response is: { \"id\": 1, \"name\": \"John Doe\", \"email\": \"john.doe@example.com\" } // Spring Boot automatically converts the incoming JSON data into // an object when the object is a parameter in the controller method. @RestController public class UserController { @PostMapping(\"/user\") public String createUser(@RequestBody User user) { return \"User \" + user.getName() + \" created!\"; } } // Input JOSN: { \"id\": 2, \"name\": \"Jane Doe\", \"email\": \"jane.doe@example.com\" } ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/framework-and-tools/framework/backend/spring/1-spring-notes/","summary":"Core Concepts Loose Coupling Loose Coupling is a design principle that aims to reduce the dependencies between components within a system.\nInversion of Control (IoC) Inversion of Control is a design principle where the control of object creation and lifecycle management is transferred from the application code to an external container or framework.\nDependency Injection (DI) Dependency Injection is a design pattern commonly used in object-oriented programming, where the dependecies of a class are provided externally rather than being created within the class itself.","title":"Spring"},{"content":"Enum In Java, an enum (short for \u0026ldquo;enumeration\u0026rdquo;) is used to define a collection of constants, such as days of the week or months of the year. An enum provides a type-safe way to handle constant values, and it can be used in a switch statement or for comparison using ==. Compared to a final constant in Java, an enum can contain fields, methods, and constructors. The values() method is used to retrive all the constants in an enum, and the valueOf() method is used to convert a string into an enum constant.\nSHOW CODE Java enum Day { SUNDAY(1), MONDAY(2), TUESDAY(3), WEDNESDA(4), THURSDAY(5), FRIDAY(6), SATURDAY(7); private final int dayNum; Day(int dayNum) { this.dayNum = dayNum; } public int getDayNum() { return dayNum; } public static Day fromNumber(int num) { for (Day day : Day.values()) { if (day.getDayNum() == num) { return day; } } throw new IllegalArgumentException(\"Invalid day number: \" + num); } @Override public String toString() { return name() + \"(\" + dayNum + \")\"; } } public class Solution { public static void main(String[] args) { for (Day d : Day.values()) { System.out.print(d + \"\\t\"); } System.out.println(\"\\n\" + Day.fromNumber(1)); // System.out.println(Day.fromNumber(8)); // Converts a string to enum constant System.out.println(Day.valueOf(\"MONDAY\")); } } Generics In Java, Generics is a mechanism that allows writing classes, interfaces, and methods with type parameters, often represented by T, E, K, and V, and allows calling them with different type parameters. It provides strong type safety checks at compile time, enhances code reusability, and eliminates the need for casting.\nBasic Generics SHOW CODE Java interface Pair { K getKey(); V getValue(); } class SimplePair\u0026lt;K,V\u0026gt; implements Pair\u0026lt;K,V\u0026gt; { private final K key; private final V value; public SimplePair(K key, V value) { this.key = key; this.value = value; } @Override public K getKey() { return key; } @Override public V getValue() { return value; } @Override public String toString() { return \"(\" + key + \",\" + value + \")\"; } } public class Main { public static void main(String[] args) { SimplePair\u0026lt;String, Integer\u0026gt; pair = new SimplePair\u0026lt;\u0026gt;(\"Signal\", 27); System.out.println(\"pair = \" + pair); String key = pair.getKey(); System.out.println(\"key = \" + key); Integer value = pair.getValue(); System.out.println(\"value = \" + value); } } Bounded Type Parameters Bounded Type Parameters in Java allow restricting the range of types when writing generic code. It can be categorized into four types: Upper Bounded Type, Lower Bounded Type, Unbounded Type, and Multiple Bounds.\nUpper Bounded Type In Java, Upper Bounded Wildcards are used to define upper bounded types. The syntax for an upper bounded wildcard is \u0026lt;T extends SomeClassOrInterface\u0026gt;, which indicates that the argument type T must be a subclass of SomeClassOrInterface or SomeClassOrInterface itself.\nSHOW CODE Java import java.util.List; public class Main { // Method that accepts a list of elements that are of type Number or its subclasses public static void printNumbers(List\u0026lt;? extends Number\u0026gt; list) { for (Number number : list) { System.out.println(number); } } public static void main(String[] args) { List\u0026lt;Integer\u0026gt; intList = List.of(1, 2, 3, 4); List\u0026lt;Double\u0026gt; doubleList = List.of(1.1, 2.2, 3.3); printNumbers(intList); // Valid, Integer is a subclass of Number printNumbers(doubleList); // Valid, Double is a subclass of Number } } Lower Bounded Type In Java, Lower Bounded Wildcards are used to define lower bounded types. The syntax for a lower bounded wildcard is \u0026lt;T super SomeClassOrInterface\u0026gt;, which indicates that the argument type T must be a super class of SomeClassOrInterface or SomeClassOrInterface itself.\nSHOW CODE Java import java.util.ArrayList; import java.util.List; // Custom class Person class Person { String name; Person(String name) { this.name = name; } @Override public String toString() { return \"Person{name='\" + name + \"'}\"; } } // Subclass Employee extends Person class Employee extends Person { double salary; Employee(String name, double salary) { super(name); this.salary = salary; } @Override public String toString() { return \"Employee{name='\" + name + \"', salary=\" + salary + \"}\"; } } public class Main { // Method that accepts a list of Person or its superclasses (e.g., Object) // This method can add Employee objects to the list. public static void addEmployees(List\u0026lt;? super Employee\u0026gt; list) { list.add(new Employee(\"Alice\", 50000)); list.add(new Employee(\"Bob\", 60000)); list.add(new Employee(\"Charlie\", 70000)); } public static void main(String[] args) { // Create a list of Person, which is a superclass of Employee List\u0026lt;Person\u0026gt; personList = new ArrayList\u0026lt;\u0026gt;(); // Add Employee objects to the personList using the addEmployees method addEmployees(personList); // Print the list to see the added Employee objects for (Person person : personList) { System.out.println(person); } } } SHOW OUTPUT Output Employee{name='Alice', salary=50000.0} Employee{name='Bob', salary=60000.0} Employee{name='Charlie', salary=70000.0} Unbounded Type In Java, the Unbounded Type is represented by using the unbounded wildcard ?, which indicates that no restrictions are placed on the type of an argument passed to the method. It is commonly used when passing a collection of elements to a method where the specific type of the elements is not important. With an unbounded wildcard, elements can be read but cannot be added to the collection (except null) inside the methods.\nSHOW CODE Java import java.util.ArrayList; import java.util.List; class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } @Override public String toString() { return \"Person(\" + name + \", \" + age + \")\"; } } public class Main { public static void printList(List\u0026lt;?\u0026gt; list) { // Iterate over the list and print each element list.add(null); // list.add(1); for (Object element : list) { System.out.println(element); } } public static void main(String[] args) { // Create lists of different types List\u0026lt;String\u0026gt; stringList = new ArrayList\u0026lt;\u0026gt;(); stringList.add(\"Hello\"); stringList.add(\"World\"); List\u0026lt;Integer\u0026gt; intList = new ArrayList\u0026lt;\u0026gt;(); intList.add(10); intList.add(20); List\u0026lt;Object\u0026gt; objectList = new ArrayList\u0026lt;\u0026gt;(); objectList.add(\"Some String\"); objectList.add(100); objectList.add(1.1); objectList.add('a'); objectList.add(true); objectList.add(new Person(\"Signal\", 18)); objectList.add(null); // Call the printList method for each list System.out.println(\"String List:\"); printList(stringList); // Works with List\u0026lt;String\u0026gt; System.out.println(\"\\nInteger List:\"); printList(intList); // Works with List\u0026lt;Integer\u0026gt; System.out.println(\"\\nObject List:\"); printList(objectList); // Works with List\u0026lt;Object\u0026gt; } } SHOW OUTPUT Output String List: Hello World Integer List: 10 20 Object List: Some String 100 1.1 a true Person(Signal, 18) null null Multiple Bounds In Java, a Multiple Bounds constraint allows the argument type T passed to a method to extend multiple types or implement multiple interfaces. This is commonly achieved using the \u0026amp; operator. The syntax for multiple bounds is \u0026lt;T extends classType \u0026amp; Interface1 \u0026amp; Interface2\u0026gt;, indicating that the argument type T must extend the class classType and implement both Interface1 and Interface2.\nSHOW CODE Java // Interface 1 interface CanFly { void fly(); } // Interface 2 interface CanSwim { void swim(); } // A base class for animals class Animal { String name; Animal(String name) { this.name = name; } } // Class that implements both interfaces class Duck extends Animal implements CanFly, CanSwim { Duck(String name) { super(name); } @Override public void fly() { System.out.println(name + \" is flying.\"); } @Override public void swim() { System.out.println(name + \" is swimming.\"); } } // A class that uses multiple bounds in its type parameter class AnimalAction\u0026lt;T extends Animal \u0026 CanFly \u0026 CanSwim\u0026gt; { T animal; AnimalAction(T animal) { this.animal = animal; } void performActions() { animal.fly(); animal.swim(); } } public class Main { public static void main(String[] args) { // Create a Duck object Duck duck = new Duck(\"Dodo\"); // Create an AnimalAction object for Duck, which extends Animal and implements CanFly and CanSwim AnimalAction\u0026ltDuck\u0026gt; action = new AnimalAction\u0026lt;\u0026gt;(duck); // Perform actions on the Duck action.performActions(); } } Reflection Reflection in Java is a feature that allows inspecting and manipulating the properties or behaviors of classes, methods, fields, and constructors at runtime. It is commonly used to examine class information, access private methods and fields, invoke methods dynamically, and create objects dynamically using the Java Reflection API. The Java Reflection API is provided by the java.lang.reflect package and the java.lang.Class class. Some of the key classes and methods in this API include:\nClass: Represents the class of an object and provides methods like getName(), getDeclaredMethods(), getDeclaredFields(), and others to examine the class\u0026rsquo;s metadata. Method: Represents a method of a class and allows invoking it dynamically using methods like invoke(). Field: Represents a field (variable) in a class and allows accessing or modifying its value dynamically. Constructor: Represents a constructor in a class and allows creating new instances dynamically using methods like newInstance(). SHOW CODE Java package dev.signalyu.warmup; import java.lang.reflect.*; class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } private void sayHello() { System.out.println(\"Hello, \" + name); } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } } public class Main { public static void main(String[] args) throws Exception { // Create a new Person object Person person = new Person(\"John\", 30); // Get the Class object associated with the Person class Class\u003c?\u003e clazz = person.getClass(); // Get class name System.out.println(\"Class name: \" + clazz.getName()); // Get declared methods Method[] methods = clazz.getDeclaredMethods(); for (Method method : methods) { System.out.println(\"Method: \" + method.getName()); } // Get declared fields Field[] fields = clazz.getDeclaredFields(); for (Field field : fields) { System.out.println(\"Field: \" + field.getName()); } // Accessing a private field via reflection Field field = clazz.getDeclaredField(\"name\"); field.setAccessible(true); // Make the private field accessible System.out.printf(\"Private field: 'name'=%s\\n\", field.get(person)); // Get the 'sayHello' method Method method = clazz.getDeclaredMethod(\"sayHello\"); // Make the private method accessible method.setAccessible(true); // Invoke the method on the 'person' object method.invoke(person); // Dynamically load the Person class Class\u003c?\u003e clazz2 = Class.forName(\"dev.signalyu.warmup.Person\"); // Get the constructor that takes a String argument Constructor\u003c?\u003e constructor = clazz2.getConstructor(String.class, int.class); // Create an instance of Person using reflection Person Signal = (Person) constructor.newInstance(\"Signal\", 18); System.out.println(\"Signal = \" + Signal); } } SHOW OUTPUT Output Class name: dev.signalyu.warmup.Person Method: getName Method: toString Method: setName Method: sayHello Method: getAge Field: name Field: age Private field: 'name'=John Hello, John Signal = Person{name='Signal', age=18} Annotations Annotations in Java are a form of metadata used to provide additional information that does not directly affect the execution of the code. They are commonly used to convey instructions to the compiler (such as detecting errors or supressing warnings) or to support runtime processing. Annotations are prefixed with the @ symbol and can be applied to classes, methods, firlds, and other program elements.\nCommon meta annotations, such as @Target adn @Retension, are used to specify how and where an annotation can be applied. The @Target annotation defines the valid program elements for an annotation, including:\nElementType.TYPE: The annotation can be applied to a class or interface. ElementType.METHOD: The annotation can be applied to a method. ElementType.FIELD: The annotation can be applied to a field. The @Retention annotation specifies the lifespan of the annotation. Foe example, using @Retention(RetentionPolicy).RUNTIME indicates that the annotation is available at runtime for reflection.\nTo customize an annotation in Java, the first step is to define its basic structure using the @interface keyword. Elements (parameters) can be included in the annotation, with or without default values, depending on the requirements.\nNext, meta-annotation such as @Target and @Retention are added to specify where the annotation can be applied and how long it will be retained.\nOnce the annotation is defined, it can be applied according to the specified @Target (e.g., on methods, classes, or fields).\nThe final step is to define the logic for processing the annotation, typically achieved through reflection at runtime.\nSHOW CODE: Login Interception Login Interception @Getter public enum ResultCodeEnum { LOGIN_AUTH(208, \"Not logged in\"); private final int code; private final String message; ResultCodeEnum(int code, String message) { this.code = code; this.message = message; } } public class RedisConstant { /** * The prefix for user login keys in Redis. */ public static final String USER_LOGIN_KEY_PREFIX = \"user:login:\"; } public class AuthContextHolder { private static final ThreadLocal\u0026lt;Long\u0026gt; userId = new ThreadLocal\u0026lt;\u0026gt;(); /** * Sets the user ID in the thread-local context. * * @param _userId The user ID to set. */ public static void setUserId(Long _userId) { userId.set(_userId); } /** * Gets the user ID from the thread-local context. * * @return The current user ID. */ public static Long getUserId() { return userId.get(); } /** * Removes the user ID from the thread-local context. */ public static void removeUserId() { userId.remove(); } } @Target({ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Inherited @Documented public @interface AppLogin { /** * Indicates if login is required for the annotated method. * Default is true. */ boolean required() default true; } @Aspect @Component public class AppLoginAspect { @Autowired private RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate; /** * Intercepts methods annotated with @AppLogin to enforce login validation. * * @param joinPoint The proceeding join point for the intercepted method. * @param appLogin The AppLogin annotation instance. * @return The result of the intercepted method execution. * @throws Throwable If an error occurs during method execution. */ @SneakyThrows @Around(\"execution(* com.atApp.tingshu.*.api.*.*(..)) \u0026\u0026 @annotation(appLogin)\") public Object loginAspect(ProceedingJoinPoint joinPoint, AppLogin appLogin) { // Extract the token from the request header String token = getTokenFromRequest(); // Check login status in Redis String loginKey = RedisConstant.USER_LOGIN_KEY_PREFIX + token; UserInfoVo userInfoVo = (UserInfoVo) redisTemplate.opsForValue().get(loginKey); // If login is required and user is not authenticated, throw exception if (appLogin.required() \u0026\u0026 userInfoVo == null) { throw new AppException(ResultCodeEnum.LOGIN_AUTH); } // If user is authenticated, set the user ID in the thread-local context if (userInfoVo != null) { AuthContextHolder.setUserId(userInfoVo.getId()); } try { // Proceed with the method execution return joinPoint.proceed(); } finally { // Ensure that user ID is cleared after the method execution AuthContextHolder.removeUserId(); } } /** * Extracts the token from the HTTP request header. * * @return The token string. */ private String getTokenFromRequest() { RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes(); ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes) requestAttributes; HttpServletRequest request = servletRequestAttributes.getRequest(); return request.getHeader(\"token\"); } } Serialization \u0026amp; Deserialization In Java, Serialization and Deserialzation are processes used to convert objects into a byte stream and restore them back into objects, respectively. These processes are essential for storing objects in files, transmitting them over a network, or preserving their state.\nSerialization involves converting an object into a byte stream. To serialize an object, its class must implement the java.io.Serializable interface, which is a marker interface without any methods. The ObjectOutputStream class is used to write the serialized object to a file or another output stream. A serialVersionUID is automatically generated if not explicitly defined, but it is recommended to provide one manually to ensure compatibility during deserialization. Fields marked as transcient are not serialized. Additionally, any objects regerenced by the serialized object are also serialized, provided they implement the Serializable interface.\nDeserialization is the process of reconstructing a serialized object back into a Java object. For deserialization to succeed, the class must be available in the classpath. This process is performed using the ObjectInputStream class, which reads the byte stream and restores the object to its original state.\nSHOW CODE Java import java.io.*; // Define a Serializable class class Person implements Serializable { private static final long serialVersionUID = 1L; // Ensures class compatibility during deserialization private String name; private int age; // Transient field will not be serialized private transient String password; public Person(String name, int age, String password) { this.name = name; this.age = age; this.password = password; } @Override public String toString() { return \"Person{name='\" + name + \"', age=\" + age + \", password='\" + password + \"'}\"; } } public class Main { public static void main(String[] args) { Person person = new Person(\"Signal Yu\", 18, \"securePassword\"); // Serialize the object try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"person.ser\"))) { oos.writeObject(person); System.out.println(\"Object serialized successfully.\"); } catch (IOException e) { e.printStackTrace(); } // Deserialize the object try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"person.ser\"))) { Person deserializedPerson = (Person) ois.readObject(); System.out.println(\"Deserialized object: \" + deserializedPerson); } catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } } } SHOW OUTPUT Output Object serialized successfully. Deserialized object: Person{name='Signal Yu', age=18, password='null'} Lambda Expression Runnable SHOW CODE Java public class Test { public static void main(String[] args) { // Java 8 之前 Runnable runnable = new Runnable() { @Override public void run() { System.out.println(\"Inside Runnable 1\"); } }; new Thread(runnable).start(); // Java 8 - Lambda 语法 Runnable runnableLambda = () -\u003e {System.out.println(\"Inside Runnable 2\");}; new Thread(runnableLambda).start(); new Thread(() -\u003e System.out.println(\"Inside Runnable 3\")).start(); } } Comparator SHOW CODE Java public class Test { public static void main(String[] args) { // JAVA 8 之前 Comparator\u0026lt;Integer\u0026gt; comparator = new Comparator\u0026lt;Integer\u0026gt;() { @Override public int compare(Integer o1, Integer o2) { /** * o1 \u003c o2 -\u003e -1 * o1 == o2 -\u003e 0 * o1 \u003e o2 -\u003e 1 */ return o1.compareTo(o2); } }; System.out.println(comparator.compare(1, 2)); // -1 /** * JAVA 8 */ // Comparator\u0026lt;Integer\u0026gt; comparatorLambda1 = (Integer a, Integer b) -\u003e a.compareTo(b); Comparator\u0026lt;Integer\u0026gt; comparatorLambda1 = Comparator.naturalOrder(); System.out.println(comparatorLambda1.compare(1, 2)); // -1 // Comparator\u0026lt;Integer\u0026gt; comparatorLambda2 = (a, b) -\u003e b.compareTo(a); Comparator\u0026lt;Integer\u0026gt; comparatorLambda2 = Comparator.reverseOrder(); System.out.println(comparatorLambda2.compare(1, 2)); // 1 int[] nums = new int[]{2, 1, 4, 3}; System.out.println(\"nums = \" + Arrays.toString(nums)); Arrays.sort(nums); // 默认为升序排序 // 倒序排序 Integer[] newNums = Arrays.stream(nums).boxed().toArray(Integer[]::new); Arrays.sort(newNums, Comparator.reverseOrder()); } } Local Variables in Lambda Expression SHOW CODE Java public class Test { public static void main(String[] args) { /** * 1. The variable used in a lambda expression must be effectively final, * meaning its value cannot change after it has been assigned. * 2. A lambda captures the values of local variables, not the variables * themselves. * 3. Local variables in a lambda cannot have the same name as variables * in the enclosing scope to avoid shadowing. */ int num = 10; // effectively final Runnable r = () -\u003e System.out.println(num); r.run(); // Error: Variable num is already defined in the scope // Runnable r = () -\u003e { // int num = 20; // Compile-time error // System.out.println(num); // }; } } Functional Interface Consumer SHOW CODE Java import java.util.Arrays; import java.util.List; import java.util.function.Consumer; public class Test { public static void main(String[] args) { List\u0026lt;String\u0026gt; items = Arrays.asList(\"One\", \"Two\", \"Three\"); /** * Consumer 接收一个参数并执行一些操作，不返回结果 * Consumer 有 accept 和 andThen 两个方法 * accept 用于接收参数，andThen 用于链接多个 Consumer */ // 示例1：定义一个 Consumer，它将打印传入的字符串 Consumer\u0026lt;String\u0026gt; printConsumer = s -\u003e System.out.println(\"打印消息: \" + s); printConsumer.accept(\"Hello, World!\"); // 输出: 打印消息: Hello, World! // 示例 2：Consumer 链式操作 Consumer\u0026lt;String\u0026gt; printItem = item -\u003e System.out.print(\"打印: \" + item + \"\\t\"); Consumer\u0026lt;String\u0026gt; printLength = item -\u003e System.out.println(\"长度: \" + item.length()); Consumer\u0026lt;String\u0026gt; combined = printItem.andThen(printLength); // 将两个 Consumer 组合在一起 // 使用 forEach 遍历集合并执行组合操作 items.forEach(combined); // items.forEach(item -\u003e { // System.out.print(\"打印: \" + item + \"\\t\"); // System.out.println(\"长度: \" + item.length()); // }); } } BiConsumer SHOW CODE Java import java.util.Arrays; import java.util.List; import java.util.function.BiConsumer; // 定义 Student 记录类，包含学生的姓名和活动列表 record Student(String name, List\u0026lt;String\u0026gt; activities) { } //class Student { // private final String name; // private final List\u0026lt;String\u0026gt; activities; // // public Student(String name, List\u0026lt;String\u0026gt; activities) { // this.name = name; // this.activities = activities; // } // // public String getName() { // return name; // } // // public List\u0026lt;String\u0026gt; getActivities() { // return activities; // } //} class StudentDataBase { // 提供学生数据，返回一个包含多个学生的列表 public static List\u0026lt;Student\u0026gt; getAllStudents() { return Arrays.asList( new Student(\"Alice\", Arrays.asList(\"Swimming\", \"Basketball\")), new Student(\"Bob\", Arrays.asList(\"Cycling\", \"Chess\")), new Student(\"Charlie\", Arrays.asList(\"Running\", \"Reading\")) ); } } class Test { public static void main(String[] args) { /** * BiConsumer 适用于对两个参数执行操作，但不需要返回结果的场景。 */ // BiConsumer 接口用于处理学生姓名和活动列表 BiConsumer\u0026lt;\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; studentBiConsumer = (name, activities) -\u003e System.out.println(name + \" : \" + activities); // 获取学生列表 List\u0026lt;Student\u0026gt; students = StudentDataBase.getAllStudents(); // 使用 forEach 遍历每个学生对象并输出其姓名和活动列表 students.forEach(student -\u003e studentBiConsumer.accept(student.name(), student.activities())); } } Predicate SHOW CODE Java import java.util.Arrays; import java.util.List; import java.util.function.Predicate; class Test { public static void main(String[] args) { /* Predicate 用于测试输入对象是否满足某种条件，常用于过滤、条件判断等场景 Predicate 提供了 and, or 和 negate 三个默认方法 Predicate 提供了 isEqual 和 not (Java 11) 两个静态方法 */ // 示例 1: Predicate\u0026lt;Integer\u0026gt; isEven = num -\u003e num % 2 == 0; List\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6); List\u0026lt;Integer\u0026gt; evenNumbers = numbers.stream() .filter(isEven) .toList(); System.out.println(\"偶数: \" + evenNumbers); // 输出: 偶数: [2, 4, 6] // 示例 2: Predicate\u0026lt;Integer\u0026gt; isOdd = num -\u003e num % 2 == 0; Predicate\u0026lt;Integer\u0026gt; isGreaterThanFive = num -\u003e num \u003e 5; // 使用 and() 方法组合两个条件 Predicate\u0026lt;Integer\u0026gt; isOddAndGreaterThanFive = isOdd.and(isGreaterThanFive); System.out.println(isOddAndGreaterThanFive.test(7)); // 输出: true System.out.println(isOddAndGreaterThanFive.test(3)); // 输出: false // 示例 3 List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\", \"Alice\"); // 使用 isEqual 和 not 来筛选出不等于 \"Alice\" 的名字 List\u0026lt;String\u0026gt; filteredNames = names.stream() .filter(Predicate.not(Predicate.isEqual(\"Alice\"))) .toList(); System.out.println(filteredNames); // Output: [Bob, Charlie] } } BiPredicate SHOW CODE Java import java.util.function.BiPredicate; class Test { public static void main(String[] args) { // BiPredicate 适合需要对两个参数进行测试或判断的情况 // 示例 1 BiPredicate\u0026lt;Integer, Integer\u0026gt; isSumGreaterThanTen = (a, b) -\u003e (a + b) \u003e 10; BiPredicate\u0026lt;Integer, Integer\u0026gt; isProductEven = (a, b) -\u003e (a * b) % 2 == 0; BiPredicate\u0026lt;Integer, Integer\u0026gt; combined = isSumGreaterThanTen.and(isProductEven); System.out.println(combined.test(5, 6)); // 输出: true，因为和大于10且乘积为偶数 System.out.println(combined.test(5, 5)); // 输出: false，因为乘积为奇数 } } Function SHOW CODE Java import java.util.function.Function; class Test { public static void main(String[] args) { /** * Function 接受一个参数并返回一个结果 * apply(T t)：对给定的参数执行函数操作并返回结果 * andThen()：在当前函数之后执行另一个函数 * compose()：在当前函数之前执行另一个函数 */ // 示例 1 Function\u0026lt;Integer, Integer\u0026gt; squareFunction = x -\u003e x * x; Integer result = squareFunction.apply(5); System.out.println(\"5 的平方是: \" + result); // 示例 2 Function\u0026lt;Integer, Integer\u0026gt; multiplyBy2 = x -\u003e x * 2; Function\u0026lt;Integer, Integer\u0026gt; add3 = x -\u003e x + 3; // 使用 andThen：先乘以 2，再加 3 Integer result1 = multiplyBy2.andThen(add3).apply(5); System.out.println(\"(5 * 2) + 3 的结果是: \" + result1); // 使用 compose：先加 3，再乘以 2 Integer result2 = multiplyBy2.compose(add3).apply(5); System.out.println(\"(5 + 3) * 2 的结果是: \" + result2); } } BiFunction SHOW CODE Java import java.util.function.BiFunction; class Test { public static void main(String[] args) { // BiFunction takes two arguments and returns a result BiFunction\u0026lt;Integer, Integer, Integer\u0026gt; sum = (a, b) -\u003e a + b; int result = sum.apply(5, 3); // Returns 8 System.out.println(\"Result: \" + result); } } Method Reference SHOW CODE Java import java.util.Arrays; import java.util.List; import java.util.function.Function; import java.util.function.Supplier; public class Test { public static void main(String[] args) { /** * Method reference is a shortcut for writing the lambda function */ // 示例 1 List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"); // 使用 Lambda 表达式 names.stream().map(name -\u003e name.toUpperCase()).forEach(name -\u003e System.out.println(name)); // 使用Method Reference names.stream().map(String::toUpperCase).forEach(System.out::println); /** * 构造器引用是Method Reference的特例 * 用法如下： * () -\u003e new Person() \u003c--\u003e Person::new; * (name) -\u003e new Person() \u003c--\u003e Person::new; */ // 示例 2 // Using () -\u003e new Person() Supplier\u0026lt;Person\u0026gt; personSupplier = () -\u003e new Person(); Person p1 = personSupplier.get(); System.out.println(p1); // Output: Person{name='Default'} // Using Person::new Supplier\u0026lt;Person\u0026gt; personSupplierRef = Person::new; Person p2 = personSupplierRef.get(); System.out.println(p2); // Output: Person{name='Default'} // 示例 3 // Using (name) -\u003e new Person(name) Function\u0026lt;String, Person\u0026gt; personFunction = (name) -\u003e new Person(name); Person p3 = personFunction.apply(\"Alice\"); System.out.println(p3); // Output: Person{name='Alice'} // Using Person::new Function\u0026lt;String, Person\u0026gt; personFunctionRef = Person::new; Person p4 = personFunctionRef.apply(\"Bob\"); System.out.println(p4); // Output: Person{name='Bob'} } } class Person { private String name; // Default constructor public Person() { this.name = \"Default\"; } // Constructor with a parameter public Person(String name) { this.name = name; } @Override public String toString() { return \"Person{name='\" + name + \"'}\"; } } Stream API Introduction to Stream API A Stream is a sequence of elements designed for processing in a functional and sequential manner. Stream operations are lazy, meaning they are not executed until a terminal operation (e.g., collect, forEach, reduce, count) is invoked. Streams are immutable, allowing access to elements without modifying the source. Java provides two types of streams: stream (for sequential processing) and parallel stream (for concurrent processing).\nCollections V.S. Stream\nIn Java, Collections are data structures designed for storing and manipulating data, whereas Streams are a sequence of elements which enable functional-style operations on data. Collections allow data modification, whereas Streams provide read-only access to elements. Operations on Collections are executed eagerly, while Streams operations are lazy and only executed when a terminal operation is invoked. Collections can be reused multiple times, but Streams are single-use and cannot be reused after processing. Debugging Streams: the peek() method can be used to inspect the intermediate results during stream operations.\nArrays.asList(\u0026#34;hello\u0026#34;, \u0026#34;hi\u0026#34;).stream() .peek(System.out::println) .filter(s -\u0026gt; s.length() \u0026gt; 2) .peek(s -\u0026gt; System.out.println(\u0026#34;Filtered: \u0026#34; + s)) .map(String::toUpperCase) .peek(s -\u0026gt; System.out.println(\u0026#34;Mapped: \u0026#34; + s)) .collect(Collectors.toList()); hello Filtered: hello Mapped: HELLO hi flatMap The flatMap method is used to transform each element in a stream into another stream and then flatten the resulting streams into a single stream.\nSHOW CODE Java import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class Test { public static void main(String[] args) { List\u0026lt;List\u0026lt;String\u0026gt; nestedList = Arrays.asList( Arrays.asList(\"A\", \"B\"), Arrays.asList(\"C\", \"D\"), Arrays.asList(\"E\", \"F\") ); List\u0026lt;String\u0026gt; flattenedList = nestedList.stream() .flatMap(List::stream) // Flatten the nested lists .map(String::toLowerCase) // Convert each string to lowercase .collect(Collectors.toList()); System.out.println(flattenedList); // Output: [a, b, c, d, e, f] } } The map method transforms each element into another type, while the flatMap method transforms and flaten streams into a single stream.\ndistinct(), count(), sorted() The distinct() method eliminates duplicate elements from the stream. The count() method calculates the total number of elements in the stream. The sorted() method sorts the elements of the stream.\nSHOW CODE Java List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Alice\", \"Charlie\"); long count = names.stream() .distinct() // Optional: Count unique elements .count(); System.out.println(count); // Output: 3 List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"); List\u0026lt;String\u0026gt; sortedByLength = names.stream() .sorted(Comparator.comparingInt(String::length)) .collect(Collectors.toList()); System.out.println(sortedByLength); // Output: [Bob, Alice, Charlie] reduce() The reduce() method in Java 8 Streams is a terminal operation used to combine elements in a stream into a single result by repeatedly applying a binary operator.\nSHOW CODE Java // Summing numbers List\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5); int sum = numbers.stream().reduce(0, Integer::sum); System.out.println(sum); // Output: 15 // Finding maximum values List\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5); int max = numbers.stream().reduce(Integer.MIN_VALUE, Integer::max); System.out.println(max); // Output: 5 // Concatenating Strings List\u0026lt;String\u0026gt; words = Arrays.asList(\"Java\", \"Stream\", \"Reduce\"); String concatenated = words.stream().reduce(\"\", String::concat); System.out.println(concatenated); // Output: JavaStreamReduce // Product of numbers List\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4); int product = numbers.stream().reduce(1, (a, b) -\u003e a * b); System.out.println(product); // Output: 24 limit(), skip() The limit() method retrieves a specified number of elements from a stream. The skip() method discards the first specified number of elements in a stream.\nSHOW CODE Java List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\", \"David\", \"Eve\"); List\u0026lt;String\u0026gt; paginatedNames = names.stream() .skip(2) // Skip the first 2 elements .limit(2) // Take the next 2 elements .collect(Collectors.toList()); System.out.println(paginatedNames); // Output: [Charlie, David] allMatch(), anyMatch(), noneMatch() The allMatch() method verifies if all elements in a stream satisfy the given predicate. The anyMatch() method determines if any element in the stream matches the specified predicate. The noneMatch() method confirms if no element in the stream matches the specified predicate.\nSHOW CODE Java List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"); // Check if all names are longer than 3 characters boolean allLongNames = names.stream().allMatch(name -\u003e name.length() \u003e 3); System.out.println(allLongNames); // Output: true // Check if any name starts with 'A' boolean anyStartsWithA = names.stream().anyMatch(name -\u003e name.startsWith(\"A\")); System.out.println(anyStartsWithA); // Output: true // Check if no name is shorter than 3 characters boolean noneShortNames = names.stream().noneMatch(name -\u003e name.length() \u003c 3); System.out.println(noneShortNames); // Output: true findAny(), findFirst() The findAny() method retrieves an arbitrary element from a stream, particularly useful for parallel processing. The findFirst() method fetches the first element from a stream based on its encounter order.\nSHOW CODE Java List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"); Optional\u0026lt;String\u0026gt; anyName = names.stream().findAny(); System.out.println(anyName.orElse(\"No names found\")); // Output: Alice (or any other element) List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"); Optional\u0026lt;String\u0026gt; firstName = names.stream().findFirst(); System.out.println(firstName.orElse(\"No names found\")); // Output: Alice Factory Methods: Of(), generate(), iterate() Stream.of() is used to create a stream from a fixed set of elements.\nSHOW CODE Java import java.util.stream.Stream; public class Main { public static void main(String[] args) { Stream\u0026lt;String\u0026gt; stream = Stream.of(\"Apple\", \"Banana\", \"Cherry\"); stream.forEach(System.out::println); } } Stream.generate() method is used to create an infinite stream of elements generated by a Supplier.\nSHOW CODE Java import java.util.stream.Stream; public class Main { public static void main(String[] args) { Stream\u0026lt;String\u0026gt; infiniteStream = Stream.generate(() -\u003e \"Hello\"); infiniteStream.limit(5).forEach(System.out::println); } } Stream.iterate() is used to create an infinite stream by applying a function repeatedly to a seed value.\nSHOW CODE Java import java.util.Random; Stream\u0026lt;Integer\u0026gt; randomNumbers = Stream.generate(() -\u003e new Random().nextInt(100)); randomNumbers.limit(5).forEach(System.out::println); When working with infinite streams, such as those created by Stream.generate() or Stream.iterate(), always use operations like limit() to prevent infinite processing.\nTerminal Operations: joining(), counting(), mapping() The joining method is a terminal operation used to concatenate the elements of a stream into a single String. By default, the elements are joined without a delimiter, but a custom delimiter, prefix, and suffix can also be specified.\nSHOW CODE Java import java.util.*; import java.util.stream.Collectors; public class JoiningExample { public static void main(String[] args) { List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"); // Simple joining String result1 = names.stream().collect(Collectors.joining()); System.out.println(result1); // AliceBobCharlie // Joining with a delimiter String result2 = names.stream().collect(Collectors.joining(\", \")); System.out.println(result2); // Alice, Bob, Charlie // Joining with delimiter, prefix, and suffix String result3 = names.stream().collect(Collectors.joining(\", \", \"[\", \"]\")); System.out.println(result3); // [Alice, Bob, Charlie] } } The counting() method is a terminal operation used to count the number of elements in a stream and return the count as a long.\nSHOW CODE Java import java.util.*; import java.util.stream.Collectors; public class CountingExample { public static void main(String[] args) { List\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5); // Counting the elements in the stream long count = numbers.stream().collect(Collectors.counting()); System.out.println(count); // 5 } } The mapping() method is an intermediate collector that applies a function to the elements of a stream before passing the transformed elements to another collector for final processing.\nSHOW CODE Java import java.util.*; import java.util.stream.Collectors; public class MappingExample { public static void main(String[] args) { List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"); // Convert names to uppercase and join them String result = names.stream() .collect(Collectors.mapping(String::toUpperCase, Collectors.joining(\", \"))); System.out.println(result); // ALICE, BOB, CHARLIE } } Terminal Operations: minBy(), maxBy(), groupingBy() The minBy() collector finds the minimum element in a stream based on a specified Comparator and returns the result as an Optional.\nSHOW CODE Java Optional min = Stream.of(3, 5, 1, 2) .collect(Collectors.minBy(Comparator.naturalOrder())); System.out.println(min.orElse(-1)); // Output: 1 The maxBy() collector finds the maximum element in a stream based on a specified Comparator and returns the result as an Optional.\nSHOW CODE Java Optional max = Stream.of(3, 5, 1, 2) .collect(Collectors.maxBy(Comparator.naturalOrder())); System.out.println(max.orElse(-1)); // Output: 5 The groupingBy() collector groups the elements of a stream based on a classification function and returns the grouped data as a Map.\nSHOW CODE Java Map\u0026lt;Integer, List\u0026lt;String\u0026gt;\u0026gt; groupedByLength = Stream.of(\"cat\", \"dog\", \"bird\", \"fox\") .collect(Collectors.groupingBy(String::length)); System.out.println(groupedByLength); // Output: {3=[cat, dog, fox], 4=[bird]} Numeric Stream A Numeric Stream in Java is a specialized type of stream that operates specifically on numeric values. There are three types of numeric streams: IntStream, LongStream, and Double Stream, which handle int, long, and double values, respectively. Numeric streams eliminate the overhead of autoboxing and provide commonly used methods such as sum() and max() for performing operations on numeric data, making them more efficient compared to regular Stream types.\nSHOW CODE Java IntStream.range(1, 5).forEach(System.out::println); // Output: 1 2 3 4 IntStream.rangeClosed(1, 5).forEach(System.out::println); // Output: 1 2 3 4 5 long count = IntStream.range(1, 10).count(); System.out.println(count); // Output: 9 int sum = IntStream.range(1, 5).sum(); System.out.println(sum); // Output: 10 (1 + 2 + 3 + 4) OptionalInt max = IntStream.range(1, 5).max(); max.ifPresent(System.out::println); // Output: 4 OptionalInt min = IntStream.range(1, 5).min(); min.ifPresent(System.out::println); // Output: 1 OptionalDouble average = IntStream.range(1, 5).average(); average.ifPresent(System.out::println); // Output: 2.5 List\u0026lt;String\u0026gt; numbers = Arrays.asList(\"1\", \"2\", \"3\", \"4\"); IntStream intStream = numbers.stream().mapToInt(Integer::parseInt); intStream.forEach(System.out::println); // Output: 1, 2, 3, 4 List\u0026lt;String\u0026gt; numbers = Arrays.asList(\"1.1\", \"2.2\", \"3.3\", \"4.4\"); DoubleStream doubleStream = numbers.stream().mapToDouble(Double::parseDouble); doubleStream.forEach(System.out::println); // Output: 1.1, 2.2, 3.3, 4.4 List\u0026lt;String\u0026gt; numbers = Arrays.asList(\"10\", \"20\", \"30\", \"40\"); LongStream longStream = numbers.stream().mapToLong(Long::parseLong); longStream.forEach(System.out::println); // Output: 10, 20, 30, 40 IntStream intStream = IntStream.range(1, 5); Stream\u0026lt;String\u0026gt; stringStream = intStream.mapToObj(Integer::toString); stringStream.forEach(System.out::println); // Output: \"1\", \"2\", \"3\", \"4\" ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/programming/java/1-java-programming/","summary":"Enum In Java, an enum (short for \u0026ldquo;enumeration\u0026rdquo;) is used to define a collection of constants, such as days of the week or months of the year. An enum provides a type-safe way to handle constant values, and it can be used in a switch statement or for comparison using ==. Compared to a final constant in Java, an enum can contain fields, methods, and constructors. The values() method is used to retrive all the constants in an enum, and the valueOf() method is used to convert a string into an enum constant.","title":"Java Programming"}]