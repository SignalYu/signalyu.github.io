[{"content":"1. Solid Principle 1.1 Single Responsibility Principle A class should have only one reason to change, meaning each class should focus on a single functionality or responsibility.\nSHOW CODE Single Responsibility Principle import java.io.IOException; import java.util.*; import java.util.regex.*; import com.fasterxml.jackson.databind.ObjectMapper; /** * 1. User class is only used to represent entity. * 2. UserValidator class is solely responsible for validating user objects. * 3. Store class is only used to manage user objects storage. * 4. UserPersistenceService class is dedicated to save the user data. * 5. UserController is solely used to handle incoming requests (in this case, creating users form JSON input). */ /* \u0026lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.18.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; */ /** * Represents a user with basic details. * User class is only used to represent entity. */ class User { private String name; private String email; private String address; public User() {} public User(String name, String email, String address) { this.name = name; this.email = email; this.address = address; } // Getters and setters public String getName() { return name; } public void setName(String name) { this.name = name; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } @Override public String toString() { return \"User [name=\" + name + \", email=\" + email + \", address=\" + address + \"]\"; } } /** * Handles incoming JSON requests that work on User. * UserController is solely used to handle incoming requests (in this case, creating users form JSON input). */ class UserController { private final UserPersistenceService persistenceService = new UserPersistenceService(); public String createUser(String userJson) throws IOException { ObjectMapper mapper = new ObjectMapper(); User user = mapper.readValue(userJson, User.class); UserValidator validator = new UserValidator(); if (!validator.validateUser(user)) { return \"ERROR\"; } persistenceService.saveUser(user); return \"SUCCESS\"; } } /** * Handles persistence of User objects. * UserPersistenceService class is dedicated to save the user data. */ class UserPersistenceService { private final Store store = new Store(); public void saveUser(User user) { store.store(user); } } /** * Validates User data. * UserValidator class is solely responsible for validating user objects. */ class UserValidator { public boolean validateUser(User user) { if (!isPresent(user.getName()) || !isValidAlphaNumeric(user.getName())) { return false; } user.setName(user.getName().trim()); user.setEmail(user.getEmail().trim()); return isValidEmail(user.getEmail()); } private boolean isPresent(String value) { return value != null \u0026\u0026 value.trim().length() \u003e 0; } private boolean isValidAlphaNumeric(String value) { Pattern pattern = Pattern.compile(\"[^A-Za-z0-9]\"); Matcher matcher = pattern.matcher(value); return !matcher.find(); } private boolean isValidEmail(String value) { Pattern pattern = Pattern.compile(\"^[\\\\w-\\\\.]+@[\\\\w-]+(\\\\.[\\\\w-]+)+$\"); Matcher matcher = pattern.matcher(value); return matcher.find(); } } /** * Stores User data in memory. * Store class is only used to manage user objects storage. */ class Store { private static final Map\u0026lt;String, User\u0026gt; STORAGE = new HashMap\u0026lt;\u0026gt;(); public void store(User user) { synchronized (STORAGE) { STORAGE.put(user.getName(), user); } } public User getUser(String name) { synchronized (STORAGE) { return STORAGE.get(name); } } } /** * Main class for demonstrating the Single Responsibility Principle. */ public class Main { private static final String VALID_USER_JSON = \"{\\\"name\\\": \\\"Signal\\\", \\\"email\\\": \\\"signalyu999@gmail.com\\\", \\\"address\\\":\\\"999 Sugar lane\\\"}\"; private static final String INVALID_USER_JSON = \"{\\\"name\\\": \\\"Sam\\\", \\\"email\\\": \\\"sam@email\\\", \\\"address\\\":\\\"111 Sugar lane\\\"}\"; public static void main(String[] args) throws IOException { UserController controller = new UserController(); String response = controller.createUser(VALID_USER_JSON); System.out.println(\"Valid JSON response: \" + response); response = controller.createUser(INVALID_USER_JSON); System.out.println(\"Invalid JSON response: \" + response); } } Each class in the above code strictly adheres to the Single Responsibility Principle by focusing on a specific responsibility:\nUser for representing the user entity UserController for request handling UserPersistenceService for data persistence UserValidator for user data validation Store for managing in-memory data storage --- title: Single Responsibility Principle - Class Diagram --- classDiagram class User { - String name - String email - String address + String toString() } class Store { + void store(User user) + User getUser(String name) } class UserPersistenceService { + void saveUser(User user) } class UserValidator { - boolean isPresent(String value) - boolean isValidAlphaNumeric(String value) - boolean isValidEmail(String value) + boolean validateUser(User user) } class UserController { + String createUser(String userJson) } class Main { + void main(String[] args) } User --* Store Store --* UserPersistenceService UserPersistenceService --* UserController UserController --\u003e UserValidator : create Main --\u003e UserController : create 1.2 Open-Closed Principle A software entity (class, module, function, etc.) should be open for extension but closed for modification.\n点击查看代码 Java import java.time.LocalDateTime; import java.util.*; // Abstract base class, closed for modification but open for extension abstract class Subscriber { protected Long subscriberId; protected String address; protected Long phoneNumber; protected int baseRate; // Getter and Setter methods public Long getSubscriberId() { return subscriberId; } public void setSubscriberId(Long subscriberId) { this.subscriberId = subscriberId; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } public Long getPhoneNumber() { return phoneNumber; } public void setPhoneNumber(Long phoneNumber) { this.phoneNumber = phoneNumber; } public int getBaseRate() { return baseRate; } public void setBaseRate(int baseRate) { this.baseRate = baseRate; } // Abstract method to calculate the bill; implementation is defined in subclasses public abstract double calculateBill(); } // PhoneSubscriber class extends Subscriber, calculates the phone bill class PhoneSubscriber extends Subscriber { @Override public double calculateBill() { List\u0026lt;CallHistory.Call\u0026gt; calls = CallHistory.getCurrentCalls(subscriberId); long totalDuration = calls.stream().mapToLong(CallHistory.Call::getDuration).sum(); return (totalDuration * baseRate) / 100.0; } } // ISPSubscriber class extends Subscriber, calculates the internet bill class ISPSubscriber extends Subscriber { private long freeUsage; // Free usage limit in data units @Override public double calculateBill() { List\u0026lt;InternetSessionHistory.InternetSession\u0026gt; sessions = InternetSessionHistory.getCurrentSessions(subscriberId); long totalData = sessions.stream().mapToLong(InternetSessionHistory.InternetSession::getDataUsed).sum(); long chargeableData = totalData - freeUsage; return chargeableData \u003c= 0 ? 0 : (chargeableData * baseRate) / 100.0; } public long getFreeUsage() { return freeUsage; } public void setFreeUsage(long freeUsage) { this.freeUsage = freeUsage; } } // InternetSessionHistory class to manage internet usage records class InternetSessionHistory { public static class InternetSession { private final LocalDateTime begin; private final Long subscriberId; private final Long dataUsed; public InternetSession(Long subscriberId, LocalDateTime begin, long dataUsed) { this.subscriberId = subscriberId; this.begin = begin; this.dataUsed = dataUsed; } public LocalDateTime getBegin() { return begin; } public long getDataUsed() { return dataUsed; } public Long getSubscriberId() { return subscriberId; } } private static final Map\u0026lt;Long, List\u0026lt;InternetSession\u0026gt;\u0026gt; SESSIONS = new HashMap\u0026lt;\u0026gt;(); // Retrieves the current sessions for a subscriber, returns an empty list if none found public static synchronized List\u0026lt;InternetSession\u0026gt; getCurrentSessions(Long subscriberId) { return SESSIONS.getOrDefault(subscriberId, Collections.emptyList()); } // Adds a new internet session record for a subscriber public static synchronized void addSession(Long subscriberId, LocalDateTime begin, long dataUsed) { SESSIONS.computeIfAbsent(subscriberId, k -\u003e new LinkedList\u0026lt;\u0026gt;()).add(new InternetSession(subscriberId, begin, dataUsed)); } } // CallHistory class to manage call records class CallHistory { public static class Call { private final LocalDateTime begin; private final long duration; private final Long subscriberId; public Call(Long subscriberId, LocalDateTime begin, long duration) { this.subscriberId = subscriberId; this.begin = begin; this.duration = duration; } public LocalDateTime getBegin() { return begin; } public long getDuration() { return duration; } public Long getSubscriberId() { return subscriberId; } } private static final Map\u0026lt;Long, List\u0026lt;Call\u0026gt; CALLS = new HashMap\u0026lt;\u0026gt;(); // Retrieves the current calls for a subscriber, returns an empty list if none found public static synchronized List\u0026lt;Call\u0026gt; getCurrentCalls(Long subscriberId) { return CALLS.getOrDefault(subscriberId, Collections.emptyList()); } // Adds a new call record for a subscriber public static synchronized void addSession(Long subscriberId, LocalDateTime begin, long duration) { CALLS.computeIfAbsent(subscriberId, k -\u003e new LinkedList\u0026lt;\u0026gt;()).add(new Call(subscriberId, begin, duration)); } } public class Main { public static void main(String[] args) { // Initialize PhoneSubscriber and ISPSubscriber with sample data PhoneSubscriber phoneSubscriber = new PhoneSubscriber(); phoneSubscriber.setSubscriberId(1L); phoneSubscriber.setBaseRate(10); ISPSubscriber ispSubscriber = new ISPSubscriber(); ispSubscriber.setSubscriberId(2L); ispSubscriber.setBaseRate(5); ispSubscriber.setFreeUsage(1000); // Add call records for PhoneSubscriber CallHistory.addSession(1L, LocalDateTime.now().minusMinutes(5), 300); // 300 seconds call CallHistory.addSession(1L, LocalDateTime.now().minusMinutes(10), 600); // 600 seconds call // Calculate and print the phone subscriber's bill double phoneBill = phoneSubscriber.calculateBill(); System.out.println(\"Phone Subscriber's Bill: \" + phoneBill); // Add internet session records for ISPSubscriber InternetSessionHistory.addSession(2L, LocalDateTime.now().minusHours(1), 500); // 500 data units InternetSessionHistory.addSession(2L, LocalDateTime.now().minusHours(2), 800); // 800 data units // Calculate and print the ISP subscriber's bill double ispBill = ispSubscriber.calculateBill(); System.out.println(\"ISP Subscriber's Bill: \" + ispBill); } } The above code demonstrates the Open/Closed Principle (OCP) by separating the base Subscriber class from its specific implementations, PhoneSubscriber and ISPSubscriber, allowing for new functionalities to be added without modifying the existing code structure.\nClosed for Modification: The Subscriber base class is closed for modification. It defines common properties (like subscriberId, address, and baseRate) and an abstract calculateBill method that acts as a placeholder for billing logic. This base class remains unchanged even as new types of subscribers or billing strategies are introduced.\nOpen for Extension: The calculateBill method in Subscriber can be extended by subclasses, like PhoneSubscriber and ISPSubscriber, to implement custom billing calculations. Each subclass overrides calculateBill according to its unique billing requirements (e.g., PhoneSubscriber calculates based on call duration, while ISPSubscriber uses data usage with free data allowances). This enables additional subscriber types to be created without altering the base class or existing subclasses.\nFlexible to New Requirements: By following OCP, any new type of subscriber can be added—such as PremiumSubscriber or CorporateSubscriber—with its own billing logic without affecting the existing structure. This ensures that the core system remains stable, extensible, and easily maintainable as new features or subscriber types are introduced.\n--- title: Open Closed Principle - Class Diagram --- classDiagram class Subscriber { +Long subscriberId +String address +Long phoneNumber +int baseRate +double calculateBill() } class PhoneSubscriber { +double calculateBill() } class ISPSubscriber { +double calculateBill() +long freeUsage +void setFreeUsage(long freeUsage) +long getFreeUsage() } Subscriber \u003c|-- PhoneSubscriber Subscriber \u003c|-- ISPSubscriber 1.3 Liskov Substitution Principle Objects of a superclass should be replaceable with objects of a subclass without altering the correctness of the program.\nSHOW CODE: Violation of LSP Violation of LSP package dev.signalyu.solid.lsp; class Rectangle { private int width; private int height; public Rectangle(int width, int height) { this.width = width; this.height = height; } public int getWidth() { return width; } public void setWidth(int width) { this.width = width; } public int getHeight() { return height; } public void setHeight(int height) { this.height = height; } public int computeArea() { return width * height; } } class Square extends Rectangle { public Square(int side) { super(side, side); } @Override public void setWidth(int width) { setSide(width); } @Override public void setHeight(int height) { setSide(height); } public void setSide(int side) { super.setWidth(side); super.setHeight(side); } } public class Main { public static void main(String[] args) { Rectangle rectangle = new Rectangle(10, 20); System.out.println(rectangle.computeArea()); // 200 = 10 * 20 Square square = new Square(10); System.out.println(square.computeArea()); // 100 = 10 * 10 useRectangle(rectangle); System.out.println(rectangle.computeArea()); // 600 = 20 * 30 useRectangle(square); // Violates Liskov Substitution Principle System.out.println(square.computeArea()); // 900 = 30 * 30 } private static void useRectangle(Rectangle rectangle) { rectangle.setHeight(20); rectangle.setWidth(30); assert rectangle.getHeight() == 20 : \"Height Not equal to 20\"; assert rectangle.getWidth() == 30 : \"Width Not equal to 30\"; } } In the above code, the useRectangle method assumes that it can independently set the width and height of a Rectangle. However, when a Square (a subclass of Rectangle) object is passed to it, unexpected behavior will occur.\nSHOW CODE: After Refactoring After Refactoring package dev.signalyu.solid.lsp; interface Shape { int computeArea(); } class Rectangle implements Shape { private int width; private int height; public Rectangle(int width, int height) { this.width = width; this.height = height; } public int getWidth() { return width; } public void setWidth(int width) { this.width = width; } public int getHeight() { return height; } public void setHeight(int height) { this.height = height; } @Override public int computeArea() { return width * height; } } class Square implements Shape { private int side; public Square(int side) { this.side = side; } public void setSide(int side) { this.side = side; } public int getSide() { return side; } @Override public int computeArea() { return side * side; } } public class Main { public static void main(String[] args) { Rectangle rectangle = new Rectangle(10, 20); System.out.println(rectangle.computeArea()); Square square = new Square(10); System.out.println(square.computeArea()); useRectangle(rectangle); } private static void useRectangle(Rectangle rectangle) { rectangle.setHeight(20); rectangle.setWidth(30); assert rectangle.getHeight() == 20 : \"Height Not equal to 20\"; assert rectangle.getWidth() == 30 : \"Width Not equal to 30\"; } } After refactoring, the useRectangle method is now dedicated exclusively to the Rectangle class.\n1.4 Interface Segregation Principle No client should be forced to depend on methods it does not use.\nSHOW CODE: Violation of ISP Violation of ISP package dev.signalyu.solid.isp; import java.time.LocalDateTime; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.stream.Collectors; // Abstract Entity Class abstract class Entity { private Long id; public Long getId() { return id; } public void setId(Long id) { this.id = id; } } // Order Entity class Order extends Entity { private LocalDateTime orderPlacedOn; private double totalValue; public LocalDateTime getOrderPlacedOn() { return orderPlacedOn; } public void setOrderPlacedOn(LocalDateTime orderPlacedOn) { this.orderPlacedOn = orderPlacedOn; } public double getTotalValue() { return totalValue; } public void setTotalValue(double totalValue) { this.totalValue = totalValue; } } // User Entity class User extends Entity { private String name; private LocalDateTime lastLogin; public String getName() { return name; } public void setName(String name) { this.name = name; } public LocalDateTime getLastLogin() { return lastLogin; } public void setLastLogin(LocalDateTime lastLogin) { this.lastLogin = lastLogin; } } // Persistence Service Interface interface PersistenceService\u0026lt;T extends Entity\u0026gt; { void save(T entity); void delete(T entity); T findById(Long id); /** * ISP VIOLATION!!! * * Order entity doesn't have a name property and hence doesn't * need to implement the findByName method */ List\u0026lt;T\u0026gt; findByName(String name); } // User Persistence Service class UserPersistenceService implements PersistenceService\u0026lt;User\u0026gt; { private static final Map\u0026lt;Long, User\u0026gt; USERS = new HashMap\u0026lt;\u0026gt;(); @Override public void save(User entity) { synchronized (USERS) { USERS.put(entity.getId(), entity); } } @Override public void delete(User entity) { synchronized (USERS) { USERS.remove(entity.getId()); } } @Override public User findById(Long id) { synchronized (USERS) { return USERS.get(id); } } @Override public List findByName(String name) { synchronized (USERS) { return USERS.values().stream() .filter(u -\u003e u.getName().equalsIgnoreCase(name)) .collect(Collectors.toList()); } } } The above code violates the Interface Segregation Principle because the PersistenceService interface defines methods that are not applicable to all entities. For instance, the Order entity does not have a name property and therefore does not require the findByName method.\nSHOW CODE: After Refactoring After Refactoring import java.time.LocalDateTime; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.stream.Collectors; // Abstract Entity Class abstract class Entity { private Long id; public Long getId() { return id; } public void setId(Long id) { this.id = id; } } // User Entity class User extends Entity { private String name; private LocalDateTime lastLogin; public String getName() { return name; } public void setName(String name) { this.name = name; } public LocalDateTime getLastLogin() { return lastLogin; } public void setLastLogin(LocalDateTime lastLogin) { this.lastLogin = lastLogin; } } // Order Entity class Order extends Entity { private LocalDateTime orderPlacedOn; private double totalValue; public LocalDateTime getOrderPlacedOn() { return orderPlacedOn; } public void setOrderPlacedOn(LocalDateTime orderPlacedOn) { this.orderPlacedOn = orderPlacedOn; } public double getTotalValue() { return totalValue; } public void setTotalValue(double totalValue) { this.totalValue = totalValue; } } // Persistence Service Interface interface PersistenceService\u0026lt;T extends Entity\u0026gt; { void save(T entity); void delete(T entity); T findById(Long id); } // Order Persistence Service class OrderPersistenceService implements PersistenceService\u0026lt;Order\u0026gt; { private static final Map\u0026lt;Long, Order\u0026gt; ORDERS = new HashMap\u0026lt;\u0026gt;(); @Override public void save(Order entity) { synchronized (ORDERS) { ORDERS.put(entity.getId(), entity); } } @Override public void delete(Order entity) { synchronized (ORDERS) { ORDERS.remove(entity.getId()); } } @Override public Order findById(Long id) { synchronized (ORDERS) { return ORDERS.get(id); } } } // User Persistence Service class UserPersistenceService implements PersistenceService\u0026lt;User\u0026gt; { private static final Map\u0026lt;Long, User\u0026gt; USERS = new HashMap\u0026lt;\u0026gt;(); @Override public void save(User entity) { synchronized (USERS) { USERS.put(entity.getId(), entity); } } @Override public void delete(User entity) { synchronized (USERS) { USERS.remove(entity.getId()); } } @Override public User findById(Long id) { synchronized (USERS) { return USERS.get(id); } } public List findByName(String name) { synchronized (USERS) { return USERS.values().stream() .filter(u -\u003e u.getName().equalsIgnoreCase(name)) .collect(Collectors.toList()); } } } After refactoring, the PersistenceService interface includes only the generic methods (save, findById, and delete) that are applicable to all entities.\n1.5 Dependency Inversion Principle High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions\nSHOW CODE: Violation of DIP Violation of DIP package dev.signalyu.solid.dip; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.ObjectMapper; import java.io.FileWriter; import java.io.IOException; import java.io.PrintWriter; import java.time.LocalDateTime; import java.time.ZoneId; // Common interface for classes formatting Message object interface Formatter { String format(Message message) throws FormatException; } // Thrown by formatter class FormatException extends IOException { public FormatException(Exception cause) { super(cause); } } // Formats message to JSON format class JSONFormatter implements Formatter { public String format(Message message) throws FormatException { ObjectMapper mapper = new ObjectMapper(); try { return mapper.writeValueAsString(message); } catch (JsonProcessingException e) { e.printStackTrace(); throw new FormatException(e); } } } // Message class with content and timestamp class Message { private String msg; private LocalDateTime timestamp; public Message(String msg) { this.msg = msg; this.timestamp = LocalDateTime.now(ZoneId.of(\"UTC\")); } public String getMsg() { return msg; } public LocalDateTime getTimestamp() { return timestamp; } } // Writes message to a file class MessagePrinter { /** * MessagePrinter directly instantiates the JSONFormatter object inside the * writeMessage method, which violates the Dependency Inversion Principle. */ public void writeMessage(Message msg, String fileName) throws IOException { Formatter formatter = new JSONFormatter(); // creates formatter try (PrintWriter writer = new PrintWriter(new FileWriter(fileName))) { // creates print writer writer.println(formatter.format(msg)); // formats and writes message writer.flush(); } } } // Main class public class Main { public static void main(String[] args) throws IOException { Message msg = new Message(\"This is a message again\"); MessagePrinter printer = new MessagePrinter(); printer.writeMessage(msg, \"test_msg.txt\"); } } In the above code, the MessagePrinter class directly instanitiates the JSONFormatter object inside the writeMessage method, which violates the Dependency Inversion Principle. This tight coupling means that if a new formatter, such as TextFormatter, needs to be added, the writeMessage method must be modified. This violates the Open-Closed Principle, which states that classes should be open for extension but closed for modification. According to the Dependency Inversion Principle, the high-level module (MessagePrinter) should not depend on the low-level module (JSONFormatter). Instead, both should depend on abstractions, such as the Formatter interface.\nSHOW CODE: After Refactoring After Refactoring import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule; import java.io.IOException; import java.io.PrintWriter; import java.time.LocalDateTime; import java.time.ZoneId; // Common interface for classes formatting Message objects interface Formatter { String format(Message message) throws FormatException; } // Custom exception thrown by Formatter class FormatException extends IOException { public FormatException(Exception cause) { super(cause); } } // Formats a Message object to JSON format class JSONFormatter implements Formatter { public String format(Message message) throws FormatException { ObjectMapper mapper = new ObjectMapper(); mapper.registerModule(new JavaTimeModule()); try { return mapper.writeValueAsString(message); } catch (JsonProcessingException e) { e.printStackTrace(); throw new FormatException(e); } } } // Represents a message with content and a timestamp class Message { private String msg; private LocalDateTime timestamp; public Message(String msg) { this.msg = msg; this.timestamp = LocalDateTime.now(ZoneId.of(\"UTC\")); } public String getMsg() { return msg; } public LocalDateTime getTimestamp() { return timestamp; } } // Responsible for writing a formatted Message to a file or output stream class MessagePrinter { public void writeMessage(Message msg, Formatter formatter, PrintWriter writer) throws IOException { writer.println(formatter.format(msg)); // Formats and writes the message writer.flush(); } } // Main class demonstrating functionality public class Main { public static void main(String[] args) throws IOException { Message msg = new Message(\"This is a message again\"); MessagePrinter printer = new MessagePrinter(); try (PrintWriter writer = new PrintWriter(System.out)) { // Writing to console output printer.writeMessage(msg, new JSONFormatter(), writer); } } } After refactoring, the MessagePrinter class now depends on the Formatter abstraction rather than its concrete implementations. This makes it easier to replace JSONFormatter with any other implementation of Formatter without modifying the existing code, adhering to the Open-Closed Principle.\n2. Creational Design Patterns Creational Design Patterns focus on the process of object creation, ensuring flexibility and promoting code reuse.\n2.1 Builder The Builder Design Pattern is a creational design pattern that enables the step-by-step construction of complex objects. It separates the construction process form the object\u0026rsquo;s representation, allowing the same process to produce different representations. This pattern is often used to build complex or immutable obejcts.\n❔❔❔ Same Construction Process Creates Different Representations:\nConsider building a meal in a fast-food restaurant, where the construction steps include:\nAdd a main dish (e.g., burger, sandwich, or pizza). Add a side dish (e.g., fries, salad, or breadsticks). Add a drink (e.g., soda, coffee, or juice). The construction process remains consistent: (main dish + side dish + drink). However, the final representation varies based on the choices:\nVeggie Meal: Sandwich + Salad + Juice. Classic Meal: Burger + Fries + Soda. Kids\u0026rsquo; Meal: Mini Pizza + Fries + Milk. --- title: UML Diagram of Builder Pattern --- classDiagram class Builder { +buildPartA() +buildPartB() +getResult() } class ConcreteBuilder1 { +buildPartA() +buildPartB() +getResult() } class ConcreteBuilder2 { +buildPartA() +buildPartB() +getResult() } class Director { +construct(builder: Builder) } class Product { +PartA +PartB } Builder \u003c|-- ConcreteBuilder1 Builder \u003c|-- ConcreteBuilder2 Director --\u003e Builder : uses ConcreteBuilder1 --\u003e Product : creates ConcreteBuilder2 --\u003e Product : creates ℹ️ In a context of design patterns, UML (Unified Modeling Language) is commonly used to represent the structure and behavior of the patterns in a clear and simple manner.\nSHOW CODE: Director Java import java.time.LocalDate; import java.time.Period; import java.util.Objects; // Address class class Address { private String houseNumber; private String street; private String city; private String zipcode; private String state; public Address(String houseNumber, String street, String city, String state, String zipcode) { this.houseNumber = houseNumber; this.street = street; this.city = city; this.state = state; this.zipcode = zipcode; } public String getFullAddress() { return houseNumber + \", \" + street + \"\\n\" + city + \"\\n\" + state + \" \" + zipcode; } } // User class class User { private String firstName; private String lastName; private LocalDate birthday; private Address address; public User(String firstName, String lastName, LocalDate birthday, Address address) { this.firstName = firstName; this.lastName = lastName; this.birthday = birthday; this.address = address; } public String getFirstName() { return firstName; } public String getLastName() { return lastName; } public LocalDate getBirthday() { return birthday; } public Address getAddress() { return address; } } // UserDTO interface interface UserDTO { String getName(); String getAddress(); String getAge(); } // UserWebDTO implementation class UserWebDTO implements UserDTO { private final String name; private final String address; private final String age; public UserWebDTO(String name, String address, String age) { this.name = name; this.address = address; this.age = age; } @Override public String getName() { return name; } @Override public String getAddress() { return address; } @Override public String getAge() { return age; } @Override public String toString() { return \"Name: \" + name + \"\\nAge: \" + age + \"\\nAddress:\\n\" + address; } } // UserDTOBuilder interface interface UserDTOBuilder { UserDTOBuilder withFirstName(String firstName); UserDTOBuilder withLastName(String lastName); UserDTOBuilder withBirthday(LocalDate birthday); UserDTOBuilder withAddress(Address address); UserDTO build(); } // Concrete builder class UserWebDTOBuilder implements UserDTOBuilder { private String firstName; private String lastName; private String age; private String address; @Override public UserDTOBuilder withFirstName(String firstName) { this.firstName = firstName; return this; } @Override public UserDTOBuilder withLastName(String lastName) { this.lastName = lastName; return this; } @Override public UserDTOBuilder withBirthday(LocalDate birthday) { if (Objects.nonNull(birthday)) { this.age = String.valueOf(Period.between(birthday, LocalDate.now()).getYears()); } return this; } @Override public UserDTOBuilder withAddress(Address address) { if (Objects.nonNull(address)) { this.address = address.getFullAddress(); } return this; } @Override public UserDTO build() { return new UserWebDTO(firstName + \" \" + lastName, address, age); } } // Client code (Director) public class Client { public static void main(String[] args) { User user = createUser(); UserDTOBuilder builder = new UserWebDTOBuilder(); UserDTO userDTO = buildUserDTO(builder, user); System.out.println(userDTO); } private static UserDTO buildUserDTO(UserDTOBuilder builder, User user) { return builder.withFirstName(user.getFirstName()) .withLastName(user.getLastName()) .withBirthday(user.getBirthday()) .withAddress(user.getAddress()) .build(); } private static User createUser() { Address address = new Address(\"100\", \"State Street\", \"Pawnee\", \"Indiana\", \"47998\"); return new User(\"Ron\", \"Swanson\", LocalDate.of(1960, 5, 6), address); } } SHOW CODE: Inner Builder Java import java.time.LocalDate; import java.time.Period; // Address class with Builder class Address { private final String houseNumber; private final String street; private final String city; private final String zipcode; private final String state; private Address(Builder builder) { this.houseNumber = builder.houseNumber; this.street = builder.street; this.city = builder.city; this.zipcode = builder.zipcode; this.state = builder.state; } public String getFullAddress() { return houseNumber + \", \" + street + \"\\n\" + city + \"\\n\" + state + \" \" + zipcode; } public static class Builder { private String houseNumber; private String street; private String city; private String zipcode; private String state; public Builder setHouseNumber(String houseNumber) { this.houseNumber = houseNumber; return this; } public Builder setStreet(String street) { this.street = street; return this; } public Builder setCity(String city) { this.city = city; return this; } public Builder setZipcode(String zipcode) { this.zipcode = zipcode; return this; } public Builder setState(String state) { this.state = state; return this; } public Address build() { return new Address(this); } } } // User class with Builder class User { private final String firstName; private final String lastName; private final LocalDate birthday; private final Address address; private User(Builder builder) { this.firstName = builder.firstName; this.lastName = builder.lastName; this.birthday = builder.birthday; this.address = builder.address; } public String getFirstName() { return firstName; } public String getLastName() { return lastName; } public LocalDate getBirthday() { return birthday; } public Address getAddress() { return address; } public static class Builder { private String firstName; private String lastName; private LocalDate birthday; private Address address; public Builder setFirstName(String firstName) { this.firstName = firstName; return this; } public Builder setLastName(String lastName) { this.lastName = lastName; return this; } public Builder setBirthday(LocalDate birthday) { this.birthday = birthday; return this; } public Builder setAddress(Address address) { this.address = address; return this; } public User build() { return new User(this); } } } // UserDTO interface interface UserDTO { String getName(); String getAddress(); String getAge(); } // UserWebDTO implementation class UserWebDTO implements UserDTO { private final String name; private final String address; private final String age; private UserWebDTO(Builder builder) { this.name = builder.name; this.address = builder.address; this.age = builder.age; } @Override public String getName() { return name; } @Override public String getAddress() { return address; } @Override public String getAge() { return age; } @Override public String toString() { return \"Name: \" + name + \"\\nAge: \" + age + \"\\nAddress:\\n\" + address; } public static class Builder { private String name; private String address; private String age; public Builder setName(String name) { this.name = name; return this; } public Builder setAddress(String address) { this.address = address; return this; } public Builder setAge(String age) { this.age = age; return this; } public UserWebDTO build() { return new UserWebDTO(this); } } } // Client code public class Client { public static void main(String[] args) { Address address = new Address.Builder() .setHouseNumber(\"100\") .setStreet(\"State Street\") .setCity(\"Pawnee\") .setState(\"Indiana\") .setZipcode(\"47998\") .build(); User user = new User.Builder() .setFirstName(\"Ron\") .setLastName(\"Swanson\") .setBirthday(LocalDate.of(1960, 5, 6)) .setAddress(address) .build(); UserWebDTO userDTO = new UserWebDTO.Builder() .setName(user.getFirstName() + \" \" + user.getLastName()) .setAddress(user.getAddress().getFullAddress()) .setAge(String.valueOf(Period.between(user.getBirthday(), LocalDate.now()).getYears())) .build(); System.out.println(userDTO); } } Summary Why builder pattern is capable of creating immutable objects?\nImplementing the builder as a static inner class facilitates the creation of immutable objects. The builder class has provileged access to the enclosing class\u0026rsquo;s internal state during the construction process. However, once the final object is built, it does not expose any setters or methods that modify its state, ensuring immutability.\nThe Director in the Builder Design Pattern is responsible for the construction process but is often not implemented as a standalone class. Instead, its responsibilities are typically handled by the client code or the consumer that requires the constructed object. This approach avoids the need for a separate director class, especially when the construction logic is simple or tailored to the client\u0026rsquo;s specific requirements.\nSHOW CODE: Without a Director Java UserDTO userDTO = new UserWebDTOBuilder() .withFirstName(\"John\") .withLastName(\"Doe\") .withBirthday(LocalDate.of(1990, 1, 1)) .withAddress(new Address(\"123\", \"Main St\", \"City\", \"State\", \"12345\")) .build(); SHOW CODE: With a Director Java public class Director { public UserDTO constructUser(UserDTOBuilder builder) { return builder.withFirstName(\"John\") .withLastName(\"Doe\") .withBirthday(LocalDate.of(1990, 1, 1)) .withAddress(new Address(\"123\", \"Main St\", \"City\", \"State\", \"12345\")) .build(); } } If a Product in the Builder Design Pattern is not part of an inheritance hierarchy, creating an abstract builder is unnecessary. The abstract builder is typically used to define method for mutiple types of builders. When there is only one type of product to construct, a concrete builder alone is sufficient to meet the requirements.\n2.2 Simple Factory The Simple Factory design pattern is a creational design pattern that delegates the responsibility of creating instances of different classes to a factory class, typically using a static method based on input parameters. This pattern centralizes object creation, simplifying the client code. However, it can violate the Open-Closed Principle (OCP), because adding a new product type requires modifying the factory class itself. This makes the code less flexible and harder to extend without altering existing source code.\nSHOW CODE Java import java.time.LocalDateTime; import java.time.LocalDate; // Abstract Post class public abstract class Post { private Long id; private String title; private String content; private LocalDateTime createdOn; private LocalDateTime publishedOn; public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } public LocalDateTime getCreatedOn() { return createdOn; } public void setCreatedOn(LocalDateTime createdOn) { this.createdOn = createdOn; } public LocalDateTime getPublishedOn() { return publishedOn; } public void setPublishedOn(LocalDateTime publishedOn) { this.publishedOn = publishedOn; } } // BlogPost class extends Post public class BlogPost extends Post { private String author; private String[] tags; public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } public String[] getTags() { return tags; } public void setTags(String[] tags) { this.tags = tags; } } // NewsPost class extends Post public class NewsPost extends Post { private String headline; private LocalDate newsTime; public String getHeadline() { return headline; } public void setHeadline(String headline) { this.headline = headline; } public LocalDate getNewsTime() { return newsTime; } public void setNewsTime(LocalDate newsTime) { this.newsTime = newsTime; } } // ProductPost class extends Post public class ProductPost extends Post { private String imageUrl; private String name; public String getImageUrl() { return imageUrl; } public void setImageUrl(String imageUrl) { this.imageUrl = imageUrl; } public String getName() { return name; } public void setName(String name) { this.name = name; } } // PostFactory class to create different types of posts public class PostFactory { public static Post createPost(String type) { switch (type) { case \"blog\": return new BlogPost(); case \"news\": return new NewsPost(); case \"product\": return new ProductPost(); default: throw new IllegalArgumentException(\"Post type is unknown\"); } } } // Client class to demonstrate the usage of Simple Factory public class Client { public static void main(String[] args) { Post post = PostFactory.createPost(\"news\"); System.out.println(post.getClass().getSimpleName()); // Prints the type of the created post (NewsPost) } } classDiagram direction RL class Post { - Long id - String title - String content - LocalDateTime createdOn - LocalDateTime publishedOn + getId() + setId(Long) + getTitle() + setTitle(String) + getContent() + setContent(String) + getCreatedOn() + setCreatedOn(LocalDateTime) + getPublishedOn() + setPublishedOn(LocalDateTime) } class BlogPost { - String author - String[] tags + getAuthor() + setAuthor(String) + getTags() + setTags(String[]) } class NewsPost { - String headline - LocalDate newsTime + getHeadline() + setHeadline(String) + getNewsTime() + setNewsTime(LocalDate) } class ProductPost { - String imageUrl - String name + getImageUrl() + setImageUrl(String) + getName() + setName(String) } class PostFactory { + createPost(String) } Post \u003c|-- BlogPost Post \u003c|-- NewsPost Post \u003c|-- ProductPost PostFactory --|\u003e BlogPost : creates PostFactory --|\u003e NewsPost : creates PostFactory --|\u003e ProductPost : creates The above code violates the Open-Closed Principle because when adding a new post type, such as EventPost, to the factory, the code must be modified by adding a new case statement, like the following:\ncase \u0026#34;event\u0026#34;: return new EventPost(); This approach breaks the OCP, which dictates that entities should be open for extension but closed for modification.\n2.3 Factory Method The Factory Method design pattern is a creational pattern that provides a method for creating objects in a superclass, while allowing subclasses to determine the type of object that will be created. This approach delegates the object creation process to the subclasses, enabling them to instantiate specific classes without the superclass needing to know the exact class being instantiated.\nSHOW CODE Java import java.util.*; /** * Abstract class representing a message, which is the \"product\". * Subclasses will provide specific content types. */ abstract class Message { public abstract String getContent(); public void addDefaultHeaders() { // Adds some default headers } public void encrypt() { // Has some code to encrypt the content } } /** * Concrete implementation of the Message class for Text messages. */ class TextMessage extends Message { @Override public String getContent() { return \"Text\"; } } /** * Concrete implementation of the Message class for JSON messages. */ class JSONMessage extends Message { @Override public String getContent() { return \"{\\\"JSON\\\":[]}\"; } } /** * Abstract creator class. The factory method createMessage() must be implemented * by subclasses to instantiate the specific message type. */ abstract class MessageCreator { public Message getMessage() { Message msg = createMessage(); msg.addDefaultHeaders(); msg.encrypt(); return msg; } // Factory method to create a message protected abstract Message createMessage(); } /** * Concrete creator for creating JSON messages. */ class JSONMessageCreator extends MessageCreator { @Override public Message createMessage() { return new JSONMessage(); } } /** * Concrete creator for creating Text messages. */ class TextMessageCreator extends MessageCreator { @Override public Message createMessage() { return new TextMessage(); } } /** * Client class demonstrating the use of the Factory Method pattern. */ public class Client { public static void main(String[] args) { printMessage(new JSONMessageCreator()); printMessage(new TextMessageCreator()); } public static void printMessage(MessageCreator creator) { Message msg = creator.getMessage(); System.out.println(msg.getContent()); } } --- title: UML Diagram of Factory Method Pattern --- classDiagram Message \u003c|-- TextMessage Message \u003c|-- JSONMessage MessageCreator \u003c|-- JSONMessageCreator MessageCreator \u003c|-- TextMessageCreator JSONMessageCreator \"1\" --\u003e \"1\" JSONMessage : creates TextMessageCreator \"1\" --\u003e \"1\" TextMessage : creates MessageCreator : +getMessage() MessageCreator : +createMessage() JSONMessageCreator : +createMessage() TextMessageCreator : +createMessage() Message : +getContent() Message : +addDefaultHeaders() Message : +encrypt() 2.4 Prototype The Prototype design pattern is a creational pattern that enables the creation of new objects by copying an existing object, known as the prototype. It is particularly useful when object creation is resource-intensive or when there is a need to dynamically create mana similar objects.\nSHOW CODE Java // Point3D class representing a 3D point class Point3D { private float x, y, z; public static final Point3D ZERO = new Point3D(0, 0, 0); public Point3D(float x, float y, float z) { this.x = x; this.y = y; this.z = z; } public Point3D normalize() { float mag = magnitude(); return new Point3D(x / mag, y / mag, z / mag); } private float magnitude() { return (float) Math.sqrt(x * x + y * y + z * z); } public Point3D multiply(float scale) { return new Point3D(x * scale, y * scale, z * scale); } public Point3D add(Point3D vector) { return new Point3D(x + vector.x, y + vector.y, z + vector.z); } @Override public String toString() { return \"(\" + x + \", \" + y + \", \" + z + \")\"; } } // Abstract GameUnit class defining the clone method abstract class GameUnit implements Cloneable { private Point3D position; public GameUnit() { position = Point3D.ZERO; } @Override public GameUnit clone() throws CloneNotSupportedException { GameUnit unit = (GameUnit) super.clone(); unit.initialize(); return unit; } protected void initialize() { this.position = Point3D.ZERO; reset(); } protected abstract void reset(); public GameUnit(float x, float y, float z) { position = new Point3D(x, y, z); } public void move(Point3D direction, float distance) { Point3D finalMove = direction.normalize(); finalMove = finalMove.multiply(distance); position = position.add(finalMove); } public Point3D getPosition() { return position; } } // Swordsman class extends GameUnit and implements specific behavior class Swordsman extends GameUnit { private String state = \"idle\"; public void attack() { this.state = \"attacking\"; } @Override public String toString() { return \"Swordsman \" + state + \" @ \" + getPosition(); } @Override protected void reset() { state = \"idle\"; } } // General class extends GameUnit but does not support cloning class General extends GameUnit { private String state = \"idle\"; public void boostMorale() { this.state = \"MoralBoost\"; } @Override public String toString() { return \"General \" + state + \" @ \" + getPosition(); } @Override public GameUnit clone() throws CloneNotSupportedException { throw new CloneNotSupportedException(\"Generals are unique\"); } @Override protected void reset() { throw new UnsupportedOperationException(\"Reset not supported\"); } } public class Main { // Client code to demonstrate the Prototype Pattern public static void main(String[] args) throws CloneNotSupportedException { // Creating and moving a Swordsman Swordsman s1 = new Swordsman(); s1.move(new Point3D(-10, 0, 0), 20); s1.attack(); System.out.println(s1); // Cloning the Swordsman Swordsman s2 = (Swordsman) s1.clone(); System.out.println(\"Cloned swordsman: \" + s2); } } Shallow Copy vs. Deep Copy: A shallow copy creates a new object but only copies the references of the original object\u0026rsquo;s fields. As a result, both the original and the copied object share references to the same inner objects. Any changes made to the inner mutable objects of the copied object will affect the original object as well. In Java, the clone method performs a shallow copy. On the other hand, a deep copy involves recursively copying the original object and all the objects it references. As a result, the copied object is entirely independent of the original, and changes made to the copied object do not affect the original one.\nSHOW CODE: Shallow Copy Java import java.util.ArrayList; import java.util.List; /** * @author Signal Yu * @since 2024-12-2 */ class Person { String name; int age; public Person(String name, int age) { this.name = name; this.age = age; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"Person{name='\" + name + \"', age=\" + age + '}'; } } public class Solution { public static void main(String[] args) { // Original list with mutable objects (Person) List\u0026lt;Person\u0026gt; originalList = new ArrayList\u0026lt;\u0026gt;(); originalList.add(new Person(\"Alice\", 30)); originalList.add(new Person(\"Bob\", 25)); // Shallow copy of the list List\u0026lt;Person\u0026gt; shallowCopyList = new ArrayList\u0026lt;\u0026gt;(originalList); // Modify the object in the shallow copy shallowCopyList.get(1).setName(\"Signal\"); // Print both lists System.out.println(\"Original List: \" + originalList); System.out.println(\"Shallow Copy List: \" + shallowCopyList); } } SHOW OUTPUT: Shallow Copy Output Original List: [Person{name='Alice', age=30}, Person{name='Signal', age=25}] Shallow Copy List: [Person{name='Alice', age=30}, Person{name='Signal', age=25}] SHOW CODE: Deep Copy Java import java.util.ArrayList; import java.util.List; class Person { String name; int age; public Person(String name, int age) { this.name = name; this.age = age; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"Person{name='\" + name + \"', age=\" + age + '}'; } // Deep copy method for Person class public Person deepCopy() { return new Person(this.name, this.age); } } public class Solution { public static void main(String[] args) { // Original list with mutable objects (Person) List\u0026lt;Person\u0026gt; originalList = new ArrayList\u0026lt;\u0026gt;(); originalList.add(new Person(\"Alice\", 30)); originalList.add(new Person(\"Bob\", 25)); // Deep copy of the list (creating new Person objects) List\u0026lt;Person\u0026gt; deepCopyList = new ArrayList\u0026lt;\u0026gt;(); for (Person person : originalList) { deepCopyList.add(person.deepCopy()); // Add a deep copy of each person } // Modify the object in the deep copy deepCopyList.get(1).setName(\"Signal\"); // Print both lists System.out.println(\"Original List: \" + originalList); System.out.println(\"Deep Copy List: \" + deepCopyList); } } SHOW OUTPUT: Deep Copy Output Original List: [Person{name='Alice', age=30}, Person{name='Bob', age=25}] Deep Copy List: [Person{name='Alice', age=30}, Person{name='Signal', age=25}] It is important to note that changes made to immutable objects in a shallow copied object will not affect the original object. For example, when performing a shallow copy of an ArrayList that contains Integer values, changes made to the Integer of the copied object will not affect the original object because Integer is immutable (since it is marked as final and its value cannot be changed).\nSHOW CODE Java import java.util.ArrayList; import java.util.List; /** * @author Signal Yu * @since 2024-12-2 */ public class Solution { public static void main(String[] args) { // Integer is an immutable class List\u0026lt;Integer\u0026gt; original = new ArrayList\u0026lt;\u0026gt;(); original.add(1); original.add(2); List\u0026lt;Integer\u0026gt; shallowCopy = new ArrayList\u0026lt;\u0026gt;(original); // Shallow copy shallowCopy.set(0, 99); // Modify the shallow copy System.out.println(original); // Output: [1, 2] System.out.println(shallowCopy); // Output: [99, 2] } } Prototype v.s. Builder\n2.5 Abstract Factory The Abstract Factory design pattern is a creational pattern that creates families of related objects without specifying their concrete classes. It allows the client to instantiate objects from a group of related products while ensuring that these objects are compatible with each other. This pattern is particularly useful when a system needs to be independent of how objects are created, composed, and represented. However, a limitation of this pattern is that when a new product type is added, the base factory typically needs to be modified, which can increase the maintainence overhead.\nSHOW CODE Java // Represents an abstract product interface Storage { String getId(); } // Represents a concrete product in a family \"Amazon Web Services\" class S3Storage implements Storage { public S3Storage(int capacityInMib) { System.out.println(\"Allocated \" + capacityInMib + \" on S3\"); } @Override public String getId() { return \"S31\"; } @Override public String toString() { return \"S3 Storage\"; } } // Represents a concrete product in a family \"Google Cloud Platform\" class GoogleCloudStorage implements Storage { public GoogleCloudStorage(int capacityInMib) { System.out.println(\"Allocated \" + capacityInMib + \" on Google Cloud Storage\"); } @Override public String getId() { return \"gcpcs1\"; } @Override public String toString() { return \"Google cloud storage\"; } } // Represents an abstract product interface Instance { enum Capacity {micro, small, large} void start(); void attachStorage(Storage storage); void stop(); } // Represents a concrete product in a family \"Amazon Web Services\" class Ec2Instance implements Instance { public Ec2Instance(Capacity capacity) { System.out.println(\"Created Ec2Instance\"); } @Override public void start() { System.out.println(\"Ec2Instance started\"); } @Override public void attachStorage(Storage storage) { System.out.println(\"Attached \" + storage + \" to Ec2Instance\"); } @Override public void stop() { System.out.println(\"Ec2Instance stopped\"); } @Override public String toString() { return \"EC2Instance\"; } } // Represents a concrete product in a family \"Google Cloud Platform\" class GoogleComputeEngineInstance implements Instance { public GoogleComputeEngineInstance(Capacity capacity) { System.out.println(\"Created Google Compute Engine instance\"); } @Override public void start() { System.out.println(\"Compute engine instance started\"); } @Override public void attachStorage(Storage storage) { System.out.println(\"Attached \" + storage + \" to Compute engine instance\"); } @Override public void stop() { System.out.println(\"Compute engine instance stopped\"); } } // Abstract factory with methods defined for each object type. interface ResourceFactory { Instance createInstance(Instance.Capacity capacity); Storage createStorage(int capMib); } // Factory implementation for Amazon Web Services resources class AwsResourceFactory implements ResourceFactory { @Override public Instance createInstance(Instance.Capacity capacity) { return new Ec2Instance(capacity); } @Override public Storage createStorage(int capMib) { return new S3Storage(capMib); } } // Factory implementation for Google Cloud Platform resources class GoogleResourceFactory implements ResourceFactory { @Override public Instance createInstance(Instance.Capacity capacity) { return new GoogleComputeEngineInstance(capacity); } @Override public Storage createStorage(int capMib) { return new GoogleCloudStorage(capMib); } } // Client class public class Client { private ResourceFactory factory; public Client(ResourceFactory factory) { this.factory = factory; } public Instance createServer(Instance.Capacity cap, int storageMib) { Instance instance = factory.createInstance(cap); Storage storage = factory.createStorage(storageMib); instance.attachStorage(storage); return instance; } public static void main(String[] args) { Client aws = new Client(new AwsResourceFactory()); Instance i1 = aws.createServer(Instance.Capacity.micro, 20480); i1.start(); i1.stop(); System.out.println(\"***************************************\"); Client gcp = new Client(new GoogleResourceFactory()); i1 = gcp.createServer(Instance.Capacity.micro, 20480); i1.start(); i1.stop(); } } SHOW OUTPUT Output Created Ec2Instance Allocated 20480 on S3 Attached S3 Storage to Ec2Instance Ec2Instance started Ec2Instance stopped *************************************** Created Google Compute Engine instance Allocated 20480 on Google Cloud Storage Attached Google cloud storage to Compute engine instance Compute engine instance started Compute engine instance stopped Adding a new product type, such as Engine, may require modifications to the base factory. This is because the new Engine product froms a new combination with Storage and Instance, and the base factory is responsible for creating all the products (i.e., Storage, Instance, and Engine). As a result, the base factory needs to include a new method, createEngine. This modification violates the Open/Closed Principle (OCP), which states that classes should be open for extension but closed for modification.\nSHOW CODE Java // Represents an abstract product for Storage interface Storage { String getId(); } // Represents a concrete product in a family \"Amazon Web Services\" for Storage class S3Storage implements Storage { public S3Storage(int capacityInMib) { System.out.println(\"Allocated \" + capacityInMib + \" on S3\"); } @Override public String getId() { return \"S31\"; } @Override public String toString() { return \"S3 Storage\"; } } // Represents a concrete product in a family \"Google Cloud Platform\" for Storage class GoogleCloudStorage implements Storage { public GoogleCloudStorage(int capacityInMib) { System.out.println(\"Allocated \" + capacityInMib + \" on Google Cloud Storage\"); } @Override public String getId() { return \"gcpcs1\"; } @Override public String toString() { return \"Google Cloud Storage\"; } } // Represents an abstract product for Engine interface Engine { String getName(); } // Represents a concrete product in a family \"Amazon Web Services\" for Engine class Ec2Engine implements Engine { String name; public Ec2Engine(String name) { this.name = name; System.out.println(name + \" engine selected.\"); } @Override public String getName() { return name; } } // Represents a concrete product in a family \"Google Cloud Platform\" for Engine class GoogleComputeEngine implements Engine { String name; public GoogleComputeEngine(String name) { this.name = name; System.out.println(name + \" engine selected.\"); } @Override public String getName() { return name; } } // Represents an abstract product for Instance interface Instance { enum Capacity {micro, small, large} void start(); void attachStorage(Storage storage); void stop(); void useEngine(Engine engine); } // Represents a concrete product in a family \"Amazon Web Services\" for Instance class Ec2Instance implements Instance { public Ec2Instance(Instance.Capacity capacity) { System.out.println(\"Created Ec2Instance\"); } @Override public void start() { System.out.println(\"Ec2Instance started\"); } @Override public void attachStorage(Storage storage) { System.out.println(\"Attached \" + storage + \" to Ec2Instance\"); } @Override public void stop() { System.out.println(\"Ec2Instance stopped\"); } @Override public void useEngine(Engine engine) { System.out.println(\"Ec2Instance uses \" + engine.getName() + \" engine.\"); } @Override public String toString() { return \"EC2Instance\"; } } // Represents a concrete product in a family \"Google Cloud Platform\" for Instance class GoogleComputeEngineInstance implements Instance { public GoogleComputeEngineInstance(Instance.Capacity capacity) { System.out.println(\"Created Google Compute Engine instance\"); } @Override public void start() { System.out.println(\"Compute engine instance started\"); } @Override public void attachStorage(Storage storage) { System.out.println(\"Attached \" + storage + \" to Compute engine instance\"); } @Override public void stop() { System.out.println(\"Compute engine instance stopped\"); } @Override public void useEngine(Engine engine) { System.out.println(\"Google compute engine instance uses \" + engine.getName() + \" engine.\"); } } // Abstract factory with methods defined for each object type interface ResourceFactory { Instance createInstance(Instance.Capacity capacity); Storage createStorage(int capMib); Engine createEngine(String name); } // Factory implementation for Amazon Web Services resources class AwsResourceFactory implements ResourceFactory { @Override public Instance createInstance(Instance.Capacity capacity) { return new Ec2Instance(capacity); // Pass engine to the Ec2Instance } @Override public Storage createStorage(int capMib) { return new S3Storage(capMib); } @Override public Engine createEngine(String name) { return new Ec2Engine(name); } } // Factory implementation for Google Cloud Platform resources class GoogleResourceFactory implements ResourceFactory { @Override public Instance createInstance(Instance.Capacity capacity) { return new GoogleComputeEngineInstance(capacity); } @Override public Storage createStorage(int capMib) { return new GoogleCloudStorage(capMib); } @Override public Engine createEngine(String name) { return new GoogleComputeEngine(name); } } // Client class to test the code public class Client { private ResourceFactory factory; public Client(ResourceFactory factory) { this.factory = factory; } public Instance createServer(Instance.Capacity cap, int storageMib, String name) { Instance instance = factory.createInstance(cap); // Pass engine to instance creation Storage storage = factory.createStorage(storageMib); Engine engine = factory.createEngine(name); instance.attachStorage(storage); instance.useEngine(engine); // Call useEngine() on instance, which delegates to engine's getName() return instance; } public static void main(String[] args) { Client aws = new Client(new AwsResourceFactory()); Instance i1 = aws.createServer(Instance.Capacity.micro, 20480, \"Ec2\"); i1.start(); i1.stop(); System.out.println(\"***************************************\"); Client gcp = new Client(new GoogleResourceFactory()); i1 = gcp.createServer(Instance.Capacity.micro, 20480, \"GCE\"); i1.start(); i1.stop(); } } 2.6 Singleton Singleton is a creational design pattern that ensures a class has only one instance and provides a global point of access to that instance (typically through a static method). To implement a Singleton, the class constructor must be private, which prevents external classes from creating instances of the class directly, and a global static method should be provided to access the instance. There are two common types of Singleton: Eager Singleton and Lazy Singleton.\n2.6.1 Eager Singleton Eager Singleton ensures that an instance is created as soon as the class is loaded, rather than being created when needed. This guarantees that the instance is ready to use but may cause unnecessary overhead if the instance is never actually used.\nSHOW CODE: Eager Singleton Eager Singleton package dev.signalyu.singleton; public class EagerRegistry { private EagerRegistry() { // Private constructor to prevent instantiation } // Eagerly initializing the single instance of EagerRegistry private static final EagerRegistry INSTANCE = new EagerRegistry(); // Public method to provide access to the instance public static EagerRegistry getInstance() { return INSTANCE; } // Main method to demonstrate usage public static void main(String[] args) { // Accessing the singleton instance EagerRegistry registry = EagerRegistry.getInstance(); System.out.println(\"Singleton instance: \" + registry); } } SHOW OUTPUT Output Singleton instance: dev.signalyu.singleton.EagerRegistry@7a81197d 2.6.2 Lazy Singleton Lazy Singleton ensures that an instance of the class is created only when it is actually needed. This approach helps avoid unnecessary overhead but requires additional mechanisms to ensure thread safety in multi-threaded environments. It is commonly implemented using techniques like Double-Checked Locking or Initialization-on-Demand Holder.\nDouble-Checked Locking is an optimization technique ensures only one instance of a class is created, even in a multi-threaded environment, while minimizing synchronization overhead. This approach involves two checks: The first check, outside the synchronized block, allows the thread to bypass synchronization if the instance has already been created. The second check, inside the synchronized block, ensures that only one thread can create the instance, even if multiple threads attempt to do so concurrently.\nSHOW CODE: Double-Checked Locking Double-Checked Locking package dev.signalyu.singleton; public class LazyRegistryWithDCL { // Private constructor to prevent external instantiation private LazyRegistryWithDCL() {} // Volatile keyword ensures visibility of changes across threads private static volatile LazyRegistryWithDCL INSTANCE; // Public method to provide access to the Singleton instance public static LazyRegistryWithDCL getInstance() { if (INSTANCE == null) { // First check (outside synchronized block) synchronized (LazyRegistryWithDCL.class) { // Synchronized block to ensure only one thread can create the instance if (INSTANCE == null) { // Second check (inside synchronized block) INSTANCE = new LazyRegistryWithDCL(); // Lazy initialization } } } return INSTANCE; } // Main method to demonstrate the usage of the Singleton public static void main(String[] args) { // Accessing the Singleton instance LazyRegistryWithDCL registry = LazyRegistryWithDCL.getInstance(); System.out.println(\"Singleton instance: \" + registry); } } SHOW OUTPUT Output Singleton instance: dev.signalyu.singleton.LazyRegistryWithDCL@7a81197d The Initialization-on-Demand Holder technique leverages the class loading mechnism to ensure that the Singleton instance is created only when it is first accessed. It takes advantages of the fact that class loading in Java inherently thread-safe. This approach relies on static inner classes, which are not loaded until they are referenced, meaning that the instance is created only when it is actually needed.\nSHOW CODE: Initialization-on-Demand Holder Initialization-on-Demand Holder package dev.signalyu.singleton; public class LazyRegistryIODH { // Private constructor to prevent external instantiation private LazyRegistryIODH() { System.out.println(\"In LazyRegistryIODH singleton\"); } // Static inner class that holds the Singleton instance private static class RegistryHolder { // The Singleton instance is created when the class is loaded static final LazyRegistryIODH INSTANCE = new LazyRegistryIODH(); } // Public method to provide access to the Singleton instance public static LazyRegistryIODH getInstance() { return RegistryHolder.INSTANCE; } // Main method to demonstrate the usage of the Singleton public static void main(String[] args) { // Accessing the Singleton instance LazyRegistryIODH registry = LazyRegistryIODH.getInstance(); System.out.println(\"Singleton instance: \" + registry); } } SHOW OUTPUT Output In LazyRegistryIODH singleton Singleton instance: dev.signalyu.singleton.LazyRegistryIODH@5ca881b5 2.7 Object Pool Object Pool Design Pattern is a creational design pattern that manages a collection of reusable objects, rather than frequently creating and destroying objects. These objects are stored in a pool, from which clients can borrow objects, use them, and return them when they are done. This pattern is particularly useful in scenerios where a large number of objects are needed temporarily, and the cost of creating these objects is high, such as resource management (e.g., database connection or thread pools).\nSHOW CODE Java import java.util.concurrent.BlockingQueue; import java.util.concurrent.LinkedBlockingQueue; import java.util.function.Supplier; // Point2D class class Point2D { private float x, y; public Point2D(float x, float y) { this.x = x; this.y = y; } @Override public String toString() { return \"Point2D [x=\" + x + \", y=\" + y + \"]\"; } } // Poolable interface interface Poolable { // state reset void reset(); } // Image interface extending Poolable interface Image extends Poolable { void draw(); Point2D getLocation(); void setLocation(Point2D location); } // Bitmap class implementing Image and Poolable class Bitmap implements Image { private Point2D location; private String name; public Bitmap(String name) { this.name = name; } @Override public void draw() { System.out.println(\"Drawing \" + name + \" @ \" + location); } @Override public Point2D getLocation() { return location; } @Override public void setLocation(Point2D location) { this.location = location; } @Override public void reset() { location = null; System.out.println(\"Bitmap is reset\"); } } // ObjectPool class for reusable objects class ObjectPool { private BlockingQueue\u0026lt;T\u0026gt; availablePool; public ObjectPool(Supplier\u0026lt;T\u0026gt; creator, int count) { availablePool = new LinkedBlockingQueue\u0026lt;\u0026gt;(); for (int i = 0; i \u003c count; i++) { availablePool.offer(creator.get()); } } public T get() { try { return availablePool.take(); } catch (InterruptedException ex) { System.err.println(\"take() was interrupted\"); } return null; } public void release(T obj) { obj.reset(); try { availablePool.put(obj); } catch (InterruptedException e) { System.err.println(\"put() was interrupted\"); } } } // Main class to demonstrate Object Pool usage public class Client { public static void main(String[] args) { // Create a pool for Bitmap objects with 5 instances ObjectPool\u0026lt;Bitmap\u0026gt; bitmapPool = new ObjectPool\u0026lt;\u0026gt;(() -\u003e new Bitmap(\"Logo.bmp\"), 5); // Borrow Bitmap objects from the pool Bitmap b1 = bitmapPool.get(); b1.setLocation(new Point2D(10, 10)); Bitmap b2 = bitmapPool.get(); b2.setLocation(new Point2D(-10, 0)); // Use the objects b1.draw(); b2.draw(); // Release the objects back to the pool bitmapPool.release(b1); bitmapPool.release(b2); } } --- title: UML Diagram of Object Pool Design Pattern --- classDiagram ObjectPool --\u003e Bitmap : uses Bitmap --\u003e Point2D : uses Poolable \u003c|-- Image : implements Image \u003c|-- Bitmap : implements Client --\u003e ObjectPool : uses class ObjectPool { +BlockingQueue~T~ availablePool +ObjectPool(Supplier~T~ creator, int count) +T get() +void release(T obj) } class Bitmap { +Point2D location +String name +Bitmap(String name) +void draw() +Point2D getLocation() +void setLocation(Point2D location) +void reset() } class Point2D { +float x +float y +Point2D(float x, float y) +String toString() } class Poolable { +void reset() } class Image { +void draw() +Point2D getLocation() +void setLocation(Point2D location) } class Client { +void main() } 3. Structural Design Patterns Structural Design Pattern focus on optimizing object composition, helping achieve better organization and efficiency.\n3.1 Adapter The Adapter Design Pattern is a structural design pattern that allows two incompatible interfaces to work together, enabling them to communicate despite differences in their method signatures. This pattern is commonly used in situations where legacy code cannot be modified but needs to integrate with a new system that has a different interface.\nSHOW CODE Java // Target Interface interface Customer { String getName(); String getDesignation(); String getAddress(); } // Client code which requires Customer interface. class BusinessCardDesigner { public String designCard(Customer customer) { String card = \"\"; card += customer.getName(); card += \"\\n\" + customer.getDesignation(); card += \"\\n\" + customer.getAddress(); return card; } } // An existing class used in our system - Adaptee class Employee { private String fullName; private String jobTitle; private String officeLocation; public String getFullName() { return fullName; } public void setFullName(String fullName) { this.fullName = fullName; } public String getJobTitle() { return jobTitle; } public void setJobTitle(String jobTitle) { this.jobTitle = jobTitle; } public String getOfficeLocation() { return officeLocation; } public void setOfficeLocation(String officeLocation) { this.officeLocation = officeLocation; } } // An object adapter using composition to translate the interface class EmployeeObjectAdapter implements Customer { private final Employee adaptee; public EmployeeObjectAdapter(Employee adaptee) { this.adaptee = adaptee; } @Override public String getName() { return adaptee.getFullName(); } @Override public String getDesignation() { return adaptee.getJobTitle(); } @Override public String getAddress() { return adaptee.getOfficeLocation(); } } public class Client { public static void main(String[] args) { // Using Object Adapter Employee employee = new Employee(); populateEmployeeData(employee); EmployeeObjectAdapter objectAdapter = new EmployeeObjectAdapter(employee); BusinessCardDesigner designer = new BusinessCardDesigner(); String card = designer.designCard(objectAdapter); System.out.println(card); } private static void populateEmployeeData(Employee employee) { employee.setFullName(\"Signal Yu\"); employee.setJobTitle(\"Software Engineer\"); employee.setOfficeLocation(\"Shenzhen, Guangdong Province\"); } } --- title: UML Diagram of Adapter Design Pattern --- classDiagram class Customer { +String getName() +String getDesignation() +String getAddress() } class BusinessCardDesigner { +String designCard(Customer customer) } class Employee { -String fullName -String jobTitle -String officeLocation +String getFullName() +String getJobTitle() +String getOfficeLocation() +setFullName(String fullName) +setJobTitle(String jobTitle) +setOfficeLocation(String officeLocation) } class EmployeeObjectAdapter { -Employee adaptee +String getName() +String getDesignation() +String getAddress() } Customer \u003c|-- EmployeeObjectAdapter : implements BusinessCardDesigner --\u003e Customer : uses EmployeeObjectAdapter --\u003e Employee : adapts 3.2 Bridge The Bridge Design Pattern is a structural design pattern that separates the abstraction and implementation, enabling them to evolve independently without affecting each other.\nIn the following example, the Queue data structure is decoupled from the implementation of LinkedList. When there is a need to change the way data is stored, this can be done without modifying the Queue class. Additionally, when a new type of list, such as Doubly Linked List, is introduced, it can be done without affecting the behavior of the Queue class.\nSHOW CODE Java // This is the implementor interface. // It defines the basic operations for a LinkedList. interface LinkedList { void addFirst(T element); T removeFirst(); void addLast(T element); T removeLast(); int getSize(); } // A concrete implementor that uses nodes to implement a Singly Linked List. // **NOT thread safe** class SinglyLinkedList implements LinkedList { private int size; private Node head; private Node last; private static class Node { private final Object data; private Node next; private Node(Object data, Node next) { this.data = data; this.next = next; } } @Override public void addFirst(T element) { if (head == null) { last = head = new Node(element, null); } else { head = new Node(element, head); } size++; } @Override public T removeFirst() { if (head == null) { return null; } @SuppressWarnings(\"unchecked\") T temp = (T) head.data; if (head.next != null) { head = head.next; } else { head = null; last = null; } size--; return temp; } @Override public void addLast(T element) { if (last == null) { last = head = new Node(element, null); } else { last.next = new Node(element, null); last = last.next; } size++; } @Override public T removeLast() { if (last == null) { return null; } if (head == last) { @SuppressWarnings(\"unchecked\") T temp = (T) head.data; head = last = null; size--; return temp; } // since we don't have a back pointer Node temp = head; while (temp.next != last) { temp = temp.next; } @SuppressWarnings(\"unchecked\") T result = (T) last.data; last = temp; last.next = null; size--; return result; } @Override public int getSize() { return size; } @Override public String toString() { StringBuilder result = new StringBuilder(\"[\"); Node temp = head; while (temp != null) { result.append(temp.data).append(temp.next == null ? \"\" : \", \"); temp = temp.next; } result.append(\"]\"); return result.toString(); } } // A concrete implementor that uses arrays to implement a LinkedList. // **NOT thread safe** class ArrayLinkedList implements LinkedList { private static final int DEFAULT_SIZE = 2; private Object[] data; private int size; public ArrayLinkedList() { data = new Object[DEFAULT_SIZE]; } @Override public void addFirst(T element) { ensureCapacity(++size); shiftOneRight(); data[0] = element; } @Override public T removeFirst() { if (size == 0) { return null; } @SuppressWarnings(\"unchecked\") T first = (T) data[0]; size--; shiftOneLeft(); return first; } @Override public void addLast(T element) { ensureCapacity(size + 1); data[size++] = element; } @Override @SuppressWarnings(\"unchecked\") public T removeLast() { if (size == 0) { return null; } return (T) data[size--]; } private void ensureCapacity(int newSize) { if (data.length \u003e newSize) { return; } Object[] temp = new Object[data.length + DEFAULT_SIZE]; System.arraycopy(data, 0, temp, 0, data.length); data = temp; } private void shiftOneRight() { System.arraycopy(data, 0, data, 1, size); } private void shiftOneLeft() { System.arraycopy(data, 1, data, 0, size); } public int getSize() { return size; } @Override public String toString() { StringBuilder result = new StringBuilder(\"[\"); for (int i = 0; i \u003c size; i++) { result.append(data[i]).append(i == size - 1 ? \"\" : \", \"); } result.append(\"]\"); return result.toString(); } } // This is the abstraction interface representing a FIFO collection. interface FifoCollection { // Adds an element to the collection void offer(T element); // Removes \u0026 returns the first element from the collection T poll(); } // A refined abstraction that uses LinkedList to implement a Queue. class Queue implements FifoCollection { private final LinkedList list; public Queue(LinkedList list) { this.list = list; } @Override public void offer(T element) { list.addLast(element); } @Override public T poll() { return list.removeFirst(); } @Override public String toString() { return \"Queue{\" + \"list=\" + list.toString() + '}'; } } // Client code to demonstrate the bridge pattern public class Client { public static void main(String[] args) { FifoCollection\u0026lt;Integer\u0026gt; arrayQueue = new Queue\u0026lt;\u0026gt;(new ArrayLinkedList\u0026lt;\u0026gt;()); arrayQueue.offer(1); arrayQueue.offer(2); arrayQueue.offer(3); System.out.print(\"Array List Queue: \"); System.out.println(arrayQueue); FifoCollection\u0026lt;Integer\u0026gt; linkedListQueue = new Queue\u0026lt;\u0026gt;(new SinglyLinkedList\u0026lt;\u0026gt;()); linkedListQueue.offer(11); linkedListQueue.offer(22); linkedListQueue.offer(33); System.out.print(\"Linked List Queue: \"); System.out.println(linkedListQueue); System.out.print(linkedListQueue.poll() + \" \"); System.out.print(linkedListQueue.poll() + \" \"); System.out.print(linkedListQueue.poll() + \"\\n\"); // Should print null as all elements are removed System.out.println(linkedListQueue.poll()); // null } } SHOW OUTPUT Output Array List Queue: Queue{list=[1, 2, 3]} Linked List Queue: Queue{list=[11, 22, 33]} 11 22 33 null --- title: UML Diagram of Adapter Design Pattern --- classDiagram class LinkedList { +addFirst(T element) +removeFirst() +addLast(T element) +removeLast() +getSize() } class SinglyLinkedList { -int size -Node head -Node last +addFirst(T element) +removeFirst() +addLast(T element) +removeLast() +getSize() +toString() } class ArrayLinkedList { -Object[] data -int size +addFirst(T element) +removeFirst() +addLast(T element) +removeLast() +getSize() +toString() } class FifoCollection { +offer(T element) +poll() } class Queue { -LinkedList list +offer(T element) +poll() +toString() } LinkedList \u003c|.. SinglyLinkedList LinkedList \u003c|.. ArrayLinkedList FifoCollection \u003c|.. Queue : implements Queue *--\u003e LinkedList : composites %% Client code class class Client { +main(String[] args) } Client --\u003e FifoCollection : Uses 3.3 Decorator Decorator Design Pattern is a structural design pattern that allows addding new behaviors to an object dynamically, without altering its structure.\nSHOW CODE Java import org.apache.commons.text.StringEscapeUtils; import java.util.Base64; // Base interface or component interface Message { String getContent(); } // Concrete component. Object to be decorated class TextMessage implements Message { private String msg; public TextMessage(String msg) { this.msg = msg; } @Override public String getContent() { return msg; } } // Decorator. Implements component interface class HtmlEncodedMessage implements Message { private Message msg; public HtmlEncodedMessage(Message msg) { this.msg = msg; } @Override public String getContent() { return StringEscapeUtils.escapeHtml4(msg.getContent()); } } // Decorator for Base64 encoding class Base64EncodedMessage implements Message { private Message msg; public Base64EncodedMessage(Message msg) { this.msg = msg; } @Override public String getContent() { // Be wary of charset!! This is platform dependent.. return Base64.getEncoder().encodeToString(msg.getContent().getBytes()); } } // Client to demonstrate the decorators public class Client { public static void main(String[] args) { Message m = new TextMessage(\"The is strong with this one!\"); System.out.println(\"Original: \" + m.getContent()); // Apply HTML encoding Message decorator = new HtmlEncodedMessage(m); System.out.println(\"HTML Encoded: \" + decorator.getContent()); // Apply Base64 encoding decorator = new Base64EncodedMessage(decorator); System.out.println(\"Base64 Encoded: \" + decorator.getContent()); } } --- title: UML Diagram of Decorator Design Pattern --- classDiagram class Message { +String getContent() } class TextMessage { -String msg +TextMessage(String msg) +String getContent() } class HtmlEncodedMessage { -Message msg +HtmlEncodedMessage(Message msg) +String getContent() } class Base64EncodedMessage { -Message msg +Base64EncodedMessage(Message msg) +String getContent() } Message \u003c|-- TextMessage Message \u003c|-- HtmlEncodedMessage Message \u003c|-- Base64EncodedMessage TextMessage --\u003e HtmlEncodedMessage : Wraps HtmlEncodedMessage --\u003e Base64EncodedMessage : Wraps 3.4 Composite The Composite Design Pattern is a structural pattern that enables treating both individual objects and compositions of objects uniformly. It is designed to represent part-whole hierarchies, where individual objects (leaf nodes) and their composites are handled in the same way. This pattern is often used for managing complex hierarchical structures, such as file systems or organization structures.\nSHOW CODE Java import java.util.ArrayList; import java.util.List; // The component base class for composite pattern // Defines operations applicable both leaf \u0026 composite abstract class File { private String name; public File(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } public abstract void ls(); public abstract void addFile(File file); public abstract File[] getFiles(); public abstract boolean removeFile(File file); } // Leaf node in composite pattern class BinaryFile extends File { private long size; public BinaryFile(String name, long size) { super(name); this.size = size; } @Override public void ls() { System.out.println(getName() + \"\\t\" + size); } @Override public void addFile(File file) { throw new UnsupportedOperationException(\"Leaf node doesn't support add operation\"); } @Override public File[] getFiles() { throw new UnsupportedOperationException(\"Leaf node doesn't support get operation\"); } @Override public boolean removeFile(File file) { throw new UnsupportedOperationException(\"Leaf node doesn't support remove operation\"); } } // Composite in the composite pattern class Directory extends File { private List\u0026lt;File\u0026gt; children = new ArrayList\u0026lt;\u0026gt;(); public Directory(String name) { super(name); } @Override public void ls() { System.out.println(getName()); children.forEach(File::ls); } @Override public void addFile(File file) { children.add(file); } @Override public File[] getFiles() { return children.toArray(new File[children.size()]); } @Override public boolean removeFile(File file) { return children.remove(file); } } // Client class that creates and displays directory structure public class Client { public static void main(String[] args) { File root1 = createTreeOne(); root1.ls(); System.out.println(\"***********************************\"); File root2 = createTreeTwo(); root2.ls(); } // Client builds tree using leaf and composites private static File createTreeOne() { File file1 = new BinaryFile(\"file1\", 1000); File file2 = new BinaryFile(\"file2\", 2000); Directory dir1 = new Directory(\"dir1\"); dir1.addFile(file1); dir1.addFile(file2); File file3 = new BinaryFile(\"file3\", 3000); Directory dir2 = new Directory(\"dir2\"); dir2.addFile(file3); dir2.addFile(dir1); return dir2; } private static File createTreeTwo() { return new BinaryFile(\"Another file\", 200); } } In the above code, the statements dir2.addFile(file3); and dir2.addFile(dir1); demonstrate how both individual objects (file3) and compositions of objects (file1 and file2) are treated in the same way.\n--- title: UML Diagram of Composite Design Pattern --- classDiagram class File { +String name +getName() +setName(String name) +ls() +addFile(File file) +getFiles() +removeFile(File file) } class BinaryFile { +long size +BinaryFile(String name, long size) +ls() +addFile(File file) +getFiles() +removeFile(File file) } class Directory { +List~File~ children +Directory(String name) +ls() +addFile(File file) +getFiles() +removeFile(File file) } File \u003c|-- BinaryFile File \u003c|-- Directory Directory *--\u003e File : contains 3.5 Facade The Facade Design Pattern is a structural design pattern that provides a simplified interface to a complex subsystem. It is often used when the client needs to interact with only a specific part of a large system, hiding its complexity and making it easier to use.\nSHOW CODE Java package dev.signalyu.facade; // Template class and related classes abstract class Template { public enum TemplateType {Email, NewsLetter} public abstract String format(Object obj); } class TemplateFactory { public static Template createTemplateFor(Template.TemplateType type) { switch (type) { case Email: return new OrderEmailTemplate(); default: throw new IllegalArgumentException(\"Unknown TemplateType\"); } } } class OrderEmailTemplate extends Template { @Override public String format(Object obj) { return \"TEMPLATE\"; } } // Stationary class and related classes interface Stationary { String getHeader(); String getFooter(); } class StationaryFactory { public static Stationary createStationary() { return new HalloweenStationary(); } } class HalloweenStationary implements Stationary { @Override public String getHeader() { return \"It's Halloween!!\"; } @Override public String getFooter() { return \"BUY MORE STUFF! It's Halloween, c'mon!!\"; } } // Email class and related classes class EmailBuilder { public EmailBuilder withTemplate(Template template) { return this; } public EmailBuilder withStationary(Stationary stationary) { return this; } public EmailBuilder forObject(Object object) { return this; } public Email build() { return new Email(); } public Email getEmail() { return new Email(); } } class Email { public static EmailBuilder getBuilder() { return new EmailBuilder(); } } // Mailer class class Mailer { private static final Mailer MAILER = new Mailer(); public static Mailer getMailer() { return MAILER; } private Mailer() { } public boolean send(Email email) { return true; } } // Order class for reference (assuming Order exists as a placeholder) class Order { private String id; private double total; public Order(String id, double total) { this.id = id; this.total = total; } public String getId() { return id; } public void setId(String id) { this.id = id; } public double getTotal() { return total; } public void setTotal(double total) { this.total = total; } } // Facade provides simple methods for the client to use class EmailFacade { public boolean sendOrderEmail(Order order) { Template template = TemplateFactory.createTemplateFor(Template.TemplateType.Email); Stationary stationary = StationaryFactory.createStationary(); Email email = Email.getBuilder() .withTemplate(template) .withStationary(stationary) .forObject(order) .build(); Mailer mailer = Mailer.getMailer(); return mailer.send(email); } } public class Client { public static void main(String[] args) { Order order = new Order(\"101\", 99.99); EmailFacade facade = new EmailFacade(); boolean result = facade.sendOrderEmail(order); System.out.println(\"Order Email \" + (result ? \"sent!\" : \"NOT sent...\")); } } --- title: UML Diagram of Facade Design Pattern --- classDiagram class EmailFacade { +sendOrderEmail(order: Order) bool } class Template { +format(obj: Object) String } class TemplateFactory { +createTemplateFor(type: TemplateType) Template } class OrderEmailTemplate { +format(obj: Object) String } class Stationary { +getHeader() String +getFooter() String } class StationaryFactory { +createStationary() Stationary } class HalloweenStationary { +getHeader() String +getFooter() String } class EmailBuilder { +withTemplate(template: Template) EmailBuilder +withStationary(stationary: Stationary) EmailBuilder +forObject(object: Object) EmailBuilder +build() Email } class Email { +getBuilder() EmailBuilder } class Mailer { +getMailer() Mailer +send(email: Email) bool } EmailFacade --\u003e TemplateFactory : uses EmailFacade --\u003e StationaryFactory : uses EmailFacade --\u003e Mailer : uses TemplateFactory --\u003e OrderEmailTemplate : creates StationaryFactory --\u003e HalloweenStationary : creates Email --\u003e EmailBuilder : has EmailBuilder --\u003e Template : uses EmailBuilder --\u003e Stationary : uses Mailer --\u003e Email : uses EmailBuilder --\u003e Email : creates OrderEmailTemplate --\u003e Template : inherits HalloweenStationary --\u003e Stationary : implements 3.6 Flyweight The Flyweight Design Pattern is a structural design pattern used to optimize memory usuage by sharing common data across multiple objects. In this pattern, an object is divided into two categories: intrinsic state and extrinsic state.\nIntrinsic state refers to the data that is shared and remains consistent across different instances. It is usually stored within the Flyweight object. Extrinsic state, on the other hand, refers to data that can vary between instances. This state is typically managed and provided by the client or the object using the Flyweight. SHOW CODE Java import java.time.Duration; import java.util.HashMap; import java.util.Map; // Interface implemented by Flyweights interface ErrorMessage { // Get error message String getText(String code); } // A concrete Flyweight. Instance is shared class SystemErrorMessage implements ErrorMessage { // some error message $errorCode private String messageTemplate; // http://somedomain.com/help?error= private String helpUrlBase; public SystemErrorMessage(String messageTemplate, String helpUrlBase) { this.messageTemplate = messageTemplate; this.helpUrlBase = helpUrlBase; } @Override public String getText(String code) { return messageTemplate.replace(\"$errorCode\", code) + helpUrlBase + code; } } // Unshared concrete flyweight. class UserBannedErrorMessage implements ErrorMessage { // All state is defined here private String caseId; private String remarks; private Duration banDuration; private String msg; public UserBannedErrorMessage(String caseId) { // Load case info from DB. this.caseId = caseId; remarks = \"You violated terms of use.\"; banDuration = Duration.ofDays(2); msg = \"You are BANNED. Sorry. \\nMore information:\\n\"; msg += caseId + \"\\n\"; msg += remarks + \"\\n\"; msg += \"Banned For:\" + banDuration.toHours() + \" Hours\"; } // We ignore the extrinsic state argument @Override public String getText(String code) { return msg; } public String getCaseNo() { return caseId; } } // Flyweight factory. Returns shared flyweight based on key class ErrorMessageFactory { // This serves as key for getting flyweight instance public enum ErrorType { GenericSystemError, PageNotFoundError, ServerError } private static final ErrorMessageFactory FACTORY = new ErrorMessageFactory(); public static ErrorMessageFactory getInstance() { return FACTORY; } private Map\u0026lt;ErrorType, SystemErrorMessage\u0026gt; errorMessages = new HashMap\u0026lt;\u0026gt;(); private ErrorMessageFactory() { errorMessages.put(ErrorType.GenericSystemError, new SystemErrorMessage(\"A genetic error of type $errorCode occurred. Please refer to:\\n\", \"https://google.com/q=\")); errorMessages.put(ErrorType.PageNotFoundError, new SystemErrorMessage(\"Page not found. An error of type $errorCode occurred. Please refer to:\\n\", \"https://google.com/q=\")); } public SystemErrorMessage getError(ErrorType type) { return errorMessages.get(type); } public UserBannedErrorMessage getUserBannedMessage(String caseId) { return new UserBannedErrorMessage(caseId); } } // Client public class Client { public static void main(String[] args) { // Accessing shared flyweight objects SystemErrorMessage msg1 = ErrorMessageFactory.getInstance().getError(ErrorMessageFactory.ErrorType.GenericSystemError); System.out.println(msg1.getText(\"4056\")); // Accessing unshared flyweight objects UserBannedErrorMessage msg2 = ErrorMessageFactory.getInstance().getUserBannedMessage(\"1202\"); System.out.println(msg2.getText(null)); } } SHOW OUTPUT Output A genetic error of type 4056 occurred. Please refer to: https://google.com/q=4056 You are BANNED. Sorry. More information: 1202 You violated terms of use. Banned For:48 Hours --- title: UML Diagram of Flyweight Design Pattern --- classDiagram class ErrorMessage { +getText(code: String): String } class SystemErrorMessage { -messageTemplate: String -helpUrlBase: String +getText(code: String): String } class UserBannedErrorMessage { -caseId: String -remarks: String -banDuration: Duration -msg: String +getText(code: String): String +getCaseNo(): String } class ErrorMessageFactory { -errorMessages: Map~ErrorType, SystemErrorMessage~ +getInstance(): ErrorMessageFactory +getError(type: ErrorType): SystemErrorMessage +getUserBannedMessage(caseId: String): UserBannedErrorMessage } class Client { +main(args: String[]): void } ErrorMessage \u003c|-- SystemErrorMessage ErrorMessage \u003c|-- UserBannedErrorMessage ErrorMessageFactory *--\u003e SystemErrorMessage ErrorMessageFactory *--\u003e UserBannedErrorMessage Client --\u003e ErrorMessageFactory 3.7 Proxy The Proxy Design Pattern is a structural design pattern that involves using a proxy object to represent another object. The proxy controls access to the real object and can add additional functionality, such aas lazy initialization, logging, or monitoring. This pattern can be primarily categorized into two types: Static Proxy and Dynamic Proxy.\nThe Static Proxy is created at compile time, where a separate proxy class is written to manage method calls to the real object. In contrast, the Dynamic Proxy is created at runtime, often using reflection techniques in languages like Java. A dynamic proxy delegates method calls to the real object without the need for manually creating a proxy class.\nSHOW CODE: Static Proxy Java // Point2D class to represent the location of the image class Point2D { private final float x; private final float y; public Point2D(float x, float y) { this.x = x; this.y = y; } @Override public String toString() { return \"Point2D [x=\" + x + \", y=\" + y + \"]\"; } } // Interface implemented by proxy and concrete objects interface Image { void setLocation(Point2D point2d); Point2D getLocation(); void render(); } // Concrete class providing actual functionality class BitmapImage implements Image { private Point2D location; private final String name; public BitmapImage(String filename) { // Loads image from file on disk System.out.println(\"Loaded from disk: \" + filename); name = filename; } @Override public void setLocation(Point2D point2d) { location = point2d; } @Override public Point2D getLocation() { return location; } @Override public void render() { // Renders to screen System.out.println(\"Rendered \" + this.name); } } // Proxy class class ImageProxy implements Image { private final String name; private BitmapImage image; private Point2D location; public ImageProxy(String name) { this.name = name; } @Override public void setLocation(Point2D point2d) { if (image != null) { image.setLocation(point2d); } else { location = point2d; } } @Override public Point2D getLocation() { if (image != null) { return image.getLocation(); } return location; } @Override public void render() { if (image == null) { image = new BitmapImage(name); if (location != null) { image.setLocation(location); } } image.render(); } } // Factory to get image objects class ImageFactory { // We'll provide proxy to caller instead of real object public static Image getImage(String name) { return new ImageProxy(name); } } // Client class to test the proxy pattern public class Client { public static void main(String[] args) { Image img = ImageFactory.getImage(\"A1.bmp\"); img.setLocation(new Point2D(10, 10)); System.out.println(\"Image location: \" + img.getLocation()); System.out.println(\"Rendering image now...\"); img.render(); } } SHOW OUTPUT Output Image location: Point2D [x=10.0, y=10.0] Rendering image now... Loaded from disk: A1.bmp Rendered A1.bmp --- title: UML Diagram of Static Proxy Design Pattern --- classDiagram class Image { + setLocation(Point2D point2d) + Point2D getLocation() + render() } class BitmapImage { - Point2D location - String name + BitmapImage(String filename) + setLocation(Point2D point2d) + getLocation(): Point2D + render() } class ImageProxy { - String name - BitmapImage image - Point2D location + ImageProxy(String name) + setLocation(Point2D point2d) + getLocation(): Point2D + render() } class ImageFactory { + getImage(String name): Image } class Client { + main(String[] args) } Image \u003c|.. BitmapImage : implements Image \u003c|.. ImageProxy : implements ImageFactory --|\u003e ImageProxy : creates Client --\u003e ImageFactory : uses ImageProxy \"1\" --\u003e \"0..1\" BitmapImage : contains SHOW CODE: Dynamic Proxy Java import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; // Point2D class to represent the location of the image class Point2D { private final float x; private final float y; public Point2D(float x, float y) { this.x = x; this.y = y; } @Override public String toString() { return \"Point2D [x=\" + x + \", y=\" + y + \"]\"; } } // Interface implemented by proxy and concrete objects interface Image { void setLocation(Point2D point2d); Point2D getLocation(); void render(); } // Concrete class providing actual functionality (BitmapImage) class BitmapImage implements Image { private Point2D location; private final String name; public BitmapImage(String filename) { // Loads image from file on disk System.out.println(\"Loaded from disk: \" + filename); name = filename; } @Override public void setLocation(Point2D point2d) { location = point2d; } @Override public Point2D getLocation() { return location; } @Override public void render() { // Renders to screen System.out.println(\"Rendered \" + this.name); } } // InvocationHandler to implement proxy behavior class ImageInvocationHandler implements InvocationHandler { private final String filename; private Point2D location; private BitmapImage image; private static final Method setLocationMethod; private static final Method getLocationMethod; private static final Method renderMethod; static { try { setLocationMethod = Image.class.getMethod(\"setLocation\", Point2D.class); getLocationMethod = Image.class.getMethod(\"getLocation\"); renderMethod = Image.class.getMethod(\"render\"); } catch (NoSuchMethodException e) { throw new NoSuchMethodError(e.getMessage()); } } public ImageInvocationHandler(String filename) { this.filename = filename; } @Override public Object invoke(Object proxy, Method method, Object[] args) { System.out.println(\"Invoking method: \" + method.getName()); if (method.equals(setLocationMethod)) { return handleSetLocation(args); } else if (method.equals(getLocationMethod)) { return handleGetLocation(); } else if (method.equals(renderMethod)) { return handleRender(); } return null; } private Object handleRender() { if (image == null) { image = new BitmapImage(filename); if (location != null) { image.setLocation(location); } } image.render(); return null; } private Point2D handleGetLocation() { if (image != null) { return image.getLocation(); } else { return this.location; } } private Object handleSetLocation(Object[] args) { if (image != null) { image.setLocation((Point2D) args[0]); } else { this.location = (Point2D) args[0]; } return null; } } // Factory to provide the proxy object class ImageFactory { public static Image getImage(String name) { return (Image) Proxy.newProxyInstance( ImageFactory.class.getClassLoader(), new Class[]{Image.class}, new ImageInvocationHandler(name) ); } } // Client class to test the proxy pattern public class Client { public static void main(String[] args) { Image img = ImageFactory.getImage(\"A.bmp\"); img.setLocation(new Point2D(-10, 0)); System.out.println(img.getLocation()); System.out.println(\"*****************************\"); img.render(); } } SHOW OUTPUT Output Invoking method: setLocation Invoking method: getLocation Point2D [x=-10.0, y=0.0] ***************************** Invoking method: render Loaded from disk: A.bmp Rendered A.bmp --- title: UML Diagram of Dynamic Proxy Design Pattern --- classDiagram class Image { +setLocation(Point2D point2d) +getLocation(): Point2D +render() } class BitmapImage { -Point2D location -String name +BitmapImage(String filename) +setLocation(Point2D point2d) +getLocation(): Point2D +render() } class ImageInvocationHandler { -String filename -Point2D location -BitmapImage image +ImageInvocationHandler(String filename) +invoke(Object proxy, Method method, Object[] args) -handleRender() -handleGetLocation(): Point2D -handleSetLocation(Object[] args) } class ImageFactory { +getImage(String name): Image } class Client { +main(String[] args) } Image \u003c|.. BitmapImage : implements Image \u003c|.. ImageInvocationHandler : delegates ImageFactory ..\u003e ImageInvocationHandler : creates Client ..\u003e ImageFactory : uses ImageInvocationHandler \"1\" -- \"1\" BitmapImage : image 4. Behavioral Design Patterns Behavioral Design Patterns focus on the communication and interaction between objects or components in a system.\n4.1 Chain of Responsibility The Chain of Responsibility Design Pattern is a behavioral design pattern that allows a request to be passed along a chain of handlers, where each handler either processes the request or passes it along to the next handler in the chain. The request will continue through the chain until it is handled by an appropriate handler or the end of the chain is reached.\nSHOW CODE Java import java.time.LocalDate; import java.time.Period; // Represents a request in our chain of responsibility class LeaveApplication { public enum Type {Sick, PTO, LOP} public enum Status {Pending, Approved, Rejected} private final Type type; private final LocalDate from; private final LocalDate to; private String processedBy; private Status status; public LeaveApplication(Type type, LocalDate from, LocalDate to) { this.type = type; this.from = from; this.to = to; this.status = Status.Pending; } public Type getType() { return type; } public LocalDate getFrom() { return from; } public LocalDate getTo() { return to; } public int getNoOfDays() { return Period.between(from, to).getDays(); } public String getProcessedBy() { return processedBy; } public Status getStatus() { return status; } public void approve(String approvalName) { this.status = Status.Approved; this.processedBy = approvalName; } public void reject(String approvalName) { this.status = Status.Rejected; this.processedBy = approvalName; } public static Builder getBuilder() { return new Builder(); } @Override public String toString() { return type + \" leave for \" + getNoOfDays() + \" day(s) \" + status + \" by \" + processedBy; } // Builder pattern for LeaveApplication public static class Builder { private Type type; private LocalDate from; private LocalDate to; private LeaveApplication application; private Builder() { } public Builder withType(Type type) { this.type = type; return this; } public Builder from(LocalDate from) { this.from = from; return this; } public Builder to(LocalDate to) { this.to = to; return this; } public LeaveApplication build() { this.application = new LeaveApplication(type, from, to); return this.application; } public LeaveApplication getApplication() { return application; } } } // This represents a handler in chain of responsibility interface LeaveApproval { void processLeaveApplication(LeaveApplication application); String getApprovalRole(); } // Abstract handler abstract class Employee implements LeaveApproval { private final String role; private final LeaveApproval successor; public Employee(String role, LeaveApproval successor) { this.role = role; this.successor = successor; } @Override public void processLeaveApplication(LeaveApplication application) { if (!processRequest(application) \u0026\u0026 successor != null) { successor.processLeaveApplication(application); } } protected abstract boolean processRequest(LeaveApplication application); @Override public String getApprovalRole() { return role; } } // A concrete handler: Manager class Manager extends Employee { public Manager(LeaveApproval nextApproval) { super(\"Manager\", nextApproval); } @Override protected boolean processRequest(LeaveApplication application) { switch (application.getType()) { case Sick: application.approve(getApprovalRole()); return true; case PTO: if (application.getNoOfDays() \u003c= 5) { application.approve(getApprovalRole()); return true; } } return false; } } // A concrete handler: ProjectLead class ProjectLead extends Employee { public ProjectLead(LeaveApproval successor) { super(\"Project Lead\", successor); } @Override protected boolean processRequest(LeaveApplication application) { if (application.getType() == LeaveApplication.Type.Sick) { if (application.getNoOfDays() \u003c= 2) { application.approve(getApprovalRole()); return true; } } return false; } } // A concrete handler: Director class Director extends Employee { public Director(LeaveApproval nextApproval) { super(\"Director\", nextApproval); } @Override protected boolean processRequest(LeaveApplication application) { if (application.getType() == LeaveApplication.Type.PTO) { application.approve(getApprovalRole()); return true; } return false; } } // Client class to test the Chain of Responsibility public class Client { public static void main(String[] args) { LeaveApplication application = LeaveApplication.getBuilder() .withType(LeaveApplication.Type.PTO) .from(LocalDate.now()) .to(LocalDate.of(2025, 1, 8)) .build(); System.out.println(application); System.out.println(\"**************************************************\"); LeaveApproval approval = createChain(); approval.processLeaveApplication(application); System.out.println(application); } private static LeaveApproval createChain() { Director director = new Director(null); Manager manager = new Manager(director); ProjectLead lead = new ProjectLead(manager); return lead; } } SHOW OUTPUT Output PTO leave for 8 day(s) Pending by null ************************************************** PTO leave for 8 day(s) Approved by Director --- title: UML Diagram of Chain of Responsibility Design Pattern --- classDiagram class LeaveApproval { +void processLeaveApplication(LeaveApplication) +String getApprovalRole() } class Employee { +String role +LeaveApproval successor +Employee(String, LeaveApproval) +void processLeaveApplication(LeaveApplication) +String getApprovalRole() +protected abstract boolean processRequest(LeaveApplication) } class Manager { +Manager(LeaveApproval) +boolean processRequest(LeaveApplication) } class ProjectLead { +ProjectLead(LeaveApproval) +boolean processRequest(LeaveApplication) } class Director { +Director(LeaveApproval) +boolean processRequest(LeaveApplication) } LeaveApproval \u003c|-- Employee : implements Employee \u003c|-- Manager : extends Employee \u003c|-- ProjectLead : extends Employee \u003c|-- Director : extends Employee *--|\u003e LeaveApproval 4.2 Command The Command Design Pattern is a behavioral design pattern that turns a request into a stand-alone object, allowing the decoupling of the sender of the request from the object that processes the request.\nSHOW CODE Java import java.util.LinkedList; import java.util.List; // Command interface implemented by all concrete command classes interface Command { void execute(); } // Concrete implementation of Command class AddMemberCommand implements Command { private String emailAddress; private String listName; private EWSService receiver; public AddMemberCommand(String email, String listName, EWSService service) { this.emailAddress = email; this.listName = listName; this.receiver = service; } @Override public void execute() { receiver.addMember(emailAddress, listName); } } // Receiver class that performs the actual action class EWSService { // Add a new member to mailing list public void addMember(String contact, String contactGroup) { System.out.println(\"Added \" + contact + \" to \" + contactGroup); } // Remove member from mailing list public void removeMember(String contact, String contactGroup) { System.out.println(\"Removed \" + contact + \" from \" + contactGroup); } } // Invoker class that executes commands on a separate thread class MailTasksRunner implements Runnable { private Thread runner; private List\u0026lt;Command\u0026gt; pendingCommands; private volatile boolean stop; private static final MailTasksRunner RUNNER = new MailTasksRunner(); public static final MailTasksRunner getInstance() { return RUNNER; } private MailTasksRunner() { pendingCommands = new LinkedList\u0026lt;\u0026gt;(); runner = new Thread(this); runner.start(); } // Run method that takes pending commands and executes them @Override public void run() { while (true) { Command cmd = null; synchronized (pendingCommands) { if (pendingCommands.isEmpty()) { try { pendingCommands.wait(); } catch (InterruptedException e) { System.out.println(\"Runner interrupted\"); if (stop) { System.out.println(\"Runner stopping\"); return; } } } cmd = pendingCommands.isEmpty() ? null : pendingCommands.remove(0); } if (cmd == null) { return; } cmd.execute(); } } // Adds a command to the pending commands list for later execution public void addCommand(Command cmd) { synchronized (pendingCommands) { pendingCommands.add(cmd); pendingCommands.notifyAll(); } } // Stops the runner thread public void shutdown() { this.stop = true; this.runner.interrupt(); } } // Client class that demonstrates how the Command pattern works public class Client { public static void main(String[] args) throws InterruptedException { EWSService service = new EWSService(); // Create commands and add them to the runner for execution Command c1 = new AddMemberCommand(\"a@a.com\", \"spam\", service); MailTasksRunner.getInstance().addCommand(c1); Command c2 = new AddMemberCommand(\"b@b\", \"spam\", service); MailTasksRunner.getInstance().addCommand(c2); // Wait for a while to let commands execute Thread.sleep(3000); // Shutdown the runner MailTasksRunner.getInstance().shutdown(); } } --- title: UML Diagram of Command Design Pattern --- classDiagram class Command { +execute() } class AddMemberCommand { -String emailAddress -String listName -EWSService receiver +AddMemberCommand(email: String, listName: String, service: EWSService) +execute() } class EWSService { +addMember(contact: String, contactGroup: String) +removeMember(contact: String, contactGroup: String) } class MailTasksRunner { -Thread runner -List~Command~ pendingCommands -volatile boolean stop -static final MailTasksRunner RUNNER +getInstance(): MailTasksRunner +addCommand(cmd: Command) +shutdown() +run() } class Client { +main(args: String[]) } Command \u003c|-- AddMemberCommand AddMemberCommand --\u003e EWSService : uses MailTasksRunner --\u003e Command : invokes Client --\u003e MailTasksRunner : uses 4.3 Interpreter The Interpreter Design Pattern is a behavioral design pattern used to define a grammatical representation for a language and provide an interpreter to evaluate sentences in that language. It is commonly used to interpret expressions in a simple language or grammar.\nSHOW CODE Java import java.util.ArrayList; import java.util.List; import java.util.Stack; import java.util.StringTokenizer; import java.util.stream.Stream; // User class class User { private List\u0026lt;String\u0026gt; permissions; private String username; public User(String username, String... permissions) { this.username = username; this.permissions = new ArrayList\u0026lt;\u0026gt;(); Stream.of(permissions).forEach(e -\u003e this.permissions.add(e.toLowerCase())); } public List\u0026lt;String\u0026gt; getPermissions() { return permissions; } public String getUsername() { return username; } } // Abstract expression interface PermissionExpression { boolean interpret(User user); } // Terminal expression class Permission implements PermissionExpression { private String permission; public Permission(String permission) { this.permission = permission.toLowerCase(); } @Override public boolean interpret(User user) { return user.getPermissions().contains(permission); } @Override public String toString() { return permission; } } // Non-terminal expression class AndExpression implements PermissionExpression { private PermissionExpression expression1; private PermissionExpression expression2; public AndExpression(PermissionExpression expression1, PermissionExpression expression2) { this.expression1 = expression1; this.expression2 = expression2; } @Override public boolean interpret(User user) { return expression1.interpret(user) \u0026\u0026 expression2.interpret(user); } @Override public String toString() { return expression1 + \" AND \" + expression2; } } // Non-terminal expression class OrExpression implements PermissionExpression { private PermissionExpression expression1; private PermissionExpression expression2; public OrExpression(PermissionExpression one, PermissionExpression two) { this.expression1 = one; this.expression2 = two; } @Override public boolean interpret(User user) { return expression1.interpret(user) || expression2.interpret(user); } @Override public String toString() { return expression1 + \" OR \" + expression2; } } // Non-terminal expression class NotExpression implements PermissionExpression { private PermissionExpression expression; public NotExpression(PermissionExpression expression) { this.expression = expression; } @Override public boolean interpret(User user) { return !expression.interpret(user); } @Override public String toString() { return \"NOT \" + expression; } } // Report class class Report { private String name; private String permission; public Report(String name, String permissions) { this.name = name; this.permission = permissions; } public String getName() { return name; } public String getPermission() { return permission; } } // Parses \u0026 builds abstract syntax tree class ExpressionBuilder { private Stack\u0026lt;PermissionExpression\u0026gt; permissions = new Stack\u0026lt;\u0026gt;(); private Stack\u0026lt;String\u0026gt; operators = new Stack\u0026lt;\u0026gt;(); public PermissionExpression build(Report report) { parse(report.getPermission()); buildExpressions(); if (permissions.size() \u003e 1 || !operators.isEmpty()) { System.out.println(\"ERROR!\"); } return permissions.pop(); } private void parse(String permission) { StringTokenizer tokenizer = new StringTokenizer(permission.toLowerCase()); while (tokenizer.hasMoreTokens()) { String token = tokenizer.nextToken(); switch (token) { case \"and\": operators.push(\"and\"); break; case \"not\": operators.push(\"not\"); break; case \"or\": operators.push(\"or\"); break; default: permissions.push(new Permission(token)); break; } } } private void buildExpressions() { while (!operators.isEmpty()) { String operator = operators.pop(); PermissionExpression perm1; PermissionExpression perm2; PermissionExpression exp; switch (operator) { case \"not\": perm1 = permissions.pop(); exp = new NotExpression(perm1); break; case \"and\": perm1 = permissions.pop(); perm2 = permissions.pop(); exp = new AndExpression(perm1, perm2); break; case \"or\": perm1 = permissions.pop(); perm2 = permissions.pop(); exp = new OrExpression(perm1, perm2); break; default: throw new IllegalArgumentException(\"Unknown operator:\" + operator); } permissions.push(exp); } } } // Client class public class Client { public static void main(String[] args) { Report report1 = new Report(\"Cash flow report\", \"FINANCE_ADMIN OR ADMIN\"); ExpressionBuilder builder = new ExpressionBuilder(); PermissionExpression exp = builder.build(report1); System.out.println(exp); User user1 = new User(\"Dave\", \"USER\"); System.out.println(\"User access report: \" + exp.interpret(user1)); } } --- title: UML Diagram of Interpreter Design Pattern --- classDiagram class PermissionExpression { + interpret(User user): boolean } class Permission { - String permission + Permission(String permission) + interpret(User user): boolean + toString(): String } class AndExpression { - PermissionExpression expression1 - PermissionExpression expression2 + AndExpression(PermissionExpression expression1, PermissionExpression expression2) + interpret(User user): boolean + toString(): String } class OrExpression { - PermissionExpression expression1 - PermissionExpression expression2 + OrExpression(PermissionExpression expression1, PermissionExpression expression2) + interpret(User user): boolean + toString(): String } class NotExpression { - PermissionExpression expression + NotExpression(PermissionExpression expression) + interpret(User user): boolean + toString(): String } class ExpressionBuilder { - Stack~PermissionExpression~ permissions - Stack~String~ operators + build(Report report): PermissionExpression - parse(String permission) - buildExpressions() } class Client { + main(String[] args) } Permission --|\u003e PermissionExpression AndExpression --|\u003e PermissionExpression OrExpression --|\u003e PermissionExpression NotExpression --|\u003e PermissionExpression ExpressionBuilder --\u003e PermissionExpression Client --\u003e ExpressionBuilder 4.4 Mediator 4.5 Iterator 4.6 Momento 4.7 Observer 4.8 State 4.9 Strategy The Strategry Design Pattern is a behavioral design pattern that encapsulates a set of algorithms and allows a client to dynamically choose one at runtime based on the context. This pattern separates the algorithm from the existing code, enabling the addition of new algorithms without modifying the existing code.\nSHOW CODE Java import java.time.LocalDate; import java.util.Collection; import java.util.HashMap; import java.util.Iterator; import java.util.LinkedList; import java.util.Map; // Order class class Order { private final String id; private final LocalDate date; private final Map\u0026lt;String, Double\u0026gt; items = new HashMap\u0026lt;\u0026gt;(); private double total; public Order(String id) { this.id = id; this.date = LocalDate.now(); } public String getId() { return id; } public LocalDate getDate() { return date; } public Map\u0026lt;String, Double\u0026gt; getItems() { return items; } public void addItem(String name, double price) { items.put(name, price); total += price; } public double getTotal() { return total; } public void setTotal(double total) { this.total = total; } } // Strategy Interface interface OrderPrinter { void print(Collection\u0026lt;Order\u0026gt; orders); } // Concrete Strategy 1: Summary Printer class SummaryPrinter implements OrderPrinter { @Override public void print(Collection\u0026lt;Order\u0026gt; orders) { System.out.println(\"*************** Summary Report *************\"); Iterator\u0026lt;Order\u0026gt; iterator = orders.iterator(); double total = 0; for (int i = 1; iterator.hasNext(); i++) { Order order = iterator.next(); System.out.println(i + \". \" + order.getId() + \"\\t\" + order.getDate() + \"\\t\" + order.getItems().size() + \"\\t\" + order.getTotal()); total += order.getTotal(); } System.out.println(\"*******************************************\"); System.out.println(\"\\t\\t\\t\\t Total \" + total); } } // Concrete Strategy 2: Detail Printer class DetailPrinter implements OrderPrinter { @Override public void print(Collection\u0026lt;Order\u0026gt; orders) { System.out.println(\"************* Detail Report ***********\"); Iterator\u0026lt;Order\u0026gt; iter = orders.iterator(); double total = 0; for (int i = 1; iter.hasNext(); i++) { double orderTotal = 0; Order order = iter.next(); System.out.println(i + \". \" + order.getId() + \"\\t\" + order.getDate()); for (Map.Entry\u0026lt;String, Double\u0026gt; entry : order.getItems().entrySet()) { System.out.println(\"\\t\\t\" + entry.getKey() + \"\\t\" + entry.getValue()); orderTotal += entry.getValue(); } System.out.println(\"----------------------------------------\"); System.out.println(\"\\t\\t Total \" + orderTotal); System.out.println(\"----------------------------------------\"); total += orderTotal; } System.out.println(\"----------------------------------------\"); System.out.println(\"\\tGrand Total \" + total); } } // PrintService class for context class PrintService { private final OrderPrinter printer; public PrintService(OrderPrinter printer) { this.printer = printer; } public void printOrders(Collection\u0026lt;Order\u0026gt; orders) { printer.print(orders); } } // Client class to simulate the creation of orders and print them public class Main { private static final LinkedList\u0026lt;Order\u0026gt; orders = new LinkedList\u0026lt;\u0026gt;(); public static void main(String[] args) { createOrders(); // Print all orders using DetailPrinter strategy PrintService service1 = new PrintService(new DetailPrinter()); service1.printOrders(orders); System.out.println(\"\\n\"); // Print all orders using DetailPrinter strategy PrintService service2 = new PrintService(new SummaryPrinter()); service2.printOrders(orders); } private static void createOrders() { Order o = new Order(\"100\"); o.addItem(\"Soda\", 2); o.addItem(\"Chips\", 10); orders.add(o); o = new Order(\"200\"); o.addItem(\"Cake\", 20); o.addItem(\"Cookies\", 5); orders.add(o); o = new Order(\"300\"); o.addItem(\"Burger\", 8); o.addItem(\"Fries\", 5); orders.add(o); } } SHOW OUTPUT Output ************* Detail Report *********** 1. 100\t2024-12-07 Chips\t10.0 Soda\t2.0 ---------------------------------------- Total 12.0 ---------------------------------------- 2. 200\t2024-12-07 Cookies\t5.0 Cake\t20.0 ---------------------------------------- Total 25.0 ---------------------------------------- 3. 300\t2024-12-07 Burger\t8.0 Fries\t5.0 ---------------------------------------- Total 13.0 ---------------------------------------- ---------------------------------------- Grand Total 50.0 *************** Summary Report ************* 1. 100\t2024-12-07\t2\t12.0 2. 200\t2024-12-07\t2\t25.0 3. 300\t2024-12-07\t2\t13.0 ******************************************* Total 50.0 --- title: UML Diagram of Strategy Design Pattern --- classDiagram class Order { +String id +LocalDate date +Map~String, Double~ items +double total +Order(String id) +String getId() +LocalDate getDate() +Map~String, Double~ getItems() +void addItem(String name, double price) +double getTotal() +void setTotal(double total) } class OrderPrinter { +void print(Collection~Order~ orders) } class SummaryPrinter { +void print(Collection~Order~ orders) } class DetailPrinter { +void print(Collection~Order~ orders) } class PrintService { +OrderPrinter printer +PrintService(OrderPrinter printer) +void printOrders(Collection~Order~ orders) } OrderPrinter \u003c|-- SummaryPrinter OrderPrinter \u003c|-- DetailPrinter PrintService *--\u003e OrderPrinter PrintService --\u003e Order 4.10 Template Method 4.11 Visitor 4.12 Null Object ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/design-patterns/1-design-patterns/","summary":"1. Solid Principle 1.1 Single Responsibility Principle A class should have only one reason to change, meaning each class should focus on a single functionality or responsibility.\nSHOW CODE Single Responsibility Principle import java.io.IOException; import java.util.*; import java.util.regex.*; import com.fasterxml.jackson.databind.ObjectMapper; /** * 1. User class is only used to represent entity. * 2. UserValidator class is solely responsible for validating user objects. * 3. Store class is only used to manage user objects storage.","title":"Design Patterns"},{"content":"Simple Two Pointers The Simple Two Pointers technique is commonly used to solve problems involving sorted array, where a set of elements needs to be found that satisfy certain constrains. This approach is efficient in scenarios such as finding a pair that sums to a target or reversing an array or string. In the two simple two pointers technique, two pointers \u0026ndash; typically labeled \u0026ldquo;left\u0026rdquo; and \u0026ldquo;right\u0026rdquo; \u0026ndash; are initialized and move in a specific direction based on the problem\u0026rsquo;s requirements.\nTwo Sum II - Input Array Is Sorted SHOW PROBLEM Problem Statement\nGiven a 1-indexed array of integers, numbers, sorted in non-decreasing order, find two numbers that add up to a specific target. Let these two numbers be numbers[index1] and numbers[index2], where 1 \u0026lt;= index1 \u0026lt; index2 \u0026lt;= numbers.length.\nReturn the indices of the two numbers, index1 and index2, incremented by one, as an integer array [index1, index2] of length 2.\nThe problem guarantees that there is exactly one solution. You may not use the same element twice. Your solution must use only constant extra space. Example 1:\nInput: numbers = [2,7,11,15], target = 9 Output: [1, 2] Explanation: The sum of 2 and 7 is 9, so index1 = 1, index2 = 2. We return [1, 2]. Example 2:\nInput: numbers = [2,3,4], target = 6 Output: [1, 3] Explanation: The sum of 2 and 4 is 6, so index1 = 1, index2 = 3. We return [1, 3]. Example 3:\nInput: numbers = [-1,0], target = -1 Output: [1, 2] Explanation: The sum of -1 and 0 is -1, so index1 = 1, index2 = 2. We return [1, 2]. Constraints:\n2 \u0026lt;= numbers.length \u0026lt;= 30,000 -1000 \u0026lt;= numbers[i] \u0026lt;= 1000 numbers is sorted in non-decreasing order. -1000 \u0026lt;= target \u0026lt;= 1000 There is exactly one solution for each test case. Go to Leetcode 🔗 SHOW CODE Java class Solution { public int[] twoSum(int[] numbers, int target) { int left = 0, right = numbers.length - 1; // Iterate while left pointer is before right pointer while (left \u003c right) { int currentSum = numbers[left] + numbers[right]; // Check if the current sum matches the target if (currentSum == target) { break; } // Adjust the pointers to move towards the target sum if (currentSum \u003c target) { left++; // Increase sum by moving left pointer right } else { right--; // Decrease sum by moving right pointer left } } // Reture 1-indexed result return new int[] { left + 1, right + 1 }; } } SHOW NOTES Algorithm Walkthrough\nnums = [1, 2, 3, 4, 5, 8] target = 7 Initialize pointers: left = 0, right = 5 First iteration: currentSum = 1 + 8 = 9 (greater than the target) Decrease the right pointer to 4 Second iteration: currentSum = 1 + 5 = 6 (less than the target) Increase the left pointer to 1 Third iteration: currentSum = 2 + 4 = 6 (equals the target) Return the indices [1, 3]. Visualization\n3Sum SHOW PROBLEM Problem Statement\nGiven an integer array nums, return all unique triplets [nums[i], nums[j], nums[k]] such that:\ni != j, i != k, and j != k nums[i] + nums[j] + nums[k] == 0 The solution set must not contain duplicate triplets.\nExample 1:\nInput: nums = [-1, 0, 1, 2, -1, -4] Output: [[-1, -1, 2], [-1, 0, 1]] Explanation: nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 The distinct triplets are [-1, 0, 1] and [-1, -1, 2].\nNote: The order of the output and the order of the triplets does not matter.\nExample 2:\nInput: nums = [0, 1, 1] Output: [] Explanation: The only possible triplet does not sum up to 0. Example 3:\nInput: nums = [0, 0, 0] Output: [[0, 0, 0]] Explanation: The only possible triplet sums up to 0. Constraints:\n3 \u0026lt;= nums.length \u0026lt;= 3000 10^5 \u0026lt;= nums[i] \u0026lt;= 10^5 Go to Leetcode 🔗 SHOW CODE Java class Solution { public List threeSum(int[] nums) { List triplets = new ArrayList\u0026lt;\u0026gt;(); // Sort the array to enable the two-pointer approach Arrays.sort(nums); for (int i = 0; i \u003c nums.length - 2; i++) { // Skip duplicates for 'i' to ensure unique triplets if (i \u003e 0 \u0026\u0026 nums[i] == nums[i - 1]) { continue; } // Find pairs that sum up to the negative of the current number findTwoSum(nums, -nums[i], i + 1, nums.length - 1, triplets); } return triplets; } private static void findTwoSum(int[] nums, int target, int left, int right, List triplets) { while (left \u003c right) { int currentSum = nums[left] + nums[right]; if (target == currentSum) { triplets.add(Arrays.asList(-target, nums[left], nums[right])); left++; right--; // Skip duplicates for 'left' and 'right' to avoid duplicate triplets while (left \u003c right \u0026\u0026 nums[left] == nums[left - 1]) { left++; } while (left \u003c right \u0026\u0026 nums[right] == nums[right + 1]) { right--; } } else if (currentSum \u003c target) { // Move 'left' pointer to the right to increase the sum left++; } else { // Move 'right' pointer to the left to decrease the sum right--; } } } } SHOW NOTES Algorithm Walkthrough:\nInitialization: [2, -1, -2, 3, -5] Sort the Array: Input: [2, -1, -2, 3, -5] Sorted: [-5, -2, -1, 2, 3] Iteration: Iteration 1: Fix -5 (at index 0), left pointer at -2 (index 1), right pointer at 3 (index 4): Target Sum: -(-5) = 5 Sum = -2 + 3 = 1 (less than targetSum), move left pointer to -1 (index 2) Sum = -1 + 3 = 2 (less than targetSum), move left pointer to 2 (index 3) Sum = 2 + 3 = 5, found triplet [-5, 2, 3] Move left pointer to 4 and right pointer to 3 (end of this iteration). Iteration 2: Fix -2 (at index 1), left pointer at -1 (index 2), right pointer at 3 (index 4): Target Sum: -(-2) = 2 Sum = -1 + 3 = 2, found triplet [-2, -1, 3] Move left pointer to 2 and right pointer to 3 (end of this iteration). Iteration 3: Fix -1 (at index 2), left pointer at 2 (index 3), right pointer at 3 (index 4): Target Sum: -(-1) = 1 Sum = 2 + 3 = 5 (greater than targetSum), move right pointer to 2 (end of this iteration). End of Loop: All elements are processed. Result: [[ -5, 2, 3], [ -2, -1, 3]] Visulization:\nFast \u0026amp; Slow Pointers The Fast and Slow Pointers pattern, also known as the Tortoise and Hare Algorithm, invloves using two pointers that move at different speeds over an array or linked list. It is commonly used to solve problems related to cycle detection or finding the middle element in linked lists or arrays.\nLinked List Cycle SHOW PROBLEM Problem Statement\nGiven the head of a singly linked list, write a function to determine whether the list contains a cycle.\nConstraints:\nThe number of nodes in the list is between 0 and 10,000. Node values are in the range of [-10^5, 10^5]. Go to Leetcode 🔗 SHOW CODE Java /** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public boolean hasCycle(ListNode head) { // Initialize slow and fast pointers at the head of the list ListNode slow = head, fast = head; // Traverse the list with fast and slow pointers while (fast != null \u0026\u0026 fast.next != null) { // Move slow pointer by one step and fast pointer by two steps slow = slow.next; fast = fast.next.next; // If the two pointers meet, a cycle is detected if (slow == fast) { return true; } } // If fast pointer reaches the end, there's no cycle return false; } } SHOW NOTES The fast and slow pointers start from the same point. The fast pointer moves two steps at a time, while the slow pointer moves one step at a time. If the linked list has no cycle, the fast pointer will reach the end before the slow pointer. If the linked list has a cycle, the fast pointer will enter the cycle first, and both pointers will continue moving in the cycle. Eventually, they will meet at some point, indicating the presence of a cycle. There are two possible scenerios when both pointers are in the cycle:\nThe fast pointer is one step behind the slow pointer. The fast pointer is two steps behind the slow pointer. In scenerio 1, after the next move, the two pointers will meet at the same position. This is the condition that confirms the presence of a cycle, as shown in the following illustration.\nMiddle of the LinkedList SHOW PROBLEM Problem Statement\nGiven the head of a singly linked list, write a method to return the middle node of the linked list.\nIf the total number of nodes in the list is even, return the second middle node.\nExample 1:\nInput: 1 → 2 → 3 → 4 → 5 → null Output: 3 Example 2:\nInput: 1 → 2 → 3 → 4 → 5 → 6 → null Output: 4 Example 3:\nInput: 1 → 2 → 3 → 4 → 5 → 6 → 7 → null Output: 4 Constraints:\nThe number of nodes in the list is between 1 and 100. Node values are between 1 and 100. Go to Leetcode 🔗 SHOW CODE Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode middleNode(ListNode head) { // Initialize slow and fast pointers at the head of the list ListNode slow = head, fast = head; while (fast != null \u0026\u0026 fast.next != null) { slow = slow.next; // Move slow pointer by one step fast = fast.next.next; // Move fast pointer by two steps } // When fast pointer reaches the end, slow pointer will be at the middle return slow; } } SHOW NOTES If the total number of nodes in the list is even, and return the first middle node is required, then\nwhile (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; // Move fast pointer by two steps if (fast != null) { break; } slow = slow.next; // Move slow pointer by one step } Remove Nth Node From End of List SHOW PROBLEM Problem Statement\nGiven the head of a singly linked list, remove the nth node from the end of the list and return the head of the updated list.\nExample 1:\nInput: head = [1, 2, 3, 4, 5], n = 2 Output: [1, 2, 3, 5] Example 2:\nInput: head = [1], n = 1 Output: [] Example 3:\nInput: head = [1, 2], n = 1 Output: [1] Constraints:\nThe number of nodes in the list is between 1 and 10^5. 1 \u0026lt;= n \u0026lt;= the number of nodes in the list. Go to Leetcode 🔗 SHOW CODE Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { // Create a dummy node to handle edge cases (e.g., removing the head) ListNode dummy = new ListNode(0); dummy.next = head; // Initialize slow and fast pointers at the dummy node ListNode slow = dummy, fast = dummy; // Move the fast pointer n+1 steps ahead from the dummy node for (int i = 0; i \u003c= n; i++) { fast = fast.next; } // Move both slow and fast pointers one step at a time until fast reaches the // end while (fast != null) { slow = slow.next; fast = fast.next; } // Remove the nth node from the end by skipping it slow.next = slow.next.next; // Return the updated head return dummy.next; } } SHOW NOTES The goal is to remove the nth node from the end of the list. The first step in solving this problem is to determine the position of the nth node from the end. This can be achieved using the slow and fast pointers techique. Initially, two pointer, slow and fast, are both set to the head of the list. The fast pointer is then moved n steps ahead from the head node.\nOnce the fast pointer is n steps ahead, both the slow and fast pointers move one step at a time simultaneously. When the fast pointer reaches the end of the list, the slow pointer will be positioned at the nth node from the end. Since the task is to remove this node, the node before it must be idetified.\nHowever, handling the edge case where the node to be removed is the head node requires special attention. To address this issue, a dummy node is introduced. The dummy node points to the head of the list, ensuring that there is always a valid node before the one to be deleted, even if the head node itself is the target.\nTo find the node just before the nth node from the end, the fast pointer is moved n+1 steps ahead from the dummy node. This places the fast pointer n+1 steps ahead of the slow pointer. Both pointers are then moved one step at a time until the fast pointer reaches the end of the list. At this point, the slow pointer will be positioned just before the nth node from the end.\nThe removal of the nth node is accomplished by updating the slow pointer\u0026rsquo;s next reference slow.next = slow.next.next;. When the node to be removed is the head, the slow pointer remains at the dummy node without moving. After executing slow.next = slow.next.next;, the node after the dummy node becomes the new head of the list.\nIllustration\nIllustration: Remove Head Node\nSliding Window The Sliding Window Pattern is a technique used to solve problems involving arrays or sequences when computing something over a continguous subarray or subsequence is required. There are two types of sliding window: fixed-size and dynamic. The fixed-size window involves calculating something over a contiguous subarray of a given size, while the dynamic window adjusts its size based on specific constraints to handle problems over a contiguous subarray or subsequence. The key to solving sliding window problems is determining when to shrink the window size.\nMaximum Sum Subarray of Size K SHOW PROBLEM Problem Statement\nGiven an array of positive numbers and a positive integer k, find the maximum sum of any contiguous subarray of size k.\nExample 1:\nInput:\narr = [2, 1, 5, 1, 3, 2], k = 3\nOutput:\n9\nExplanation:\nThe subarray with the maximum sum is [5, 1, 3], which has a sum of 9.\nExample 2:\nInput:\narr = [2, 3, 4, 1, 5], k = 2\nOutput:\n7\nExplanation:\nThe subarray with the maximum sum is [3, 4], which has a sum of 7.\nSHOW CODE Java public class Solution { public int findMaxSumSubArray(int k, int[] arr) { int windowStart = 0; int windowSum = 0, maxSum = Integer.MIN_VALUE; for (int windowEnd = 0; windowEnd \u003c arr.length; windowEnd++) { windowSum += arr[windowEnd]; // Update the window sum // Iterate the array to expand the window if (windowEnd \u003e= k - 1) { maxSum = Math.max(windowSum, maxSum); // Update the maximum sum windowSum -= arr[windowStart]; // Remove the element going out of the window windowStart++; // Shink the window } } return maxSum; } public static void main(String[] args) { Solution sol = new Solution(); System.out.println(\"Maximum sum of a subarray of size K: \" + sol.findMaxSumSubArray(3, new int[]{2, 1, 5, 1, 3, 2})); System.out.println(\"Maximum sum of a subarray of size K: \" + sol.findMaxSumSubArray(2, new int[]{2, 3, 4, 1, 5})); } } SHOW OUTPUT Output Maximum sum of a subarray of size K: 9 Maximum sum of a subarray of size K: 7 SHOW NOTES Algorithm Walkthrough\narr = [2, 1, 5, 1, 3, 2] k = 3 Initialization: windowSum = 0 maxSum = 0 windowStart = 0 Iteration: windowEnd = 0: Add arr[0] (2) to windowSum: windowSum = 2 windowEnd = 1: Add arr[1] (1) to windowSum: windowSum = 3 windowEnd = 2: Add arr[2] (5) to windowSum: windowSum = 8 Since windowEnd \u0026gt;= k - 1: Update maxSum = Math.max(0, 8) = 8 Subtract arr[0] = 2 from windowSum: windowSum = 6 Increment windowStart: windowStart = 1 windowEnd = 3: Add arr[3] (1) to windowSum: windowSum = 7 Since windowEnd \u0026gt;= k - 1: Update maxSum = Math.max(8, 7) = 8 Subtract arr[1] = 1 from windowSum: windowSum = 6 Increment windowStart: windowStart = 2 windowEnd = 4: Add arr[4] (3) to windowSum: windowSum = 9 Since windowEnd \u0026gt;= k - 1: Update maxSum = Math.max(8, 9) = 9 Subtract arr[2] = 5 from windowSum: windowSum = 4 Increment windowStart: windowStart = 3 windowEnd = 5: Add arr[5] (2) to windowSum: windowSum = 6 Since windowEnd \u0026gt;= k - 1: Update maxSum = Math.max(9, 6) = 9 Subtract arr[3] = 1 from windowSum: windowSum = 5 Increment windowStart: windowStart = 4 Result: The final maxSum is 9, which is the maximum sum of any subarray of size k = 3. Visualization\nLongest Substring with At Most K Distinct Characters SHOW PROBLEM Problem Statement\nGiven a string, find the length of the longest substring that contains no more than K distinct characters.\nIt is guaranteed that K will be less than or equal to the length of the given string.\nExample 1:\nInput: String = \u0026quot;araaci\u0026quot;, K = 2 Output: 4 Explanation: The longest substring with no more than 2 distinct characters is \u0026quot;araa\u0026quot;. Example 2:\nInput: String = \u0026quot;araaci\u0026quot;, K = 1 Output: 2 Explanation: The longest substring with no more than 1 distinct character is \u0026quot;aa\u0026quot;. Example 3:\nInput: String = \u0026quot;cbbebi\u0026quot;, K = 3 Output: 5 Explanation: The longest substrings with no more than 3 distinct characters are \u0026quot;cbbeb\u0026quot; and \u0026quot;bbebi\u0026quot;. Constraints:\n1 \u0026lt;= str.length \u0026lt;= 50,000 0 \u0026lt;= K \u0026lt;= 50 SHOW CODE Java import java.util.HashMap; import java.util.Map; class Solution { public int findLength(String str, int k) { Map\u0026lt;Character, Integer\u0026gt; charFrequencyMap = new HashMap\u0026lt;\u0026gt;(); int windowStart = 0; int maxLength = 0; // Iterate the char sequence to expand the window for (int windowEnd = 0; windowEnd \u003c str.length(); windowEnd++) { char endChar = str.charAt(windowEnd); charFrequencyMap.put(endChar, charFrequencyMap.getOrDefault(endChar, 0) + 1); // Shrink the window if there are more than 'k' distinct characters while (charFrequencyMap.size() \u003e k) { char startChar = str.charAt(windowStart); charFrequencyMap.put(startChar, charFrequencyMap.get(startChar) - 1); if (charFrequencyMap.get(startChar) == 0) { charFrequencyMap.remove(startChar); } windowStart++; // Shrink the window } // Update the maximum length of the valid substring found maxLength = Math.max(maxLength, windowEnd - windowStart + 1); } return maxLength; } public static void main(String[] args) { Solution sol = new Solution(); System.out.println(\"Length of the longest substring: \" + sol.findLength(\"araaci\", 2)); System.out.println(\"Length of the longest substring: \" + sol.findLength(\"araaci\", 1)); System.out.println(\"Length of the longest substring: \" + sol.findLength(\"cbbebi\", 3)); } } SHOW NOTES Algorithm Walkthrough:\nstr = \u0026quot;araaci\u0026quot; K = 2 Initialize: windowStart = 0, windowEnd = 0 Iteration: windowEnd = 0 Add 'a' to the hash map: {'a': 1} Maximum length = 1 windowEnd = 1 Add 'r' to the hash map: {'a': 1, 'r': 1} Maximum length = 2 windowEnd = 2 Add 'a' to the hash map: {'a': 2, 'r': 1} Maximum length = 3 windowEnd = 3 Add 'a' to the hash map: {'a': 3, 'r': 1} Maximum length = 4 windowEnd = 4 Add 'c' to the hash map: {'a': 3, 'r': 1, 'c': 1} Since the hash map has more than K = 2 distinct characters, shrink the window from the left: Remove one 'a': {'a': 2, 'r': 1, 'c': 1} Move windowStart = 1 Remove one 'r': {'a': 2, 'c': 1} Move windowStart = 2 Maximum length = 4 windowEnd = 5 Add 'i' to the hash map: {'a': 2, 'c': 1, 'i': 1} Since the hash map has more than K = 2 distinct characters, shrink the window from the left: Remove one 'a': {'a': 1, 'c': 1, 'i': 1} Move windowStart = 3 Remove one 'a': {'c': 1, 'i': 1} Move windowStart = 4 Maximum length = 4 Result: The maximum length of the substring with at most 2 distinct characters is 4. Visulization\nMerge Intervals The Merge Interval Pattern is a technique used to solve problems involving a list of intervals, where each interval is represented by a pair $[\\text{start}_i, \\text{end}_i]$. Common tasks following this pattern include merging overlapping intervals, inserting a new interval into an existing list, or finding the intersection of two interval lists.\nTo solve problems related to the merge interval pattern, the first step is to understand how two disjoint intervals can relate to each other. Given two intervals \u0026ldquo;a\u0026rdquo; and \u0026ldquo;b\u0026rdquo;, there are six possible relationships between them, as illustrated in the following image.\nAssuming a.start \u0026lt;= b.start (which can be achieved by sorting the intervals based on their starting points), there are only four possible scenatios:\nBy observing the above image, for two intervals to overlap, the condition a.start \u0026lt;= b.start \u0026amp;\u0026amp; b.start \u0026lt;= a.end must hold true. In this case, the merged interval becomes $[\\text{a.start}, \\text{max}\\{\\text{a.end, b.end}\\}]$.\nMerge Intervals SHOW PROBLEM Problem Statement\nGiven a list of intervals, merge all overlapping intervals to produce a list of mutually exclusive intervals.\nExample 1:\nInput: [[1, 4], [2, 5], [7, 9]] Output: [[1, 5], [7, 9]] Explanation: The first two intervals [1, 4] and [2, 5] overlap, so they are merged into one interval [1, 5]. Example 2:\nInput: [[6, 7], [2, 4], [5, 9]] Output: [[2, 4], [5, 9]] Explanation: The intervals [6, 7] and [5, 9] overlap, so they are merged into [5, 9]. Example 3:\nInput: [[1, 4], [2, 6], [3, 5]] Output: [[1, 6]] Explanation: All the given intervals overlap, so they are merged into one interval [1, 6]. Constraints:\n$1 \u0026lt;= \\text{intervals.length} \u0026lt;= 10^4$ $\\text{intervals[i].length} == 2$ $0 \u0026lt;= \\text{start}_i \u0026lt;= \\text{end}_i \u0026lt;= 10^4$ Go to Leetcode 🔗 SHOW CODE Java class Solution { public int[][] merge(int[][] intervals) { // Sort intervals by their start point Arrays.sort(intervals, (a, b) -\u003e a[0] - b[0]); // List to store merged intervals List\u0026lt;int[]\u0026gt; mergedIntervals = new ArrayList\u0026lt;\u0026gt;(); // Initialize the first interval as the current interval mergedIntervals.add(intervals[0]); // Iterate through the intervals for (int i = 1; i \u003c intervals.length; i++) { int[] currentInterval = mergedIntervals.get(mergedIntervals.size() - 1); int[] nextInterval = intervals[i]; // If the next interval overlaps with the current interval if (nextInterval[0] \u003c= currentInterval[1]) { // Merge by updating the end point of the current interval currentInterval[1] = Math.max(currentInterval[1], nextInterval[1]); } else { // No overlap, add the next interval as a new interval mergedIntervals.add(nextInterval); } } // Convert the list to a 2D array and return return mergedIntervals.toArray(new int[mergedIntervals.size()][]); } } SHOW NOTES Algorithm Walkthrough\nInput: [[1, 4], [2, 5], [7, 9]] Sort Intervals:\nOriginal intervals: [[1, 4], [2, 5], [7, 9]] Sorted intervals: [[1, 4], [2, 5], [7, 9]] (already sorted) Initialize Merged List:\nmergedIntervals = [[1, 4]] Iterate Through Intervals:\nFirst Iteration:\nCurrent interval: [1, 4] Next interval: [2, 5] Check overlap: 2 \u0026lt;= 4 (True) Merged intervals: [[1, 5]] Second Iteration:\nCurrent interval: [1, 5] Next interval: [7, 9] Check overlap: 7 \u0026lt;= 5 (False) Merged intervals: [[1, 5], [7, 9]] Result:\nResult: [[1, 5], [7, 9]] Visulization\nInsert Interval SHOW PROBLEM Problem Statement\nGiven a list of non-overlapping intervals sorted by their start time, insert a given interval at the correct position and merge all overlapping intervals to produce a list of mutually exclusive intervals.\nExample 1:\nInput: Intervals = [[1, 3], [5, 7], [8, 12]], New Interval = [4, 6] Output: [[1, 3], [4, 7], [8, 12]] Explanation: After inserting [4, 6], it overlaps with [5, 7], so they are merged into [4, 7]. Example 2:\nInput: Intervals = [[1, 3], [5, 7], [8, 12]], New Interval = [4, 10] Output: [[1, 3], [4, 12]] Explanation: After inserting [4, 10], it overlaps with [5, 7] and [8, 12], so they are merged into [4, 12]. Example 3:\nInput: Intervals = [[2, 3], [5, 7]], New Interval = [1, 4] Output: [[1, 4], [5, 7]] Explanation: After inserting [1, 4], it overlaps with [2, 3], so they are merged into [1, 4]. Constraints:\n1 \u0026lt;= intervals.length \u0026lt;= 10^4 intervals[i].length == 2 0 \u0026lt;= start_i \u0026lt;= end_i \u0026lt;= 10^5 intervals is sorted by start_i in ascending order. newInterval.length == 2 0 \u0026lt;= start \u0026lt;= end \u0026lt;= 10^5 Go to Leetcode 🔗 SHOW CODE Java class Solution { public int[][] insert(int[][] intervals, int[] newInterval) { List\u0026lt;int[]\u0026gt; mergedIntervals = new ArrayList\u0026lt;\u0026gt;(); int i = 0; // Add all intervals that ends before the new interval starts while (i \u003c intervals.length \u0026\u0026 intervals[i][1] \u003c newInterval[0]) { mergedIntervals.add(intervals[i]); i++; } // Merge the overlapping intervals with the new interval while (i \u003c intervals.length \u0026\u0026 intervals[i][0] \u003c= newInterval[1]) { newInterval[0] = Math.min(intervals[i][0], newInterval[0]); newInterval[1] = Math.max(intervals[i][1], newInterval[1]); i++; } // Add the merged new interval to the result list mergedIntervals.add(newInterval); // Add all intervals that don't overlap with the new interval to the result list while (i \u003c intervals.length) { mergedIntervals.add(intervals[i]); i++; } // Convert the list to a 2-D array and return return mergedIntervals.toArray(new int[mergedIntervals.size()][]); } } SHOW NOTES Since the interval list is sorted, the first step is to skip all intervals that satisfy the condition intervals[i].end \u0026lt; newInterval.start. After that, there are five possible ways the new interval can relate to the next interval in the list (where \u0026ldquo;a\u0026rdquo; represents newInterval, and \u0026ldquo;b\u0026rdquo; represents the next interval in the list), as shown in the following image.\nBy observing the above image, for two intervals to overlap, the condition interval.start \u0026lt;= newInterval.end must hold true. In this case, the merged interval will be $[\\text{min\\{a.start, b.start\\}}, \\text{max\\{a.end, b.end\\}}]$.\nAlgorithm Walkthrough\nIntervals = [[1, 3], [5, 7], [8, 12]] New Interval = [4, 10] Initialize Merged List:\nmergedIntervals = [] Iterate Through Intervals: Process the first interval [1, 3]: Ends before [4, 10] starts. Add to mergedIntervals: [[1, 3]] Process the second interval [5, 7]: Overlaps with [4, 10]. No change to the new interval: [4, 10] -\u0026gt; [4, 10] No change to mergedIntervals. Process the third interval [8, 12]: Overlaps with [4, 10]. Adjust new interval: [4, 10] -\u0026gt; [4, 12] Add the merged interval [4, 12] to mergedIntervals: [[1, 3], [4, 12]] No more intervals left to process. Final merged intervals: [[1, 3], [4, 12]] Visulization\nIntervals Intersection SHOW PROBLEM Problem Statement\nGiven two lists of disjoint intervals, find their intersection. Each list is sorted by the start time of the intervals.\nExample 1:\nInput: arr1 = [[1, 3], [5, 6], [7, 9]], arr2 = [[2, 3], [5, 7]] Output: [[2, 3], [5, 6], [7, 7]] Explanation: The output list contains the common intervals between the two lists. Example 2:\nInput: arr1 = [[1, 3], [5, 7], [9, 12]], arr2 = [[5, 10]] Output: [[5, 7], [9, 10]] Explanation: The output list contains the common intervals between the two lists. Constraints:\n0 \u0026lt;= arr1.length, arr2.length \u0026lt;= 1000 arr1.length + arr2.length \u0026gt;= 1 $0 \\le \\text{start}_i \u0026lt; \\text{end}_i \\le 10^9$ $end_i \u0026lt; \\text{start}_{i+1}$ for all intervals in arr1 $0 \\le \\text{start}_j \u0026lt; \\text{end}_j \\le 10^9$ $end_j \u0026lt; \\text{start}_{j+1}$ for all intervals in arr2 Go to Leetcode 🔗 SHOW CODE Java Optimization class Solution { public int[][] intervalIntersection(int[][] arr1, int[][] arr2) { List\u0026lt;int[]\u0026gt; intersections = new ArrayList\u0026lt;\u0026gt;(); int i = 0, j = 0; // Iterate over both interval lists to find all intersections while (i \u003c arr1.length \u0026\u0026 j \u003c arr2.length) { // Check if both intervals are overlapped if ((arr1[i][0] \u003e= arr2[j][0] \u0026\u0026 arr1[i][0] \u003c= arr2[j][1]) || (arr2[j][0] \u003e= arr1[i][0] \u0026\u0026 arr2[j][0] \u003c= arr1[i][1])) { // Store the intersection part intersections.add(new int[]{Math.max(arr1[i][0], arr2[j][0]), Math.min(arr1[i][1], arr2[j][1])}); } // Move the pointer of the interval that ends first if (arr1[i][1] \u003c arr2[j][1]) { i++; } else { j++; } } // Return the intersections as a 2D array return intersections.toArray(new int[intersections.size()][]); } } class Solution { public int[][] intervalIntersection(int[][] arr1, int[][] arr2) { List\u0026lt;int[]\u0026gt; intersections = new ArrayList\u0026lt;\u0026gt;(); int i = 0, j = 0; // Iterate over both interval lists to find all intersections while (i \u003c arr1.length \u0026\u0026 j \u003c arr2.length) { int start = Math.max(arr1[i][0], arr2[j][0]); int end = Math.min(arr1[i][1], arr2[j][1]); // Add the intersection to the result if valid if (start \u003c= end) { intersections.add(new int[] { start, end }); } // Move the pointer of the interval that ends first if (arr1[i][1] \u003c arr2[j][1]) { i++; } else { j++; } } // Return the result as a 2D array return intersections.toArray(new int[intersections.size()][]); } } SHOW NOTES Two Interval List: arr1 and arr2\nPointer Initialization: Initialize two pointers i and j, both set to 0, to track the current positions in arr1 and arr2, respectively.\nOverlapping Check: For two intervals a and b to overlap, at least one of the following conditions must hold true:\na.start \u0026lt;= b.start \u0026amp;\u0026amp; b.start \u0026lt;= a.end b.start \u0026lt;= a.start \u0026amp;\u0026amp; a.start \u0026lt;= b.end Interval Calculation: If a and b overlap (follows overlapping check), the intersection is calculated as:\n$[\\text{max}\\{\\text{a.start, b.start}\\}, \\text{min}\\{\\text{a.end, b.end}\\}]$ Interval Caculation (Optimization): Based on the Overlapping Check and Interval Calculation, the calculation can be optimized as follows:\nmaxStart = max{a.start, b.start} minEnd = min{a.end, b.end} An intersection [maxStart, minEnd] exists if maxStart \u0026lt;= minEnd Pointer Movement: Increment the pointer that ends first. For example, if arr1[i].end \u0026lt; arr2[j].end, increment i; otherwise increment j.\nIn-place Reversal of a Linked List The In-place Reversal of a Linked List pattern is a commonly used approach to solve linked-list-related problems efficiently without extra space. It relies on maintaining three pointers:\nprev: Points to the previous node. Initially set to null since there is no node before the head. current: Points to the node currently being processed. next: Points to the next node, ensuring the remaining list is not lost during the reversal process. This pattern typically involves the following three steps:\nInitialization: Set prev = null and current = head to start processing from the head of list. Iteration: Save the next node (next = current.next) to keep track of the remaining list. Reverse the link by updating current.next to point to prev. Move the prev pointer forward (prev = current). Move the current pointer forward (current = next); Termination: When current becomes null, the prev pointer will point to the new head of the reversed linked list. Reverse Linked List SHOW PROBLEM Problem Statement\nGiven the head of a singly linked list, reverse the list in-place and return the new head of the reversed list.\nConstraints\nThe number of nodes in the list is in the range: $[0, 5000]$. Each node’s value is within the range: $[-5000, 5000]$. Go to Leetcode 🔗 SHOW CODE Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseList(ListNode head) { ListNode prev = null; // Tracks the previous node ListNode current = head; // Tracks the current node // Traverse and reverse the list while (current != null) { ListNode next = current.next; // Save the next node current.next = prev; // Reverse the link prev = current; // Move prev forward current = next; // Move current forward } return prev; // New head of the reversed list } } SHOW NOTES Visulization\nReverse a Sublist SHOW PROBLEM Given the head of a LinkedList and two positions, left and right, reverse the portion of the LinkedList from position left to position right.\nConstraints:\nThe number of nodes in the list is n. 1 \u0026lt;= n \u0026lt;= 500 -500 \u0026lt;= Node.val \u0026lt;= 500 1 \u0026lt;= left \u0026lt;= right \u0026lt;= n Go to Leetcode 🔗 SHOW CODE Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseBetween(ListNode head, int left, int right) { ListNode prev = null, current = head; // Skip the first left - 1 node to reach the node at position left for (int i = 1; i \u003c left \u0026\u0026 current != null; i++) { prev = current; current = current.next; } // Save the node at position left - 1 to reconnect the reversed sublist ListNode lastNodeOfFirstPart = prev; // After reversing, the left node will become the last node of the reversed sublist ListNode lastNodeOfReversedList = current; // Reverse the node from left to right ListNode next = null; for (int i = 1; i \u003c= right - left + 1 \u0026\u0026 current != null; i++) { next = current.next; // Save the next node current.next = prev; // Reverse the link prev = current; // Move the 'prev' node forward current = next; // Move the 'current' node forward } // Reconnect the reversed sublist with the rest of the list if (lastNodeOfFirstPart != null) { // Connect with the new head of the sublist lastNodeOfFirstPart.next = prev; } else { // left == 1 in this case head = prev; } // Connect the tail of the reversed sublist to the remaining list lastNodeOfReversedList.next = current; return head; } } SHOW NOTES Skip the first left - 1 nodes to reach the node at position left Save the node at position left - 1 to later reconnect it with the reversed sublist. Save the node at position left before reversing, after reversing, the node will become the last node of the reversed sublist. Reverse the nodes from position left to right Reconnect the node at position left - 1 to the head of the reversed sublist, and connect the node at position right + 1 to the tail of the reversed sublist. Reverse Nodes in k-Group SHOW PROBLEM Problem Statement:\nGiven the head of a linked list, reverse the nodes of the list in groups of k at a time, and return the modified list.\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k, then the remaining nodes at the end should remain as they are (i.e., not reversed). You are not allowed to alter the values of the nodes in the list; only the nodes themselves may be rearranged. Example 1:\nInput: head = [1, 2, 3, 4, 5], k = 2 Output: [2, 1, 4, 3, 5] Example 2:\nInput: head = [1, 2, 3, 4, 5], k = 3 Output: [3, 2, 1, 4, 5] Go to Leetcode 🔗 SHOW CODE Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseKGroup(ListNode head, int k) { // Return the original list if the list is empty or k is 1 if (head == null || k == 1) { return head; } // Count the total number of the list ListNode temp = head; int count = 0; while (temp != null) { count++; temp = temp.next; } ListNode prev = null, current = head, next = null; while (current != null \u0026\u0026 count \u003e= k) { ListNode lastNodeOfPrevGroup = prev; // After reversing, the current node will become the last node of the reversed list ListNode lastNodeOfReversedList = current; // Reverse the list in groups of size k for (int i = 0; i \u003c k; i++) { next = current.next; current.next = prev; prev = current; current = next; count--; } // Connect the last node of the reversed sublist to the start node of the // remaining list lastNodeOfReversedList.next = current; // Connect with the previous group if (lastNodeOfPrevGroup != null) { // After reversing, the prev node is the head node of the sublist lastNodeOfPrevGroup.next = prev; } else { // When previous group is null, the prev node becomes the head of the original list head = prev; } // Break the loop when current is null or count is less than k if (current == null || count \u003c k) { break; } // Update the prev node for next iteration prev = lastNodeOfReversedList; } return head; } } SHOW NOTES The first step to solve this problem is to track the last node of the previous group and the last node of the reversed sublist. When the previous group is null, the head of the reversed sublist becomes the new head of the original list.\nBefore reversing, the current node points to the head of the sublist. After reversing, the head of the sublist becomes the last node of the reversed segment. Therefore, the last node of the reversed list can be tracked by setting lastNodeOfReversedList = current. To track the last node of the previous group, simply setting lastNodeOfPreviousGroup = prev.\nAfter the reversal, the prev node will point to the head of the reversed sublist, and the current node (if it\u0026rsquo;s not null) will point to the head of the next sublist. To maintain the list structure, There are two key steps need to do, the first step is connecting the last node of the previous group to the head (prev after reversal) of the reversed sublist, the second step is connecting the last node of the reversed sublist to the remaining node (if any).\nFinally, update the prev node to be the last node of the reversed sublist, preparing it for the next iteration.\nHash Maps Hash Map Data Structure A Hash Map is a data structure that stores key-value pairs, enabling efficient lookup, insertion, and deletion operations. Under most conditions, it provides constant time complexity (O(1)) for these operations. The Hash Map Pattern takes advantage of the hash map\u0026rsquo;s efficiency to store and retrive data quickly. It is commonly used to solve problems involving the calculation of element frequencies in a sequency or array.\nFirst Unique Character in a String SHOW PROBLEM Problem Statement\nGiven a string, find the position of the first character that appears only once. If no such character exists, return -1.\nExample 1:\nInput: \u0026quot;apple\u0026quot; Expected Output: 0 Justification: The first character 'a' appears only once in the string, and it is located at index 0. Example 2:\nInput: \u0026quot;abcab\u0026quot; Expected Output: 2 Justification: The first character that appears only once is 'c', which is located at index 2. Example 3:\nInput: \u0026quot;abab\u0026quot; Expected Output: -1 Justification: All characters in the string appear more than once, so there is no character that appears only once. Constraints:\n1 \u0026lt;= s.length \u0026lt;= 10^5 s consists of only lowercase English letters. Go to Leetcode 🔗 SHOW CODE Java class Solution { public int firstUniqChar(String s) { // Use a HashMap to store the frequency of each character Map\u0026lt;Character, Integer\u0026gt; charFrequencyMap = new HashMap\u0026lt;\u0026gt;(); // Populate the map with the frequency of each character for (char c : s.toCharArray()) { charFrequencyMap.put(c, charFrequencyMap.getOrDefault(c, 0) + 1); } // Iterate over the string to find the index of the first unique character for (int i = 0; i \u003c s.length(); i++) { if (charFrequencyMap.get(s.charAt(i)) == 1) { return i; // Return the index of the first unique character } } // No unique character found, return -1 return -1; } } SHOW NOTES Virsulization:\nMaximum Number of Balloons SHOW PROBLEM Problem Statement\nGiven a string, determine the maximum number of times the word \u0026ldquo;balloon\u0026rdquo; can be formed using the characters from the string. Each character in the string can be used only once.\nExample 1:\nInput: \u0026quot;balloonballoon\u0026quot; Expected Output: 2 Justification: The word \u0026ldquo;balloon\u0026rdquo; can be formed twice from the given string. Example 2:\nInput: \u0026quot;bbaall\u0026quot; Expected Output: 0 Justification: The word \u0026ldquo;balloon\u0026rdquo; cannot be formed because the character \u0026lsquo;o\u0026rsquo; is missing twice. Example 3:\nInput: \u0026quot;balloonballoooon\u0026quot; Expected Output: 2 Justification: The word \u0026ldquo;balloon\u0026rdquo; can be formed twice, even though there are extra \u0026lsquo;o\u0026rsquo; characters. Constraints:\n1 \u0026lt;= text.length \u0026lt;= 10^4 text consists of lowercase English letters only. Go to Leetcode 🔗 SHOW CODE Java class Solution { public int maxNumberOfBalloons(String text) { // Define the required frequencies of characters to form 'balloon' Map\u0026lt;Character, Integer\u0026gt; requiredCharMap = Map.of( 'b', 1, 'a', 1, 'l', 2, 'o', 2, 'n', 1); // Calculate the frequencies of characters that are part of 'balloon' Map\u0026lt;Character, Integer\u0026gt; availableCharMap = new HashMap\u0026lt;\u0026gt;(); for (char c : text.toCharArray()) { if (requiredCharMap.containsKey(c)) { availableCharMap.put(c, availableCharMap.getOrDefault(c, 0) + 1); } } // Calculate the maximum available count of the word 'balloon' int maxCount = Integer.MAX_VALUE; if (availableCharMap.size() == requiredCharMap.size()) { for (char c : availableCharMap.keySet()) { int requiredCount = requiredCharMap.get(c); int availableCount = availableCharMap.get(c); maxCount = Math.min(maxCount, availableCount / requiredCount); } } return (maxCount == Integer.MAX_VALUE) ? 0 : maxCount; } } SHOW NOTES Virsulization:\nLongest Palindrome SHOW PROBLEM Problem Statement:\nGiven a string, determine the length of the longest palindrome that can be constructed using the characters from the string. Return the maximum possible length of the palindromic string.\nExample 1:\nInput: \u0026quot;applepie\u0026quot; Expected Output: 5 Justification: The longest palindrome that can be formed is \u0026quot;pepep\u0026quot;, which has a length of 5. Other valid palindromes are also of length 5. Example 2:\nInput: \u0026quot;aabbcc\u0026quot; Expected Output: 6 Justification: We can form the palindrome \u0026quot;abccba\u0026quot;, which has a length of 6. Example 3:\nInput: \u0026quot;bananas\u0026quot; Expected Output: 5 Justification: The longest palindrome that can be formed is \u0026quot;anana\u0026quot;, which has a length of 5. Constraints:\n1 \u0026lt;= s.length \u0026lt;= 2000 s consists of lowercase and/or uppercase English letters only. Go to Leetcode 🔗 SHOW CODE Java class Solution { public int longestPalindrome(String s) { // Calculate the frequency of each character in the string Map\u0026lt;Character, Integer\u0026gt; frequencyMap = new HashMap\u0026lt;\u0026gt;(); for (char c : s.toCharArray()) { frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1); } // Flag to track if any character has an odd frequency boolean oddFound = false; int maxLength = 0; // Calculate the maximum possible length of the palindrome for (int count : frequencyMap.values()) { if (count % 2 == 0) { // Add even counts directly to the length of the palindorme maxLength += count; } else { maxLength += count - 1; // Add the even parts of odd counts oddFound = true; // Mark an odd frequency character exists } } // For characters has an odd count, one can be placed in the middle of the palindrome return oddFound ? maxLength + 1 : maxLength; } } SHOW NOTES To solve this problem, the first step is to calculate the frequency of each character in the original string. If no character has an odd frequency, simply add the frequency of each character to the length of the palindrome. If there are characters with an odd frequency, one of those characters can be placed in the middle of the palindrome.\nTherefore, to get the maximum length of the palindrome, two key steps are involved. First, add the even part of each character\u0026rsquo;s frequency to the palindrome length. Then, if there is any character with an odd count, increment the length by 1, representing the character placed in the middle of the palindrome.\nVirsulization:\nPrefix Sum A prefix sum refers to the cumulative sum of an array from the begining up to a specified index. The prefix sum pattern is a programming technique commonly used to solve problems related to subarrays, such as calculating the range sum, range maximum/minimum, or frequency counting.\nTo calculate the prefix sum, the steps typically include:\nInitialze a prefix array with the same length as the original array. Assign prefix[0] = arr[0]. Iterate through the array from index 1 to n - 1, set prefix[i] = arr[i] + prefix[i - 1] Once the prefix sum array is constructed, the time complexity for calculating the sum of any subarray is O(1), makeing this technique very efficient.\nFind the Middle Index in Array SHOW PROBLEM Problem Statement:\nGiven an integer array nums, return the leftmost middleIndex (i.e., the smallest index among all possible middle indices).\nA middleIndex is an index where the sum of the numbers to the left of this index is equal to the sum of the numbers to the right of this index.\nYou can consider the left sum to be 0 when middleIndex == 0, and the right sum to be 0 when middleIndex == nums.length - 1. If no middle index exists in the array, return -1. Example 1:\nInput: nums = [1, 7, 3, 6, 5, 6] Expected Output: 3 Justification: The sum of the numbers to the left of index 3 (1 + 7 + 3 = 11) is equal to the sum of the numbers to the right of index 3 (5 + 6 = 11). Example 2:\nInput: nums = [2, 1, -1] Expected Output: 0 Justification: The sum of the numbers to the left of index 0 is considered 0. The sum of the numbers to the right of index 0 (1 + -1 = 0) is also 0. Example 3:\nInput: nums = [2, 3, 5, 5, 3, 2] Expected Output: -1 Justification: There is no index in the array where the left and right sums are equal. Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 100 -1000 \u0026lt;= nums[i] \u0026lt;= 1000 Go to Leetcode 🔗 SHOW CODE Java class Solution { public int findMiddleIndex(int[] nums) { // Calculate the total sum of the array int totalSum = Arrays.stream(nums).sum(); int leftSum = 0; // Iterate through the array to find the middle index for (int i = 0; i \u003c nums.length; i++) { // Calculate the right sum int rightSum = totalSum - leftSum - nums[i]; // Found the middle index if left sum equals to right sum if (leftSum == rightSum) { return i; } // Update the left sum for next iteration leftSum += nums[i]; } // Return -1 if middle index is found return -1; } } SHOW NOTES Visualization:\nLeft and Right Sum Differences SHOW PROBLEM Problem Statement\nGiven an integer array nums, you need to find a new integer array called differenceArray, where each element at index i in differenceArray is the absolute difference between the sum of all elements to the left of index i and the sum of all elements to the right of index i in the original array nums.\nFormally, for each index i in the array:\n$$ \\text{differenceArray}[i] = | \\text{leftSumi} - \\text{rightSumi} | $$\nWhere:\n$\\text{leftSum}_i$ is the sum of all elements to the left of index i (i.e., nums[0] + nums[1] + ... + nums[i-1]). $\\text{rightSum}_i$ is the sum of all elements to the right of index i (i.e., nums[i+1] + nums[i+2] + ... + nums[nums.length-1]). If there are no elements to the left or right of i, treat the sum as 0. Example 1:\nInput: nums = [2, 5, 1, 6, 1] Expected Output: [13, 6, 0, 7, 14] Explanation: For i = 0: | (0) - (5 + 1 + 6 + 1) | = | 0 - 13 | = 13 For i = 1: | (2) - (1 + 6 + 1) | = | 2 - 8 | = 6 For i = 2: | (2 + 5) - (6 + 1) | = | 7 - 7 | = 0 For i = 3: | (2 + 5 + 1) - (1) | = | 8 - 1 | = 7 For i = 4: | (2 + 5 + 1 + 6) - (0) | = | 14 - 0 | = 14 Example 2:\nInput: nums = [3, 3, 3] Expected Output: [6, 0, 6] Explanation: For i = 0: | (0) - (3 + 3) | = | 0 - 6 | = 6 For i = 1: | (3) - (3) | = | 3 - 3 | = 0 For i = 2: | (3 + 3) - (0) | = | 6 - 0 | = 6 Example 3:\nInput: nums = [1, 2, 3, 4, 5] Expected Output: [14, 11, 6, 1, 10] Explanation: For i = 0: | (0) - (2 + 3 + 4 + 5) | = | 0 - 14 | = 14 For i = 1: | (1) - (3 + 4 + 5) | = | 1 - 12 | = 11 For i = 2: | (1 + 2) - (4 + 5) | = | 3 - 9 | = 6 For i = 3: | (1 + 2 + 3) - (5) | = | 6 - 5 | = 1 For i = 4: | (1 + 2 + 3 + 4) - (0) | = | 10 - 0 | = 10 Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 1000 1 \u0026lt;= nums[i] \u0026lt;= 10^5 Go to Leetcode 🔗 SHOW CODE Java class Solution { public int[] leftRightDifference(int[] nums) { int n = nums.length; // Calculate the total sum of nums int totalSum = Arrays.stream(nums).sum(); // Construct prefix sum array based on nums int[] prefix = new int[n]; prefix[0] = nums[0]; for (int i = 1; i \u003c n; i++) { prefix[i] = nums[i] + prefix[i - 1]; } int[] answer = new int[n]; // Iterate over nums to calculate the absolute difference between left and right // sums for each index for (int i = 0; i \u003c n; i++) { int leftSum = prefix[i] - nums[i]; int rightSum = totalSum - prefix[i]; answer[i] = Math.abs(leftSum - rightSum); } return answer; } } Subarray Sums Divisible by K SHOW PROBLEM Problem Statement:\nGiven an integer array nums and an integer k, return the number of non-empty subarrays whose sum is divisible by k.\nA subarray is a contiguous part of an array.\nExample 1:\nInput: nums = [3, 1, 2, -2, 5, -1], k = 3 Output: 7 Explanation: There are 7 subarrays whose sum is divisible by k = 3: [3], [1, 2], [3, 1, 2], [-2, 2], [3, 1, 2, -2, 5], [1, 2, -2, 5], [-2, 5]. Example 2:\nInput: nums = [4, 5, 0, -2, -3, 1], k = 5 Output: 7 Explanation: There are 7 subarrays whose sum is divisible by k = 5: [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]. Example 2:\nInput: nums = [5], k = 9 Output: 0. Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 30,000 -10,000 \u0026lt;= nums[i] \u0026lt;= 10,000 2 \u0026lt;= k \u0026lt;= 10,000 Go to Leetcode 🔗 SHOW CODE Java class Solution { public int subarraysDivByK(int[] nums, int k) { // Store frequency of prefix sum modulo k Map\u0026lt;Integer, Integer\u0026gt; prefixSumModCount = new HashMap\u0026lt;\u0026gt;(); // Initialize with mod 0 having a frequency of 1 // (for the case where the prefix sum itself is divisible by k) prefixSumModCount.put(0, 1); // Initialize the prefix sum and the count of valid subarrays int prefixSum = 0, count = 0; for (int num : nums) { // Update the current prefix sum prefixSum += num; // Ensure the modulo is always positive int mod = ((prefixSum % k) + k) % k; // If the same mod has been seen before, // it means there are subarrays whose sum is divisible by k count += prefixSumModCount.getOrDefault(mod, 0); // Update frequency of current mod prefixSumModCount.put(mod, prefixSumModCount.getOrDefault(mod, 0) + 1); } return count; } } SHOW NOTES If the sum of a subarray form index $i$ to $j$ can be divisable by $k$, then: $$ (a[0] + a[1] + \\dots + a[i - 1] + a[i]) \\;\\text{mod} \\;k $$\nequals to\n$$ (a[0] + a[1] + \\dots + a[i] + \\dots + a[j-1] + a[j]) \\;\\text{mod} \\;k $$\nAlgorithm Walkthrough\nInput: nums = [3, 1, 2, -2, 5, -1] and k = 3. Initialization:\nremainder_count = {0: 1} (We start by initializing the count of remainders with 0, assuming a subarray sum of 0 is divisible by k.) cumulative_sum = 0 count = 0 Iteration 1 (num = 3):\ncumulative_sum = 3 remainder = 3 % 3 = 0 count += remainder_count[0] = 1 → count = 1 Update remainder_count: {0: 2} Iteration 2 (num = 1):\ncumulative_sum = 4 remainder = 4 % 3 = 1 count += remainder_count.get(1, 0) = 0 → count = 1 Update remainder_count: {0: 2, 1: 1} Iteration 3 (num = 2):\ncumulative_sum = 6 remainder = 6 % 3 = 0 count += remainder_count[0] = 2 → count = 3 Update remainder_count: {0: 3, 1: 1} Iteration 4 (num = -2):\ncumulative_sum = 4 remainder = 4 % 3 = 1 count += remainder_count[1] = 1 → count = 4 Update remainder_count: {0: 3, 1: 2} Iteration 5 (num = 5):\ncumulative_sum = 9 remainder = 9 % 3 = 0 count += remainder_count[0] = 3 → count = 7 Update remainder_count: {0: 4, 1: 2} Iteration 6 (num = -1):\ncumulative_sum = 8 remainder = 8 % 3 = 2 count += remainder_count.get(2, 0) = 0 → count = 7 Update remainder_count: {0: 4, 1: 2, 2: 1} The total count of subarrays whose sum is divisible by k is 7.\nMonotonic Stack A monotonic stack pattern is a technique commonly used to solve problems that involve finding the next greater or next smaller element in a sequence or array, or finding the largest rectangle in a histogram. There are two types of monotonic stacks: the increasing monotonic stack and the decreasing monotonic stack.\nAn increasing monotonic stack maintains elements in increasing order from bottom to top (i.e., each element is greater than or equal to the element below it). An decreasing monotonic stack maintains elements in decreasing order from bottom to top (i.e., each element is smaller than or equal to the element below it). Creating a monotonic stack commonly involves the following steps (using increasing monotonic stack as an example):\nInitialize an empty stack. Iterate over the array. Compare the current element with the top element of the stack (if the stack is not empty). Pop all elements from the stack that are smaller than the current element. This ensures that the stack only contains elements greater than or equal to the current element. Push the current element onto the stack. Next Greater Element I SHOW PROBLEM The next greater element for an element x in an array is the first element greater than x that appears to the right of x in the same array.\nYou are given two distinct 0-indexed integer arrays, nums1 and nums2, where nums1 is a subset of nums2.\nFor each 0 \u0026lt;= i \u0026lt; nums1.length, find the index j such that nums1[i] == nums2[j], and then determine the next greater element of nums2[j] in nums2. If there is no next greater element, return -1 for that query.\nReturn an array ans of length nums1.length such that ans[i] is the next greater element for nums1[i] as described above.\nExample 1:\nInput: nums1 = [4, 1, 2], nums2 = [1, 3, 4, 2] Output: [-1, 3, -1] Explanation: The next greater element for 4 is not found in nums2, so the answer is -1. The next greater element for 1 is 3. The next greater element for 2 is not found, so the answer is -1. Example 2:\nInput: nums1 = [2, 4], nums2 = [1, 2, 3, 4] Output: [3, -1] Explanation: The next greater element for 2 is 3. The next greater element for 4 is not found, so the answer is -1. Constraints:\n1 \u0026lt;= nums1.length \u0026lt;= nums2.length \u0026lt;= 1000 0 \u0026lt;= nums1[i], nums2[i] \u0026lt;= 10⁴ All integers in nums1 and nums2 are unique. All integers of nums1 are also present in nums2. Go to Leetcode 🔗 SHOW CODE Java class Solution { public int[] nextGreaterElement(int[] nums1, int[] nums2) { // Initialize an empty stack to track elements in nums2 Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); // Map to store the next greater element for each number in nums2 Map\u0026lt;Integer, Integer\u0026gt; nextGreaterMap = new HashMap\u0026lt;\u0026gt;(); // Traverse nums2 from right to left to populate the nextGreaterMap for (int i = nums2.length - 1; i \u003e= 0; i--) { int num = nums2[i]; // Pop elements from stack that are less than or equal to the current number while (!stack.isEmpty() \u0026\u0026 stack.peek() \u003c= num) { stack.pop(); } // If stack is empty, no greater element exists, otherwise top of stack is the next greater element nextGreaterMap.put(num, stack.isEmpty() ? -1 : stack.peek()); // Push the current number onto the stack for future comparisons stack.push(num); } // Prepare the result array for nums1 based on nextGreaterMap int[] result = new int[nums1.length]; // Find the next greater element for each number in nums1 for (int i = 0; i \u003c nums1.length; i++) { result[i] = nextGreaterMap.get(nums1[i]); } return result; } } SHOW NOTES When iterating over an increasing monotonic stack from right to left, if the current element is greater than the top of the stack, it means the current element could be the next greater element for the previous ones. In this case, pop the stack.\nRemove All Adjacent Duplicates in String II SHOW PROBLEM You are given a string s and an integer k. A k-duplicate removal consists of selecting k adjacent and identical letters from s and removing them, causing the left and right sides of the deleted substring to merge together.\nYou must repeatedly perform k-duplicate removals on s until no further removals are possible.\nReturn the final string after all such duplicate removals have been made. It is guaranteed that the answer is unique.\nExample 1:\nInput: s = \u0026quot;abcd\u0026quot;, k = 2 Output: \u0026quot;abcd\u0026quot; Explanation: There are no adjacent duplicate characters, so no removal happens. Example 2:\nInput: s = \u0026quot;deeedbbcccbdaa\u0026quot;, k = 3\nOutput: \u0026quot;aa\u0026quot; Explanation: First, delete \u0026ldquo;eee\u0026rdquo; and \u0026ldquo;ccc\u0026rdquo;, which results in \u0026quot;ddbbbdaa\u0026quot;. Then, delete \u0026ldquo;bbb\u0026rdquo;, resulting in \u0026quot;dddaa\u0026quot;. Finally, delete \u0026ldquo;ddd\u0026rdquo;, resulting in \u0026quot;aa\u0026quot;. Example 3:\nInput: s = \u0026quot;pbbcggttciiippooaais\u0026quot;, k = 2\nOutput: \u0026quot;ps\u0026quot;\nConstraints:\n1 \u0026lt;= s.length \u0026lt;= 10^5 2 \u0026lt;= k \u0026lt;= 10^4 s only contains lowercase English letters. Go to Leetcode 🔗 SHOW CODE Java class Solution { public String removeDuplicates(String s, int k) { // Stack to store characters along with their consecutive count Stack\u0026lt;int[]\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); // Iterate over each character in the string for (char c : s.toCharArray()) { // Check if the stack is not empty and the current character is the same as the top character if (!stack.isEmpty() \u0026\u0026 stack.peek()[0] == c) { // Increment the count of top character by 1 stack.peek()[1]++; } else { // Otherwise, push the current character onto the stack with count 1 stack.push(new int[]{c, 1}); } // If the top character's count reaches k, remove it from the stack if (stack.peek()[1] == k) { stack.pop(); } } // Construct result string from the stack StringBuilder builder = new StringBuilder(); for (int[] entry : stack) { builder.append(String.valueOf((char) entry[0]).repeat(entry[1])); } return builder.toString(); } } Largest Rectangle in Histogram SHOW PROBLEM Problem Statement:\nGiven an array of integers heights representing the heights of the histogram\u0026rsquo;s bars, where the width of each bar is 1, return the area of the largest rectangle that can be formed in the histogram.\nExample 1:\nInput: heights = [2, 1, 5, 6, 2, 3] Output: 10 Explanation: The above is a histogram where each bar has a width of 1. The largest rectangle is formed by the bars of height 5 and 6, with a width of 2, yielding an area of 10 units. Example 2:\nInput: heights = [2, 4] Output: 4 Explanation: The largest rectangle is formed by the bar of height 4, yielding an area of 4 units. Constraints:\n1 \u0026lt;= heights.length \u0026lt;= 10^5 1 \u0026lt;= heights[i] \u0026lt;= 10^4 Go to Leetcode 🔗 SHOW CODE Javaimport java.util.Stack; class Solution { public int largestRectangleArea(int[] heights) { // Stack to store indices of the bars Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); int maxArea = 0; // Inerate through all the bars for (int i = 0; i \u003c heights.length; i++) { // While the stack is not empty and the current bar is shorter than the bar at the stack's top while (!stack.isEmpty() \u0026\u0026 heights[i] \u003c heights[stack.peek()]) { // Pop the top index from the stack int height = heights[stack.pop()]; // Calculate the width of the rectangle formed by the popped bar // If the stack is empty, it means the popped bar was the smallest so far, // so the width is 'i' int width = stack.isEmpty() ? i : i - stack.peek() - 1; // Calculate the area with the popped bar as the shortest bar maxArea = Math.max(maxArea, height * width); } // Push the current bar's index onto the stack stack.push(i); } // Process the remaining bars in the stack while (!stack.isEmpty()) { int height = heights[stack.pop()]; // If the stack is empty, it means the popped bar was the smallest so far int width = stack.isEmpty() ? heights.length : heights.length - stack.peek() - 1; maxArea = Math.max(maxArea, height * width); } return maxArea; } } SHOW NOTES To solve this problem, an increasing monotonic stack can be used. When the height of the current bar is less than the height of the bar at the top of the stack, the index of the top bar is popped to calculate the maximal area. Since the elements in the stack are in increasing order, the bar at the top always forms a rectangle with the bar below it, as illustrated in the follow image.\nFor example, consider an increasing monotonic stack containing the elements 2, 5, 6, and the current element is 2 (less than 6) with index 4. The indices of the three elements in the stack are 0, 2, 3, respectively. First, pop the bar with height 6. The area is calculated as height x width = 6 x (4 - 2 - 1). In this case, 2 is the index of element 5, because after popping the element 6, the top of the stack becomes index 2. Therefore, the width is calculated as the index of the current element minus stack.peek() minus 1, if the stack is not empty after popping.\nTree Breadth First Search The Tree Breadth First Search Pattern is a programming technique used for traversing a tree or graph level by level. It explores all nodes at the current depth before moving to the next level. This approach leverages the FIFO (First-In-First-Out) principle of the queue data structure to ensure that all nodes at a given level are processed before their child nodes. It is commonly used to solve problems that require level-wise processing, such as finding the shortest path or performing level-order operations.\nThe Tree Breadth First Search Pattern typically involves the following steps:\nEmpty Check: Check if the tree or graph is null. Queue Initialization: Initialize an empty queue and enqueue the root node. Process and Enqueue: While the queue is not empty, compute the current queue size, dequeue nodes one by one (dequeue times equal to the size of the current level), process each node, and enqueue its children if they exist. Repeat: Continue processing nodes until the queue is empty. Binary Tree Level Order Traversal SHOW PROBLEM Problem Statement:\nGiven the root of a binary tree, return the level order traversal of its nodes\u0026rsquo; values. (i.e., traverse the tree from left to right, level by level).\nExample 1:\nInput: root = [3, 9, 20, null, null, 15, 7] Output: [[3], [9, 20], [15, 7]] Example 2:\nInput: root = [1] Output: [[1]] Example 3:\nInput: root = [] Output: [] Constraints:\nThe number of nodes in the tree is in the range [0, 2000]. -1000 \u0026lt;= Node.val \u0026lt;= 1000. Go to Leetcode 🔗 SHOW CODE Java /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); // Return an empty list if the tree is empty if (root == null) { return result; } // Initialize a queue for level order traversal Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(root); // Add the root node to the queue while (!queue.isEmpty()) { int levelSize = queue.size(); // Get the number of nodes at the current level List\u0026lt;Integer\u0026gt; currentLevel = new ArrayList\u0026lt;\u0026gt;(); // Process all nodes at the current level for (int i = 0; i \u003c levelSize; i++) { TreeNode node = queue.poll(); currentLevel.add(node.val); // Add left and right children to the queue if they exist if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } } // Add the current level's result to the overall result result.add(currentLevel); } return result; // Return the level order traversal result } } Binary Tree Zigzag Level Order Traversal SHOW PROBLEM Problem Statement:\nGiven the root of a binary tree, return the zigzag level order traversal of its nodes\u0026rsquo; values. That is, traverse the tree from left to right for the first level, then right to left for the next level, and alternate between the two directions for each subsequent level.\nExample 1:\nInput: root = [3, 9, 20, null, null, 15, 7] Output: [[3], [20, 9], [15, 7]] Example 2:\nInput: root = [1] Output: [[1]] Example 3:\nInput: root = [] Output: [] Constraints:\nThe number of nodes in the tree is in the range [0, 2000]. -100 \u0026lt;= Node.val \u0026lt;= 100. Go to Leetcode 🔗 SHOW CODE Java /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; zigzagLevelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); // Return empty result if tree is empty if (root == null) { return result; } Queue queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(root); // Add the root node to the queue boolean leftToRight = true; // Flag to alternate direction of traversal while (!queue.isEmpty()) { int levelSize = queue.size(); List\u0026lt;Integer\u0026gt; currentLevel = new LinkedList\u0026lt;\u0026gt;(); // Process each node at the current level for (int i = 0; i \u003c levelSize; i++) { TreeNode node = queue.poll(); // Add node value based on the current direction if (leftToRight) { currentLevel.add(node.val); // Left to right } else { currentLevel.add(0, node.val); // Right to left } // Enqueue left and right children if they exist if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } } result.add(currentLevel); leftToRight = !leftToRight; // Toggle the direction for the next level } return result; } } SHOW NOTES Visualization\nPopulating Next Right Pointers in Each Node SHOW PROBLEM Problem Statement:\nYou are given a perfect binary tree where all leaves are on the same level, and every parent node has two children. The binary tree is defined as follows:\nstruct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\nInitially, all next pointers are set to NULL.\nExample 1:\nInput: root = [1,2,3,4,5,6,7] Output: [1,#,2,3,#,4,5,6,7,#] Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with # signifying the end of each level. Example 2:\nInput: root = [] Output: [] Constraints:\nThe number of nodes in the tree is in the range [0, 2^12 - 1]. -1000 \u0026lt;= Node.val \u0026lt;= 1000. Go to Leetcode 🔗 SHOW CODE Java /* // Definition for a Node. class Node { public int val; public Node left; public Node right; public Node next; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, Node _left, Node _right, Node _next) { val = _val; left = _left; right = _right; next = _next; } }; */ class Solution { public Node connect(Node root) { // If the root is null, return null as there's nothing to connect if (root == null) { return root; } // Initialize a queue for level order traversal Queue\u0026lt;Node\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(root); // Process nodes level by level while (!queue.isEmpty()) { int levelSize = queue.size(); // Get the number of nodes at the current level // Iterate through nodes at the current level for (int i = 0; i \u003c levelSize; i++) { Node node = queue.poll(); // Set the next pointer for all nodes except the last node at the level if (i \u003c levelSize - 1) { node.next = queue.peek(); // Next node at the same level } else { node.next = null; // Last node points to null } // Enqueue left and right children for the next level if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } } } // Return the root of the tree with updated next pointers return root; } } SHOW NOTES Tree Depth First Search The Tree Depth-First Search Pattern is a programming technique commonly used to explore tree or graph data structures. It begins at the root node and explores all nodes in a single branch as far as possible before backtracking. This approach is especially useful for problems that involve tree traversal or handling hierarchical data.\nImplementing the Tree Depth-First Search Pattern commonly involves the following steps:\nEmpty Check: If the current node is null, return. Leaf Node Check: If both the left and right children of the current node are null, then the current node is a leaf node. Recursive Traversal: Recursively call the function on the left and right children of the current node. Result Computation: Compute the result based on the results obtained from the left and right branches. Path Sum SHOW PROBLEM Problem Description:\nGiven the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that the sum of all the node values along the path equals targetSum.\nA leaf is a node with no children. Example 1:\nInput: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 Output: true Explanation: The root-to-leaf path that sums to the target value is: 5 -\u0026gt; 4 -\u0026gt; 11 -\u0026gt; 2. This path sums to 22. Example 2:\nInput: root = [1,2,3], targetSum = 5 Output: false Explanation: There are two root-to-leaf paths: (1 → 2): The sum is 3. (1 → 3): The sum is 4. Neither of these paths has a sum equal to 5. Example 3:\nInput: root = [], targetSum = 0 Output: false Explanation: Since the tree is empty, there are no root-to-leaf paths. Constraints:\nThe number of nodes in the tree is in the range [0, 5000]. -1000 \u0026lt;= Node.val \u0026lt;= 1000 -1000 \u0026lt;= targetSum \u0026lt;= 1000 Go to Leetcode 🔗 SHOW CODE Java /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean hasPathSum(TreeNode root, int targetSum) { // Return false if the node is null if (root == null) { return false; } // Check if current node is a leaf node if (root.left == null \u0026\u0026 root.right == null) { return root.val == targetSum; } // Recursively check left and right subtrees with the reduced target targetSum -= root.val; // Reduce the target sum by the current node's value return hasPathSum(root.left, targetSum) || hasPathSum(root.right, targetSum); } } SHOW NOTES Visulization\nPath Sum II SHOW PROBLEM Problem Statement:\nGiven the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of node values, not node references.\nA root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children.\nExample 1:\nInput: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 Output: [[5,4,11,2],[5,8,4,5]] Explanation: There are two paths whose sum equals targetSum: 5 + 4 + 11 + 2 = 22 5 + 8 + 4 + 5 = 22 Example 2:\nInput: root = [1,2,3], targetSum = 5 Output: [] Example 3:\nInput: root = [1,2], targetSum = 0 Output: [] Constraints:\nThe number of nodes in the tree is in the range [0, 5000]. -1000 \u0026lt;= Node.val \u0026lt;= 1000 -1000 \u0026lt;= targetSum \u0026lt;= 1000 Go to Leetcode 🔗 SHOW CODE Java /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; pathSum(TreeNode root, int targetSum) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); findPaths(root, targetSum, new ArrayList\u0026lt;\u0026gt;(), result); return result; } private void findPaths(TreeNode node, int remainingSum, List\u0026lt;Integer\u0026gt; currentPath, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result) { // Base case: return if the node is null if (node == null) return; // Add the current node's value to the path currentPath.add(node.val); // If it's a leaf node and the remaining sum equals the node's value, add the path to the result if (node.left == null \u0026\u0026 node.right == null \u0026\u0026 node.val == remainingSum) { result.add(new ArrayList\u0026lt;\u0026gt;(currentPath)); // Add a copy of current path } else { // Recursively explore left and right subtrees, updating the remaining sum findPaths(node.left, remainingSum - node.val, currentPath, result); findPaths(node.right, remainingSum - node.val, currentPath, result); } // Backtrack: remove the current node from the path currentPath.remove(currentPath.size() - 1); } } SHOW NOTES Visulization:\nPath Sum III SHOW PROBLEM Problem Statement:\nGiven the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.\nA path is a sequence of nodes where each consecutive node in the path is the child of the previous node. A path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).\nExample 1:\nInput: root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8 Output: 3 Explanation: The paths that sum to 8 are: Path 1: 5 → 3 → 2 Path 2: 5 → 3 Path 3: -3 → 11 Example 2:\nInput: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 Output: 3 Explanation: The paths that sum to 22 are: Path 1: 5 → 4 → 11 → 2 Path 2: 5 → 8 → 4 → 5 Path 3: 8 → 4 → 7 Constraints:\nThe number of nodes in the tree is in the range [0, 1000]. -10^9 \u0026lt;= Node.val \u0026lt;= 10^9 -1000 \u0026lt;= targetSum \u0026lt;= 1000 Go to Leetcode 🔗 SHOW CODE Java /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int pathSum(TreeNode root, int targetSum) { HashMap\u0026lt;Long, Integer\u0026gt; prefixSumMap = new HashMap\u0026lt;\u0026gt;(); // Base case: a path with current sum matches target sum exitst at the root prefixSumMap.put(0L, 1); return pathSumRecursive(root, 0, targetSum, prefixSumMap); } private static int pathSumRecursive(TreeNode node, long currentSum, int targetSum, Map\u0026lt;Long, Integer\u0026gt; prefixSumMap) { if (node == null) { return 0; } // Update the current sum currentSum += node.val; // Calculate the number of valid paths ending at this node int pathCount = prefixSumMap.getOrDefault(currentSum - targetSum, 0); // Add the current sum to the map prefixSumMap.put(currentSum, prefixSumMap.getOrDefault(currentSum, 0) + 1); // Recur for left and right sub-trees pathCount += pathSumRecursive(node.left, currentSum, targetSum, prefixSumMap); pathCount += pathSumRecursive(node.right, currentSum, targetSum, prefixSumMap); // Remove the current path sum to backtrack prefixSumMap.put(currentSum, prefixSumMap.get(currentSum) - 1); return pathCount; } } Cyclic Sort Matrix Traversal Modified Binary Search 2-Dimensional Prefix Sum Subsets Bitwise XOR Greedy Algorithm Dynamic Programming Backtracking Union Find Topological Sort Ordered Set Trie Top \u0026lsquo;K\u0026rsquo; Elements K-way Merge Two Heaps ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/patterns/1-coding-patterns/","summary":"Simple Two Pointers The Simple Two Pointers technique is commonly used to solve problems involving sorted array, where a set of elements needs to be found that satisfy certain constrains. This approach is efficient in scenarios such as finding a pair that sums to a target or reversing an array or string. In the two simple two pointers technique, two pointers \u0026ndash; typically labeled \u0026ldquo;left\u0026rdquo; and \u0026ldquo;right\u0026rdquo; \u0026ndash; are initialized and move in a specific direction based on the problem\u0026rsquo;s requirements.","title":"Coding Patterns"},{"content":"Introduction to Databases A database is a collection of data that is stored, managed, and accessed electronically. It typically contains one or more tables, which resemble Excel or Google sheets, with data organized into rows and columns. As the number of tables grows, managing the database can become complex, making it essential to design a scalable and maintainable strucutre.\nDatabases can be broadly categorized into two types: Relational database, primarily used for real-time data updates and transactions, and data warehouse, optimized for data analysis and reporting purposes.\nData Modeling Data modeling is the process of creating a conceptual representation of data structures, relationships, and rule to meet business requirements. It serves as a blueprint for designing and managing a database.\nThere are three types of data models: conceptual, logical, and physical. The conceptual data model provides a high-level overview, specifying relationships between objects without technical details. The logical data model refine the conceptual data model by adding more detail, such as fields for each object. The physical data model describe the internal schema of the database, including table structures, storage details, and implementation specifics.\n--- title: Conceptual Data Model --- erDiagram Customer ||--o{ Order : places Order ||--|{ Product : contains --- title: Logical Data Model --- erDiagram Customer { int customerId string name string email } Order { int orderId date orderDate float totalAmount } Product { int productId string productName float price } Customer ||--o{ Order : places Order ||--|{ Product : contains --- title: Physical Data Model --- erDiagram Customer { int customerId PK varchar name varchar email } Order { int orderId PK date orderDate float totalAmount int customerId FK } Product { int productId PK varchar productName decimal price } OrderItem { int orderItemId PK int orderId FK int productId FK int quantity } Customer ||--o{ Order : places Order ||--|{ OrderItem : includes OrderItem ||--|{ Product : contains Example: University Enrollment Management System Entities In database design, an entity is a distinct object that typically represents real-world objects, events, or concepts. Entities are represented as tables in a relational database, and they are similar to classes in object-oriented design. Each row in the table represents an instance of the entity. Each entity has attributes that describe its characteristics. For example, a Student entity may have attributes like student_id, first_name, last_name, and date_of_birth, among others. Entities can be related to one another, and these relationships are often captured using foreign keys or relationship tables, which link entities together based on logical associations. For example, a Student might be linked to a Course through an enrollment relationship.\nIdentifying Entities Identifying entities in database design is a crucial step, as entities form the foundation of a database. A useful approach for identifying entities is to clarify the design objectives and look for nouns in the objective statement. For example, consider the University Enrollment Management System. The objective statement might be:\n\u0026ldquo;The University Enrollment Management System\u0026rdquo; is designed to help a university track enrolled students, the subjects they are taking, and the teachers assigned to those subjects\u0026quot;.\nIn this sentence, the nouns university, student, subject, and teacher are potential entities, as they represent key objects or concepts that the system needs to track.\n--- title: Identifying Entities --- erDiagram UNIVERSITY STUDENT erDiagram TEACHER SUBJECT Defining Attributes In database design, an attribute describes the characteristics of an entity. In a relational database, attributes are typically represented as columns in a table. Defining entity attributes is a crucial step in database design, as it ensures that the entity captures all the necessary details required by the system. When defining attributes, it\u0026rsquo;s important to consider what properties or characteristics the entity possesses.\nFor example, in a University Enrollment Management System, the Student entity might have attributes like first_name, last_name, date_of_birth, and address. After identifying the necessary attributes, the next step is to specify the approapriate data type for each attribute. For instance, attributes like first_name, last_name, and address would typically use the TEXT data type, while the date_of_birth attribute would be defined with the DATE data type.\n--- title: Defining Attributes --- erDiagram UNIVERSITY { string name string address } STUDENT { string first_name string last_name date date_of_birth string address } erDiagram SUBJECT { string subject_name string category string students_enrolled } TEACHER { string first_name string last_name date date_of_birth string address string subject_taught } Normalization Normalization in database design is the process of organizing the attributes of entities and their relationships to reduce data redundency, avoid operational anomalies, and improve data integrity. Normalization involves decomposing a large, complex database into smaller, simpler tables while preserving the relationships between entities. This decomposition follows a set of rules called normal forms. In real-world database design, the three most commonly used normal normal forms are First Normal Form (1NF), Second Normal Form (2NF), and Third Normal Form (3NF).\nFirst Normal Form First Normal Form (1NF) is a property of a relational database table that ensures the table is structured properly. It follows the following conditions:\nEach column must contain atomic values, meaning that the value in a field should be indivisible and not contain sets or lists of values. Each row must be unique, which can be achieved by using a primary key to uniquely identify each record. All values in single column should be of the same data type. A Primary Key is a column (or a set of columns) in a relational database table that uniquely identifies each row in that table. It satisfies the following conditions:\nThe value in the primary key must be unique for each row. The value in the primary key must not be null for any record. The value in the primary key should generally be immutable, meaning it should not change once assigned. When designing tables, assess if any combination of columns can be used to uniquely identify a record. If such a combination exists, those columns can form the primary key. If no suitable combination is found, create a new column to serve as the primary key.\nA primary key can be a set of columns when a single column is not sufficient to uniquely identify a row. For example, in the following table, neither the StudentID nor the CourseID alone can uniquely identify a row, because a student might enroll mutiple courses, and a course can have multiple students. However, the combination of both columns can uniquely identify each enrollment record.\nStudentID CourseID EnrollmentDate 1 CS101 2024-01-01 1 MATH101 2024-01-02 2 CS101 2024-01-03 1NF: Student In the following Student table, there is no single field that can uniquely identify a row. Therefore, it is necessary to add a new field. such as StudentID, to ensure each row has a unique identifier. Additionally, the Address field may contain multiple values, such as unit number, street number, street name, suburb, city, state, country, and postcode. To comply with the First Normal Form (1NF), the Address firld must be divided into multiple separate columns, ensuring that each column contains only atomic values.\n--- title: Violation of 1NF - Student --- erDiagram STUDENT { string first_name string last_name date date_of_birth string address } --- title: Comply with 1NF - Student --- erDiagram STUDENT { number student_id PK string first_name string last_name date date_of_birth number unit_number number street_number string street_name string suburb string city string state string country string postcode } 1NF: Subject --- title: Violation of 1NF - Subject --- erDiagram SUBJECT { string subject_name string category string students_enrolled } --- title: Comply with 1NF - Subject --- erDiagram SUBJECT { number subject_id PK string subject_name string category string students_enrolled } 1NF: Teacher --- title: Violation of 1NF - Teacher --- erDiagram TEACHER { string first_name string last_name date date_of_birth string address string subject_taught } --- title: Comply with 1NF - Teacher --- erDiagram TEACHER { number teacher_id PK string first_name string last_name date date_of_birth number unit_number number street_number string street_name string suburb string city string state string country string postcode string subject_taught } 1NF: University --- title: Violation of 1NF - University --- erDiagram UNIVERSITY { string name string address } --- title: Comply with 1NF - University --- erDiagram UNIVERSITY { number university_id PK string name number unit_number number street_number string street_name string suburb string city string state string country string postcode } Second Normal Form The Second Normal Form (2NF) in database design is a level of normalization that builds upon the First Normal Form (1NF). A table is in 2NF if every non-key attribute is fully functionally dependent on the entire primary key, not just part of it, particularly in tables with composite primary keys (a key made up of two or more columns).\nRelationships Relationship in database design refers to the association between different entities (tables) in a database. It defines how data in one table is related to data in another table, enabling efficient organization and retrival of data. Relationships are established through a foreign key, which is a column in one table that references the primary key of another table. There are four main types of relationships: One-to-One (1:1), One-to-Many (1:N), Many-to-Many (N:M), and Self-Reference.\nIn a One to One relationship, each record in one table is related to exactly one record in another table. For example, consider a Person table and a Passport table, where each person has one unique passport, and each passport is associated with only one person. This type of relationship is relatively rare in real-world database design.\nThe One to Many relationship is the most common type in real-world database design. In a 1:N relationship, one record in a table can be linked to multiple records in another table. For example, in a Department table and an Employee table, one department can have many employees, but each employee blongs to exactly one department. This is a typical relational model for most business applications.\nThe Many-to-Many relationship is common but often requires an intermediary table to properly represent the association. In an N:M relationship, multiple records in one table can be asoociated with multiple records in another table. For instance, in a Student table and a Course table, a student can enroll in many courses, and each course can have many students enrolled. This relationship is typically handled by a joining table, such as Student_Course.\nIn a Self-Referencing relationship, a table is related to itself. In other words, a record in the table is associated with another record in the same table. For example, in an Employee table, each employee has a Manager, and that manager may also have a manager. This type of relationship is useful for representing hierarchical structures, such as organizational charts.\nIn database design, a foreign key is a column that references the primary key of another table. It is used to establish a relationship between two tables, ensuring referential integrity and maintaining consistent data across the database.\n2NF: Subject \u0026amp; Category In the following Subject table, the subject_name is dependent on the primary key subject_id, but the category is not fully dependent on the primary key, which violates 2NF. To resolve this issue, a new Category table should be created with two fields: category_id as the primary key and subject_id as a foreign key. The two tables have a One-to-Many relationship, where each category can have many subjects, while each subject bleongs to exactly one category.\n--- title: Violation of 2NF - Subject --- erDiagram SUBJECT { number subject_id PK string subject_name string category } --- title: Comply with 2NF - Subject --- erDiagram SUBJECT { number subject_id PK string subject_name number category_id FK } CATEGORY { number category_id PK string category_name } CATEGORY ||--|{ SUBJECT : \"\" 2NF: Student \u0026amp; Subject In the following Subject table, the subject_id and students_enrolled create a Many-to-Many relationship. However, relational databases should not represent Many-to-Many relationships directly in s single table. This is because a single table cannot handle multiple instances of related data (such as multiple students enrolled in multiple subjects) within a single field. To resolve this issue, a junction table is introduced. It breaks down the Many-to-Many relationship into two One-to-Many relationships, ensuring data integrity and normalization.\n--- title: Violation of 2NF - Subject --- erDiagram SUBJECT { number subject_id PK string subject_name string students_enrolled } subject_id subject_name students_name 1 Math Alice, Bob, Charlie 2 History David, Emily, Frank, Grace 3 Science Helen, Ian In the above table, the students_enrolled field violates First Normal Form (1NF), which requires each column to contain only atomic values. Additionally, this design leads to data redundancy. For example, if the student Alice enrolls in multiple courses such as Math, History, and Science. her name will be repeated in each row, causing unnecessary duplication of data.\nFurthermore, this design makes data manipulation more complex. For instance, when a student drops a course or a new student enrolls in a course, the list of students in the students_enrolled column must be manually updated, which is error-prone and inefficient.\n--- title: Comply with 2NF - Subject --- erDiagram SUBJECT { number subject_id PK string subject_name } STUDENT { number student_id PK string students_enrolled } ENROLLMENT { number subject_id FK number student_id FK } SUBJECT ||--|{ ENROLLMENT : \"has\" STUDENT ||--|{ ENROLLMENT : \"enrolled in\" Comply with 2NF: Real-World Example 2NF: Teacher --- title: Violation of 2NF - Teacher (subject_taught) --- erDiagram TEACHER { number teacher_id string first_name string last_name date date_of_birth string subject_taught } --- title: Comply with 2NF - Teacher --- erDiagram TEACHER { number teacher_id string first_name string last_name date date_of_birth } SUBJECT { number subject_id PK string subject_name number category_id FK number teacher_id FK } TEACHER ||--|{ SUBJECT : \"teaches\" 2NF: University --- title: Comply with 2NF - UNIVERSITY --- erDiagram UNIVERSITY { number university_id PK string name } SUBJECT { number subject_id PK string subject_name number category_id FK number teacher_id FK number university_id FK } UNIVERSITY ||--|{ SUBJECT : \"\" Third Normal From Third Normal Form (3NF) is a level of normalization that satisfies Second Normal Form (2NF) and eliminates transitive dependencies. In simpler terms, a non-key attribute in a table should not depend on another non-key attrubute. For example, if A $\\rightarrow$ B and B $\\rightarrow$ C, then A $\\rightarrow$ C, which means C should be moved to a separate table to avoid redundency. This process helps reduce data redundency and improves the efficiency of relational databases.\n3NF: Student In the following Student table, the non-key attributes (unit_number, street_number, street_name, suburb, city, state, country, and postcode) are not directly dependent on the primary key student_id; instead, they depend on the student\u0026rsquo;s address. This results in a transitive dependency, which violates 3NF. Furthermore, since multiple students may share the same address, these address attributes will be repeated for each student, leading to data redundency.\n--- title: Violation of 3NF - Student --- erDiagram STUDENT { number student_id PK string first_name string last_name date date_of_birth number unit_number number street_number string street_name string suburb string city string state string country string postcode } --- title: Comply with 3NF - Student --- erDiagram STUDENT { number student_id PK string first_name string last_name date date_of_birth number address_id FK } ADDRESS { number address_id PK number unit_number number street_number string street_name string suburb string city string state string country string postcode } STUDENT ||--|{ ADDRESS : \"\" 3NF: Teacher --- title: Comply with 3NF - Teacher --- erDiagram TEACHER { number teacher_id PK string first_name string last_name date date_of_birth number address_id FK } ADDRESS { number address_id PK number unit_number number street_number string street_name string suburb string city string state string country string postcode } TEACHER ||--|{ ADDRESS : \"\" 3NF: University --- title: Comply with 3NF - University --- erDiagram UNIVERSITY { number university_id PK string name number address_id FK } ADDRESS { number address_id PK number unit_number number street_number string street_name string suburb string city string state string country string postcode } UNIVERSITY ||--|{ ADDRESS : \"\" Design Considerations Determine Data Types \u0026amp; Precision Determining data types and precision in database design is crucial for ensuring optimal storage, performance, and accuracy of data. There are typically three steps to determine the apprpriate data type and precision for a field:\nIdentifying the nature of the field: Determine the type of data the field will store—whether it\u0026rsquo;s numeric, string, or data/time. For example, the student_id field might be of type INT, while the first_time field might of type CHAR or VARCHAR. Choose the smallest sufficient data type: Select the samllest data type that can accommodate the required values. For example, if a field\u0026rsquo;s values range from -128 to 127, use TINYINT instead of INT to optimize performance and storage efficiency. Set precision and scale for numeric values: For numeric fields, it\u0026rsquo;s important to define the precision (total number of digits) and scale (number of digits after the decimal point). For example, a price field should be set to DECIMAL(10,2), which allows for 10 digits in total, with 2 digits after the decimal point. Integrity Constraints Integrity Constraints in database design are rules that ensure the accuracy, consistency, and validity of data. There are several types of integrity constraints, each serving a specific purpose:\nEntity Integrity Entity Integrity ensures that each record in a table is unique and identifiable. This is achieved by setting a column in a table as a primary key. For example, the student_id field must be unique for each record in the Student table.\nCREATE TABLE Student ( student_id INT PRIMARY KEY, first_name VARCHAR(100), last_name VARCHAR(100) ); Referencial Integrity Referencial Integrity ensures that relationships between tables are maintained consistently. Foreign keys enforce this constraint by ensuring that a value in one table corresbonds to a valid value in another table. For example, the student_id field in the Enrollment table serves as a foreign key referencing the primary key student_id in the Student table.\nCREATE TABLE Enrollment ( enrollment_id INT PRIMARY KEY, student_id INT, course_id INT, FOREIGN KEY (student_id) REFERENCES Students(student_id) ); Domain Integrity Domain Integrity ensures that the data entered in a column matches the defined data type, format, and range. This is enforced using data types. default values. and check constraints. For example, the price field should only store positive values.\nCREATE TABLE Product ( product_id INT PRIMARY KEY, product_name VARCHAR(100), price DECIMAL(10, 2) CHECK (price \u0026gt; 0) ); User-Defined Integrity User-defined integrity enforces business rules specific to the application or domain. For instance, in the Enrollment table, the combination of student_id and course_id should be unique to prevent a student from enrolling in the same course more than once.\nCREATE TABLE Enrollment ( enrollment_id INT PRIMARY KEY, student_id INT, course_id INT, UNIQUE (student_id, course_id) ); Null Integrity Null integrity ensures that certain fields cannot store NULL values. This is enforced by defining the column with the NOT NULL constraint. For example, the student_id field in the Student table must not be NULL because it is used to identify each record.\nCREATE TABLE Student ( student_id INT PRIMARY KEY NOT NULL, first_name VARCHAR(100) NOT NULL, last_name VARCHAR(100) NOT NULL ); ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/database/database-design/1-database-design/","summary":"Introduction to Databases A database is a collection of data that is stored, managed, and accessed electronically. It typically contains one or more tables, which resemble Excel or Google sheets, with data organized into rows and columns. As the number of tables grows, managing the database can become complex, making it essential to design a scalable and maintainable strucutre.\nDatabases can be broadly categorized into two types: Relational database, primarily used for real-time data updates and transactions, and data warehouse, optimized for data analysis and reporting purposes.","title":"Database Design"},{"content":"Recursion Recursion is a programming technique where a function repeatedly calls itself until it reaches a base case, whcih stops the recursion and allows it to return a result. It is a way of breaking down complex problems into smaller, simpler subproblems that are eaiser to solve.\nHead Recursion Head Recursion is a type of recursion where a function makes its recursive call first, immediately after checking the base case, and performs all other operations only after the recursive call returns.\nSHOW CODE: Head Recursion Head Recursion void printNumbers(int n) { if (n == 0) { return; // Base case } printNumbers(n - 1); // Recursive call printf(\"%d\\n\", n); // Processing after recursion } Call Stack Operation Current Value of n headRecursion(3) Call function 3 headRecursion(2) Call function 2 headRecursion(1) Call function 1 headRecursion(0) Base case, exit 0 Unwinding begins: printf(1) Print 1 1 printf(2) Print 2 2 printf(3) Print 3 3 Tail Recursion Tail Recursion is a type of recursion where a function makes its recursive call as the last operation in its body. with no further operations after the call. This type of recursion can be optimized by the compiler into an iterative loop through tail call optimization (TCO), which help reduce memory consumption by the reusing the stack frame.\nSHOW CODE: Tail Recursion Tail Recursion void tailRecursion(int n) { if (n \u003e 0) { printf(\"%d \", n); // Operation first tailRecursion(n - 1); // Recursive call at the end } } Call Stack Operation Current Value of n tailRecursion(3) Print 3 3 tailRecursion(2) Print 2 2 tailRecursion(1) Print 1 1 tailRecursion(0) Base case, exit 0 Tail recursion is generally perfered for performance when recursion depth is large because it can be optimized into an iterative process.\nSHOW CODE: Tail Recursion Optimization Tail Recursion Optimization void tailRecursionOptimized(int n) { while (n \u003e 0) { printf(\"%d \", n); // Operation first n--; // Decrement n, same as `tailRecursion(n - 1)` } } In the above code, optimized Loop replaces recursion with a loop, ensuring only a single stack frame is used.\nConditions for Tail Recursion: The recursive call must be the last operation in the function, and its result must be immediately returned without any further computation after the call.\nSHOW CODE: Tail Recursive Function Tail Recursive Function // Tail recursive function to calculate factorial int factorialTailRecursion(int n, int accumulator) { if (n == 0) { return accumulator; // Base case: return accumulated result } return factorialTailRecursion(n - 1, accumulator * n); // Recursive call is the last operation } SHOW CODE: Non-tail Recursive Function Non-tail recursive // Non-tail recursive function to calculate factorial int factorialNonTailRecursion(int n) { if (n == 0) { return 1; // Base case } return n * factorialNonTailRecursion(n - 1); // Recursive call is not the last operation } Tree Recursion Tree recursion is a type of recursion in which a function makes multiple recursive calls to itself in its body, it creates a tree-like data structure, as each call can branch into multiple additional calls.\nSHOW CODE C public int fib(int n) { if (n \u003c= 1) { return n; } return fib(n - 1) + fib(n - 2); } Recursion Tree Analysis:\n--- title: Recursion Tree Analysis - fibonacci sequence --- graph TD L0((\"fib\\(5\\)\")) --\u003e L1((\"fib\\(4\\)\")) L0 --\u003e L2((\"fib\\(3\\)\")) L1 --\u003e L3((\"fib\\(3\\)\")) L1 --\u003e L4((\"fib\\(2\\)\")) L2 --\u003e L5((\"fib\\(2\\)\")) L2 --\u003e L6((\"fib\\(1\\)\")) L3 --\u003e L7((\"fib\\(2\\)\")) L3 --\u003e L8((\"fib\\(1\\)\")) L4 --\u003e L9((\"fib\\(1\\)\")) L4 --\u003e L10((\"fib\\(0\\)\")) L5 --\u003e L11((\"fib\\(1\\)\")) L5 --\u003e L12((\"fib\\(0\\)\")) L7 --\u003e L13((\"fib\\(1\\)\")) L7 --\u003e L14((\"fib\\(0\\)\")) Array An array is a data structure that stores a collection of elements of the same type in a fixed-size, continguous block of memory. Arrays can be categorized into two types: static arrays and dynamic arrays.\nA static array has a fixed size that cannot be changed after its declaration. Memory for a static array is allocated at compile time, and its size must be explicitly specified.\nIn contrast, a dynamic array allows its size to be adjusted during runtime, enabling it to grow or shrink as needed. Unlike static arrays, the size of a dynamic array does not need to be specified at the time of declaration, and memory is allocated dynamically from the heap.\nImplementation of Static Arrays Implementation of Dynamic Arrays Compiler\u0026rsquo;s Memory Layout for Arrays The address of an array element is determined at runtime. Array elements are stored in a continguous block of memory, and the compiler calculates each element\u0026rsquo;s address using its index and the size of each element.\n1-Dimentional Array Element Access Formula (0-based index): $\\text{Addr}_{A[i]} = B + i \\times W$\nB: Base Address i: Zero-based Index of Each Element W: Size of Each Element SHOW CODE C #include \u0026lt;stdio.h\u0026gt; int main() { int arr[5] = {10, 20, 30, 40, 50}; for (int i = 0; i \u003c 5; i++) { void *addr_i = (void *) arr + (i * sizeof(int)); printf(\"Element at index %d: %d \\t Address: %p\\n\", i, arr[i], addr_i); } return 0; } SHOW OUTPUT Output Element at index 0: 10 Address: 0x7ff7bb0b7170 Element at index 1: 20 Address: 0x7ff7bb0b7174 Element at index 2: 30 Address: 0x7ff7bb0b7178 Element at index 3: 40 Address: 0x7ff7bb0b717c Element at index 4: 50 Address: 0x7ff7bb0b7180 2-Dimentional Array Element Access Formula (Row Major Order): $\\text{Addr}_{A[i][j]} = \\text{B} + [(i \\times \\text{C}) + j] \\times \\text{W}$\nB: Base Address i: Zero-based Row Index of Each Element j: Zero-based Column Index of Each ELement C: Number of Columns W: Size of Each Element SHOW CODE C #include \u0026lt;stdio.h\u0026gt; int main() { int arr[2][3] = {{1, 2, 3}, {4, 5, 6}}; for (int i = 0; i \u003c 2; i++) { for (int j = 0; j \u003c 3; j++) { void *addr_ij = (void *) \u0026arr + (i * 3 + j) * sizeof(int); printf(\"Element at [%d][%d]: %d, Address: %p\\n\", i, j, arr[i][j], addr_ij); } } return 0; } SHOW OUTPUT Output Element at [0][0]: 1, Address: 0x7ff7b2c64170 Element at [0][1]: 2, Address: 0x7ff7b2c64174 Element at [0][2]: 3, Address: 0x7ff7b2c64178 Element at [1][0]: 4, Address: 0x7ff7b2c6417c Element at [1][1]: 5, Address: 0x7ff7b2c64180 Element at [1][2]: 6, Address: 0x7ff7b2c64184 Why do most compilers use 0-based indexing? Take a 1-dimentional array as an example, the element access formula for a 0-based index is $\\text{Addr}_{A[i]} = B + i \\times W$. This formula requires two operations (multiplication and addition) to access each element in the array.\nIn contract, the formula for 1-based indexing is $\\text{Addr}_{A[i]} = B + (i - 1) \\times W$. This requires three operations (multiplication. subtraction, and addition). Compared to 0-based indexing, 1-based indexing introduces one additional operation, which becomes a significant overhead when dealing with large size arrays.\nString Matrix Linked List Stack Queue A Queue is a linear data structure that follows the First In, First Out (FIFO) principle, meaning elements are added to the back and removed from the front. There are four main types of queues: Simple Queue, Circular Queue, Double-Ended Queue (Deque), and Priority Queue.\nSimple Queue A Simple Queue is a basic type of queue data structure in which elements are added to the back and removed from the front, following the First In, First Out (FIFO) principle.\nImplementation of Simple Queue Array with a single pointer SHOW CODE Java class SimpleQueue { private final int[] queue; private final int capacity; private int rear; public SimpleQueue(int capacity) { this.queue = new int[capacity]; this.capacity = capacity; this.rear = -1; } public boolean isEmpty() { return rear == -1; } private boolean isFull() { return rear == capacity - 1; } public int size() { return rear + 1; } public void enqueue(int element) { if (this.isFull()) { System.out.println(\"Queue is full.\"); } else { rear++; queue[rear] = element; } } public int dequeue() { if (this.isEmpty()) { System.out.println(\"Queue is empty.\"); return -1; } int frontElement = queue[0]; // Shift all elements to the left for (int i = 0; i \u003c rear; i++) { queue[i] = queue[i + 1]; } rear--; return frontElement; } public int peek() { if (this.isEmpty()) { System.out.println(\"Queue is empty.\"); return -1; } return queue[0]; } } public class Main { public static void main(String[] args) { SimpleQueue queue = new SimpleQueue(5); queue.enqueue(10); queue.enqueue(20); queue.enqueue(30); System.out.println(\"Front element: \" + queue.peek()); // Expected: 10 System.out.println(\"Dequeued: \" + queue.dequeue()); // Expected: 10 queue.enqueue(40); queue.enqueue(50); System.out.println(\"Queue size: \" + queue.size()); // Expected: 4 System.out.println(\"Dequeued: \" + queue.dequeue()); // Expected: 20 } } The implementation of a queue using an array with a single pointer (rear) is inefficient for deletion because the remaining elements need to be shifted left after every dequeue operation.\nArray with two pointers SHOW CODE Java class SimpleQueue { private final int[] queue; private final int capacity; private int front; private int rear; public SimpleQueue(int capacity) { this.capacity = capacity; queue = new int[capacity]; this.front = -1; this.rear = -1; } public boolean isEmpty() { return front == -1; } private boolean isFull() { return rear + 1 == capacity; } public int size() { if (this.isEmpty()) { return 0; } return rear - front + 1; } public void enqueue(int element) { if (this.isFull()) { System.out.println(\"Queue is full.\"); } else { // Set front to 0 when the first element is added if (front == -1) { front = 0; } rear++; queue[rear] = element; } } public int dequeue() { if (this.isEmpty()) { System.out.println(\"Queue is empty.\"); return -1; } else { int frontElement = queue[front]; // Reset both pointers to -1 when the queue has only one element if (front == rear) { front = -1; rear = -1; } else { // Move front to the next element front++; } return frontElement; } } public int peek() { if (this.isEmpty()) { System.out.println(\"Queue is empty.\"); return -1; } else { return queue[front]; } } } public class Main { public static void main(String[] args) { SimpleQueue queue = new SimpleQueue(5); queue.enqueue(10); queue.enqueue(20); queue.enqueue(30); System.out.println(\"Front element: \" + queue.peek()); // Expected: 10 System.out.println(\"Dequeued: \" + queue.dequeue()); // Expected: 10 queue.enqueue(40); queue.enqueue(50); System.out.println(\"Queue size: \" + queue.size()); // Expected: 3 System.out.println(\"Dequeued: \" + queue.dequeue()); // Expected: 20 } } Implementing a queue using an array with two pointers (front and rear) is more efficient for deletion compared to using a single pointer (rear), as it eliminates the need to shift elements to the left after each dequeue operation. However, this approach has drawback: the space in front of the front pointer cannot be reused until the array is empty, leading to potential wasted memory.\nLinked List with a pointer SHOW CODE Java class Node { int data; Node next; public Node(int data) { this.data = data; this.next = null; } } class SimpleQueue { private Node front; private int size; public SimpleQueue() { front = null; size = 0; } // Check if the queue is empty public boolean isEmpty() { return size == 0; } // Get the current size of the queue public int size() { return size; } // Display the elements of the queue public void display() { if (isEmpty()) { System.out.println(\"Queue is empty.\"); return; } // Traverse through the queue and print its elements Node temp = front; // Use StringBuilder to efficiently build the string StringBuilder builder = new StringBuilder(); while (temp != null) { builder.append(temp.data).append(\"\u003c-\"); temp = temp.next; } // Remove the last \"\u003c-\" (extra arrow at the end) builder.setLength(builder.length() - 2); System.out.println(builder); } // Add an element to the rear (end) of the queue public void enqueue(int data) { Node node = new Node(data); // If the queue is empty, the new node becomes the front of the queue if (isEmpty()) { front = node; } else { Node temp = front; // Traverse the list to find the last node (rear of the queue) while (temp.next != null) { temp = temp.next; } temp.next = node; // Link the new node at the end of the queue } size++; // Increment the size of the queue } // Remove and return the element from the front of the queue public int dequeue() { if (isEmpty()) { throw new IllegalStateException(\"Queue is empty.\"); } int dequeued = front.data; front = front.next; size--; return dequeued; } // Return the element from the front of the queue without removing it public int peek() { if (isEmpty()) { throw new IllegalStateException(\"Queue is empty.\"); } return front.data; } } public class Main { public static void main(String[] args) { SimpleQueue queue = new SimpleQueue(); // Enqueue some elements into the queue queue.enqueue(10); queue.enqueue(20); queue.enqueue(30); queue.enqueue(40); System.out.println(\"Queue after enqueuing elements:\"); queue.display(); // Display the current state of the queue // Dequeue two elements and print them System.out.println(\"Dequeued: \" + queue.dequeue()); System.out.println(\"Dequeued: \" + queue.dequeue()); System.out.println(\"Queue after dequeuing elements:\"); queue.display(); // Display the queue after dequeuing elements // Peek at the front element without removing it System.out.println(\"Peek front: \" + queue.peek()); // Print the current size of the queue System.out.println(\"Queue size: \" + queue.size()); } } Linked List with two pointers SHOW CODE Java // Node class representing each element in the queue class Node { int data; Node next; public Node(int data) { this.data = data; this.next = null; } } // SimpleQueue class implementing queue operations using a linked list class SimpleQueue { private Node front; private Node rear; private int size; // Constructor to initialize the queue public SimpleQueue() { front = rear = null; size = 0; } // Check if the queue is empty public boolean isEmpty() { return size == 0; } // Get the size of the queue public int size() { return size; } // Display the elements in the queue public void display() { if (isEmpty()) { System.out.println(\"Queue is empty.\"); return; } // Build a string representation of the queue StringBuilder builder = new StringBuilder(); Node temp = front; while (temp != null) { builder.append(temp.data).append(\"\u003c-\"); temp = temp.next; } // Remove the trailing \" \u003c- \" builder.setLength(builder.length() - 2); System.out.println(builder); } // Enqueue: Add an element to the rear of the queue public void enqueue(int data) { Node newNode = new Node(data); // If the queue is empty, both front and rear point to the new node if (isEmpty()) { front = rear = newNode; } else { // Add new node at the end and update the rear pointer rear.next = newNode; rear = newNode; } size++; } // Dequeue: Remove and return the element from the front of the queue public int dequeue() { if (isEmpty()) { throw new IllegalStateException(\"Queue is empty.\"); } // Get the front element and update the front pointer int dequeuedData = front.data; front = front.next; // If the queue becomes empty, reset the rear to null if (front == null) { rear = null; } size--; return dequeuedData; } // Peek: Get the front element without removing it public int peek() { if (isEmpty()) { throw new IllegalStateException(\"Queue is empty.\"); } return front.data; } } // Main class to test the queue implementation public class Main { public static void main(String[] args) { SimpleQueue queue = new SimpleQueue(); // Enqueue elements into the queue queue.enqueue(10); queue.enqueue(20); queue.enqueue(30); queue.enqueue(40); // Display the queue after enqueuing elements System.out.println(\"Queue after enqueuing elements:\"); queue.display(); // Dequeue elements from the queue System.out.println(\"Dequeued: \" + queue.dequeue()); System.out.println(\"Dequeued: \" + queue.dequeue()); // Display the queue after dequeuing elements System.out.println(\"Queue after dequeuing elements:\"); queue.display(); // Peek the front element and show the queue size System.out.println(\"Peek front: \" + queue.peek()); System.out.println(\"Queue size: \" + queue.size()); } } Circular Queue A Circular Queue is a variation of the standard queue data structure that reuses the space freed by dequeue operations by connecting the last position back to the front position. It overcomes the limitation of a simple fixed-size queue, where the space at the front of the queue cannot be reused after dequeueing elements.\nArray Implementation SHOW CODE Java class CircularQueue { private final int[] queue; private int front; private int rear; private final int capacity; private int size; public CircularQueue(int capacity) { this.capacity = capacity; queue = new int[capacity]; front = rear = -1; // Initialize both front and rear as -1 to indicate the queue is empty size = 0; } // Check if the queue is empty public boolean isEmpty() { return size == 0; } // Check is the queue is full public boolean isFull() { return size == capacity; } // Get the current size of the queue public int size() { return size; } // Display the elements of the queue public void display() { if (isEmpty()) { System.out.println(\"Queue is empty.\"); return; } StringBuilder builder = new StringBuilder(); for (int i = 0; i \u003c size; i++) { builder.append(queue[(front + i) % capacity]); if (i != size - 1) { builder.append(\"\u003c-\"); } } System.out.println(builder); } public void enqueue(int data) { if (isFull()) { throw new IllegalStateException(\"Queue is full.\"); } if (isEmpty()) { front = 0; } // Move the rear pointer in a circular manner rear = (rear + 1) % capacity; // Add the data to the rear of the queue queue[rear] = data; // Increase the size size++; } public int dequeue() { if (isEmpty()) { throw new IllegalStateException(\"Queue is empty.\"); } int dequeued = queue[front]; if (front == rear) { // If the queue become empty, reset both front and rear to -1 front = rear = -1; } else { // Move the front pointer in a circular manner front = (front + 1) % capacity; } size--; // Decrease the size return dequeued; } public int peek() { if (isEmpty()) { throw new IllegalStateException(\"Queue is empty.\"); } return queue[front]; } } public class Main { public static void main(String[] args) { CircularQueue queue = new CircularQueue(5); queue.enqueue(10); queue.enqueue(20); queue.enqueue(30); queue.enqueue(40); queue.enqueue(50); System.out.println(\"Queue after enqueuing 5 elements:\"); queue.display(); // Attempt to enqueue an element to a full queue (throws exception) try { queue.enqueue(60); } catch (IllegalStateException e) { System.out.println(e.getMessage()); } // Dequeue two elements System.out.println(\"Dequeued: \" + queue.dequeue()); System.out.println(\"Dequeued: \" + queue.dequeue()); System.out.println(\"Queue after dequeuing 2 elements:\"); queue.display(); // Enqueue two more elements queue.enqueue(60); queue.enqueue(70); System.out.println(\"Queue after enqueuing 2 more elements:\"); queue.display(); // Peek at the front element System.out.println(\"Front element: \" + queue.peek()); // Display the current size of the queue System.out.println(\"Queue size: \" + queue.size()); } } Linked List Implementation SHOW CODE Java class Node { int data; Node next; public Node(int data) { this.data = data; this.next = null; } } class CircularQueue { private Node front; private Node rear; private int size; public CircularQueue() { front = rear = null; size = 0; } // Check if the queue is empty public boolean isEmpty() { return size == 0; } // Get the size of the queue public int size() { return size; } // Display the elements of the queue public void display() { if (isEmpty()) { System.out.println(\"Queue is empty.\"); return; } Node temp = front; StringBuilder builder = new StringBuilder(); do { builder.append(temp.data).append(\"\u003c-\"); temp = temp.next; } while (temp != front); // Loop until reach the front newNode again builder.setLength(builder.length() - 2); System.out.println(builder); } // Add an element to the queue public void enqueue(int data) { Node newNode = new Node(data); // Both front and rear will point to the new node if queue is empty if (isEmpty()) { front = rear = newNode; } else { rear.next = newNode; // Connect the current rear to the new node rear = newNode; // Move the rear to the new node } rear.next = front; // Connect the rear's next to the front size++; } // Remove the front element in the queue public int dequeue() { if (isEmpty()) { throw new IllegalStateException(\"Queue is empty\"); } int dequeued = front.data; // Set both front and rear to null if there is only one element if (front == rear) { front = rear = null; } else { front = front.next; // Move the front node to the next rear.next = front; // Maintain the circular link } size--; return dequeued; } // Get the front element without removing it public int peek() { if (isEmpty()) { throw new IllegalStateException(\"Queue is empty.\"); } return front.data; } } public class Main { public static void main(String[] args) { CircularQueue queue = new CircularQueue(); // Enqueue elements queue.enqueue(10); queue.enqueue(20); queue.enqueue(30); queue.enqueue(40); // Display queue elements System.out.println(\"Queue after enqueuing elements:\"); queue.display(); // Dequeue elements System.out.println(\"Dequeued: \" + queue.dequeue()); System.out.println(\"Dequeued: \" + queue.dequeue()); // Display queue elements after dequeueing System.out.println(\"Queue after dequeuing elements:\"); queue.display(); // Peek front element System.out.println(\"Peek front: \" + queue.peek()); // Display the size of the queue System.out.println(\"Queue size: \" + queue.size()); } } Double Ended Queue Priority Queue Tree Graph A graph is a fundamental data structure used to represent the connections or relationships between entities. It consists of vertices (also called node) and edges (also called arcs). A vertex represents a single entity in the graph, while an edge represents a connection or relationship between two vertices. Edges may have additional properties, such as weight (to indicate the cost or distance of the connection) or direction (to indicate the direction of the relationship).\nTypes of Graph Undirected Graph vs. Directed Graph In an undirected graph, the connection between two vertices is bidrectional. For example, if there is an edge between vertex A and vertex B, traversal is possible from A to B and from B to A. In contrast, in a directed graph, the relationships are one-way. For instance, if there is an edge from vertex A to vertex B, traversal is possible from A to B, but not from B to A unless there is a separate edge in the opposite direction.\nUnweighted Graph vs. Weighted Graph In an unweighted graph, the relationships between vertices have no additional properties, and all edges are treated equally. In contrast, a weighted graph assigns a weight to each node, which can represent attributes such as distance, time, cost, eetc. The weight provides more information about the connection between vertices and is often used in problems like shortest path or network flow.\nCyclic Graph vs. Acyclic Graph A cyclic graph contains at least one cycle, which is a path that starts and ends at the same vertex. In contrast, an acyclic graph doest not contain any cycles. A special case of an acyclic graph is the directed acyclic graph (DAG), which has directed edges and no cycles.\nConnected Graph vs. Disconnected Graph A connected graph is a graph in which there is a path between every pair of vertices. In contrast, a disconnected graph is a graph where at least one pair of vertices is not connected by any path.\nGraph Terminology The degree of a vertex is the number of edges incident to that vertex. In an undirected graph, the degree is simply the number of edges connected to the vertex. In a directed graph, the degree is the sum of the in-degree (number of incoming edges) and the out-degree (number of outgoing edges) of the vertex.\nA path is a sequence of vertices where each consecutive pair of vertices is connected by an edge.\nA cycle is a path that starts and ends at the same vertex, with no repeated vertices except for the starting or ending vertex. For example, in a cycle with $A \\rightarrow B \\rightarrow C \\rightarrow D \\rightarrow A$, the path starts and ends at the same vertex $A$, but each of the other vertices $(B, C, and D)$ is visited exactly once.\nConnectivity refers to whether there exists a path between any pair of vertices in the graph.\nA subgraph is a graph formd by a subset of the vertices and edges of the original graph.\nA component is a subgraph where there is a path between every pair of vertices in that subgraph.\nGraph Representation Adjacency Matrix An Adjacency Matrix ia a 2-dimentional array where each element at position [i][j] represents an edge between vertex i and j. In a weighted graph, the value at position [i][j] stores the weight of the edge between the two vertices. In an unweight graph, the value at position [i][j] typically stores 1 to indicate an edge exists between the vertices, and 0 to indicate no edge exists. The space complexity of an adjacency matrix is $O(V^2)$, where $V$ is the number of vertices, as it requires a matrix of size $V \\times V$ to represent the graph.\nAdjacency List An Adjacency List is a collection of lists, where each position i stores a list of nerighbors of vertex i. In a weighted graph. each element in the list typically represents a pair (neighbor, weight), where neighbor is a vertex connected to i, and weight is the weight of the edge between i and neighbor. The space complexity of an adjacency list is $O(V + E)$, where $V$ is the number of vertices and $E$ is the number of edges. This is because each vertex has a list of neighbors, and the total number of entries in all lists is proportional to the number of edges.\nEdge List An Edge List is a collection of pairs, where each pair (i, j) represents an edge between vertex i and vertex j. In a weighted graph. each element may also include the weight of the edge. typically represented as (i, j, weight). The space complexity of an edge list is $O(E)$, where $E$ is the number of edges, as each edge is stored as a separate entry in the list.\nGraph Traversal Breadth First Search Breadth-First Search (BFS) explores all the neighbors of a vertex before moving on to their neighbors. It proceeds level by level, ensuring that all vertices at a given distance from the starting vertex are visited before moving on to vertices at a greater distance. BFS is commonly used to find the shortest path in an unweighted graph.\nDepth First Search Depth-First Search (DFS) explores as far as possible alone a branch of the graph before backtracking to explore other branches. It follows a path from the starting vertex to a dead end, then retrace its steps and explores alternative paths. DFS is useful for finding all paths between vertices, detecting cycles, or performing topological sorting in directed acyclic graphs (DAGs).\nSpanning Tree A spanning tree is a subset of a graph that includes all the vertices and contains exactly $V - 1$ edges, where $V$ is the number of vertices in the graph. A connected graph can have multiple spanning trees, whereas a disconnected graph does not have a spanning tree because there is at least one pair of vertices that are not connected, making it impossible to form a tree that spans all the vertices.\nMinimum Spanning Tree (MST) A minimum spanning tree is a type of spanning tree that connects all the vertices of a graph with the smallest possible total edge weight, compared to all other possible spanning trees.\nPrim\u0026rsquo;s Algorithm Prim\u0026rsquo;s Algorithm is used to find the minimum spanning tree (MST) that connects all the vertices of a graph without forming a cycle, while minimizing the total edge weight. This algorithm is efficient for solving problems related to undirected, weighted graphs. The algorithm steps are as follows:\nInitialize an inMST array to track the vertices included in the MST, and a priority queue (min-heap) to process the edges with the smallest weight. Select an arbitrary starting vertex. Add all edges connected to this vertex into the priority queue and mark the vertex as included in the inMST array. Extract the edge with the minimum weight from the priority queue. If the destination vertex of this edge is not yet in the inMST array, include it, and add all edges connected to this newly included vertex (whose destination is not in the MST) to the priority queue. Repeat step 3 until all vertices are included in the MST. SHOW CODE Java import java.util.*; /** * @author Signal Yu * @since 2024-12-1 */ class Edge implements Comparable\u0026lt;Edge\u0026gt; { int src; int dest; int weight; public Edge(int src, int dest, int weight) { this.src = src; this.dest = dest; this.weight = weight; } @Override public int compareTo(Edge other) { // Sort edges based on weight return this.weight - other.weight; } } class Graph { int vertices; int edges; List\u0026lt;List\u0026gt;Edge\u0026gt;\u0026gt; adjacencyList; public Graph(int vertices) { this.vertices = vertices; adjacencyList = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c vertices; i++) { adjacencyList.add(new ArrayList\u0026lt;\u0026gt;()); } } void addEdge(int src, int dest, int weight) { // Add edge for undirected graph Edge edge1 = new Edge(src, dest, weight); Edge edge2 = new Edge(dest, src, weight); adjacencyList.get(src).add(edge1); adjacencyList.get(dest).add(edge2); } void primMST() { // Step 1: Initialize an `inMST` array to track the vertices // included in the MST, and a priority queue (min-heap) to // process the edges with the smallest weight. boolean[] inMST = new boolean[vertices]; Queue priorityQ = new PriorityQueue\u003c\u003e(); // Step 2: Select an arbitrary starting vertex. Add all edges // connected to this vertex into the priority queue and mark // the vertex as included in the `inMST` array. int start = 0; for (Edge edge : adjacencyList.get(start)) { priorityQ.offer(edge); } inMST[start] = true; // Step 4: Repeat step 3 until all vertices are included in the MST. while (!priorityQ.isEmpty()) { // Step 3: Extract the edge with the minimum weight from the // priority queue. If the destination vertex of this edge is // not yet in the `inMST` array, include it, and add all edges // connected to this newly included vertex (whose destination // is not in the MST) to the priority queue. Edge edge = priorityQ.poll(); int u = edge.src, v = edge.dest; if (!inMST[v]) { System.out.println(u + \"---[\" + edge.weight + \"]---\" + v); inMST[v] = true; // Add all edges from the newly included vertex (whose destination // is not included in `inMST`) to the priority queue for (Edge nextEdge : adjacencyList.get(v)) { if (!inMST[nextEdge.dest]) { priorityQ.offer(nextEdge); } } } } } } public class Solution { public static void main(String[] args) { int vertices = 4; // Number of vertices in the graph Graph graph = new Graph(vertices); // Create a graph with specified vertices // Add edges to the graph graph.addEdge(0, 1, 10); graph.addEdge(0, 2, 6); graph.addEdge(0, 3, 5); graph.addEdge(1, 3, 15); graph.addEdge(2, 3, 4); // Run Prim's algorithm to construct MST graph.primMST(); } } ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/algorithms/1-data-structure-and-algorithms/","summary":"Recursion Recursion is a programming technique where a function repeatedly calls itself until it reaches a base case, whcih stops the recursion and allows it to return a result. It is a way of breaking down complex problems into smaller, simpler subproblems that are eaiser to solve.\nHead Recursion Head Recursion is a type of recursion where a function makes its recursive call first, immediately after checking the base case, and performs all other operations only after the recursive call returns.","title":"Data Structure \u0026 Algorithms"},{"content":"JUnit assertEquals In JUnit, assertEquals is a method used to check if the expected value and the actual value are equal in unit tests.\nSHOW CODE Java import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class UnitTest { @Test void addition() { Calculator calculator = new Calculator(); int result = calculator.add(1, 1); assertEquals(2, result, \"The result of 1 + 1 should be 2\"); } } assertTure \u0026amp; assertFalse In JUnit, the assertTrue and the assertFalse methods are used to validate boolean expressions in unit tests.\nSHOW CODE Java import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertTrue; public class UnitTest { @Test void testIsOdd() { int n = 5; assertTrue(n % 2 == 1, \"Number should be an odd\"); assertFalse(n % 2 == 0, \"Number should not be an even\"); } } @BeforeEach \u0026amp; @AfterEach In JUnit, the @BeforeEach and @AfterEach annotations are used to specify methods that should run before or after each test method, respectively. These annotations are useful for setting up resources before each test and cleaning up resources after each test.\nSHOW CODE Java import org.junit.jupiter.api.AfterEach; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class UnitTest { private Calculator calculator; @BeforeEach void setup() { calculator = new Calculator(); } @Test void testAddition() { assertEquals(2, calculator.add(1, 1), \"The result of 1 + 1 should be 2.\"); } @AfterEach void teardown() { calculator = null; } } @BeforeAll \u0026amp; @AfterAll In JUnit, the @BeforeAll and @AfterAll annotations are used to specify methods that run once before and after all the test methods in a test class, respectively. These methods are commonly used for expensive setup and cleanup.\nSHOW CODE Java import org.junit.jupiter.api.AfterAll; import org.junit.jupiter.api.BeforeAll; import org.junit.jupiter.api.Test; public class UnitTest { @BeforeAll public static void setUpBeforeClass() { System.out.println(\"Executed before all tests are run.\"); } @AfterAll public static void tearDownAfterClass() { System.out.println(\"Executed after all tests are run.\"); } @Test public void testMethod1() { System.out.println(\"Test 1 executed.\"); } @Test public void testMethod2() { System.out.println(\"Test 2 executed.\"); } } SHOW OUTPUT Output Executed before all tests are run. Test 1 executed. Test 2 executed. Executed after all tests are run. assertArrayEquals \u0026amp; assertNotEquals In JUnit, the assertArrayEquals and assertNotEquals methods are used to check if both arrays are equal in sizeand whether each corresponding element is equal or not. For arrays containing objects, JUnit will use the equals method of the objects for the comparison.\nSHOW CODE Java import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertArrayEquals; import static org.junit.jupiter.api.Assertions.assertNotEquals; public class UnitTest { @Test void testArrayEquality() { int[] expected = {1, 2, 3}; int[] actual = {1, 2, 3}; assertArrayEquals(expected, actual, \"Arrays should be equal\"); String[] expected2 = {\"apple\", \"banana\", \"cherry\"}; String[] actual2 = {\"apple\", \"banana\", \"cherry\"}; // Compare arrays of objects (Strings in this case) assertArrayEquals(expected2, actual2); } @Test void testArrayNotEquality() { int[] expected = {1, 2, 3}; int[] actual = {1, 2, 4}; assertNotEquals(expected, actual, \"Arrays should not be equal\"); } } assertThrows In Junit, the assertThrows is a method used to assert that a specific exception is throwing during the execution of a piece of code.\nSHOW CODE Java import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertThrows; public class UnitTest { @Test void testDivision() { Calculator calculator = new Calculator(); ArithmeticException exception = assertThrows(ArithmeticException.class, () -\u003e { calculator.divide(1, 0); }); assertEquals(\"/ by zero\", exception.getMessage()); } } assertTimeout \u0026amp; assertTimeoutPreemptively In JUnit, the assertTimeout and assertTimeoutPreemptively methods are used to ensure that a unit test finishes within a specified time limit. The key difference between them is that the assertTimeoutPreemptively method will terminate the test as soon as the excution time exceeds the specified limit. In contrast, the assertTimeout method allows the test to complete before checking if the time limit was exceeded.\nSHOW CODE Java import org.junit.jupiter.api.Test; import java.time.Duration; import static org.junit.jupiter.api.Assertions.*; public class UnitTest { @Test void testExecutionWithinTimeoutPreemptively() { assertTimeoutPreemptively(Duration.ofMillis(1000), () -\u003e { // Simulate a task that takes more time than allowed Thread.sleep(1500); // Task that takes more than 1000ms }); } @Test void testExecutionWithinTimeout() { assertTimeout(Duration.ofMillis(1000), () -\u003e { // Simulate a task that takes some time Thread.sleep(500); // Task that takes less than 1000ms }); } } Parameterized Tests In JUnit, Parameterized Tests allow a test to be run with different parameters and expected results, which reduces repetitive code and increases test coverage. Common parameter sources include @ValueSource, which passes a group of values to the test; @CsvSource, which allows passing multiple values separated by commmas; @MethodSource, which generates values dynamically from a method; and @EnumSource, which passes enum constants from an enum class.\nSHOW CODE Java import org.junit.jupiter.params.ParameterizedTest; import org.junit.jupiter.params.provider.CsvSource; import org.junit.jupiter.params.provider.EnumSource; import org.junit.jupiter.params.provider.MethodSource; import org.junit.jupiter.params.provider.ValueSource; import java.util.stream.Stream; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertTrue; public class UnitTest { @ParameterizedTest @ValueSource(strings = {\"apple\", \"banana\", \"cherry\"}) void testWithStringParameter(String fruit) { assertTrue(fruit.length() \u003e 3); } @ParameterizedTest @CsvSource({ \"apple, 5\", \"banana, 6\", \"cherry, 6\" }) void testWithCsvSource(String fruit, int length) { assertEquals(fruit.length(), length); } static Stream\u0026lt;String\u0026gt; stringProvider() { return Stream.of(\"apple\", \"banana\", \"cherry\"); } @ParameterizedTest @MethodSource(\"stringProvider\") void testWithMethodSource(String fruit) { assertTrue(fruit.length() \u003e 3); } enum FRUIT {APPLE, BANANA, CHERRY} @ParameterizedTest @EnumSource(FRUIT.class) void testWithEnumSource(FRUIT fruit) { assertTrue(fruit.name().length() \u003e 3); } } Mockito System Under Test The System Under Test (SUT) refers to the specific part of the software being tested in a given test case. It can range from a single method in unit testing to larger components in integration or system testing based on different context. The SUT is typically isolated using mocking and stubbing to test its behavior independently.\nSHOW CODE Java public class Calculator { public int add(int a, int b) { return a + b; } } public class CalculatorTest { @Test void testAdd() { Calculator calculator = new Calculator(); // SUT int result = calculator.add(2, 3); // The add method is the System Under Test assertEquals(5, result); } } Mocking vs. Stubbing In unit testing, Mocking and Stubbing are used to simulate and control the behavior of external dependencies. Mocking is commonly used for behavior verification, where objects are created to simulate the behavior of real-world components in a controlled manner. On the other hand, Stubbing is typically used to isolate the SUT by controlling the return values or responses from dependencies.\nSHOW CODE: Mocking Java public class Calculator { private Logger logger; public Calculator(Logger logger) { this.logger = logger; } public int add(int a, int b) { int result = a + b; logger.log(\"Addition performed: \" + result); return result; } } @Test void testAdd() { Logger mockLogger = mock(Logger.class); Calculator calculator = new Calculator(mockLogger); calculator.add(2, 3); // Verifying the interaction with the mock: was log method called? verify(mockLogger).log(\"Addition performed: 5\"); } SHOW CODE: Stubbing Java public class Calculator { private DatabaseService databaseService; public Calculator(DatabaseService databaseService) { this.databaseService = databaseService; } public int getProductPrice(int productId) { Product product = databaseService.getProduct(productId); return product.getPrice(); } } @Test void testGetProductPrice() { // Stub the DatabaseService to return a fixed product DatabaseService stubbedService = mock(DatabaseService.class); Product stubProduct = new Product(1, \"Laptop\", 1000); when(stubbedService.getProduct(1)).thenReturn(stubProduct); Calculator calculator = new Calculator(stubbedService); int price = calculator.getProductPrice(1); assertEquals(1000, price); } mock(), when().thenReturn(), verify() In Mockito, the mock() method is used to create a mock object, which allows simulating the behavior of an object without invoking its real methods. The when() method is used to define the behavior of a mock object\u0026rsquo;s method when it is called with specific arguments. The thenReturn() method specifies the return value of a mocked method. The verify() method is used to check whether a specified method on a mock object was called during the test execution.\nSHOW CODE Java import org.junit.jupiter.api.Test; import java.util.List; import static org.junit.jupiter.api.Assertions.assertTrue; import static org.mockito.Mockito.*; public class UnitTest { @Test public void testMockingBehavior() { // Create a mock List object List\u0026lt;String\u0026gt; mockList = mock(List.class); // Specify behavior for when add() is called when(mockList.add(\"Hello\")).thenReturn(true); // Return true when \"Hello\" is added // Call the mock method boolean result = mockList.add(\"Hello\"); // Verify the behavior assertTrue(result); // The add method should return true verify(mockList).add(\"Hello\"); // Verify that add(\"Hello\") was called // Verify that add(\"World\") was never called verify(mockList, never()).add(\"World\"); } } Argument Matchers In Mockito, argument matchers are used to specify conditions for method arguments when stubbing methods. They are commonly used in the when() and thenReturn() methods when the exact method argument is not critical. Some commonly used argument marchers include:\nany(): Matches any argument of the specified type. eq(): Matches a specified argument. anyString(): Matches any argument of type String. anyInt(): Matches any argument of type Integer. isA(): Matches an argument of a specified class type. argThat(): Allows for custom argument matching logic. SHOW CODE Java import org.junit.jupiter.api.Test; import java.util.List; import static org.junit.jupiter.api.Assertions.*; import static org.mockito.ArgumentMatchers.anyInt; import static org.mockito.Mockito.*; public class UnitTest { @Test public void testAnyMatcher() { List mockList = mock(List.class); // Stub behavior using argument matcher when(mockList.get(anyInt())).thenReturn(\"Signal\"); // Verify that any argument passed to get will return \"Signal\" assertEquals(\"Signal\", mockList.get(9)); assertEquals(\"Signal\", mockList.get(999)); } @Test public void testEqMatcher() { Calculator calculator = mock(Calculator.class); when(calculator.add(eq(1), eq(1))).thenReturn(2); assertEquals(2, calculator.add(1, 1)); assertNotEquals(3, calculator.add(1, 1)); } @Test public void testAnyStringMatcher() { // Create a mock List List\u0026lt;String\u0026gt; mockList = mock(List.class); // Stub the method to return \"Hello\" for any string argument when(mockList.contains(anyString())).thenReturn(true); // Verify that the mock returns true for any string passed as an argument assertTrue(mockList.contains(\"Test\")); // Matches any string assertTrue(mockList.contains(\"Hello\")); // Matches any string assertTrue(mockList.contains(\"World\")); // Matches any string } @Test public void testAnyIntMatcher() { // Create a mock List List mockList = mock(List.class); // Stub the method to return \"Found\" for any integer argument when(mockList.get(anyInt())).thenReturn(\"Found\"); // Verify that the mock returns \"Found\" regardless of the argument assertEquals(\"Found\", mockList.get(1)); // Matches any integer assertEquals(\"Found\", mockList.get(999)); // Matches any integer } @Test public void testArgThatMatcher() { // Create a mock List List\u0026lt;String\u0026gt; mockList = mock(List.class); // Use argThat to match arguments that are not null and have length greater than 3 when(mockList.add(argThat(argument -\u003e argument != null \u0026\u0026 argument.length() \u003e 3))) .thenReturn(true); // Verify that the mock behaves correctly assertTrue(mockList.add(\"Hello\")); // Matches: length \u003e 3 assertFalse(mockList.add(\"\")); // Does not match: empty string } } Essential Mockito Annotaitons The key annotations in Mockito are @Mock, @InjectMocks, @ExtendWith, and @Captor. The @Mock annotation is used to create mock objects. The @InjectMocks annotation injects the objects, created with @Mock, into the specified class under test. The @ExtendWith annotation specifies a custom test runner to use when executing the test. The @Captor annotation is used to create an ArgumentCaptor instance, which captures and verifies the arguments passed to mocked methods.\nSHOW CODE Java import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.ExtendWith; import org.mockito.ArgumentCaptor; import org.mockito.Captor; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.junit.jupiter.MockitoExtension; import java.util.List; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.mockito.Mockito.verify; @ExtendWith(MockitoExtension.class) public class UnitTest { @Mock private List\u0026lt;String\u0026gt; mockList; // Mocked dependency @InjectMocks private MyClass myClass; // Class under test @Captor private ArgumentCaptor\u0026lt;String\u0026gt; captor; // Captures arguments passed to the mock @Test void testAddItem() { // Perform the action under test myClass.addItem(\"Test Item\"); // Verify that the mockList's add method was called with the argument \"Test Item\" verify(mockList).add(captor.capture()); // Capture and assert the argument String capturedArgument = captor.getValue(); System.out.println(\"capturedArgument = \" + capturedArgument); // Assert the captured item is correct assertEquals(\"Test Item\", capturedArgument); } static class MyClass { private final List\u0026lt;String\u0026gt; list; public MyClass(List\u0026lt;String\u0026gt; list) { this.list = list; } public void addItem(String item) { list.add(item); } } } Mockit Spy Mockito\u0026rsquo;s spy is a partial mock, typically created using @Spy, where real methods are used by default, and only the specified methods are stubbed.\nSHOW CODE Java import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.ExtendWith; import org.mockito.Mock; import org.mockito.Spy; import org.mockito.junit.jupiter.MockitoExtension; import java.util.ArrayList; import java.util.List; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.mockito.Mockito.doReturn; import static org.mockito.Mockito.verify; @ExtendWith(MockitoExtension.class) public class UnitTest { // Create a spy for the class under test @Spy private MyClass myClass = new MyClass(); // Inject the mock dependency into the class under test @Mock private List\u0026lt;String\u0026gt; mockList; @Test public void testAddItemWithSpy() { // Use the real method to add an item myClass.addItem(\"Test Item\"); // Verify that the mock's addItem method is called with the argument // Fail the test: Actually, there were zero interactions with this mock. verify(mockList).add(\"Test Item\"); // Stub the method for testing doReturn(\"Mocked Response\").when(myClass).getGreeting(); // Now the method getGreeting() will return the mocked response String response = myClass.getGreeting(); System.out.println(response); // Output: Mocked Response // Assert the mocked behavior assertEquals(\"Mocked Response\", response); } // Class under test static class MyClass { private final List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); public void addItem(String item) { list.add(item); } public String getGreeting() { return \"Hello, World!\"; } } } In the above code, the statement verify(mockList).add(\u0026quot;Test Item\u0026quot;); will fail because mockList is a partial mock. By default, real methods are called on a spy object, and since the real method is not stubbed or tracked. the verification cannot succeed.\nMockito and SpringBoot Example SHOW CODE: pom.xml pom.xml \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.4.0\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;dev.signalyu\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springtest\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;springtest\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;springtest\u0026lt;/description\u0026gt; \u0026lt;url/\u0026gt; \u0026lt;licenses\u0026gt; \u0026lt;license/\u0026gt; \u0026lt;/licenses\u0026gt; \u0026lt;developers\u0026gt; \u0026lt;developer/\u0026gt; \u0026lt;/developers\u0026gt; \u0026lt;scm\u0026gt; \u0026lt;connection/\u0026gt; \u0026lt;developerConnection/\u0026gt; \u0026lt;tag/\u0026gt; \u0026lt;url/\u0026gt; \u0026lt;/scm\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;17\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.mockito/mockito-core --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mockito\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mockito-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.14.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-test --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.4.0\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.34\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.springframework.data/spring-data-commons --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.data\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-data-commons\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!--\t\u0026lt;build\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;plugins\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;plugin\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;configuration\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;annotationProcessorPaths\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;path\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;/path\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;/annotationProcessorPaths\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;/configuration\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;/plugin\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;plugin\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;configuration\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;excludes\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;exclude\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;/exclude\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;/excludes\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;/configuration\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;/plugin\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;/plugins\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;/build\u0026gt;--\u0026gt; \u0026lt;/project\u0026gt; SHOW CODE Java import lombok.AllArgsConstructor; import lombok.Data; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.data.repository.CrudRepository; import org.springframework.stereotype.Repository; import org.springframework.stereotype.Service; import org.springframework.test.context.bean.override.mockito.MockitoBean; import org.springframework.test.web.servlet.MockMvc; import org.springframework.test.web.servlet.result.MockMvcResultMatchers; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; import static org.mockito.Mockito.when; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status; @Data class User { private Long id; private String name; } @Repository interface UserRepository extends CrudRepository\u0026lt;User, Long\u0026gt; { } @Service @Data class UserService { @Autowired private final UserRepository userRepository; public String getUserById(Long id) { User user = userRepository.findById(id).orElse(null); return user == null ? \"User not found\" : user.getName(); } } @RestController @AllArgsConstructor class UserController { private final UserService userService; @GetMapping(\"/user/{id}\") public String getUser(@PathVariable Long id) { return userService.getUserById(id); } } @SpringBootTest @AutoConfigureMockMvc public class UnitTest { @Autowired private MockMvc mockMvc; @MockitoBean private UserService userService; @Test public void testGetUser() throws Exception { Long userId = 1L; String mockResponse = \"Signal Yu\"; when(userService.getUserById(userId)).thenReturn(mockResponse); mockMvc.perform(get(\"/user/{id}\", userId)) .andExpect(status().isOk()) .andExpect(MockMvcResultMatchers.content().string(mockResponse)); } } ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/framework-and-tools/framework/backend/unit-testing/1-junit-and-mockito-notes/","summary":"JUnit assertEquals In JUnit, assertEquals is a method used to check if the expected value and the actual value are equal in unit tests.\nSHOW CODE Java import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class UnitTest { @Test void addition() { Calculator calculator = new Calculator(); int result = calculator.add(1, 1); assertEquals(2, result, \"The result of 1 + 1 should be 2\"); } } assertTure \u0026amp; assertFalse In JUnit, the assertTrue and the assertFalse methods are used to validate boolean expressions in unit tests.","title":"Junit \u0026 Mockito Notes"},{"content":"Synchronous Messaging VS. Asynchronous Messaging Synchronous Messaging and Asynchronous Messaging are two commnication paradigms used in distributed systems. In synchronous messaging, the sender will not continue executing until it receives the acknowledged message from the receiver. This paradigm is commonly used in situations that require immediate feedback to continue operations, such as payments or transaction processing.\nThe advantages of this paradigm include ease of implementation and usefulness in situations where immediate feedback is needed. However, the drawbacks are also obvious: it may lead to performance bottlenecks when the receiver is slow or unavailable, and it can also limit scalability.\n--- title: Synchronous Messaging --- sequenceDiagram participant Sender participant MessageBus participant MessageListener Sender-\u003e\u003eMessageBus: MessageBusUtil.sendSynchronousMessage() MessageBus-\u003e\u003eMessageListener: destination.send() MessageListener--\u003e\u003eMessageBus: return response note over Sender: (block and wait) MessageBus--\u003e\u003eSender: return response In asynchronous messaging, the sender doesn\u0026rsquo;t block after sending the message, meaning it can continue processing without waiting for the response from the receiver. It is commonly used in situations where systems can tolerate delays in response, like message notification after a successful payment. Compared to synchronous messaging, asynchronous messaging is more complex to implement. Additionaly, the sender has no guarantee of immediate feedback. It requires extra techniques, such as callback functions or message listeners, to handle the response.\nsequenceDiagram participant Sender participant MessageBus as Message Bus participant MessageListener1 as Message Listener 1 Sender-\u003e\u003eMessageBus: MessageBusUtil.sendMessage() MessageBus-\u003e\u003eMessageListener: destination.send() MessageListener--\u003e\u003eMessageBus: return response Sender-\u003e\u003eSender: (continue with processing) MessageBus--\u003e\u003eSender: return response RabbitMQ Introduction to RabbitMQ RabbitMQ is a message broker that facilitates asynchronous communication between distributed systems. Its working mechnism involves four key components:\nProducer: Responsible for sending messages Exchange: Handles the routing of messages to the appropriate queues. Queue: Stores messages until they are consumed. Consumer: Processes the messages from the queue. --- title: Introduction to RabbitMQ --- graph LR P((P)) --\u003e|send| X{{Exchange}} --\u003e|binding| Q[[Queue]] --\u003e|receive| C((C)) Example: Hello RabbitMQ SHOW CODE Producer Consumer import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import java.nio.charset.StandardCharsets; public class Producer { // Name of the queue where the message will be sent private final static String QUEUE_NAME = \"hello\"; public static void main(String[] argv) throws Exception { // Create a connection factory to configure and connect to RabbitMQ ConnectionFactory factory = new ConnectionFactory(); // Configure RabbitMQ server address (default is localhost) factory.setHost(\"localhost\"); // Configure the port for RabbitMQ (default is 5672) factory.setPort(5672); // Use try-with-resource to automatically close the connection and channel after use try (Connection connection = factory.newConnection(); // Establish a connection to RabbitMQ Channel channel = connection.createChannel()) { // Create a communication channel // Declare a queue with the specified name channel.queueDeclare(QUEUE_NAME, false, false, false, null); String message = \"Hello RabbitMQ!\"; // Publish the message to the queue channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes(StandardCharsets.UTF_8)); System.out.println(\" [P] Sent '\" + message + \"'\"); } } } import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import com.rabbitmq.client.DeliverCallback; import java.nio.charset.StandardCharsets; public class Consumer { private final static String QUEUE_NAME = \"hello\"; public static void main(String[] argv) throws Exception { // Create a connection factory to configure and connect to RabbitMQ ConnectionFactory factory = new ConnectionFactory(); // Configure RabbitMQ server address (default is localhost) factory.setHost(\"localhost\"); // Configure the port for RabbitMQ (default is 5672) factory.setPort(5672); // Establish a connection to RabbitMQ Connection connection = factory.newConnection(); // Create a communication channel Channel channel = connection.createChannel(); // Declare a queue with the specified name channel.queueDeclare(QUEUE_NAME, false, false, false, null); System.out.println(\" [*] Waiting for messages. To exit press CTRL+C\"); // Define the callback function to handle incoming message DeliverCallback deliverCallback = (consumerTag, delivery) -\u003e { // Retrieve the message body and convert it to a string using UTF-8 encoding String message = new String(delivery.getBody(), StandardCharsets.UTF_8); System.out.println(\" [C] Received '\" + message + \"'\"); }; // Start consuming messages from the queue channel.basicConsume(QUEUE_NAME, true, deliverCallback, consumerTag -\u003e { // No action required for cancellation in this example }); } } Message Acknowledgment In RabbitMQ, message acknowledgement is a mechanism that ensures messages have been received and processed successfully. There are two main types of message acknowledgement: auto ack and manual ack.\nIn auto-ack mode, RabbitMQ considers the message acknowledged as soon as it is delieved to the consumer. The consumer does not need to explictly send an acknowledgement. However, this can be risky. If the consumer fails due to a connection issue or channel break, the message may be lost, meaning it hasn\u0026rsquo;t been processed successfully.\nboolean autoAck = true; channel.basicConsume(queueName, autoAck, consumer); In manual ack mode, the consumer must send an acknowledgement back to RabbitMQ once the message has been processed successfully. If RabbitMQ does not receive the acknowledgement from the consumer within a specified time (30 minutes by default), it will redeliver the message to another consumer or the same consumer, depending on the configuration.\n// Acknowledging a message manually boolean autoAck = false; channel.basicConsume(queueName, autoAck, new DefaultConsumer(channel) { @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { String message = new String(body, \u0026#34;UTF-8\u0026#34;); // Process the message here channel.basicAck(envelope.getDeliveryTag(), false); // Acknowledge the message } }); Message Durability In RabbitMQ, message durability refers to the ability to ensure that a message will not be lost in case of a broker failure. It involves saving both the queue and message to disk so they can be recovered after a system restart. To guarantee durability, two key components need to be considered: durable queues and persistent messages.\nWhen a queue is declared as durable, it is saved to disk. The queue will still exist even if the broker fails.\nboolean durable = true; channel.queueDeclare(\u0026#34;myQueue\u0026#34;, durable, false, false, null); To ensure a message\u0026rsquo;s persistence after a broker restart, it must be marked as persistent by setting the delieveryMode to 2 (persistent). This ensures that the message is saved to disk. However, it\u0026rsquo;s important to note that marking a message as persistent does not fully guarantee that it won\u0026rsquo;t be lost. There is still a short window in which RabbitMQ has accepted the message but has not yet saved it to disk. Additionaly, RabbitMQ does not call fsync(2) for every message, meaning it may store the message in cache rather than writing it to disk immediately. Therefore, the durability guerantee is not strong.\n// Publish the message to the queue channel.basicPublish(\u0026#34;\u0026#34;, TASK_QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, // delieveryMode = 2 message.getBytes(\u0026#34;UTF-8\u0026#34;)); Prefetch When a consumer subscribes to a message queue, RabbitMQ begins delivering messages. By default, RabbitMQ uses a Round Robin Dispatching strategy, which evenly distributes messages across multiple consumers. However, if one of the consumers processes tasks slowly, it may lead to message buildup and memory pressure.\nIn RabbitMQ, the prefetch mechnism controls the maximum number of messages a consumer can hold at a time. When the number of messages a consumer holds reaches the prefetch limit, RabbitMQ will stop sending additional messages to that consumer until it acknowledges some of the messages. This mechanism helps prevent message accumulation and reduces memory pressure.\n--- title: Worker Queue - prefetch --- graph LR P((P)) --\u003e|send| Q[[Worker]] --\u003e|prefetch = 1| C1((C1)) Q --\u003e|prefetch = 1| C2((C2)) SHOW CODE Producer Worker import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import com.rabbitmq.client.MessageProperties; public class Producer { private static final String TASK_QUEUE_NAME = \"task_queue\"; public static void main(String[] argv) throws Exception { // Create a connection factory to configure and connect to RabbitMQ ConnectionFactory factory = new ConnectionFactory(); // Configure RabbitMQ server address (default is localhost) factory.setHost(\"localhost\"); // Configure the port for RabbitMQ (default is 5672) factory.setPort(5672); // Use try-with-resource to automatically close the connection and channel after use try (Connection connection = factory.newConnection(); // Establish a connection to RabbitMQ Channel channel = connection.createChannel()) { // Create a communication channel // Declare a queue with the specified name channel.queueDeclare(TASK_QUEUE_NAME, true, false, false, null); String message = \"Hello RabbitMQ!\"; // Publish the message to the queue channel.basicPublish(\"\", TASK_QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes(\"UTF-8\")); System.out.println(\" [P] Sent '\" + message + \"'\"); } } } import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import com.rabbitmq.client.DeliverCallback; public class Worker { // Name of the queue where the message will be sent private static final String TASK_QUEUE_NAME = \"task_queue\"; public static void main(String[] argv) throws Exception { // Create a connection factory to configure and connect to RabbitMQ ConnectionFactory factory = new ConnectionFactory(); // Configure RabbitMQ server address (default is localhost) factory.setHost(\"localhost\"); // Establish a connection to RabbitMQ final Connection connection = factory.newConnection(); // Create a communication channel final Channel channel = connection.createChannel(); // Declare a queue with the specified name channel.queueDeclare(TASK_QUEUE_NAME, true, false, false, null); System.out.println(\" [*] Waiting for messages. To exit press CTRL+C\"); // Specify the prefetch count channel.basicQos(1); // Define a callback to process incoming messages DeliverCallback deliverCallback = (consumerTag, delivery) -\u003e { String message = new String(delivery.getBody(), \"UTF-8\"); System.out.println(\" [C] Received '\" + message + \"'\"); try { try { // Simulate task processing Thread.sleep(1000); } catch (InterruptedException _ignored) { Thread.currentThread().interrupt(); } } finally { // Acknowledge the message after work is completed System.out.println(\" [C] Done\"); channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); } }; // Start consuming messages with manual acknowledgment channel.basicConsume(TASK_QUEUE_NAME, false, deliverCallback, consumerTag -\u003e { }); } } Publish/Subscribe Publish/Subscribe is a communication pattern where a message is sent by a producer to multiple consumers. In RabbitMQ, this pattern is implemented using Exchanges and Queues.\nIn the Publish/Subscribe pattern in RabbitMQ, the producer sends a message to an Exchange, which then routes the message to multiple queues that are bound to it. There are four types of exchanges in RabbitMQ:\nfanout: Routes messages to all queues bound to it, without considering any routing key. direct: Routes messages to queues based on an exact match with the routing key. topic: Routes messages to queues based on pattern matching of the routing key. headers: Routes messages based on the attributes of message headers. Fanout Exchange --- title: Publish/Subscribe - fanout --- graph LR P((P)) --\u003e|send| Ex{{fanout}} --\u003e|binding| Q1[[Q1]] Ex --\u003e|binding| Q2[[Q2]] Q1 --\u003e C1((C1)) Q2 --\u003e C2((C2)) SHOW CODE: Fanout Exchange Publisher Subscriber import com.rabbitmq.client.BuiltinExchangeType; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; public class EmitLog { private static final String EXCHANGE_NAME = \"logs\"; public static void main(String[] argv) throws Exception { // Create a new connection factory to connect to RabbitMQ ConnectionFactory factory = new ConnectionFactory(); // Set the host (default is 'localhost') factory.setHost(\"localhost\"); // Use try-with-resource to ensures automatic resource management try (Connection connection = factory.newConnection(); // Establish a connection Channel channel = connection.createChannel()) { // Create a channel // Declare an exchange of type 'fanout' which sends messages to all bound queues channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT); String message = argv.length \u003c 1 ? \"info: Hello World!\" : String.join(\" \", argv); // Publish the message to the exchange with an empty routing key (for fanout exchange) channel.basicPublish(EXCHANGE_NAME, \"\", null, message.getBytes(\"UTF-8\")); System.out.println(\" [x] Sent '\" + message + \"'\"); } } } import com.rabbitmq.client.*; public class ReceiveLogs { private static final String EXCHANGE_NAME = \"logs\"; public static void main(String[] argv) throws Exception { // Create a new connection factory to connect to RabbitMQ ConnectionFactory factory = new ConnectionFactory(); // Set the host (default is 'localhost') factory.setHost(\"localhost\"); // Establish a connection and create a new channel for communication Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); // Declare the exchange with the same name as in the emitter (logs) and of type 'fanout' channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT); // Bind the queue to the exchange with an empty routing key (for fanout exchange) String queueName = channel.queueDeclare().getQueue(); channel.queueBind(queueName, EXCHANGE_NAME, \"\"); System.out.println(\" [*] Waiting for messages. To exit press CTRL+C\"); // Define the callback function to process incoming messages DeliverCallback deliverCallback = (consumerTag, delivery) -\u003e { String message = new String(delivery.getBody(), \"UTF-8\"); System.out.println(\" [x] Received '\" + message + \"'\"); }; // Consume messages from the queue channel.basicConsume(queueName, true, deliverCallback, consumerTag -\u003e { }); } } Direct Exchange --- title: Publish/Subscribe - direct --- graph LR P((P)) --\u003e|send| Ex{{direct}} --\u003e|error| Q1[[Q1]] Ex --\u003e|info| Q2[[Q2]] Ex --\u003e|warn| Q2[[Q2]] Ex --\u003e|error| Q2[[Q2]] Q1 --\u003e C1((C1)) Q2 --\u003e C2((C2)) SHOW CODE: Direct Exchange Publisher Subscriber import com.rabbitmq.client.BuiltinExchangeType; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; public class EmitLogDirect { private static final String EXCHANGE_NAME = \"direct_logs\"; public static void main(String[] argv) throws Exception { // Create a new connection factory to connect to RabbitMQ ConnectionFactory factory = new ConnectionFactory(); // Set the host (default is 'localhost') factory.setHost(\"localhost\"); //Use try-with-resource for automatic resource management try (Connection connection = factory.newConnection(); // Establish a new connection Channel channel = connection.createChannel()) { // Create a new channel // Declare an exchange with type of 'direct' channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT); // Get the severity level (routing key) from the command-line arguments String severity = getSeverity(argv); // Get the message content from the command-line arguments String message = getMessage(argv); // Publish the message to the exchange with given severity as the routing key channel.basicPublish(EXCHANGE_NAME, severity, null, message.getBytes(\"UTF-8\")); System.out.println(\" [x] Sent '\" + severity + \"':'\" + message + \"'\"); } } private static String getSeverity(String[] strings) { if (strings.length \u003c 1) { return \"info\"; } return strings[0]; } private static String getMessage(String[] strings) { if (strings.length \u003c 2) { return \"Hello World!\"; } return joinStrings(strings, \" \", 1); } private static String joinStrings(String[] strings, String delimiter, int startIndex) { int length = strings.length; if (length == 0) { return \"\"; } if (length \u003c= startIndex) { return \"\"; } StringBuilder words = new StringBuilder(strings[startIndex]); for (int i = startIndex + 1; i \u003c length; i++) { words.append(delimiter).append(strings[i]); } return words.toString(); } } import com.rabbitmq.client.*; public class ReceiveLogsDirect { private static final String EXCHANGE_NAME = \"direct_logs\"; public static void main(String[] argv) throws Exception { // Create a new connection factory to connect to RabbitMQ ConnectionFactory factory = new ConnectionFactory(); // Set the host (default is 'localhost') factory.setHost(\"localhost\"); // Establish a new connection Connection connection = factory.newConnection(); // Create a new channel Channel channel = connection.createChannel(); // Declare a direct exchange, where messages will be routed based on the routing key channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT); String queueName = channel.queueDeclare().getQueue(); // Exit the program if no arguments are passed (no routing keys provided) if (argv.length \u003c 1) { System.err.println(\"Usage: ReceiveLogsDirect [info] [warning] [error]\"); System.exit(1); } for (String severity : argv) { // Bind the queue to the exchange with a specific routing key channel.queueBind(queueName, EXCHANGE_NAME, severity); } System.out.println(\" [*] Waiting for messages. To exit press CTRL+C\"); // Define the callback function for processing the received messages DeliverCallback deliverCallback = (consumerTag, delivery) -\u003e { String message = new String(delivery.getBody(), \"UTF-8\"); System.out.println(\" [x] Received '\" + delivery.getEnvelope().getRoutingKey() + \"':'\" + message + \"'\"); }; // Consume messages from the queue channel.basicConsume(queueName, true, deliverCallback, consumerTag -\u003e { }); } } Topic Exchange In RabbitMQ, the Topic Exchange is a type of exchange that routes messages to queues based on pattern matching of the routing key. The routing key in a topic exchange is typically a string of words separated by dots (.). The routing key can also contain wildcards like * and #. The * wildcard matches exactly one word, while the # wildcard matches zero or more words. Compared to the direct exchange, the topic exchange offers greater flexibility and efiiciency in routing messages to queues based on more complex patterns.\nSHOW CODE: Topic Exchange Publisher Subscriber import com.rabbitmq.client.BuiltinExchangeType; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; public class EmitLogTopic { private static final String EXCHANGE_NAME = \"topic_logs\"; public static void main(String[] argv) throws Exception { // Create a connection factory to connect to RabbitMQ ConnectionFactory factory = new ConnectionFactory(); // Set the host (default is 'localhost') factory.setHost(\"localhost\"); // Use try-with-resource for automatic management try (Connection connection = factory.newConnection(); // Establish a new connection Channel channel = connection.createChannel()) { // Create a new channel // Declare a topic exchange with specified name channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC); String routingKey = getRouting(argv); String message = getMessage(argv); // Publish the message to the exchange channel.basicPublish(EXCHANGE_NAME, routingKey, null, message.getBytes(\"UTF-8\")); System.out.println(\" [x] Sent '\" + routingKey + \"':'\" + message + \"'\"); } } private static String getRouting(String[] strings) { if (strings.length \u003c 1) return \"anonymous.info\"; return strings[0]; } private static String getMessage(String[] strings) { if (strings.length \u003c 2) return \"Hello World!\"; return joinStrings(strings, \" \", 1); } private static String joinStrings(String[] strings, String delimiter, int startIndex) { int length = strings.length; if (length == 0) return \"\"; if (length \u003c startIndex) return \"\"; StringBuilder words = new StringBuilder(strings[startIndex]); for (int i = startIndex + 1; i \u003c length; i++) { words.append(delimiter).append(strings[i]); } return words.toString(); } } import com.rabbitmq.client.*; public class ReceiveLogsTopic { private static final String EXCHANGE_NAME = \"topic_logs\"; public static void main(String[] argv) throws Exception { // Create a new connection factory to connect to RabbitMQ ConnectionFactory factory = new ConnectionFactory(); // Set the host (default is 'localhost') factory.setHost(\"localhost\"); // Establish a new connection Connection connection = factory.newConnection(); // Create a new channel Channel channel = connection.createChannel(); // Declare a topic exchange with the specified name channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC); String queueName = channel.queueDeclare().getQueue(); if (argv.length \u003c 1) { System.err.println(\"Usage: ReceiveLogsTopic [binding_key]...\"); System.exit(1); } for (String bindingKey : argv) { channel.queueBind(queueName, EXCHANGE_NAME, bindingKey); } System.out.println(\" [*] Waiting for messages. To exit press CTRL+C\"); // Define the callback function for process received messages DeliverCallback deliverCallback = (consumerTag, delivery) -\u003e { String message = new String(delivery.getBody(), \"UTF-8\"); System.out.println(\" [x] Received '\" + delivery.getEnvelope().getRoutingKey() + \"':'\" + message + \"'\"); }; // Consume messages from the queue channel.basicConsume(queueName, true, deliverCallback, consumerTag -\u003e { }); } } Reliability: Publisher Publisher Retry Publisher Retry in RabbitMQ refers to the mechanism where the publisher reconnects to RabbitMQ after a network issue. This mechanism improves the likelihood of a successful connection when the network is unstable. However, the retry process is executed in blocking manner, which may lead to performance issues during reconnection. Below are the relavant configurations for application.properties.\nspring.rabbitmq.listener.simple.retry.enabled=false # Whether or not publishing retries are enabled. spring.rabbitmq.listener.simple.retry.initial-interval=1000 # Interval between the first and second attempt to deliver a message. spring.rabbitmq.listener.simple.retry.max-attempts=3 # Maximum number of attempts to deliver a message. spring.rabbitmq.listener.simple.retry.max-interval=10000 # Maximum interval between attempts. spring.rabbitmq.listener.simple.retry.multiplier=1.0 # A multiplier to apply to the previous delivery retry interval. spring.rabbitmq.listener.simple.retry.stateless=true # Whether or not retry is stateless or stateful. Publisher Confirm \u0026amp; Publisher Return RabbitMQ provides two types of message confirmation mechanisms between the publisher and the broker: Publisher Confirm and Publisher Return. The Publisher Confirm mechanism allows the publisher to receive an ack from the broker when the message is successfully delivered to the broker. The Publisher Return mechanism enables the broker to notify the publisher when a message cannot be routed to any queue.\nWhen a message is sent to the broker, if the message type is temporary and can be successfully routed to the specified queue, the broker will return an ack to the publisher. If the message type if durable and the message can be delievered to the queue and successfully saved to disk, the broker will return an ack. Otherwise, the broker will return an nack (negative acknowledgement) to the publisher.\nspring.rabbitmq.publisher-confirms=false # Enable publisher confirms. spring.rabbitmq.publisher-returns=false # Enable publisher returns. The Publisher Confirm mechanism provides two types of confirmation: synchronous mode (simple) and asynchronous mode (correlated). Synchronous mode offers a strict acknowledgement process but may lead to performance issues in high-throughput environments. It is typically used when reliability is the top priority. On the other hand, asynchronous mode improves throughput but requires that the acknowledgement process be handled in the background.\nIt is important to note that using Publisher Confirm and Publisher Return mechanism incurs additional network and system resource costs. Therefore, these mechanisms should be used with caution in production systems. If they must be used, it\u0026rsquo;s recommended to rely on Publisher Confirm only, as routing issues are often caused by business logic problems, and Publisher Return is less commonly needed. Additionally, for messages that are negatively acknowledged (nack), retry them within a limited time window to avoid an infinite retry loop. If retried continue to fail, record the exception logs instead of attempting retries indefinitely.\nReliability: Broker Data Persistency LazyQueue ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/asynchronous-messaging/1-asynchronous-messaging/","summary":"Synchronous Messaging VS. Asynchronous Messaging Synchronous Messaging and Asynchronous Messaging are two commnication paradigms used in distributed systems. In synchronous messaging, the sender will not continue executing until it receives the acknowledged message from the receiver. This paradigm is commonly used in situations that require immediate feedback to continue operations, such as payments or transaction processing.\nThe advantages of this paradigm include ease of implementation and usefulness in situations where immediate feedback is needed.","title":"Asynchronous Messaging"},{"content":"Introduction to DBMS A Database Management System (DBMS) is software that provides an interface for users to interact with databases. It enables the management, storage, and manipulation of data within databases. DBMS can be broadly classified into two main types: Relational DBMS and NoSQL DBMS.\nIn a Relational DBMS, data is stored in structured tables and is manipulated using SQL (Structured Query Language). Examples of relational DBMS inlcude MySQL, Oracle, and PostgreSQL.\nIn a NoSQL DBMS, data is typically unstructured or semi-structured, offering flexibility to handle diverse data types. Examples of NoSQL DBMS include MongoDB and Redis.\nMySQL MySQL is a relational database management system (RDBMS) that uses Structured Query Language (SQL) to interact with databases. It stores data in tables made up of rows and columns, allowing for efficient organization, retrival, and manipulation of data.\nSQL Commands SQL Commands are used to interact with relational databases. These commands can be classified into five types: DDL, DQL, DML, DCL, and TCL.\nSQL Commands DDL (Data Definition Language): Used to define and manage the structure of database instances, such as creating, altering, and deleting tables, and defining constraints. DQL (Data Query Language): Used to retrive data from the database, primarily through the SELECT statement. DML (Data Manipulation Language): Used to manipulate data within tables, such as inserting, updating, and deleting records. DCL (Data Control Language): Used to control access to data, manage user priviledges, and ensure data security. It includes commands like GRANT and REVOKE. TCL (Transaction Control Language): Used to manage transactions, ensuring data consistency. It includes commands like COMMIT, ROLLBACK, and SAVEPOINT. SQL Query Execution Order MySQL Execution Order: In MySQL, the execution order of an SQL query differs from the order in which components (e.g., SELECT, FROM, WHERE) are written in the query. MySQL begins by identifying the tables or views specified in the FROM clause. If there are any JOIN operation, MySQL performs the joins first and applies the ON condition. After completing the join operations, MySQL filters the based on the conditions specified in the WHERE clause.\nIf a GROUP BY clause is present, MySQL groups the rows based on the specified column(s) and then executes any aggregation functions (e.g., SUM(), COUNT(), etc.). Following the grouping, if a HAVING clause is provided, MySQL further filters the grouped results based on the specified condition.\nAfter filtering grouped results, MySQL selects the specified columns in the SELECT clause. If the DISTINCT keyword is used, MySQL removes duplicate rows from the selected result. Once the rows are selected and duplicates are removed, MySQL sorts the result set according to the rules defined in the ORDER BY clause.\nFinally, if a LIMIT or OFFSET clause is included, MySQL limits the number of rows returned, starting from the specified OFFSET.\nSQL Query Execution Order Select Find Customer Referee SHOW PROBLEM Table: Customer\nColumn Name Type id int name varchar referee_id int The id column is the primary key. Each row represents a customer, their name, and the id of the customer who referred them. If a customer wasn\u0026rsquo;t referred by anyone, the referee_id is NULL. Problem:\nFind the names of customers who were not referred by the customer with id = 2.\nThe result can be returned in any order.\nExample:\nInput: Customer table:\nid name referee_id 1 Will NULL 2 Jane NULL 3 Alex 2 4 Bill NULL 5 Zack 1 6 Mark 2 Output:\nname Will Jane Bill Zack Go to Leetcode 🔗 SHOW CODE MySQL SELECT name FROM Customer WHERE referee_id != 2 OR referee_id IS NULL; SHOW NOTES In SQL, NULL is not equal to any value, including 2. Therefore, the condition referee_id != 2 will exclude records where referee_id is NULL, because comparisons with NULL always result in an unknown NULL value, which is neither TRUE nor FALSE. It is crucial to consider the handling of NULL values when working with databases.\nArticle Views I SHOW PROBLEM Table: Views\nColumn Name Type article_id int author_id int viewer_id int view_date date There is no primary key in this table, and the table may contain duplicate rows. Each row indicates that a viewer viewed an article, where the article is written by an author, on a specific date. If author_id and viewer_id are the same, it indicates that the author viewed their own article. Problem:\nWrite a query to find the IDs of authors who have viewed at least one of their own articles.\nReturn the result table sorted by author_id in ascending order.\nExample:\nInput:\nViews table:\narticle_id author_id viewer_id view_date 1 3 5 2019-08-01 1 3 6 2019-08-02 2 7 7 2019-08-01 2 7 6 2019-08-02 4 7 1 2019-07-22 3 4 4 2019-07-21 3 4 4 2019-07-21 Output:\nid 4 7 Go to Leetcode 🔗 SHOW CODE MySQL SELECT DISTINCT author_id AS id FROM Views WHERE author_id = viewer_id ORDER BY id ASC; SHOW NOTES In SQL, the DISTINCT keyword is used to remove duplicate records from the result set, ensuring that only unique values are returned. It is commonly used in scenarios such as aggregating distinct values and ensuring uniqueness in join queries.\n# Aggregating unique values SELECT DISTINCT product_id FROM Order_Items; # Ensuring unique results in join queries SELECT DISTINCT c.customer_id, c.name FROM Customers c JOIN Orders o ON c.customer_id = o.customer_id; Baisc Joins LEFT JOIN: Replace Employee ID With The Unique Identifier In MySQL, LEFT JOIN is used to combine rows from two or more tables based on a related column between them. It returns all rows from the left table and the matching rows from the right table. If there is no match, the result will include NULL values for the column from the right table.\nSHOW PROBLEM Tables:\nEmployees\nColumn Name Type id int name varchar id is the primary key for this table. Each row represents an employee in the company, containing their id and name. EmployeeUNI\nColumn Name Type id int unique_id int (id, unique_id) is the primary key, meaning the combination of id and unique_id is unique across the table. Each row represents an employee\u0026rsquo;s id and their corresponding unique_id in the company. Task:\nWrite a SQL query that returns the unique_id of each employee from the Employees table. If an employee does not have a corresponding unique_id, return NULL for that employee.\nQuery Requirements:\nIf an employee has a unique_id, show it. If an employee does not have a unique_id, return NULL. The result should display the unique_id and the name of each employee. The results can be returned in any order.\nExample:\nInput:\nEmployees table:\nid name 1 Alice 7 Bob 11 Meir 90 Winston 3 Jonathan EmployeeUNI table:\nid unique_id 3 1 11 2 90 3 Output:\nunique_id name NULL Alice NULL Bob 2 Meir 3 Winston 1 Jonathan Explanation:\nAlice and Bob do not have a unique_id, so NULL is shown for both. Meir has a unique_id of 2. Winston has a unique_id of 3. Jonathan has a unique_id of 1. Go to Leetcode 🔗 SHOW CODE MySQL SELECT euni.unique_id, e.name FROM Employees e LEFT JOIN EmployeeUNI euni ON e.id = euni.id; LEFT JOIN: Confirmation Rate SHOW PROBLEM Table: Signups\nColumn Name Type user_id int time_stamp datetime user_id is a unique identifier for each user. Each row represents the signup time for the user identified by user_id. Table: Confirmations\nColumn Name Type user_id int time_stamp datetime action ENUM The primary key is a combination of user_id and time_stamp. user_id is a foreign key referencing the Signups table. action is an ENUM with two possible values: 'confirmed' or 'timeout'. Each row represents a confirmation request made by the user with user_id, indicating whether the confirmation message was confirmed ('confirmed') or timed out ('timeout'). Problem Description\nThe confirmation rate of a user is calculated as the ratio of 'confirmed' actions to the total number of confirmation requests. If a user has not made any confirmation requests, the confirmation rate is 0. The rate should be rounded to two decimal places.\nGoal\nWrite a SQL query to find the confirmation rate for each user.\nReturn the result in any order.\nInput\nSignups table:\nuser_id time_stamp 3 2020-03-21 10:16:13 7 2020-01-04 13:57:59 2 2020-07-29 23:09:44 6 2020-12-09 10:39:37 Confirmations table:\nuser_id time_stamp action 3 2021-01-06 03:30:46 timeout 3 2021-07-14 14:00:00 timeout 7 2021-06-12 11:57:29 confirmed 7 2021-06-13 12:58:28 confirmed 7 2021-06-14 13:59:27 confirmed 2 2021-01-22 00:00:00 confirmed 2 2021-02-28 23:59:59 timeout Output\nuser_id confirmation_rate 6 0.00 3 0.00 7 1.00 2 0.50 Explanation:\nUser 6 did not request any confirmation messages, so their confirmation rate is 0. User 3 made two confirmation requests, but both timed out, so their confirmation rate is 0. User 7 made three requests, and all were confirmed, so their confirmation rate is 1.00. User 2 made two requests: one confirmed and one timed out, so their confirmation rate is 1/2 = 0.50. Go to Leetcode 🔗 SHOW CODE MySQL SELECT user_id, ROUND(IFNULL(SUM(action = 'confirmed') / COUNT(1), 0), 2) AS confirmation_rate FROM SignUps LEFT JOIN Confirmations USING (user_id) GROUP BY 1; SELECT s.user_id, CASE WHEN c.user_id IS NULL THEN 0.00 ELSE ROUND(SUM(CASE WHEN action = 'confirmed' THEN 1 ELSE 0 END) / COUNT(*),2) END AS confirmation_rate FROM Signups s LEFT JOIN Confirmations c ON c.user_id = s.user_id GROUP BY s.user_id SHOW NOTES SUM(action = 'confirmed'): action = 'confirmed' returns 1 for confirmed actions and 0 for 'timeout' action. COUNT(1): Counts the total number of rows. (Use COUNT(*) for counting rows is more clear and idiomatic). LEFT JOIN Confirmations USING (user_id): Joins the Signups table with the Confirmations table on the user_id column. GROUP BY 1: A shorthand for GROUP BY user_id. It groups the results by the first column in the SELECT list, which is user_id in this case. INNER JOIN: Product Sales Analysis I In MySQL, the INNER JOIN is used to combine rows from two or more tables based on a related column between them. It only returns rows where there is a match in all the joined tables.\nSHOW PROBLEM Tables:\nSales\nColumn Name Type sale_id int product_id int year int quantity int price int (sale_id, year) is the primary key, meaning this combination of columns is unique. product_id is a foreign key referencing the Product table. Each row represents a sale of a product identified by product_id in a particular year. The price is per unit of the product. Product\nColumn Name Type product_id int product_name varchar product_id is the primary key for this table. Each row represents a product with its product_name. Task:\nWrite a SQL query to report the product_name, year, and price for each sale in the Sales table.\nQuery Requirements:\nReturn the product_name from the Product table, corresponding to the product_id in the Sales table. Include the year and price from the Sales table for each sale. The result can be returned in any order. Example:\nInput:\nSales table:\nsale_id product_id year quantity price 1 100 2008 10 5000 2 100 2009 12 5000 7 200 2011 15 9000 Product table:\nproduct_id product_name 100 Nokia 200 Apple 300 Samsung Output:\nproduct_name year price Nokia 2008 5000 Nokia 2009 5000 Apple 2011 9000 Explanation:\nFrom sale_id = 1, we can conclude that Nokia was sold for 5000 in 2008. From sale_id = 2, we can conclude that Nokia was sold for 5000 in 2009. From sale_id = 7, we can conclude that Apple was sold for 9000 in 2011. Go to Leetcode 🔗 SHOW CODE MySQL SELECT p.product_name, s.year, s.price FROM Sales s INNER JOIN Product p ON s.product_id = p.product_id; LEFT JOIN: Customer Who Visited but Did Not Make Any Transactions SHOW PROBLEM Table: Visits\nColumn Name Type visit_id int customer_id int visit_id is the unique identifier for each visit. This table contains information about the customers who visited the mall. Table: Transactions\nColumn Name Type transaction_id int visit_id int amount int transaction_id is the unique identifier for each transaction. This table contains information about the transactions made during each visit. Task:\nWrite a SQL query to find the IDs of customers who visited the mall without making any transactions, and count how many times they made these visits.\nThe result should include:\ncustomer_id — the ID of the customer. count_no_trans — the number of visits where no transaction was made. Query Requirements:\nReturn the result sorted in any order. Input:\nVisits table:\nvisit_id customer_id 1 23 2 9 4 30 5 54 6 96 7 54 8 54 Transactions table:\ntransaction_id visit_id amount 2 5 310 3 5 300 9 5 200 12 1 910 13 2 970 Output:\ncustomer_id count_no_trans 54 2 30 1 96 1 Explanation:\nCustomer with id = 23 visited once and made a transaction during the visit with id = 12. Customer with id = 9 visited once and made a transaction during the visit with id = 13. Customer with id = 30 visited once and did not make any transactions. Customer with id = 54 visited three times. During two visits, they did not make any transactions, and during one visit, they made three transactions. Customer with id = 96 visited once and did not make any transactions. In the output, customers with id = 30, id = 96, and id = 54 (for two of their visits) made visits without transactions.\nGo to Leetcode 🔗 SHOW CODE MySQL SELECT v.customer_id, COUNT(v.visit_id) as count_no_trans FROM Visits v LEFT JOIN Transactions t ON v.visit_id = t.visit_id WHERE t.transaction_id IS NULL GROUP BY v.customer_id; SHOW NOTES In the above SQL query, MySQL first identifies the Visits table and performs a LEFT JOIN with the Transactions table based on the condition v.visit_id = t.visit_id. The LEFT JOIN operation combines the two tables and fills NULL in rows where there is no match in the Transactions table. The result looks like this:\nSELECT * FROM Visits v LEFT JOIN Transactions t ON v.visit_id = t.visit_id; visit_id customer_id transaction_id visit_id amount 1 23 12 1 910 2 9 13 2 970 4 30 null null null 5 54 9 5 200 5 54 3 5 300 5 54 2 5 310 6 96 null null null 7 54 null null null 8 54 null null null After joining the tables, MySQL applies the WHERE clause to filter rows where t.transaction_id IS NULL, which means visits without any transactions.\nSELECT * FROM Visits v LEFT JOIN Transactions t ON v.visit_id = t.visit_id WHERE t.transaction_id IS NULL; visit_id customer_id transaction_id visit_id amount 4 30 null null null 6 96 null null null 7 54 null null null 8 54 null null null Next, MySQL groups the filtered rows by customer_id and calculates the number of visits per customer using the COUNT(v.visit_id) function.\nSELECT *, COUNT(v.visit_id) FROM Visits v LEFT JOIN Transactions t ON v.visit_id = t.visit_id WHERE t.transaction_id IS NULL GROUP BY v.customer_id; visit_id customer_id transaction_id visit_id amount COUNT(v.visit_id) 4 30 null null null 1 6 96 null null null 1 7 54 null null null 2 Finally, MySQL selects the desired columns and renames the COUNT(v.visit_id) column using the AS clause.\nSELECT v.customer_id, COUNT(v.visit_id) AS count_no_trans FROM Visits v LEFT JOIN Transactions t ON v.visit_id = t.visit_id WHERE t.transaction_id IS NULL GROUP BY v.customer_id; customer_id count_no_trans 30 1 96 1 54 2 SELF JOIN: Rising Temperature In MySQL, a self join is an operation where a table joins itself. It is commonly used when comparing rows within the same table based on a specific condition or when working with hierarchical data, such as relating employees to their managers.\nSHOW PROBLEM Table: Weather\nColumn Name Type id int recordDate date temperature int id is a column with unique values. There are no duplicate rows for the same recordDate. This table contains information about the temperature on specific dates. Problem Statement\nWrite a solution to find the id of all dates where the temperature is higher compared to the previous day (yesterday).\nReturn\nReturn the result table in any order. Input:\nWeather Table:\nid recordDate temperature 1 2015-01-01 10 2 2015-01-02 25 3 2015-01-03 20 4 2015-01-04 30 Output:\nid 2 4 Explanation:\nOn 2015-01-02, the temperature was higher than the previous day (10 -\u0026gt; 25). On 2015-01-04, the temperature was higher than the previous day (20 -\u0026gt; 30). Go to Leetcode 🔗 SHOW CODE MySQL SELECT w1.id FROM Weather w1 JOIN Weather w2 ON DATE_ADD(w2.recordDate, INTERVAL 1 DAY) = w1.recordDate WHERE w1.temperature \u003e w2.temperature; SHOW NOTES In the above query, the DATE_ADD(w2.recordDate, INTERVAL 1 DAY) = w1.recordDate condition ensures that the recordDate of w1 matches the day following w2\u0026rsquo;s recordDate.\nSELECT * FROM Weather w1 JOIN Weather w2 ON DATE_ADD(w2.recordDate, INTERVAL 1 DAY) = w1.recordDate id recordDate temperature id recordDate temperature 1 2015-01-01 10 2 2015-01-02 25 1 2015-01-01 10 3 2015-01-03 20 2 2015-01-02 25 4 2015-01-04 30 3 2015-01-03 20 4 2015-01-04 30 Result of the Join:\nid recordDate temperature id recordDate temperature 2 2015-01-02 25 1 2015-01-01 10 3 2015-01-03 20 2 2015-01-02 25 4 2015-01-04 30 3 2015-01-03 20 when id equals to 2, 25 \u0026gt; 10, so it is selcted. when id equals to 3, 20 \u0026lt; 25, so it is not selcted. when id equals to 4, 25 \u0026gt; 10, so it is selcted. Therefore, the result will be:\nid 2 4 Example: Relating Employees to Their Managers\nEmployees Table:\nid name manager_id 1 Alice NULL 2 Bob 1 3 Charlie 1 4 David 2 SELECT e1.name AS Employee, e2.name AS Manager FROM Employees e1 JOIN Employees e2 ON e1.manager_id = e2.id; Result of the Join:\nid name manager_id id name manager_id 2 Bob 1 1 Alice NULL 3 Charlie 1 1 Alice NULL 4 David 2 2 Bob 1 Final Result:\nEmployee Manager Bob Alice Charlie Alice David Bob SELF JOIN: Managers with at Least 5 Direct Reports SHOW PROBLEM Problem Description\nTable: Employee\nColumn Name Data Type Description id int Unique identifier for each employee. name varchar Name of the employee. department varchar Department to which the employee belongs. managerId int ID of the employee\u0026rsquo;s manager. If managerId is null, the employee does not have a manager. id is the primary key, ensuring each value is unique. Each row represents an employee, including their name, department, and their manager’s ID. If managerId is null, the employee does not report to any manager. An employee cannot be their own manager. Task\nWrite a query to find the managers who have at least five direct reports.\nReturn the result in any order.\nInput:\nEmployee Table:\nid name department managerId 101 John A null 102 Dan A 101 103 James A 101 104 Amy A 101 105 Anne A 101 106 Ron B 101 Output:\nname John Go to Leetcode 🔗 SHOW CODE MySQL SELECT b.name FROM Employee a JOIN Employee b ON a.managerId = b.id GROUP BY b.id HAVING COUNT(*) \u003e= 5 SHOW NOTES Table: Employee:\nid name department managerId 101 John A null 102 Dan A 101 103 James A 101 104 Amy A 101 105 Anne A 101 106 Ron B 101 Perform a self join, the table becomes:\nSELECT * FROM Employee a JOIN Employee b ON a.managerId = b.id Table: Slef Joined Result:\nid name department managerId id name department managerId 106 Ron B 101 101 John A null 105 Anne A 101 101 John A null 104 Amy A 101 101 John A null 103 James A 101 101 John A null 102 Dan A 101 101 John A null Group the self joined result:\nSELECT * FROM Employee a JOIN Employee b ON a.managerId = b.id GROUP BY b.id Table: Grouped Result:\nid name department managerId id name department managerId 106 Ron B 101 101 John A null Filter grouped result:\nSELECT * FROM Employee a JOIN Employee b ON a.managerId = b.id GROUP BY b.id HAVING COUNT(*) \u0026gt;= 5 Table: Filtered Grouped Result:\nid name department managerId id name department managerId 106 Ron B 101 101 John A null Select the specified column(s):\nSELECT b.name FROM Employee a JOIN Employee b ON a.managerId = b.id GROUP BY b.id HAVING COUNT(*) \u0026gt;= 5 Final Result:\nname John SELF JOIN: Average Time of Process per Machine SHOW PROBLEM Table: Activity\nColumn Name Type machine_id int process_id int activity_type enum timestamp float The table records user activities for machines on a factory website. The combination of (machine_id, process_id, activity_type) is the primary key, ensuring uniqueness in the table. machine_id is the ID of the machine. process_id is the ID of the process running on the machine with ID machine_id. activity_type is an ENUM type with values 'start' and 'end', representing the start and end of a process. timestamp is a float value representing the time (in seconds) the event occurred. The 'start' timestamp is always earlier than the 'end' timestamp for each (machine_id, process_id) pair. It is guaranteed that each (machine_id, process_id) pair has a corresponding 'start' and 'end' timestamp. Problem:\nThere are several machines on a factory website, and each machine runs the same number of processes. Your task is to write a SQL query that calculates the average time each machine takes to complete a process.\nThe time to complete a process is the difference between the 'end' timestamp and the 'start' timestamp. The average time for each machine is calculated by dividing the total time for all processes on that machine by the number of processes. The result should contain the following columns:\nmachine_id — the ID of the machine. processing_time — the average processing time, rounded to 3 decimal places. Input:\nActivity table: |------------|------------|---------------|-----------| | machine_id | process_id | activity_type | timestamp | |------------|------------|---------------|-----------| | 0 | 0 | start | 0.712 | | 0 | 0 | end | 1.520 | | 0 | 1 | start | 3.140 | | 0 | 1 | end | 4.120 | | 1 | 0 | start | 0.550 | | 1 | 0 | end | 1.550 | | 1 | 1 | start | 0.430 | | 1 | 1 | end | 1.420 | | 2 | 0 | start | 4.100 | | 2 | 0 | end | 4.512 | | 2 | 1 | start | 2.500 | | 2 | 1 | end | 5.000 | |------------|------------|---------------|-----------| Output:\n|------------|-----------------| | machine_id | processing_time | |------------|-----------------| | 0 | 0.894 | | 1 | 0.995 | | 2 | 1.456 | |------------|-----------------| Explanation:\nMachine 0:\nProcess 0: End time 1.520, Start time 0.712 → Time taken = 1.520 - 0.712 = 0.808 Process 1: End time 4.120, Start time 3.140 → Time taken = 4.120 - 3.140 = 0.980 Average time = (0.808 + 0.980) / 2 = 0.894 Machine 1:\nProcess 0: End time 1.550, Start time 0.550 → Time taken = 1.550 - 0.550 = 1.000 Process 1: End time 1.420, Start time 0.430 → Time taken = 1.420 - 0.430 = 0.990 Average time = (1.000 + 0.990) / 2 = 0.995 Machine 2:\nProcess 0: End time 4.512, Start time 4.100 → Time taken = 4.512 - 4.100 = 0.412 Process 1: End time 5.000, Start time 2.500 → Time taken = 5.000 - 2.500 = 2.500 Average time = (0.412 + 2.500) / 2 = 1.456 Go to Leetcode 🔗 SHOW CODE MySQL SELECT machine_id, ROUND(AVG(end_time - start_time), 3) AS processing_time FROM ( SELECT a.machine_id, a.process_id, a.timestamp AS start_time, b.timestamp AS end_time FROM Activity a JOIN Activity b ON a.machine_id = b.machine_id AND a.process_id = b.process_id AND a.activity_type = 'start' AND b.activity_type = 'end' ) AS process_times GROUP BY machine_id; SHOW NOTES In the following SQL query, the condition a.activity_type = 'start' and b.activity_type = 'end' ensures that the start and end timestamp are correctly matched for the same process on the same machine.\nSELECT * FROM Activity a JOIN Activity b ON a.machine_id = b.machine_id AND a.process_id = b.process_id AND a.activity_type = \u0026#39;start\u0026#39; AND b.activity_type = \u0026#39;end\u0026#39; Result of the Join:\nmachine_id process_id activity_type timestamp machine_id process_id activity_type timestamp 0 0 start 0.712 0 0 end 1.52 0 1 start 3.14 0 1 end 4.12 1 0 start 0.55 1 0 end 1.55 1 1 start 0.43 1 1 end 1.42 2 0 start 4.1 2 0 end 4.512 2 1 start 2.5 2 1 end 5 The result is selected from of the joined result:\nSELECT machine_id, ROUND(AVG(end_time - start_time), 3) AS processing_time FROM ( SELECT a.machine_id, a.process_id, a.timestamp AS start_time, b.timestamp AS end_time FROM Activity a JOIN Activity b ON a.machine_id = b.machine_id AND a.process_id = b.process_id AND a.activity_type = \u0026#39;start\u0026#39; AND b.activity_type = \u0026#39;end\u0026#39; ) AS process_times GROUP BY machine_id; Final Result:\nmachine_id processing_time 0 0.894 1 0.995 2 1.456 CROSS JOIN: Students and Examinations In MySQL, a CROSS JOIN is a type of join that returns the Cartesian product of two tables. It combines each row from the first table with every row from the second table, without the need for a join condition. For example, consider two tables, Students and Subjects:\nTable 1: Students\nstudent_id student_name 1 Alice 2 Bob Table 2: Subjects\nsubject_name Math Physics When a Cross Join is performed between these two tables, the result will be:\nTable: Result of Cross Join\nstudent_id student_name subject_name 1 Alice Math 1 Alice Physics 2 Bob Math 2 Bob Physics SHOW PROBLEM Table: Students\nColumn Name Type student_id int student_name varchar student_id is the primary key (unique values) for this table. Each row represents a student with their unique ID and name. Table: Subjects\nColumn Name Type subject_name varchar subject_name is the primary key (unique values) for this table. Each row represents the name of a subject offered in the school. Table: Examinations\nColumn Name Type student_id int subject_name varchar There is no primary key for this table, and it may contain duplicates. Each row indicates that a student with student_id attended the exam for the subject subject_name. Every student takes every course from the Subjects table. Task:\nWrite a query to find the number of times each student attended each exam, ordered by student_id and subject_name.\nInput:\nStudents Table:\nstudent_id student_name 1 Alice 2 Bob 13 John 6 Alex Subjects Table:\nsubject_name Math Physics Programming Examinations Table:\nstudent_id subject_name 1 Math 1 Physics 1 Programming 2 Programming 1 Physics 1 Math 13 Math 13 Programming 13 Physics 2 Math 1 Math Output:\nstudent_id student_name subject_name attended_exams 1 Alice Math 3 1 Alice Physics 2 1 Alice Programming 1 2 Bob Math 1 2 Bob Physics 0 2 Bob Programming 1 6 Alex Math 0 6 Alex Physics 0 6 Alex Programming 0 13 John Math 1 13 John Physics 1 13 John Programming 1 Explanation:\nThe result table contains all students and all subjects.\nAlice attended the Math exam 3 times, the Physics exam 2 times, and the Programming exam 1 time. Bob attended the Math exam 1 time, the Programming exam 1 time, and did not attend the Physics exam. Alex did not attend any exams. John attended the Math exam 1 time, the Physics exam 1 time, and the Programming exam 1 time. Go to Leetcode 🔗 SHOW CODE MySQL SELECT s.student_id, s.student_name, sub.subject_name, COUNT(e.student_id) AS attended_exams FROM Students s CROSS JOIN Subjects sub LEFT JOIN Examinations e ON s.student_id = e.student_id AND sub.subject_name = e.subject_name GROUP BY s.student_id, s.student_name, sub.subject_name ORDER BY s.student_id, sub.subject_name; SHOW NOTES Table: Students\nstudent_id student_name 1 Alice 2 Bob 13 John 6 Alex Table: Subjects:\nsubject_name Math Physics Programming When a CROSS JOIN is performed between the Students and Subjects tables, the result will be:\nSELECT * FROM Students s CROSS JOIN Subjects sub Table: Result of Cross Join:\nstudent_id student_name subject_name 1 Alice Programming 1 Alice Physics 1 Alice Math 2 Bob Programming 2 Bob Physics 2 Bob Math 13 John Programming 13 John Physics 13 John Math 6 Alex Programming 6 Alex Physics 6 Alex Math Table: Examniations:\nstudent_id subject_name 1 Math 1 Physics 1 Programming 2 Programming 1 Physics 1 Math 13 Math 13 Programming 13 Physics 2 Math 1 Math Perform a LEFT JOIN on the cross-joined tables with the Examinations table:\nSELECT * FROM Students s CROSS JOIN Subjects sub LEFT JOIN Examinations e ON s.student_id = e.student_id AND sub.subject_name = e.subject_name Table: Left Join Result:\nstudent_id student_name subject_name student_id subject_name 1 Alice Programming 1 Programming 1 Alice Physics 1 Physics 1 Alice Physics 1 Physics 1 Alice Math 1 Math 1 Alice Math 1 Math 1 Alice Math 1 Math 2 Bob Programming 2 Programming 2 Bob Physics null null 2 Bob Math 2 Math 13 John Programming 13 Programming 13 John Physics 13 Physics 13 John Math 13 Math 6 Alex Programming null null 6 Alex Physics null null 6 Alex Math null null After grouping the left joined result and count the e.studentId, the table will look like:\nSELECT *, COUNT(e.student_id) AS attended_exams FROM Students s CROSS JOIN Subjects sub LEFT JOIN Examinations e ON s.student_id = e.student_id AND sub.subject_name = e.subject_name GROUP BY s.student_id, s.student_name, sub.subject_name Table: Grouped Result with Count:\nstudent_id student_name subject_name student_id subject_name attended_exams 1 Alice Programming 1 Programming 1 1 Alice Physics 1 Physics 2 1 Alice Math 1 Math 3 2 Bob Programming 2 Programming 1 2 Bob Physics null null 0 2 Bob Math 2 Math 1 13 John Programming 13 Programming 1 13 John Physics 13 Physics 1 13 John Math 13 Math 1 6 Alex Programming null null 0 6 Alex Physics null null 0 6 Alex Math null null 0 After selecting the specified columns, the result table becomes:\nSELECT s.student_id, s.student_name, sub.subject_name, COUNT(e.student_id) AS attended_exams FROM Students s CROSS JOIN Subjects sub LEFT JOIN Examinations e ON s.student_id = e.student_id AND sub.subject_name = e.subject_name GROUP BY s.student_id, s.student_name, sub.subject_name student_id student_name subject_name attended_exams 1 Alice Programming 1 1 Alice Physics 2 1 Alice Math 3 2 Bob Programming 1 2 Bob Physics 0 2 Bob Math 1 13 John Programming 1 13 John Physics 1 13 John Math 1 6 Alex Programming 0 6 Alex Physics 0 6 Alex Math 0 Sort the selcted table based on the condition s.student_id and sub.subject_name, return the final result:\nTable: Final Result:\nstudent_id student_name subject_name attended_exams 1 Alice Math 3 1 Alice Physics 2 1 Alice Programming 1 2 Bob Math 1 2 Bob Physics 0 2 Bob Programming 1 6 Alex Math 0 6 Alex Physics 0 6 Alex Programming 0 13 John Math 1 13 John Physics 1 13 John Programming 1 Basic Aggregate Functions Average Selling Price SHOW PROBLEM Table: Prices\nColumn Name Type product_id int start_date date end_date date price int The primary key for this table is the combination of (product_id, start_date, end_date), ensuring unique periods for each product. Each row represents the price of a product for a specific period, from start_date to end_date. For each product, no two periods will overlap. Table: UnitsSold\nColumn Name Type product_id int purchase_date date units int This table may contain duplicate rows. Each row represents the date, number of units, and product_id for a product sold on that date. Problem:\nWrite a SQL query to find the average selling price for each product. The average_price should be rounded to two decimal places. If a product does not have any sold units, its average selling price should be considered 0.\nReturn the result table in any order.\nInput:\nPrices table:\nproduct_id start_date end_date price 1 2019-02-17 2019-02-28 5 1 2019-03-01 2019-03-22 20 2 2019-02-01 2019-02-20 15 2 2019-02-21 2019-03-31 30 UnitsSold table:\nproduct_id purchase_date units 1 2019-02-25 100 1 2019-03-01 15 2 2019-02-10 200 2 2019-03-22 30 Output:\nproduct_id average_price 1 6.96 2 16.96 Explanation:\nFor product 1:\nFrom 2019-02-17 to 2019-02-28, 100 units were sold at a price of 5. From 2019-03-01 to 2019-03-22, 15 units were sold at a price of 20. Average price is calculated based on the total price and total units sold. For product 2:\nFrom 2019-02-01 to 2019-02-20, 200 units were sold at a price of 15. From 2019-02-21 to 2019-03-31, 30 units were sold at a price of 30. Average price is calculated based on the total price and total units sold. Go to Leetcode 🔗 SHOW CODE MySQL SELECT p.product_id, ROUND(IFNULL(SUM(price * units) / SUM(units), 0), 2) AS average_price FROM Prices AS p LEFT JOIN UnitsSold AS u ON p.product_id = u.product_id AND purchase_date BETWEEN start_date AND end_date GROUP BY 1; SHOW NOTES: Right Answer MySQL Query Walkthrough:\nTable: Prices\nproduct_id start_date end_date price 1 2019-02-17 2019-02-28 5 1 2019-03-01 2019-03-22 20 2 2019-02-01 2019-02-20 15 2 2019-02-21 2019-03-31 30 3 2019-02-21 2019-03-31 30 Table: UnitsSold\nproduct_id purchase_date units 1 2019-02-25 100 1 2019-03-01 15 2 2019-02-10 200 2 2019-03-22 30 Join the two tables based on the product_id and the purchase_date, where the purchase_date falls between the start_date and the end_date:\nSELECT * FROM Prices AS p LEFT JOIN UnitsSold AS u ON p.product_id = u.product_id AND purchase_date BETWEEN start_date AND end_date; product_id start_date end_date price product_id purchase_date units 1 2019-02-17 2019-02-28 5 1 2019-02-25 100 1 2019-03-01 2019-03-22 20 1 2019-03-01 15 2 2019-02-01 2019-02-20 15 2 2019-02-10 200 2 2019-02-21 2019-03-31 30 2 2019-03-22 30 3 2019-02-21 2019-03-31 30 null null null Group the joined result and then use aggregation functions to calculate the average price:\nSELECT *, ROUND(IFNULL(SUM(price * units) / SUM(units), 0), 2) AS average_price FROM Prices AS p LEFT JOIN UnitsSold AS u ON p.product_id = u.product_id AND purchase_date BETWEEN start_date AND end_date GROUP BY 1; product_id start_date end_date price product_id purchase_date units average_price 1 2019-02-17 2019-02-28 5 1 2019-02-25 100 6.96 2 2019-02-01 2019-02-20 15 2 2019-02-10 200 16.96 3 2019-02-21 2019-03-31 30 null null null 0 Select the desired columns:\nSELECT p.product_id, ROUND(IFNULL(SUM(price * units) / SUM(units), 0), 2) AS average_price FROM Prices AS p LEFT JOIN UnitsSold AS u ON p.product_id = u.product_id AND purchase_date BETWEEN start_date AND end_date GROUP BY 1; product_id average_price 1 6.96 2 16.96 3 0 SHOW NOTES: Wrong Answer # Wrong Answer SELECT p.product_id, ROUND(IFNULL(SUM(price * units) / SUM(units), 0), 2) AS average_price FROM Prices AS p LEFT JOIN UnitsSold AS u ON p.product_id = u.product_id WHERE purchase_date BETWEEN start_date AND end_date GROUP BY 1; Join the two tables based on the condition p.product_id = u.product_id:\nSELECT * FROM Prices AS p LEFT JOIN UnitsSold AS u ON p.product_id = u.product_id; product_id start_date end_date price product_id purchase_date units 1 2019-02-17 2019-02-28 5 1 2019-03-01 15 1 2019-02-17 2019-02-28 5 1 2019-02-25 100 1 2019-03-01 2019-03-22 20 1 2019-03-01 15 1 2019-03-01 2019-03-22 20 1 2019-02-25 100 2 2019-02-01 2019-02-20 15 2 2019-03-22 30 2 2019-02-01 2019-02-20 15 2 2019-02-10 200 2 2019-02-21 2019-03-31 30 2 2019-03-22 30 2 2019-02-21 2019-03-31 30 2 2019-02-10 200 3 2019-02-21 2019-03-31 30 null null null Filter out the rows that do not fall between start_date and end_date:\nSELECT * FROM Prices AS p LEFT JOIN UnitsSold AS u ON p.product_id = u.product_id WHERE purchase_date BETWEEN start_date AND end_date; product_id start_date end_date price product_id purchase_date units 1 2019-02-17 2019-02-28 5 1 2019-02-25 100 1 2019-03-01 2019-03-22 20 1 2019-03-01 15 2 2019-02-01 2019-02-20 15 2 2019-02-10 200 2 2019-02-21 2019-03-31 30 2 2019-03-22 30 Group the filtered result and then use aggregation functions to calculate average price:\nSELECT *, ROUND(IFNULL(SUM(price * units) / SUM(units), 0), 2) AS average_price FROM Prices AS p LEFT JOIN UnitsSold AS u ON p.product_id = u.product_id WHERE purchase_date BETWEEN start_date AND end_date GROUP BY 1; product_id start_date end_date price product_id purchase_date units average_price 1 2019-02-17 2019-02-28 5 1 2019-02-25 100 6.96 2 2019-02-01 2019-02-20 15 2 2019-02-10 200 16.96 Select the desired columns:\nSELECT p.product_id, ROUND(IFNULL(SUM(price * units) / SUM(units), 0), 2) AS average_price FROM Prices AS p LEFT JOIN UnitsSold AS u ON p.product_id = u.product_id WHERE purchase_date BETWEEN start_date AND end_date GROUP BY 1; product_id average_price 1 6.96 2 16.96 The correct answer is:\nproduct_id average_price 1 6.96 2 16.96 3 0 Summary: The LEFT JOIN operation will return NULL results for rows without without matching records in the UnitsSold table. In the condition p.product_id = u.product_id AND purchase_date BETWEEN start_date AND end_date, the date range check is applied during the join operation, while WHERE purchase_date BETWEEN start_date AND end_date is applied after the join operation. The WHERE clause exlcudes rows with NULL values, which means products with no matching sales records (i.e., where purchase_date doesn\u0026rsquo;t match) will be excluded from the result. When grouping the result, no rows containing NULL values remain, leading to an incorrect result (missing product_id = 3 with average_price = 0).\nPercentage of Users Attended a Contest SHOW PROBLEM Table: Users\nColumn Name Type user_id int user_name varchar user_id is the primary key (a unique identifier) for this table. Each row in this table represents a user, with their unique ID and name. Table: Register\nColumn Name Type contest_id int user_id int (contest_id, user_id) is the primary key (a unique combination of columns) for this table. Each row in this table represents the registration of a user in a specific contest. Task\nWrite a solution to calculate the percentage of users registered for each contest, rounded to two decimal places.\nReturn the result table sorted by percentage in descending order. If there is a tie in percentage, order by contest_id in ascending order.\nInput:\nUsers table:\nuser_id user_name 6 Alice 2 Bob 7 Alex Register table:\ncontest_id user_id 215 6 209 2 208 2 210 6 208 6 209 7 209 6 215 7 208 7 210 2 207 2 210 7 Output:\ncontest_id percentage 208 100.0 209 100.0 210 100.0 215 66.67 207 33.33 Explanation:\nContests 208, 209, and 210 had 100% user registration. The results are sorted by contest_id in ascending order. Contest 215 had a registration rate of 66.67%, as Alice and Alex registered, out of a total of three users. Contest 207 had a registration rate of 33.33%, as only Bob registered, out of a total of three users. Go to Leetcode 🔗 SHOW CODE MySQL SELECT contest_id, ROUND(COUNT(user_id) * 100 / (SELECT COUNT(user_id) FROM Users),2) percentage FROM Register a GROUP BY contest_id ORDER BY percentage DESC,contest_id ASC; SHOW NOTES $$ \\text{percentage} = \\frac{\\text{number of users attended in the contest}}{\\text{total number of users}} \\times 100 \\% $$\nCompute the total number of users: SELECT COUNT(user_id) FROM Users Compute the number of users attended in the contest: Group the table based on the column contest_id, then count the number of users in each group. Queries Quality and Percentage SHOW PROBLEM Table: Queries\nColumn Name Type query_name varchar result varchar position int rating int This table may contain duplicate rows. It contains information collected from various queries executed on a database. The position column has a value ranging from 1 to 500. The rating column has a value between 1 and 5. Queries with a rating less than 3 are considered poor queries. Definitions:\nQuery quality: The average of the ratio between the query\u0026rsquo;s rating and its position. Poor query percentage: The percentage of queries with a rating less than 3. Objective: Write a solution to find:\nThe query_name, The quality of each query (rounded to 2 decimal places), The poor_query_percentage for each query (rounded to 2 decimal places). Input: Queries table:\nquery_name result position rating Dog Golden Retriever 1 5 Dog German Shepherd 2 5 Dog Mule 200 1 Cat Shirazi 5 2 Cat Siamese 3 3 Cat Sphynx 7 4 Output:\nquery_name quality poor_query_percentage Dog 2.50 33.33 Cat 0.66 33.33 Explanation:\nDog queries:\nQuality:\n$$ \\left( \\frac{5}{1} + \\frac{5}{2} + \\frac{1}{200} \\right) / 3 = 2.50 $$ Poor query percentage:\n$$ \\frac{1}{3} \\times 100 = 33.33 $$ Cat queries:\nQuality:\n$$ \\left( \\frac{2}{5} + \\frac{3}{3} + \\frac{4}{7} \\right) / 3 = 0.66 $$ Poor query percentage:\n$$ \\frac{1}{3} \\times 100 = 33.33 $$ Go to Leetcode 🔗 SHOW CODE MySQL SELECT query_name, ROUND(AVG(rating / position), 2) AS quality, ROUND(SUM(CASE WHEN rating \u003c 3 THEN 1 ELSE 0 END) / COUNT(*) * 100, 2) AS poor_query_percentage FROM Queries GROUP BY query_name; Monthly Transactions I SHOW PROBLEM Table: Transactions\nColumn Name Type id int country varchar state enum amount int trans_date date id is the primary key of this table. The table stores information about incoming transactions. The state column is an enum with values [\u0026ldquo;approved\u0026rdquo;, \u0026ldquo;declined\u0026rdquo;]. Task:\nFor each month and country, find the following information:\nThe total number of transactions (trans_count). The total amount of all transactions (trans_total_amount). The number of approved transactions (approved_count). The total amount of approved transactions (approved_total_amount). The results should be returned in any order.\nExample Input:\nid country state amount trans_date 121 US approved 1000 2018-12-18 122 US declined 2000 2018-12-19 123 US approved 2000 2019-01-01 124 DE approved 2000 2019-01-07 Example Output:\nmonth country trans_count approved_count trans_total_amount approved_total_amount 2018-12 US 2 1 3000 1000 2019-01 US 1 1 2000 2000 2019-01 DE 1 1 2000 2000 Go to Leetcode 🔗 SHOW CODE MySQL SELECT DATE_FORMAT(trans_date, '%Y-%m') AS month, country, COUNT(*) AS trans_count, SUM(CASE WHEN state = 'approved' THEN 1 ELSE 0 END) AS approved_count, SUM(amount) AS trans_total_amount, SUM(CASE WHEN state = 'approved' THEN amount ELSE 0 END) AS approved_total_amount FROM Transactions GROUP BY month, country; SELECT DATE_FORMAT(trans_date, '%Y-%m') AS month, country, COUNT(*) AS trans_count, COUNT(IF(state = 'approved', 1, NULL)) AS approved_count, SUM(amount) AS trans_total_amount, SUM(IF(state = 'approved', amount, 0)) AS approved_total_amount FROM Transactions GROUP BY month, country; SHOW NOTES The DATE_FORMAT function in SQL is used to format a date into a specific string format. For example, DATE_FORMAT('2024-12-19', '%Y-%m') will output '2024-12', extracting the year and month from the date. The IF function in SQL returns one value if the condition is true and another value if the condition is false. For example, IF(amount \u0026gt; 1000, 1, 0) will return 1 if the amount is greater than 1000, otherwise, it will return 0. The CASE...WHEN...THEN...ELSE...END statement is similar to the switch statement in other programming languages like Java. It works like the IF function, but with the ability to handle multiple conditions. It checks each condition in sequence and returns the corresponding result for the first true condition. Immediate Food Delivery II SHOW PROBLEM Table: Delivery\nColumn Name Type delivery_id int customer_id int order_date date customer_pref_delivery_date date delivery_id is the unique identifier for each delivery. The table contains information about food deliveries, where customers place orders on a specific date and specify a preferred delivery date (either on the same day or later). If the customer_pref_delivery_date is the same as the order_date, the order is considered immediate; otherwise, it is scheduled. The first order of a customer is defined as the one with the earliest order_date. Each customer has exactly one first order. Task:\nFind the percentage of immediate orders among the first orders of all customers, rounded to two decimal places.\nThe result should follow the format shown below:\nExample Input:\ndelivery_id customer_id order_date customer_pref_delivery_date 1 1 2019-08-01 2019-08-02 2 2 2019-08-02 2019-08-02 3 1 2019-08-11 2019-08-12 4 3 2019-08-24 2019-08-24 5 3 2019-08-21 2019-08-22 6 2 2019-08-11 2019-08-13 7 4 2019-08-09 2019-08-09 Example Output:\nimmediate_percentage 50.00 Explanation:\nCustomer 1 has their first order with delivery_id 1, which is scheduled. Customer 2 has their first order with delivery_id 2, which is immediate. Customer 3 has their first order with delivery_id 5, which is scheduled. Customer 4 has their first order with delivery_id 7, which is immediate. Hence, 50% of the first orders are immediate.\nGo to Leetcode 🔗 SHOW CODE MySQL SELECT ROUND((SUM(IF(order_date = customer_pref_delivery_date, 1, 0)) / COUNT(*)) * 100, 2) AS immediate_percentage FROM (SELECT customer_id, MIN(order_date) AS first_order_date FROM Delivery GROUP BY customer_id) AS first_orders INNER JOIN Delivery AS d ON first_orders.customer_id = d.customer_id AND first_orders.first_order_date = d.order_date; Game Play Analysis IV SHOW PROBLEM Table: Activity\nColumn Name Type player_id int device_id int event_date date games_played int The combination of (player_id, event_date) is the primary key of this table, ensuring each player can only log in once per day. This table tracks the activity of players in games, where each record represents a player\u0026rsquo;s login and the number of games played (which could be zero) before logging out on a specific day using a particular device. Task:\nCalculate the fraction of players who logged in again on the day after their first login date. The result should be rounded to two decimal places.\nIn other words, identify the players who logged in on consecutive days starting from their first login date, then divide that count by the total number of players.\nExample Input:\nplayer_id device_id event_date games_played 1 2 2016-03-01 5 1 2 2016-03-02 6 2 3 2017-06-25 1 3 1 2016-03-02 0 3 4 2018-07-03 5 Example Output:\nfraction 0.33 Explanation:\nPlayer 1 logged in on 2016-03-01 and 2016-03-02, meaning they logged in for at least two consecutive days, starting from their first login. Player 2 did not log in again on the day after their first login. Player 3 did not log in on consecutive days, as there was a gap between their logins. Thus, only player 1 satisfies the condition, and the fraction is calculated as 1/3 = 0.33.\nGo to Leetcode 🔗 SHOW CODE MySQL SELECT ROUND( SUM(IF(DATEDIFF(event_date, min_event_date) = 1, 1, 0)) / COUNT(DISTINCT player_id), 2) AS fraction FROM ( SELECT player_id, event_date, MIN(event_date) OVER (PARTITION BY player_id) AS min_event_date FROM activity ) AS activity_with_min_date; SHOW NOTES The DATEDIFF function in MySQL calculates the difference in days between two dates. For example, DATEDIFF('2024-12-30', '2024-12-25') will output 5, indicating there are 5 days between the two dates. The PARTITION BY clause is used in window functions to divide the result ser into partitions (groups) based on a specified column. It applies window functions, such as RANK(), SUM(), ROW_NUMBER(), and others, to each partition. This works similarly to GROUP BY, but unlike GROUP BY, the PARTITION BY clause allows retaining the row-level data while applying the window functions. Input Table: employees\ndepartment_id employee_id salary 101 1 5000 101 2 4000 101 3 6000 102 4 4500 102 5 5500 102 6 4800 SELECT department_id, employee_id, salary, RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) AS salary_rank FROM employees; Output (Result of Query):\ndepartment_id employee_id salary salary_rank 101 3 6000 1 101 1 5000 2 101 2 4000 3 102 5 5500 1 102 6 4800 2 102 4 4500 3 Sorting and Grouping User Activity for the Past 30 Days I SHOW PROBLEM Table: Activity\nColumn Name Type user_id int session_id int activity_date date activity_type enum The activity_type column is an ENUM with values: \u0026lsquo;open_session\u0026rsquo;, \u0026rsquo;end_session\u0026rsquo;, \u0026lsquo;scroll_down\u0026rsquo;, \u0026lsquo;send_message\u0026rsquo;. This table logs user activities for a social media website, where each session is linked to exactly one user. The table may contain duplicate rows. Task:\nYou need to find the count of unique active users per day for the 30-day period ending on 2019-07-27, inclusive. A user is considered active on a particular day if they perform at least one activity on that day.\nExample:\nInput: Activity table\nuser_id session_id activity_date activity_type 1 1 2019-07-20 open_session 1 1 2019-07-20 scroll_down 1 1 2019-07-20 end_session 2 4 2019-07-20 open_session 2 4 2019-07-21 send_message 2 4 2019-07-21 end_session 3 2 2019-07-21 open_session 3 2 2019-07-21 send_message 3 2 2019-07-21 end_session 4 3 2019-06-25 open_session 4 3 2019-06-25 end_session Output:\nday active_users 2019-07-20 2 2019-07-21 2 Explanation:\nOnly the days with active users (those who performed at least one activity) are included in the output. For 2019-07-20, users 1 and 2 were active, and for 2019-07-21, users 2 and 3 were active. Go to Leetcode 🔗 SHOW CODE MySQL SELECT activity_date AS day, COUNT(DISTINCT user_id) AS active_users FROM Activity WHERE activity_date \u003c= '2019-07-27' AND DATEDIFF('2019-07-27', activity_date) \u003c 30 GROUP BY activity_date SELECT activity_date AS day, COUNT(DISTINCT user_id) AS active_users FROM Activity WHERE activity_date \u003c= '2019-07-27' AND activity_date\u003e DATE_SUB('2019-07-27',INTERVAL 30 day) GROUP BY activity_date SHOW NOTES In MySQL, both DATEDIFF and DATE_SUB are used for date calculations. DATEDIFF calculates the difference between two dates, returning the result in days. On the other hand, DATE_SUB is used to subtract a specified time interval (such as days, months, or years) from a given date.\nSELECT DATEDIFF(\u0026#39;2023-12-31\u0026#39;, \u0026#39;2023-01-01\u0026#39;); -- Result: 364 SELECT DATE_SUB(\u0026#39;2023-12-31\u0026#39;, INTERVAL 30 DAY); -- Result: \u0026#39;2023-12-01\u0026#39; SELECT DATE_SUB(\u0026#39;2023-12-31\u0026#39;, INTERVAL 2 MONTH); -- Result: \u0026#39;2023-10-31\u0026#39; Product Sales Analysis III SHOW PROBLEM Table: Sales\nColumn Name Type sale_id int product_id int year int quantity int price int The combination of sale_id and year is the primary key of this table, ensuring each record is unique for a given sale. product_id is a foreign key referencing the Product table. Each row in this table represents a sale of a specific product (product_id) in a given year. The price refers to the price per unit of the product. Table: Product\nColumn Name Type product_id int product_name varchar product_id is the primary key of this table, ensuring unique product identifiers. Each row represents the name of a product associated with the corresponding product_id. Task: Write a query to select the product_id, year, quantity, and price for the first year in which each product was sold.\nReturn the result in any order.\nExample:\nInput: Sales table\nsale_id product_id year quantity price 1 100 2008 10 5000 2 100 2009 12 5000 7 200 2011 15 9000 Product table:\nproduct_id product_name 100 Nokia 200 Apple 300 Samsung Output:\nproduct_id first_year quantity price 100 2008 10 5000 200 2011 15 9000 Explanation:\nFor product_id = 100, the first sale occurred in 2008 with a quantity of 10 and a price of 5000. For product_id = 200, the first sale occurred in 2011 with a quantity of 15 and a price of 9000. The query should return the first sale year for each product, along with the corresponding quantity and price.\nGo to Leetcode 🔗 SHOW CODE MySQL SELECT product_id, year AS first_year, quantity, price FROM Sales WHERE (product_id, year) IN ( SELECT product_id, MIN(year) AS year FROM Sales GROUP BY product_id ); SELECT product_id, first_year, quantity, price FROM ( SELECT product_id, year AS first_year, quantity, price, RANK() OVER (PARTITION BY product_id ORDER BY year) AS row_num FROM Sales ) subquery WHERE row_num = 1; SELECT s.product_id, s.year AS first_year, s.quantity, s.price FROM Sales s JOIN ( SELECT product_id, MIN(year) AS first_year FROM Sales GROUP BY product_id ) first_sale ON s.product_id = first_sale.product_id AND s.year = first_sale.first_year; SHOW NOTES Biggest Single Number SHOW PROBLEM Table: MyNumbers\nColumn Name Type num int This table may contain duplicates (i.e., there is no primary key in the SQL table). Each row contains an integer.\nProblem Description\nA single number is a number that appears only once in the MyNumbers table.\nThe task is to find the largest single number. If there is no single number, return null.\nExample 1:\nInput: MyNumbers table:\nnum 8 8 3 3 1 4 5 6 Output:\nnum 6 Explanation:\nThe single numbers are 1, 4, 5, and 6. Since 6 is the largest single number, we return it.\nExample 2:\nInput: MyNumbers table:\nnum 8 8 7 7 3 3 3 Output:\nnum null Explanation:\nThere are no single numbers in the input table, so we return null.\nGo to Leetcode 🔗 SHOW CODE MySQL SELECT MAX(num) AS num FROM ( SELECT num FROM MyNumbers GROUP BY 1 HAVING COUNT(1) = 1 ) AS t; SELECT IF(COUNT(num) = 1, num, null) AS num FROM MyNumbers GROUP BY num ORDER BY 1 DESC LIMIT 1; Advanced Select \u0026amp; Joins The Number of Employees Which Report to Each Employee SHOW PROBLEM Table: Employees\nColumn Name Type employee_id int name varchar reports_to int age int employee_id is the unique identifier for each employee in the table. This table stores information about employees and the ID of the manager they report to. Some employees may not report to anyone (reports_to is null). A manager is defined as an employee who has at least one other employee reporting to them. Problem Description\nYou are required to write a solution that reports the following information for each manager:\nThe manager\u0026rsquo;s employee_id and name. The number of employees directly reporting to the manager. The average age of these employees, rounded to the nearest integer. The results should be ordered by employee_id.\nExample 1:\nInput:\nEmployees table:\nemployee_id name reports_to age 9 Hercy null 43 6 Alice 9 41 4 Bob 9 36 2 Winston null 37 Output:\nemployee_id name reports_count average_age 9 Hercy 2 39 Explanation:\nHercy manages 2 employees (Alice and Bob). The average age of Alice and Bob is (41 + 36) / 2 = 38.5, which rounds to 39. Example 2:\nInput:\nEmployees table:\nemployee_id name reports_to age 1 Michael null 45 2 Alice 1 38 3 Bob 1 42 4 Charlie 2 34 5 David 2 40 6 Eve 3 37 7 Frank null 50 8 Grace null 48 Output:\nemployee_id name reports_count average_age 1 Michael 2 40 2 Alice 2 37 3 Bob 1 37 Explanation:\nMichael manages Alice and Bob. The average age of Alice and Bob is (38 + 42) / 2 = 40. Alice manages Charlie and David, with an average age of (34 + 40) / 2 = 37. Bob manages Eve, with an average age of 37. Go to Leetcode 🔗 SHOW CODE MySQL SELECT e1.employee_id, e1.name, COUNT(e1.employee_id) AS reports_count, ROUND(AVG(e2.age)) AS average_age FROM Employees e1 INNER JOIN Employees e2 ON e1.employee_id = e2.reports_to GROUP BY e1.employee_id ORDER BY e1.employee_id; Primary Department for Each Employee SHOW PROBLEM Table: Employee\nColumn Name Type employee_id int department_id int primary_flag varchar The combination of (employee_id, department_id) is the primary key for this table, meaning each employee can belong to multiple departments, but each (employee_id, department_id) pair is unique. employee_id: The ID of the employee. department_id: The ID of the department to which the employee belongs. primary_flag: A flag indicating whether the department is the primary department for the employee. It can be one of the following: 'Y': The department is the primary department. 'N': The department is not the primary department. Problem Description\nEmployees may belong to multiple departments, and when they do, they must designate one department as their primary. If an employee belongs to only one department, the primary_flag for that department will be 'N'.\nYou are tasked with reporting the primary department for each employee. If an employee has only one department, report that department as their primary.\nInput:\nEmployee table:\nemployee_id department_id primary_flag 1 1 N 2 1 Y 2 2 N 3 3 N 4 2 N 4 3 Y 4 4 N Output:\nemployee_id department_id 1 1 2 1 3 3 4 3 Explanation:\nFor employee 1, their only department is department 1, so it is reported as their primary department. Employee 2 belongs to two departments (1 and 2). The primary_flag for department 1 is 'Y', so department 1 is their primary department. Employee 3 only belongs to department 3, so it is reported as their primary department. Employee 4 belongs to three departments (2, 3, and 4). The primary_flag for department 3 is 'Y', so department 3 is reported as their primary department. Go to Leetcode 🔗 SHOW CODE sql SELECT employee_id, department_id FROM Employee WHERE primary_flag = 'Y' UNION SELECT employee_id, department_id FROM Employee GROUP BY employee_id HAVING COUNT(1) = 1; SHOW NOTES The UNION operator is used to combine the results of two or more SELECT queries into a single result set. By default, UNION removes duplicate rows, ensuring that the final result contains only distinct records. In contrast, UNION ALL includes all rows, even if they are duplicates. It\u0026rsquo;s important to note that each SELECT statement involved in a UNION operation must contain the same number of columns, and the corresponding columns must have compatable data types.\nTriangle Judgement SHOW PROBLEM Table: Triangle\nColumn Name Type x int y int z int Primary Key: (x, y, z)\nEach row in this table represents the lengths of three line segments. Task:\nDetermine whether the three line segments (x, y, z) from each row can form a triangle.\nReturn the result table in any order, including a column that specifies if the segments form a triangle.\nTriangle Formation Rule:\nThree segments can form a triangle if and only if the following conditions are met:\n$x + y \u0026gt; z$ $x + z \u0026gt; y$ $y + z \u0026gt; x$ Example:\nInput:\n**Triangle table: **\nx y z 13 15 30 10 20 15 Output:\nx y z triangle 13 15 30 No 10 20 15 Yes Go to Leetcode 🔗 SHOW CODE MySQL SELECT *, IF(x + y \u003e z AND x + z \u003e y AND y + z \u003e x, 'Yes', 'No') AS triangle FROM Triangle; SELECT *, CASE WHEN (x + y \u003e z) AND (x + z \u003e y) AND (y + z \u003e x) THEN 'Yes' ELSE 'No' END AS triangle FROM Triangle; Consecutive Numbers SHOW PROBLEM Table: Logs\nColumn Name Type id int num varchar id is the primary key for this table. The id column is an auto-increment column that starts from 1. Problem Statement:\nFind all numbers (num) that appear at least three times consecutively in the table.\nReturn the result table in any order.\nExample:\nInput:\nLogs table:\nid num 1 1 2 1 3 1 4 2 5 1 6 2 7 2 Output:\nConsecutiveNums 1 Explanation:\nThe number 1 is the only value that appears at least three times consecutively in the table.\nGo to Leetcode 🔗 SHOW CODE MySQL SELECT DISTINCT l1.num AS ConsecutiveNums FROM Logs l1 JOIN Logs l2 ON l1.id = l2.id - 1 JOIN Logs l3 ON l2.id = l3.id - 1 WHERE l1.num = l2.num AND l2.num = l3.num; SELECT DISTINCT l2.num AS ConsecutiveNums FROM Logs AS l1 JOIN Logs AS l2 ON l1.id = l2.id - 1 AND l1.num = l2.num JOIN Logs AS l3 ON l2.id = l3.id - 1 AND l2.num = l3.num; Product Price at a Given Date SHOW PROBLEM Table: Products\nColumn Name Type product_id int new_price int change_date date (product_id, change_date) is the primary key (a combination of columns with unique values) of this table. Each row indicates that the price of a product was changed to a new price on a specific date. Problem Statement\nWrite a query to find the prices of all products on 2019-08-16. Assume the price of all products before any change is 10.\nReturn the result in any order.\nExample:\nInput:\nProducts table:\nproduct_id new_price change_date 1 20 2019-08-14 2 50 2019-08-14 1 30 2019-08-15 1 35 2019-08-16 2 65 2019-08-17 3 20 2019-08-18 Output:\nproduct_id price 2 50 1 35 3 10 Go to Leetcode 🔗 SHOW CODE MySQL WITH T AS (SELECT DISTINCT product_id FROM Products), P AS ( SELECT product_id, new_price AS price FROM Products WHERE (product_id, change_date) IN ( SELECT product_id, MAX(change_date) AS change_date FROM Products WHERE change_date \u003c= '2019-08-16' GROUP BY 1 ) ) SELECT product_id, IFNULL(price, 10) AS price FROM T LEFT JOIN P USING (product_id); WITH P AS ( SELECT p1.product_id, new_price, change_date FROM ( SELECT DISTINCT product_id FROM Products ) AS p1 LEFT JOIN Products AS p2 ON p1.product_id = p2.product_id AND p2.change_date \u003c= '2019-08-16' ), T AS ( SELECT *, RANK() OVER ( PARTITION BY product_id ORDER BY change_date DESC ) AS rk FROM P ) SELECT product_id, IFNULL(new_price, 10) AS price FROM T WHERE rk = 1; SHOW NOTES Last Person to Fit in the Bus SHOW PROBLEM Table: Queue\nColumn Name Type person_id int person_name varchar weight int turn int The person_id column contains unique values. This table holds information about people waiting to board a bus. The person_id and turn columns contain values from 1 to n, where n is the number of rows in the table. The turn column determines the order in which people will board the bus. A turn value of 1 indicates the first person to board, and turn = n indicates the last person to board. The weight column represents the person’s weight in kilograms. The bus has a weight limit of 1000 kilograms, so some people may not be able to board if the total weight exceeds this limit. The goal is to identify the name of the last person who can board the bus without exceeding the weight limit.\nOnly one person can board the bus at any given time, based on their turn. Input:\nQueue table:\nperson_id person_name weight turn 5 Alice 250 1 4 Bob 175 5 3 Alex 350 2 6 John Cena 400 3 1 Winston 500 6 2 Marie 200 4 Output:\nperson_name John Cena Explanation:\nThe following table shows the order in which people board the bus, ordered by the turn column for simplicity:\nTurn person_id person_name weight Total Weight 1 5 Alice 250 250 2 3 Alex 350 600 3 6 John Cena 400 1000 4 2 Marie 200 1200 5 4 Bob 175 ___ 6 1 Winston 500 ___ John Cena is the last person who can board the bus without exceeding the weight limit of 1000 kilograms.\nGo to Leetcode 🔗 SHOW CODE MySQL WITH T AS ( SELECT person_name, SUM(weight) OVER (ORDER BY turn) AS acumulated_weight FROM Queue ) SELECT person_name FROM T WHERE acumulated_weight \u003c= 1000 ORDER BY acumulated_weight DESC LIMIT 1; Count Salary Categories SHOW PROBLEM Table: Accounts\nColumn Name Type account_id int income int The account_id column is the primary key, meaning it contains unique values for each row. Each row represents the monthly income of a specific bank account. Task:\nWrite a solution to calculate the number of bank accounts in each salary category. The salary categories are defined as:\n\u0026ldquo;Low Salary\u0026rdquo;: Salaries strictly less than $20,000. \u0026ldquo;Average Salary\u0026rdquo;: Salaries in the inclusive range [$20,000, $50,000]. \u0026ldquo;High Salary\u0026rdquo;: Salaries strictly greater than $50,000. The result table should contain all three categories. If no accounts fall into a category, return 0 for that category.\nThe result can be returned in any order.\nInput:\nAccounts table:\naccount_id income 3 108939 2 12747 8 87709 6 91796 Output:\ncategory accounts_count Low Salary 1 Average Salary 0 High Salary 3 Explanation:\nLow Salary: Account 2 has an income of $12,747, which is below $20,000. Average Salary: There are no accounts with an income between $20,000 and $50,000. High Salary: Accounts 3, 6, and 8 have incomes above $50,000. Go to Leetcode 🔗 SHOW CODE MySQL WITH S AS ( SELECT 'Low Salary' AS category UNION SELECT 'Average Salary' UNION SELECT 'High Salary' ), T AS ( SELECT CASE WHEN income \u003c 20000 THEN 'Low Salary' WHEN income \u003e 50000 THEN 'High Salary' ELSE 'Average Salary' END AS category, COUNT(1) AS accounts_count FROM Accounts GROUP BY category ) SELECT category, IFNULL(accounts_count, 0) AS accounts_count FROM S LEFT JOIN T USING (category); Subqueries Exchange Seats SHOW PROBLEM Table: Seat\nColumn Name Type id int student varchar id is the primary key for this table. Each row represents a student\u0026rsquo;s name and their seat ID. The id starts from 1 and increases consecutively. Problem Description:\nWrite a query to swap the seat IDs of every two consecutive students in the Seat table. If the number of students is odd, the last student\u0026rsquo;s seat ID should remain unchanged.\nThe result should be ordered by the id column in ascending order.\nInput:\nSeat table:\nid student 1 Abbot 2 Doris 3 Emerson 4 Green 5 Jeames Output:\nid student 1 Doris 2 Abbot 3 Green 4 Emerson 5 Jeames Explanation:\nThe students Abbot and Doris swap places, as well as Emerson and Green. Since there are an odd number of students, Jeames\u0026rsquo;s seat remains unchanged. Go to Leetcode 🔗 SHOW CODE MySQL SELECT CASE WHEN id % 2 = 1 AND id \u003c (SELECT MAX(id) FROM Seat) THEN id + 1 WHEN id % 2 = 0 THEN id - 1 ELSE id END AS id, student FROM Seat ORDER BY id; Movie Rating SHOW PROBLEM Table: Movies\nColumn Name Type movie_id int title varchar movie_id is the primary key (column with unique values) for this table. title is the name of the movie.\nTable: Users\nColumn Name Type user_id int name varchar user_id is the primary key (column with unique values) for this table. The column \u0026rsquo;name\u0026rsquo; has unique values.\nTable: MovieRating\nColumn Name Type movie_id int user_id int rating int created_at date (movie_id, user_id) is the primary key (column with unique values) for this table. This table contains the rating of a movie by a user in their review. created_at is the user\u0026rsquo;s review date.\nProblem:\nFind the name of the user who has rated the greatest number of movies. In case of a tie, return the lexicographically smaller user name. Find the movie name with the highest average rating in February 2020. In case of a tie, return the lexicographically smaller movie name. Result format:\nThe result should contain two columns:\nresults – containing the user name with the greatest number of movie ratings. results – containing the movie name with the highest average rating in February 2020. Input:\nMovies table:\nmovie_id title 1 Avengers 2 Frozen 2 3 Joker Users table:\nuser_id name 1 Daniel 2 Monica 3 Maria 4 James MovieRating table:\nmovie_id user_id rating created_at 1 1 3 2020-01-12 1 2 4 2020-02-11 1 3 2 2020-02-12 1 4 1 2020-01-01 2 1 5 2020-02-17 2 2 2 2020-02-01 2 3 2 2020-03-01 3 1 3 2020-02-22 3 2 4 2020-02-25 Output:\nresults Daniel Frozen 2 Explanation:\nDaniel and Monica have rated 3 movies (\u0026ldquo;Avengers\u0026rdquo;, \u0026ldquo;Frozen 2\u0026rdquo; and \u0026ldquo;Joker\u0026rdquo;), but Daniel is lexicographically smaller. \u0026ldquo;Frozen 2\u0026rdquo; and \u0026ldquo;Joker\u0026rdquo; both have an average rating of 3.5 in February, but \u0026ldquo;Frozen 2\u0026rdquo; is lexicographically smaller. Go to Leetcode 🔗 SHOW CODE MySQL ( SELECT name AS results FROM Users JOIN MovieRating USING (user_id) GROUP BY user_id ORDER BY COUNT(1) DESC, name LIMIT 1 ) UNION ALL ( SELECT title FROM MovieRating JOIN Movies USING (movie_id) WHERE DATE_FORMAT(created_at, '%Y-%m') = '2020-02' GROUP BY movie_id ORDER BY AVG(rating) DESC, title LIMIT 1 ); ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/database/database-management-system/1-database-management-system/","summary":"Introduction to DBMS A Database Management System (DBMS) is software that provides an interface for users to interact with databases. It enables the management, storage, and manipulation of data within databases. DBMS can be broadly classified into two main types: Relational DBMS and NoSQL DBMS.\nIn a Relational DBMS, data is stored in structured tables and is manipulated using SQL (Structured Query Language). Examples of relational DBMS inlcude MySQL, Oracle, and PostgreSQL.","title":"Database Management Systems"},{"content":"Introduction to Multithreading Program, Process, and Thread A program is a static set of instructions that stores on a disk. A process is an instance of a program that is currently being executed by the operating system. A thread is a small unit of process that can be scheduled and executed by the operating system. In simpler terms, a program is the code, a process is the excution of the code, a thread is a unit of execution within a process. Their relationships are illustrated in the following image:\nProgram, Process, and Thread Thread Life Cycle Within Concurrency A thread goes through various states in its life cycle, from creation to its termination. The life cycle of a thread typically includes five states: New, Runnable, Running, Blocked/Waiting, and Terminated.\nNew: This refers to the state where a thread instance is created but has not yet started running. In Java, this is commonly achieved by using new Thread(). Runnable: This refers to the state where a thread instance is ready to run but is waiting for CPU time. In Java, this is commonly achieved by ivoking start() on the thread instance. Running: This is refers to the state where the thread instance is actively executing its task. Blocked/Waiting: This refers to the state where a thread instance is waiting for other threads to complete their tasks, or it is waiting for a particular condition to be met. Terminated: This refers to the state where the thread instance has completed its task and has exited. Thread Life Cycle Within Concurrency Fork/Join Model The Fork/Join Model is an effective strategy commonly used in scenarios where a task can be recursively divided into multiple smaller, independent subtasks. This strategy typically involves the following steps:\nThe process begins with a single master thread. When it encounters a task that can be broken down into smaller subtasks, the master thread forks (spawns) multiple subsidiary threads, each of which takes on a portion of the task.\nOnce the subsidiary threads have completed their respective tasks, they join back with the master thread. Joining involves terminating the subsidiary threads and consolidating their results into the master thread. Afterward, the master thread continues its execution.\nFork/Join Model SHOW CODE Java import java.util.Arrays; import java.util.concurrent.RecursiveTask; import java.util.concurrent.ForkJoinPool; public class Solution { // RecursiveTask to compute the sum of a part of an array static class SumTask extends RecursiveTask { private final int[] array; private final int start; private final int end; // Threshold for splitting the task into smaller subtasks private static final int THRESHOLD = 1000; public SumTask(int[] array, int start, int end) { this.array = array; this.start = start; this.end = end; } @Override protected Long compute() { // If the task is small enough, calculate the sum directly if (end - start \u003c= THRESHOLD) { long sum = 0; for (int i = start; i \u003c end; i++) { sum += array[i]; } return sum; } // Otherwise, split the task into two subtasks int middle = (start + end) / 2; SumTask leftTask = new SumTask(array, start, middle); SumTask rightTask = new SumTask(array, middle, end); // Fork the subtasks leftTask.fork(); rightTask.fork(); // Join the results of the subtasks long leftResult = leftTask.join(); long rightResult = rightTask.join(); // Combine the results and return return leftResult + rightResult; } } public static void main(String[] args) { int[] array = new int[10000]; // Initialize all elements to 1 Arrays.fill(array, 1); // Create a ForkJoinPool to execute the tasks ForkJoinPool pool = new ForkJoinPool(); // Submit the task to the ForkJoinPool SumTask task = new SumTask(array, 0, array.length); long result = pool.invoke(task); System.out.println(\"Sum: \" + result); // Output the result } } SHOW OUTPUT Output Sum: 10000 Critical Section \u0026amp; Race Condition Critical Section refers to a portion of a program where shared resources are accessed and modified. A Race Condition occurs when the program\u0026rsquo;s behavior depends on the non-deterministic execution order of threads. Since multiple threads can access a critical section concurrently, it is essential to synchronize their access to avoid data inconsistency.\nFor example, suppose there are four threads trying to read a value of 20 from memory. Each thread increments the value by 1 and writes it back to memory. Without synchronization mechanisms, after all threads complete their writes, the final value might be 21 instead of the expected 24. This leads to an unexpected outcome, as illustrated below.\nCritical Section \u0026amp; Race Condition To resolve this issue, access to the critical section must be exclusive. This is commonly achieved by using mutexes, read/write locks, semaphores, conditional variables or barriers to ensure that only one thread can modify the shared resource at a time.\nSynchronization Mechanisms Synchronization Mechanisms are rules used to coordinate the execution of threads in a program, ensuring safe access to shared resources. These mechanisms can be primarily classified into five types: Mutexes, Read/Write Locks, Semaphores, Conditional Variables, and Barriers.\nMutex Mechanism The mutex mechanism ensures that only one thread can access the critical section at a time. Other threads will be blocked until the mutex is released. The key logic behind the mutex mechanism is as follows:\nLock lock = new ReentrantLock(); lock.lock(); // Acquire the lock try { // Critical section code } finally { lock.unlock(); // Release the lock } Mutex Mechanism SHOW CODE Java public class Mutex { private static int counter = 0; private static final Object lock = new Object(); public static void runExperiment(String experimentName, Runnable task) { counter = 0; Thread t1 = new Thread(task); Thread t2 = new Thread(task); t1.start(); t2.start(); try { t1.join(); t2.join(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"Final counter value \" + experimentName + \": \" + counter + \"\"); } public static void incrementCounterWithMutex() { for (int i = 0; i \u003c 100; i++) { synchronized (lock) { int temp = counter; try { Thread.sleep(1); // Sleep for 1 millisecond } catch (InterruptedException e) { e.printStackTrace(); } counter = temp + 1; } } } public static void incrementCounterNoMutex() { for (int i = 0; i \u003c 100; i++) { int temp = counter; try { Thread.sleep(1); // Sleep for 1 millisecond } catch (InterruptedException e) { e.printStackTrace(); } counter = temp + 1; } } public static void main(String[] args) { runExperiment(\"With Mutex Experiment\", Mutex::incrementCounterWithMutex); runExperiment(\"No Mutex Experiment\", Mutex::incrementCounterNoMutex); } } SHOW OUTPUT Output Final counter value With Mutex Experiment: 200 Final counter value No Mutex Experiment: 100 Read/Write Lock Mechanism The Read/Write Lock Mechanism allows threads read the shared resources concurrently, but ensures exclusive access for write operations. This mechanism is useful in scenarios where there are many read operations and fewer write operations, such as caching systems or databases. The key logic behind the read/write lock mechanism is as follows:\nReadWriteLock rwLock = new ReentrantReadWriteLock(); rwLock.readLock().lock(); // Acquire read lock try { // Read operation } finally { rwLock.readLock().unlock(); // Release read lock } rwLock.writeLock().lock(); // Acquire write lock try { // Write operation } finally { rwLock.writeLock().unlock(); // Release write lock } Under the Read/Write Lock mechanism, multiple threads can access the critical section simultaneously without blocking each other. When a writer thread is accessing the critical section, other writer threads and reader threads are blocked. Similarly, when a reader thread is accessing the critical section, the writer thread is blocked.\nRead/Write Lock Mechanism SHOW CODE Java import java.util.ArrayList; import java.util.List; import java.util.concurrent.locks.ReentrantReadWriteLock; public class ReadWriteLock { private static volatile int counter = 0; private static final int TARGET_VALUE = 1000; private static final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(); public static int incrementValue() { lock.writeLock().lock(); try { Thread.sleep(1); if (counter \u003c TARGET_VALUE) { counter++; } } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.writeLock().unlock(); } return counter; } public static int readValue() { lock.readLock().lock(); try { Thread.sleep(1); return counter; } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.readLock().unlock(); } return 0; } public static void main(String[] args) { long start = System.currentTimeMillis(); List readers = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u003c 8; i++) { readers.add(new Thread(() -\u003e { while (readValue() \u003c TARGET_VALUE) { try { Thread.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } } })); } List writers = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u003c 2; i++) { writers.add(new Thread(() -\u003e { while (incrementValue() \u003c TARGET_VALUE) { try { Thread.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } } })); } readers.forEach(Thread::start); writers.forEach(Thread::start); readers.forEach(t -\u003e { try { t.join(); } catch (InterruptedException e) { e.printStackTrace(); } }); writers.forEach(t -\u003e { try { t.join(); } catch (InterruptedException e) { e.printStackTrace(); } }); long end = System.currentTimeMillis(); System.out.println(\"Time taken: \" + (end - start) / 1000.0 + \" seconds\"); } } SHOW OUTPUT Output Time taken: 1.787 seconds In the above code, the readValue method uses a read lock, allowing multiple reader threads to access the counter (critical section) simultaneously without blocking each other. If the method used a write lock instead of a read lock, the execution time would be higher. This is because when a writer thread is accessing the counter, all other threads would be blocked.\npublic static int readValue() { // lock.readLock().lock(); lock.writeLock().lock(); try { Thread.sleep(1); return counter; } catch (InterruptedException e) { e.printStackTrace(); } finally { // lock.readLock().unlock(); lock.writeLock().unlock(); } return 0; } Time taken: 6.793 seconds # Use write lock Semaphore Mechanism The Semaphore mechanism uses an integer to manage a set of permits, allowing multiple threads to access shared resources simultaneously, but only up to a predetermined limit. There are two types of semaphores: Binary Semaphore and Counting Semaphore.\nBinary Semaphore: Similar to a mutex, it operates with two states (0 and 1), ensuring mutual exclusion in critical sections. Counting Semaphore: Allows a count greater than 1, permitting multiple threads to access shared resources concurrently, as long as the permit limit is not exceeded. Semaphores are useful in controlling access to a pool of resources, such as limiting the number of threads that can access a database connection or a server. The key logic behind the semaphore mechanism is as follows:\nSemaphore semaphore = new Semaphore(3); // Allow 3 threads at once semaphore.acquire(); // Acquire a permit try { // Critical section code } finally { semaphore.release(); // Release a permit } Semaphore Mechanism SHOW CODE Java import java.util.concurrent.Semaphore; import java.util.concurrent.atomic.AtomicInteger; public class SemaphoreTest { // Global shared resource // AtomicInteger allows multiple threads to read/write value of counter without requiring synchronization private static final AtomicInteger counter = new AtomicInteger(0); // Semaphore with a count of 5 private static final Semaphore semaphore = new Semaphore(5); private static final int TARGET_VALUE = 5000; public static void main(String[] args) { long startTime = System.currentTimeMillis(); Thread[] workers = new Thread[10]; for (int i = 0; i \u003c workers.length; i++) { workers[i] = new Thread(SemaphoreTest::worker); workers[i].start(); } for (Thread worker : workers) { try { worker.join(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); System.out.println(\"Thread was interrupted\"); } } long endTime = System.currentTimeMillis(); System.out.println(\"Time taken: \" + (endTime - startTime) / 1000.0 + \" seconds\"); } private static void worker() { while (true) { try { semaphore.acquire(); // Acquire the semaphore if (counter.get() \u003e= TARGET_VALUE) { break; } counter.incrementAndGet(); // Atomically increments the counter Thread.sleep(1); // Simulate work } catch (InterruptedException e) { Thread.currentThread().interrupt(); System.out.println(\"Thread was interrupted\"); } finally { semaphore.release(); // Release the semaphore } } } } Conditional Variable Mechanism The Conditional Variable Mechanism allows a thread to suspend its execution until other threads signal that a certain condition has been met. It is often used in conjunction with mutexes to implement synchronization patterns, such as the producer-consumer pattern.\nIn this mechanism, a thread can wait on a condition variable until it is notified by other threads that the condition has been satisfied. When the condition is fulfilled, one or more threads can be signaled to wake up and proceed. Condition variables are commonly used in scenarios like the producer-consumer problem, where one thread produces data and another consumes it, with both threads needing to wait for each other under specific conditions.\nThe key logic behind the Conditional Variable Mechanism is as follows:\nsynchronized (lock) { while (!condition) { lock.wait(); // Wait until condition is true } // Proceed with critical section } synchronized (lock) { condition = true; lock.notify(); // Notify waiting threads } Conditional Variable Mechanism SHOW CODE Wait \u0026amp; Notify Busy Waiting public class ConditionalVariable { private static final Object mutex = new Object(); private static int sharedNumber; private static boolean ready = false; public static void producer() { synchronized (mutex) { sharedNumber = 9; // Producing a number ready = true; System.out.println(\"Producer has produced the number: \" + sharedNumber); mutex.notify(); // Notify the consumer } } public static void consumer() { synchronized (mutex) { while (!ready) { try { mutex.wait(); // Wait until the number is ready } catch (InterruptedException e) { Thread.currentThread().interrupt(); System.out.println(\"Consumer thread was interrupted.\"); } } System.out.println(\"Consumer has consumed the number: \" + sharedNumber); } } public static void main(String[] args) { Thread producerThread = new Thread(ConditionalVariable::producer); Thread consumerThread = new Thread(ConditionalVariable::consumer); producerThread.start(); consumerThread.start(); try { producerThread.join(); consumerThread.join(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); System.out.println(\"Main thread was interrupted.\"); } } } public class Solution { private static final Object mutex = new Object(); private static int sharedNumber; private static boolean ready = false; private static void producer() { synchronized (mutex) { sharedNumber = 9; // Producing a number ready = true; System.out.println(\"Producer has produced the number: \" + sharedNumber); } } private static void consumer() { // Busy waiting loop while (true) { synchronized (mutex) { if (ready) { System.out.println(\"Consumer has consumed the number: \" + sharedNumber); break; } } try { Thread.sleep(1); // Sleep for a short time } catch (InterruptedException e) { Thread.currentThread().interrupt(); System.out.println(\"Thread was interrupted\"); } } } public static void main(String[] args) { Thread producerThread = new Thread(Solution::producer); Thread consumerThread = new Thread(Solution::consumer); producerThread.start(); consumerThread.start(); try { producerThread.join(); consumerThread.join(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); System.out.println(\"Main thread was interrupted\"); } } } Barrier Mechanism The Barrier Mechanism allows threads to wait for each other at a specified point in their execution. It ensures that threads cannot proceed to the subsequent code until all threads have reached the barrier, as illustrated in the following image.\nBarrier Mechanism Barrier Mechanism are useful in parallel algorithms where multiple threads need to work in phases, and the next phase cannot begin until all threads complete the current one.\nThe key logic behind this mechanism is as follows:\nCyclicBarrier barrier = new CyclicBarrier(4, new Runnable() { public void run() { System.out.println(\u0026#34;All threads reached the barrier!\u0026#34;); } }); // Threads: barrier.await(); // Wait at the barrier SHOW CODE Java import java.util.concurrent.CyclicBarrier; class Barriers { private static final CyclicBarrier barrier = new CyclicBarrier(2, () -\u003e System.out.println(\"All threads have reached the barrier. Continue execution.\")); public static void main(String[] args) { Thread t1 = new Thread(Barriers::work); Thread t2 = new Thread(Barriers::work); // Start both threads. t1.start(); t2.start(); } private static void work() { System.out.println(\"Thread \" + Thread.currentThread().getName() + \" is waiting at the barrier\"); try { // Wait for the specified number of threads (2 in this case) to reach the barrier. barrier.await(); System.out.println(\"Thread \" + Thread.currentThread().getName() + \" is released\"); } catch (Exception e) { // Handle exceptions, if any. } } } SHOW OUTPUT Output Thread Thread-0 is waiting at the barrier Thread Thread-1 is waiting at the barrier All threads have reached the barrier. Continue execution. Thread Thread-1 is released Thread Thread-0 is released Thread Creation In Java Extending Thread Class SHOW CODE Java class MyThread extends Thread { @Override public void run() { System.out.println(this.getName() + \" is running.\"); } } public class Main { public static void main(String[] args) { MyThread myThread = new MyThread(); myThread.setName(\"MYTHREAD-0\"); myThread.start(); } } Implementing Runnable Interface SHOW CODE Java public class Main { public static void main(String[] args) { Thread thread = new Thread(() -\u003e System.out.println(Thread.currentThread().getName() + \" is running.\")); thread.start(); } } //class MyRunnable implements Runnable { // @Override // public void run() { // System.out.println(\"Thread is running\"); // } //} // //public class Main { // public static void main(String[] args) { // Thread thread = new Thread(new MyRunnable()); // thread.start(); // Starts a new thread // } //} Using the Callable Interface SHOW CODE Java import java.util.concurrent.*; public class Main { public static void main(String[] args) throws Exception { ExecutorService executor = Executors.newSingleThreadExecutor(); Future\u0026lt;String\u0026gt; future = executor.submit(() -\u003e Thread.currentThread().getName() + \" is running.\"); System.out.println(future.get()); executor.shutdown(); } } class MyCallable implements Callable\u0026lt;String\u0026gt; { // @Override // public String call() { // return \"Thread executed\"; // } //} // //public class Main { // public static void main(String[] args) throws Exception { // ExecutorService executor = Executors.newSingleThreadExecutor(); // Future\u0026lt;String\u0026gt; future = executor.submit(new MyCallable()); // System.out.println(future.get()); // Retrieves the result // executor.shutdown(); // } //} Using Executors SHOW CODE Java import java.util.concurrent.*; public class Main { public static void main(String[] args) { ExecutorService executor = Executors.newFixedThreadPool(2); Runnable task1 = () -\u003e System.out.println(Thread.currentThread().getName() + \" executed\"); Runnable task2 = () -\u003e System.out.println(Thread.currentThread().getName() + \" executed\"); executor.execute(task1); executor.execute(task2); executor.shutdown(); } } Thread Termination In Java Using a flag SHOW CODE Java class Task implements Runnable { // Use volatile to ensure visibility between thread private volatile boolean running = true; @Override public void run() { while (running) { System.out.println(\"Thread is running.\"); try { Thread.sleep(1000); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } System.out.println(\"Thread is stopping.\"); } public void stop() { running = false; } } public class Main { public static void main(String[] args) throws InterruptedException { Task task = new Task(); Thread thread = new Thread(task); thread.start(); Thread.sleep(3000); // Allow thread to run for a while task.stop(); // Signal thread to stop } } Interrupting a Thread SHOW CODE Java public class Main { public static void main(String[] args) throws InterruptedException { Thread thread = new Thread(() -\u003e { try { while (!Thread.currentThread().isInterrupted()) { System.out.println(\"Thread is running\"); Thread.sleep(1000); } } catch (InterruptedException e) { System.out.println(\"Thread is interrupted\"); } }); thread.start(); Thread.sleep(3000); // Allow thread to run for a while thread.interrupt(); // Interrupt the thread } } Daemon Threads A daemon thread in Java is a low-priority thread that runs in the background, typically handling tasks such as garbage collection or other housekeeping operations. The JVM terminates when all non-daemon threads have completed execution, even if daemon threads are still active. To create a daemon thread, the setDaemon(true) method is used on a Thread object before it is started.\nSHOW CODE Java public class Main { public static void main(String[] args) { Thread daemonThread = new Thread(() -\u003e { while (true) { System.out.println(\"Daemon thread is running\"); try { Thread.sleep(1000); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } }); daemonThread.setDaemon(true); // Mark as daemon daemonThread.start(); System.out.println(\"Main thread is ending\"); } } SHOW OUTPUT Output Main thread is ending Daemon thread is running Performance Optimization When it comes to multithreading, performance optimization typically focuses on two key areas: latency reduction and throughput improvement.\nLatency reduction refers to minimizing the time it takes to complete a single task, measured in time units. This is often achieved by breaking a task into smaller subtasks that can be executed concurrently by multiple threads.\nThroughput, on the other hand, measures the number of tasks completed within a specific time frame, typically expressed as tasks / time unit. Throughput improvement is commonly achieved by utilizing thread pooling, which reduces the overhead of creating and destroying threads for each task.\nSHOW CODE: Latency Reduction Java import javax.imageio.ImageIO; import java.awt.image.BufferedImage; import java.io.File; import java.io.IOException; import java.util.ArrayList; import java.util.List; public class Main { private static final String SOURCE_FILE = \"src/main/resources/1-flower.jpg\"; private static final String DESTINATION_FILE = \"./out/1-flower.jpg\"; public static void main(String[] args) throws IOException { BufferedImage originalImage = ImageIO.read(new File(SOURCE_FILE)); BufferedImage resultImage = new BufferedImage(originalImage.getWidth(), originalImage.getHeight(), BufferedImage.TYPE_INT_RGB); long startTime = System.currentTimeMillis(); // recolorSingleThreaded(originalImage, resultImage); int numberOfThreads = 1; recolorMultithreaded(originalImage, resultImage, numberOfThreads); long endTime = System.currentTimeMillis(); long duration = endTime - startTime; File outputFile = new File(DESTINATION_FILE); File parentDir = outputFile.getParentFile(); if (parentDir != null \u0026\u0026 !parentDir.exists()) { parentDir.mkdirs(); // Create the directory if it doesn't exist } ImageIO.write(resultImage, \"jpeg\", outputFile); System.out.println(\"duration = \" + duration); } public static void recolorMultithreaded(BufferedImage originalImage, BufferedImage resultImage, int numberOfThreads) { List\u0026lt;Thread\u0026gt; threads = new ArrayList\u0026lt;\u0026gt;(); int width = originalImage.getWidth(); int height = originalImage.getHeight() / numberOfThreads; for(int i = 0; i \u003c numberOfThreads ; i++) { final int threadMultiplier = i; Thread thread = new Thread(() -\u003e { int xOrigin = 0 ; int yOrigin = height * threadMultiplier; recolorImage(originalImage, resultImage, xOrigin, yOrigin, width, height); }); threads.add(thread); } for(Thread thread : threads) { thread.start(); } for(Thread thread : threads) { try { thread.join(); } catch (InterruptedException e) { } } } private static void recolorSingleThreaded(BufferedImage originalImage, BufferedImage resultImage) { recolorImage(originalImage, resultImage, 0, 0, originalImage.getWidth(), originalImage.getHeight()); } private static void recolorImage(BufferedImage originalImage, BufferedImage resultImage, int leftCorner, int topCorner, int width, int height) { for (int x = leftCorner; x \u003c leftCorner + width \u0026\u0026 x \u003c originalImage.getWidth(); x++) { for (int y = topCorner; y \u003c topCorner + height \u0026\u0026 y \u003c originalImage.getHeight(); y++) { recolorPixel(originalImage, resultImage, x, y); } } } private static void recolorPixel(BufferedImage originalImage, BufferedImage resultImage, int x, int y) { int rgb = originalImage.getRGB(x, y); int red = getRed(rgb); int green = getGreen(rgb); int blue = getBlue(rgb); int newRed; int newGreen; int newBlue; if (isShadeOfGray(red, green, blue)) { newRed = Math.min(255, red + 10); newGreen = Math.max(0, green - 80); newBlue = Math.max(0, blue - 20); } else { newRed = red; newGreen = green; newBlue = blue; } int newRGB = createRGBFromColors(newRed, newGreen, newBlue); setRGB(resultImage, x, y, newRGB); } public static void setRGB(BufferedImage image, int x, int y, int rgb) { image.getRaster().setDataElements(x, y, image.getColorModel().getDataElements(rgb, null)); } public static boolean isShadeOfGray(int red, int green, int blue) { return Math.abs(red - green) \u003c 30 \u0026\u0026 Math.abs(red - blue) \u003c 30 \u0026\u0026 Math.abs(green - blue) \u003c 30; } public static int createRGBFromColors(int red, int green, int blue) { int rgb = 0; rgb |= blue; rgb |= green \u003c\u003c 8; rgb |= red \u003c\u003c 16; rgb |= 0xFF000000; return rgb; } public static int getRed(int rgb) { return (rgb \u0026 0x00FF0000) \u003e\u003e 16; } public static int getGreen(int rgb) { return (rgb \u0026 0x0000FF00) \u003e\u003e 8; } public static int getBlue(int rgb) { return rgb \u0026 0x000000FF; } } SHOW IMAGE: BEFORE PROCESSING SHOW IMAGE: AFTER PROCESSING Single Threaded VS. Multithreaded SHOW CODE: Throughput vs. Threads Throughput vs. Threads import com.sun.net.httpserver.HttpExchange; import com.sun.net.httpserver.HttpHandler; import com.sun.net.httpserver.HttpServer; import java.io.IOException; import java.io.OutputStream; import java.net.InetSocketAddress; import java.nio.file.Files; import java.nio.file.Paths; import java.util.concurrent.Executor; import java.util.concurrent.Executors; public class ThroughputHttpServer { private static final String INPUT_FILE = \"./resources/war_and_peace.txt\"; private static final int NUMBER_OF_THREADS = 8; public static void main(String[] args) throws IOException { String text = new String(Files.readAllBytes(Paths.get(INPUT_FILE))); startServer(text); } public static void startServer(String text) throws IOException { HttpServer server = HttpServer.create(new InetSocketAddress(8000), 0); server.createContext(\"/search\", new WordCountHandler(text)); Executor executor = Executors.newFixedThreadPool(NUMBER_OF_THREADS); server.setExecutor(executor); server.start(); } private static class WordCountHandler implements HttpHandler { private String text; public WordCountHandler(String text) { this.text = text; } @Override public void handle(HttpExchange httpExchange) throws IOException { String query = httpExchange.getRequestURI().getQuery(); String[] keyValue = query.split(\"=\"); String action = keyValue[0]; String word = keyValue[1]; if (!action.equals(\"word\")) { httpExchange.sendResponseHeaders(400, 0); return; } long count = countWord(word); byte[] response = Long.toString(count).getBytes(); httpExchange.sendResponseHeaders(200, response.length); OutputStream outputStream = httpExchange.getResponseBody(); outputStream.write(response); outputStream.close(); } private long countWord(String word) { long count = 0; int index = 0; while (index \u003e= 0) { index = text.indexOf(word, index); if (index \u003e= 0) { count++; index++; } } return count; } } } SHOW IMAGE: Throughput VS. Threads Problems Linear Search with Finding One Occurrence SHOW PROBLEM Problem Statement:\nThe input consists of a large array (or list) of elements and a target value to search for. The goal is to utilize multiple threads to divide the search space and concurrently search for the target value, ultimately returning the index of the first occurrence of the target or -1 indicating that the target is not present.\nRequirements:\nMultithreading: Divide the array into multiple segments, with each thread searching a specific segment of the array. Each thread should operate independently and search its assigned segment. Return First Occurrence: Once the target value is found by any thread, it should return the index of the first occurrence, and other threads should stop searching. Constraints:\nThe array can be large (millions of elements). The number of threads used should be adjustable. The target value may appear multiple times in the array, but only the index of the first occurrence should be returned. SHOW CODE Java public class Solution { private static final int SIZE = 280000; private static final int NUM_THREADS = 4; private static final Object mtx = new Object(); // Mutex for controlling access to foundIndex private static volatile int foundIndex = -1; private static void linearSearch(int threadId, int[] arr, int key) { int chunkSize = arr.length / NUM_THREADS; int start = threadId * chunkSize; int end = (threadId == NUM_THREADS - 1) ? arr.length : start + chunkSize; for (int i = start; i \u003c end; ++i) { // Early exit if foundIndex is set by another thread synchronized (mtx) { if (foundIndex != -1) { break; } } if (arr[i] == key) { synchronized (mtx) { if (foundIndex == -1) { foundIndex = i; break; // Exit after setting foundIndex } } } } } public static void main(String[] args) { // Fill array with random numbers between 0-99 int[] arr = new int[SIZE]; for (int i = 0; i \u003c SIZE; ++i) { arr[i] = (int) (Math.random() * 100); } Thread[] threads = new Thread[NUM_THREADS]; int key = 9; for (int i = 0; i \u003c NUM_THREADS; ++i) { final int threadId = i; threads[i] = new Thread(() -\u003e linearSearch(threadId, arr, key)); threads[i].start(); } for (Thread thread : threads) { try { thread.join(); } catch (InterruptedException e) { e.printStackTrace(); } } if (foundIndex == -1) { System.out.println(\"Element not found in the array.\"); } else { System.out.println(\"Element found at index: \" + foundIndex); } } } Linear Search for All Occurrences SHOW PROBLEM Problem Statement:\nThe input consists of a large array (or list) of elements and a target value to search for. The goal is to utilize multiple threads to divide the search space and concurrently search for the target value, ultimately returning the index of all occurrences of the target or an empty list indicating that the target is not present.\nRequirements:\nMultithreading: Divide the array into multiple segments, with each thread searching a specific segment of the array. Each thread should operate independently and search its assigned segment. Return All Occurrences: Once the target value is found, the thread should store the index. All threads should continue searching, and their results (all indices of the target’s occurrences) should be combined and returned. Constraints:\nThe array can be large (millions of elements). The number of threads used should be adjustable. The target value may appear multiple times in the array, and all indices where the target is found should be returned. SHOW CODE Java import java.util.ArrayList; import java.util.List; import java.util.Random; public class Solution { private static final int SIZE = 4000; private static final int NUM_THREADS = 4; // Mutex for controlling access to foundPlaces private static final Object lockObj = new Object(); private static List\u0026lt;Integer\u0026gt; foundPlaces = new ArrayList\u0026lt;\u0026gt;(); private static void linearSearch(int threadId, int[] arr, int key) { int chunkSize = arr.length / NUM_THREADS; int start = threadId * chunkSize; int end = (threadId == NUM_THREADS - 1) ? arr.length : start + chunkSize; for (int i = start; i \u003c end; ++i) { if (arr[i] == key) { synchronized (lockObj) { // Lock when modifying foundPlaces foundPlaces.add(i); // Append the index to foundPlaces } } } } public static void main(String[] args) { // Create an array and fill it with random numbers between 0 and 99 int[] arr = new int[SIZE]; Random random = new Random(); for (int i = 0; i \u003c SIZE; ++i) { arr[i] = random.nextInt(100); } Thread[] threads = new Thread[NUM_THREADS]; // List to hold the threads int key = 9; // Element to find // Start the threads for (int i = 0; i \u003c NUM_THREADS; ++i) { final int threadId = i; threads[i] = new Thread(() -\u003e linearSearch(threadId, arr, key)); threads[i].start(); } // Join the threads with the main thread for (Thread thread : threads) { try { thread.join(); } catch (InterruptedException e) { e.printStackTrace(); } } // Display the result if (foundPlaces.isEmpty()) { System.out.println(\"Element not found in the array.\"); } else { System.out.print(\"Element found at indices: \"); synchronized (lockObj) { // Lock when reading from foundPlaces for (int index : foundPlaces) { System.out.print(index + \" \"); } } System.out.println(); } } } SHOW NOTES The synchonization block can be removed when reading values from foundPlaces, as no threads modify the foundPlaces after the join() method is called.\n// Display the result if (foundPlaces.isEmpty()) { System.out.println(\u0026#34;Element not found in the array.\u0026#34;); } else { System.out.print(\u0026#34;Element found at indices: \u0026#34;); // No need for synchronization here, as no threads are modifying foundPlaces now // synchronized (lockObj) { // Lock when reading from foundPlaces for (int index : foundPlaces) { System.out.print(index + \u0026#34; \u0026#34;); } // } System.out.println(); } Linear Search with Indices and Occurrences SHOW PROBLEM Problem Statement:\nYou are given a large array (or list) of elements and a target value to search for. Your task is to implement a linear search that finds all occurrences of the target value in the array using multiple threads. Each thread should search a specific segment of the array, and the results (indices where the target is found) should be stored in a shared collection (e.g., a list). Additionally, a shared variable should keep track of the count of occurrences of the target value.\nRequirements:\nMultithreading: Divide the array into equal segments based on the number of threads. Each thread should independently search its assigned segment for the target value. The number of threads should be adjustable to optimize performance depending on the size of the array. Return: A list of integers representing the indices of all occurrences of the target value. An integer representing the total count of occurrences of the target value. Constraints:\nThe array can be very large, potentially containing millions of elements. The number of threads used should be adjustable, allowing the program to scale with the size of the array and the system\u0026rsquo;s available resources. The target value may appear multiple times, and all occurrences should be included in the final result. SHOW CODE Java import java.util.ArrayList; import java.util.List; import java.util.Random; public class Solution { private static final int SIZE = 4000; private static final int NUM_THREADS = 4; private static final List\u0026lt;Integer\u0026gt; foundIndices = new ArrayList\u0026lt;\u0026gt;(); // Shared list to store the indices of all occurrences private static int occurrencesCount = 0; // Shared variable to store the count of occurrences private static final Object indicesLock = new Object(); // Lock for synchronizing access to foundIndices private static final Object countLock = new Object(); // Lock for synchronizing access to occurrencesCount // Function executed by each thread to search for indices and occurrences private static void searchIndicesOccurrences(int threadId, int[] arr, int key) { int chunkSize = arr.length / NUM_THREADS; int start = threadId * chunkSize; int end = (threadId == NUM_THREADS - 1) ? arr.length : start + chunkSize; List\u0026lt;Integer\u0026gt; localIndices = new ArrayList\u0026lt;\u0026gt;(); int localCount = 0; for (int i = start; i \u003c end; ++i) { if (arr[i] == key) { localIndices.add(i); localCount++; } } if (!localIndices.isEmpty()) { synchronized (indicesLock) { foundIndices.addAll(localIndices); } } if (localCount \u003e 0) { synchronized (countLock) { occurrencesCount += localCount; } } } public static void main(String[] args) { // Create an array and fill it with random numbers between 0 and 99 int[] arr = new int[SIZE]; Random random = new Random(); for (int i = 0; i \u003c SIZE; ++i) { arr[i] = random.nextInt(100); } Thread[] threads = new Thread[NUM_THREADS]; // Array of threads int key = 9; // Element to find // Start the threads for (int i = 0; i \u003c NUM_THREADS; ++i) { int threadId = i; threads[i] = new Thread(() -\u003e searchIndicesOccurrences(threadId, arr, key)); threads[i].start(); } // Wait for all threads to complete for (Thread thread : threads) { try { thread.join(); } catch (InterruptedException e) { e.printStackTrace(); } } // Output the results if (foundIndices.isEmpty()) { System.out.println(\"Element not found in the array.\"); } else { System.out.print(\"Element found \" + occurrencesCount + \" times at indices: \"); for (int index : foundIndices) { System.out.print(index + \" \"); } System.out.println(); } } } Min/Max/Sum SHOW PROBLEM Problem Statement:\nThe input consists of a large array (or list) of elements. The goal is to efficiently calculate the minimum, maximum, and sum of elements in the array using multithreading. The array is divided into multiple segments, with each thread processing a specific segment. The threads will then return partial results (minimum, maximum, and sum for their respective segments), which will be combined to compute the final values for the entire array.\nRequirements:\nMultithreading: Divide the array into multiple segments, with each thread processing a specific portion of the array. Each thread should independently compute the minimum, maximum, and sum for its assigned segment.\nCombine Results: Once each thread has finished processing, their partial results (min, max, and sum for the segment) should be combined to compute the final minimum, maximum, and sum for the entire array.\nEfficiency: The program should use multithreading to optimize the processing time, especially when dealing with large arrays containing millions of elements. The number of threads should be adjustable for optimal performance.\nConstraints:\nThe array can be large (millions of elements).\nThe number of threads used should be adjustable based on the size of the array and the system’s capabilities.\nThe array can contain both positive and negative numbers, and the minimum, maximum, and sum should be computed accurately, including for arrays with all negative values.\nSHOW CODE Java import java.util.Random; public class Solution { private static final int DATA_SIZE = 100; private static final int NUMBER_OF_THREADS = 4; private static int[] data = new int[DATA_SIZE]; private static int[] threadResultsSum = new int[NUMBER_OF_THREADS]; private static int[] threadResultsMin = new int[NUMBER_OF_THREADS]; private static int[] threadResultsMax = new int[NUMBER_OF_THREADS]; public static void main(String[] args) throws InterruptedException { // Initialize data array Random random = new Random(); for (int i = 0; i \u003c DATA_SIZE; i++) { data[i] = random.nextInt(500); } Thread[] threads = new Thread[NUMBER_OF_THREADS * 3]; // Start threads for sum, min, and max calculations for (int i = 0; i \u003c NUMBER_OF_THREADS; i++) { final int threadId = i; final int start = threadId * (DATA_SIZE / NUMBER_OF_THREADS); final int end = (threadId + 1) * (DATA_SIZE / NUMBER_OF_THREADS); threads[threadId] = new Thread(() -\u003e threadedSum(threadId, start, end)); threads[threadId + NUMBER_OF_THREADS] = new Thread(() -\u003e threadedMin(threadId, start, end)); threads[threadId + NUMBER_OF_THREADS * 2] = new Thread(() -\u003e threadedMax(threadId, start, end)); threads[threadId].start(); threads[threadId + NUMBER_OF_THREADS].start(); threads[threadId + NUMBER_OF_THREADS * 2].start(); } // Wait for threads to finish for (Thread thread : threads) { thread.join(); } // Aggregate results from threads int totalSum = 0; for (int sum : threadResultsSum) { totalSum += sum; } int min = Integer.MAX_VALUE; for (int minResult : threadResultsMin) { min = Math.min(min, minResult); } int max = Integer.MIN_VALUE; for (int maxResult : threadResultsMax) { max = Math.max(max, maxResult); } System.out.println(\"Sum is \" + totalSum); System.out.println(\"Min is \" + min); System.out.println(\"Max is \" + max); } private static void threadedSum(int threadId, int start, int end) { int sum = 0; for (int i = start; i \u003c end; i++) { sum += data[i]; } threadResultsSum[threadId] = sum; } private static void threadedMin(int threadId, int start, int end) { int min = Integer.MAX_VALUE; for (int i = start; i \u003c end; i++) { min = Math.min(min, data[i]); } threadResultsMin[threadId] = min; } private static void threadedMax(int threadId, int start, int end) { int max = Integer.MIN_VALUE; for (int i = start; i \u003c end; i++) { max = Math.max(max, data[i]); } threadResultsMax[threadId] = max; } } Pi Calculation SHOW PROBLEM Problem Statement\nThe problem is to estimate the value of Pi using the Monte Carlo simulation method. In this method, we randomly generate points within a square and check how many of these points fall inside a circle inscribed within the square. The ratio of points inside the circle to the total points generated provides an approximation of Pi.\nRequirements:\nRandom Point Generation:\nGenerate a large number of random points within a square. The square should have side lengths of 2 (i.e., points with coordinates ranging from -1 to 1 on both the x and y axes). Each point has coordinates $(x, y)$, where $x$ and $y$ are randomly generated floating-point values between -1 and 1. Circle Inside the Square:\nA circle is inscribed within the square, with a radius of 1 and centered at the origin (0, 0). A point $(x, y)$ lies inside the circle if the following condition is true: $$ x^2 + y^2 \\leq 1 $$ Monte Carlo Estimation of Pi:\nCount how many of the generated points fall inside the circle. The ratio of the points inside the circle to the total number of points can be used to estimate Pi. Specifically, the approximation of Pi is given by: $$ \\pi \\approx 4 \\times \\frac{\\text{points inside the circle}}{\\text{total number of points}} $$ Multithreading:\nTo speed up the simulation, divide the task of generating points and checking whether they lie inside the circle into multiple threads. Each thread should be responsible for generating a subset of points and counting how many fall inside the circle. Once all threads finish their work, their results should be combined to compute the final approximation of Pi. Output:\nReturn the estimated value of Pi based on the simulation. Constraints:\nThe number of points to generate can be very large (millions of points). The number of threads used should be adjustable. The accuracy of the approximation improves with more points, but the simulation should be efficient enough to handle large numbers of points and multiple threads. SHOW CODE Java import java.util.Random; public class Solution { private static final int NUM_THREADS = 10; private static final int NUMBER_OF_TOSSES = 100000000; private static int[] results = new int[NUM_THREADS]; public static void main(String[] args) throws InterruptedException { Thread[] threads = new Thread[NUM_THREADS]; for (int i = 0; i \u003c NUM_THREADS; i++) { final int threadId = i; threads[i] = new Thread(() -\u003e { Random rand = new Random(); int start = threadId * NUMBER_OF_TOSSES / NUM_THREADS; int end = (threadId + 1) * NUMBER_OF_TOSSES / NUM_THREADS; int count_in_circle = 0; for (int j = start; j \u003c end; j++) { double x = rand.nextDouble() * 2 - 1; // Random x in range [-1, 1] double y = rand.nextDouble() * 2 - 1; // Random y in range [-1, 1] if (x * x + y * y \u003c= 1) { // If point is inside the circle count_in_circle++; } } results[threadId] = count_in_circle; }); threads[i].start(); } for (Thread thread : threads) { thread.join(); } // Compute final estimate of Pi int total_inside = 0; for (int result : results) { total_inside += result; } double pi_estimate = 4.0 * total_inside / NUMBER_OF_TOSSES; System.out.println(\"PI = \" + pi_estimate); } } SHOW NOTES Introduction to Monte Carlo Estimation of $\\pi$\nSuppose a square with a circle inscribed inside it, as shown in the image below. The circle has a radius of $r$, and the square has side length $2r$. The area of the circle is $A_{\\text{circle}} = \\pi r^2$, and the area of the square is $A_{\\text{square}} = (2r)^2 = 4r^2$\nThe ratio of the area of the circle to the area of the square is $$ \\frac{A_{\\text{circle}}}{A_{\\text{square}}} = \\frac{\\pi r^2}{4 r^2} = \\frac{\\pi}{4} $$\nTherefore, the value of $\\pi$ can be estimated by the formula:\n$$ \\pi \\approx 4 \\times \\frac{\\text{Number of points inside the circle}}{\\text{Total number of points inside the square}} $$\nVisulization:\n","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/multithreading-and-concurrency/1-multithreading-and-concurrency/","summary":"Introduction to Multithreading Program, Process, and Thread A program is a static set of instructions that stores on a disk. A process is an instance of a program that is currently being executed by the operating system. A thread is a small unit of process that can be scheduled and executed by the operating system. In simpler terms, a program is the code, a process is the excution of the code, a thread is a unit of execution within a process.","title":"Multithreading \u0026 Concurrency"},{"content":"Introduction to System Design System Design is the process of defining the architecture, components, modules, interfaces, and data for a system to fulfill specific business requirements, while ensuring scalability, maintainability, and performance.\nLoad Balancing In System Design, Load Balancing refers to the practice of distributing incoming network traffic or workload across multiple servers or resources to optimize resource use and ensure high availability.\nLoad Balancing To fullly leverage scalability and redundency, load balancing can occur at different layers: between user and the web server, between web server and an internal platform serve, between internal platform server and database as illustrated in the following image:\nLoad Balancing at Different Layers The typical process of load balancing involves the following steps:\nThe load balancer recerves a request from the client. The load balancer evaluates the request and routes it to a server based on the chosen load balancing algorithm. The selected server or resource processes the request and sends the response back to the load balancer. The load balancer receives the response and forwards it to the client. --- title: Process of Load Balancing --- sequenceDiagram participant Client participant LoadBalancer participant Server Client-\u003e\u003eLoadBalancer: Sends Request LoadBalancer-\u003e\u003eLoadBalancer: Evaluates Request (Load Balancing Algorithm) LoadBalancer-\u003e\u003eServer: Routes Request to Selected Server Server-\u003e\u003eLoadBalancer: Sends Response LoadBalancer-\u003e\u003eClient: Forwards Response Load Balancing Algorithms A load balancing algorithm is a method used by a load balancer to determine how an incoming request should be distributed across multiple servers. Commonly used load balancing algorithms include Round Robin, Least Connections, Weight Round Robin, Weighted Least Connections, IP Hash, Least Response Time, Random, and Least Bandwidth.\nRound Robin The Round Robin algorithm distributes requests evenly across multiple servers in a circular manner. This algorithm does not consider the current load or capabilities of each server. It is commonly used in environments where servers have similar capacity and performance, or in applications where each request can be handled independently.\nRound Robin Load Balancing Algorithm Least Connections The Least Connections algorithm distributes requests to servers with the fewest active connections. It takes into account the server\u0026rsquo;s current workload, helping to prevent any single server from becoming overwhelmed. This algorithm is particularly useful in scenerios where traffic or workload is unpredictable, servers have varying capabilities, or maintaining session state is important.\nLeast Connections Load Balancing Algorithm Weighted Round Robin The Weighted Round Robin algorithm is an enhanced version of Round Robin, where each server is assigned a weight based on its capability and workload. Servers with higher weights process more requests, helping to prevent overloading less powerful servers. This algorithm is ideal for scenarios where servers have varying processing abilities, such as in a database cluster, where nodes with higher processing power can handle more queries.\nWeighted Round Robin Load Balancing Algorithm Weighted Least Connections The Weighted Least Connections algorithm is a combination of the Least Connections and the Weighted Round Robin algorithms. It takes into account the number of active connections of each server and the weight assigned to a server based on its capability. Requests are routed to servers based on the load factor, which is commonly calculated using the formular: the number of active connections of a server divided by its weight.\n$$ \\text{Load Factor} = \\frac{\\text{Number of Active Connections}}{\\text{Weight of the Server}} $$\nWeighted Least Connections Load Balancing Algorithm IP Hash The H+IP Hash algorithm routes requests to servers based on a hash of the client\u0026rsquo;s IP address. The load balancer applies a hash function to the client\u0026rsquo;s IP address to calculate the hash value, which is then used to determined which server will handle the current request. If the distribution of client IP addresses is uneven, some servers may receive more requests than others, leading to an imbalanced load. This algorithm is ideal for scenarios where maintaining state is important, such as online shopping carts or user sessions.\nIP Hash Load Balancing Algorithm Least Response Time The Least Response Time algorithm routes incoming requests to the server with the lowest response time, ensuring efficient resource utilization and optimal client experience. It is ideal for scenerios where low latancy and fast response times are crucial, such as online gaming and financial trading.\nLeast Response Time Load Balancing Algorithm Random The Random load balancing algorithm routes incoming requests to servers randomly. It is commonly used in scenarios where the load is relatively uniform and the servers have similar capabilities.\nRandom Load Balancing Algorithm Least Bandwidth The Least Bandwidth algorithm routes incoming requests to the server that is consuming the least amount of bandwidth. It is ideal for applications with high bandwidth usage, such as vedio streaming, file downloads, and large file transfers.\nLeast Bandwidth Load Balancing Algorithm Redundent Load Balancers The Single Point of Failure (SPOF) refers to any component in a system or infrastructure that, if it fails, causes the entire system or a significant portion of it to become unavailable. For instance, if a load balancer is responsible for routing all incoming requests to servers, its faulure would result in the entire system or application becoming inoperable. To mitigate this risk, redundent load balancers can be deployed.\nFor example, in an active-passive setup, two load balancers are used, where both are capable of routing traffic and detecting failures. The active load balancer handles all incoming requests, and if it fails, the passive load balancer takes over to ditribute requests, ensuring continuous availability. This approach helps prevent the system from being dependent on a single point of failure, as illustrated in the following diagram.\nLoad Balancer Cluster API Gateway An API Gateway is a server-side component that acts as a central entry point for clients to access as a collection of microservices. It recerves client requests, forwards them to the appropriate microservice, and then returns the response from the server to the client. The API Gateway is responsible for various tasks, such as request routing, authentication, rate limiting.\nAPI Gateway The key difference between an API Gateway and a load balancer lies in their core functions. An API Gateway focuses on routing requests to specific microservices. In contrast, a Load Balancer is responsible for distributing incoming traffic across multiple backend servers. Additionally, while an API Gateway typically deals with requests that target specific APIs identified by unique URLs, a load balancer generally handles requests directed to a single, well-known IP address, distributing those requests to one of serveral backend servers based on load-balancing algorithms.\nThe Difference Between API Gateway and Load Balancer Key Characteristics of Distributed System Scalability Scalability refers to a system\u0026rsquo;s ability to handle increasing workloads. In system design, there are two primary types of scaling: horizontal and vertical. Horizontal scaling involves adding more machines to distribute the load across multiple servers, while vertical scaling typically involves upgrading the hardware of a single machine.\nVertical Scaling vs. Horizontal Scaling Availability In system design, availability refers to the ability of a system to remain operational even in the face of faulures or high demand. Factors that affect availability include redundency, failover mechanisms, and load balancing. Redundency involves duplicating critical components to ensure that if one fails, another can take over. Failover mechanisms refer to the ability to quickly switch to a backup system during failure. Load balancing distributes requests across multiple servers to prevent any single point from becoming overwhelmed.\nIn distributed systems, there is often a trade-off between availability and consistency. The three common types of consistency models are strong, weak, and eventual consistency. The strong consistency model ensure that all replicas have the same data at all times, which can reduce availability and performance. The weak consistency model allows for temporary inconsistencies between replicas, offering improved availability and performance. The eventual consistency model guarantees that all replicas will eventually converge to the same data, balancing consistency and availability over time.\nMonitoring Monitoring in distributed systems is crucial for identifying issues and ensuring the overall health of the system. It typically involves four key components: metrics collection, distributed tracing, logging, and anomaly detection.\nMetrics collection involves gathering and analyzing key performance indicators such as latency, throughput, error rates, and resource utilization. This helps identify performance bottlenecks, potential issues, and areas for optimization. Common tools for metrics collection inculde Prometheus, Graphite, and InfluxDB.\nDistributed tracing is a technique for tracking and analyzing requests as they pass through various services, helping identify issues within specific services. Common tools for distributed tracing include Zipkin.\nLogging refers to the collection, centralization, and analysis of logs from all services in a distributed system. It provides valuable insights into system behavior, aiding in debugging and troubleshooting. Tools like the ELK Stack (Elasticsearch, Logstash, Kibana) are used for logging.\nAnomaly detection involves monitoring for unusual behaviors or patterns and notifying the appropriate team when such events occur. Tools like Grafana can be used for anomaly detection in distributed systems.\nCaching Introduction to Caching In system design, caching is a high-speed storage layer positioned between the application and the original data source, such as a database or a remote web service. The primary goal of caching is to minimize access to the original data source, thereby improving application performance. Caching can be implemented in various forms, including in-memory caching, disk caching, database caching, and CDN caching:\nIn-memory caching stores data directly in the computer\u0026rsquo;s memory, offering faster access than disk storage. Disk caching stores data on disk, which is slower than memory but faster than fetching data from an external source. Database caching stores data within the database itself, reducing the need to access external storage systems. CDN caching stores data on a distributed network of servers, minimizing latency when accessing data from remote locations. Here are some key caching terms:\nCache Hit: Occurs when the requested data is found in the cache. Cache Miss: Happens when the requested data is not found in the cache, requiring a fetch from the original data source. Cache Eviction: The process of removing data from the cache, often to make room for new data based on a predefined cache eviction policy. Cache Staleness: Refers to the situation where the cached data is outdated compared to the original data source. Here are some of the most common types of caching:\nTypes of Caching Caching Replacement Policies When caching data becomes outdated, it should be removed. Therefore, specifying a cache replacement policy is crucial when implementing caching. Common cache replacement policies include: LRU (Least Recently Used), LFU (Least Frequently Used), FIFO (First In, First Out), and Random Replacement.\nLRU (Least Recently Used) removes the least recently accessed data when the cache becomes full. It ensures that data that have been accessed more recently are more likely to be accessed again in the future. LFU (Least Frequently Used) removes the least frequently accessed data when the cache is full. It ensures that data that have been accessed more frequently are more likely to be accessed again in the futrue. FIFO (First In, First Out) removes the oldest data when the cache becomes full. It assumes that the oldest data are least likely to be accessed in the future. Random Replacement removes random data when the cache is full. This policy can be useful when the data access pattern is unpredictable. Cache Invalidation Cache Invalidation is the process of marking data in the cache as stale or directly removing it from the cache, ensuring that the cache doesn\u0026rsquo;t serve outdated or incorrect data. Common cache invalidation schemes include write-through cache, write-around cache, write-back cache, and write-behind cache.\nWrite-Through Cache: In a write-through scheme, data is written to both the cache and the data store simultaneously. This ensures that the cached always serves the most up-to-date data, but it introduces latency, as each write operation must be performed twice before the data is returned. Write-Around Cache: In a write-around scheme, data is directly written to the underlying data store, bypassing the cache. This prevents the cache from becoming flooded with less frequently accessed data, while ensuring that the data store always holds the most recent data. However, this can result in a cache miss when requesting data that was recently written. Write-Back Cache: In a write-back scheme, data is written only to the cache, and the write operation is immediately confirmed. The data is written to the data store only when the cached data is evicted. This ensures low latency and high throughput but may lead to data loss in the event of a crash, as the data is stored only in the cache. Write-Behind Cache: Similar to the write-back scheme, the write-behind cache writes data to the underlying store after a specified delay. The key difference is that in a write-back cache, data is only written to the data store when necessary (e.g., upon eviction). In contrast, in a write-behind cache, data is written to the data store at regular intervals. Here are some of the most commonly used cache invalidation methods:\nPurge: The purge method removes cached data immediately. When a purge request is received, the cached data is deleted, and the next time the key is requested, the cache fetches a fresh copy from the original data store, stores it, and returns it. Refresh: The refresh method updates the cached data with the latest data from the original data store. This ensures the cache always holds the most up-to-date data. Ban: The ban method blocks access to certain cached data. When a ban command is issued, the key is added to a ban list. From then on, every request is checked against the ban list. If the requested resource matches an invalidation rule, the cache treats it as stale, fetches a fresh copy from the original data store, and updates the cache. Unlike purge, which removes the cache entry immediately, ban simply marks the entry as stale, and the data remains in the cache until it is evicted. Time To Live (TTL) Expiration: This method involves setting a time-to-live (TTL) value for cached data. Once the TTL expires, the data is considered stale. When a request is made, the cache checks the TTL of the cached data and serves it only if if hasn\u0026rsquo;t expired. If expired, the cache fetches the fresh copy from the original data store and returns it. Stale-While-Revalidate: This method serves the cached data to the client immediately when a request is received. Meanwhile, the cache asynchronously updates itself with the latest version of the data from the original data store. This approach ensures a qucik response, even if the cached data is slightly outdated, and is commonly used in CDN caching. Cache Invalidation Methods Cache Read Strategies Cache read strategies define how the cache behaves when a cache miss occurs. The most common cache read strategies are read-through and read-aside.\nIn a read-through cache strategy, the cache is responsible for fetching fresh data from the original data store when a cache miss occurs. If the requested data is not found in the cache, the cache automatically retrives the data from the data store, stores it in the cache, and returns it to the client. In a read-aside cache strategy, the application first requests the data from the caceh. If the data is found, the cached data is used. However, if the data is not found, the application fetches the data from the underlying data store, updates the cache with the retrived data, and then uses it. Cache Coherence and Cache Consistence Cache coherence refers to the consistency of data stored in multiple caches that are part of the same system, particularly in multi-core systems. In a distributed system, each cache may store a local copy of shared data. When one cache modifies its copy, all other caches holding a copy of that data must be updated or invalidated to maintain consistency. The most common protocols for achieving cache coherence are write-invalidate and write-update.\nWrite-Invalidate: When a cache writes to its copy of shared data, it broadcasts a message to all other caches, invalidating their copies. When another cache needs the updated data, it fetches the new data from memory or from the cache that made the update. Write-Update: When a cache writes to its copy of shared data, it broadcasts a message to all other caches, prompting them to update their local copies accordingly. Cache consistency focuses on maintaining the consistency of data between the cache and the original data source. Cache consistency models define the rules governing how data is updated and accessed in a distributed system with multiple caches. These models vary in terms of their strictness, and include strict consistency, sequential consistency, casual consistency, and eventual consistency.\nStrict Consistency: In a strict consistency model, any write to a data item is immediately visible to all caches. While this ensures data is always up-to-date, it may lead to performance issues due to the significant synchronization overhead required. Sequential Consistency: In a sequential consistency model, all operations on data items must appear in a specific, sequential order across all caches. This model ensures a predictable order of operations but may not guarantee the exact real-time visibility of changes. Casual Consistency: In a casual consistency model, operations that are casually related (e.g., one operation depends on the outcome of another) are guaranteed to appear in order across multiple caches. Operations that are not casually related can occur in any order. This model strikes a balance between on consistency and performance. Eventual Consistency: In an eventual consistency model, updates to a data item will eventually propagate to all caches, but there is no guarantee regarding the order or timing of these updates. This model offers the best performance but the weakest consistency guarantees, making it ideal for distributed systems where performance and scalability are prioritized over strict consistency. Caching Challenges The main cache-related issues include Thundering Herd, Cache Penetration, Cache Stampede, and Cache Pollution.\nThundering Herd: This problem arises when a popular piece of data expires, leading to a sundden surge of requests to the original server, resulting in performance degradation. Solutions include staggered expiration times, cache locking, or background updates before expiration.\nCache Penetration: This occurs when multiple requests for non-existent data bypass the cache, querying the original data store directly. Solutions include negative caching (caching \u0026ldquo;not found\u0026rdquo; responses) or using a Bloom Filter to check the existence of data before querying the cache.\nCache Stampede: This happens when multiple requests for the same data arrive after cache expires, causing a heavy load on the original data source. Solutions typically involve request coalescing (letting on request fetch the data while others wait) or implementing a read-through cache, where the cache itself fetches missing data. Cache Pollution: This occurs when less frequently accessed data displaces more frequently accessed data, reducing cache hit rates. To mitigate cache pollution, eviction policies such as LRU (Least Recently Used) or LFU (Least Frequently Used) can be implemented.\nData Partitioning In system design, data partitioning is a technique used to break large datasets into smaller, more manageable units called partitions. Each partition is independent and contains a subset of the overall data. Common data partitioning methods include horizontal partitioning and vertical partitioning.\nHorizontal partitioning, also known as sharding, involves dividing a database into multiple shards, with each shard containing a subset of rows. These shards are typically stored on different database servers, allowing for parallel processing and improving query execution times. Vertical partitioning divides a database into multiple partitions based on columns, with each partition containing a subset of the columns. This technique is commonly used when some fields are accessed more frequently than others, optimizing performance for specific queries. Horizontal Partitioning vs. Vertical Partitioning Data sharding splits table horizontally, here are some common sharding techniques.\nRange-Based Sharding: Data is divided based on a specific range, such as numeric ranges or dates. For example, an e-commerce platform may partition the order table by order date. Hash-Based Sharding: Data is partitioned by applying a hash function to a partition key. The hash value determines which shard will store the data. Directory-Based Sharding: Data is partitioned based on a lookup table that tracks which shard contains which data. Geographical Sharding: Data is divided based on geographical locations, such as countries or regions. Hybrid-Based Sharding: A combination of multiple sharding strategies to optimize system performance. ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/system-design/1-system-design/","summary":"Introduction to System Design System Design is the process of defining the architecture, components, modules, interfaces, and data for a system to fulfill specific business requirements, while ensuring scalability, maintainability, and performance.\nLoad Balancing In System Design, Load Balancing refers to the practice of distributing incoming network traffic or workload across multiple servers or resources to optimize resource use and ensure high availability.\nLoad Balancing To fullly leverage scalability and redundency, load balancing can occur at different layers: between user and the web server, between web server and an internal platform serve, between internal platform server and database as illustrated in the following image:","title":"System Design"},{"content":"Basic Components of Compiter Hardware Von Neumann Architecture Von Neumann Architecture is a computer architecture model that forms the foundation of modern computer systems. It primarily consists of five major components: the CPU, Memory, Input Devices, Output Devices, and Buses.\nThe CPU (Central Processing Unit) contains two main parts: the Arithmetic and Logic Unit (ALU) and the Control Unit. The ALU performs mathematical calculations and logical operations, while the Control Unit manages the processor\u0026rsquo;s operations by fetching, decoding, and executing instructions.\nThe Memory is used to store both instructions and data. It consists of two main types: RAM (Random Access Memory) and ROM (Read-Only Memory). RAM temporarily stores data and instructions while the program is running, while ROM stores the system\u0026rsquo;s firmware and startup instructions.\nInput Devices allow users to provide data or commands to the computer, such as keyboards, mice, and scanners.\nOutput Devices display the results of the computer\u0026rsquo;s processing, such as monitors, printers, and speakers.\nVon Neumann Architecture Buses are pathways used to transfer data between the CPU, memory, and input/output devices. There are three main types of buses: Data Buses, Control Buses, and Address Buses. The Data Bus transfers actual data, the Control Bus manages the signals that direct operations, and the Address Bus carries memory addresses to and from the CPU.\nIn Von Neumann Architecture, both data and instructions are represented in binary. Instructions are composed of two main components: the opcode and the address code. The opcode specifies the operation to be performed, such as addition, subtraction, or data transfer, while the address code refers to the memory location where the data for the operation is stored.\nThe core of Von Neumann Architecture is the ALU, which handles all computational tasks. The architecture also follows the concept of a stored program, where both data and instructions are stored in the same memory, with no distinction between them. Additionally, in a Von Neumann system, the program is executed sequentially, meaning instructions are fetched one at a time, and the CPU processes them in order.\nModern Computer Architecture One limitation of the Von Neumann Architecture is known as the Von Neumann bottleneck. This refers to the limitation on thoughput caused by the shared memory bus, where the CPU is often waiting for data to be fetched from memory, leading to delays.\nTo overcome the Von Neumann Bottleneck, modern computer architecture adopts a memory-centric design. In this design, the primary memory serves as the central component, connecting all other parts of the system. This design reduces latency and enhances performance, ensuring that the CPU can access data more efficiently. By optimizing memory access, it helps alleviate the limitations imposed by the traditional Von Neumann Architecture and improves overall system throughput.\nModern Computer Architecture The Five Components Memory The Memory is made up of three primary components: the memory unit, the Memory Address Register (MAR), and the Memory Data Register (MDR).\nThe memory unit consists of individual storage cells, each of which stores a sequence of binary code, referred to as a storage word. The number of bits in this binary code defines the word length. Each bit in the binary code is stored by an electronic component called a storage element, which is capable of holding one bit of information.\nThe MAR (Memory Address Register) holds the address of the storage cell that is currently being accessed. It indicates the specific location within the memory cell. The number of bits of MAR reflects the number of storage cells available in memory. For example, if MAR is 2 bits, it can represent $2^2$ addresses: 00, 01, 10, and 11. The MDR (Memory Data Register) holds the data that is being read from or written to the memory. The number of bits in the MDR is equal to the word length of the storage cell being accessed.\nMemory Arithmetic Unit ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/meocs-408/1-principles-of-computer-organization/","summary":"Basic Components of Compiter Hardware Von Neumann Architecture Von Neumann Architecture is a computer architecture model that forms the foundation of modern computer systems. It primarily consists of five major components: the CPU, Memory, Input Devices, Output Devices, and Buses.\nThe CPU (Central Processing Unit) contains two main parts: the Arithmetic and Logic Unit (ALU) and the Control Unit. The ALU performs mathematical calculations and logical operations, while the Control Unit manages the processor\u0026rsquo;s operations by fetching, decoding, and executing instructions.","title":"Principles of Computer Organization"},{"content":"1. STEVE JOBS: Stanford Speech https://youtu.be/1i9kcBHX2Nw SHOW SUBTITLES I am honored to be with you today at your commencement from one of the finest universities in the world. I never graduated from college. Truth be told, this is the closest I\u0026rsquo;ve ever gotten to a college graduation. Today I want to tell you three stories from my life. That\u0026rsquo;s it. No big deal. Just three stories.\nThe first story is about connecting the dots.\nI dropped out of Reed College after the first 6 months, but then stayed around as a drop-in for another 18 months or so before I really quit. So why did I drop out?\nIt started before I was born. My biological mother was a young, unwed college graduate student, and she decided to put me up for adoption. She felt very strongly that I should be adopted by college graduates, so everything was all set for me to be adopted at birth by a lawyer and his wife. Except that when I popped out they decided at the last minute that they really wanted a girl. So my parents, who were on a waiting list, got a call in the middle of the night asking: \u0026ldquo;We have an unexpected baby boy; do you want him?\u0026rdquo; They said: \u0026ldquo;Of course.\u0026rdquo; My biological mother later found out that my mother had never graduated from college and that my father had never graduated from high school. She refused to sign the final adoption papers. She only relented a few months later when my parents promised that I would someday go to college.\nAnd 17 years later I did go to college. But I naively chose a college that was almost as expensive as Stanford, and all of my working-class parents\u0026rsquo; savings were being spent on my college tuition. After six months, I couldn\u0026rsquo;t see the value in it. I had no idea what I wanted to do with my life and no idea how college was going to help me figure it out. And here I was spending all of the money my parents had saved their entire life. So I decided to drop out and trust that it would all work out OK. It was pretty scary at the time, but looking back it was one of the best decisions I ever made. The minute I dropped out I could stop taking the required classes that didn\u0026rsquo;t interest me, and begin dropping in on the ones that looked interesting.\nIt wasn\u0026rsquo;t all romantic. I didn\u0026rsquo;t have a dorm room, so I slept on the floor in friends\u0026rsquo; rooms, I returned coke bottles for the $0.05 deposits to buy food with, and I would walk the 7 miles across town every Sunday night to get one good meal a week at the Hare Krishna temple. I loved it. And much of what I stumbled into by following my curiosity and intuition turned out to be priceless later on. Let me give you one example:\nReed College at that time offered perhaps the best calligraphy instruction in the country. Throughout the campus, every poster, every label on every drawer, was beautifully hand calligraphed. Because I had dropped out and didn\u0026rsquo;t have to take the normal classes, I decided to take a calligraphy class to learn how to do this. I learned about serif and san serif typefaces, about varying the amount of space between different letter combinations, about what makes great typography great. It was beautiful, historical, artistically subtle in a way that science can\u0026rsquo;t capture, and I found it fascinating.\nNone of this had even a hope of any practical application in my life. But ten years later, when we were designing the first Macintosh computer, it all came back to me. And we designed it all into the Mac. It was the first computer with beautiful typography. If I had never dropped in on that single course in college, the Mac would have never had multiple typefaces or proportionally spaced fonts. And since Windows just copied the Mac, it\u0026rsquo;s likely that no personal computer would have them. If I had never dropped out, I would have never dropped in on this calligraphy class, and personal computers might not have the wonderful typography that they do. Of course it was impossible to connect the dots looking forward when I was in college. But it was very, very clear looking backwards ten years later.\nAgain, you can\u0026rsquo;t connect the dots looking forward; you can only connect them looking backwards. So you have to trust that the dots will somehow connect in your future. You have to trust in something — your gut, destiny, life, karma, whatever. This approach has never let me down, and it has made all the difference in my life.\nMy second story is about love and loss.\nI was lucky — I found what I loved to do early in life. Woz and I started Apple in my parents’ garage when I was 20. We worked hard, and in 10 years Apple had grown from just the two of us in a garage into a $2 billion company with over 4000 employees. We had just released our finest creation — the Macintosh — a year earlier, and I had just turned 30. And then I got fired. How can you get fired from a company you started? Well, as Apple grew we hired someone who I thought was very talented to run the company with me, and for the first year or so things went well. But then our visions of the future began to diverge and eventually we had a falling out. When we did, our Board of Directors sided with him. So at 30 I was out. And very publicly out. What had been the focus of my entire adult life was gone, and it was devastating.\nI really didn\u0026rsquo;t know what to do for a few months. I felt that I had let the previous generation of entrepreneurs down — that I had dropped the baton as it was being passed to me. I met with David Packard and Bob Noyce and tried to apologize for screwing up so badly. I was a very public failure, and I even thought about running away from the valley. But something slowly began to dawn on me — I still loved what I did. The turn of events at Apple had not changed that one bit. I had been rejected, but I was still in love. And so I decided to start over .\nI didn\u0026rsquo;t see it then, but it turned out that getting fired from Apple was the best thing that could have ever happened to me. The heaviness of being successful was replaced by the lightness of being a beginner again, less sure about everything. It freed me to enter one of the most creative periods of my life.\nDuring the next five years, I started a company named NeXT, another company named Pixar, and fell in love with an amazing woman who would become my wife. Pixar went on to create the world’s first computer animated feature film, Toy Story, and is now the most successful animation studio in the world. In a remarkable turn of events, Apple bought NeXT, I returned to Apple, and the technology we developed at NeXT is at the heart of Apple\u0026rsquo;s current renaissance. And Laurene and I have a wonderful family together.\nI\u0026rsquo;m pretty sure none of this would have happened if I hadn\u0026rsquo;t been fired from Apple. It was awful tasting medicine, but I guess the patient needed it. Sometimes life hits you in the head with a brick. Don\u0026rsquo;t lose faith. I\u0026rsquo;m convinced that the only thing that kept me going was that I loved what I did. You\u0026rsquo;ve got to find what you love. And that is as true for your work as it is for your lovers. Your work is going to fill a large part of your life, and the only way to be truly satisfied is to do what you believe is great work. And the only way to do great work is to love what you do. If you haven\u0026rsquo;t found it yet, keep looking. Don\u0026rsquo;t settle. As with all matters of the heart, you\u0026rsquo;ll know when you find it. And, like any great relationship, it just gets better and better as the years roll on. So keep looking until you find it. Don\u0026rsquo;t settle.\nMy third story is about death.\nWhen I was 17, I read a quote that went something like: \u0026ldquo;If you live each day as if it was your last, someday you\u0026rsquo;ll most certainly be right.\u0026rdquo; It made an impression on me, and since then, for the past 33 years, I have looked in the mirror every morning and asked myself: \u0026ldquo;If today were the last day of my life, would I want to do what I am about to do today?\u0026rdquo; And whenever the answer has been \u0026ldquo;No\u0026rdquo; for too many days in a row, I know I need to change something.\nRemembering that I\u0026rsquo;ll be dead soon is the most important tool I\u0026rsquo;ve ever encountered to help me make the big choices in life. Because almost everything — all external expectations, all pride, all fear of embarrassment or failure — these things just fall away in the face of death, leaving only what is truly important. Remembering that you are going to die is the best way I know to avoid the trap of thinking you have something to lose. You are already naked. There is no reason not to follow your heart.\nAbout a year ago I was diagnosed with cancer. I had a scan at 7:30 in the morning, and it clearly showed a tumor on my pancreas. I didn\u0026rsquo;t even know what a pancreas was. The doctors told me this was almost certainly a type of cancer that is incurable, and that I should expect to live no longer than three to six months. My doctor advised me to go home and get my affairs in order, which is doctor\u0026rsquo;s code for prepare to die. It means to try to tell your kids everything you thought you\u0026rsquo;d have the next 10 years to tell them in just a few months. It means to make sure everything is buttoned up so that it will be as easy as possible for your family. It means to say your goodbyes.\nI lived with that diagnosis all day. Later that evening I had a biopsy, where they stuck an endoscope down my throat, through my stomach and into my intestines, put a needle into my pancreas and got a few cells from the tumor. I was sedated, but my wife, who was there, told me that when they viewed the cells under a microscope the doctors started crying because it turned out to be a very rare form of pancreatic cancer that is curable with surgery. I had the surgery and I\u0026rsquo;m fine now.\nThis was the closest I\u0026rsquo;ve been to facing death, and I hope it\u0026rsquo;s the closest I get for a few more decades. Having lived through it, I can now say this to you with a bit more certainty than when death was a useful but purely intellectual concept:\nNo one wants to die. Even people who want to go to heaven don\u0026rsquo;t want to die to get there. And yet death is the destination we all share. No one has ever escaped it. And that is as it should be, because Death is very likely the single best invention of Life. It is Life\u0026rsquo;s change agent. It clears out the old to make way for the new. Right now the new is you, but someday not too long from now, you will gradually become the old and be cleared away. Sorry to be so dramatic, but it is quite true.\nYour time is limited, so don\u0026rsquo;t waste it living someone else\u0026rsquo;s life. Don\u0026rsquo;t be trapped by dogma — which is living with the results of other people\u0026rsquo;s thinking. Don\u0026rsquo;t let the noise of others\u0026rsquo; opinions drown out your own inner voice. And most important, have the courage to follow your heart and intuition. They somehow already know what you truly want to become. Everything else is secondary.\nWhen I was young, there was an amazing publication called The Whole Earth Catalog, which was one of the bibles of my generation. It was created by a fellow named Stewart Brand not far from here in Menlo Park, and he brought it to life with his poetic touch. This was in the late 1960s, before personal computers and desktop publishing, so it was all made with typewriters, scissors, and polaroid cameras. It was sort of like Google in paperback form, 35 years before Google came along: it was idealistic, and overflowing with neat tools and great notions.\nStewart and his team put out several issues of The Whole Earth Catalog, and then when it had run its course, they put out a final issue. It was the mid-1970s, and I was your age. On the back cover of their final issue was a photograph of an early morning country road, the kind you might find yourself hitchhiking on if you were so adventurous. Beneath it were the words: \u0026ldquo;Stay Hungry. Stay Foolish.\u0026rdquo; It was their farewell message as they signed off. Stay Hungry. Stay Foolish. And I have always wished that for myself. And now, as you graduate to begin anew, I wish that for you.\nStay Hungry. Stay Foolish.\nThank you all very much.\n","permalink":"https://signalyu.github.io/posts/3-humanities/languages/listening/english/2-learn-english-with-speeches/","summary":"1. STEVE JOBS: Stanford Speech https://youtu.be/1i9kcBHX2Nw SHOW SUBTITLES I am honored to be with you today at your commencement from one of the finest universities in the world. I never graduated from college. Truth be told, this is the closest I\u0026rsquo;ve ever gotten to a college graduation. Today I want to tell you three stories from my life. That\u0026rsquo;s it. No big deal. Just three stories.\nThe first story is about connecting the dots.","title":"Learn English With Speeches"},{"content":"String 华为OD机试：字符串分割【100分】 点击查看题目 一、题目描述\n给定一个非空字符串 S，其中包含多个子串，这些子串由 - 符号分隔。我们还给定一个正整数 K，要求按以下规则转换字符串：\n对于字符串中的每个子串，从第二个子串开始，将其分为每 K 个字符的片段。 对每个片段应用以下转换规则： 如果片段中小写字母数量多于大写字母，将该片段的所有大写字母转换为小写字母。 如果片段中大写字母数量多于小写字母，将该片段的所有小写字母转换为大写字母。 如果大写和小写字母数量相等，不做转换。 二、输入描述\n输入包含两行：\n第一行为整数 K。 第二行为字符串 S，由 - 分隔成多个子串。 三、输出描述\n输出转换后的字符串。\n四、测试用例\n测试用例 1 输入\n3 12abc-abcABC-4aB@ 输出\n12abc-abc-ABC-4aB-@ 说明\n子串为 12abc、abcABC、4aB@。第一个子串保留。 对 abcABC 按每 3 个字符分组为 abc 和 ABC： abc 中小写字母多，转换为 abc。 ABC 中大写字母多，转换为 ABC。 对 4aB@ 按每 3 个字符分组为 4aB 和 @： 4aB 中大小写字母数量相等，不做转换。 @ 中无字母，不做转换。 最终输出为 12abc-abc-ABC-4aB-@。 测试用例 2\n输入\n3 Test-aaBBcc-CCddEE 输出\nTest-aab-bcc-CCD-DEE 说明\n子串为 Test、aaBBcc、CCddEE。第一个子串保留。 对 aaBBcc 按每 3 个字符分组为 aab 和 bcc： aab 中小写字母多，转换为 aab。 bcc 中小写字母多，转换为 bcc。 对 CCddEE 按每 3 个字符分组为 CCD 和 DEE： CCD 中大写字母多，转换为 CCD。 DEE 中大写字母多，转换为 DEE。 最终输出为 Test-aab-bcc-CCD-DEE。 点击查看代码 Java import java.util.*; class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取正整数 k int k = Integer.parseInt(in.nextLine().trim()); // 读取字符串 String s = in.nextLine().trim(); // 字符串转换 String result = transformString(s, k); // 输出结果 System.out.println(result); } private static String transformString(String s, int k) { // 根据 \"-\" 分隔符获取子串数组 String[] substringList = s.split(\"-\"); // 构建结果容器 StringBuilder builder = new StringBuilder(); builder.append(substringList[0]); for (int i = 1; i \u003c substringList.length; i++) { builder.append(\"-\"); // 子字符串进一步转换 String transformed = transformSubstring(substringList[i], k); builder.append(transformed); } return builder.toString(); } private static String transformSubstring(String s, int k) { // 构建结果容器 StringBuilder builder = new StringBuilder(); for (int i = 0; i \u003c s.length(); i += k) { int end = Math.min(i + k, s.length()); String subString = s.substring(i, end); // 对子串进行大小写转换处理 String transformed = applyCaseTransformation(subString); builder.append(transformed).append(\"-\"); } // 去除最后一个 \"-\" builder.setLength(builder.length() - 1); return builder.toString(); } private static String applyCaseTransformation(String s) { int lowerCaseCount = 0; int upperCaseCount = 0; // 统计字符串中大小写字母的频率 for (char c : s.toCharArray()) { if (Character.isLowerCase(c)) { lowerCaseCount++; } else if (Character.isUpperCase(c)){ upperCaseCount++; } } if (lowerCaseCount \u003e upperCaseCount) { return s.toLowerCase(); } else if (lowerCaseCount \u003c upperCaseCount) { return s.toUpperCase(); } return s; } } 字符匹配【100分】 SHOW PROBLEM 一、题目描述 给定一个字符串数组（每个字符串均由小写字母组成）和一个字符规律（由小写字母、.和*组成），请识别数组中哪些字符串可以完全匹配该字符规律。\n. 匹配任意单个字符。 * 匹配零个或多个前面的字符（即“零个或多个”的概念）。 匹配是要涵盖整个字符串，而不仅仅是部分字符串。\n二、输入描述\n第一行是一个由空格分隔的字符串数组，其中每个字符串的长度满足 1 \u0026lt; 单个字符串长度 \u0026lt; 100。 第二行为字符规律，长度满足 1 \u0026lt; 字符规律长度 \u0026lt; 50。 三、输出描述\n输出符合字符规律的字符串在数组中的下标，多个匹配时，下标按升序排列，并用逗号分隔。 如果没有任何字符串匹配，输出 -1。 示例\n输入：\ngolang java kafka .*a 输出：\n1,2 说明：\n匹配规则 .*a 表示以 a 结尾的任意字符串。符合要求的字符串是 java 和 kafka，因此它们的下标是 1 和 2（从 0 开始索引）。 SHOW CODE Java import java.util.*; import java.util.regex.Pattern; public class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); String[] words = in.nextLine().trim().split(\" \"); String rule = in.nextLine().trim(); String result = getMatchingIndices(words, rule); System.out.println(result); } private static String getMatchingIndices(String[] words, String rule) { List indices = new ArrayList\u003c\u003e(); // // 构建正则表达式 Pattern pattern = Pattern.compile(\"^\" + rule + \"$\"); // 遍历字符串数组，查找匹配项 for (int i = 0; i \u003c words.length; i++) { if (pattern.matcher(words[i]).matches()) { indices.add(i); } } return indices.isEmpty() ? \"-1\" : indices.toString().replaceAll(\"[\\\\[\\\\]\\\\s]\", \"\"); } } Queue 银行插队 SHOW PROBLEM 一、题目描述\n某银行将客户分为了若干个优先级，1级最高，5级最低。当客户到达银行时，优先级高的人可以随时插队到优先级低的人的前面。\n现在给定一系列的客户到达和办理业务的时间序列，请你每次银行办理业务时输出客户的编号。\n如果有多个优先级相同且最高的客户，则按照到达顺序进行办理。\n二、输入描述\n第一行是一个正整数 n（1 ≤ n ≤ 500），表示输入序列中的事件数量。 接下来的 n 行每行第一个字符为 a 或 p： 当字符为 a 时，后面跟着两个正整数 num 和 x，表示到达的客户编号 num 和优先级 x。 当字符为 p 时，表示当前优先级最高的客户去办理业务。 三、输出描述\n对于每个 p 类型的事件，输出一行，仅包含一个正整数 num，表示办理业务的客户编号。\n四、测试用例\n测试用例 1\n输入:\n4 a 1 3 a 2 2 a 3 2 p 输出:\n2 说明:\n客户 1 到达，优先级为 3。 客户 2 和客户 3 到达，优先级为 2。 第一次 p 会办理客户 2，因为客户 2 和客户 3 优先级相同，但是客户 2 先到达。 测试用例 2\n输入:\n6 a 10 1 a 20 5 a 30 3 p p p 输出:\n10 30 20 说明:\n客户 10 到达，优先级为 1（最高优先级）。 客户 20 到达，优先级为 5。 客户 30 到达，优先级为 3。 第一次 p 处理客户 10（因为客户 10 优先级最高）。 第二次 p 处理客户 30（优先级 3 高于 5）。 第三次 p 处理客户 20。 SHOW CODE Java import java.util.PriorityQueue; import java.util.Scanner; class Solution { static class Customer { int id; int priority; public Customer(int id, int priority) { this.id = id; this.priority = priority; } } public static void main(String[] args) { Scanner in = new Scanner(System.in); int n = Integer.parseInt(in.nextLine().trim()); // Customers with higher priority come first, // if priorities are equal, order by ID PriorityQueue\u0026lt;Customer\u0026gt; queue = new PriorityQueue\u0026lt;\u0026gt;(( c1, c2) -\u003e c1.priority == c2.priority ? Integer.compare(c1.id, c2.id) : Integer.compare(c1.priority, c2.priority) ); // Process each event for (int i = 0; i \u003c n; i++) { String[] parts = in.nextLine().trim().split(\" \"); processEvents(parts, queue); } } private static void processEvents(String[] parts, PriorityQueue\u0026lt;Customer\u0026gt; queue) { char action = parts[0].charAt(0); // A customer arrives if the action equals to 'a' if (action == 'a') { int id = Integer.parseInt(parts[1]); int priority = Integer.parseInt(parts[2]); queue.add(new Customer(id, priority)); } else if (action == 'p' \u0026\u0026 !queue.isEmpty()) { // Poll the highest priority customer from the queue Customer customer = queue.poll(); System.out.println(customer.id); } } } SHOW NOTES When sorting involves multiple fields, it is a good practice to encapsulate these fields in an entity class. This approach simplifies specifying the sorting order based on specific conditions, enhancing both the maintainability and readability of the code.\nTwo Pointers 华为OD机试：最大花费金额【100分】 点击查看题目 一、题目描述\n小明希望在预算范围内尽可能花完资金。双十一期间，众多商品打折销售，他想从心仪的商品中挑选三件购买。请设计一个程序，帮助小明计算可以花费的最大金额。\n二、输入描述\n第一行：一维整型数组 M，表示商品的价格列表，数组长度小于 100，每个商品价格小于 1000。 第二行：整数 R，表示购买的总资金限制，R 小于 100000。 三、输出描述\n输出满足条件的最大花费金额。如果不存在符合条件的组合，输出 -1。\n示例\n输入：\n28 16 36 22 100 输出：\n86 说明\n在示例中，购买三件商品且总价不超过 100 的最大组合为 28 + 36 + 22 = 86。\n点击查看代码 Java import java.util.*; class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取字符串数组并转换为整数数组 int[] prices = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); // 读取购买资金额度 int budget = Integer.parseInt(in.nextLine().trim()); // 计算预算范围内可以花费的最大金额 int maxCost = getMaxCost(prices, budget); // 输出结果 System.out.println(maxCost); } private static int getMaxCost(int[] prices, int budget) { // 对价格进行排序 Arrays.sort(prices); int maxCost = 0; // 用于记录最大花费金额 for (int i = 0; i \u003c prices.length - 2; i++) { if (prices[i] \u003c budget) { int left = i + 1, right = prices.length - 1; while (left \u003c right) { int currentCost = prices[i] + prices[left] + prices[right]; // 当前花费金额 if (currentCost == budget) { return currentCost; } else if (currentCost \u003c budget) { maxCost = Math.max(maxCost, currentCost); left++; } else { right--; } } } else { break; } } return maxCost; } } 华为OD机试：字符串序列判定【100分】 点击查看题目 一、题目描述\n给定两个字符串 a 和 b，均由小写英文字母组成。a 的长度不超过 100，b 的长度不超过 500,000。要求判断 a 是否是 b 的一个有效子序列。\n判定规则：\na 中的每个字符都能在 b 中找到（字符可以不连续）。 a 在 b 中的字符顺序必须保持一致。 例如，当 a = \u0026quot;qwt\u0026quot; 时，a 是 b = \u0026quot;qwerty\u0026quot; 的一个有效子序列，因为 a 的字符 q、w 和 t 在 b 中按顺序出现。 二、输入描述\n输入包含两个字符串 a 和 b，均由小写英文字母组成：\n第一行输入字符串 a。 第二行输入字符串 b。 字符串 a 的长度 ≤ 100，字符串 b 的长度 ≤ 500,000。\n三、输出描述\n输出 a 在 b 中的最后一个有效字符的位置（索引从 0 开始）。如果 a 不是 b 的有效子序列，返回 -1。\n点击查看代码 Java import java.util.*; class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取输入 String a = in.nextLine().trim(); String b = in.nextLine().trim(); in.close(); // 判断 a 是否是 b 的有效子串 int result = substringCheck(a, b); // 输出结果 System.out.println(result); } private static int substringCheck(String a, String b) { if (a.length() \u003e b.length()) { return -1; } int i = 0, j = 0; int lastMatchPosition = -1; // 用于记录 a 的最后一个有效字符在 b 中的索引位置 while (i \u003c a.length() \u0026\u0026 j \u003c b.length()) { if (a.charAt(i) == b.charAt(j)) { lastMatchPosition = j; // 更新最后一个匹配位置 i++; } j++; } return lastMatchPosition; } } 华为OD机试：租车骑绿道【100分】 点击查看题目 一、题目描述\n部门组织团建活动，安排绿道骑行，需要租用双人自行车。每辆自行车最多可容纳两人，且载重上限为 m。给出部门中每个人的体重，求最少需要租用多少辆双人自行车。\n二、输入描述\n第一行包含两个整数 m 和 n，其中 m 表示每辆自行车的最大载重，n 表示部门的总人数。 第二行包含 n 个整数，表示每个人的体重（每个人的体重不超过自行车的载重限制 m）。 输入数据满足以下条件：\n0 \u0026lt; m \u0026lt;= 200 0 \u0026lt; n \u0026lt;= 1,000,000 三、输出描述\n输出最少需要的双人自行车数量。\n点击查看代码 Java import java.util.*; class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取自行车限重与人数 int[] parts = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); int m = parts[0]; // 读取体重数据 int[] weights = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); // 计算所需最少双人自行车数量 int result = computeMinimumBicycles(weights, m); // 输出结果 System.out.println(result); } private static int computeMinimumBicycles(int[] weights, int maxWeight) { // 对数组进行排序，便于使用双指针模式 Arrays.sort(weights); // 初始化双指针 int left = 0, right = weights.length - 1; int bicycleCount = 0; // while (left \u003c= right) { // // 最轻和最重的人可以共用一辆车 // if (weights[left] + weights[right] \u003c= maxWeight) { // left++; // 左指针右移 // right--; // bicycleCount++; // } else { // 不能公用自行车 // right--; // 右指针左移 // bicycleCount++; // } // } while (left \u003c= right) { // 最轻和最重的人可以共用一辆车 if (weights[left] + weights[right] \u003c= maxWeight) { left++; // 左指针右移 } right--; // 右指针左移 bicycleCount++; } return bicycleCount; } } 华为OD机试：求最多可以派出多少支团队【100分】 点击查看题目 题目描述\n有一个数组表示每个人的能力值。比赛活动要求参赛团队的能力总和至少为 N。每个团队可以由一人或两人组成，每个人只能参加一个团队。请计算最多可以组建多少个符合要求的团队。\n输入描述\n第一行：一个整数表示总人数，范围为 1 至 500,000。 第二行：一个整数数组表示每个人的能力值，数组大小为 1 至 500,000，数组元素取值范围为 1 至 500,000。 第三行：一个整数表示团队能力要求的最低值 N，范围为 1 至 500,000。 输出描述\n输出一个整数，表示最多可以组建的符合要求的团队数量。 说明\n输入 输出 说明 3\n1 1 9\n8 1 9自己一队，输出1 5\n3 1 5 7 9\n8 3 说明3、5组成为一队，1、7组成一队，9自己一队，输出3 7\n3 1 5 7 9 2 6\n8 4 说明3、5组成为一队，1、7组成一队，9自己一队，2、6组成一队，输出4 点击查看代码 Java import java.util.Arrays; import java.util.Scanner; class Main { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取输入数据 int n = Integer.parseInt(in.nextLine().trim()); int[] abilities = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); int minTeamAbility = Integer.parseInt(in.nextLine().trim()); in.close(); // 计算符合题目要求的团队数量 int result = computeMaxTeams(abilities, n, minTeamAbility); // 输出结果 System.out.println(result); } private static int computeMaxTeams(int[] abilities, int n, int minTeamAbility) { // 对数组进行排序，便于使用双指针模式 Arrays.sort(abilities); // 初始化双指针 int left = 0, right = n - 1; int teamCount = 0; while (left \u003c= right) { if (abilities[left] == abilities[right] \u0026\u0026 abilities[right] \u003e= minTeamAbility) { // 只剩下一个人 teamCount++; break; } else if (abilities[right] \u003e= minTeamAbility) { // 能力最强的人单人成队 teamCount++; right--; } else if (abilities[left] + abilities[right] \u003e= minTeamAbility) { teamCount++; left++; right--; } else { left++; } } return teamCount; } } 华为OD机试：寻找身高相近的小朋友【100分】 点击查看题目 一、题目描述\n小明今年升入小学一年级，来到新班级后发现其他小朋友的身高各不相同。他想根据每个小朋友与自己的身高差，对他们进行排序，帮助自己更好地认识新同学。\n二、输入描述\n第一行包含两个正整数 $h $和 $n $，其中：\n$h $表示小明的身高，范围为 $0 \u0026lt; h \u0026lt; 200 $。 $n $表示班级中其他小朋友的数量，范围为 $0 \u0026lt; n \u0026lt; 50 $。 第二行包含 $n $个正整数，分别表示其他小朋友的身高 $h_1, h_2, \\ldots, h_n $，每个身高的取值范围为 $0 \u0026lt; h_i \u0026lt; 200 $，且这些数互不相同。\n三、输出描述\n按照以下规则输出排序结果，各正整数之间用空格分隔：\n与小明身高差的绝对值越小的小朋友排在前面。 如果与小明身高差的绝对值相同，则身高较矮的小朋友排在前面。 点击查看代码 Java import java.util.*; class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取小明身高值和小明同学数 int[] part = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); int h = part[0]; // 小明身高值 int n = part[1]; // 小明同学个数 // 读取小明同学身高数据并解析为数组 int[] heightList = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); // 基于小明的身高对小明同学的身高进行排序 String result = sortHeight(heightList, h, n); // 输出结果 System.out.println(result); } private static String sortHeight(int[] heightList, int h, int n) { // 对数组进行排序，便于使用双指针模式 Arrays.sort(heightList); // 构建结果容器 StringBuilder builder = new StringBuilder(); // 初始化双指针 int left = 0, right = n - 1; while (left \u003c= right) { if (Math.abs(h - heightList[left]) \u003e Math.abs(h - heightList[right])) { builder.insert(0, heightList[left]); left++; } else if (Math.abs(h - heightList[left]) \u003c= Math.abs(h - heightList[right])) { builder.insert(0, heightList[right]); right--; } builder.insert(0, \" \"); } return builder.substring(1); } } 华为OD机试：太阳能板最大面积【100分】 点击查看题目 一、题目描述\n在航天器的一侧安装太阳能板（如图中红色斜线区域）时，需要先固定两根支柱（如图中黑色竖条）。太阳能板的安装面积取决于支柱之间的距离和较短支柱的高度。\n现给定一组整数数组，表示各个支柱的高度。假设每根支柱之间的距离相等且为 1 个单位长度，计算如何选择两根支柱以使太阳能板的安装面积最大化。\n注意：支柱的高度无序排列。\n二、输入描述\n输入一个表示支柱高度的整数数组，如：10,9,6,7,8,5,4,7,2,3\n三、输出描述\n输出最大太阳能板的安装面积。\n点击查看代码 Java import java.util.*; class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取支柱高度 int[] height = Arrays.stream(in.nextLine().trim().split(\",\")) .mapToInt(Integer::parseInt) .toArray(); in.close(); // 计算最大面积 int maxArea = computeMaxArea(height); // 输出结果 System.out.println(maxArea); } private static int computeMaxArea(int[] height) { // 初始化双指针 int left = 0, right = height.length - 1; int maxArea = 0; // 用于记录最大面积 while (left \u003c right) { int area = Math.min(height[left], height[right]) * (right - left); maxArea = Math.max(maxArea, area); // 更新最大面积 // 移动较短的支柱，尝试获取更大的面积 if (height[left] \u003c height[right]) { left++; } else { right--; } } return maxArea; } } Sliding Window 华为OD机试：寻找连续区间【100分】 点击查看题目 题目描述\n给定一个包含 $N $个正整数的数组，找出所有连续子数组（包括单个元素），其和大于等于给定的整数 $X $的组合数量。\n输入描述\n第一行包含两个整数 $N $和 $X $。（$0 \u0026lt; N \\leq 100000 $, $0 \\leq X \\leq 10000000 $）\n第二行包含 $N $个正整数（每个正整数的值不超过 100）。\n输出描述\n输出一个整数，表示满足条件的连续子数组的数量。\n输入示例\n3 7 3 4 7 输出示例\n4 示例说明\n输入的第一个数 3 表示数组包含 3 个元素，7 是目标值，用于判断子数组和是否大于等于该值。\n满足条件的子数组包括：3+4, 3+4+7, 4+7, 7，总共 4 个。\n点击查看代码 Java import java.util.*; class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取正整数个数和目标值 int[] part = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); int n = part[0]; int x = part[1]; // 读取整数 int[] nums = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); // 计算子数组和大于或等于目标值的个数 int result = countSubArrays(nums, x); // 输出结果 System.out.println(result); } private static int countSubArrays(int[] nums, int target) { int windowStart = 0, count = 0; int windowSum = 0; for (int windowEnd = 0; windowEnd \u003c nums.length; windowEnd++) { windowSum += nums[windowEnd]; // 更新窗口和 // 当窗口和大于或等于目标值时，缩小窗口 while (windowSum \u003e= target) { // 符合要求子数组：左边界为 windowStart，右边界取值范围为 [windowEnd, nums.length - 1] count += nums.length - windowEnd; windowSum -= nums[windowStart]; windowStart++; // 缩小窗口 } } return count; } } 点击查看笔记 count += nums.length - windowEnd; nums = [1, 4, 5], target = 4 windowEnd 为 0 时，当前窗口和1小于目标值 windowEnd 为 1 时，当前窗口和5大于目标值，符合要求的子数组为：[1, 4]和[1, 4, 5]。也就是说，子数组的左边界为windowStart = 0，右边界的取值可为：1, 2。 while (windowSum \u0026gt;= target) 而非 if (windowSum \u0026gt;= target) 当找到符合要求的子数组时，应尽可能缩小窗口。例如，子数组[1, 4] 缩小后变为[4]，但此时[4]仍满足题意，此时windowEnd的取值1和2，即子数组可为[4]和[4,5]。 华为OD机试：阿里巴巴找黄金宝箱(V)【100分】 点击查看题目 一、题目描述\n樵夫阿里巴巴在砍柴途中发现了一个藏宝地，这里有编号从 $0$ 到$N-1$的宝箱，每个宝箱上贴有一个数字，表示其价值。阿里巴巴记住了一个“咒语数字”$k$（$k \u0026lt; N$），他希望通过这个数字找到宝藏组合的最大价值。具体而言，阿里巴巴要找出连续$k$个宝箱中的数字和的最大值，并输出该最大值。\n二、输入描述\n第一行：一个包含整数的字符串，表示宝箱上的数字，数字之间用逗号分隔。例子：2,10,-3,-8,40,5\n条件： 1 ≤ 数字的个数 ≤ 100,000 -10,000 ≤ 每个数字 ≤ 10,000 第二行：一个正整数$k$，表示咒语数字，指定连续宝箱的数量。例子：4，其中$k \u0026lt;$宝箱的个数。\n三、输出描述\n输出一个整数，表示连续$k$个宝箱的最大和。例如：39\n四、测试用例\n测试用例 1：\n输入 2,10,-3,-8,40,5 4 输出 39 说明\n初始窗口：2,10,-3,-8，和为 1。\n移动窗口：10,-3,-8,40，和为 39，更新最大和。\n接下来窗口为：-3,-8,40,5，和为 34，保持最大和为 39。 测试用例 2：\n输入 8 1 输出 8 说明\n只有一个数字，窗口大小为 1，直接输出该数字 8。 测试用例 3：\n输入\n-1,-2,-3,-4 2 输出\n-3 说明\n初始窗口为 -1,-2，和为 -3。后续窗口的和分别为 -5 和 -7，因此最大和保持为 -3。\n点击查看代码 Java import java.util.*; class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取宝箱数字并转换为数组 int[] nums = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); // // 读取连续宝箱的个数 int boxes = Integer.parseInt(in.nextLine().trim()); // 计算指定连续宝箱个数的最大和 int maxSum = computeMaxSum(nums, boxes); // 输出结果 System.out.println(maxSum); } private static int computeMaxSum(int[] nums, int k) { int windowStart = 0, windowSum = 0; int maxSum = Integer.MIN_VALUE; for (int windowEnd = 0; windowEnd \u003c nums.length; windowEnd++) { windowSum += nums[windowEnd]; // 更新窗口和 // 当窗口大小等于k时，缩小窗口 if (windowEnd - windowStart + 1 == k) { maxSum = Math.max(maxSum, windowSum); // 更新最大和 windowSum -= nums[windowStart]; windowStart++; // 缩小窗口 } } return maxSum; } } 华为OD机试：最多购买宝石数目【100分】 点击查看题目 一、题目描述\n在一个橱窗里，有一排编号为 0 到 n-1 的宝石，每个宝石的价格用数组 gems[i] 表示（其中 0 \u0026lt;= i \u0026lt; n，且 n = gems.length）。你可以选择购买一组宝石，但需要满足以下条件：\n选择的宝石必须是连续编号的，例如：gems[i], gems[i+1], ..., gems[i+m-1]。 可以选择购买的宝石总数不能超过一个最大值 m。 你拥有的总金额为 value。 请计算，在给定的金额 value 和最大宝石数量 m 的限制下，最多可以购买多少个宝石。如果无法购买任何宝石，则返回 0。\n二、输入描述\n第一行输入整数 n，表示橱窗中宝石的总数量。取值范围：0 \u0026lt;= n \u0026lt;= 10^6 接下来的 n 行，每行一个整数，表示宝石的价格。即，第 i 行输入的是 gems[i] 的价格。价格范围：0 \u0026lt; gems[i] \u0026lt;= 1000 最后一行输入整数 m，表示拥有的总金额。取值范围：0 \u0026lt;= value \u0026lt;= 10^9 三、输出描述\n输出一个整数，表示在给定金额和数量限制下，最多可以购买的宝石数量。\n四、测试用例\n测试用例 1\n输入\n7 8 4 6 3 1 6 7 10 输出\n3 说明 可以购买编号为 2, 3, 4 的宝石，其价格和为 6 + 3 + 1 = 10，总价不超过 value\n点击查看代码 Java import java.util.*; class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取宝石数量 int n = Integer.parseInt(in.nextLine().trim()); // 读取宝石价格 int[] prices = new int[n]; for (int i = 0; i \u003c n; i++) { prices[i] = Integer.parseInt(in.nextLine().trim()); } // 读取拥有钱 int money = Integer.parseInt(in.nextLine().trim()); // 计算能够购买最多的宝石数量 int maxGem = buyMaxGems(prices, money); // 输出结果 System.out.println(maxGem); } private static int buyMaxGems(int[] prices, int money) { int windowStart = 0; int maxGem = 0, currentPrice = 0; for (int windowEnd = 0; windowEnd \u003c prices.length; windowEnd++) { currentPrice += prices[windowEnd]; // 如果总价超过预算，缩小窗口 if (currentPrice \u003e money) { currentPrice -= prices[windowStart]; windowStart++; } // 更新最大可购买的宝石数量 maxGem = Math.max(maxGem, windowEnd - windowStart + 1); } return maxGem; } } 点击查看笔记 问题本质：求给定条件下的最大区间\n华为OD机试：找出通过车辆最多颜色【100分】 点击查看题目 一、题目描述\n在一个狭窄的路口，每秒钟只能通过一辆车，且车辆的颜色只有三种。请找出在给定的统计时间窗内，经过的车辆中数量最多的颜色的车辆数量。\n颜色共有三种，分别用编号 0、1、2 表示。\n二、输入描述\n第一行是一个数组，表示每秒钟通过的车辆颜色信息。例如，输入 [0, 1, 1, 2] 表示在 4 秒钟内，车辆颜色依次为 0、1、1、2。 第二行是一个整数，表示统计时间窗的长度 T（单位：秒）。 三、输出描述\n输出在指定的统计时间窗 T 内，经过的数量最多的颜色的车辆数量。\n示例\n输入\n[0, 1, 1, 2] 3 输出\n2 说明\n在时间窗为 3 秒的范围内，颜色 1 的车辆数量最多，有 2 辆。\n点击查看代码 Java import java.util.*; class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取车辆颜色数据并转换为数组 int[] colors = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); // 读取指定时间窗口长度 int k = Integer.parseInt(in.nextLine().trim()); // 计算指定时间窗口内经过的最多颜色的车辆数量 int num = maxPassedCars(colors, k); // 输出结果 System.out.println(num); } private static int maxPassedCars(int[] colors, int windowSize) { int windowStart = 0, maxCars = 0; Map\u0026lt;Integer, Integer\u0026gt; frequencyMap = new HashMap\u0026lt;\u0026gt;(); for (int windowEnd = 0; windowEnd \u003c colors.length; windowEnd++) { int count = frequencyMap.getOrDefault(colors[windowEnd], 0) + 1; maxCars = Math.max(maxCars, count); frequencyMap.put(colors[windowEnd], count); // 当窗口大小等于指定时间窗口时，缩小窗口 if (windowEnd - windowStart + 1 == windowSize) { frequencyMap.put(colors[windowStart], frequencyMap.get(colors[windowStart]) - 1); windowStart++; // 缩小窗口 } } return maxCars; } } 点击查看笔记 问题本质：统计指定区间内数字的出现频率\n长度最小的子数组 【力扣传送门】 SHOW CODE Java class Solution { public int minSubArrayLen(int target, int[] nums) { int windowSum = 0, minLength = Integer.MAX_VALUE; int windowStart = 0; for (int windowEnd = 0; windowEnd \u003c nums.length; windowEnd++) { windowSum += nums[windowEnd]; // 当窗口和大于目标值时，尽可能缩小窗口 while (windowSum \u003e= target) { minLength = Math.min(minLength, windowEnd - windowStart + 1); windowSum -= nums[windowStart]; windowStart++; } } return minLength == Integer.MAX_VALUE ? 0 : minLength; } } 水果成篮 【力扣传送门】 SHOW CODE Java class Solution { public int totalFruit(int[] fruits) { int maxLength = Integer.MIN_VALUE; Map\u0026lt;Integer, Integer\u0026gt; frequencyMap = new HashMap\u0026lt;\u0026gt;(); int windowStart = 0; for (int windowEnd = 0; windowEnd \u003c fruits.length; windowEnd++) { int endFruit = fruits[windowEnd]; frequencyMap.put(endFruit, frequencyMap.getOrDefault(endFruit, 0) + 1); // 当水果类型大于2时缩小窗口 while (frequencyMap.size() \u003e 2) { int startFruit = fruits[windowStart]; frequencyMap.put(startFruit, frequencyMap.get(startFruit) - 1); if (frequencyMap.get(startFruit) == 0) { frequencyMap.remove(startFruit); } windowStart++; } maxLength = Math.max(maxLength, windowEnd - windowStart + 1); } return maxLength; } } 华为OD机试：计算最接近的数【100分】 点击查看题目 一、题目描述\n给定一个数组 X 和一个正整数 K，请找出一个下标 i，使得表达式 $X[i] - X[i-1] - \\dots - X[i+K+1]$ 的结果最接近数组中位数的下标i。如果有多个满足条件的下标 i，请返回最大的 i。\n数组的中位数定义为：将长度为 N 的数组按元素值从小到大排序后，下标为 N/2 的元素的值。\n二、输入描述\n第一行输入一个数组 X（元素为整数，长度为 N）。 第二行输入正整数 K。 三、输出描述\n表达式 $X[i] - X[i-1] - \\dots - X[i+K+1]$ 的结果最接近数组中位数的起始下标i。如果存在多个下标满足条件，返回最大的 i。\n点击查看代码 Java import java.util.*; /** * @author Signal Yu * @since 2024-11-07 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取输入数组并去除方括号与空格 int[] nums = Arrays.stream(in.nextLine() .replaceAll(\"[\\\\[\\\\]\\\\s]\", \"\") .split(\",\")) .mapToInt(Integer::parseInt) .toArray(); // 读取整数k int k = Integer.parseInt(in.nextLine().trim()); // 计算最接近中位数的表达式下标 int index = getClosestIndex(nums, k); // 输出结果 System.out.println(index); } private static int getClosestIndex(int[] nums, int k) { // 创建数组副本并排序以找到中位数 int[] sortedNums = Arrays.copyOf(nums, nums.length); Arrays.sort(sortedNums); int median = sortedNums[sortedNums.length / 2]; // 计算中位数 int closestIndex = -1; // 最终输出的最接近中位数的起始下标 int minDistance = Integer.MAX_VALUE; // 初始化最小差值为最大整数 for (int start = 0; start \u003c nums.length; start++) { int current = nums[start]; for (int end = start + 1; end \u003c= Math.min(nums.length - 1, start + k + 1); end++) { current -= nums[end]; } // 计算当前子数组和与中位数的差值 int diff = Math.abs(current - median); // 更新最接近的下标与最小差值（若差值相同则选择更大的下标） if (diff \u003c= minDistance) { closestIndex = start; minDistance = diff; } } return closestIndex; } } 华为OD机试：用连续自然数之和来表达整数【100分】 点击查看题目 题目描述 给定一个整数，可以用连续的自然数之和表示。请计算该整数有多少种不同的连续自然数之和的表示方式，并输出每种表示。\n输入描述 一个目标整数 T，其中 1 \u0026lt;= T \u0026lt;= 1000。\n输出描述 输出该整数的所有连续自然数之和的表示方式以及表示方式的总数。\n输出顺序要求：优先输出自然数数量最少的表达方式。 每个表达式中自然数应按递增顺序排列，格式参考样例。 在所有表达式输出结束后，单独输出一行 \u0026quot;Result:X\u0026quot;，其中 X 为表达式的总个数。 输入示例\n9 输出示例\n9=9 9=4+5 9=2+3+4 Result:3 点击查看代码 Java import java.util.Scanner; /** * @author Signal Yu * @since 2024-11-07 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取整数 t int t = Integer.parseInt(in.nextLine().trim()); // 获取符合条件的表达式及总数 String result = getExpressionAndResult(t); // 输出结果 System.out.println(result); } private static String getExpressionAndResult(int n) { StringBuilder result = new StringBuilder(); int start = 1; // 记录窗口起始位置 int count = 0; // 记录符合条件的表达式个数 int windowSum = 0; // 记录窗口和 // 使用滑动窗口找到所有符合条件的表达式 for (int end = 1; end \u003c= n; end++) { windowSum += end; // 更新窗口和 // 窗口和大于目标 n时，缩小窗口 while (windowSum \u003e n) { windowSum -= start; start++; } // 窗口和等于目标 n，记录表达式 if (windowSum == n) { StringBuilder expression = new StringBuilder(); expression.append(n).append(\"=\"); for (int i = start; i \u003c= end; i++) { expression.append(i).append(\"+\"); } expression.setLength(expression.length() - 1); // 移除最后一个加号 expression.append(\"\\n\"); result.insert(0, expression); // 将表达式插入到结果的起始位置 count++; } } // 添加表达式总数 result.append(\"Result:\").append(count); return result.toString(); } } 华为OD机试：滑动窗口最大和【100分】 点击查看题目 题目描述\n给定一个包含 $N$ 个整数的数组和一个长度为 $M$ 的滑动窗口，从数组的第一个数开始，窗口逐步滑动直到无法再滑动。每次滑动窗口会生成一个窗口和（窗口中所有元素的总和），请找出所有窗口和中的最大值。\n输入描述\n第一行输入一个正整数 $N$，表示数组中的整数个数（$0 \u0026lt; N \u0026lt; 100000$）。 第二行输入 $N$ 个整数，范围为 $[-100, 100]$。 第三行输入一个正整数 $M$，表示窗口大小，满足 $1 \\le M \\le N$。 输出描述\n输出所有窗口和的最大值。\n示例\n输入\n6 10 20 30 15 23 12 3 输出\n68 说明\n窗口长度为 3，窗口滑动产生的窗口和为：\n10 + 20 + 30 = 60 20 + 30 + 15 = 65 30 + 15 + 23 = 68 15 + 23 + 12 = 50 因此，最大窗口和为 68。\n点击查看代码 Java import java.util.*; /** * @author Signal Yu * @since 2024-11-07 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取整数个数 int n = Integer.parseInt(in.nextLine().trim()); // 读取整数字符串并转换为数组 int[] nums = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); // 读取滑动窗口大小 int m = Integer.parseInt(in.nextLine().trim()); // 计算符合条件的最大和 int maxSum = getMaxSum(nums, n, m); // 输出结果 System.out.println(maxSum); } private static int getMaxSum(int[] nums, int n, int m) { int start = 0, windowSum = 0, maxSum = Integer.MIN_VALUE; for (int end = 0; end \u003c n; end++) { windowSum += nums[end]; // 更新窗口和 // 当窗口大小等于 m 时，缩小窗口 if (end - start + 1 == m) { maxSum = Math.max(maxSum, windowSum); // 更新最大和 windowSum -= nums[start]; start++; // 缩小窗口 } } return maxSum; } } 替换后的最长重复字符 【力扣传送门】 SHOW CODE Java class Solution { public int characterReplacement(String s, int k) { Map\u0026lt;Character, Integer\u0026gt; frequencyMap = new HashMap\u0026lt;\u0026gt;(); int maxLength = Integer.MIN_VALUE; int maxRepeatLetterCount = 0; int windowStart = 0; for (int windowEnd = 0; windowEnd \u003c s.length(); windowEnd++) { char endChar = s.charAt(windowEnd); frequencyMap.put(endChar, frequencyMap.getOrDefault(endChar, 0) + 1); maxRepeatLetterCount = Math.max(maxRepeatLetterCount, frequencyMap.get(endChar)); // 当窗口大小与最大重复字母数之差大于 k 时，需要缩小窗口 if (windowEnd - windowStart + 1 - maxRepeatLetterCount \u003e k) { char startChar = s.charAt(windowStart); frequencyMap.put(startChar, frequencyMap.get(startChar) - 1); windowStart++; } maxLength = Math.max(maxLength, windowEnd - windowStart + 1); } return maxLength; } } 华为OD机试：补种未成活胡杨【100分】 点击查看题目 题目描述\n近年来，我国在防沙治沙方面取得了显著成果。某沙漠中新种植了 N 棵胡杨树，排成一行。一段时间后，有 M 棵胡杨未能成活，现需选择其中的 K 棵进行补种（只能补种已枯死的胡杨，不能新增种植）。请问如何补种，能够使连续胡杨树的数量达到最大？\n输入描述\n第一行包含三个整数，分别为： N：种植的胡杨总数量（1 ≤ N ≤ 100,000） M：未成活的胡杨数量（1 ≤ M ≤ N） M 个空格分隔的整数，按编号从小到大排列 K：最多可以补种的胡杨数量（0 ≤ K ≤ M） 输出描述\n输出最多的连续胡杨树数量。\n示例\n输入\n5 2 2 4 1 输出\n3 说明\n在 5 棵胡杨中，编号为 2、4 的胡杨未成活。最多可以补种 1 棵，通过补种编号为 2 或 4，可以形成最多的连续胡杨树，即 3 棵。\n点击查看代码 Java import java.util.*; import java.util.stream.Collectors; /** * @author Signal Yu * @since 2024-11-08 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取种植的胡杨总数 int n = Integer.parseInt(in.nextLine().trim()); // 读取未成活的胡杨数量 int m = Integer.parseInt(in.nextLine().trim()); // 读取未成活的胡杨编号并转换为集合 Set\u0026lt;Integer\u0026gt; deadPopulusSet = Arrays.stream(in.nextLine().trim().split(\" \")) .map(Integer::parseInt) .collect(Collectors.toSet()); // 读取可以补种的棵数 int k = Integer.parseInt(in.nextLine().trim()); // 计算补种后最多连续胡杨树数量 int maxSurvivals = getMaxAlive(n, deadPopulusSet, k); // 输出结果 System.out.println(maxSurvivals); } private static int getMaxAlive(int n, Set deadPopulusSet, int k) { int start = 1, maxSurvivals = 0, deathCount = 0; for (int end = 1; end \u003c= n; end++) { if (deadPopulusSet.contains(end)) { deathCount++; } // 当前窗口内未成活的胡杨树棵数超过 k 时，缩小窗口 while (deathCount \u003e k) { if (deadPopulusSet.contains(start)) { deathCount--; } start++; // 缩小窗口 } maxSurvivals = end - start + 1; // 更新最大连续成活数量 } return maxSurvivals; } } 最大连续1的个数 III 【力扣传送门】 SHOW CODE Java class Solution { public int longestOnes(int[] nums, int k) { int maxLength = 0; // 记录最长窗口长度 int maxOnesInWindow = 0; // 记录当前窗口内的1的个数 int windowStart = 0; for (int windowEnd = 0; windowEnd \u003c nums.length; windowEnd++) { if (nums[windowEnd] == 1) { maxOnesInWindow++; } // 如果当前窗口内0的个数超过k，缩小窗口 while (windowEnd - windowStart + 1 - maxOnesInWindow \u003e k) { if (nums[windowStart] == 1) { maxOnesInWindow--; } windowStart++; } // 更新最长窗口长度 maxLength = Math.max(maxLength, windowEnd - windowStart + 1); } return maxLength; } } 字符串的排列 【力扣传送门】 SHOW CODE Java class Solution { public boolean checkInclusion(String s1, String s2) { Map\u0026lt;Character, Integer\u0026gt; frequencyMap = new HashMap\u0026lt;\u0026gt;(); // 初始化s1中每个字符的频率 for (char c : s1.toCharArray()) { frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1); } int windowStart = 0; // 滑动窗口起始位置 int matched = 0; // 已匹配的字符种类数 // 移动窗口的结束位置 for (int windowEnd = 0; windowEnd \u003c s2.length(); windowEnd++) { char endChar = s2.charAt(windowEnd); // 当前窗口的结束字符 // 如果结束字符在频率表中，更新其频率 if (frequencyMap.containsKey(endChar)) { frequencyMap.put(endChar, frequencyMap.get(endChar) - 1); // 如果字符频率降为0，表示完全匹配一个字符 if (frequencyMap.get(endChar) == 0) { matched++; } } // 若所有字符都匹配，返回true if (matched == frequencyMap.size()) { return true; } // 当窗口大小等于s1的长度时，调整窗口 if (windowEnd - windowStart + 1 \u003e= s1.length()) { char startChar = s2.charAt(windowStart); // 当前窗口的起始字符 // 若起始字符在频率表中，恢复频率并更新匹配状态 if (frequencyMap.containsKey(startChar)) { if (frequencyMap.get(startChar) == 0) { matched--; } frequencyMap.put(startChar, frequencyMap.get(startChar) + 1); } // 移动窗口起始位置 windowStart++; } } // 若未找到匹配的子串，返回false return false; } } 华为OD机试：关联子串【100分】 点击查看题目 题目描述\n给定两个字符串 str1 和 str2，判断是否存在 str1 的某种排列是 str2 的子串。如果存在，返回该子串在 str2 中的起始位置；如果不存在，则返回 -1。\n输入描述\n第一行输入两个字符串，分别为 str1 和 str2，用空格分隔。\n输出描述\n返回 str1 的某排列在 str2 中的子串起始位置。如果不存在关联子串，则输出 -1。\n示例\n输入\nvae hsgseva 输出\n4 说明\n在 str2 中，str1 的某种排列 eva 出现于索引 4。\n点击查看代码 Java import java.util.*; /** * @author Signal Yu * @since 2024-11-07 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取字符串 str1 和 str2 String[] parts = in.nextLine().trim().split(\" \"); String str1 = parts[0]; String str2 = parts[1]; // 计算关联子串 str1 在 str2 中的起始位置，非关联子串返回 -1 int index = getInclusionIndex(str1, str2); // 输出结果 System.out.println(index); } private static int getInclusionIndex(String s1, String s2) { if (s1.length() \u003e s2.length()) { return -1; } // 统计字符串 s1 中的字母频率 Map\u0026lt;Character, Integer\u0026gt; frequencyMap = new HashMap\u0026lt;\u0026gt;(); for (char c : s1.toCharArray()) { frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1); } int start = 0; // 记录窗口起始位置 int matched = 0; // 记录已匹配的字符 for (int end = 0; end \u003c s2.length(); end++) { char endChar = s2.charAt(end); // 当前窗口结束字符 if (frequencyMap.containsKey(endChar)) { frequencyMap.put(endChar, frequencyMap.get(endChar) - 1); if (frequencyMap.get(endChar) == 0) { matched++; } } // 当所有字符匹配时，返回起始位置 if (matched == frequencyMap.size()) { return start; } // 当窗口大小等于字符串s1长度时，收缩窗口 if (end - start + 1 == s1.length()) { char startChar = s2.charAt(start); // 当前窗口起始字符 if (frequencyMap.containsKey(startChar)) { if (frequencyMap.get(startChar) == 0) { matched--; } frequencyMap.put(startChar, frequencyMap.get(startChar) + 1); } start++; // 收缩窗口 } } return -1; } } 找到字符串中所有字母异位词 【力扣传送门】 SHOW CODE Java class Solution { public List\u0026lt;Integer\u0026gt; findAnagrams(String s, String p) { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); Map\u0026lt;Character, Integer\u0026gt; frequencyMap = new HashMap\u0026lt;\u0026gt;(); for (char c : p.toCharArray()) { frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1); } int windowStart = 0, matched = 0; for (int windowEnd = 0; windowEnd \u003c s.length(); windowEnd++) { char endChar = s.charAt(windowEnd); // 当前窗口的结束字符 if (frequencyMap.containsKey(endChar)) { // 更新频率映射，记录匹配字符 frequencyMap.put(endChar, frequencyMap.get(endChar) - 1); if (frequencyMap.get(endChar) == 0) { matched++; } } // 如果所有字符都匹配，则记录起始索引 if (matched == frequencyMap.size()) { result.add(windowStart); } // 窗口大小与目标字符串长度相等时，开始收缩窗口 if (windowEnd - windowStart + 1 \u003e= p.length()) { char startChar = s.charAt(windowStart); // 当前窗口的起始字符 if (frequencyMap.containsKey(startChar)) { if (frequencyMap.get(startChar) == 0) { matched--; } frequencyMap.put(startChar, frequencyMap.get(startChar) + 1); } windowStart++; // 收缩窗口 } } return result; } } 最小覆盖子串 【力扣传送门】 SHOW CODE Java class Solution { public String minWindow(String s, String t) { // 如果 t 比 s 长，直接返回空字符串 if (t.length() \u003e s.length()) { return \"\"; } // 创建 t 的字符频率映射 Map\u0026lt;Character, Integer\u0026gt; frequencyMap = new HashMap\u0026lt;\u0026gt;(); for (char c : t.toCharArray()) { frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1); } int windowStart = 0; // 窗口的起始位置 int minLength = s.length() + 1; // 最小窗口长度，初始化为超过 s 长度 int matched = 0; // 记录匹配到的字符数 int subStrStart = 0; // 最小窗口的起始位置 // 扩展窗口 for (int windowEnd = 0; windowEnd \u003c s.length(); windowEnd++) { char endChar = s.charAt(windowEnd); // 如果结束字符在 t 中，则减少其频率 if (frequencyMap.containsKey(endChar)) { frequencyMap.put(endChar, frequencyMap.get(endChar) - 1); // 频率非负时，说明该字符计入有效匹配 if (frequencyMap.get(endChar) \u003e= 0) { matched++; } } // 当前窗口包含所有 t 中字符时，尝试收缩窗口 while (matched == t.length()) { // 更新最小窗口长度和起始位置 if (windowEnd - windowStart + 1 \u003c minLength) { minLength = windowEnd - windowStart + 1; subStrStart = windowStart; } // 收缩窗口，处理起始字符 char startChar = s.charAt(windowStart); if (frequencyMap.containsKey(startChar)) { // 如果起始字符频率为 0，说明缩小窗口会减少匹配数 if (frequencyMap.get(startChar) == 0) { matched--; } // 恢复起始字符的频率 frequencyMap.put(startChar, frequencyMap.get(startChar) + 1); } windowStart++; // 窗口起点右移 } } // 返回最小窗口子串或空字符串 return minLength \u003e s.length() ? \"\" : s.substring(subStrStart, subStrStart + minLength); } } 华为OD机试：最左侧冗余覆盖子串【100分】 点击查看题目 一、题目描述\n给定两个字符串 s1 和 s2 以及一个正整数 k，其中 s1 的长度为 n1，s2 的长度为 n2。要求在 s2 中找到一个长度为 n1 + k 的子串，满足以下条件：\n该子串的长度为 n1 + k； 该子串包含 s1 中的所有字母； 该子串中每个字母的出现次数不少于 s1 中对应的字母次数。 如果在 s2 中存在满足条件的子串，则称 s2 以长度 k 冗余覆盖 s1。要求返回满足条件的最左侧子串的起始下标；如果不存在，则返回 -1。\n二、输入描述\n输入为三行：\n第一行是字符串 s1。 第二行是字符串 s2。 第三行是整数 k。 注意：s1 和 s2 都只包含小写字母。\n三、输出描述\n输出满足条件的 s2 中子串的最左侧起始下标；若不存在，则返回 -1。\n点击查看代码 Java import java.util.*; /** * @author Signal Yu * @since 2024-11-06 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取字符串和正整数k String s1 = in.nextLine().trim(); String s2 = in.nextLine().trim(); int k = Integer.parseInt(in.nextLine().trim()); // 计算冗余覆盖子串的最左侧起始下标 int index = getIndex(s1, s2, k); // 输出结果 System.out.println(index); } private static int getIndex(String s1, String s2, int k) { int index = -1; int subStrLength = s1.length() + k; if (subStrLength \u003e s2.length()) { return -1; // s2 不足以包含指定长度的子串 } // 构建 s1 中字符的频率表 Map\u0026lt;Character, Integer\u0026gt; frequencyMap = new HashMap\u0026lt;\u0026gt;(); for (char c : s1.toCharArray()) { frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1); } int windowStart = 0; int matched = 0; // 记录已匹配字符 for (int windowEnd = 0; windowEnd \u003c s2.length(); windowEnd++) { char endChar = s2.charAt(windowEnd); // 当前窗口结束字符 if (frequencyMap.containsKey(endChar)) { frequencyMap.put(endChar, frequencyMap.get(endChar) - 1); if (frequencyMap.get(endChar) == 0) { // 已匹配当前字符 matched++; } } // 所有字符匹配完成，返回结果 if (matched == frequencyMap.size()) { return windowStart; } // 窗口大小等于目标子串长度时，缩小窗口 if (windowEnd - windowStart + 1 == subStrLength) { char startChar = s2.charAt(windowStart); // 当前窗口起始字符 if (frequencyMap.containsKey(startChar)) { if (frequencyMap.get(startChar) == 1) { // 收缩窗口后，该字符变为未匹配 matched--; } frequencyMap.put(startChar, frequencyMap.get(startChar) + 1); } windowStart++; // 窗口收缩 } } return index; } } 串联所有单词的子串 【力扣传送门】 SHOW CODE Java 包含所有三种字符的子字符串数目 【力扣传送门】 SHOW CODE Java class Solution { public int numberOfSubstrings(String s) { int[] charCount = new int[3]; // 用于存储 'a', 'b', 'c' 的出现次数 int start = 0, count = 0; for (int end = 0; end \u003c s.length(); end++) { // 更新当前窗口内字符的出现次数 charCount[s.charAt(end) - 'a']++; while (charCount[0] \u003e 0 \u0026\u0026 charCount[1] \u003e 0 \u0026\u0026 charCount[2] \u003e 0) { count += s.length() - end; // 子串数量加1 charCount[s.charAt(start) - 'a']--; // 移除窗口起始字符 start++; // 缩小窗口 } } return count; } } 华为OD机试：优雅子数组【100分】 点击查看题目 题目描述\n如果一个数组中某个元素的出现次数大于等于 $k$ 次，则称该数组为 k-优雅数组，其中 $k$ 被称为 优雅阈值。\n例如，数组 [2, 3, 1, 2, 3, 1, 2, 3, 1] 是一个 3-优雅数组，因为元素 1 的出现次数达到了 3 次或更多。相反，数组 [2, 3, 1, 2, 3, 1] 不是一个 3-优雅数组，因为其中出现次数最多的元素（1 和 2）都仅出现了 2 次。\n给定一个数组 A 和一个阈值 k，请计算 A 中有多少个子数组是 k-优雅子数组。\n子数组是数组中由一个或多个连续元素组成的子集。例如，数组 [1, 2, 3, 4] 包含 10 个子数组，分别为：\n[1]，[1, 2]，[1, 2, 3]，[1, 2, 3, 4] [2]，[2, 3]，[2, 3, 4] [3]，[3, 4] [4] 输入描述\n第一行输入两个整数，以空格隔开，分别表示数组 A 的长度和优雅阈值 k。 第二行输入数组 A 的元素，以空格隔开。 输出描述\n输出数组 A 中有多少个子数组是 k-优雅子数组。 测试用例\n测试用例 1\n输入：\n7 3 1 2 3 1 2 3 1 输出：\n1 说明： 只有整个数组 [1, 2, 3, 1, 2, 3, 1] 中，元素 1 的出现次数达到 3 次。\n测试用例 2\n输入：\n7 2 1 2 3 1 2 3 1 输出：\n10 说明： 有 10 个子数组中，至少有一个元素出现了 2 次或更多。\n点击查看代码 Java import java.util.*; /** * @author Signal Yu * @since 2024-11-09 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取数组长度和优雅阈值 int[] parts = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); int n = parts[0]; int k = parts[1]; // 读取数字字符串并转换为整数数组 int[] nums = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); // 计算优雅子数组的个数 int count = countElegantSubarrays(nums, n, k); // 输出结果 System.out.println(count); } private static int countElegantSubarrays(int[] nums, int n, int k) { Map\u0026lt;Integer, Integer\u0026gt; frequencyMap = new HashMap\u0026lt;\u0026gt;(); int start = 0, count = 0; for (int end = 0; end \u003c n; end++) { // 统计窗口内数字的频率 frequencyMap.put(nums[end], frequencyMap.getOrDefault(nums[end], 0) + 1); // 检查当前窗口是否符合 k-优雅条件 while (isKElegant(frequencyMap, k)) { count += n - end; // 更新优雅子数组的个数 // 缩小窗口，并减少频率映射中对应元素的计数 frequencyMap.put(nums[start], frequencyMap.get(nums[start]) - 1); if (frequencyMap.get(nums[start]) == 0) { frequencyMap.remove(nums[start]); } start++; } } return count; } private static boolean isKElegant(Map\u0026lt;Integer, Integer\u0026gt; frequencyMap, int k) { for (int count : frequencyMap.values()) { if (count \u003e= k) { return true; } } return false; } } 数学与逻辑分析模式相关算法题 华为OD机试：考勤信息【100分】 点击查看题目 一、题目描述\n公司使用一个字符串来表示员工的出勤情况，其中：\nabsent 表示缺勤 late 表示迟到 leaveearly 表示早退 present 表示正常出勤 需要根据员工的出勤记录，判断该员工是否可以获得出勤奖。出勤奖的获得条件如下：\n缺勤次数不超过一次； 没有连续的迟到或早退； 任意连续 7 次出勤记录中，缺勤、迟到或早退的次数不超过 3 次。 二、输入描述\n第一行输入一个正整数 $n $，表示考勤记录的条数。\n接下来的 $n $行，每行包含一个字符串，表示一条考勤记录。\n注意：\n记录条数 $n \\geq 1 $； 每个字符串长度小于 10000； 不存在非法输入。 三、输出描述\n根据每条考勤记录，如果该员工符合出勤奖条件，则输出 \u0026quot;true\u0026quot;；否则输出 \u0026quot;false\u0026quot;。\n对于输入示例的结果，输出每条考勤记录对应的判断结果，每个结果占一行。\n示例\n输入：\n2 present present absent late present present leaveearly present absent late late leaveearly absent present 输出：\ntrue false 点击查看代码 Java import java.util.*; /** * @author Signal Yu * @since 2024-11-04 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取考勤记录条数 int n = Integer.parseInt(in.nextLine().trim()); // 读取考勤记录并处理 for (int i = 0; i \u003c n; i++) { String attendanceRecord = in.nextLine().trim(); String result = isEligibleForAward(attendanceRecord) ? \"true\" : \"false\"; System.out.println(result); } in.close(); } private static boolean isEligibleForAward(String attendanceRecord) { String[] attendanceList = attendanceRecord.split(\" \"); int absentCount = 0; int continuousLateOrLeaveEarly = 0; for (int i = 0; i \u003c attendanceList.length; i++) { String record = attendanceList[i]; // 条件1：缺勤次数不超过1次 if (\"absent\".equals(record)) { absentCount++; if (absentCount \u003e 1) { return false; } } // 条件2：没有连续的迟到或早退 if (\"late\".equals(record) || \"leaveearly\".equals(record)) { continuousLateOrLeaveEarly++; if (continuousLateOrLeaveEarly \u003e 1) { return false; } } else { continuousLateOrLeaveEarly = 0; } // 条件3：任意连续7次出勤记录中，缺勤、迟到和早退的次数不超过3次 // 条件3等价于一周内present次数小于4 if (i \u003e= 6) { int presentCount = 0; for (int j = i - 6; j \u003c= i; j++) { if (\"present\".equals(attendanceList[j])) { presentCount++; } } if (presentCount \u003c 4) { return false; } } } return true; } } 质数减法运算 【力扣传送门】 SHOW CODE Java class Solution { public boolean primeSubOperation(int[] nums) { // 获取数组最大值 int maxNum = Arrays.stream(nums).max().orElseThrow(); // 生成素数数组 int[] primes = generatePrimes(maxNum); int prev = 0; // 初始化前一个数字为0以便第一次比较 for (int num : nums) { // 尝试用小于 num 的最大素数使其变为比 prev 大的值 boolean found = false; for (int prime : primes) { if (num - prime \u003e prev) { num -= prime; found = true; break; } } // 如果找不到合适的素数来调整num以满足严格递增，则返回false if (!found \u0026\u0026 num \u003c= prev) { return false; } prev = num; } return true; } // 生成小于 limit 且呈递减顺序的素数数组 private static int[] generatePrimes(int limit) { List primes = new ArrayList\u003c\u003e(); for (int i = limit - 1; i \u003e= 2; i--) { if (isPrime(i)) { primes.add(i); } } return primes.stream().mapToInt(Integer::intValue).toArray(); } // 判断自然数是否为素数 private static boolean isPrime(int n) { if (n \u003c= 1) { return false; } if (n \u003c= 3) { return true; } if (n % 2 == 0 || n % 3 == 0) { return false; } /** 所有大于 3 的质数都可以表示成 6𝑘±1 的形式 i 从 5 开始，表示第一个满足 6k - 1 的数。 i + 2 则是紧接的满足 6k + 1 的数。 */ for (int i = 5; i \u003c= Math.sqrt(n); i += 6) { if (n % i == 0 || n % (i+2) == 0) { return false; } } return true; } } 数列描述【100分】 SHOW PROBLEM 一、题目描述\n有一个数列 a[N]（N=60），其中 a[0] = \u0026quot;1\u0026quot;，每一项 a[n+1] 是对前一项 a[n] 的描述。具体规则如下：\na[0] = \u0026quot;1\u0026quot;。 a[1] = \u0026quot;11\u0026quot;，表示 a[0] 中有一个 \u0026ldquo;1\u0026rdquo;。 a[2] = \u0026quot;21\u0026quot;，表示 a[1] 中有两个 \u0026ldquo;1\u0026rdquo;。 a[3] = \u0026quot;1211\u0026quot;，表示 a[2] 中有一个 \u0026ldquo;2\u0026rdquo; 和一个 \u0026ldquo;1\u0026rdquo;。 a[4] = \u0026quot;111221\u0026quot;，表示 a[3] 中有一个 \u0026ldquo;1\u0026rdquo;、一个 \u0026ldquo;2\u0026rdquo; 和两个 \u0026ldquo;1\u0026rdquo;。 即每一项的生成规则是：从前一项的数字中按顺序描述出现次数和对应的数字。\n例如：\na[0] = \u0026quot;1\u0026quot;，描述为 \u0026ldquo;一个 1\u0026rdquo;，得到 a[1] = \u0026quot;11\u0026quot;。 a[1] = \u0026quot;11\u0026quot;，描述为 \u0026ldquo;两个 1\u0026rdquo;，得到 a[2] = \u0026quot;21\u0026quot;。 a[2] = \u0026quot;21\u0026quot;，描述为 \u0026ldquo;一个 2，一个 1\u0026rdquo;，得到 a[3] = \u0026quot;1211\u0026quot;。 a[3] = \u0026quot;1211\u0026quot;，描述为 \u0026ldquo;一个 1，一个 2，两个 1\u0026rdquo;，得到 a[4] = \u0026quot;111221\u0026quot;。 请输出数列中的第 n 项。\n二、输入描述\n输入一个整数 n，表示数列中第 n 项的位置（0 \u0026lt;= n \u0026lt;= 59）。\n三、输出描述\n输出数列中第 n 项的内容。\n四、输入输出示例\n输入：\n5 输出\n312211 五、说明\n通过输入 n=5，输出 a[5]。 根据规则，数列的前几项如下： a[0] = \u0026quot;1\u0026quot; a[1] = \u0026quot;11\u0026quot; a[2] = \u0026quot;21\u0026quot; a[3] = \u0026quot;1211\u0026quot; a[4] = \u0026quot;111221\u0026quot; a[5] = \u0026quot;312211\u0026quot; SHOW CODE Java import java.util.Scanner; /** * @author Signal Yu * @since 2024-11-30 */ public class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); int n = Integer.parseInt(in.nextLine().trim()); String result = getNthTerm(n); System.out.println(result); } private static String getNthTerm(int n) { String term = \"1\"; // 初始项 a[0] = \"1\" // 逐项生成数列的每一项，直到第 n 项 for (int i = 1; i \u003c= n; i++) { term = describeTerm(term); // 对当前项描述生成下一项 } return term; } private static String describeTerm(String term) { StringBuilder nextTerm = new StringBuilder(); int count = 1; // 计数器，初始时认为当前数字出现了 1 次 // 从第二个字符开始遍历当前项，统计连续相同字符的次数 for (int i = 1; i \u003c term.length(); i++) { if (term.charAt(i) == term.charAt(i - 1)) { count++; // 当前字符与前一个字符相同，计数器加 1 } else { nextTerm.append(count).append(term.charAt(i - 1)); // 描述上一组数字 count = 1; // 重置计数器 } } // 处理最后一组字符 nextTerm.append(count).append(term.charAt(term.length() - 1)); return nextTerm.toString(); // 返回描述后的下一项 } } 前缀和模式相关算法题 找到数组的中间位置 【力扣传送门】 SHOW CODE Java class Solution { public int findMiddleIndex(int[] nums) { int totalSum = Arrays.stream(nums).sum(); int leftSum = 0; for (int i = 0; i \u003c nums.length; i++) { int rightSum = totalSum - leftSum - nums[i]; if (leftSum == rightSum) { return i; } leftSum += nums[i]; } return -1; } } 华为OD机试：阿里巴巴找黄金宝箱(I) 点击查看题目 一、题目描述\n樵夫阿里巴巴在砍柴路上意外发现了强盗团伙的藏宝地。藏宝地有一排编号从0到N的箱子，每个箱子上贴有一个数字。传说中，这些箱子里藏有一个黄金宝箱。\n黄金宝箱的定义是：它满足以下条件——在它之前所有箱子上数字的总和，等于在它之后所有箱子上数字的总和。\n第一个箱子左边部分的数字总和定义为0，最后一个箱子右边部分的数字总和也定义为0。\n请帮助阿里巴巴找到第一个符合条件的黄金宝箱，并输出该黄金宝箱的编号。如果不存在这样的黄金宝箱，则返回-1。\n二、输入描述\n一个用逗号分隔的数字列表，表示每个箱子上贴的数字，例如：1,-1,0。\n箱子的数量至少为1个，最多为10,000个。 每个箱子上的数字范围在-1000到1000之间。 三、输出描述\n输出第一个符合条件的黄金宝箱的编号，如果没有符合条件的宝箱，则输出-1。\n点击查看代码 Java import java.util.*; /** * @author Signal Yu * @since 2024-11-04 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取箱子数字 int[] boxNumbers = Arrays.stream(in.nextLine().trim().split(\",\")) .mapToInt(Integer::parseInt) .toArray(); in.close(); // 寻找黄金宝箱编号 int result = findTreasureBox(boxNumbers); // 输出结果 System.out.println(result); } private static int findTreasureBox(int[] boxNumbers) { // 计算箱子数字总和 int totalSum = Arrays.stream(boxNumbers).sum(); int leftSum = 0; for (int i = 0; i \u003c boxNumbers.length; i++) { int rightSum = totalSum - leftSum - boxNumbers[i]; if (leftSum == rightSum) { return i; } leftSum += boxNumbers[i]; } return -1; } } 华为 OD 光伏场地建设规划【100分】 SHOW PROBLEM 一、题目描述\n祖国西北部有一片广阔的荒地，零星分布着一些湖泊、保护区和矿区。整体上，这片地区常年光照良好，但也存在一些光照较差的区域。某电力公司希望在这片荒地上建设多个光伏电站，生产清洁能源。为了评估不同区域的发电潜力，对每平方公里的土地进行了发电量评估，其中不能建设的区域的发电量为0千瓦，能够建设的区域根据光照、地形等因素给出了每平方公里的年发电量（单位：千瓦）。我们希望能够找到其中发电量集中且合适的矩形区域用于建设光伏电站，从而获得良好的收益。\n二、输入描述\n第一行输入为调研区域的长、宽，以及准备建设电站的边长。电站的边长是正方形，且要求每个电站的最小年发电量。 随后的每一行包含调研区域中每平方公里的年发电量。 输入格式：\n第一行包含四个整数 L、W、S、M，其中： L：调研区域的长度。 W：调研区域的宽度。 S：电站的边长（单位：公里，正方形电站）。 M：电站的最低年发电量要求（单位：千瓦）。 接下来的 L 行，每行包含 W 个整数，表示该位置每平方公里的年发电量。 输入示例：\n2 5 2 6 2 3 7 1 4 3 5 2 8 1 三、输出描述\n输出符合要求的矩形区域的数量。即，每个边长为 S 的正方形区域（电站区域）在该区域内的年发电量总和大于或等于 M 的数量。 输出示例：\n4 四、补充说明\n调研区域的长宽 L 和 W 均大于等于 1。 电站的边长 S 大于等于 1，且 S 小于等于 L 和 W 中较小的那个值。 任何区域的年发电量都大于或等于 0千瓦。 SHOW CODE Java import java.util.*; /** * @author Signal Yu * @since 2024-12-1 */ public class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); int[] parts = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); int rows = parts[0]; int cols = parts[1]; int side = parts[2]; int minPower = parts[3]; int[][] matrixPower = new int[rows][cols]; for (int i = 0; i \u003c rows; i++) { matrixPower[i] = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); } int result = countAvailableArea(matrixPower, side, minPower); System.out.println(result); } private static int countAvailableArea(int[][] matrixPower, int side, int minPower) { int rows = matrixPower.length; int cols = matrixPower[0].length; // 计算前缀和矩阵 int[][] prefix = calculatePrefixSum(matrixPower); int count = 0; // 遍历所有可能的电站位置，检查每个 SxS 子矩阵的发电量 for (int i = 0; i \u003c= rows - side; i++) { for (int j = 0; j \u003c= cols - side; j++) { // 计算当前子矩阵的总发电量 int totalPower = prefix[i+side][j+side] - prefix[i+side][j] - prefix[i][j+side] + prefix[i][j]; // 如果总发电量大于等于最低要求，则该区域有效 if (totalPower \u003e= minPower) { count++; } } } return count; } private static int[][] calculatePrefixSum(int[][] matrix) { int rows = matrix.length; int cols = matrix[0].length; int[][] prefix = new int[rows + 1][cols + 1]; for (int i = 1; i \u003c= rows; i++) { for (int j = 1; j \u003c= cols; j++) { prefix[i][j] = matrix[i-1][j-1] + prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1]; } } return prefix; } } $\\text{prefix}[i][j] = \\text{matrix}[i-1][j-1] + \\text{prefix}[i-1][j] + \\text{prefix}[i][j-1] - \\text{prefix}[i-1][j-1]\\dots i,j \u0026gt; 0（减去重叠部分）$，\n$\\text{Sub-Matrix Sum} = \\text{prefix}[i+k_1][j+k_2] - \\text{prefix}[i][j+k_2] - \\text{prefix}[i+k_1][j] + \\text{prefix}[i][j];$\n单调队列模式相关算法题 绝对差不超过限制的最长连续子数组 【力扣传送门】 SHOW CODE Java class Solution { public int longestSubarray(int[] nums, int limit) { // 使用双端队列来维护当前窗口的最大值和最小值的索引 Deque\u0026lt;Integer\u0026gt; maxDeque = new LinkedList\u0026lt;\u0026gt;(); Deque\u0026lt;Integer\u0026gt; minDeque = new LinkedList\u0026lt;\u0026gt;(); int windowStart = 0, maxLength = 0; // 定义窗口的起始位置和最长子数组长度 for (int windowEnd = 0; windowEnd \u003c nums.length; windowEnd++) { int current = nums[windowEnd]; // 更新最大值队列，保持降序（队首为最大值） while (!maxDeque.isEmpty() \u0026\u0026 nums[maxDeque.peekLast()] \u003c current) { maxDeque.pollLast(); } maxDeque.offerLast(windowEnd); // 更新最小值队列，保持升序（队首为最小值） while (!minDeque.isEmpty() \u0026\u0026 nums[minDeque.peekLast()] \u003e current) { minDeque.pollLast(); } minDeque.offerLast(windowEnd); // 当当前窗口的最大值和最小值之差超过给定的限制时，收缩窗口 while (nums[maxDeque.peekFirst()] - nums[minDeque.peekFirst()] \u003e limit) { windowStart++; // 移动窗口的起始位置 // 移除超出窗口范围的元素索引 if (maxDeque.peekFirst() \u003c windowStart) { maxDeque.pollFirst(); } if (minDeque.peekFirst() \u003c windowStart) { minDeque.pollFirst(); } } // 更新最长子数组长度 maxLength = Math.max(maxLength, windowEnd - windowStart + 1); } return maxLength; } } 购买水果需要的最少金币数 【力扣传送门】 SHOW CODE Java class Solution { public int minimumCoins(int[] prices) { int n = prices.length; Deque\u0026lt;Integer\u0026gt; deque = new LinkedList\u0026lt;\u0026gt;(); // 扩展数组，在末尾添加一个0，表示到达数组末尾的最终成本为0 prices = Arrays.copyOf(prices, n + 1); prices[n] = 0; // 基础情况：到达数组末尾的成本为0 deque.offerLast(n); // 初始化双端队列，末尾为最小成本的虚拟索引n // 从倒数第二个元素开始遍历数组，向前遍历至数组开头 for (int i = n - 1; i \u003e= 0; i--) { int maxCoveredIndex = Math.min(n, 2 * i + 2); // 计算当前水果的最大覆盖索引范围 // 从双端队列头部移除超出当前水果覆盖范围的索引 while (!deque.isEmpty() \u0026\u0026 deque.peekFirst() \u003e maxCoveredIndex) { deque.pollFirst(); } // 更新当前水果的成本，加上该水果可达的最小成本 prices[i] += prices[deque.peekFirst()]; // 维持单调递增的双端队列，移除队列尾部比当前成本大的元素 while (!deque.isEmpty() \u0026\u0026 prices[deque.peekLast()] \u003e prices[i]) { deque.pollLast(); } // 将当前索引加入队列，以便后续计算中使用最小值 deque.offerLast(i); } return prices[0]; // 返回从第一个物品开始的最小硬币总成本 } } 不间断子数组 【力扣传送门】 SHOW CODE Java class Solution { Deque\u0026lt;Integer\u0026gt; increasingQ; Deque\u0026lt;Integer\u0026gt; decreasingQ; public long continuousSubarrays(int[] nums) { increasingQ = new LinkedList\u0026lt;\u0026gt;(); decreasingQ = new LinkedList\u0026lt;\u0026gt;(); int start = 0; long result = 0; // 扩展窗口的终止位置 for (int end = 0; end \u003c nums.length; end++) { // 更新递增队列，确保队列从小到大有序 while (!increasingQ.isEmpty() \u0026\u0026 increasingQ.peekLast() \u003e nums[end]) { increasingQ.pollLast(); } // 更新递减队列，确保队列从大到小有序 while (!decreasingQ.isEmpty() \u0026\u0026 decreasingQ.peekLast() \u003c nums[end]) { decreasingQ.pollLast(); } // 将当前元素加入递增和递减队列 increasingQ.offerLast(nums[end]); decreasingQ.offerLast(nums[end]); // 检查当前窗口是否满足最大值和最小值之差不超过2的条件 while (getMaxInSubArray() - getMinInSubArray() \u003e 2) { // 如果不满足条件，收缩窗口左边界 if (!increasingQ.isEmpty() \u0026\u0026 increasingQ.peekFirst() == nums[start]) { increasingQ.pollFirst(); // 移除递增队列的头部元素 } if (!decreasingQ.isEmpty() \u0026\u0026 decreasingQ.peekFirst() == nums[start]) { decreasingQ.pollFirst(); // 移除递减队列的头部元素 } start++; // 收缩窗口左边界 } // 增加当前窗口内满足条件的子数组数量 result += end - start + 1; } return result; } // 获取当前窗口中的最大值 private long getMaxInSubArray() { return decreasingQ.isEmpty() ? -1 : decreasingQ.peekFirst(); } // 获取当前窗口中的最小值 private long getMinInSubArray() { return increasingQ.isEmpty() ? -1 : increasingQ.peekFirst(); } } HashMap/List/Set 模式相关算法题 华为OD机试：环中最长子串【100分】 点击查看题目 题目描述\n给定一个字符串 s，假设该字符串首尾相连形成一个环形，请在环形字符串中找出包含 o 字符出现偶数次的最长子字符串，并输出该子字符串的长度。\n输入描述\n输入为一个仅由小写字母组成的字符串 s。\n输出描述\n输出一个整数，表示符合条件的最长子字符串的长度。\n示例\n输入：\nalolobo 输出：\n6 示例说明\n在输入字符串 alolobo 中，符合条件的最长子字符串之一是 alolob，它包含 2 个 o 字符，因此其长度为 6。\n点击查看代码 Java import java.util.*; /** * @author Signal Yu * @since 2024-11-06 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取字符串 String s = in.nextLine().trim(); // 计算最长出现了'o'字符的最长子串长度 int maxLength = computeMaxLength(s); // 输出结果 System.out.println(maxLength); } private static int computeMaxLength(String s) { Map frequencyMap = new HashMap\u0026lt;\u0026gt;(); // 统计字符串中各字符出现的频率 for (char c : s.toCharArray()) { frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1); } // 字母'o'的频率 int oCount = frequencyMap.getOrDefault('o', 0); if (oCount % 2 == 0) { // 字母'o'的长度为偶数，直接返回字符串的长度 return s.length(); } else { // 字母'o'的长度为奇数，返回字符串的长度减1 return s.length() - 1; } } } 字符串中的第一个唯一字符 【力扣传送门】 SHOW CODE Java class Solution { public int firstUniqChar(String s) { Map\u0026lt;Character, Integer\u0026gt; frequencyMap = new HashMap\u0026lt;\u0026gt;(); // 统计字符串中的字母频率 for (char c : s.toCharArray()) { frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1); } // 查找第一个只出现一次的字符，并返回其索引 for (int i = 0; i \u003c s.length(); i++) { if (frequencyMap.get(s.charAt(i)) == 1) { return i; } } // 若无唯一字符，返回 -1 return -1; } } “气球” 的最大数量 【力扣传送门】 SHOW CODE Java class Solution { public int maxNumberOfBalloons(String text) { // 定义 balloon 中字符所需的频率，其中 'l' 和 'o' 的需求为 2 Map\u0026lt;Character, Integer\u0026gt; requiredCharMap = Map.of( 'b', 1, 'a', 1, 'l', 2, 'o', 2, 'n', 1); // 统计 text 中与 balloon 相关字符的出现次数 Map\u0026lt;Character, Integer\u0026gt; availableCharMap = new HashMap\u0026lt;\u0026gt;(); for (char c : text.toCharArray()) { if (requiredCharMap.containsKey(c)) { availableCharMap.put(c, availableCharMap.getOrDefault(c, 0) + 1); } } // 计算可以拼成 \"balloon\" 的最大次数 int maxCount = Integer.MAX_VALUE; if (availableCharMap.size() == requiredCharMap.size()) { for (char c : availableCharMap.keySet()) { int requiredCount = requiredCharMap.get(c); int availableCount = availableCharMap.get(c); maxCount = Math.min(maxCount, availableCount / requiredCount); } } return (maxCount == Integer.MAX_VALUE) ? 0 : maxCount; } } 最长回文串 【力扣传送门】 SHOW CODE Java class Solution { public int longestPalindrome(String s) { // 统计每个字符的出现频率 Map\u0026lt;Character, Integer\u0026gt; frequencyMap = new HashMap\u0026lt;\u0026gt;(); for (char c : s.toCharArray()) { frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1); } int maxLength = 0; boolean oddFound = false; // 用于检测是否有频率为奇数的字符 // 计算最长的回文长度 for (int count : frequencyMap.values()) { if (count % 2 == 0) { maxLength += count; // 如果频率为偶数，直接加入到长度 } else { maxLength += count - 1; // 对于奇数频率，加入最大偶数部分 oddFound = true; // 标记存在奇数频率字符 } } // 如果存在奇数频率字符，可将其中一个放在回文中心 return oddFound ? maxLength + 1 : maxLength; } } 赎金信 【力扣传送门】 SHOW CODE Java class Solution { public boolean canConstruct(String ransomNote, String magazine) { // 若 ransomNote 比 magazine 长，则直接返回 false if (ransomNote.length() \u003e magazine.length()) { return false; } // 用数组统计 magazine 中每个字母的出现频率 int[] charCount = new int[26]; for (char c : magazine.toCharArray()) { charCount[c - 'a']++; } // 检查 ransomNote 中每个字母的需求是否可以在 magazine 中满足 for (char c : ransomNote.toCharArray()) { if (charCount[c - 'a'] == 0) { return false; } charCount[c - 'a']--; } return true; } } 华为OD机试：数组去重和排序【100分】 点击查看题目 一、题目描述\n给定一个乱序的数组，删除所有重复元素，使得每个元素只出现一次，并按照出现次数从高到低进行排序。对于出现次数相同的元素，按照它们第一次出现的顺序进行排序。\n二、输入描述\n输入为一个数组，元素之间用逗号分隔。\n三、输出描述\n输出去重并排序后的数组，元素之间用逗号分隔。\n输入示例\n1,3,3,3,2,4,4,4,5 输出示例\n3,4,1,2,5 备注\n数组大小不超过100。 数组元素的值不超过100。 点击查看代码 Java import java.util.*; /** * @author Signal Yu * @since 2024-10-28 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取输入数组 int[] nums = Arrays.stream(in.nextLine().split(\",\")) .map(String::trim) .mapToInt(Integer::parseInt) .toArray(); // 去重并排序 int[] result = removeDuplicatesAndSort(nums); // 输出结果 formatOutput(result); } private static void formatOutput(int[] nums) { StringBuilder sb = new StringBuilder(); for (int num : nums) { sb.append(num).append(\",\"); } sb.setLength(sb.length() - 1); System.out.println(sb); } private static int[] removeDuplicatesAndSort(int[] nums) { Map\u0026lt;Integer, Integer\u0026gt; frequencyMap = new HashMap\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; orderList = new ArrayList\u0026lt;\u0026gt;(); // 统计数字出现次数 for (int num : nums) { if (!frequencyMap.containsKey(num)) { // 第一次出现，记录在顺序表中 orderList.add(num); } frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1); } // 根据出现次数进行排序处理 orderList.sort((a, b) -\u003e frequencyMap.get(b).compareTo(frequencyMap.get(a))); return orderList.stream().mapToInt(Integer::intValue).toArray(); } } 华为OD机试：垃圾信息拦截【100分】 点击查看题目 一、题目描述\n大众对垃圾短信深恶痛绝，希望能识别垃圾短信发送者。经过分析，发现正常用户的短信通常具备交互性，而垃圾短信往往是大量单向的短信。根据如下规则进行垃圾短信识别：\n发送者 A 如果符合以下任一条件，则认为 A 是垃圾短信发送者：\n① A 发送短信的接收者中，没有向 A 发送过短信的人数 $L \u0026gt; 5$；\n② $A 发送的短信数 - A 接收的短信数 M \u0026gt; 10$；\n③ 存在接收者 $X$，使得 $A 发送给 X 的短信数 - A 接收到 X 的短信数 N \u0026gt; 5$。\n二、输入描述\n第一行为条目数目，接下来的几行是具体的条目。每个条目是一个发送者 ID 和一个接收者 ID，之间用空格隔开。所有 ID 为无符号整型，最大值为 100；同一条目中两个 ID 不会相同（即不会自己给自己发消息）。最后一行为指定的 ID。\n三、输出描述\n输出结果为字符串。\n首先输出该 ID 是否为垃圾短信发送者（是则输出 true，否则输出 false），并按序列输出 L 和 M 的值（N 值不需要输出）。\n示例\n输入 8 1 2 1 3 1 4 1 5 1 6 6 1 5 2 6 3 1 输出 false 4 1 说明 输出该 ID 是否为垃圾短信发送者（是则输出 true，否则输出 false），并按序列输出 L 和 M 的值； L 为没有向 A 发过短信的人数，M 为 A 接收的短信数。 在示例中，A 接收的短信数 M 为 1，而没有向 A 发过短信的人数 L 为 4。 点击查看代码 Java import java.util.*; /** * @author Signal Yu * @since 2024-11-11 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取条目数 n int n = Integer.parseInt(in.nextLine().trim()); // 构建发送者到接收者的映射关系 Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u003e senderToReceiverMap = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u003c n; i++) { String[] parts = in.nextLine().trim().split(\" \"); int sender = Integer.parseInt(parts[0]); int receiver = Integer.parseInt(parts[1]); // 添加接收者到对应发送者的列表中 senderToReceiverMap.putIfAbsent(sender, new ArrayList\u0026lt;\u0026gt;()); senderToReceiverMap.get(sender).add(receiver); } // 读取指定的用户 ID A int A = Integer.parseInt(in.nextLine().trim()); in.close(); // 判断指定用户是否为垃圾短信发送者并 String result = isSpamSender(A, senderToReceiverMap); // 输出结果 System.out.println(result); } /** * 判断指定用户是否为垃圾短信发送者，并返回结果字符串。 * * @param A 指定的用户 ID * @param senderToReceiverMap 发送者到接收者的映射关系 * @return 返回 \"true L M\" 或 \"false L M\"，其中 L 和 M 为判定依据的参数值 */ public static String isSpamSender(int A, Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u003e senderToReceiverMap) { List\u0026lt;Integer\u0026gt; sendByAList = senderToReceiverMap.getOrDefault(A, Collections.emptyList()); /* L: 没有回复 A 的接收者人数 M: 给 A 发送过短信的接收者人数 X: A 发送给用户 X 的短信数 N: A 接受到用户 X 的短信数 */ int L = 0, M = 0; boolean flag = false; // 标记条件③是否满足 for (int receiver : sendByAList) { List\u0026lt;Integer\u0026gt; sendToAList = senderToReceiverMap.getOrDefault(receiver, Collections.emptyList()); if (!sendToAList.contains(A)) { L++; // 接收者未给 A 回复，增加 L } else { M++; // 接收者给 A 回复过，增加 M if (!flag) { // 判断条件③：A 发给接收者的次数减去接收者回复 A 的次数 \u003e 5 int X = Collections.frequency(sendByAList, receiver); int N = Collections.frequency(sendToAList, A); flag = X - N \u003e 5; } } } // 根据条件判定是否为垃圾短信发送者 boolean isSpam = L \u003e 5 || (sendByAList.size() - M) \u003e 10 || flag; return String.format(\"%s %d %d\", isSpam, L, M); } } 华为OD机试：最大N个数与最小N个数的和【100分】 点击查看题目 题目描述\n给定一个整数数组，请编写一个函数来计算该数组中最大N个数与最小N个数的和，要求对数组中的数字进行去重处理。\n数组中的数字范围为 $[0, 1000]$。 最大 $N$ 个数与最小 $N$ 个数不能有重叠，如果存在重叠或输入不合法，返回 -1。 输入描述\n第一行输入整数 M，表示数组的大小。 第二行输入 M 个整数，表示数组的内容，元素之间以空格分隔。 第三行输入整数 N，表示需要计算的最大和最小的 N 个数的数量。 输出描述\n输出最大N个数与最小N个数的和。如果输入不合法，输出 -1。\n测试用例\n输入：\n7 47 17 26 9 18 47 52 3 期望输出：\n169 说明：去重后数组为 [9, 17, 18, 26, 47, 52]，最大 3 个数为 26 + 47 + 52 = 125，最小 3 个数为 9 + 17 + 18 = 44。\n点击查看代码 Java import java.util.*; /** * @author Signal Yu * @since 2024-11-12 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取 int m = Integer.parseInt(in.nextLine().trim()); int[] nums = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); int n = Integer.parseInt(in.nextLine().trim()); int result = getSum(nums, n); // 输出结果 System.out.println(result); } /** * 计算最大N个数与最小N个数的和 * * @param nums 输入的数组 * @param n 最大、最小N个数 * @return 最大N个数与最小N个数之和，若输入非法返回-1 */ private static int getSum(int[] nums, int n) { // 使用TreeSet去重并排序 TreeSet\u0026lt;Integer\u0026gt; sortedSet = new TreeSet\u0026lt;\u0026gt;(); for (int num : nums) { sortedSet.add(num); } // 检查是否有足够的元素来获取最大和最小的N个数 if (sortedSet.size() \u003c 2 * n) { return -1; } // 计算最小N个数的和 int minSum = 0; Iterator ascIterator = sortedSet.iterator(); for (int i = 0; i \u003c n; i++) { minSum += ascIterator.next(); } // 计算最大N个数的和 int maxSum = 0; Iterator descIterator = sortedSet.descendingIterator(); for (int i = 0; i \u003c n; i++) { maxSum += descIterator.next(); } return minSum + maxSum; // 计算最小N个数的和 // int totalSum = 0; // for (int i = 0; i \u003c n; i++) { // totalSum += sortedSet.pollFirst(); // totalSum += sortedSet.pollLast(); // } // return totalSum; } } 华为OD机试：全量和已占用字符集【100分】 点击查看题目 一、题目描述\n给定两个字符集，一个是全量字符集，一个是已占用字符集。已占用字符集中的字符不能再使用，要求输出剩余可用字符集。\n二、输入描述\n输入一个字符串，必定包含@，@前为全量字符集，@后的为已占用字符集。 已占用字符集中的字符必定是全量字符集中的字符，字符集中的字符之间使用英文逗号隔开。 每个字符表示为字符加数字的形式，用英文冒号分隔，比如 a:1 表示1个a字符。 字符只考虑英文字母，区分大小写，数字只考虑正整数，不超过100。 如果没有字符被占用，@仍需存在，例如 a:3,b:5,c:2@。 三、输出描述\n输出可用字符集，不同的字符集之间用回车换行。\n注意：输出的字符顺序要与输入一致，不能输出b:3,a:2,c:2。如果某个字符已全部占用，则不需再输出。\n示例\n输入 a:3,b:5,c:2@a:1,b:2 输出 a:2,b:3,c:2 说明\n全量字符集为 3a+5b+2c，已占用字符集为 1a+2b。可用字符集 = 全部字符集 - 已占用字符集 = 2a+3b+2c。 点击查看代码 Java import java.util.*; /** * @author Signal Yu * @since 2024-11-12 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取输入字符串 String input = in.nextLine().trim(); // 分割全量字符串和已占用字符串 String[] parts = input.split(\"@\"); String[] fullSet = parts[0].split(\",\"); String[] usedSet = parts[1].isEmpty() ? new String[0] : parts[1].split(\",\"); // 解析全量字符串 Map\u0026lt;String, Integer\u0026gt; fullCharMap = parseCharacterSet(fullSet); // 解析已占用字符串 Map\u0026lt;String, Integer\u0026gt; usedCharMap = parseCharacterSet(usedSet); // 计算可用字符集 Map\u0026lt;String, Integer\u0026gt; availableCharMap = calculateAvailableMap(fullCharMap, usedCharMap); // 格式化输出可用字符集 String result = formatOutput(availableCharMap); // 输出结果 System.out.println(result); } /** * 格式化输出字符集，格式为 \"字符:数量\" 形式，元素之间用逗号分隔 */ private static String formatOutput(Map\u0026lt;String, Integer\u0026gt; availableCharMap) { StringBuilder result = new StringBuilder(); availableCharMap.forEach((key, value) -\u003e result.append(key).append(\":\").append(value).append(\",\")); // 去掉最后一个多余的逗号 if (!result.isEmpty()) { result.setLength(result.length() - 1); } return result.toString(); } /** * 计算可用字符集，即从全量字符集中扣除已占用字符数，返回剩余可用字符集 */ private static Map\u0026lt;String, Integer\u0026gt; calculateAvailableMap(Map\u0026lt;String, Integer\u0026gt; fullCharMap, Map\u0026lt;String, Integer\u0026gt; usedCharMap) { Map\u0026lt;String, Integer\u0026gt; availableCharMap = new LinkedHashMap\u0026lt;\u0026gt;(); fullCharMap.forEach((charKey, fullCount) -\u003e { int availableCount = fullCount - usedCharMap.getOrDefault(charKey, 0); if (availableCount \u003e 0) { availableCharMap.put(charKey, availableCount); } }); return availableCharMap; } /** * 解析字符集字符串数组（如 \"A:5\"）为 Map，每个字符及其对应数量 */ private static Map\u0026lt;String, Integer\u0026gt; parseCharacterSet(String[] charSet) { Map\u0026lt;String, Integer\u0026gt; charSetMap = new LinkedHashMap\u0026lt;\u0026gt;(); for (String item : charSet) { String[] parts = item.split(\":\"); if (parts.length == 2) { String charKey = parts[0]; int charCount = Integer.parseInt(parts[1]); charSetMap.put(charKey, charCount); } } return charSetMap; } } 华为OD机试：告警抑制【100分】 点击查看题目 一、题目描述\n在告警系统中，高优先级的告警可以抑制低优先级的告警。当一个高优先级告警发生后，与之有抑制关系的低优先级告警将不再触发。请根据给定的告警抑制关系和告警产生列表，计算出最终实际产生的告警列表。\n抑制规则：当某告警A抑制告警B时，若A触发，B将被抑制，反之不然。 不传递抑制：如果A抑制B且B抑制C，A不会直接抑制C。 无循环抑制：保证抑制关系中不存在循环。 二、输入描述\n第一行输入一个整数N，表示告警抑制关系的数量，0 \u0026lt;= N \u0026lt;= 120。 接下来N行，每行包含两个告警ID，由空格分隔，格式为 id1 id2，表示 id1 抑制 id2。告警ID由一个大写字母和可选的一个数字组成。 最后一行输入告警产生列表，表示实际发生的告警ID序列，长度为 1 ～ 100。 三、输出描述\n输出实际产生的告警列表，按照输入顺序去除被抑制的告警。\n四、示例\n输入示例\n3 A C B D A B A B C D E 输出示例\nA E 示例说明\nA抑制C； B抑制D； A抑制B； 因此，最终的实际产生告警列表为 A E。 点击查看代码 Java import java.util.*; /** * @author Signal Yu * @since 2024-11-12 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取告警抑制关系的数量 int n = Integer.parseInt(in.nextLine().trim()); // 读取抑制关系并构建映射表 Map\u0026lt;String, List\u0026lt;String\u0026gt;\u003e suppressionMap = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u003c n; i++) { String[] parts = in.nextLine().trim().split(\" \"); String highPriority = parts[0]; String lowPriority = parts[1]; suppressionMap.putIfAbsent(highPriority, new ArrayList\u0026lt;\u0026gt;()); suppressionMap.get(highPriority).add(lowPriority); } // 读取告警产生列表 List\u0026lt;String\u0026gt; warningList = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(in.nextLine().trim().split(\" \"))); in.close(); // 获取实际产生的告警列表 String result = getActualWarningList(suppressionMap, warningList); // 输出最终告警列表 System.out.println(result); } /** * 根据告警抑制关系，计算最终的实际告警列表 * * @param suppressionMap 抑制关系映射，key表示高优先级告警，value表示被其抑制的低优先级告警列表 * @param warningList 初始告警产生列表 * @return 实际产生的告警列表字符串 */ private static String getActualWarningList(Map\u0026lt;String, List\u0026lt;String\u0026gt;\u003e suppressionMap, List\u0026lt;String\u0026gt; warningList) { Set\u0026lt;String\u0026gt; suppressedWarnings = new HashSet\u0026lt;\u0026gt;(); // 遍历告警抑制关系，标记被抑制的告警 for (String highPriority : suppressionMap.keySet()) { suppressedWarnings.addAll(suppressionMap.get(highPriority)); } // 过滤掉被抑制的告警，保留未被抑制的告警 warningList.removeAll(suppressedWarnings); // 格式化输出最终告警列表 return String.join(\" \", warningList); } } 华为OD机试：报文回路【100分】 点击查看题目 一、题目描述 在 IGMP 协议中，响应报文和查询报文是维持组播通路的重要机制。在一条已建立的组播通路中，两个相邻的主机（host）和路由器（router）之间会通过这两类报文进行通信。路由器定期向主机发送查询报文，主机在接收到查询后，向路由器发送响应报文以维持连接关系。一旦这种关系断裂，组播通路就会出现异常。\n现已通过抓包工具截获了所有 host 与 router 之间的查询和响应报文。请根据这些报文分析该组播通路是否正常。\n二、输入描述\n第一行输入一个整数 C，表示抓到的报文数量（C \u0026lt;= 100）。 接下来的 C 行，每行包含两个用空格隔开的整数 D1 和 D2，表示一个从设备节点 D1 到设备节点 D2 的单向报文。 三、输出描述\n输出组播通路的状态。若通路正常，输出 true；若异常，输出 false。\n示例\n输入： 5 1 2 2 3 3 2 1 2 2 1 输出： true 点击查看代码 Java import java.util.*; /** * @author Signal Yu * @since 2024-11-13 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取抓到的报文数量 int c = Integer.parseInt(in.nextLine().trim()); // 构建报文发送关系映射：key为发送设备，value为接收设备的集合 Map\u0026lt;Integer, Set\u0026lt;Integer\u0026gt;\u0026gt; communicationMap = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u003c c; i++) { String[] parts = in.nextLine().trim().split(\" \"); int sender = Integer.parseInt(parts[0]); int receiver = Integer.parseInt(parts[1]); communicationMap .computeIfAbsent(sender, k -\u003e new HashSet\u0026lt;\u0026gt;()) .add(receiver); // communicationMap.putIfAbsent(sender, new HashSet\u0026lt;\u0026gt;()); // communicationMap.get(sender).add(receiver); } // 判断组播通路的状态 boolean isPathNormal = checkBidirectionalConnections(communicationMap); // 输出结果 System.out.println(isPathNormal); } /** * 检查所有报文对是否满足双向性要求。 * * @param communicationMap 设备之间的报文传输关系映射 * @return true如果所有报文对双向连接正常；否则返回false */ private static boolean checkBidirectionalConnections(Map\u0026lt;Integer, Set\u0026lt;Integer\u0026gt;\u0026gt; communicationMap) { for (Map.Entry\u0026lt;Integer, Set\u0026lt;Integer\u0026gt;\u0026gt; entry : communicationMap.entrySet()) { Integer sender = entry.getKey(); Set receivers = entry.getValue(); // 检查每个接收设备是否具有相应的反向报文 for (Integer receiver : receivers) { if (!communicationMap.containsKey(receiver) || !communicationMap.get(receiver).contains(sender)) { return false; // 发现单向连接，返回异常状态 } } } return true; // 所有连接均双向，返回正常状态 } } 华为OD机试：异常的打卡记录【100分】 点击查看题目 一、题目描述 考勤记录用于分析和考核员工的工作时间利用情况，也是计算工资的依据。为了确保考勤数据的准确性，公司决定对员工的打卡记录进行异常排查。\n判断打卡异常的条件如下：\n实际设备号与员工的注册设备号不一致； 同一员工的两个打卡记录时间间隔小于60分钟，且打卡地点间距超过5公里。 给定打卡记录的字符串数组 clockRecord，每条记录格式为：工号,时间（分钟）,打卡距离（公里）,实际设备号,注册设备号。请返回其中所有异常的打卡记录，按输入顺序输出。\n二、输入描述\n第一行输入为整数 N，表示打卡记录的总数； 接下来的 N 行分别是每条打卡记录，每行包含如下信息： 工号，时间（分钟），打卡距离（公里），实际设备号，注册设备号 三、输出描述\n按输入顺序输出所有异常的打卡记录，每条记录之间用分号隔开。 示例\n输入\n6 1,10,1,100,100 1,80,10,100,100 1,120,16,100,100 2,80,10,200,200 2,150,15,200,200 3,150,15,200,300 输出\n1,80,10,100,100;1,120,16,100,100;3,150,15,200,300 点击查看代码 Java import java.util.*; /** * @author Signal Yu * @since 2024-11-13 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取打卡记录数量 int n = Integer.parseInt(in.nextLine().trim()); // 读取打卡记录并构建映射表 Map\u0026lt;String, List\u0026lt;ClockRecord\u0026gt;\u003e recordMap = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u003c n; i++) { String recordStr = in.nextLine().trim(); String[] parts = recordStr.split(\",\"); String id = parts[0]; int time = Integer.parseInt(parts[1]); double distance = Double.parseDouble(parts[2]); String actualDeviceNo = parts[3]; String registeredDeviceNo = parts[4]; ClockRecord record = new ClockRecord(id, time, distance, actualDeviceNo, registeredDeviceNo, recordStr); recordMap.computeIfAbsent(id, k -\u003e new ArrayList\u0026lt;\u0026gt;()) .add(record); } // 检查异常记录 String abnormalClockRecords = checkAbnormalRecords(recordMap); // 输出结果 System.out.println(abnormalClockRecords); } /** * 检查所有打卡记录，识别异常记录 * @param recordMap 每位员工的打卡记录映射表 * @return 异常记录字符串，以分号隔开 */ private static String checkAbnormalRecords(Map\u0026lt;String, List\u0026lt;ClockRecord\u0026gt;\u003e recordMap) { Set\u0026lt;String\u0026gt; anomalies = new LinkedHashSet\u0026lt;\u0026gt;(); // 遍历每个员工的打卡记录 for (Map.Entry\u0026lt;String, List\u0026lt;ClockRecord\u0026gt;\u003e entry : recordMap.entrySet()) { List\u0026lt;ClockRecord\u0026gt; records = entry.getValue(); // 对于同一员工的每一条打卡记录，检查设备号一致性和时间间隔与距离条件 for (int i = 0; i \u003c records.size(); i++) { ClockRecord record = records.get(i); // 条件1：检查设备号是否一致 if (!record.actualDeviceNo.equals(record.registeredDeviceNo)) { anomalies.add(record.originalRecord); continue; } // 条件2：检查时间间隔和距离 for (int j = i + 1; j \u003c records.size(); j++) { ClockRecord otherRecord = records.get(j); int timeDiff = Math.abs(record.time - otherRecord.time); double distanceDiff = Math.abs(record.distance - otherRecord.distance); // 若满足条件2，记录异常打卡记录 if (timeDiff \u003c 60 \u0026\u0026 distanceDiff \u003e 5) { anomalies.add(record.originalRecord); anomalies.add(otherRecord.originalRecord); break; // 已识别异常，跳过进一步的比较 } } } } // 返回按输入顺序排列的异常记录，用分号分隔 return String.join(\";\", anomalies); } } /** * 员工打卡记录类 */ class ClockRecord { String id; // 员工工号 int time; // 打卡时间（分钟） double distance; // 打卡距离（公里） String actualDeviceNo; // 实际设备号 String registeredDeviceNo; // 注册设备号 String originalRecord; // 原始打卡记录字符串 public ClockRecord(String id, int time, double distance, String actualDeviceNo, String registeredDeviceNo, String originalRecord) { this.id = id; this.time = time; this.distance = distance; this.actualDeviceNo = actualDeviceNo; this.registeredDeviceNo = registeredDeviceNo; this.originalRecord = originalRecord; } } 贪心算法模式相关算法题 救生艇 【力扣传送门】 SHOW CODE Java class Solution { public int numRescueBoats(int[] people, int limit) { // 对体重数组进行升序排序 Arrays.sort(people); int left = 0, right = people.length - 1; int minBoatCount = 0; // 记录所需最小的船的数量 while (left \u003c= right) { if (left == right) { minBoatCount++; break; } // if (people[left] + people[right] \u003c= limit) { // left++; // right--; // minBoatCount++; // } else { // right--; // minBoatCount++; // } // 最轻和最重的两人可以共用一艘船 if (people[left] + people[right] \u003c= limit) { left++; } right--; // 无论是否共用，右指针都左移，表示最重者已被安排 minBoatCount++; } return minBoatCount; } } 华为OD机试：租车骑绿道【100分】 点击查看题目 一、题目描述\n部门组织团建活动，安排绿道骑行，需要租用双人自行车。每辆自行车最多可容纳两人，且载重上限为 m。给出部门中每个人的体重，求最少需要租用多少辆双人自行车。\n二、输入描述\n第一行包含两个整数 m 和 n，其中 m 表示每辆自行车的最大载重，n 表示部门的总人数。 第二行包含 n 个整数，表示每个人的体重（每个人的体重不超过自行车的载重限制 m）。 输入数据满足以下条件：\n0 \u0026lt; m \u0026lt;= 200 0 \u0026lt; n \u0026lt;= 1,000,000 三、输出描述\n输出最少需要的双人自行车数量。\n点击查看代码 Java import java.util.*; /** * @author Signal Yu * @since 2024-11-03 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取自行车限重与人数 int[] parts = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); int m = parts[0]; // 读取体重数据 int[] weights = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); // 计算所需最少双人自行车数量 int result = computeMinimumBicycles(weights, m); // 输出结果 System.out.println(result); } private static int computeMinimumBicycles(int[] weights, int maxWeight) { // 对数组进行排序，便于使用双指针模式 Arrays.sort(weights); // 初始化双指针 int left = 0, right = weights.length - 1; int bicycleCount = 0; // while (left \u003c= right) { // // 最轻和最重的人可以共用一辆车 // if (weights[left] + weights[right] \u003c= maxWeight) { // left++; // 左指针右移 // right--; // bicycleCount++; // } else { // 不能公用自行车 // right--; // 右指针左移 // bicycleCount++; // } // } while (left \u003c= right) { // 最轻和最重的人可以共用一辆车 if (weights[left] + weights[right] \u003c= maxWeight) { left++; // 左指针右移 } right--; // 右指针左移 bicycleCount++; } return bicycleCount; } } 验证回文串 II 【力扣传送门】 SHOW CODE Java class Solution { public boolean validPalindrome(String s) { int left = 0, right = s.length() - 1; // 遍历字符串，左右指针逐步收缩 while (left \u003c right) { // 如果左右字符不相等，尝试跳过一次字符判断是否为回文 if (s.charAt(left) != s.charAt(right)) { // 若去掉左边或右边的一个字符后形成回文，则返回true return isPalindrome(s, left + 1, right) || isPalindrome(s, left, right - 1); } left++; right--; } // 若没有出现不相等字符，原字符串已是回文 return true; } // 辅助函数：判断子字符串是否为回文 private static boolean isPalindrome(String s, int left, int right) { while (left \u003c right) { if (s.charAt(left) != s.charAt(right)) { return false; } left++; right--; } return true; } } 最长数对链 【力扣传送门】 SHOW CODE Java class Solution { public int findLongestChain(int[][] pairs) { // 按照每个数对的第二个元素升序排序 Arrays.sort(pairs, (a, b) -\u003e a[1] - b[1]); int chainCount = 0; // 记录最长数对链的长度 int currentEnd = Integer.MIN_VALUE; // 当前数对链的末尾数对的第二个元素 for (int[] pair : pairs) { // 若当前数对的起始元素大于当前链的末尾元素，说明可以将该数对加入链中 if (pair[0] \u003e currentEnd) { currentEnd = pair[1]; // 更新链的末尾元素 chainCount++; // 增加数对链的长度 } } return chainCount; // 返回最长数对链 } } 使括号有效的最少添加 【力扣传送门】 SHOW CODE Java class Solution { public int minAddToMakeValid(String s) { int openNeeded = 0; // 记录需要补充的左括号数量 int closeNeeded = 0; // 记录需要补充的右括号数量量 for (char c : s.toCharArray()) { // 遇到左括号，所需右括号加 1；遇到右括号则减 1 closeNeeded += c == '(' ? 1 : -1; // closeNeeded 为负值表明该右括号多余，需要一个左括号进行匹配 if (closeNeeded == -1) { openNeeded++; // 左括号数量加 1 closeNeeded++; // 增加左括号数量后，多余的右括号数量减 1 } } return openNeeded + closeNeeded; // 返回至少需要的括号总数 } } 去除重复字母 【力扣传送门】 SHOW CODE Java class Solution { public String removeDuplicateLetters(String s) { Map\u0026lt;Character, Integer\u0026gt; frequencyMap = new HashMap\u0026lt;\u0026gt;(); // 统计每个字符的出现频率 for (char c : s.toCharArray()) { frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1); } Stack\u0026lt;Character\u0026gt; charStack = new Stack\u0026lt;\u0026gt;(); // 维护结果字符的栈 Set\u0026lt;Character\u0026gt; charSet = new HashSet\u0026lt;\u0026gt;(); // 记录栈中已包含的字符 for (char c : s.toCharArray()) { if (!charSet.contains(c)) { // 移除栈中比当前字符字典序大的字符，确保字典序最小 // 栈顶元素频率不为0表明还存在未被遍历相同元素 while (!charStack.isEmpty() \u0026\u0026 frequencyMap.get(charStack.peek()) \u003e 0 \u0026\u0026 charStack.peek() \u003e c) { charSet.remove(charStack.pop()); } charStack.push(c); // 将当前字符加入栈中 charSet.add(c); // 将当前字符标记为已加入栈 } // 更新当前字符的剩余出现次数 frequencyMap.put(c, frequencyMap.get(c) - 1); } // 构建结果字符串 StringBuilder builder = new StringBuilder(); for (char c : charStack) { builder.append(c); } return builder.toString(); } } 最大回文数字 【力扣传送门】 SHOW CODE Java class Solution { public String largestPalindromic(String num) { // 存储回文的第一部分 StringBuilder firstHalf = new StringBuilder(); // 统计每个数字字符的出现频率 int[] frequency = new int[10]; for (char c : num.toCharArray()) { int i = (int) c - '0'; frequency[i]++; } int middle = -1; // 存储回文中间的单个字符 // 从高位到低位遍历，优先选择较大的数字构建回文 for (int i = 9; i \u003e= 0; i--) { // 确保避免前导零（添加0之前firstHalf不能为空） if (frequency[i] \u003e 0 \u0026\u0026 (i != 0 || !firstHalf.isEmpty())) { int count = frequency[i]; while (count \u003e 1) { firstHalf.append(i); count -= 2; } // 如果当前数字剩余一个且未设置中间字符，选择该数字为中间字符 if (count == 1 \u0026\u0026 middle == -1) { middle = i; } } } StringBuilder secondHalf = new StringBuilder(firstHalf); if (middle != -1) { // 若存在中间字符，将其加入到回文中间 firstHalf.append(middle); } firstHalf.append(secondHalf.reverse()); // 拼接第二部分构成完整回文 return !firstHalf.isEmpty() ? firstHalf.toString() : \"0\"; } } 从数组中移除最大值和最小值 【力扣传送门】 SHOW CODE Java class Solution { public int minimumDeletions(int[] nums) { int n = nums.length; int minIndex = 0, maxIndex = 0; // 查找数组中的最大值和最小值对应的索引 for (int i = 0; i \u003c n; i++) { if (nums[i] \u003c nums[minIndex]) { minIndex = i; } if (nums[i] \u003e nums[maxIndex]) { maxIndex = i; } } // 计算从起点或终点删除最大值和最小值的最小距离 int minFromStart = minIndex + 1; int minFromEnd = n - minIndex; int maxFromStart = maxIndex + 1; int maxFromEnd = n - maxIndex; // 考虑四种删除方式，并选择删除步数最小的方案： int[] deletionOptions = new int[]{ // 同向移动存在重叠，取最大值 Math.max(minFromStart, maxFromStart), // 同时从起点删除 Math.max(minFromEnd, maxFromEnd), // 同时从重点删除 minFromStart + maxFromEnd, // 分别从起点和终点删除 maxFromStart + minFromEnd // 分别从起点和终点删除 }; // 返回删除步数的最小值 return Arrays.stream(deletionOptions).min().orElseThrow(); } } 华为OD机试：模拟商场优惠打折II【100分】 点击查看题目 一、题目描述\n某网上商城推出了三种类型的优惠券：满减、打折和无门槛优惠券，具体规则如下：\n满减券：每满100元减10元，可叠加使用，无使用张数限制。例如，购物金额在100至199元之间可使用1张满减券减10元，200至299元可使用2张减20元，以此类推。 打折券：92折，每次限用1张。例如，100元使用后为92元。 无门槛优惠券：每张直接减5元，可叠加使用，无张数限制。 每次购物最多允许使用2种优惠券，且优惠叠加时按优惠后的价格计算。以购物金额200元为例：\n方案1：先使用92折券，优惠至184元，再使用1张满减券减10元，最终价格为174元。 方案2：先使用2张满减券减20元至180元，再用92折券优惠到165元（结果向下取整）。 不同的使用顺序会产生不同的优惠价格，应优先考虑优惠后的最低价格。如果多个方案优惠后的价格相同，则优先选择使用优惠券数量最少的方案。如果无需使用优惠券即可达到最低价格，也可选择不使用。\n每位顾客在活动中仅可参与一次，且优惠券种类和数量一致。\n二、输入描述\n第一行：三个整数，表示每人拥有的满减券、打折券和无门槛优惠券的数量（每种数量的取值范围为 $[0,10]$）。 第二行：一个整数n，表示购物的人数（$1 ≤ n ≤ 10,000$）。 接下来的 n 行：每行一个整数，表示每位顾客优惠前的购物总价（购物总价范围为 $(0,1000]$，均为整数）。 三、输出描述\n每行输出每位顾客优惠后的最低价格和使用的优惠券总数量，按输入顺序输出结果。 补充说明\n优惠券数量均为整数，范围为 $[0,10]$。 购物人数为整数，范围为 $[1,10,000]$。 购物总价为整数，范围为 $(0,1000]$。 计算优惠后的价格若为小数，则向下取整。输出均为整数。 点击查看代码 Java 执行任务赚积分【100分】 SHOW PROBLEM 一、题目描述\n有 N 个任务需要处理，每个任务的处理时间为 1 单位时间。每个任务都有一个最晚处理时间限制和一个积分值，只有在最晚处理时间之前完成任务才能获得对应的积分。\n假设有 T 单位时间可以用于处理任务，请问在这 T 单位时间内，可以获得的最大积分是多少？\n二、输入描述\n第一行输入一个整数 N，表示任务的数量 (1 ≤ N ≤ 100)。 第二行输入一个整数 T，表示可用于处理任务的时间单位数 (1 ≤ T ≤ 100)。 接下来 N 行，每行两个整数 SLA 和 V，分别表示任务的最晚处理时间和该任务的积分值： 1 \u0026lt; SLA ≤ 100 0 ≤ V ≤ 100000 三、输出描述\n输出一个整数，表示在有限的时间内可以获得的最大积分。\n四、测试用例\n测试用例 1\n输入： 4 3 1 2 1 3 1 4 3 5 输出： 9 说明： 第 1 个时间单位内，处理任务 (1, 4)，获得 4 分。 第 2 个时间单位内，处理任务 (1, 5)，获得 5 分。 最终总积分为 4 + 5 = 9。 测试用例 2\n输入： 4 3 1 2 1 3 1 4 1 5 输出： 5 说明： 虽然有 3 个时间单位可以处理任务，但是所有任务在时间 1 之后都已经无效，因此只能在第 1 个时间单位处理任务 (1, 5)，获得 5 分。 测试用例 3\n输入： 4 3 1 2 2 4 2 3 1 5 输出： 9 说明： 按照积分从高到低排序后，任务顺序为： (1, 5)，(2, 4)，(2, 3)，(1, 2) 第 1 个时间单位，处理任务 (1, 5)，获得 5 分。 第 2 个时间单位，处理任务 (2, 4)，获得 4 分。 第 3 个时间单位，没有合适的任务可以处理。 最终总积分为 5 + 4 = 9。 SHOW CODE Java import java.util.*; /** * @author Signal Yu * @since 2024-11-29 */ public class Solution { static class Task { int deadline; // The latest time the task can be completed int value; // The points awarded for completing the task public Task(int deadline, int value) { this.deadline = deadline; this.value = value; } } public static void main(String[] args) { Scanner in = new Scanner(System.in); // Read the number of tasks (n) and available time units (t) int n = Integer.parseInt(in.nextLine().trim()); int t = Integer.parseInt(in.nextLine().trim()); // Create a list to store tasks List\u0026lt;Task\u0026gt; taskList = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c n; i++) { int[] parts = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); // Read task's deadline and value taskList.add(new Task(parts[0], parts[1])); } // Calculate the maximum points we can earn int maxPoints = getMaxPoints(taskList, t); // Output the result System.out.println(maxPoints); } private static int getMaxPoints(List\u0026lt;Task\u0026gt; taskList, int t) { // Sort tasks by value in descending order to prioritize higher value tasks taskList.sort((a, b) -\u003e Integer.compare(b.value, a.value)); // Array to track used time slots boolean[] timeSlots = new boolean[t]; int totalPoints = 0; for (Task task : taskList) { // Try to find the latest available time slot before or on the task's deadline for (int i = Math.min(task.sla - 1, t - 1); i \u003e= 0; i--) { if (!timeSlots[i]) { // If the time slot is available timeSlots[i] = true; // Mark the time slot as occupied totalPoints += task.value; // Add task's points to the total break; // Move to the next task after assigning this one } } } return totalPoints; } } 栈模式相关算法题 删除字符串中的所有相邻重复项 【力扣传送门】 SHOW CODE Java class Solution { public String removeDuplicates(String s) { Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); // 遍历字符串中的每个字符 for (char c : s.toCharArray()) { // 若栈不为空且栈顶字符与当前字符相同，则弹出栈顶元素（移除重复字符） if (!stack.isEmpty() \u0026\u0026 stack.peek() == c) { stack.pop(); } else { // 否则将当前字符压入栈中 stack.push(c); } } // 构建结果字符串 StringBuilder builder = new StringBuilder(); for (char c : stack) { builder.append(c); } // 返回去重后的字符串 return builder.toString(); } } 华为OD机试：字符串消除【100分】 点击查看题目 一、题目描述\n游戏规则 Q：给定一个只包含英文字母的字符串，若字符串中的两个相邻且相同的字母，则这两个字母可以消除。在字符串上反复执行消除的操作，直到无法再消除为止。游戏结束时，输出剩余字符串的长度。\n二、输入描述\n输入原始字符串 str，它只包含大小写英文字母，字母的大小写敏感，且 str 的长度不超过 100。\n三、输出描述\n输出游戏结束后，最终剩余字符串的长度。\n示例：\n输入 1：\ngg 输出 1：\n0 说明 1： gg 可以直接消除，得到空串，长度为 0。\n输入 2：\naabccba 输出 2：\n1 说明 2： 首先消除 aa，然后消除 cc，再消除 b，b，最后剩余a，长度为 1。\n点击查看代码 Java import java.util.*; /** * @author Signal Yu * @since 2024-11-15 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取输入字符串 String str = in.nextLine().trim(); // 移除重复字符 String result = removeDuplicates(str); // 输出结果 System.out.println(result); } private static String removeDuplicates(String s) { Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); // 遍历字符串中的每个字符 for (char c : s.toCharArray()) { // 若栈不为空且栈顶字符与当前字符相同，则弹出栈顶元素（移除重复字符） if (!stack.isEmpty() \u0026\u0026 stack.peek() == c) { stack.pop(); } else { // 否则将当前字符压入栈中 stack.push(c); } } // 构建结果字符串 StringBuilder builder = new StringBuilder(); for (char c : stack) { builder.append(c); } // 返回去重后的字符串 return builder.toString(); } } 有效的括号 【力扣传送门】 SHOW CODE Java class Solution { public boolean isValid(String s) { Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (char c : s.toCharArray()) { // 若字符为左括号，压入栈中 if (c == '(' || c == '[' || c == '{') { stack.push(c); } else { // 若栈为空或栈顶元素不匹配当前右括号，则无效 if (stack.isEmpty() || !isMatchingPair(stack.pop(), c)) { return false; } } } // 最终栈应为空，表示所有括号匹配 return stack.isEmpty(); } private boolean isMatchingPair(char open, char close) { return (open == '(' \u0026\u0026 close == ')') || (open == '[' \u0026\u0026 close == ']') || (open == '{' \u0026\u0026 close == '}'); } } 华为OD机试：最大括号深度【100分】 点击查看题目 一、题目描述\n给定一个字符串，由以下六种括号组成：(、)、{、}、[、]。判断该字符串是否为有效的括号匹配字符串。\n一个字符串为无效，如果满足以下任意条件：\n任意一种括号的左右数量不匹配； 存在未按正确顺序的括号闭合，即右括号在左括号之前出现。 若字符串有效，输出该字符串的最大嵌套深度；若字符串无效，输出 0。\n0 \u0026lt;= 字符串长度 \u0026lt;= 100000。\n二、输入描述\n一个只包含(、)、{、}、[、] 六种括号的字符串。\n三、输出描述\n输出一个整数，表示字符串中的最大括号嵌套深度。如果字符串无效，输出 0。\n示例：\n输入 1：\n[] 输出 1：\n1 说明 1： 字符串 [] 是有效的，最大嵌套深度为 1。\n输入 2：\n[{[]}()] 输出 2：\n3 说明 2： 字符串 [{[]}()] 是有效的，最大嵌套深度为 3。\n输入 3：\n[{(])} 输出 3：\n0 说明 3： 字符串 [{(])} 是无效的，因为 ( 和 ) 不是正确配对的，输出 0。\n点击查看代码 Java import java.util.*; /** * @author Signal Yu * @since 2024-11-15 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取包含括号的字符串 String str = in.nextLine().trim(); // 计算括号的最大嵌套深度 int maxDepth = getMaxDepth(str); // 输出结果 System.out.println(maxDepth); } private static int getMaxDepth(String s) { Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); int maxDepth = 0; // 记录括号最大嵌套深度 for (char c : s.toCharArray()) { if (isOpenParenthesis(c)) { stack.push(c); } else { // 栈为空，没有与之匹配的左括号，字符串无效 if (stack.isEmpty()) { return 0; } // 判断栈顶元素与当前右括号是否匹配 if (!isMatch(stack.peek(), c)) { return 0; } // 更新最大深度 maxDepth = Math.max(maxDepth, stack.size()); // 匹配成功，弹出栈顶元素 stack.pop(); } } return maxDepth; // 返回最终计算的最大深度 } private static boolean isOpenParenthesis(char c) { return c == '(' || c == '[' || c == '{'; } private static boolean isMatch(char c1, char c2) { return (c1 == '(' \u0026\u0026 c2 == ')') || (c1 == '[' \u0026\u0026 c2 == ']') || (c1 == '{' \u0026\u0026 c2 == '}'); } } 删除字符串中的所有相邻重复项 II 【力扣传送门】 SHOW CODE Java class Solution { public String removeDuplicates(String s, int k) { // 使用栈存储字符及其计数信息 Stack\u0026lt;int[]\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); // 遍历字符串中的每个字符 for (char c : s.toCharArray()) { // 若栈顶字符与当前字符相同，则增加计数 if (!stack.isEmpty() \u0026\u0026 stack.peek()[0] == c) { stack.peek()[1]++; } else { // 若不同，则将当前字符及计数1入栈 stack.push(new int[]{c, 1}); } // 如果栈顶字符的计数达到k，弹出栈顶（删除k个相同字符） if (stack.peek()[1] == k) { stack.pop(); } } // 构建结果字符串 StringBuilder builder = new StringBuilder(); for (int[] entry : stack) { builder.append(String.valueOf((char) entry[0]).repeat(entry[1])); } return builder.toString(); } } 简化路径 【力扣传送门】 SHOW CODE Java class Solution { public String simplifyPath(String path) { // 将路径按“/”分割 String[] split = path.split(\"/\"); // 用栈来处理路径的规范化 Stack\u0026lt;String\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (String s : split) { // 忽略空字符串和当前目录符号 \".\" if (!s.isEmpty() || !\".\".equals(s)) { stack.push(s); } else if (\"..\".equals(s)) { // 如果是父目录符号 \"..\"，且栈不为空，则弹出栈顶元素 if (!stack.isEmpty()) { stack.pop(); } } } // 构建结果路径 StringBuilder builder = new StringBuilder(); for (String dir : stack) { builder.append(\"/\").append(dir); } // 如果栈为空，返回根目录 \"/\" return builder.length() == 0 ? \"/\" : builder.toString(); } } 华为OD机试：模拟目录管理【100分】 点击查看题目 一、题目描述\n实现一个模拟目录管理功能的软件，支持以下命令序列，并输出最后一条命令的运行结果。\n创建目录命令：mkdir 目录名称，如 mkdir abc 用于在当前目录创建名为 abc 的目录。如果已存在同名目录，则不执行任何操作。此命令无输出。\n进入目录命令：cd 目录名称，如 cd abc 用于进入 abc 目录。特殊地，cd .. 用于返回上级目录。如果目录不存在，则不执行任何操作。此命令无输出。\n查看当前所在路径命令：pwd，输出当前路径字符串。\n约束：\n目录名称仅支持小写字母；mkdir 和 cd 命令的参数仅支持单个目录，如 mkdir abc 和 cd abc；不支持嵌套路径和绝对路径，如 mkdir abc/efg、cd abc/efg 等。 目录符号为 /，根目录 / 作为初始目录。 任何不符合上述定义的无效命令不做任何处理，并且无输出。 二、输入描述\n输入 N 行字符串，每一行字符串是一条命令。\n三、输出描述\n输出最后一条命令的运行结果字符串。\n补充说明：\n命令行数限制为 100 行以内，目录名称限制为 10 个字符以内。 四、测试用例\n输入 mkdir abc cd abc pwd 输出\n/abc/ 输入 mkdir test cd test mkdir example cd example cd .. pwd 输出\n/test/ 说明 mkdir test 创建了目录 test。 cd test 进入目录 test。 mkdir example 在 test 目录下创建了目录 example（该命令实际不影响路径管理）。 cd .. 返回上级目录 /test/。 pwd 输出当前路径 /test/。 点击查看代码 Java import java.util.*; /** * @author Signal Yu * @since 2024-11-14 */ class Solution { private static final String ROOT = \"/\"; // 根目录标识 private static final Stack\u0026lt;String\u0026gt; pathStack = new Stack\u0026lt;\u0026gt;(); // 存储当前路径的目录栈 private static final Set\u0026lt;String\u0026gt; dirNames = new HashSet\u0026lt;\u0026gt;(); // 存储已创建的目录名称集合 public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取命令条目 while (in.hasNextLine()) { String command = in.nextLine().trim(); if (command.startsWith(\"mkdir \")) { mkdir(command.substring(6)); // 创建目录 } else if (command.startsWith(\"cd \")) { cd(command.substring(3)); // 切换目录 } else if (\"pwd\".equals(command)) { System.out.println(pwd()); // 显示当前路径 } } in.close(); } private static boolean isValidName(String dirName) { return dirName.matches(\"[a-z]{1,10}\"); } private static String pwd() { StringBuilder builder = new StringBuilder(ROOT); for (String dirName : pathStack) { builder.append(dirName).append(\"/\"); // 将每个目录名添加到路径中 } return builder.toString(); } private static void cd(String dirName) { if (\"..\".equals(dirName) \u0026\u0026 !pathStack.isEmpty()) { pathStack.pop(); // 返回上一级目录 } else if (isValidName(dirName) \u0026\u0026 dirNames.contains(dirName)) { pathStack.push(dirName); // 切换到有效且已创建的目录 } } private static void mkdir(String dirName) { if (isValidName(dirName)) { dirNames.add(dirName); // 添加到已创建目录集合 } } } 华为OD机试：荒岛求生【100分】 点击查看题目 题目描述\n有一个荒岛，岛上有两个港口（左港口和右港口），它们通过一座桥连接。现在一群人需要从两个港口逃生，有的人往右逃生（正数表示），有的人往左逃生（负数表示）。当两个人相遇时，会发生PK，体力值较大的人胜出，体力值相同的人则同归于尽。胜者继续向前逃生，并相应减少体力值。\n输入描述\n一行非零整数，用空格隔开，正数代表向右逃生，负数代表向左逃生。\n输出描述\n最终能够成功逃生的人数。\n示例\n输入：\n10 20 -20 -5 10 输出：\n2 说明：\n正数集合：10, 20, 10 负数集合：-20, -5 20 和 -20 同归于尽； 10 和 -5 对战，剩余 5 体力； 最终逃生人数为 2 人。 点击查看代码 Java import java.util.*; /** * @author Signal Yu * @since 2024-11-15 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取输入数据 int[] nums = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); // 计算最终成功逃生的人数 int result = escape(nums); // 输出结果 System.out.println(result); } private static int escape(int[] nums) { // 使用栈来模拟桥上的人，栈顶表示当前在桥上的人 Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (int num : nums) { // 如果栈不为空且当前人和栈顶人的体力值符号相反（即发生碰撞） while (!stack.isEmpty() \u0026\u0026 stack.peek() * num \u003c 0) { // 对战：将体力较小的人的体力值加到栈顶，并判断结果 num += stack.pop(); } // 如果当前人仍然有体力（体力不为零），则继续逃生，将其加入栈 if (num != 0) { stack.push(num); } } // 返回栈中剩余人的数量，即最终成功逃生的人数 return stack.size(); } } 字符串解码 【力扣传送门】 SHOW CODE Java public class Solution { public String decodeString(String s) { // 栈用于存储重复次数和之前的字符串 Stack\u0026lt;Integer\u0026gt; countStack = new Stack\u0026lt;\u0026gt;(); Stack\u0026lt;StringBuilder\u0026gt; stringStack = new Stack\u0026lt;\u0026gt;(); // 当前正在构建的字符串 StringBuilder currentString = new StringBuilder(); // 当前的重复次数 int currentCount = 0; // 遍历字符串中的每个字符 for (char c : s.toCharArray()) { if (Character.isDigit(c)) { // 如果是数字，构建当前重复次数（可能是多位数） currentCount = currentCount * 10 + (c - '0'); } else if (c == '[') { // 遇到 '['，将当前重复次数和字符串入栈，准备开始一个新的编码块 countStack.push(currentCount); // 入栈重复次数 stringStack.push(currentString); // 入栈当前字符串 currentString = new StringBuilder(); // 重置当前字符串 currentCount = 0; // 重置重复次数 } else if (c == ']') { // 遇到 ']'，解码：将当前字符串重复 countStack 中的次数 int repeatTimes = countStack.pop(); // 从栈中取出重复次数 StringBuilder decodedSubstring = currentString; // 获取当前解码块 currentString = stringStack.pop(); // 获取之前的字符串 // 重复当前字符串并拼接到原来的字符串上 for (int i = 0; i \u003c repeatTimes; i++) { currentString.append(decodedSubstring); } } else { // 如果是字母，直接加入当前字符串 currentString.append(c); } } return currentString.toString(); } } 华为OD机试：简单的解压缩算法【100分】 点击查看题目 一、题目描述\n现需要实现一种算法，将一组压缩字符串还原成原始字符串。压缩规则如下：\n字符重复规则：如果字符后面加上一个数字 N，则表示该字符重复 N 次。例如：压缩内容为 A3，表示原始字符串为 AAA。 花括号重复规则：花括号中的字符串后面加上一个数字 N，表示花括号中的字符串重复 N 次。例如：压缩内容为 {AB}3，表示原始字符串为 ABABAB。 嵌套规则：字符重复和花括号内容的重复规则支持任意的嵌套结构，包括互相嵌套。例如：压缩内容可以是 {A3B1{C}3}3，表示原始字符串为 AACCCBAACCCBAACCCB。 请实现一个算法，解压给定的压缩字符串，并还原成原始字符串。\n二、输入描述\n输入为一行压缩后的字符串。\n三、输出描述\n输出解压后的原始字符串。\n四、补充说明\n输入保证，数字 N 不为 0，花括号中的内容不为空，且保证输入的字符串合法有效。 输入和输出的字符串区分大小写。 输入的字符串长度范围为 [1, 10000]。 输出的字符串长度范围为 [1, 100000]。 数字 N 的取值范围为 [1, 10000]。 点击查看代码 Java import java.util.*; /** * @author Signal Yu * @since 2024-11-16 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取压缩字符串 String str = in.nextLine().trim(); // 解压字符串并还原成原始字符串 String result = decodeString(str); // 输出结果 System.out.println(result); } private static String decodeString(String s) { Stack\u0026lt;String\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); int n = s.length(); int repeatTimes; // 重复次数 int i = 0; while (i \u003c n) { char c = s.charAt(i); // 如果是 '{' 或者字母，直接入栈 if (c == '{' || Character.isLetter(c)) { stack.push(String.valueOf(c)); i++; } else if (Character.isDigit(c)) { // 如果是数字，表示需要处理重复逻辑 int j = i; // 获取数字部分（重复次数） while (j \u003c n \u0026\u0026 Character.isDigit(s.charAt(j))) { j++; } // 获取重复次数 repeatTimes = Integer.parseInt(s.substring(i, j)); String top = stack.pop(); stack.push(top.repeat(repeatTimes)); i = j; // 更新索引，跳过数字部分 } else { // 如果是 '}'，处理嵌套部分 StringBuilder builder = new StringBuilder(); // 弹出栈顶元素直到遇到 '{'，构建当前部分的字符串 while (!stack.isEmpty()) { String top = stack.pop(); if (\"{\".equals(top)) { break; } builder.insert(0, top); // 将当前元素添加到结果的开头 } stack.push(builder.toString()); i++; } } // 拼接栈中的子串以构建原始字符串 StringBuilder result = new StringBuilder(); for (String str : stack) { result.append(str); } return result.toString(); } } 单调栈模式相关算法题 下一个更大元素 I 【力扣传送门】 SHOW CODE Java class Solution { public int[] nextGreaterElement(int[] nums1, int[] nums2) { Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); Map\u0026lt;Integer, Integer\u0026gt; nextGreaterMap = new HashMap\u0026lt;\u0026gt;(); // 从右向左遍历 nums2，构建每个元素的下一个更大元素映射 for (int i = nums2.length - 1; i \u003e= 0; i--) { int num = nums2[i]; // 移除栈顶小于等于当前元素的值 while (!stack.isEmpty() \u0026\u0026 stack.peek() \u003c= num) { stack.pop(); } // 若栈不为空，栈顶即为下一个更大元素，否则为 -1 nextGreaterMap.put(num, stack.isEmpty() ? -1 : stack.peek()); // 将当前元素入栈，用于后续元素的比较 stack.push(num); } // 构建结果数组，将 nums1 中的每个元素对应的下一个更大元素取出 int[] result = new int[nums1.length]; for (int i = 0; i \u003c nums1.length; i++) { result[i] = nextGreaterMap.get(nums1[i]); } return result; } } 华为OD机试：分奖金【100分】 点击查看题目 一、题目描述 公司老板做了一笔大生意，想要给每位员工分配一些奖金，决定通过游戏的方式来确定每个人分到多少奖金。每位员工根据工号顺序随机抽取一个数字。按照工号顺序，遇到第一个比自己数字大的员工，前面的员工可以获得“距离 * 数字差值”的奖金。如果没有员工的数字比自己大，则该员工获得与自己数字相同的奖金。具体规则如下：\n每位员工抽取一个数字，并按照工号顺序排列； 对于每一位员工，找到第一个数字比自己大的人，计算奖金为“距离 * 数字差值”； 如果没有找到比自己数字大的员工，则该员工获得自己数字的奖金。 例如，假设员工的随机数字依次为：2 10 3，那么：\n第1个员工：数字2，遇到第2个员工数字10，比自己大，因此第1个员工可以获得奖金 1 * (10 - 2) = 8； 第2个员工：数字10，后面没有比10大的数字，所以他获得自己的奖金，金额为10； 第3个员工：数字3，后面没有比3大的数字，所以他获得自己的奖金，金额为3。 请编写程序，计算每位员工最终获得的奖金。\n二、输入描述\n第一行是一个整数 n，表示员工的数量（包含老板）。 第二行是一个包含 n 个数字的字符串，每个数字表示对应员工抽取的随机数字。 三、输出描述\n输出一行，包含每个员工最终分配的奖金数量，以空格分隔。\n四、测试用例\n测试用例1： 输入：\n3 2 10 3 输出：\n8 10 3 测试用例2： 输入：\n4 5 7 8 6 输出：\n2 1 8 6 点击查看代码 Java import java.util.*; /** * @author Signal Yu * @since 2024-11-15 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取员工数量 int n = Integer.parseInt(in.nextLine().trim()); // 读取员工抽取的随机数字 int[] nums = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); // 计算每个员工最终获得的奖金数量 int[] bonus = computeBonus(nums, n); // 格式化输出结果 System.out.println(Arrays.toString(bonus).replaceAll(\"[\\\\[\\\\],]\", \"\").trim()); } private static int[] computeBonus(int[] nums, int n) { Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); int[] bonus = new int[n]; // 用来存储每个员工的奖金 for (int i = n - 1; i \u003e= 0; i--) { // 弹出栈中所有不大于当前员工数字的元素 while (!stack.isEmpty() \u0026\u0026 nums[stack.peek()] \u003c= nums[i]) { stack.pop(); } // 如果栈非空，说明当前员工的奖金由栈顶的员工决定 if (!stack.isEmpty()) { bonus[i] = (stack.peek() - i) * (nums[stack.peek()] - nums[i]); } else { // 如果栈为空，说明当前员工没有遇到比自己数字大的员工，奖金为自己的数字 bonus[i] = nums[i]; } // 将当前员工的索引推入栈中 stack.push(i); } return bonus; } } 每日温度 【力扣传送门】 SHOW CODE Java class Solution { public int[] dailyTemperatures(int[] temperatures) { int n = temperatures.length; int[] result = new int[n]; Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); // 栈中存储温度索引 // 从后向前遍历温度数组 for (int i = n - 1; i \u003e= 0; i--) { // 弹出栈顶不满足条件的元素，即栈顶温度不高于当前温度 while (!stack.isEmpty() \u0026\u0026 temperatures[stack.peek()] \u003c= temperatures[i]) { stack.pop(); } // 如果栈为空，则结果为 0，否则为最近的更高温度索引差值 result[i] = stack.isEmpty() ? 0 : stack.peek() - i; // 当前索引入栈，作为后续元素的比较参考 stack.push(i); } return result; } } 下一个更大元素 II 【力扣传送门】 SHOW CODE Java class Solution { public int[] nextGreaterElements(int[] nums) { int n = nums.length; Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); int[] result = new int[n]; // 初始化结果数组为 -1，假设不存在下一个更大元素 Arrays.fill(result, -1); // 双倍长度遍历数组模拟循环数组 for (int i = 0; i \u003c 2 * n; i++) { int num = nums[i % n]; // 如果栈顶元素的下一个更大元素是当前元素，则更新结果数组 while (!stack.isEmpty() \u0026\u0026 nums[stack.peek()] \u003c num) { result[stack.pop()] = num; } // 仅当 i \u003c n 时压栈，避免重复处理 if (i \u003c n) { stack.push(i); } } return result; } } 华为OD机试：阿里巴巴找黄金宝箱（IV）【100分】 点击查看题目 一、题目描述\n一贫如洗的樵夫阿里巴巴，在去砍柴的路上，无意中发现了一个藏宝地，藏宝地有编号从0到N的箱子，每个箱子上面都有一个数字。这些箱子按照顺时针方向排列成一个环，编号最大的箱子的下一个是编号为0的箱子。\n现在，请你帮助阿里巴巴计算每个箱子上数字后的下一个比它大的数字。如果某个箱子没有比它大的数字，则输出-1。\n二、输入描述\n输入一个由逗号分隔的数字子串，表示各个箱子上的数字。\n1 \u0026lt;= 子串中数字的个数 \u0026lt;= 10,000 -100,000 \u0026lt;= 每个数字的值 \u0026lt;= 100,000 三、输出描述\n输出一个逗号分隔的数字列表，表示每个箱子上数字后的下一个比它大的数字。如果没有，则输出-1。\n示例\n输入\n1,2,3,1 输出\n2,3,-1,2 说明\n第一个箱子的数字1，后面第一个比它大的数字是2。 第二个箱子的数字2，后面第一个比它大的数字是3。 第三个箱子的数字3，没有比它大的数字，输出 -1。 第四个箱子的数字1，后面第一个比它大的数字是 2。 点击查看代码 Java import java.util.*; /** * @author Signal Yu * @since 2024-11-15 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取宝箱编号 int[] nums = Arrays.stream(in.nextLine().trim().split(\",\")) .mapToInt(Integer::parseInt) .toArray(); // 查找每个箱子数字下一个比它大的数字 String result = nextGreaterElement(nums); // 输出结果 System.out.println(result); } private static String nextGreaterElement(int[] nums) { int n = nums.length; int[] result = new int[n]; // 使用栈来保存数组的索引 Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); // 初始化结果数组为 -1，假设所有元素都没有下一个更大的元素 Arrays.fill(result, -1); // 遍历数组两遍，模拟环形数组 for (int i = 0; i \u003c 2 * n; i++) { int num = nums[i % n]; // 当前元素，利用i % n保证环形结构 // 如果栈顶元素对应的数字小于当前数字，说明当前数字是下一个更大的元素 while (!stack.isEmpty() \u0026\u0026 nums[stack.peek()] \u003c num) { result[stack.pop()] = num; // 更新结果数组 } // 仅当i小于n时，将索引压栈，避免重复处理 if (i \u003c n) { stack.push(i); } } // 构建返回结果的字符串 StringBuilder builder = new StringBuilder(); for (int num : result) { builder.append(num).append(\",\"); } // 删除最后一个多余的逗号 builder.setLength(builder.length() - 1); return builder.toString(); } } 从链表中移除节点 【力扣传送门】 SHOW CODE Java /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode removeNodes(ListNode head) { // 使用栈来存储节点，确保每个节点的值不小于前面的节点 Stack\u0026lt;ListNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); ListNode current = head; // 遍历链表 while (current != null) { // 如果当前节点值大于栈顶节点的值，则弹出栈顶节点，确保栈中节点值单调递减 while (!stack.isEmpty() \u0026\u0026 stack.peek().val \u003c current.val) { stack.pop(); } // 如果栈不为空，连接栈顶节点与当前节点，确保链表的连续性 if (!stack.isEmpty()) { stack.peek().next = current; } // 将当前节点压入栈中 stack.push(current); // 移动到下一个节点 current = current.next; } // 返回栈底的节点，即链表头节点 return stack.isEmpty() ? null : stack.get(0); } } 移掉 K 位数字 【力扣传送门】 SHOW CODE Java class Solution { public String removeKdigits(String num, int k) { Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); // 遍历数字字符，使用单调递增栈保持最小的数字组合 for (char digit : num.toCharArray()) { // 当前数字比栈顶小，且仍有移除次数时，弹出栈顶数字 while (!stack.isEmpty() \u0026\u0026 stack.peek() \u003e digit \u0026\u0026 k \u003e 0) { stack.pop(); k--; } stack.push(digit); // 将当前数字压入栈中 } // 若 k \u003e 0，移除栈顶元素以达到所需移除的位数 for (int i = 0; i \u003c k; i++) { stack.pop(); } // 将栈中数字构建为结果字符串 StringBuilder builder = new StringBuilder(); for (char c : stack){ builder.append(c); } // 删除前导零 while (!builder.isEmpty() \u0026\u0026 builder.charAt(0) == '0') { builder.deleteCharAt(0); } // 若结果为空，则返回 \"0\" return builder.isEmpty() ? \"0\" : builder.toString(); } } 子集模式相关算法题 子集 【力扣传送门】 SHOW CODE Java class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets(int[] nums) { // 用于存储所有子集的列表 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets = new ArrayList\u0026lt;\u0026gt;(); // 添加空集 subsets.add(new ArrayList\u0026lt;\u0026gt;()); for (int num : nums) { int size = subsets.size(); // 遍历已有子集，将当前数字添加到每个子集中生成新子集 for (int i = 0; i \u003c size; i++) { // 创建当前子集的副本并添加当前数字 List currentSet = new ArrayList(subsets.get(i)); currentSet.add(num); // 将新子集添加到子集列表中 subsets.add(currentSet); } } return subsets; } } 子集 II 【力扣传送门】 SHOW CODE Java class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsetsWithDup(int[] nums) { // 对数组进行排序，以便在遍历时检测重复元素 Arrays.sort(nums); List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets = new ArrayList\u0026lt;\u0026gt;(); // 添加空集作为初始子集 subsets.add(new ArrayList\u0026lt;\u0026gt;()); int start = 0, end = 0; // 遍历每个元素，构造包含该元素的子集 for (int i = 0; i \u003c nums.length; i++) { // 如果当前元素与上一个元素相同，则仅从上次新增的子集开始 start = (i \u003e 0 \u0026\u0026 nums[i] == nums[i - 1]) ? end + 1 : 0; // 记录当前子集的末尾位置，以便确定新子集的起始范围 end = subsets.size() - 1; // 从 startIdx 到 endIdx 遍历，生成新的子集 for (int j = start; j \u003c= end; j++) { // 为当前子集创建副本并添加当前元素 List currentSet = new ArrayList\u0026lt;\u0026gt;(subsets.get(j)); currentSet.add(nums[i]); subsets.add(currentSet); } } return subsets; } } 华为OD机试：查找充电设备【100分】 点击查看题目 一、题目描述\n某个充电站可以提供 $n$ 个充电设备，每个充电设备均有对应的输出功率。任意个充电设备组合的输出功率总和构成一个功率集合 $P$。功率集合 $P$ 的最优元素表示最接近充电站最大输出功率 $p_{max}$ 的元素。\n二、输入描述\n输入共 3 行：\n第 1 行为充电设备的个数 $n$； 第 2 行为每个充电设备的输出功率，以空格分隔； 第 3 行为充电站的最大输出功率 $p_{max}$。 三、输出描述\n输出功率集合$P$的最优元素。\n四、补充说明\n充电设备个数 $n \u0026gt; 0$； 最优元素必须小于或等于充电站最大输出功率 $p_{max}$。 点击查看代码 Java import java.util.ArrayList; import java.util.List; import java.util.Scanner; /** * 计算功率的所有子集 * 求解最优子集和 * * @author Signal Yu * @since 2024-10-28 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 获取充电设备个数 int n = in.nextInt(); // 获取充电设备功率 List\u0026lt;Integer\u0026gt; powerList = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u003c n; i++) { powerList.add(in.nextInt()); } // 获取充电站最大输出功率 int maxPower = in.nextInt(); in.close(); // 求解最有功率组合 int result = findOptimalPower(powerList, maxPower); // 输出结果 System.out.println(result); } private static int findOptimalPower(List\u0026lt;Integer\u0026gt; powerList, int maxPower) { if (powerList.isEmpty()) { return 0; } int optimalPower = Integer.MIN_VALUE; List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets = new ArrayList\u0026lt;\u0026gt;(); subsets.add(new ArrayList\u0026lt;\u0026gt;()); for (int power : powerList) { int subsetSize = subsets.size(); for (int i = 0; i \u003c subsetSize; i++) { // 在原子集基础上新建子集 List\u0026lt;Integer\u0026gt; subset = new ArrayList\u0026lt;\u0026gt;(subsets.get(i)); subset.add(power); int subsetSum = subset.stream().mapToInt(Integer::intValue).sum(); if (subsetSum \u003c= maxPower) { optimalPower = Math.max(optimalPower, subsetSum); } subsets.add(subset); } } return (optimalPower == Integer.MIN_VALUE) ? 0 : optimalPower; } } 全排列 【力扣传送门】 SHOW CODE Java class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { // 存储最终结果的全排列 List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); // 存储中间状态的排列 Queue\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permutations = new LinkedList\u0026lt;\u0026gt;(); // 初始添加空排列 permutations.add(new ArrayList\u0026lt;\u0026gt;()); // 遍历每个数字，将其插入到现有排列的每个位置 for (int num : nums) { int n = permutations.size(); for (int i = 0; i \u003c n; i++) { List oldPermutation = permutations.poll(); // 将当前数字插入到排列中的每个可能位置，形成新的排列 for (int j = 0; j \u003c= oldPermutation.size(); j++) { List newPermutation = new ArrayList\u0026lt;\u0026gt;(oldPermutation); // 在第 j 个位置插入当前数字 newPermutation.add(j, num); // 如果新排列的长度与输入数组长度相等，则表示一个完整的排列 if (newPermutation.size() == nums.length) { result.add(newPermutation); } else { // 继续加入队列待处理 permutations.add(newPermutation); } } } } return result; } } 字母大小写全排列 【力扣传送门】 SHOW CODE Java class Solution { public List\u0026lt;String\u0026gt; letterCasePermutation(String s) { List\u0026lt;String\u0026gt; permutations = new ArrayList\u0026lt;\u0026gt;(); permutations.add(s); // 初始化时将原始字符串添加到结果列表中 // 遍历字符串的每个字符 for (int i = 0; i \u003c s.length(); i++) { // 如果字符是字母，则生成大小写的变换 if (Character.isLetter(s.charAt(i))) { int size = permutations.size(); // 对当前已有的每个排列进行修改，生成新排列 for(int j = 0; j \u003c size; j++) { char[] charArray = permutations.get(j).toCharArray(); // 切换当前字母的大小写 charArray[i] = Character.isUpperCase(charArray[i]) ? Character.toLowerCase(charArray[i]) : Character.toUpperCase(charArray[i]); // 将新排列添加到列表 permutations.add(new String(charArray)); } } } return permutations; } } 括号生成 【力扣传送门】 SHOW CODE Java class Solution { public List\u0026lt;String\u0026gt; generateParenthesis(int n) { List\u0026lt;String\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); // 存储所有有效的括号组合 Queue\u0026lt;ParenthesesString\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.add(new ParenthesesString(\"\", 0, 0)); // 初始状态，字符串为空，左右括号数为0 // 广度优先遍历，生成每种可能的括号组合 while (!queue.isEmpty()) { ParenthesesString parentheses = queue.poll(); // 如果当前字符串已包含 n 对括号，将其加入结果集 if (parentheses.openCount == n \u0026\u0026 parentheses.closeCount == n) { result.add(parentheses.str); } else { // 如果左括号数小于 n，可以添加左括号 if (parentheses.openCount \u003c n) { queue.add(new ParenthesesString(parentheses.str + \"(\", parentheses.openCount + 1, parentheses.closeCount)); } // 如果右括号数小于左括号数，可以添加右括号 if (parentheses.openCount \u003e parentheses.closeCount) { queue.add(new ParenthesesString(parentheses.str + \")\", parentheses.openCount, parentheses.closeCount + 1)); } } } return result; } } // 辅助类，用于存储生成过程中的字符串及其左右括号数量 class ParenthesesString { String str; // 当前生成的括号字符串 int openCount; // 左括号数量 int closeCount; // 右括号数量 public ParenthesesString(String str, int openCount, int closeCount) { this.str = str; this.openCount = openCount; this.closeCount = closeCount; } } 区间合并模式相关算法题 合并区间 【力扣传送门】 SHOW CODE Java class Solution { public int[][] merge(int[][] intervals) { // 按每个区间的起始位置进行升序排序 Arrays.sort(intervals, (a, b) -\u003e a[0] - b[0]); // 用于存放合并后的区间 List\u0026lt;int[]\u0026gt; mergedIntervals = new ArrayList\u0026lt;\u0026gt;(); // 初始化当前区间为第一个区间 int[] currentInterval = intervals[0]; mergedIntervals.add(currentInterval); // 遍历后续区间并进行合并 for (int[] interval : intervals) { int currentEnd = currentInterval[1]; int nextStart = interval[0]; int nextEnd = interval[1]; // 如果当前区间的结束点不小于下一个区间的起始点，则合并区间 if (nextStart \u003c= currentEnd) { currentInterval[1] = Math.max(currentEnd, nextEnd); // 更新当前区间的结束点 } else { // 否则，当前区间结束，将下一个区间设为新的当前区间 currentInterval = interval; mergedIntervals.add(currentInterval); } } // 将列表转换为二维数组返回 return mergedIntervals.toArray(new int[mergedIntervals.size()][]); } } 华为OD机试：会议室占用时间段【100分】 点击查看题目 一、题目描述\n现有若干个会议，所有会议共享一个会议室。用数组表示各个会议的开始时间和结束时间，格式为：[[会议1开始时间，会议1结束时间], [会议2开始时间，会议2结束时间]]。请计算会议室的占用时间段。\n二、输入描述\n[[会议1开始时间，会议1结束时间], [会议2开始时间，会议2结束时间]]\n备注：\n会议个数范围：[1, 100] 会议室时间段：[1, 24] 三、输出描述\n输出格式与输入一致，具体请看用例。\n[[会议开始时间，会议结束时间], [会议开始时间，会议结束时间]]\n1、输入 [[1, 4], [4, 5]]\n2、输出 [[1, 5]]\n点击查看代码 Java import java.util.ArrayList; import java.util.Comparator; import java.util.List; import java.util.Scanner; /** * 区间合并问题： * 1. 根据区间起始时间排序 * 2. 若区间发生重叠，则更新当前区间的结束时间 * 3. 若区间没有发生重叠，则将其添加至结果集 * 4. 重叠判定：下一个区间的起始时间是否小于或等于当前区间结束时间 * * @author Signal Yu * @since 2024-10-28 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取输入 String input = in.nextLine(); in.close(); // 处理输入 List\u0026lt;int[]\u0026gt; intervals = parseInput(input); // 区间合并 List\u0026lt;int[]\u0026gt; mergedIntervals = mergeIntervals(intervals); // 输出结果 System.out.println(formatOutput(mergedIntervals)); } private static String formatOutput(List\u0026lt;int[]\u0026gt; intervals) { StringBuilder sb = new StringBuilder(); sb.append(\"[\"); for (int[] interval : intervals) { sb.append(\"[\").append(interval[0]).append(\",\").append(interval[1]).append(\"],\"); } // 移除末尾的逗号 if (!sb.isEmpty()) { sb.setLength(sb.length() - 1); } sb.append(\"]\"); return sb.toString(); } private static List\u0026lt;int[]\u0026gt; mergeIntervals(List\u0026lt;int[]\u0026gt; intervals) { if (intervals.size() \u003c= 1) { return intervals; } // 根据区间的起始时间进行排序 intervals.sort(Comparator.comparingInt(a -\u003e a[0])); List\u0026lt;int[]\u0026gt; mergedIntervals = new ArrayList\u0026lt;\u0026gt;(); int[] currentInterval = intervals.get(0); mergedIntervals.add(currentInterval); for (int i = 1; i \u003c intervals.size(); i++) { int[] nextInterval = intervals.get(i); int nextStart = nextInterval[0]; int nextEnd = nextInterval[1]; int currentEnd = currentInterval[1]; if (nextStart \u003c= currentEnd) { // 区间重叠 // 更新当前区间的结束时间 currentInterval[1] = Math.max(currentEnd, nextEnd); } else { // 区间无重叠 mergedIntervals.add(nextInterval); currentInterval = nextInterval; } } return mergedIntervals; } private static List\u0026lt;int[]\u0026gt; parseInput(String input) { // 移除中括号和空格 input = input.replaceAll(\"[\\\\[\\\\]\\\\s]\", \"\"); String[] pairs = input.split(\",\"); List\u0026lt;int[]\u0026gt; intervals = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u003c pairs.length; i += 2) { int start = Integer.parseInt(pairs[i]); int end = Integer.parseInt(pairs[i + 1]); intervals.add(new int[]{start, end}); } return intervals; } } 华为OD机试：路灯照明问题【100分】 点击查看题目 题目描述\n在一条笔直的公路上安装了 $N$ 个路灯，从位置 0 开始安装，路灯之间的间距固定为 100 米。每个路灯都有其照明半径，请计算从第一个路灯到最后一个路灯之间无法被任何路灯照亮的区间长度之和。\n输入描述\n第一行包含一个整数 $N$，表示路灯的个数，$1 \\leq N \\leq 100000$。 第二行包含 $N$ 个正整数，以空格分隔，表示每个路灯的照明半径，$1 \\leq \\text{照明半径}$。 输出描述\n输出第一个路灯与最后一个路灯之间，所有无法照亮的区间长度之和。\n示例\n输入：\n3 20 70 30 输出：\n10 说明\n第一个路灯覆盖 0 到 20 米，第二个路灯覆盖 30 到 170 米，第二个路灯覆盖 170 到 230 米，因此未被照明的区间为[20, 30]，所以输出为 $10（30 -20）$。\n点击查看代码 Java import java.util.*; /** * @author Signal Yu * @since 2024-11-12 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取路灯个数 int n = Integer.parseInt(in.nextLine().trim()); // 读取照明半径字符串并转换为数组 int[] lightRadius = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); // 计算无法照亮的的长度和 int result = getNonLightDistance(lightRadius, n); // 输出结果 System.out.println(result); } private static int getNonLightDistance(int[] lightRadius, int n) { // 根据照明半径生成照明区间 List lightIntervals = new ArrayList\u003c\u003e(); // 生成每个路灯的照明区间：[起始位置 - 半径, 起始位置 + 半径] for (int i = 0; i \u003c n; i++) { int r = lightRadius[i]; lightIntervals.add(new int[]{i * 100 - r, i * 100 + r}); } // 按照区间起点进行排序 lightIntervals.sort(Comparator.comparingInt(a -\u003e a[0])); int currentEnd = lightIntervals.get(0)[1]; int totalNonLightDistance = 0; for (int i = 1; i \u003c lightIntervals.size(); i++) { int[] interval = lightIntervals.get(i); int start = interval[0]; int end = interval[1]; if (currentEnd \u003c start) { // 当前区间和下一个区间之间的未覆盖部分 totalNonLightDistance += start - currentEnd; } currentEnd = Math.max(currentEnd, end); // 更新已覆盖的最远端 } return totalNonLightDistance; } } 插入区间 【力扣传送门】 SHOW CODE Java class Solution { public int[][] insert(int[][] intervals, int[] newInterval) { List\u0026lt;int[]\u0026gt; mergedIntervals = new ArrayList\u0026lt;\u0026gt;(); int i = 0; // 将不重叠且位于 newInterval 左侧的区间直接加入结果集 while (i \u003c intervals.length \u0026\u0026 intervals[i][1] \u003c newInterval[0]) { mergedIntervals.add(intervals[i]); i++; } // 合并与 newInterval 重叠的区间，更新 newInterval 的左右边界 while (i \u003c intervals.length \u0026\u0026 intervals[i][0] \u003c= newInterval[1]) { newInterval[0] = Math.min(intervals[i][0], newInterval[0]); newInterval[1] = Math.max(intervals[i][1], newInterval[1]); i++; } // 将合并后的 newInterval 加入结果集 mergedIntervals.add(newInterval); // 将剩余不重叠且位于 newInterval 右侧的区间加入结果集 while (i \u003c intervals.length) { mergedIntervals.add(intervals[i]); i++; } // 将结果集转换为二维数组返回 return mergedIntervals.toArray(new int[mergedIntervals.size()][]); } } 区间列表的交集 【力扣传送门】 SHOW CODE Java class Solution { public int[][] intervalIntersection(int[][] firstList, int[][] secondList) { List\u0026lt;int[]\u0026gt; intersections = new ArrayList\u0026lt;\u0026gt;(); int i = 0, j = 0; // 使用双指针遍历两个列表，寻找所有重叠区间 while (i \u003c firstList.length \u0026\u0026 j \u003c secondList.length) { int start = Math.max(firstList[i][0], secondList[j][0]); int end = Math.min(firstList[i][1], secondList[j][1]); // 如果两个区间有交集，加入结果列表 if (start \u003c= end) { intersections.add(new int[] { start, end }); } // 移动指向区间结束较早的指针，以继续寻找可能的交集 if (firstList[i][1] \u003c secondList[j][1]) { i++; } else { j++; } } return intersections.toArray(new int[intersections.size()][]); } } 无重叠区间 【力扣传送门】 SHOW CODE Java class Solution { public int eraseOverlapIntervals(int[][] intervals) { // 按区间的结束时间升序排序，以便优先选择结束早的区间 Arrays.sort(intervals, (a, b) -\u003e Integer.compare(a[1], b[1])); int removeCount = 0; // 记录需要移除的重叠区间数 int end = intervals[0][1]; // 初始化为第一个区间的结束时间 // 从第二个区间开始遍历 for (int i = 1; i \u003c intervals.length; i++) { // 如果当前区间的起始时间不小于上一个区间的结束时间，则无重叠 if (intervals[i][0] \u003e= end) { end = intervals[i][1]; // 更新结束时间为当前区间的结束时间 } else { removeCount++; // 重叠区间，计数增加 } } return removeCount; } } 判断两个事件是否存在冲突 【力扣传送门】 SHOW CODE Java class Solution { public boolean haveConflict(String[] event1, String[] event2) { /* 时间格式为 \"HH:MM\" ，符合字典顺序，可以使用 compareTo 方法来比较时间的先后顺序。 str1.compareTo(str2): 负数 --\u003e str1 \u003c str2 0 --\u003e str1 == str2 正数 --\u003e str1 \u003e str2 */ /* 不存在冲突情况 (1)【事件1】 】 【事件2】 (2)【事件2】 】 【事件1】 */ return !(event1[1].compareTo(event2[0]) \u003c 0 || event2[1].compareTo(event1[0]) \u003c 0); } } 动态规划模式相关算法题 斐波那契数列模式 斐波那契数 【力扣传送门】 点击查看代码：暴力递归 暴力递归 class Solution { public int fibRecursive(int n) { if (n \u003c 2) { return n; // 基础情况：F(0) = 0，F(1) = 1 } return fibRecursive(n - 1) + fibRecursive(n - 2); // 递归计算 F(n) = F(n-1) + F(n-2) } } 点击查看代码：记忆化递归 记忆化递归 class Solution { public int fibMemoization(int n) { int[] cache = new int[n + 1]; // 用于缓存计算结果 return fibRecursiveWithCache(n, cache); } private int fibRecursiveWithCache(int n, int[] cache) { if (n \u003c 2) { return n; // 基础情况 } if (cache[n] == 0) { // 缓存未命中时，计算并保存结果 cache[n] = fibRecursiveWithCache(n - 1, cache) + fibRecursiveWithCache(n - 2, cache); } return cache[n]; // 返回缓存结果 } } 递归树分析：\n斐波那契数列 = [0, 1, 1, 2, 3, 5] n = 5 --- title: 递归树分析：斐波那契数 --- graph TD L0((5)) L0 --\u003e L1((4)) L0 --\u003e R1((3)) L1 --\u003e L2a((3)) L1 --\u003e L2b((2)) L2a --\u003e L3a((2)) L2a --\u003e L3b((1)) L3a --\u003e L4a((1)) L3a --\u003e L4b((0)) style R1 fill:blue style L2a fill:blue style L2b fill:orange,color:black style L3a fill:orange,color:black 点击查看代码：自下而上迭代 自下而上迭代 class Solution { public int fibTabulation(int n) { if (n \u003c 2) { return n; // 基础情况 } int[] dp = new int[n + 1]; // 状态数组 dp[0] = 0; dp[1] = 1; for (int i = 2; i \u003c= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; // F(i) = F(i-1) + F(i-2) } return dp[n]; // 返回最终结果 } } 自下而上迭代 点击查看代码：空间优化 空间优化 class Solution { public int fibSpaceOptimized(int n) { if (n \u003c 2) { return n; // 基础情况 } int prev1 = 0, prev2 = 1, current; // 初始化前两个状态 for (int i = 2; i \u003c= n; i++) { current = prev1 + prev2; // F(i) = F(i-1) + F(i-2) prev1 = prev2; // 更新状态 prev2 = current; } return prev2; // 返回最终结果 } } 斐波那契数等式：$F(n) = F(n-1) + F(n-2)$\n爬楼梯 【力扣传送门】 点击查看代码：暴力递归 暴力递归 class Solution { public int climbStairsRecursive(int n) { if (n \u003c 3) { return n; // 基础情况：1级楼梯1种方法，2级楼梯2种方法 } return climbStairsRecursive(n - 1) + climbStairsRecursive(n - 2); // F(n) = F(n-1) + F(n-2) } } 点击查看代码：记忆化递归 记忆化递归 class Solution { public int climbStairsMemoization(int n) { int[] cache = new int[n + 1]; // 缓存数组 return climbStairsWithCache(n, cache); } private int climbStairsWithCache(int n, int[] cache) { if (n \u003c 3) { return n; // 基础情况 } if (cache[n] == 0) { // 缓存未命中时，计算并保存结果 cache[n] = climbStairsWithCache(n - 1, cache) + climbStairsWithCache(n - 2, cache); } return cache[n]; // 返回缓存结果 } } 点击查看代码：自下而上迭代 自下而上迭代 class Solution { public int climbStairsTabulation(int n) { if (n \u003c 3) { return n; // 基础情况 } int[] cache = new int[n + 1]; // 状态数组 cache[1] = 1; cache[2] = 2; for (int i = 3; i \u003c= n; i++) { cache[i] = cache[i - 1] + cache[i - 2]; // F(i) = F(i-1) + F(i-2) } return cache[n]; // 返回结果 } } 点击查看代码：空间优化 空间优化 class Solution { public int climbStairsSpaceOptimized(int n) { if (n \u003c 3) { return n; // 基础情况 } int prev1 = 1, prev2 = 2, current = 0; // 初始化前两个状态 for (int i = 3; i \u003c= n; i++) { current = prev1 + prev2; // F(i) = F(i-1) + F(i-2) prev1 = prev2; // 更新状态 prev2 = current; } return prev2; // 返回最终结果 } } 斐波那契数等式：$F(n) = F(n - 1) + F(n - 2)$\n使用最小花费爬楼梯 【力扣传送门】 点击查看代码：暴力递归 暴力递归 class Solution { public int minCostClimbingStairs(int[] cost) { int n = cost.length; // 从倒数第一步或倒数第二步到达楼顶 return Math.min(minCost(cost, n - 1), minCost(cost, n - 2)); } private int minCost(int[] cost, int i) { // 基础情况：第 0 或第 1 级台阶 if (i == 0 || i == 1) { return cost[i]; } // 递归计算当前台阶的最小花费 return cost[i] + Math.min(minCost(cost, i - 1), minCost(cost, i - 2)); } } 点击查看代码：记忆化递归 记忆化递归 class Solution { public int minCostClimbingStairs(int[] cost) { int n = cost.length; int[] cache = new int[n]; Arrays.fill(cache, -1); // 从倒数第一步或倒数第二步到达楼顶 return Math.min(minCost(cost, n - 1, cache), minCost(cost, n - 2, cache)); } private int minCost(int[] cost, int i, int[] cache) { if (i \u003c 2) { return cost[i]; } // 递归计算并存储当前台阶的最小花费 if (cache[i] == -1) { cache[i] = cost[i] + Math.min(minCost(cost, i - 1, cache), minCost(cost, i - 2, cache)); } return cache[i]; } } 点击查看代码：自下而上迭代 Java class Solution { public int minCostClimbingStairs(int[] cost) { int n = cost.length; int[] cache = new int[n]; // 初始化第 0 和第 1 级台阶的花费 cache[0] = cost[0]; cache[1] = cost[1]; // 计算到达每一级台阶的最小花费 for (int i = 2; i \u003c n; i++) { cache[i] = cost[i] + Math.min(cache[i - 1], cache[i - 2]); } // 返回从倒数第一步或倒数第二步到达楼顶的最小花费 return Math.min(cache[n - 1], cache[n - 2]); } } 点击查看代码：空间优化 空间优化 class Solution { public int minCostClimbingStairs(int[] cost) { int n = cost.length; // 初始化前两个台阶的最小花费 int prev1 = cost[0], prev2 = cost[1]; // 逐步计算当前台阶的最小花费 for (int i = 2; i \u003c n; i++) { int current = cost[i] + Math.min(prev1, prev2); prev1 = prev2; prev2 = current; } // 返回从倒数第一步或倒数第二步到达楼顶的最小花费 return Math.min(prev1, prev2); } } 斐波那契数等式：$F(n) = \\min\\{\\text{cache}[n], \\text{cache}[n-1]\\}$\n打家劫舍 【力扣传送门】 点击查看代码：暴力解法 暴力解法 class Solution { public int rob(int[] nums) { int n = nums.length; // 从最后一间房屋开始计算最大收益 return robFrom(nums, n - 1); } private int robFrom(int[] nums, int i) { // 边界条件：如果索引小于 0，表示无房屋可抢，返回 0 if (i \u003c 0) { return 0; } // 选择抢当前房屋或跳过当前房屋 int robCurrent = nums[i] + robFrom(nums, i - 2); // 抢当前房屋 int robSkip = robFrom(nums, i - 1); // 跳过当前房屋 // 返回两种选择的最大值 return Math.max(robCurrent, robSkip); } } 递归树分析：\nnums = [1, 2, 3, 1] [index] --- title: 打家劫舍：递归树分析 --- graph TD L0((\"\\[3\\]\")) --\u003e|+1| L1((\"\\[1\\]\")) L0 -.-\u003e|skip| R1((\"\\[2\\]\")) L1 --\u003e|+2| L2A((\"\\[-1\\]\")) L1 -.-\u003e|skip| R2A((\"\\[0\\]\")) R1 --\u003e|+3| L2B((\"\\[0\\]\")) R1 -.-\u003e|skip| R2B((\"\\[1\\]\")) style L1 fill:blue style R2B fill:blue L2A --\u003e r1((0)) R2A --\u003e r2((1)) L2B --\u003e r3((1)) R2B --\u003e r4((2)) 点击查看代码：记忆化递归 记忆化递归 class Solution { public int rob(int[] nums) { int n = nums.length; // 初始化缓存数组，-1 表示尚未计算 int[] cache = new int[n]; Arrays.fill(cache, -1); // 从最后一间房屋开始计算最大收益 return robRecursive(nums, n - 1, cache); } private static int robRecursive(int[] nums, int i, int[] cache) { if (i \u003c 0) { return 0; } if (cache[i] == -1) { // 选择抢当前房屋或跳过当前房屋 int robCurrent = nums[i] + robRecursive(nums, i - 2, cache); int robSkip = robRecursive(nums, i - 1, cache); // 缓存结果 cache[i] = Math.max(robCurrent, robSkip); } return cache[i]; } } 点击查看代码：自下而上迭代 自下而上迭代 class Solution { public int rob(int[] nums) { int n = nums.length; // 边界条件：只有一间房屋时直接返回金额 if (n == 1) { return nums[0]; } // 初始化缓存数组 int[] cache = new int[n]; cache[0] = nums[0]; // 仅抢第一间房屋 cache[1] = Math.max(nums[0], nums[1]); // 抢第一间或第二间房屋 // 从第三间房屋开始，计算每间房屋的最大收益 for (int i = 2; i \u003c n; i++) { cache[i] = Math.max(nums[i] + cache[i - 2], cache[i - 1]); } // 返回最后一间房屋的最大收益 return cache[n - 1]; } } 点击查看代码：空间优化 空间优化 class Solution { public int rob(int[] nums) { int n = nums.length; // 边界条件：只有一间房屋时直接返回金额 if (n == 1) { return nums[0]; } // 使用两个变量滚动存储状态 int prev1 = nums[0]; // 抢第一间房屋 int prev2 = Math.max(nums[0], nums[1]); // 抢第一间或第二间房屋 for (int i = 2; i \u003c n; i++) { int current = Math.max(nums[i] + prev1, prev2); // 当前最大收益 prev1 = prev2; // 更新状态 prev2 = current; } // 返回最终的最大收益 return prev2; } } 斐波那契数等式：$F(n) = \\max\\{\\text{nums}[n] + F(n-2), F(n-1)\\}$\n0/1 背包模式 0/1 背包问题 点击查看题目 给定两个整数数组分别表示 N 个物品的重量和利润，要求找到一个物品的子集，使其总重量不超过给定的容量 C，同时获得最大利润。编写一个函数返回最大利润。每个物品只能被选择一次，也就是说，物品要么被放入背包，要么不放入。\nweights：{ 1, 2, 3 }\nprofits：{ 6, 10, 16 }\ncapacity：4\n最大利润为 6 + 16 = 22\n点击查看代码：暴力递归 暴力递归 public class Solution { public int solveKnapsack(int[] profits, int[] weights, int capacity) { return solveKnapsackRecursive(profits, weights, capacity, 0); } private int solveKnapsackRecursive(int[] profits, int[] weights, int capacity, int i) { // 基础情况：容量不足或所有物品已处理完 if (capacity \u003c 0 || i == weights.length) { return 0; } // 包含当前物品的选择 int include = 0; if (weights[i] \u003c= capacity) { include = profits[i] + solveKnapsackRecursive(profits, weights, capacity - weights[i], i + 1); } // 排除当前物品的选择 int exclude = solveKnapsackRecursive(profits, weights, capacity, i + 1); // 返回两种选择中较大的利润 return Math.max(include, exclude); } } 递归树分析\nweights = [1, 2, 3] profits = [6, 10, 16] capacity = 4 (current weight, [profits], remaining capacity) current weight 的值为 null 表示已经遍历完毕 --- title: 背包问题：递归树分析 --- graph TD L0[\"(1,[],4)\"] --\u003e|+6| L1[\"(2,[6],3)\"] L0 -.-\u003e|skip| R1[\"(2,[],4)\"] L1 --\u003e|+10| L2A[\"(3,[6,10],2)\"] L1 -.-\u003e|skip| R2A[\"(3,[6],3)\"] R1 --\u003e|+10| L2B[\"(3,[10],2)\"] R1 -.-\u003e|skip| R2B[\"(3,[],4)\"] R2A --\u003e|+16| L3B[\"(null,[6,16],0)\"] R2A -.-\u003e|skip| R3B[\"(null,[6],3)\"] R2B --\u003e|+16| L3D[\"(null,[16],1)\"] R2B -.-\u003e|skip| R3D[\"(null,[],4)\"] L3B --\u003e r1((6 \\+ 16 = 22)) style L3B fill:blue 点击查看代码：记忆化递归 记忆化递归 public class Solution { public int solveKnapsack(int[] profits, int[] weights, int capacity) { // 初始化缓存数组，用于存储子问题的结果以避免重复计算 Integer[][] cache = new Integer[weights.length][capacity + 1]; return solveKnapsackRecursive(profits, weights, capacity, 0, cache); } private int solveKnapsackRecursive(int[] profits, int[] weights, int capacity, int currentIndex, Integer[][] cache) { // 基础情况：容量不足或所有物品已处理完 if (capacity \u003c= 0 || currentIndex \u003e= weights.length) { return 0; } // 如果当前状态未计算过，则计算并缓存结果 if (cache[currentIndex][capacity] == null) { // 选择当前物品的情况 int include = 0; if (weights[currentIndex] \u003c= capacity) { include = profits[currentIndex] + solveKnapsackRecursive(profits, weights, capacity - weights[currentIndex], currentIndex + 1, cache); } // 不选择当前物品的情况 int exclude = solveKnapsackRecursive(profits, weights, capacity, currentIndex + 1, cache); // 取两种选择中的最大值并缓存结果 cache[currentIndex][capacity] = Math.max(include, exclude); } return cache[currentIndex][capacity]; } } 点击查看代码：自下而上迭代 自下而上迭代 public class Solution { public int solveKnapsack(int[] profits, int[] weights, int capacity) { if (capacity \u003c= 0) { return 0; } int n = weights.length; // cache[i][c] 表示前 i 个物品在容量 c 下的最大利润 int[][] cache = new int[n][capacity + 1]; // 初始化第一列：容量为 0 时，利润始终为 0 for (int i = 0; i \u003c n; i++) { cache[i][0] = 0; } // 初始化第一行：只考虑第一个物品 for (int c = 0; c \u003c= capacity; c++) { if (weights[0] \u003c= c) { cache[0][c] = profits[0]; } } for (int i = 1; i \u003c n; i++) { for (int c = 1; c \u003c= capacity; c++) { // 包含当前物品 int include = 0; if (weights[i] \u003c= c) { include = profits[i] + cache[i - 1][c - weights[i]]; } // 不包含当前物品 int exclude = cache[i - 1][c]; cache[i][c] = Math.max(include, exclude); } } return cache[n - 1][capacity]; } } 步骤演示：\nweights = [1, 2, 3] profits = [6, 10, 16] capacity = 4 点击查看步骤演示 填充第一列 01234 00 10 20 填充第一行 01234 006666 10 20 填充第二行 01234 006666 106101616 20 填充第三行 01234 006666 106101616 206101622 最大利润来源 01234 006666 106101616 206101622 点击查看代码：空间优化 I 空间优化 I（二维滚动数组） public class Solution { public int solveKnapsack(int[] profits, int[] weights, int capacity) { // 基本检查：容量小于等于 0 或数组为空或数组长度不一致 if (capacity \u003c= 0) { return 0; } int n = profits.length; // 滚动数组缓存，只需要两行交替存储 int[][] cache = new int[2][capacity + 1]; // 仅考虑第一个物品时的最大价值 for (int c = 0; c \u003c= capacity; c++) { if (weights[0] \u003c= c) { cache[0][c] = profits[0]; } } // 逐步计算子数组在每种容量下的最优解 for (int i = 1; i \u003c n; i++) { for (int c = 0; c \u003c= capacity; c++) { int include = 0; // 包含当前物品 int exclude = 0; // 不包含当前物品 // 如果当前物品重量不超过容量，尝试包含当前物品 if (weights[i] \u003c= c) { include = profits[i] + cache[(i - 1) % 2][c - weights[i]]; } // 不包含当前物品的情况 exclude = cache[(i - 1) % 2][c]; // 当前容量下取最大值 cache[i % 2][c] = Math.max(include, exclude); } } // 返回最后一个物品在最大容量下的最优解 return cache[(n - 1) % 2][capacity]; } } 点击查看代码：空间优化 II 空间优化 II（一维数组） public class Solution { private static int solveKnapsack(int[] profits, int[] weights, int capacity) { // If the knapsack capacity is 0 or negative, no profit can be made if (capacity \u003c= 0) { return 0; } // Initialize cache for the first item int n = profits.length; int[] cache = new int[capacity + 1]; for (int c = 0; c \u003c= capacity; c++) { if (c \u003e= weights[0]) cache[c] = profits[0]; } // Fill the cache for all remaining items (1 to n-1) for (int i = 1; i \u003c n; i++) { // Traverse the capacities in reverse to avoid reusing the same item for (int c = capacity; c \u003e= weights[i]; c--) { // Include the current item int include = profits[i] + cache[c - weights[i]]; // Exclude the current item int exclude = cache[c]; // Update cache with the maximum profit for the current capacity cache[c] = Math.max(include, exclude); } } // The last element in the cache will store the maximum profit that can be obtained with the given capacity return cache[capacity]; } } 分割等和子集 【力扣传送门】 点击查看代码：暴力递归 暴力递归 public class Solution { public boolean canPartition(int[] nums) { int sum = Arrays.stream(nums).sum(); if (sum % 2 == 1) { return false; } return canPartitionRecursive(nums, 0, sum / 2); } private static boolean canPartitionRecursive(int[] nums, int currentIndex, int target) { // 如果目标和为 0，则找到一个子集 if (target == 0) { return true; } // 如果遍历到数组末尾或目标值小于 0，则无法找到满足条件的子集 if (currentIndex == nums.length || target \u003c 0) { return false; } // 包含当前元素 boolean include = canPartitionRecursive(nums, currentIndex + 1, target - nums[currentIndex]); // 不包含当前元素 boolean exclude = canPartitionRecursive(nums, currentIndex + 1, target); // 如果包含或不包含当前元素的任一情况可以找到目标子集，则返回 true return include || exclude; } } 递归树分析：\nnums = [1, 2, 3, 4]\nsum = 1 + 2 + 3 + 4 = 10\ntarget = sum / 2 = 5\n(index, target)\n--- title: 分割等和子集：递归树分析 --- graph TD L0((\"\\(0,5\\)\")) --\u003e L1((\"\\(1,4\\)\")) L0 -.-\u003e R1((\"\\(1,5\\)\")) L1 --\u003e L2_1((\"\\(2,2\\)\")) L1 -.-\u003e R2_1((\"\\(2,4\\)\")) R1 --\u003e L2_2((\"\\(2,3\\)\")) R1 -.-\u003e R2_2((\"\\(2,5\\)\")) L2_1 --\u003e L3_1((\"\\(3,-1\\)\")) L2_1 -.-\u003e R3_1((\"\\(3,2\\)\")) R2_1 --\u003e L3_2((\"\\(3,1\\)\")) R2_1 -.-\u003e R3_2((\"\\(3,4\\)\")) R2_2 --\u003e L3_4((\"\\(3,2\\)\")) R2_2 -.-\u003e R3_4((\"\\(3,5\\)\")) R3_1 --\u003e L4_2((\"\\(4,-2\\)\")) R3_1 -.-\u003e R4_2((\"\\(4,2\\)\")) L3_2 --\u003e L4_3((\"\\(4,-3\\)\")) L3_2 -.-\u003e R4_3((\"\\(4,1\\)\")) L3_4 --\u003e L4_7((\"\\(4,-2\\)\")) L3_4 -.-\u003e R4_7((\"\\(4,2\\)\")) R3_4 --\u003e L4_8((\"\\(4,1\\)\")) R3_4 -.-\u003e R4_8((\"\\(4,5\\)\")) style L2_2 fill:lightblue,color:black style R3_2 fill:lightblue,color:black style L3_1 fill:red style L4_2 fill:red style R4_2 fill:red style R4_3 fill:red style L4_3 fill:red style R4_7 fill:red style L4_7 fill:red style R4_8 fill:red style L4_8 fill:red style L3_4 fill:purple,color:white style R3_1 fill:purple,color:white 点击查看代码：记忆化递归 记忆化递归 class Solution { public boolean canPartition(int[] nums) { // 计算数组总和 int sum = Arrays.stream(nums).sum(); // 如果总和为奇数，不可能分割成两个和相等的子集 if (sum % 2 == 1) { return false; } int target = sum / 2; // 使用缓存表记录子问题的解，避免重复计算 Boolean[][] cache = new Boolean[nums.length][target + 1]; return canPartitionRecursive(nums, 0, target, cache); } private static boolean canPartitionRecursive(int[] nums, int currentIndex, int target, Boolean[][] cache) { // 如果目标和为 0，说明找到一个子集 if (target == 0) { return true; } // 如果遍历到数组末尾或目标值小于 0，无法找到满足条件的子集 if (currentIndex == nums.length || target \u003c 0) { return false; } if (cache[currentIndex][target] == null) { // 包含当前元素 boolean include = canPartitionRecursive(nums, currentIndex + 1, target - nums[currentIndex], cache); // 不包含当前元素 boolean exclude = canPartitionRecursive(nums, currentIndex + 1, target, cache); // 缓存当前子问题的结果 cache[currentIndex][target] = include || exclude; } return cache[currentIndex][target]; } } 点击查看代码：自下向上迭代 自下而上迭代 class Solution { public boolean canPartition(int[] nums) { // 计算数组总和 int sum = Arrays.stream(nums).sum(); // 如果总和为奇数，不可能分割成两个和相等的子集 if (sum % 2 == 1) { return false; } int n = nums.length; int target = sum / 2; boolean[][] cache = new boolean[n][target + 1]; // 目标和为 0 时，无需选择任何元素，因此为 true for (int i = 0; i \u003c n; i++) { cache[i][0] = true; } // 只有第一个元素，且其值等于目标和，则为 true for (int t = 1; t \u003c= target; t++) { if (nums[0] == t) { cache[0][t] = true; } } for (int i = 1; i \u003c n; i++) { for (int t = 1; t \u003c= target; t++) { boolean include = false; // 如果当前元素小于等于目标和 t，则尝试包含该元素 if (nums[i] \u003c= t) { include = cache[i-1][t-nums[i]]; } // 不包含当前元素的情况 boolean exclude = cache[i - 1][t]; // 当前状态取包含或不包含两种情况的逻辑或 cache[i][t] = include || exclude; } } return cache[n - 1][target]; } } 点击查看代码：空间优化 I 空间优化 I（二维滚动数组） 点击查看代码：空间优化 II 空间优化 II（一维数组） class Solution { public boolean canPartition(int[] nums) { // Calculate the total sum of the array int sum = Arrays.stream(nums).sum(); // If the sum is odd, it cannot be partitioned into two equal subsets if (sum % 2 != 0) { return false; } // The target sum for one subset is half of the total sum int target = sum / 2; // DP array to track achievable sums up to the target value // cache[i] will be true if a subset with sum i is achievable boolean[] cache = new boolean[target + 1]; cache[0] = true; // A sum of 0 is always achievable (by selecting no elements) // Iterate over each number in the array for (int num : nums) { // Update the DP table from right to left to avoid using the same number multiple times for (int i = target; i \u003e= num; i--) { // If the current sum i - num was achievable, then sum i is also achievable by adding num cache[i] |= cache[i - num]; } } // The answer is whether the target sum is achievable return cache[target]; } } 最小子集和差 点击查看题目 问题描述\n给定一组正整数，将该集合划分为两个子集，使它们的子集和之间的差最小。\n示例 1：\n输入：\n{1, 2, 3, 9} 输出：\n3 解释：可以将给定集合划分为两个子集，使得它们的和之间的绝对差最小为 3。以下是两个子集：{1, 2, 3} 和 {9}。\n示例 2：\n输入：\n{1, 2, 7, 1, 5} 输出：\n0 解释：可以将给定集合划分为两个子集，使得它们的和之间的绝对差最小为 0。以下是两个子集：{1, 2, 5} 和 {7, 1}。\n示例 3：\n输入：\n{1, 3, 100, 4} 输出：\n92 解释：可以将给定集合划分为两个子集，使得它们的和之间的绝对差最小为 92。以下是两个子集：{1, 3, 4} 和 {100}。\n约束条件\n$1 \\leq n \\leq 15$ $\\text{nums.length} == 2 \\times n$ $-10^7 \\leq \\text{nums[i]} \\leq 10^7$ SHOW CODE：暴力递归 暴力解法 class Solution { public int canPartition(int[] nums) { return canPartitionRecursive(nums, 0, 0, 0); } private static int canPartitionRecursive(int[] nums, int currentIndex, int sum1, int sum2) { // 基本条件：当所有元素都被分配完时，返回两个子集和的绝对差 if (currentIndex == nums.length) { return Math.abs(sum1 - sum2); } // 选择将当前元素加入到子集1中 int include = canPartitionRecursive(nums, currentIndex + 1, sum1 + nums[currentIndex], sum2); // 选择将当前元素加入到子集2中 int exclude = canPartitionRecursive(nums, currentIndex + 1, sum1, sum2 + nums[currentIndex]); // 返回两种选择中差值的最小值 return Math.min(include, exclude); } } 递归树分析：\nnums = [1, 2, 3] (index, sum1, sum2) --- title: 最小子集和差：递归树分析 --- graph TD L0[\"\\(0,0,0\\)\"] --\u003e L1[\"\\(1,1,0\\)\"] L0 -.-\u003e R1[\"\\(1,0,1\\)\"] L1 --\u003e L2[\"\\(2,3,0\\)\"] L1 -.-\u003e R2[\"\\(2,1,2\\)\"] R1 --\u003e L3[\"\\(2,2,1\\)\"] R1 -.-\u003e R3[\"\\(2,0,3\\)\"] L2 --\u003e L4[\"\\(3,6,0\\)\"] --\u003e r1((6)) L2 -.-\u003e R4[\"\\(3,3,3\\)\"] --\u003e r2((0)) R2 --\u003e L5[\"\\(3,4,2\\)\"] --\u003e r3((2)) R2 -.-\u003e R5[\"\\(3,1,5\\)\"] --\u003e r4((4)) L3 --\u003e L6[\"\\(3,5,1\\)\"] --\u003e r5((4)) L3 -.-\u003e R6[\"\\(3,2,4\\)\"] --\u003e r6((2)) R3 --\u003e L7[\"\\(3,3,3\\)\"] --\u003e r7((0)) R3 -.-\u003e R7[\"\\(3,0,6\\)\"] --\u003e r8((6)) 点击查看代码：记忆化递归 Java import java.util.*; class Solution { public int canPartition(int[] nums) { int totalSum = Arrays.stream(nums).sum(); Integer[][] cache = new Integer[nums.length][totalSum + 1]; return this.canPartitionRecursive(nums, 0, 0, 0, cache); } private int canPartitionRecursive(int[] nums, int currentIndex, int sum1, int sum2, Integer[][] cache) { // 基础条件：如果已经处理完数组的所有元素，返回两个子集的绝对和差 if (currentIndex == nums.length) { return Math.abs(sum1 - sum2); } // 如果缓存中不存在当前子问题的结果，则计算并存入缓存 if (cache[currentIndex][sum1] == null) { // 选择将当前元素加入子集 1 int include = canPartitionRecursive(nums, currentIndex + 1, sum1 + nums[currentIndex], sum2, cache); // 选择将当前元素加入子集 2 int exclude = canPartitionRecursive(nums, currentIndex + 1, sum1, sum2 + nums[currentIndex], cache); // 取两种选择中子集和差的最小值，存入缓存 cache[currentIndex][sum1] = Math.min(include, exclude); } // 返回缓存中的结果 return cache[currentIndex][sum1]; } } 点击查看代码：自下而上迭代 自下而上迭代 import java.util.*; class Solution { public int canPartition(int[] nums) { int totalSum = Arrays.stream(nums).sum(); int n = nums.length; // cache[i][j] 表示前 i 个数是否可以组成和为 j boolean[][] cache = new boolean[n][totalSum / 2 + 1]; // 初始化：和为 0 时总能成立 for (int i = 0; i \u003c n; i++) { cache[i][0] = true; } // 初始化第一个数字的情况 for (int i = 0; i \u003c= totalSum / 2; i++) { if (nums[0] == i) { cache[0][i] = true; } } for (int i = 1; i \u003c n; i++) { for (int j = 1; j \u003c= totalSum / 2; j++) { // 选择当前数字（需确保当前数字不超过目标和） boolean include = nums[i] \u003c= j \u0026\u0026 cache[i - 1][j - nums[i]]; // 不选择当前数字 boolean exclude = cache[i - 1][j]; cache[i][j] = include || exclude; } } int sum1 = 0; // 从最后一行逆序查找最大子集和 for (int i = totalSum / 2; i \u003e= 0; i--) { if (cache[n-1][i]) { sum1 = i; break; } } int sum2 = totalSum - sum1; return Math.abs(sum1 - sum2); } } 目标和 【力扣传送门】 SHOW CODE 暴力解法 记忆化递归 class Solution { public int findTargetSumWays(int[] nums, int target) { return findTargetSumWaysRecursive(nums, target, 0, 0); } private static int findTargetSumWaysRecursive(int[] nums, int target, int sum, int i) { // 递归终止条件：如果已处理完所有数字，检查当前和是否等于目标值 if (i == nums.length) { return sum == target ? 1 : 0; } // 考虑当前数字添加 '+' 符号 int add = findTargetSumWaysRecursive(nums, target, sum + nums[i], i + 1); // 考虑当前数字添加 '-' 符号 int subtract = findTargetSumWaysRecursive(nums, target, sum - nums[i], i + 1); // 返回两种可能的结果之和 return add + subtract; } } class Solution { public int findTargetSumWays(int[] nums, int target) { Map\u0026lt;String, Integer\u0026gt; cache = new HashMap\u0026lt;\u0026gt;(); // 缓存，存储中间结果 return findTargetSumWaysRecursive(nums, target, 0, 0, cache); } private static int findTargetSumWaysRecursive(int[] nums, int target, int sum, int i, Map\u0026lt;String, Integer\u0026gt; cache) { // 递归终止条件：如果已处理完所有数字，检查当前和是否等于目标值 if (i == nums.length) { return sum == target ? 1 : 0; } // 使用当前索引和累加和作为缓存的键 String key = i + \",\" + sum; // 如果缓存中不存在当前状态的结果，进行递归计算 if (cache.get(key) == null) { // 当前数字添加 '+' 符号 int add = findTargetSumWaysRecursive(nums, target, sum + nums[i], i + 1, cache); // 当前数字添加 '-' 符号 int subtract = findTargetSumWaysRecursive(nums, target, sum - nums[i], i + 1, cache); // 将结果存入缓存 cache.put(key, add + subtract); } // 返回缓存中存储的结果 return cache.get(key); } } 递归树分析：\nnums = [1, 2, 2], target = 1 (index, sum) --- title: 目标和：递归树分析 --- graph TD A((\"\\(0,0\\)\")) --\u003e|\\+| B((\"\\(1,1\\)\")) A -.-\u003e|−| C((\"\\(1,-1\\)\")) B --\u003e|\\+| D((\"\\(2,3\\)\")) B -.-\u003e|−| E((\"\\(2,-1\\)\")) C --\u003e|\\+| F((\"\\(2,1\\)\")) C -.-\u003e|−| G((\"\\(2,-3\\)\")) D --\u003e|\\+| H((\"\\(3,5\\)\")) D -.-\u003e|−| I((\"\\(3,1\\)\")) E --\u003e|\\+| J((\"\\(3,1\\)\")) E -.-\u003e|−| K((\"\\(3,-3\\)\")) F --\u003e|\\+| L((\"\\(3,3\\)\")) F -.-\u003e|−| M((\"\\(3,-1\\)\")) G --\u003e|\\+| N((\"\\(3,-1\\)\")) G -.-\u003e|−| O((\"\\(3,-5\\)\")) style I fill:lightblue,color:black style J fill:lightblue,color:black 完全背包模式 零钱兑换 【力扣传送门】 SHOW CODE 暴力解法 记忆化递归 class Solution { public int coinChange(int[] coins, int amount) { // 调用递归函数计算最小硬币数 int result = coinChangeRecursive(coins, amount, 0); // 如果结果是Integer.MAX_VALUE（表示无解），返回-1；否则返回结果 return result == Integer.MAX_VALUE ? -1 : result; } private static int coinChangeRecursive(int[] coins, int amount, int i) { // 基本情况：如果金额为0，返回0表示不需要更多硬币 if (amount == 0) { return 0; } // 基本情况：如果硬币用完或金额为负，返回一个较大值表示无解 if (i == coins.length || amount \u003c 0) { return Integer.MAX_VALUE; } // 尝试包含当前硬币 int include = coinChangeRecursive(coins, amount - coins[i], i); // 如果包含当前硬币的结果有效（不是Integer.MAX_VALUE），加1表示使用了一个硬币 if (include != Integer.MAX_VALUE) { include += 1; } // 尝试跳过当前硬币 int exclude = coinChangeRecursive(coins, amount, i + 1); // 返回两种选择中较小的值 return Math.min(include, exclude); } } class Solution { public int coinChange(int[] coins, int amount) { // 创建缓存（哈希表）用于存储子问题的结果 Map\u0026lt;String, Integer\u0026gt; cache = new HashMap\u0026lt;\u0026gt;(); // 调用递归函数计算最小硬币数 int result = coinChangeRecursive(coins, amount, 0, cache); // 如果结果是Integer.MAX_VALUE（表示无解），返回-1；否则返回结果 return result == Integer.MAX_VALUE ? -1 : result; } private static int coinChangeRecursive(int[] coins, int amount, int i, Map\u0026lt;String, Integer\u0026gt; cache) { // 基本情况：如果金额为0，返回0表示不需要更多硬币 if (amount == 0) { return 0; } // 基本情况：如果硬币用完或金额为负，返回一个较大值表示无解 if (i == coins.length || amount \u003c 0) { return Integer.MAX_VALUE; } // 生成当前子问题的键，用于标识缓存中的结果 String key = i + \",\" + amount; // 如果当前子问题的结果不在缓存中，进行计算 if (cache.get(key) == null) { // 尝试包含当前硬币 int include = coinChangeRecursive(coins, amount - coins[i], i, cache); // 如果包含当前硬币的结果有效（不是Integer.MAX_VALUE），加1表示使用了一个硬币 if (include != Integer.MAX_VALUE) { include += 1; } // 尝试跳过当前硬币 int exclude = coinChangeRecursive(coins, amount, i + 1, cache); // 将两种选择的最小值存入缓存 cache.put(key, Math.min(include, exclude)); } // 返回缓存中存储的结果 return cache.get(key); } } 最长公共子串模式 最长公共子串长度 点击查看题目 给定两个字符串 s1 和 s2，找到它们之间最长公共子串的长度。\n示例 1：\n输入:\ns1 = \u0026quot;abdca\u0026quot;\ns2 = \u0026quot;cbda\u0026quot;\n输出: 2\n解释: 最长的公共子串是 \u0026quot;bd\u0026quot;。\n示例 2：\n输入:\ns1 = \u0026quot;passport\u0026quot;\ns2 = \u0026quot;ppsspt\u0026quot;\n输出: 3\n解释: 最长的公共子串是 \u0026quot;ssp\u0026quot;。\n限制条件：\n1 \u0026lt;= s1.length, s2.length \u0026lt;= 1000 s1 和 s2 仅由小写英文字母组成。 SHOW CODE 暴力解法 记忆化递归 自下而上 空间优化 class Solution { /** * 查找两个字符串的最长公共子串长度。 * * @param s1 字符串1 * @param s2 字符串2 * @return 最长公共子串的长度 */ public int findLCSLength(String s1, String s2) { return findLCSLengthRecursive(s1, s2, 0, 0, 0); } /** * 使用递归查找最长公共子串长度。 * * @param s1 字符串1 * @param s2 字符串2 * @param i1 s1 当前字符的索引 * @param i2 s2 当前字符的索引 * @param count 当前匹配子串的长度 * @return 最长公共子串的长度 */ private int findLCSLengthRecursive(String s1, String s2, int i1, int i2, int count) { // 基本结束条件：如果任一字符串达到末尾，返回当前匹配的长度 if (i1 \u003e= s1.length() || i2 \u003e= s2.length()) { return count; } // 如果当前字符匹配，递归计算匹配长度并更新 count int newCount = count; if (s1.charAt(i1) == s2.charAt(i2)) { newCount = findLCSLengthRecursive(s1, s2, i1 + 1, i2 + 1, count + 1); } // 跳过当前字符分别从两个方向继续递归，重置 count int skipS1 = findLCSLengthRecursive(s1, s2, i1 + 1, i2, 0); int skipS2 = findLCSLengthRecursive(s1, s2, i1, i2 + 1, 0); // 返回三者中最大的值：继续匹配、新分支1、新分支2 return Math.max(newCount, Math.max(skipS1, skipS2)); } } class Solution { public int findLCSLength(String s1, String s2) { Map\u0026lt;String, Integer\u0026gt; cache = new HashMap\u0026lt;\u0026gt;(); return findLCSLengthRecursive(s1, s2, 0, 0, 0, cache); } private int findLCSLengthRecursive(String s1, String s2, int i1, int i2, int count, Map\u0026lt;String, Integer\u0026gt; cache) { // 递归结束条件：如果任一索引超出字符串长度，返回当前匹配长度 if (i1 \u003e= s1.length() || i2 \u003e= s2.length()) { return count; } // 当前字符匹配时，递归计算匹配长度 int newCount = count; if (s1.charAt(i1) == s2.charAt(i2)) { newCount = findLCSLengthRecursive(s1, s2, i1 + 1, i2 + 1, count + 1, cache); } String key = i1 + \",\" + i2 + \",\" + count; if (cache.get(key) == null) { // 分别跳过 s1 或 s2 当前字符的递归分支，重置匹配计数 int skipS1 = findLCSLengthRecursive(s1, s2, i1 + 1, i2, 0, cache); int skipS2 = findLCSLengthRecursive(s1, s2, i1, i2 + 1, 0, cache); // 缓存结果：当前匹配长度与跳过分支的最大值 cache.put(key, Math.max(newCount, Math.max(skipS1, skipS2))); } return cache.get(key); } } class Solution { public int findLCSLength(String s1, String s2) { // dp[i][j]表示s1的前i个字符与s2的前j个字符的最长公共子串长度 int[][] dp = new int[s1.length() + 1][s2.length() + 1]; int maxLength = 0; for (int i = 1; i \u003c= s1.length(); i++) { for (int j = 1; j \u003c= s2.length(); j++) { // 如果当前字符相等，最长公共子串长度加1 if (s1.charAt(i - 1) == s2.charAt(j - 1)) { dp[i][j] = dp[i - 1][j - 1] + 1; } // else { // // 如果不相等，当前公共子串长度为0（dp[i][j]默认就是0） // dp[i][j] = 0; // } // 更新最长公共子串的长度 maxLength = Math.max(maxLength, dp[i][j]); } } return maxLength; } } class Solution { public int findLCSLength(String s1, String s2) { // dp[i][j]表示s1的前i个字符与s2的前j个字符的最长公共子串长度 int[][] dp = new int[2][s2.length() + 1]; int maxLength = 0; for (int i = 1; i \u003c= s1.length(); i++) { for (int j = 1; j \u003c= s2.length(); j++) { // 如果当前字符相等，最长公共子串长度加1 if (s1.charAt(i - 1) == s2.charAt(j - 1)) { dp[i % 2][j] = dp[(i - 1) % 2][j - 1] + 1; } else { dp[i % 2][j] = 0; } // 更新最长公共子串的长度 maxLength = Math.max(maxLength, dp[i % 2][j]); } } return maxLength; } } 递归树分析：\ns1 = \u0026quot;ab\u0026quot;, s2 = \u0026quot;cba\u0026quot; (i1, i2, count) --- title: 最长公共子串长度：递归树分析 --- graph TD L0[\"(0,0,0)\"] L0 === L1[\"❌\"] L0 --- M1[\"(1,0,0)\"] L0 -.- R1[\"(0,1,0)\"] M1 === M2L[\"❌\"] M1 --- M2M[\"(2,0,0)\"] M1 -.- M2R[\"(1,1,0)\"] R1 === R2L[\"❌\"] R1 --- R2M[\"(1,1,0)\"] R1 -.- R2R[\"(0,2,0)\"] M2R === R3L[\"(2,2,1)\"] M2R --- R3M[\"(2,1,0)\"] M2R -.- R3R[\"(1,2,0)\"] R3L --- r2[\"1\"] R3M --- r3[\"0\"] R3R --- r4[\"0\"] style R3L fill:blue style r2 fill:blue style M2R fill:green style R2M fill:green 最长公共子序列 【力扣传送门】 SHOW CODE 暴力解法 记忆化递归 class Solution { public int longestCommonSubsequence(String text1, String text2) { return findLCSRecursive(text1, text2, 0, 0); } private static int findLCSRecursive(String s1, String s2, int i1, int i2) { // 如果任一字符串已遍历完，返回0 if (i1 == s1.length() || i2 == s2.length()) { return 0; } // 如果当前字符匹配，跳过当前字符并累加1 if (s1.charAt(i1) == s2.charAt(i2)) { return 1 + findLCSRecursive(s1, s2, i1 + 1, i2 + 1); } // 否则，分别跳过s1和s2的当前字符，取两种情况的最大值 int skipS1 = findLCSRecursive(s1, s2, i1, i2 + 1); int skipS2 = findLCSRecursive(s1, s2, i1 + 1, i2); return Math.max(skipS1, skipS2); } } class Solution { public int longestCommonSubsequence(String text1, String text2) { Map\u0026lt;String, Integer\u0026gt; cache = new HashMap\u0026lt;\u0026gt;(); return findLCSRecursive(text1, text2, 0, 0, cache); } private static int findLCSRecursive(String s1, String s2, int i1, int i2, Map\u0026lt;String, Integer\u0026gt; cache) { // 如果任一字符串已遍历完，返回0 if (i1 == s1.length() || i2 == s2.length()) { return 0; } String key = i1 + \"|\" + i2; if (cache.get(key) == null) { // 如果当前字符匹配，跳过当前字符并累加1 if (s1.charAt(i1) == s2.charAt(i2)) { cache.put(key, 1 + findLCSRecursive(s1, s2, i1 + 1, i2 + 1, cache)); } else { // 否则，分别跳过s1和s2的当前字符，取两种情况的最大值 int skipS1 = findLCSRecursive(s1, s2, i1, i2 + 1, cache); int skipS2 = findLCSRecursive(s1, s2, i1 + 1, i2, cache); cache.put(key, Math.max(skipS1, skipS2)); } } return cache.get(key); } } 递归树分析：\ns1 = \u0026quot;aba\u0026quot;, s2 = \u0026quot;acb\u0026quot; (i1, i2) --- title: 递归树分析：最长公共子序列 --- graph TD L0((\"\\(0,0\\)\")) L0 ---|\"\\+1\"| L1((\"\\(1,1\\)\")) L0 --- R1[\"❌\"] L1 --- L2L((\"\\(1,2\\)\")) L1 --- L2R((\"\\(2,1\\)\")) L2L ---|\"\\+1\"| L3LL((\"\\(2,3\\)\")) L2L --- L3LR[\"❌\"] L2R --- L3RL((\"\\(3,1\\)\")) L2R --- L3RR((\"\\(2,2\\)\")) L3RR --- L4L((\"\\(3, 2\\)\")) L3RR --- L4R((\"\\(2, 3\\)\")) L3LL --- r1[0] L3RL --- r2[0] L4L --- r3[0] L4R --- r4[0] style L3LL fill:blue style L4R fill:blue 两个字符串的删除操作 【力扣传送门】 SHOW CODE 暴力解法 记忆化递归 class Solution { public int minDistance(String word1, String word2) { // 找到 word1 和 word2 的最长公共子序列（LCS）长度 int lengthOfLCS = findLCSLengthRecursive(word1, word2, 0, 0); // 删除操作次数 = word1 长度 - LCS 长度 int minDeleted = word1.length() - lengthOfLCS; // 插入操作次数 = word2 长度 - LCS 长度 int minInserted = word2.length() - lengthOfLCS; // 总操作次数为删除和插入次数之和 return minDeleted + minInserted; } private static int findLCSLengthRecursive(String word1, String word2, int i1, int i2) { if (i1 == word1.length() || i2 == word2.length()) { return 0; } // 当前字符相等，LCS 长度加 1，继续递归 if (word1.charAt(i1) == word2.charAt(i2)) { return 1 + findLCSLengthRecursive(word1, word2, i1 + 1, i2 + 1); } // 当前字符不相等，尝试跳过 word1 或 word2 的当前字符 int skipWord1 = findLCSLengthRecursive(word1, word2, i1 + 1, i2); int skipWord2 = findLCSLengthRecursive(word1, word2, i1, i2 + 1); return Math.max(skipWord1, skipWord2); } } class Solution { public int minDistance(String word1, String word2) { // 缓存用于记忆化递归，避免重复计算 Map\u0026lt;String, Integer\u0026gt; cache = new HashMap\u0026lt;\u0026gt;(); // 找到 word1 和 word2 的最长公共子序列（LCS）长度 int lengthOfLCS = findLCSLengthRecursive(word1, word2, 0, 0, cache); // 删除操作次数 = word1 长度 - LCS 长度 int minDeleted = word1.length() - lengthOfLCS; // 插入操作次数 = word2 长度 - LCS 长度 int minInserted = word2.length() - lengthOfLCS; // 总操作次数为删除和插入次数之和 return minDeleted + minInserted; } private static int findLCSLengthRecursive(String word1, String word2, int i1, int i2, Map\u0026lt;String, Integer\u0026gt; cache) { if (i1 == word1.length() || i2 == word2.length()) { return 0; } String key = i1 + \",\" + i2; // 如果缓存中没有当前子问题的结果，计算并存储 if (cache.get(key) == null) { if (word1.charAt(i1) == word2.charAt(i2)) { // 当前字符相等，LCS 长度加 1，继续递归 cache.put(key, 1 + findLCSLengthRecursive(word1, word2, i1 + 1, i2 + 1, cache)); } else { // 当前字符不相等，尝试跳过 word1 或 word2 的当前字符 int skipWord1 = findLCSLengthRecursive(word1, word2, i1 + 1, i2, cache); int skipWord2 = findLCSLengthRecursive(word1, word2, i1, i2 + 1, cache); // 取两种情况的最大值作为当前结果 cache.put(key, Math.max(skipWord1, skipWord2)); } } return cache.get(key); } } 最长递增子序列（待定） 【力扣传送门】 SHOW CODE 暴力解法 记忆化递归 无矛盾的最佳球队（待定） 【力扣传送门】 SHOW CODE 暴力解法 记忆化递归 自下而上迭代 空间优化 回文子序列模式 最长回文子序列 【力扣传送门】 SHOW CODE 暴力解法 记忆化递归 自下而上迭代 空间优化 class Solution { public int longestPalindromeSubseq(String s) { return getLPSRecursive(s, 0, s.length() - 1); } private static int getLPSRecursive(String s, int start, int end) { // 如果起始索引超过结束索引，返回0（无有效子序列） if (start \u003e end) { return 0; } // 如果起始索引等于结束索引，返回1（单个字符是回文） if (start == end) { return 1; } // 如果两端字符相等，继续递归处理中间部分，同时长度增加2 if (s.charAt(start) == s.charAt(end)) { return 2 + getLPSRecursive(s, start + 1, end - 1); } // 计算跳过起始字符或结束字符的两种情况的最大值 int skipStart = getLPSRecursive(s, start + 1, end); int skipEnd = getLPSRecursive(s, start, end - 1); return Math.max(skipStart, skipEnd); } } 最长回文子串 【力扣传送门】 SHOW CODE 暴力解法 记忆化递归 自下而上迭代 空间优化 回文子串 【力扣传送门】 SHOW CODE 暴力解法 记忆化递归 自下而上迭代 空间优化 Huawei OD 玩牌高手【100分】 SHOW PROBLEM 一、题目描述\n给定一个长度为 n 的整型数组，表示选手在 n 轮内可选择的牌面分数。选手需要基于以下规则选牌，请计算在所有轮结束后，选手可以获得的最高总分数。\n选择规则如下：\n在每一轮，选手可以选择获取该轮牌面分数，则其总分数加上该轮的分数，更新为新的总分数； 选手也可以跳过当前轮牌面，直接进入下一轮。如果选择跳过，则当前总分数恢复为三轮前的总分数。如果当前轮次小于等于3（即在第1、2、3轮选择跳过），则总分数置为0； 选手的初始总分数为0，并且必须依次参加每一轮。 二、输入描述\n第一行输入一个由逗号分隔的字符串，表示每轮的牌面分数。1 \u0026lt;= n \u0026lt;= 20。 每个分数为整数，范围是 -100 \u0026lt;= 分数值 \u0026lt;= 100。 三、输出描述\n输出选手在所有轮结束后获得的最高总分数。\n四、输入输出示例\n输入：\n2,-3,-7,4,3,4,-2,-7 输出：\n7 说明\n轮次 1：选手选择分数 2，总分 = 2。 轮次 2：选择分数 -3，当前总分为 2 + (-3) = -1；如果跳过当前轮，则总分数为 0（因为跳过前三轮总分归0）。 轮次 3：选择分数 -7，当前总分为 -1 + (-7) = -8；若跳过，则总分数为 0。 轮次 4：选择分数 4，总分为 0 + 4 = 4。 轮次 5：选择分数 3，总分为 4 + 3 = 7。 轮次 6：选择分数 4，总分为 7 + 4 = 11。 轮次 7：选择分数 -2，总分为 11 + (-2) = 9。如果选择跳过此轮，则恢复为三轮前的总分数 7，9 大于 7，因此不跳过。 轮次 8：选择分数 -7，总分为 9 + (-7) = 2。如果选择跳过，则恢复为三轮前的总分数 7，7 大于 2，因此跳过此轮。 最终输出为 7。\nSHOW CODE Java import java.util.*; /** * @author Signal Yu * @since 2024-11-30 */ public class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 输入并转换为整数数组 int[] scores = Arrays.stream(in.nextLine().trim().split(\",\")) .mapToInt(Integer::parseInt) .toArray(); // 获取结果并输出 int result = getMaximumScore(scores); System.out.println(result); } private static int getMaximumScore(int[] scores) { int n = scores.length; // dp数组，用于存储每轮结束后的最大得分 int[] dp = new int[n + 1]; dp[0] = 0; // 初始化总分为0 // 动态规划，遍历每一轮 for (int i = 1; i \u003c= n; i++) { // 选当前轮的牌面分数 int current = dp[i - 1] + scores[i - 1]; // 如果当前轮次小于等于3，跳过则总分归零 if (i \u003c= 3) { dp[i] = Math.max(current, 0); } else { // 如果轮次大于3，可以选择跳过该轮 dp[i] = Math.max(current, dp[i - 3]); } } return dp[n]; // 返回最后的最大总分 } } 跳格子2【100分】\u0026ndash; Divide \u0026amp; Conquer SHOW PROBLEM 一、题目描述\n小明和朋友玩跳格子游戏，游戏中有 n 个连续的格子组成一个圆圈，每个格子上有不同的得分。小朋友可以选择从任意格子开始跳跃，但必须遵循以下规则：\n不能跳到连续的格子； 不能回头跳； 不能跨越一圈。 给定一个表示每个格子得分的非负整数数组，计算在遵循规则的前提下，能够获得的最高分数。\n二、输入描述\n输入一个非负整数数组，表示每个格子的得分，其中数组的第一个格子和最后一个格子首尾相连。\n例如，输入：[2, 3, 2] 表示有 3 个格子，得分分别为 2、3 和 2。\n三、输出描述\n输出能够获得的最高得分。\n四、测试用例\n输入1：\n[2, 3, 2] 输出1：\n3 解释：\n不能从第一个格子跳到第三个格子，因为第一个格子和最后一个格子首尾相连，不满足题中要求的不能超过一圈。 输入2：\n[1, 2, 9, 4, 5] 输出2：\n15 解释：\n小朋友可以选择从第 1 个格子（得分为 1）跳到第 3 个格子（得分为 9），然后跳到第 5 个格子（得分为 5），获得的总分为 1 + 9 + 5 = 15。 SHOW CODE Java import java.util.*; /** * @author Signal Yu * @since 2024-11-30 */ public class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); int[] scores = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); // Calculate maximum score int result = getMaxScore(scores); // Output the result System.out.println(result); } private static int getMaxScore(int[] scores) { int n = scores.length; // Case 1: Including the first cell but excluding the last cell int score1 = calculateScore(scores, 0, n - 2); // Case 2: Excluding the first cell but including the last cell int score2 = calculateScore(scores, 1, n - 1); // Return the maximum of the two cases return Math.max(score1, score2); } private static int calculateScore(int[] scores, int start, int end) { int n = end - start + 1; if (n == 1) { return scores[0]; } int[] dp = new int[n]; // Initialization: The first cell is the score of the start position dp[0] = scores[start]; // The second cell is the maximum of the first and second grid cells dp[1] = Math.max(scores[start], scores[start + 1]); // For each subsequent cell, either take it or skip it for (int i = 2; i \u003c n; i++) { // Include the current cell int include = scores[start + i] + dp[i - 2]; // Exclude the current cell int exclude = dp[i - 1]; dp[i] = Math.max(include, exclude); } // Return the maximum score that can be obtained up to the end index return dp[n - 1]; } } 猴子爬山【100分】 SHOW PROBLEM 一、题目描述\n一天，一只顽皮的猴子想从山脚爬到山顶，途中需要经过一个有N个台阶的阶梯。然而，这只猴子有一个习惯：每次跳跃时，它只能选择跳1步或3步。请你计算，猴子有多少种不同的方式能够跳上这个阶梯？\n二、输入描述\n输入一个整数N $(0 \u0026lt; N \\le 50)$，表示阶梯的台阶数。\n三、输出描述\n输出一个整数，表示猴子跳上这个阶梯的不同跳跃方式的数量。\nSHOW CODE: Brute Force Brute Force import java.util.*; public class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); int n = Integer.parseInt(in.nextLine().trim()); int result = climbMountain(n); System.out.println(result); } private static int climbMountain(int n) { if (n \u003c 0) { return 0; } if (n \u003c 3) { return 1; } if (n == 3) { return 2; } return climbMountain(n - 1) + climbMountain(n - 3); } } SHOW CODE: Memoization Memoiztion import java.util.*; /** * @author Signal Yu * @since 2024-12-1 */ public class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); int n = Integer.parseInt(in.nextLine().trim()); int[] cache = new int[n + 1]; int result = climbMountain(n, cache); System.out.println(result); } private static int climbMountain(int n, int[] cache) { if (n \u003c 0) { return 0; } if (n \u003c 3) { return 1; } if (n == 3) { return 2; } if (cache[n] == 0) { cache[n] = climbMountain(n - 1, cache) + climbMountain(n - 3, cache); } return cache[n]; } } SHOW CODE: Bottom-Up Bottom Up Please optimize the following code: import java.util.Scanner; /** * @author Signal Yu * @since 2024-12-1 */ public class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); int n = Integer.parseInt(in.nextLine().trim()); int result = climbMountain(n); System.out.println(result); } private static int climbMountain(int n) { if (n \u003c= 0) { return 0; } if (n \u003c 3) { return 1; } int[] cache = new int[n]; cache[0] = 1; cache[1] = 1; cache[2] = 2; for (int i = 3; i \u003c n; i++) { cache[i] = cache[i - 1] + cache[i - 3]; } return cache[n - 1]; } } SHOW CODE: Space Optimization Space Optimization import java.util.Scanner; /** * @author Signal Yu * @since 2024-12-1 */ public class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); int n = Integer.parseInt(in.nextLine().trim()); int result = climbMountain(n); System.out.println(result); } private static int climbMountain(int n) { if (n \u003c= 0) { return 0; } if (n \u003c 3) { return 1; } int prev1 = 1, prev2 = 1, prev3 = 2; for (int i = 3; i \u003c n; i++) { int current = prev1 + prev3; prev1 = prev2; prev2 = prev3; prev3 = current; } return prev3; } } 查找重复代码【100分】 SHOW PROBLEM 一、题目描述\n小明负责维护项目中的代码，他需要查找并优化重复的代码。请你帮助小明找到两行代码中的最长公共子串。如果没有公共子串，返回空字符串。\n二、输入描述\n输入两行代码，每行以字符串形式给出。\n三、输出描述\n输出两行代码中的最长公共子串。如果没有公共子串，输出空字符串。\nSHOW CODE Java 延伸：返回多个最大公共子串 import java.util.Scanner; /** * @author Signal Yu * @since 2024-12-2 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); String s1 = in.nextLine().trim(); String s2 = in.nextLine().trim(); String result = getLCS(s1, s2); System.out.println(result); } private static String getLCS(String s1, String s2) { // dp[i][j]表示s1的前i个字符和s2的前j个字符的最长公共子串长度 int[][] dp = new int[2][s2.length() + 1]; int maxLength = 0; // 最长公共子串的长度 int endIndex = 0; // 记录最长公共子串的结束位置 for (int i = 1; i \u003c= s1.length(); i++) { for (int j = 1; j \u003c= s2.length(); j++) { if (s1.charAt(i - 1) == s2.charAt(j - 1)) { dp[i % 2][j] = dp[(i - 1) % 2][j - 1] + 1; if (dp[i % 2][j] \u003e maxLength) { maxLength = dp[i % 2][j]; endIndex = i; // 更新最长公共子串的结束位置 } } else { // 不匹配则当前公共子串长度为0 dp[i % 2][j] = 0; } } } return maxLength == 0 ? \"\" : s1.substring(endIndex - maxLength, endIndex); } } import java.util.*; /** * @author Signal Yu * @since 2024-12-2 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); String s1 = in.nextLine().trim(); String s2 = in.nextLine().trim(); List result = getLCS(s1, s2); System.out.println(result); } private static List\u0026lt;String\u0026gt; getLCS(String s1, String s2) { // dp[i][j]表示s1的前i个字符和s2的前j个字符的最长公共子串长度 int[][] dp = new int[2][s2.length() + 1]; List\u0026lt;String\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); int maxLength = 0; // 最长公共子串的长度 for (int i = 1; i \u003c= s1.length(); i++) { for (int j = 1; j \u003c= s2.length(); j++) { if (s1.charAt(i - 1) == s2.charAt(j - 1)) { dp[i % 2][j] = dp[(i - 1) % 2][j - 1] + 1; if (dp[i % 2][j] \u003e maxLength) { maxLength = dp[i % 2][j]; result.clear(); result.add(s1.substring(i - maxLength, i)); } else if (dp[i % 2][j] == maxLength) { result.add(s1.substring(i - maxLength, i)); } } else { // 不匹配则当前公共子串长度为0 dp[i % 2][j] = 0; } } } return result; } } 最多获得的短信条数【100分】\u0026ndash;0/1背包问题 SHOW PROBLEM 一、题目描述\n某云短信厂商为庆祝国庆推出充值优惠活动。给定客户的预算和不同金额的充值优惠方案，求客户在预算范围内最多可获得的短信条数。\n二、输入描述\n第一行：客户预算 $M$（$0 \\leq M \\leq 10^6$）。 第二行：售价表，包含 $n$ 个整数 $P_1, P_2, \\dots, P_n$，表示每种充值金额对应的短信条数（$1 \\leq n \\leq 100$，$1 \\leq P_i \\leq 1000$）。 三、输出描述\n输出客户在预算范围内最多可获得的短信条数。\nSHOW CODE Java import java.util.*; /** * @author Signal Yu * @since 2024-12-2 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); int budget = Integer.parseInt(in.nextLine().trim()); int[] prices = Arrays.stream(in.nextLine().trim().split(\",\")) .mapToInt(Integer::parseInt) .toArray(); int result = getMaximumMessages(prices, budget, 0, 0); System.out.println(result); } private static int getMaximumMessages(int[] prices, int budget, int index, int count) { if (index == prices.length) { return count; } int include = count; if (budget \u003e= index + 1) { include = getMaximumMessages(prices, budget - index - 1, index + 1, count + prices[index]); } int exclude = getMaximumMessages(prices, budget, index + 1, count); return Math.max(include, exclude); } } 广度优先搜索 102. Binary Tree Level Order Traversal Go to Leetcode 🔗 SHOW CODE Java /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); if (root == null) { return result; } Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(root); while (!queue.isEmpty()) { int levelSize = queue.size(); List\u0026lt;Integer\u0026gt; currentLevel = new ArrayList\u0026lt;\u0026gt;(levelSize); // Process all nodes in the current level for (int i = 0; i \u003c levelSize; i++) { TreeNode node = queue.poll(); currentLevel.add(node.val); // Add children to the queue if they exist if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } } result.add(currentLevel); } return result; } } 107. Binary Tree Level Order Traversal II Go to Leetcode 🔗 SHOW CODE Java /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrderBottom(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new LinkedList\u0026lt;\u0026gt;(); if (root == null) { return result; } Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.add(root); while (!queue.isEmpty()) { int levelSize = queue.size(); List\u0026lt;Integer\u0026gt; currentLevel = new ArrayList\u0026lt;\u0026gt;(levelSize); // Process all nodes at the current level for (int i = 0; i \u003c levelSize; i++) { TreeNode node = queue.poll(); currentLevel.add(node.val); // Add children to the queue if they exist if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } } // Add the current level at the begining result.add(0, currentLevel); } return result; } } 103. Binary Tree Zigzag Level Order Traversal Go to Leetcode 🔗 SHOW CODE Java /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; zigzagLevelOrder(TreeNode root) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); if (root == null) { return result; } Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(root); int level = 0; // Tracks the current level number while (!queue.isEmpty()) { int levelSize = queue.size(); List\u0026ltInteger\u0026gt; currentLevel = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u003c levelSize; i++) { TreeNode node = queue.poll(); // Add the node reversely if at the odd level if (level % 2 == 1) { currentLevel.add(0, node.val); } else { currentLevel.add(node.val); } // Add children to the queue if they are exist if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } } result.add(currentLevel); level++; } return result; } } 637. Average of Levels in Binary Tree Go to Leetcode 🔗 SHOW CODE Java /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List\u0026lt;Double\u0026gt; averageOfLevels(TreeNode root) { List\u0026lt;Double\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(root); while (!queue.isEmpty()) { int levelSize = queue.size(); long levelSum = 0L; // Process all nodes at the current level for (int i = 0; i \u003c levelSize; i++) { TreeNode node = queue.poll(); levelSum += node.val; // Add children to the queue if they exist if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } } // Add the current level's average to the result result.add((double) levelSum / levelSize); } return result; } } 111. Minimum Depth of Binary Tree Go to Leetcode 🔗 SHOW CODE Java /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int minDepth(TreeNode root) { if (root == null) { return 0; } Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(root); int minTreeDepth = 0; whileLoop: while (!queue.isEmpty()) { minTreeDepth++; int levelSize = queue.size(); // Process all nodes at the current level for (int i = 0; i \u003c levelSize; i++) { TreeNode node = queue.poll(); // Found the minimum depth if both child are null if (node.left == null \u0026\u0026 node.right == null) { break whileLoop; } // Add children to the queue if they exist if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } } } return minTreeDepth; } } 104. Maximum Depth of Binary Tree Go to Leetcode 🔗 SHOW CODE Java /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int maxDepth(TreeNode root) { if (root == null) { return 0; } Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(root); int depth = 0; while (!queue.isEmpty()) { depth++; int levelSize = queue.size(); // Process all nodes at the current level for (int i = 0; i \u003c levelSize; i++) { TreeNode node = queue.poll(); // Add children to the queue if they exist if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } } } return depth; } } 116. Populating Next Right Pointers in Each Node Go to Leetcode 🔗 SHOW CODE Java /* // Definition for a Node. class Node { public int val; public Node left; public Node right; public Node next; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, Node _left, Node _right, Node _next) { val = _val; left = _left; right = _right; next = _next; } }; */ class Solution { public Node connect(Node root) { if (root == null) { return root; } Queue\u0026lt;Node\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(root); while (!queue.isEmpty()) { int levelSize = queue.size(); // Process all nodes at the current level for (int i = 0; i \u003c levelSize; i++) { Node node = queue.poll(); // The last node at the current level points to null if (i == levelSize - 1) { node.next = null; } else { node.next = queue.peek(); } // Add children to the queue if they exist if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } } } return root; } } 199. Binary Tree Right Side View Go to Leetcode 🔗 SHOW CODE Java /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List\u0026ltInteger\u0026gt; rightSideView(TreeNode root) { List\u0026ltInteger\u0026gt; result = new ArrayList\u0026lt\u0026gt;(); if (root == null) { return result; } Queue\u0026ltTreeNode\u0026gt; queue = new LinkedList\u0026lt\u0026gt;(); queue.offer(root); while (!queue.isEmpty()) { int levelSize = queue.size(); // Process all nodes at the current level for (int i = 0; i \u003c levelSize; i++) { TreeNode node = queue.poll(); // Found the rightmost node at the current level if (i == levelSize - 1) { result.add(node.val); } // Add children to the queue if they exist if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } } } return result; } } Huawei OD 最长广播效应【200分】 SHOW PROBLEM 一、题目描述\n在某通信网络中，有N个网络结点，结点的编号为1到N。网络中的结点之间是互联互通的，且每条连接的时延为一个时间单位。现给定一个网络结点的连接关系link = {u, v}，其中u和v表示两个相连的网络结点。\n当指定一个结点向其他结点进行广播时，所有被广播的结点在接收到消息后会在原路径上回复一条响应消息。请计算发送广播的结点，至少需要等待多少时间单位才能收到所有被广播结点的响应消息。\n注：\n网络结点的数量N的取值范围为[1, 100]； 连接关系link的长度不超过3000，且1 \u0026lt;= u, v \u0026lt;= N； 网络中任意结点之间都是可达的。 二、输入描述\n输入的第一行包含两个正整数，分别表示网络结点的个数N，以及时延列表的长度T。 接下来的T行输入，表示结点之间的连接关系。每行包含两个整数u和v，表示结点u与结点v之间存在一条连接。 最后一行输入一个正整数，表示指定的广播结点的编号。 三、输出描述\n输出一个整数，表示发送结点接收到所有响应消息至少需要等待的时长。即广播结点到其他所有结点的最短路径时延的最大值。\n四、测试用例\n测试用例1：\n输入：\n5 7 1 4 2 1 2 3 2 4 3 4 3 5 4 5 2 输出：\n4 说明：\n离节点 2 最远的点为 4 或 5，距离为 2，所需时间为 $2 \\times 2 = 4s$。\n测试用例2：\n输入：\n3 2 1 2 2 3 1 输出：\n4 说明：\n离节点 1 最远的点为 3，距离为 2，所需时间为 $2 \\times 2 = 4s$。\n测试用例3：\n输入：\n3 2 1 2 2 3 2 输出：\n2 说明：\n离节点 1 最远的点为 1 或 3，距离为 1，所需时间为 $2 \\times 1 = 2s$。\nSHOW CODE Java import java.util.*; /** * @author Signal Yu * @since 2024-11-27 */ public class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); int[] parts = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); int n = parts[0]; int edgeCount = parts[1]; int[][] edges = new int[edgeCount][2]; for (int i = 0; i \u003c edgeCount; i++) { int[] edge = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); edges[i] = new int[]{edge[0] - 1, edge[1] - 1}; } int start = Integer.parseInt(in.nextLine().trim()) - 1; // Convert to 0-based index // Construct the graph List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph = constructGraph(edges, n); // Calculate shortest time int result = findMaxBroadcastTime(graph, start); System.out.println(result); } private static int findMaxBroadcastTime(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph, int start) { int[] distance = new int[graph.size()]; Arrays.fill(distance, -1); // -1 indicates unvisited nodes Queue queue = new LinkedList\u0026lt;\u0026gt;(); distance[start] = 0; // Distance to itself is 0 queue.offer(start); // Perform BFS to find the shortest path from the start node to all other nodes while (!queue.isEmpty()) { int node = queue.poll(); List neighbors = graph.get(node); for (int neighbor : neighbors) { if (distance[neighbor] == -1) { // If the neighbor hasn't been visited distance[neighbor] = distance[node] + 1; queue.offer(neighbor); } } } // Multiply by 2 for round-trip time return 2 * Arrays.stream(distance).max().orElse(0); } private static List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; constructGraph(int[][] edges, int n) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(n); for (int i = 0; i \u003c n; i++) { // 0-based index graph.add(new ArrayList\u0026lt;\u0026gt;()); } for (int[] edge : edges) { graph.get(edge[0]).add(edge[1]); graph.get(edge[1]).add(edge[0]); } return graph; } } 深度优先搜索 112. Path Sum Go to Leetcode 🔗 SHOW CODE Java /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean hasPathSum(TreeNode root, int targetSum) { // Return false if the tree is empty if (root == null) { return false; } // Return true if current node is a leaf node and its value equals to remaining target sum if (root.left == null \u0026\u0026 root.right == null) { return targetSum == root.val; } // Perform recursive calls for the left and right subtrees with updated target sum return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val); } } 257. Binary Tree Paths Go to Leetcode 🔗 SHOW CODE Java /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List\u0026ltString\u0026gt; binaryTreePaths(TreeNode root) { List\u0026ltString\u0026gt; allPaths = new ArrayList\u0026lt;\u0026gt;(); findPathsRecursive(root, allPaths, \"\"); return allPaths; } private static void findPathsRecursive(TreeNode node, List\u0026ltString\u0026gt; allPaths, String currentPath) { if (node == null) { return; } // Add the current node value to the path currentPath += node.val; // Check if the current node is a leaf node if (node.left == null \u0026\u0026 node.right == null) { allPaths.add(currentPath); } else { currentPath += \"-\u003e\"; // Traverse the left and the right subtree findPathsRecursive(node.left, allPaths, currentPath); findPathsRecursive(node.right, allPaths, currentPath); } } } 129. Sum Root to Leaf Numbers Go to Leetcode 🔗 SHOW CODE Java /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int sumNumbers(TreeNode root) { return calculateSum(root, 0); } private static int calculateSum(TreeNode node, int currentSum) { if (node == null) { return 0; } currentSum = currentSum * 10 + node.val; // Check if it's a leaf node if (node.left == null \u0026\u0026 node.right == null) { return currentSum; } // Traverse the left subtree int leftSum = calculateSum(node.left, currentSum); int rightSum = calculateSum(node.right, currentSum); return leftSum + rightSum; } } 1971. Find if Path Exists in Graph Go to Leetcode 🔗 SHOW CODE Java class Solution { public boolean validPath(int n, int[][] edges, int source, int destination) { // Initialize the adjacency list representation of the graph List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u003c n; i++) { graph.add(new ArrayList\u0026lt;\u0026gt;()); } // Populate the adjacency list with the edges for (int[] edge : edges) { graph.get(edge[0]).add(edge[1]); graph.get(edge[1]).add(edge[0]); } // Array to track visited nodes boolean[] visited = new boolean[n]; // Perform a DFS to check if a path exists return dfs(graph, visited, source, destination); } private static boolean dfs(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; graph, boolean[] visited, int source, int destination) { // Base case: If the source and destination are the same, a path exists if (source == destination) { return true; } // Mark the current node as visited visited[source] = true; // Explore all unvisited nodes List neighbors = graph.get(source); for (int neighbor : neighbors) { if (!visited[neighbor] \u0026\u0026 dfs(graph, visited, neighbor, destination)) { return true; } } // No path found from this node return false; } } 华为 OD 文件目录大小【100分】 SHOW PROBLEM 一、题目描述\n文件系统以如下格式表示目录数据：\n目录id 本目录中文件大小（子目录id列表）\n目录id：全局唯一，取值范围为 1-200； 本目录中文件大小：取值范围为 1-1000； 子目录id列表：包含 0-10 个子目录的 id，以逗号分隔。 例如：\n1 20 (2,3) 表示目录 id 为 1，其中文件大小为 20，且包含两个子目录，id 分别为 2 和 3。\n现给定文件系统中所有目录的信息以及待查询的目录 id，计算该目录及其所有子目录的文件大小之和。\n二、输入描述\n第一行：两个整数 M 和 N，分别表示目录的个数和待查询的目录 id： 1 \u0026lt;= M \u0026lt;= 100 1 \u0026lt;= N \u0026lt;= 200 接下来的 M 行：每行为一个目录的数据，格式为： 目录id 本目录中文件大小（子目录id列表） 子目录列表中的 id 以逗号分隔，若无子目录，则表示为空括号 ()。 三、输出描述\n输出待查询目录及其所有子目录的文件大小之和。\n四、输入输出示例\n输入示例：\n3 1 1 10 (2) 2 20 (3) 3 30 () 输出示例：\n60 示例说明：\n系统包含 3 个目录： 目录 1 的文件大小为 10，其子目录 id 为 2； 目录 2 的文件大小为 20，其子目录 id 为 3； 目录 3 的文件大小为 30，无子目录。 待查询的目录为 1： 目录 1 的文件大小为 10； 子目录 2 的文件大小为 20； 子目录 3 的文件大小为 30。 大小之和为：10 + 20 + 30 = 60。 五、约束条件\n输入保证是合法的，不会出现循环引用或无效目录。 目录列表中所有 id 保证唯一。 SHOW CODE Java import java.util.*; /** * @author Signal Yu * @since 2024-11-26 */ public class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // Parse input for number of directories and the target directory ID int[] nums = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); int m = nums[0]; int n = nums[1]; // Construct the directory map Map\u0026lt;Integer, Directory\u0026gt; directoryMap = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u003c m; i++) { String[] parts = in.nextLine().trim().split(\" \"); int id = Integer.parseInt(parts[0]); int size = Integer.parseInt(parts[1]); String subDirs = parts[2].replaceAll(\"[()]\", \"\"); List\u0026lt;Integer\u0026gt; subDirList = new ArrayList\u0026lt;\u0026gt;(); if (!subDirs.isEmpty()) { for (String c : subDirs.split(\",\")) { subDirList.add(Integer.parseInt(c)); } } directoryMap.put(id, new Directory(id, size, subDirList)); } // Compute and output the total size for the target directory int totalSize = calculateTotalSize(n, directoryMap); System.out.println(totalSize); } private static int calculateTotalSize(int id, Map\u0026lt;Integer, Directory\u0026gt; directoryMap) { Directory dir = directoryMap.get(id); if (dir == null) { return 0; } int totalSize = dir.size; // Sum the size of the current directory and its subdirectories for (int subId : dir.subDirList) { totalSize += calculateTotalSize(subId, directoryMap); } return totalSize; } } class Directory { int id; int size; List\u0026lt;Integer\u0026gt; subDirList; public Directory(int id, int size, List\u0026lt;Integer\u0026gt; subDirList) { this.id = id; this.size = size; this.subDirList = subDirList; } } 悄悄话【100分】 SHOW PROBLEM 题目描述：\n给定一个二叉树，每个节点上站着一个人，节点的数字表示从父节点到该节点传递悄悄话所需的时间。初始时，根节点所在位置的人有一个悄悄话想要传递给其他所有节点的人，求传递完毕、所有节点上的人都接收到悄悄话所需的最大时间。\n输入描述：\n输入包含二叉树的表示： 每个节点的值表示从父节点到该节点的传递时间； -1表示空节点。 例如，输入：0 9 20 -1 -1 15 7 -1 -1 -1 -1 3 2 -1 -1\n输出描述：\n输出为所有节点都收到悄悄话所花费的时间。 测试用例1： 输入：\n0 1 2 -1 -1 3 4 -1 -1 -1 -1 输出：\n6 说明：\n根节点到叶节点最大和为 $0 + 2 + 4 = 6$\n测试用例2：\n输入：\n0 1 2 3 4 5 6 -1 -1 -1 -1 -1 -1 -1 -1 输出：\n8 说明：\n根节点到叶节点最大和为 $0 + 2 + 6 = 8$\n示例3：\n输入：\n0 9 20 -1 -1 15 7 -1 -1 -1 -1 3 2 -1 -1 输出：\n38 说明：\n根节点到叶节点最大和为 $0 + 20 + 15 + 3 = 38$\nSHOW CODE Java import java.util.Arrays; import java.util.Scanner; /** * @author Signal Yu * @since 2024-11-27 */ public class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); int[] nodes = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); int result = findMaxPathSumDFS(nodes, 0); System.out.println(result); } private static int findMaxPathSumDFS(int[] tree, int index) { // If the index is out of bounds or the node is null if (index \u003e= tree.length || tree[index] == -1) { return 0; } // Time at the current node int currentTime = tree[index]; // Recursively calculate the time for the left and right children int leftChildTime = findMaxPathSumDFS(tree, 2 * index + 1); int rightChildTime = findMaxPathSumDFS(tree, 2 * index + 2); // Return the maximum time between left and right child paths, adding the current node's time return currentTime + Math.max(leftChildTime, rightChildTime); } } 回溯 113. Path Sum II Go to Leetcode 🔗 SHOW CODE Java /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List\u0026ltList\u0026lt;Integer\u0026gt;\u0026gt; pathSum(TreeNode root, int targetSum) { List\u0026ltList\u0026lt;Integer\u0026gt;\u0026gt; requiredPaths = new ArrayList\u0026lt\u0026gt;(); List\u0026ltInteger\u0026gt; currentPath = new ArrayList\u0026lt\u0026gt;(); // Find required paths recursively findPathsRecursive(root, targetSum, requiredPaths, currentPath); return requiredPaths; } private static void findPathsRecursive(TreeNode node, int targetSum, List\u0026ltList\u0026lt;Integer\u0026gt;\u0026gt; requiredPaths, List\u0026ltInteger\u0026gt; currentPath) { if (node == null) { return; } // Add the current node value to the path currentPath.add(node.val); // Check if this is a leaf node and its value matches the remaining target sum if (node.left == null \u0026\u0026 node.right == null \u0026\u0026 node.val == targetSum) { requiredPaths.add(new ArrayList\u0026lt\u0026gt;(currentPath)); } else { // Traverse the left subtree findPathsRecursive(node.left, targetSum - node.val, requiredPaths, currentPath); // Traverse the right subtree findPathsRecursive(node.right, targetSum - node.val, requiredPaths, currentPath); } // Backtrack to explore other paths currentPath.remove(currentPath.size() - 1); } } 437. Path Sum III Go to Leetcode 🔗 SHOW CODE Java /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int pathSum(TreeNode root, int targetSum) { HashMap\u0026lt;Long, Integer\u0026gt; prefixSumMap = new HashMap\u0026lt;\u0026gt;(); // Base case: a path with current sum matches target sum exitst at the root prefixSumMap.put(0L, 1); return pathSumRecursive(root, 0, targetSum, prefixSumMap); } private static int pathSumRecursive(TreeNode node, long currentSum, int targetSum, Map\u0026lt;Long, Integer\u0026gt; prefixSumMap) { if (node == null) { return 0; } // Update the current sum currentSum += node.val; // Calculate the number of valid paths ending at this node int pathCount = prefixSumMap.getOrDefault(currentSum - targetSum, 0); // Add the current sum to the map prefixSumMap.put(currentSum, prefixSumMap.getOrDefault(currentSum, 0) + 1); // Recur for left and right sub-trees pathCount += pathSumRecursive(node.left, currentSum, targetSum, prefixSumMap); pathCount += pathSumRecursive(node.right, currentSum, targetSum, prefixSumMap); // Remove the current path sum to backtrack prefixSumMap.put(currentSum, prefixSumMap.get(currentSum) - 1); return pathCount; } } 39. Combination Sum Go to Leetcode 🔗 SHOW CODE Java /** * This Program uses the backtracking technique to find all unique combinations * where the sum equals to the target. * * @author Signal Yu * @since 2024-11-25 */ class Solution { /** * Finds combinations of numbers that sum to the target value. * * @param candidates Array of candidate numbers. * @param target Target sum to achieve. * @return A list of all unique combinations where the sum of numbers equals the target. */ public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum(int[] candidates, int target) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); backtrack(candidates, target, 0, new ArrayList\u0026lt;\u0026gt;(), result); return result; } /** * Helper method for backtracking to find valid combinations. * * @param candidates Array of candidate numbers. * @param target Remaining target sum to achieve. * @param start Starting index for exploration to avoid duplicates. * @param combination Current combination being explored. * @param result List to store all valid combinations. */ private static void backtrack(int[] candidates, int target, int start, List\u0026lt;Integer\u0026gt; combination, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result) { // Found a combination if the remaining target matches 0 if (target == 0) { result.add(combination); return; } // Iterate over the candidates array to find the combination for (int i = start; i \u003c candidates.length; i++) { // Skip the candidate greater than the remaining target if (candidates[i] \u003e target) { continue; } // Add the current element to the combination array combination.add(candidates[i]); // Recur with the updated combination array and the remaining target backtrack(candidates, target - candidates[i], i, combination, result); // Backtrack to explore other possibilities combination.remove(combination.size() - 1); } } } 项目规划【100分】 SHOW PROBLEM 一、题目描述\nH公司正在进行项目规划，目前有3个团队（前端、后端、测试）需要共同完成M个项目。每个团队有固定的人力总和（单位：人月）。每个项目的特点如下：\n每个项目需要多个团队投入不同数量的人力。 每个项目具有一个预估价值（单位：万元）。 你的任务是帮助公司进行项目规划，在团队人力允许的情况下，选择一组项目使其预估价值总和最大化。\n如果无法承接任何项目，则返回0。\n二、输入描述\n项目数量：$M;(0 \u0026lt; M \\le 20)$。 三个团队的人力总和：$S_1，S_2，S_3;(0 \u0026lt; S_i \\le 1000);$。 每个项目的预估价值：$V_1, V_2, \u0026hellip;, Vm（0 \u0026lt; V_i \\le 1,000,000);$。 每个项目所需人力：$\\{P_{11}, P_{12}, P_{13}\\}, \\{P_{21}, P_{22}, P_{23}\\}, \u0026hellip;, \\{P_{m1}, P_{m2}, P_{m3}\\}$。 其中，$P_{ij}$表示第$i$个项目对第$j$个团队的人力需求（$0 \\le Pij \\le Si$）。 三、输出描述\n输出能够承接的最大预估价值总和。如果无法承接任何项目，输出0。\n四、输入输出示例\n示例1\n输入\n2 100 100 100 10000 8000 60 60 60 60 60 60 输出\n10000 说明\n有2个项目： 第1个项目价值为10000万元，需要每个团队分别投入60人月。 第2个项目价值为8000万元，也需要每个团队分别投入60人月。 由于3个团队的人力总和分别为100人月，只有第1个项目可以完成，因此最大预估价值为10000。 SHOW CODE Java import java.util.*; /** * This solution uses backtracking coding pattern for calculating maximum achievable project value. * * @author Signal Yu * @since 2024-11-25 */ public class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // Project count int m = Integer.parseInt(in.nextLine().trim()); // Team capacity int[] teamCapacity = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); // Project values int[] projectValues = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); // Project Requirements int[][] projectRequirements = new int[m][3]; for (int i = 0; i \u003c m; i++) { int[] parts = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); projectRequirements[i][0] = parts[0]; projectRequirements[i][1] = parts[1]; projectRequirements[i][2] = parts[2]; } // Calculate the max value int maxValue = getMaxProjectValue(teamCapacity, projectValues, projectRequirements, 0, 0); // Print result System.out.println(maxValue); } /** * Calculate the maximum project value. * * @param teamCapacity Remaining capacity of each team. * @param projectValues Value of each project * @param projectRequirements Team Requirements for each project * @param index Current project index. * @param currentValue Current accumulated value * @return Maximum value achievable. */ private static int getMaxProjectValue(int[] teamCapacity, int[] projectValues, int[][] projectRequirements, int index, int currentValue) { if (index == projectValues.length) { return currentValue; } // Skip the current project int maxValue = getMaxProjectValue(teamCapacity, projectValues, projectRequirements, index + 1, currentValue); // Check if the current project can be completed if (canCompleteProject(teamCapacity, projectRequirements[index])) { // Deduct team capacity for the current project adjustCapacity(teamCapacity, projectRequirements[index], -1); // Include the current project and calculate the new value maxValue = Math.max(maxValue, getMaxProjectValue(teamCapacity, projectValues, projectRequirements, index + 1, currentValue + projectValues[index])); // Backtrack: restore capacity adjustCapacity(teamCapacity, projectRequirements[index], 1); } return maxValue; } /** * Check if the project can be completed with the current capability * * @param teamCapacity Remaining capacity of each team. * @param projectRequirement Requirements for the current project. * @return true if the project can be completed, false otherwise. */ private static boolean canCompleteProject(int[] teamCapacity, int[] projectRequirement) { for (int i = 0; i \u003c teamCapacity.length; i++) { if (teamCapacity[i] \u003c projectRequirement[i]) { return false; } } return true; } /** * Adjust the team capacity by adding or subtracting the project requirements * * @param teamCapacity Remaining capacity of each team. * @param projectRequirement Requirements to be adjusted. * @param multiplier Adjustment direction (1 for adding, -1 for subtracting) */ private static void adjustCapacity(int[] teamCapacity, int[] projectRequirement, int multiplier) { for (int i = 0; i \u003c teamCapacity.length; i++) { teamCapacity[i] += projectRequirement[i] * multiplier; } } } 趣味游戏【100分】 SHOW PROBLEM 一、题目描述\n小明负责公司年会，设计了一个趣味游戏：\n屏幕会给出4个1~9之间的不重复数字，要求大家以最快的速度计算出这几个数字可以拼接成的所有数字（从小到大排序后）的第N个数字。\nN的值为给出的4个数字中的最大值。如果排列的数字个数小于N，则输出最后一个数字。\n规则：\n数字 2 和 5 可以互相替代使用，屏幕不会同时出现 2 和 5。 数字 6 和 9 可以互相替代使用，屏幕不会同时出现 6 和 9。 例如：\n输入数字为 1,4,8,7 时，可以拼接的所有数字为：\n1, 4, 7, 8, 14, 17, 18, 41, 47, 48, 71, 74, 78, 81, 84, 87, 147, 148, 178, 187...\n第 8 个数字为 41，因此输出 41。 二、输入描述\n输入为以逗号分隔的4个1~9的数字组成的字符串。\n要求：\n输入的数字范围必须在1~9之间。 输入的数字不能重复。 如果输入不满足要求，输出 -1。\n三、输出描述\n输出这几个数字拼接的所有数字从小到大排序后，第 N 个数字。\n如果拼接出的数字个数少于 N，则输出最后一个数字。\n四、样例\n输入样例 1：\n1,4,8,7 输出样例 1：\n41 样例说明： 可拼接的数字为：\n1, 4, 7, 8, 14, 17, 18, 41, 47, 48, 71, 74, 78, 81, 84, 87, 147, 148, 178, 187...\n第8个数字为 41，因此输出 41。\n输入样例 2：\n2,4,6,8 输出样例 2：\n42 样例说明：\n可拼接的数字为：\n2, 4, 6, 8, 24, 26, 28, 42, 46, 48, 62, 64, 68, 82, 84, 86, 246, 248, 268, 284...\n第8个数字为 42，因此输出 42。\nSHOW CODE Java import java.util.*; import java.util.stream.Collectors; /** * @author Signal Yu * @since 2024-11-25 */ public class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // Parse input into a list of integers List\u0026lt;Integer\u0026gt; nums = Arrays.stream(in.nextLine().trim().split(\",\")) .map(Integer::parseInt) .collect(Collectors.toList()); // Determine the maximum number in the list int maxNum = Collections.max(nums); // Validate the input and process if valid if (!isValidInput(nums)) { System.out.println(\"-1\"); } else { // Generate and sort all unique permutations List\u0026lt;Integer\u0026gt; sortedPermutations = generateSortedPermutations(nums); // Find the N-th smallest number or the last number if insufficient permutations int result = sortedPermutations.size() \u003e= maxNum ? sortedPermutations.get(maxNum - 1) : sortedPermutations.get(sortedPermutations.size() - 1); System.out.println(result); } } private static List\u0026lt;Integer\u0026gt; generateSortedPermutations(List\u0026lt;Integer\u0026gt; nums) { List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); backtrack(nums, new boolean[nums.size()], new StringBuilder(), result); return result.stream().sorted().collect(Collectors.toList()); } private static void backtrack(List\u0026lt;Integer\u0026gt; nums, boolean[] used, StringBuilder current, List\u0026lt;Integer\u0026gt; result) { if (!current.isEmpty()) { result.add(Integer.parseInt(current.toString())); } for (int i = 0; i \u003c nums.size(); i++) { if (used[i]) { continue; } // Add current number to the combination current.append(nums.get(i)); used[i] = true; // Recurse with the updated state backtrack(nums, used, current, result); // Backtrack: remove the last number and reset state current.deleteCharAt(current.length() - 1); used[i] = false; } } private static boolean isValidInput(List\u0026lt;Integer\u0026gt; nums) { if (nums.size() != 4) { return false; } int digitTwoOrFive = 0; int digitSixOrNine = 0; for (int num : nums) { if (num \u003c 1 || num \u003e 9) { return false; } else if (num == 2 || num == 5) { digitTwoOrFive++; } else if (num == 6 || num == 9) { digitSixOrNine++; } } return digitTwoOrFive \u003c= 1 \u0026\u0026 digitSixOrNine \u003c= 1; } } 猜谜码【100分】 SHOW PROBLEM 一、题目描述\n小杨申请了一个保密柜，但忘记了密码。唯一记得的是密码的数字都来源于一个范围内，并且这些数字互不重复。请你帮助小杨根据以下规则，计算可能的密码组合：\n密码的数字来源于给定的数字范围，并且同一密码内数字不能重复； 密码的数字需按从小到大的顺序排列，组合之间按字典序排序； 密码的长度需大于等于给定的最小数字数量； 如果没有符合条件的组合，则输出“None”。 二、输入描述\n第一行：可能的密码数字范围（1~9 的整数），以半角逗号 , 分隔。 第二行：密码的最小数字数量（正整数）。 三、输出描述\n输出所有可能的密码组合，每种组合的数字以半角逗号 , 分隔，并按字典序排序。 每种组合占一行。 如果没有符合条件的组合，输出 None。\n四、输入示例\n输入：\n2,3,4 2 输出：\n2,3 2,3,4 2,4 3,4 五、输出示例\n输入：\n1,2,3 4 输出：\nNone SHOW CODE Java import java.util.*; import java.util.stream.Collectors; /** * @author Signal Yu * @since 2024-11-25 */ public class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); List nums = Arrays.stream(in.nextLine().trim().split(\",\")) .map(Integer::parseInt) .sorted() .collect(Collectors.toList()); int minLength = Integer.parseInt(in.nextLine().trim()); // Generate combinations List","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/programming/coding-problems/1-coding-problem-set/","summary":"String 华为OD机试：字符串分割【100分】 点击查看题目 一、题目描述\n给定一个非空字符串 S，其中包含多个子串，这些子串由 - 符号分隔。我们还给定一个正整数 K，要求按以下规则转换字符串：\n对于字符串中的每个子串，从第二个子串开始，将其分为每 K 个字符的片段。 对每个片段应用以下转换规则： 如果片段中小写字母数量多于大写字母，将该片段的所有大写字母转换为小写字母。 如果片段中大写字母数量多于小写字母，将该片段的所有小写字母转换为大写字母。 如果大写和小写字母数量相等，不做转换。 二、输入描述\n输入包含两行：\n第一行为整数 K。 第二行为字符串 S，由 - 分隔成多个子串。 三、输出描述\n输出转换后的字符串。\n四、测试用例\n测试用例 1 输入\n3 12abc-abcABC-4aB@ 输出\n12abc-abc-ABC-4aB-@ 说明\n子串为 12abc、abcABC、4aB@。第一个子串保留。 对 abcABC 按每 3 个字符分组为 abc 和 ABC： abc 中小写字母多，转换为 abc。 ABC 中大写字母多，转换为 ABC。 对 4aB@ 按每 3 个字符分组为 4aB 和 @： 4aB 中大小写字母数量相等，不做转换。 @ 中无字母，不做转换。 最终输出为 12abc-abc-ABC-4aB-@。 测试用例 2\n输入\n3 Test-aaBBcc-CCddEE 输出","title":"Coding Problem Set"},{"content":"1. Order Food in Restaurant https://youtu.be/_izDbJ45Q5I SHOW NOTES I'm still working on it. This sentence expresses that an action is ongoing and not yet completed. It also suggests that more time is needed to finish it. Did you finish reading? — I\u0026rsquo;m still working on it. Did you fix my car? — I\u0026rsquo;m still working on it. Coke and Fries This refers to a popular combination of fast food: Coca-cola and French Fries. Complimentary This word is used to describe something that is free of charge or offered as a gift. For example: The hotel offers complimentary breakfast. (The breakfast is free of charge.) I'll go with This phrase means to choose or select something from available options. For example: I\u0026rsquo;ll go with pizza. (Pizza is the chosen option over others.) Grab This word means to qucikly take hold of something or pick something up in a hurry. For example: On your way home, can you grab some milk? Wait for me, please. I need to grab my coat. Let\u0026rsquo;s grab a cup of coffee. 2. Calling in Sick https://youtu.be/UCtpnO9r7pQ SHOW NOTES I'm feeling quite ill today. This phrase indicates that the person is experiencing discomfort or sickness. I'm coming down with the flu. This sentence means the person is starting to get sick with the flu. \u0026ldquo;Coming down with\u0026rdquo; is an informal way to say that someone is begining to show symptoms of disease. Calling in sick This phrase is commonly used to notify the employer by phone or email that the person will be absent due to illness. I was hoping to take the day off. This sentence means that the person wants to have a break from work for the day, usually because of personal reasons or illness. 3. Describe Someone\u0026rsquo;s Appearance https://youtu.be/KRysx-guzlw SHOW NOTES Description of Someone's Appearance: He\u0026rsquo;s good looking, he\u0026rsquo;s quite tall, around 6'1. He\u0026rsquo;s in his early 30s, and he get the most beautiful dark brown eyes. Heard is the past tense of the verb hear, which means to listen or become aware of something through the sense of hearing. I heard you\u0026rsquo;re dating a new guy. Julie told me she heard that you\u0026rsquo;re pregnant. What! You got fired? I heard that you quit. Fill me in This phrase means to provide someone with the details or information about something, especially if they missed out on it. For example: Can you fill me in on what happened during the meeting? Career path refers to the direction of someone\u0026rsquo;s career over time. It\u0026rsquo;s the journey someone follows in their professional life. For example: She\u0026rsquo;s thinking about changing her career path and moving into marketing. Goodlooking is used to describe someone who is attractive. It\u0026rsquo;s more natural than handsome. Hot is an informal term used to describe someone who is very attractive, typically in a physical or sexual way. However, it\u0026rsquo;s important to note that it is not always appropriate to use it directly when describing someone, as it can be considered somewhat impolite. It is more commonly used among friends or in casual settings as a comment or compliment. 4. Road Trip https://youtu.be/X8ch6GxkG7I SHOW NOTES Munchies refers to snacks or small amounts of food, often eaten casually or between meals. Fill up the tank means to fill the gas tank of a car with fuel. It\u0026rsquo;s often used when someone is getting ready to drive somewhere. A Pit Stop originally refers to a quick stop made by race cars during a race or refuel or change tires. In everyday language, it can refer to any quick stop made during a journey, such as for food, a bathroom break, etc. For example: Let\u0026rsquo;s make a pit stop for some coffee before we continue driving. We've got all our bases covered. This phrase means that all possible situations or needs have been thought about and planned for. For example: Don\u0026rsquo;t worry about the trip, we\u0026rsquo;ve got all our bases covered. We\u0026rsquo;ve got all our bases covered in case the Hurricane hits. Okay, I have my keys, wallet and passport, looks like I have all my bases covered. Let's get ... This is a common expression used to start something or make it happen. It can be used in many contexts, such as starting a project, meal, or activity. For example: I have a chicken, so let\u0026rsquo;s get cooking. This house is really scary, let\u0026rsquo;s get out of here. I have another meeting in 20 minutes, so let\u0026rsquo;s get down to business. Are we ready to go? This is a question asking if everything is prepared and if it\u0026rsquo;s time to start or leave. It\u0026rsquo;s often used when you\u0026rsquo;re about to start a trip, a task, or an activity. For example: Are we ready to go? The car is packed! It's all set. This means that everything is prepared or ready to go. It suggests that no further work is needed and everything is in order. For example: Don\u0026rsquo;t worry about the meeting, it\u0026rsquo;s all set. 5. Computer Viruses https://youtu.be/1Ic3G-KyEzQ SHOW NOTES Froze refers to something especially a computer or software that suddenly stopped responding and is no longer working, For example: My computer froze when I was trying to open the file. Infected file refers to a file on a computer that has been corrupted or infected by a virus or malware. Up to date means that something is current, recent, and has the latest information or updates. For example: I need to buy a new computer, because mine isn\u0026rsquo;t up to date. I can\u0026rsquo;t find the street, are you sure this map is up to date. Sarah has just finished the reports and all the information is up to date. I'll be right... It is an informal way to describe someone will return or be ready very soon. For example: Can you help me with my computer. — I\u0026rsquo;ll be right there. Come downstairs, dinner is ready. — I\u0026rsquo;ll be right down. Hurry up! I need to use the bathroom. — I\u0026rsquo;ll be right out. It turns out that This phrase is used to reveal a surprising or unexpected result or discovery. It often introduces new information. For example: Frank didn\u0026rsquo;t come to work today, and it turns out that he was sick. I\u0026rsquo;ve been feeling really sick recently, it turns out that I\u0026rsquo;m pregnant. It's acting up again. When something \u0026ldquo;acts up,\u0026rdquo; it means it\u0026rsquo;s behaving in an unusual or malfunctioning way. It is commonly used to describe a technical problem. For example: Oh great! That stupid computer froze again, that\u0026rsquo;s the third time today. 6. Embarrassing Situation https://youtu.be/yFAepMyEIWM SHOW NOTES In a bit of a hurry This phrase means that someone need to do something quickly. For example: Can you drive fast, I\u0026rsquo;m in a bit of a hurry. I can\u0026rsquo;t talk right now, I\u0026rsquo;m in a bit of a hurry. I\u0026rsquo;m in a bit of a hurry, so I\u0026rsquo;ll check these files later. Slipped my mind This means that someone forgot something unintentionally. For example: I\u0026rsquo;m sorry I forgot to respond to your email, it just slipped my mind. I meant to call you but it completely slipped my mind. Don\u0026rsquo;t you know what day is it today? — Oh, it\u0026rsquo;s your birthday. It completely slipped my mind. around here This refers to the local area or the place where someone is currently. For example: Are there any good restaurants around here? Is there a bank around here? Extention: Los Angeles is a great city, I used to live around there. terrible with This means someone is not good at something. For example, You\u0026rsquo;re terrible with numbers, you can\u0026rsquo;t even remember your own telephone number. I\u0026rsquo;m teribble with directions, I\u0026rsquo;m always getting lost. I\u0026rsquo;m teribble with faces, I can never remember what people look like. how's it going? This sentence is a casual, native way to greet someone. For example, How\u0026rsquo;s it going? Everything is going well. 7. Watch a Movie https://youtu.be/8LwCV7IHgss SHOW NOTES inconsiderate This word describes someone who is thoughtless or doesn\u0026rsquo;t consider how their actions affect others. For example: It was inconsiderate of him to interrupt during the meeting. keep it down This phrase is used to ask someone to lower the volume or make less noise. For example: I\u0026rsquo;m trying to study, do you mind keeping it down? not such a big deal This phrase is used to suggest that something is not as important or serious as it may seem. For example: Don\u0026rsquo;t worry about the mistake; it\u0026rsquo;s not such a big deal. I can\u0026rsquo;t get these files to you by tomorrow. — It\u0026rsquo;s OK, it\u0026rsquo;s not such a big deal. switch it off This means to turn something off, usually referring to electronics or devices. For example: Please switch it off when you\u0026rsquo;re done using the computer. can't hear a thing This phrase means that it is so noisy that it is impossible to hear anything clearly. For example: What? This music is too loud, I can\u0026rsquo;t hear a thing. Do you mind... This is a polite way to ask if someone is okay with something or if something would be a problem. For example: Do you mind holding my coat for me? I forgot my wallet. Do you mind paying for dinner? Do you mind turning off your phone? 8. In Debt https://youtu.be/QHeOq0D4zjU SHOW NOTES recession refers to a period of economic decline when businesses slow down and unemployment rises. For example: The country is going through a recession, and many people are losing their jobs. mortgagerefers to a loan taken out to buy property, where the property itself serves as collateral until the loan is paid off. For example: He has a mortgage on his house, and he\u0026rsquo;s paying it off monthly. hit me pretty hard This phrase means something had a strong, negative impact on someone emotionally or financially. For example: My divorce hit me pretty hard, I\u0026rsquo;m so depressed. This cold hit me pretty hard, I\u0026rsquo;ve been in bed for a week. The news of Fluffy\u0026rsquo;s death hit me pretty hard, I\u0026rsquo;ve been crying for days. what can I do for you: This is a polite way to ask how to help someone or what they need. I'm sorry to trouble you This is a polite way of apologizing for causing inconvenience or bothering someone. For example: Can I trouble you for a moment, I just need you to sign this form for me. I\u0026rsquo;m sorry to trouble you, but may I go home early today. Can I trouble you for a pen, mine is not working anymore. On top of all that This phrase is commonly used to add something additional to make things worse, but it can also be used in positive things. For example: Today I lost my job, my car got stolen, and on top of all that, my girl friend broke up with me. Today was a really great day, it was my birthday and all my friends came to visit me, and on top of all that, I received a surprising gift! 9. In a Rush https://youtu.be/DjgpFzIWCRs SHOW NOTES step on it This phrase means to go faster or speed up, especially when driving or in a hurry. For example: We\u0026rsquo;re running late, step on it. have a fit This means to become very angry, upset, or emotional about something. For example: Jeez, you don\u0026rsquo;t need to have a fit, nothing is going to happen if we\u0026rsquo;re five minutes late. My boss is going to have a fit if I don\u0026rsquo;t finish this on time. I almost had a fit when my boss told me I had to work this weekend. cut through means to go through a path that helps save time or provides a shortcut, often through an area that isn\u0026rsquo;t typically a main route. For example: I\u0026rsquo;ll cut through the park to get to the other side of the neighborhood faster. make a left/right/U-turn: These are driving directions. For example: Make a left at the light, then a right at the next stop sign. I missed my exit. I need to make a U-turn. are you nuts This is a casual, humorous, shocked way to ask if someone is crazy or acting irrationally. For example: You want to get married now? Are you nuts? You only met her 3 weeks ago. Are you nuts? I\u0026rsquo;m not going to cheat on the exam, what if I get caught? Let's take a side street/Wilson Avenue/the freeway These phases are used to suggest an alternative route or road. For example: The main road is too congested. Let\u0026rsquo;s take a side street to avoid the traffic. We can get there faster if we take Wilson Avenue. Let\u0026rsquo;s take the freeway to avoid getting stuck in traffic. 10. Visiting the Eye Doctor https://youtu.be/lJLgLQWmpBI SHOW NOTES 2020 vision refers to the normal vision in United States. It\u0026rsquo;s often used to indicate perfect or ideal eyesight. Far-sighted/Near-sighted Far-sighted refers to hyperopia, a condition where distant objects are clear, but nearby objects appear blurry. People with this condition have difficulty seeing things close up. Near-sighted refers to myopia, a condition where nearby objects are clear, but distant objects appear blurry. People with this condition have trouble seeing things far away. make out means to be able to see or understand something, especially when it is difficult to do so. For example: I can barely make out the words on the sign. If you look carefully , you almost make out a few of the stars in the sky. Can you see what\u0026rsquo;s written on the sign there — No, I can\u0026rsquo;t quite make it out. Blind as a bat is a fugurative expression used to describe someone who has very poor vision or is unable to see well. What seems to be the problem/matter/trouble These are used to ask what the issue or difficulty is. What seems to be the problem? (asking about a difficulty or issue) What seems to be the matter? (asking about what is troubling someone) What seems to be the trouble? (asking about a specific difficulty or issue) head on/in/out/up are informal expressions that typically refer to moving or going in a certain direction. head on in: It’s getting late; let’s head on in. head on out: We’ll head on out after lunch. head on up: We’re going to head on up to the second floor. 11. Scheduling an Appointment https://youtu.be/E8vH3YpcFfg SHOW NOTES double check means to verify or check something again to make sure it is correct or accurate. For example: I\u0026rsquo;ll double check my schedule to make sure I\u0026rsquo;m free tomorrow. scheduled means that something has been planned or arranged to happen at a specific time. For example: I have a meeting scheduled for 2 PM. booked solid means that all available time slots are taken, and there are no open appointments or spaces left. For example: I can\u0026rsquo;t get a hotel room, they\u0026rsquo;re booked solid until after the New Year. I\u0026rsquo;m pretty sorry there are no seats available on this flight, we booked solid over the Christmas holidays. Sorry, I can\u0026rsquo;t meet you today, I\u0026rsquo;m booked solid. Sentence Collecting: Appointment: I\u0026rsquo;m calling to arrange an appointment with Ms Mcneely. Please book an appointment for next week. Please schedule an appointment for next week. Dialogue: A: How\u0026rsquo;s Thursday? Does she have any time available then? B: Unfortunately, she\u0026rsquo;s booked solid on Thursday. How does next Monday work for you? A: Actually, I\u0026rsquo;ve got something scheduled on Monday. Can she do Tuesday? B: Let me see, sure, Tuesday\u0026rsquo;s perfect. 12. Going Out to Eat https://youtu.be/VpsxLnJ52ME SHOW NOTES food poisoning refers to an illness caused by consuming food or drink that is contaminated with harmful bacteria, viruses, or toxins. For example: I think I have food poisoning from the salad I ate yesterday. allergic refers to having an allergy, which is an immunue system reaction to certain substances, such as food, pollen, or pet dander. For example: She is allegic to peanuts, so she has to be careful about what she eats. check out This phrase usually means to look at or examine something, or visit a place. For example: Have you been to new cafe next door. — Yeah, I checked it out yesterday, the food was great. I\u0026rsquo;m going to check out that new shopping mall this weekend. bistro refers to a small, casual restaurant or cafe, often offering simple, home-style meals. For example: We went to a charming bistro for dinner last night. not all that crazy about is an informal expression that means not very interested in or not particularly fond of something. Do you want to go shopping with me tomorrow? — I\u0026rsquo;m not all that crazy about shopping, I don\u0026rsquo;t like spending money. I\u0026rsquo;m not all that crazy about Jazz music. Can I change this song? in the mood for This expression means desiring or wanting something at a particular moment, usually referring to food or activities. For example: We always eat hamburgers for dinner, I\u0026rsquo;m in the mood for something different. Let\u0026rsquo;s watch movie. How about Texas Chainsaw Massacre. — I\u0026rsquo;m not in the mood for a horrible movie. Sentence Collecting Ask Suggestions Do you have any suggestions? Do you have any ideas? Do you have any thoughts? Giving Suggestions I\u0026rsquo;d recommend giving it a try. You\u0026rsquo;ve gotta give them a try. You could give them a try. 13. Cancelling an Appointment https://youtu.be/lcZA5FeM2_I SHOW NOTES reschedule means to change the time or date of an event or appointment to a later time. For example: We need to reschedule the meeting for next week. postpone means to delay or push something to a later time, often with a specific future date in mind. For example: The concert was postponed due to the rain. can't make it is a casual way of saying that attending or participating in an event or meeting is not possible. For example: I\u0026rsquo;m sorry, I can\u0026rsquo;t make it to the party tonight. this thing came up This phrase is used to explain that something unexpected or urgent has happened, preventing attendence or participation in a planned activity. I\u0026rsquo;m sorry that I\u0026rsquo;m late this thing came up at work, and I had to stay to take care of it. I can\u0026rsquo;t talk right now, something came up. The meeting at 3 PM had to be rescheduled because this thing came up at work. Sentence Collecting What\u0026rsquo;s up? — Not much./Nothing. 14. Asking for More Time https://youtu.be/IKm6ceWu1IU SHOW NOTES press kit refers to a collection of materials, such as photos, press releases, or information about a company, product, or event, that is given to journalists or media for publicity purpose. deadline/extension deadline is the final date by which something must be completed or submitted. For example: The deadline for the report is Friday at 5 PM. extension is an extra period of time given to complete something after the original deadline. For example: She requested an extension on the project deadline. ran into means to unexpectedly meet someone or experience something, usually a problem. For example: We ran into a storm on our way home. If you\u0026rsquo;re not careful now, you\u0026rsquo;re going to run into a lot of problems later. I ran into some trouble with my computer. I've been meaning to... This is used to express an intention to do something that has not yet been done. For example: I\u0026rsquo;m sorry I haven\u0026rsquo;t called you yet, I\u0026rsquo;ve been meaning to but I\u0026rsquo;ve been busy. I\u0026rsquo;ve been meaning to tell you but John quit yesterday. I\u0026rsquo;ve been meaning to see that film for a while. beyond my control refers to something that cannot be influenced or changed by the person, usually an event or situation. For example: The delay was beyond my control because of the weather. put this off means to delay or postpone something to a later time. For example: I\u0026rsquo;ve been putting off this project for a week, and it\u0026rsquo;s due tomorrow. Can we put off our meeting till next week, I\u0026rsquo;m too busy right now. I\u0026rsquo;ve been putting off my email all day, and now I have 50 messages to respond to. 15. Complimentary Upgrade https://youtu.be/vJlvav_HThc SHOW NOTES under the name refers to something that is registered or listed in someone\u0026rsquo;s name. For example: Do you have a reservation under the name Smith? mix up means to confuse or mistake one thing for another. For example: There was a mix up at the airport, and my bags were sent to Antarctica. I\u0026rsquo;m sorry sir, there\u0026rsquo;s been a terrible mix up with giving you the wrong baby. overlooked means more reservations or tickets have been sold than there is capacity to accommodate. For example: The hotel was overbooked, and they didn\u0026rsquo;t have a room for us when we arrived. complimentary upgrade refers to a free improvement. For example: We received a complimentary upgrade to a presidential suite at the hotel. 16. Cutting in Line https://youtu.be/79cfTb94tHU SHOW NOTES there's no way... This phrase is used to express that something is impossible to happen. For example: There\u0026rsquo;s no way I can have those reports finished today. The stadium is so crowded that there\u0026rsquo;s no way we\u0026rsquo;ll find a seat. Do you think Michael\u0026rsquo;s gonna buy that house? — There\u0026rsquo;s no way he has enough money to buy it. cut in line means to move ahead of others in a line or queue, usually in an unfair or rude manner. For example: Excuse me, I\u0026rsquo;m really late, can I cut in line, please? I hate it when people cut in line at the bank, it\u0026rsquo;s so rude. I think it\u0026rsquo;s okay when a pregnant woman cuts in line. sue me is a casual or somewhat sarcastic expression used to suggest that someone is free to take legal action, often when the speaker does not care about the consequences. It can also be used humorously when someone is being accused of something. For example: I forgot your birthday. Sue me! (Used in a joking way) 17. Wedding Day https://youtu.be/MCtwK8KGtBk SHOW NOTES it's about time. is commonly used to express that something finally happens after a long wait. For example: Dinner\u0026rsquo;s ready. — It\u0026rsquo;s about time, I\u0026rsquo;m starving. Guess what. I finally got a job. — It\u0026rsquo;s about time, you\u0026rsquo;ve been unemployeed for two years. We\u0026rsquo;re almost there, just a couple more minutes. — It\u0026rsquo;s about time, we\u0026rsquo;ve been driving for 12 hours. bridesmaids are women who are chosen to assist the bride on her wedding day. flower girl is a young girl who walks down the aisle before the bride, scattering flower petals. ring bearer is a young boy who carries the wedding rings down the aisle. gorgeous is a uni-sex adjective, it can be used to describe both people and things. For example: She looks gorgeous in that dress. The sunset was absolutely gorgeous. Common Mistake Wrong: Let\u0026rsquo;s marry. Right: Let\u0026rsquo;s get married. Flower Girl \u0026amp; Ring Bearer 18. Asking for Time Off https://youtu.be/Ds5zwyfLyqI SHOW NOTES notice refers to the information that gived someone in advance about something, often referring to leaving a job or ending an agreement. For example: If you want to quit your job, make sure you give enough notice, you\u0026rsquo;ll need to tell us four weeks in advance. You didn\u0026rsquo;t give me enough notice about this project, I didn\u0026rsquo;t have enough time to finish it. Sentence Collecting: Do you have a sec/second/minute? — Sure, what can I do for you? Would you be okay with that? — I\u0026rsquo;m fine with that. Are you alright with that? / Will you Ok with this? I was just wondering/thinking/hoping... is more polite than I want to... 19. Hiring an Assistant https://youtu.be/JZFIdKbnZCU SHOW NOTES understaffed means that there are not enough employees or workers to handle the work or tasks. For example: Our team is understaffed right now, so we need to delay the project deadline. the timing is just not right means that it\u0026rsquo;s not the right moment or situation to do something. For example: I was gonna sell my house, but the timing is just not right. Honey, I think we should have a baby. — The timing is just not right. weight off my shoulders phrase means feeling relieved from stress or worry. After I finished my final exam, it felt like a weight was off my shoulders. give me a hand is an informal way of asking for help. For example: Can you give me a hand with these boxes. Neil, I\u0026rsquo;ll need you to give me a hand with the sales reports. Let me give you a hand with your suitcase. keep our costs down means to reduce or control expenses. We need to keep our costs down if we want to make a profit this quarter. 20. Bargain https://youtu.be/I4ivQUabfyo SHOW NOTES bargain refers to a good deal or something you buy at a lower price than usual. It can also refer to negotiating for a better price. For example: I found a great bargain on these shoes—they were 50% off! price range refers to the range of prices within which something is available, or the amount someone is willing to pay. For example: I\u0026rsquo;m looking for a new phone, but my price range is between $200 and $400. shop around means to look at different stores or options to compare prices before making a purchase. For example: Before you buy that jacket, shop around and see if you can find a better deal at another store. Can you give me a better deal? This is a request for a lower price or a better offer, often used during negotiations. For example: I really like this shirt, but it\u0026rsquo;s too expensive. Can you give me a better deal? Can you give me a better price on this car, I really don\u0026rsquo;t have that much money. That's still more than I wanted to spend. This is commonly used in situations where the price is still too high even after trying to negotiate or considering different options. For example: I know the dress is on sale, but that\u0026rsquo;s still more than I wanted to spend. That's my last offer This is commonly used in situations where the final price someone is willing to accept; no further negotiations will be made. For example: I can\u0026rsquo;t go lower than $500 for the laptop. That\u0026rsquo;s my last offer. 21. Watching Basketball https://youtu.be/O-BvPcJfX1w SHOW NOTES foul refers to a violation of the rules in a sport, usually resulting in a penalty. For example: He committed a foul by pushing the opponent during the game. ref is short for referee, refers to an official who oversees a game or match to enforce the rules. For example: The ref called a foul on that play because the defender hit the shooter. free throw refers to a shot taken from the free-throw line without any defense, usually awarded after a foul. For example: She made both of her free throws after the foul was committed. make the shot means to successfully score by getting the ball into the hoop or goal. For example: If Gretzky make a shot, they\u0026rsquo;re gonna win the Stanley Cup. 3-pointer refers to a basketball shot taken from beyond the three-point line, worth three points if successful. For example: He hit a 3-pointer to tie the game in the final seconds. travel refers to a vilation in basketball where a player takes too many steps without dribbling the ball. For example: The ref called a travel because the player took five steps without dribbling. beer run informally refers to going to get beer, usually in a group or as part of a social activity. For example: We\u0026rsquo;re running out of drinks—time for a beer run. screw up means to make a mistake or do something badly, often in a way that causes problems or difficulties. For example: Jill, you really screwed up this time, you\u0026rsquo;re fired. This game is important, if you screw it up again, we\u0026rsquo;re out of the finals. I\u0026rsquo;m sorry, I know I screwed up, will you forgive me? 22. Ending a Relationship https://youtu.be/HjXbEHvwskM SHOW NOTES get a hold of means to contact or reach someone. For example: I tried calling her all day, but I couldn\u0026rsquo;t get a hold of her. stood me up means to fail to meet someone as planned, especially when they were expecting you. For example: I waited for an hour, but she stood me up and never showed. priority refers to something that is considered more important to be done or dealt with first. For example: Getting the report finished is my top priority today. heading is commonly used to express the future direction, outcome, or progress. For example: I don\u0026rsquo;t know where our relationship is heading. Where is this bus heading? Where is this project heading? Do you have any idea...? This is commonly used to ask if someone knows or has any information about something. For example: You forgot my birthday. Do you have any idea how angry I am? Julie kiss my borfriend, does she have any idea how mean that was? I just broke up with my boyfriend, don\u0026rsquo;t you have any idea how sad I am? I've heard it all before. This phrase is used when someone is tired of hearing the same things or excuses. For example: You say you\u0026rsquo;ll change, but I\u0026rsquo;ve heard it all before. I\u0026rsquo;m not buying it. 23. New Year\u0026rsquo;s Resolution https://youtu.be/I9k50oVZPHA SHOW NOTES transform means to change something completely in appearance, form, or nature, often for the better. For example: She used to be shy, but the experience completely transformed her. stuffed means to be very full, especially after eating too much. For example: I ate so much pizza, I\u0026rsquo;m completely stuffed! stick to it means to continue with something especially when it\u0026rsquo;s difficult. For example: I can\u0026rsquo;t solve this math problem. — Stick to it. I\u0026rsquo;m sure you\u0026rsquo;ll get it. I mean it. This phrase emphasizes seriousness in what someone is saying. For example: If you don\u0026rsquo;t finish your homework by tonight, there will be consequences. I mean it! cut out means to remove something entirely. For example: It\u0026rsquo;s time for me to focus on my work, I\u0026rsquo;m going to cut out everything else from my life. You have to cut out the salt and carbon from your diet, no more chips, no more French fries, no more popcorn. 24. Ordering Pizza https://youtu.be/yaeLbz_NK4U SHOW NOTES pepperoni is a type of spicy Italian sausage made from cured pork and beef, often used as a topping for pizza. olives are small, oval-shaped fruits that are typically green or black. They are often used in salads, pasta dishes, or as pizza toppings. martini is a classic cocktail typically made with gin and vermouth, garnished with an olive or a twist of lemon peel. thick crust / thin crust Thick crust is soft and doughy, while thin crust is crispy and light. ham is a type of cured or smoked meat, often made from the thigh of a pig. It is commonly used as a topping for pizzas or in sandwiches. Regina Margarita is a variation of the famous Margherita pizza, typically with tomato, mozzarella, and basil, but may also include other toppings or slightly different variations depending on the restaurant. This is Marty speaking. This is a way to introduce oneself on the phone, letting the other person know who is speaking. For example: Hello, this is Marty speaking. How can I help you? 2 for 1 special is a promotional offer where customers get two items for the price of one. This is commonly seen in restaurants, stores, or fast-food promotions. 25. Receptionist https://youtu.be/sgxrbqyGonE SHOW NOTES May I take your name? This is a polite way of asking for someone\u0026rsquo;s name, typically when answering the phone or greeting someone in an office or service setting. Miss Stevens will be with you momentarily. This is a polite way to inform someone that Miss Stevens will arrive or be ready to speak with them shortly. For example: Please take a seat. Miss Stevens will be with you momentarily. Miss Stenvens is ready for you now. This is used to inform someone that the person they are waiting to see is now available to meet them. For example: Miss Stevens is ready for you now. Please follow me. I'll show you to her office. This is used to guide someone to another person\u0026rsquo;s office or location. For example: Please follow me. I\u0026rsquo;ll show you to her office. right this way is a polite way of directing someone to go in a certain direction. watch your step is a cautionary phrase used to warn someone to be careful of their footing, often when walking on uneven ground or stairs. 26. Swimming https://youtu.be/kGopb2awYiM SHOW NOTES anchor the boat means to secure a boat in place by dropping an anchor into the water, preventing it from drifting. For example: We need to anchor the boat before we go swimming. doggy padding is a simple swimming stroke where the swimmer uses a paddling motion with their arms and legs, similar to how a dog swims. It is often used by beginners as it\u0026rsquo;s an easy and natural way to stay afloat. breaststroke is a swimming stroke where the swimmer moves their arms in a half-circle motion while pulling their legs in a frog-like kick. backstroke is a swimming stroke done on the back, where the swimmer alternates arm strokes in a circular motion while kicking their legs. take a dip means to go into the water for a quick swim. For example: It\u0026rsquo;s such a hot day; let\u0026rsquo;s take a dip in the pool to cool off. for a little while means for a short period of time. I\u0026rsquo;m going to take a dip for little while before the sunset. 27. Eggs Preparation https://youtu.be/e-z7jc3B4zg SHOW NOTES picky means being very selective or particular, especially when it comes to food, preferences, or choices. He\u0026rsquo;s really picky about his food—he doesn\u0026rsquo;t like vegetables. yolk/egg white yolk is the yellow part of an egg, which is surrounded by the egg white. egg white is the clear part of an egg that surrounds the yolk sunny side up is a way of cooking eggs where the egg is fried on one side only, leaving the yolk exposed and not flipped. soft/hard boiled eggs soft boiled egg is an egg that has been boiled for a short time, resulting in a runny yolk and slightly firm white. hard boiled egg is an egg that has been boiled for a longer period, making both the yolk and white firm. eggs and soldiers is a British dish where soft-boiled eggs are served with strips of toast (called soldiers) for dipping into the yolk. I feel like... This is often used to express a desire, mood, or inclination to do something. I feel like baking. I feel like eating pizza. drives me crazy means to cause frustration or annoyance, often in a way that is hard to ignore. This music is driving me crazy, turn it down. Don\u0026rsquo;t leave garbage in my car, it drives me crazy. Your mom is driving me crazy, she keeps calling me. 28. At the Bar https://youtu.be/l-IL4mtzye0 SHOW NOTES on tap refers to beverages, especially beer, that are available from a keg. When something is \u0026ldquo;on tap\u0026rdquo;, it means that it\u0026rsquo;s being served from a tap at a bar or restaurant. happy hour refers a time when drinks and appetizers are sold at discounted, usually in the late afternoon or early evening. a special refers to a discounted item, usually in a restaurant or bar. Today\u0026rsquo;s special is a burger and fries for only $5. pint is a unit of measurement for liquids, commonly for beer. a pint = 473 milliliters appetizer is a small dish served before the main course to stimulate appetite. Nachos /ˈnɑːtʃoʊz/ is a popular snack made from tortilla chips covered with melted cheese and often topped with things like salsa, guacamole, sour cream, etc. Heineken /ˈhaɪnɪkən/ is a popular brand of beer originally from the Netherlands. Budweiser /ˈbʌdˌwaɪzər/ is a well-known American beer brand. Mozzarella /ˌmɑːtsəˈrɛlə/ is an Italian cheese that is soft, white, and commonly used in salads, pizzas, and pasta dishes. how/what about are used to suggest or inquire about something. What about these dirty clothes, you said you would wash them days ago. What about going to the mall instead. I\u0026rsquo;m tired of going to the movies. How about we go to the new restaurant tonight? 29. Fingers https://youtu.be/y-eo1VNedcQ SHOW NOTES pinky, ring finger, middle finger, index finger, thumb pinky: The smallest finger. ring finger: The fourth finger, typically where a ring is worn. middle finger: The third finger, located in the center of the hand. index finger: The second finger, next to the thumb, often used for pointing. thumb: The first and thickest finger, opposable to the other fingers, making grasping objects easier. may this ring be blessed This phrase refers to a wish or prayer for the ring to be blessed or sactified, often said during a wedding ceremony. abide in peace This phrase means to live or remain in peace, suggesting calmness and harmony. with this ring, I thee wed This is a traditional phrase spoken during a wedding ceremony, where one person declares their intention to marry the other by placing a ring on their finger. wear it as a symbol of our love and commitment This phrase explains that the ring represents the love and promise made between two people in marriage. 30. Math https://youtu.be/8uLJQnZROyI SHOW NOTES teacher's pet refers to a student who is overly favored by the teacher, often because they try to please the teacher. It common have a negative connotation, implying that the student is trying too hard to gain the teacher\u0026rsquo;s approval. scuk up means someone who is overly flattering someone, usually a person in power, like a teacher or boss, in an insincere way to gain favor. smarty pants is a playful or teasing way to describe someone who is very clever or shows off their intelligence, often in a way that annoys others. know-it-all refers to a person who believes they know everything. It\u0026rsquo;s usually used in negative or sarcastic way to describe someone who is seen as arrogant about their knowledge. 31. Sci-fi https://youtu.be/hdcGDXFFiq4 SHOW NOTES blaster is a type of weapon, often seen in science fiction or action movies. break through means to make progress or succeed after overcoming obstacles, which can refer to physical barriers like wall, or more abstract challenges like tough problems. After 15 minutes, the workers broke through the wall, and rescued everyone from the fire. He is such a good player, he broke through the entire defense. They are breaking through our impenetrable wall. settle this means to solve a disagreement or issue. It can be used when there\u0026rsquo;s need to come to a final decision or conclusion about something. I\u0026rsquo;m fed up with arguing about this, let\u0026rsquo;s just settle the argument once and for all. tractor beam is a concept from science fiction, usually referring to a powerful beam used to pull or attract objects toward a spacecraft. no longer be means that something is no longer happening, or someone is no longer in a particular role. I\u0026rsquo;ll no longer be your boyfriend. know nothing of This phrase is often used to express that someone is ignorant or uninformed about a topic. You think you can understand what I\u0026rsquo;m going through, but you know nothing of the struggles I\u0026rsquo;ve faced. once and for all means to finally resolve or finish something, often in a definitive or conclusive way. He claims that his photographs prove once and for all that UFOs do exist. I told him once and for all that I don\u0026rsquo;t want to be his girlfriend anymore. 32. Barber Shop/Hair Salon https://youtu.be/l4jdN_P3UjE SHOW NOTES trim means to cut something or small adjustments, usually to hair. silky is commonly used to describe hair that very soft and smooth to touch. shiny is used to describe something that has a bright, smooth surface, such as shiny hair or a shiny car. grow out means to let something, such as hair or nails, become longer naturally without cutting them. sideburn is the strip of hair that grows along the sides of the face, in front of the ears. take a little off the top is commonly used when someone wants to trim a small amount of hair from the top part of their head. nothing too fancy means something is simple, not elaborate, or not showing off. don't just stand there is used to tell people to take action instead of staying still or doing nothing. Don\u0026rsquo;t just stand there, help me take these boxes into the house. The house is on fire, don\u0026rsquo;t just stand there, call the fire department. look like a million buck means to look very attractive, stylish, or impressive. It\u0026rsquo;s a compliment often used when someone is well-dressed or appears confident and radiant. Mullet is a hairstyle where the front of the hair is short, and the back is left long. It bacame popular in the 1980s. Hockey Hair is a term for a hairstyle similar to the mullet, often associated with hockey players. It’s characterized by long hair in the back and shorter hair in the front. Afro refers to a hairstyle where the hair is naturally grown out and styled into a rounded shape, often associated with African heritage. Mohawk is a hairstyle where the hair is shaved or very short on the sides, with a strip of longer hair running from the front to the back of the head. Flat Top is a hairstyle where the hair is cut short on the sides and top, creating a flat, even surface. crew cut is very short and simple style where the hair on the sides and top is cut short and uniform in length. Dreadlocks is a hairstyle where the hair is matted or twisted into long, rope like strands. It is often associated with various cultures, especially in the Caribbean and African communities. 33. Pharmacy/Drug Store/Chemist https://youtu.be/5J2cwx5gHUI SHOW NOTES price check refers to checking the price of an item, usually at a store or supermarket. Can you do a price check on this shirt? I\u0026rsquo;m not sure if it\u0026rsquo;s on sale. capsule is a medication enclosed in a soft or hard shell, usually made of gelatin. tablet is a solid form of medication that is typically swallowed. overdose means to take more than the recommended or safe amount of a drug. eyedrops means a liquid medication that is applied to the eyes. Prozac is a brand name for the medication fluoxetine, which is used to treat depression, anxiety, and other disorders. be sure means to be certain about something. Be sure not to forget your unbrella, it\u0026rsquo;s raining today. hang on generally means to wait for a short time or hold something tightly. wait: Hang on, I\u0026rsquo;ll be right there. hold: Hang on to the railing while going down the stairs. 34. Baseball https://youtu.be/Uc1GjEKoPZI SHOW NOTES national anthem is a patriotic song officially recognized by a country, often sing at the begining of public events like sports games. hymn is a religous song, typically sing during religious ceremonies or services. pitcher is a player in baseball who throws the ball to the batter from the pitcher\u0026rsquo;s mound. outfielder is a player in baseball who is positioned in the outfield (the area fartest from the home plate) and is responsible for catching fly balls and making throws back to the infield. line drive is a type of hit in baseball where the ball is hit sharply and traight, usually at a low angle. scrambling refers to a player in baseball quickly and awkwardly to avoid being tagged or to regain control of the ball. inning is a division of a baseball game where both teams have a chance to bat and field. The game went into extra innings, and the home team won in the 12th inning. up to bat refers to the player who is currently batting or next in line to the bat in a baseball game. It\u0026rsquo;s your turn, you\u0026rsquo;re up to bat now. strike one refers to a term used in baseball when the batter misses a pitched ball, or doesn\u0026rsquo;t swing at a ball that\u0026rsquo;s in the strike zone. curve ball is a type of pitch in baseball that curves or breaks as it approaches the batter, making it harder to hit. Also used figuratively to mean something unexpected. The pitcher threw a curve ball, and the batter couldn\u0026rsquo;t hit it. My boss threw me a curve ball today, so I have to stay and work late. hit a home run A home run is a term from baseball that refers to a hit in which the batter hits the ball out of the playing field, typically over the outfield fence, without it being caught. In a figurative sense, it means achieving a significant success or accomplishing something exceptionally well. Great job on that sales presentation, you really hit home run. Our sales team hit a home run this month by doubling our revenue. 35. Confess Love https://youtu.be/74FmjXrg0t8 SHOW NOTES here's the thing is used to introduce something important or to explain a situation. Here\u0026rsquo;s the thing, we need to leave in 10 minutes if we want to catch the train. I can't take it anymore is used when someone feels overwhelmed, frustrated, or exhausted by a situation and can no longer handle it. The man next door has been so loud, I can\u0026rsquo;t take it anymore. My boss always yells at me, I can\u0026rsquo;t take it anymore. I can\u0026rsquo;t take it anymore, I\u0026rsquo;m going to quit. are you serious is similar to really, it\u0026rsquo;s often used when something is surprising, unbelievable, or hard to believe. Are you serious? You just won the lottery?! have the guts means having the courage to do something difficult, dangerous, or challenging. I don\u0026rsquo;t think I have the guts to go skydiving. I don\u0026rsquo;t have the guts to give a speech. I\u0026rsquo;ve never had the guts to say no to my boss. just for the two of us means something is meant for only two people, often implying exclusivity or intimacy. I booked a small table at the restaurant, just for the two of us. give me a shot means to give someone a chance to try or attempt something. I know I can do this drawing better, just give me a shot. The HR manager wasn\u0026rsquo;t going to hire me, but he decided to give me a shot. 36. Back In 1950 https://youtu.be/9Ox9lC_Jbuk SHOW NOTES A Sock Hop is a type of informal dance event that was popular in the 1950s and 1960s. A Sadie Hawkins Dance is a type of dance where girls ask the boys to be their dates, instead of the traditional way where boys ask girls. I'm swell is an old-fashioned, informal way of saying \u0026ldquo;I\u0026rsquo;m doing great\u0026rdquo; or \u0026ldquo;I\u0026rsquo;m fine.\u0026rdquo; It was popular in the 1930s and 1940s. How are you feeling today?—I\u0026rsquo;m swell. cool it means to relax or calm down, especially if someone is getting overly excited or angry. It\u0026rsquo;s a way to tell someone to take it easy. Just cool it. Now is not the right time to get angry. You need to cool it and stop yelling at me. knuckle sandwich is a humorous or exaggerated way of referring to a punch in the face. It\u0026rsquo;s a playful way of saying someone might get hit. If you keep talking like that, you might end up with a knuckle sandwich! pipsqueak is a playful term or slightly insulting term for someone who is small or weak, often used for children or someone who\u0026rsquo;s being annoying in a harmless way. Stop being such a pipsqueak and help me carry these boxes. It'll be blast means that something is going to be a lot of fun or exciting. Don\u0026rsquo;t worry, the party\u0026rsquo;s going to be a blast. have my eyes on means to be interested in or focused on something, whether it\u0026rsquo;s a person, a goal, or an object. I\u0026rsquo;ve had my eyes on that new phone for a while. ease off means to reduce the intensity, pressure, or effort being applied to something or someone. It’s used when someone is doing something too forcefully, and you suggest they should stop being so intense or give more space. You\u0026rsquo;re pushing Susie too much, you need to ease off a bit. You need to ease off the junk food. Matt is putting so much pressure on me these days, I wish he would ease off. Scok Hop Sadie Hawkins Dance 37. Back In 1970 https://youtu.be/lJqo8PYZbBc SHOW NOTES roller rink ia a place where people go to skate. A roller skate is a type of skate with four wheels arranged in two rows, like a small car\u0026rsquo;s wheels. A roller blade is a type of skate with wheels arranged in a single line. groovy is a slang term from the 1960s-70s meaning \u0026ldquo;cool\u0026rdquo; or \u0026ldquo;awesome\u0026rdquo;. far out ia slang term in 1970s meaning \u0026ldquo;amazing\u0026rdquo; or \u0026ldquo;incredible\u0026rdquo;. foxy is used to describe someone as very attractive or sexy. mellow out means to relax or calm down. You need to mellow out after a stressful day. right on is a phrase showing aggrement or excitement, similar to saying \u0026ldquo;exactly\u0026rdquo; or \u0026ldquo;that\u0026rsquo;s great\u0026rdquo;. Right on, you got a high score, that\u0026rsquo;s amazing. gravy is a slang for something extra good or easy, like a bonus. This raise was gravy on top of the promotion. to book is a casual way to say \u0026ldquo;leave quickly\u0026rdquo; or \u0026ldquo;run away\u0026rdquo;. We need to book before it gets too late. how's it hanging is a casual way of saying \u0026ldquo;how are you?\u0026rdquo; chat her up is a british slang phrase meaning to start a conversation with someone, usually flirting. hit someone up is a casual way to say \u0026ldquo;contact someone\u0026rdquo;, often to ask for something, either by calling, texting, or meeting. Can you believe Patrick, he came up to me a month ago, and tried to hit me up for some money. When I was a kid, I used to always hit my dead up for lunch money. This is the last time I lend you money, don\u0026rsquo;t even try to hit me up for more. grab some grub is a casual phrase meaning \u0026ldquo;get something to eat.\u0026rdquo; Grub is a slang term for food. Let\u0026rsquo;s grab some grub before the movie. ","permalink":"https://signalyu.github.io/posts/3-humanities/languages/listening/english/1-learning-english-with-podcasts/","summary":"1. Order Food in Restaurant https://youtu.be/_izDbJ45Q5I SHOW NOTES I'm still working on it. This sentence expresses that an action is ongoing and not yet completed. It also suggests that more time is needed to finish it. Did you finish reading? — I\u0026rsquo;m still working on it. Did you fix my car? — I\u0026rsquo;m still working on it. Coke and Fries This refers to a popular combination of fast food: Coca-cola and French Fries.","title":"Learning English With Podcasts"},{"content":"IDEA Maven Introduction to Maven Maven is a build automation and project management tool primarily used for Java projects. It follows the concept of Project Object Model (POM), which is defined in an XML file (pom.xml) at the root of the project.\nsettings.xml Configuration ./ ├── bin/ │ ├── m2.conf │ ├── mvn* │ ├── mvn.cmd │ ├── mvnDebug* │ ├── mvnDebug.cmd │ └── mvnyjp* ├── boot/ │ ├── plexus-classworlds-2.7.0.jar │ └── plexus-classworlds.license ├── conf/ │ ├── logging/ │ │ └── simplelogger.properties │ ├── settings.xml # CUSTOMIZE DEFAULT BEHAVIOR IN THIS FILE │ └── toolchains.xml ├── ... The settings.xml file in Maven is typically used to customize the default behavior according to user needs. Common modifications include configuring repository locations, setting up mirrors, and defining profiles.\nSHOW CODE: Configuring Repository Location Configuring Repository Location \u0026lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: ${user.home}/.m2/repository \u0026lt;localRepository\u0026gt;/path/to/local/repo\u0026lt;/localRepository\u0026gt; --\u0026gt; \u0026lt;localRepository\u0026gt;/Users/signalfish/maven-repository\u0026lt;/localRepository\u0026gt; SHOW CODE: Setting Up Mirrors Setting Up Mirrors \u0026lt;mirrors\u0026gt; \u0026lt;!-- mirror | Specifies a repository mirror site to use instead of a given repository. The repository that | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used | for inheritance and direct lookup purposes, and must be unique across the set of mirrors. | \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;mirrorId\u0026lt;/id\u0026gt; \u0026lt;mirrorOf\u0026gt;repositoryId\u0026lt;/mirrorOf\u0026gt; \u0026lt;name\u0026gt;Human Readable Name for this Mirror.\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://my.repository.com/repo/path\u0026lt;/url\u0026gt; \u0026lt;/mirror\u0026gt; --\u0026gt; \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;alimaven\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;aliyun maven\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://maven.aliyun.com/nexus/content/groups/public/\u0026lt;/url\u0026gt; \u0026lt;mirrorOf\u0026gt;central\u0026lt;/mirrorOf\u0026gt; \u0026lt;/mirror\u0026gt; \u0026lt;/mirrors\u0026gt; SHOW CODE: Defining Profiles Defining Profiles \u0026lt;profiles\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;env-dev\u0026lt;/id\u0026gt; \u0026lt;activation\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;target-env\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;dev\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/activation\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;tomcatPath\u0026gt;/path/to/tomcat/instance\u0026lt;/tomcatPath\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/profile\u0026gt; --\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;jdk-1.8\u0026lt;/id\u0026gt; \u0026lt;activation\u0026gt; \u0026lt;activeByDefault\u0026gt;true\u0026lt;/activeByDefault\u0026gt; \u0026lt;jdk\u0026gt;1.8\u0026lt;/jdk\u0026gt; \u0026lt;/activation\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;1.8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;1.8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;maven.compiler.compilerVersion\u0026gt;1.8\u0026lt;/maven.compiler.compilerVersion\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;jdk-17\u0026lt;/id\u0026gt; \u0026lt;activation\u0026gt; \u0026lt;activeByDefault\u0026gt;true\u0026lt;/activeByDefault\u0026gt; \u0026lt;jdk\u0026gt;17\u0026lt;/jdk\u0026gt; \u0026lt;/activation\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;17\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;17\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;maven.compiler.compilerVersion\u0026gt;17\u0026lt;/maven.compiler.compilerVersion\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/profiles\u0026gt; GAVP In Maven, GAVP refers to four key components that are used to uniquely identify and describe an artifact (e.g., WAR, JAR, or POM) in a Maven repository.\nG stands for GroupID, which represents the organization or group responsible for the artifact. It typically follows the reverse domain name convention, such as \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; or \u0026lt;groupId\u0026gt;dev.signalyu\u0026lt;/groupId\u0026gt;. A stands for ArtifactID, which identifies the specific artifact within the group. It usually matches the project name or module name, such as \u0026lt;artifactId\u0026gt;my-app\u0026lt;/artifactId\u0026gt;. V stands for Version, which specifies the version of the artifact, such as \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt;. P stands for Packaging, which specifies the type of artifact. It tells Maven what kind of output to expect from the project, such as a JAR file for a library or a WAR file for a web application, such as \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt;. Common Maven Commands mvn compile: Compiles the source code of the project. mvn test: Compiles the source code, runs unit tests, and reports the results. mvn package: Compiles the source code, runs unit tests, and packages the compiled code into desired artifact. mvn clean: Removes the previously compiled files and generated artifacts. mvn install: Compiles the source code, runs unit tests, packages the compiled code into an artifact, and installs it into local Maven repository. mvn deploy: Compiles the source code, runs unit tests, packages the compiled code into an artifact, and deploys the artifact to a remote repository. Maven Dependency Download Failure When Maven fails to download dependencies, follow these steps to resolve the issue:\nCheck the network connection: Ensure a stable internet connection. If an internal network is used, verify the mirror configuration in settings.xml to ensure it\u0026rsquo;s correctly set up. Verify the dependency version: Double-check the version of the dependency specified in pom.xml. Clean the local repository: If the previous steps don\u0026rsquo;t resolve the issue, try cleaning the local Maven repository or deleting the specific dependency directory in the repository. Invalidate caches in the IDE: In IntelliJ IDEA, navigate to File -\u0026gt; Invalidate Caches to clear any cached information that might be causing issues. Then, restart the IntelliJ IDEA. Dependency Inheritence In Maven, dependency inheritance refers to the ability to inherit dependencies from a parent project. This feature enables better management of dependencies in multi-module projects, where a child module can inherit dependency configurations from the parent POM.\nSHOW CODE Parent POM Child POM \u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;parent-project\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; \u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;child-project1\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;child-project2\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.12\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- These dependencies can be inherited by child projects --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.commons\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-lang3\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.12.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; \u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;parent-project\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;relativePath\u0026gt;../pom.xml\u0026lt;/relativePath\u0026gt; \u0026lt;!-- Path to the parent POM --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;artifactId\u0026gt;child-project1\u0026lt;/artifactId\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- Child module can use the dependency inherited from the parent --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-core\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; In the above code, The spring-core dependency is inherited from the parent, and the version is automatically resolved by Maven from the parent’s dependencyManagement section. The commons-lang3 dependency from the parent is also inherited, but does not need to be re-declared in the child POM.\nThe difference between dependencyManagement and dependencies is that dependencies directly add dependencies to the project build, meaning they are included in the project\u0026rsquo;s final artifact. On the other hand, dependencyManagement specifies the version and configuration of dependencies for inheritance in child modules, without directly adding them to the project build.\nPostman ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/framework-and-tools/tools/1-idea-maven-postman-notes/","summary":"IDEA Maven Introduction to Maven Maven is a build automation and project management tool primarily used for Java projects. It follows the concept of Project Object Model (POM), which is defined in an XML file (pom.xml) at the root of the project.\nsettings.xml Configuration ./ ├── bin/ │ ├── m2.conf │ ├── mvn* │ ├── mvn.cmd │ ├── mvnDebug* │ ├── mvnDebug.cmd │ └── mvnyjp* ├── boot/ │ ├── plexus-classworlds-2.7.0.jar │ └── plexus-classworlds.","title":"Idea \u0026 Maven \u0026 Postman Notes"},{"content":"Core Concepts Loose Coupling Loose Coupling is a design principle that aims to reduce the dependencies between components within a system.\nInversion of Control (IoC) Inversion of Control is a design principle where the control of object creation and lifecycle management is transferred from the application code to an external container or framework.\nDependency Injection (DI) Dependency Injection is a design pattern commonly used in object-oriented programming, where the dependecies of a class are provided externally rather than being created within the class itself.\nBeans Beans are objects that are managed by the Spring framework.\nContainer A Spring Container is responsible for managing the life cycle, configuration, and dependencies injection of the beans in a Spring Application.\nLife Cycle of Beans Beans are objects that are managed by the Spring framework. Bean Definition includes configuration meta data required by the Spring container to create and manage the bean. Bean Configurations can be provided in various way, including XML configuration files, annotations, and Java-based configuration. Bean Instantiation $\\rightarrow$ Population of Properties $\\rightarrow$ Initialization $\\rightarrow$ Ready for Use $\\rightarrow$ Destruction The Difference between instantiation and initiation?\nInstantiation occurs when a new keyword is used to create an object. It focus on constructing the object\u0026rsquo;s structure and allocating memory. In contrast, initialization focus on assigning values to the object\u0026rsquo;s fields and setting up its initial state after instantiation.\nConstructor Injection \u0026amp; Setter Injection \u0026amp; Field Injection Constructor Injection Constructor Injection in Spring is a type of dependency injection where the Spring framework provides the required dependency to a class by invoking its constructor. Since dependencies are supplied via the constructor, they cannot be changed after object creation \u0026ndash; promoting immutability. However, this approach may cause circular dependency issues if two or more beans depend on each other in a circular manner.\nSHOW CODE Java @Component public class ServiceA { private final RepositoryA repositoryA; // Constructor injection @Autowired public ServiceA(RepositoryA repositoryA) { this.repositoryA = repositoryA; } } Setter Injection Setter Injection in Spring is a form of dependency injection where the Spring framework injects dependencies into a bean by calling the bean\u0026rsquo;s setter method. This approach is flexible and commonly used to inject optional dependencies or when the dependency might change after the object is initialized.\nSHOW CODE Java @Component public class ServiceB { private RepositoryB repositoryB; // Setter injection @Autowired public void setRepositoryB(RepositoryB repositoryB) { this.repositoryB = repositoryB; } } Field Injection Field Injection in Spring is a form of dependency injection where the Spring framework directly injects dependencies into a class\u0026rsquo;s fields. Like constructor injection, the dependencies remain immutable after being injected. Under the hood. Spring uses reflection to assign values to private fields.\nSHOW CODE Java @Component public class ServiceC { @Autowired private RepositoryC repositoryC; public void performAction() { repositoryC.doSomething(); } } @Component \u0026amp; @ComponentScan The @Component annotation in Spring is used to mark a class as spring-managed bean, allowing Spring to detect and register it as a bean in the application context. The @ComponentScan annotation is used to specify base packages that Spring should scan for @Component-annotated during configuration.\nSHOW CODE Java package com.example.myapp @Component public class MyService { public void performTask() { System.out.println(\"Task performed!\"); } } @Configuration @ComponentScan(basePackages = \"com.example.myapp\") public class AppConfig { } @Value \u0026amp; @Autowired \u0026amp; @Qualifier @Value The @Value annotation is used to inject values into fields, mathod parameters, and constructor arguments.\nSHOW CODE Java // Injects literal values @Value(\"Hello, World!\") private String message; // Injects from a properties file app.name=MySpringApp @Value(\"${app.name}\") private String appName; // Injects default values @Value(\"${app.version:1.0.0}\") private String appVersion; // Injects expression @Value(\"#{T(java.lang.Math).random() * 100}\") private double randomValue; @Autowired The @Autowired annotation is used for automatic dependency injection. It allows Spring resolve and inject the required bean into a class automatically by type.\nSHOW CODE Java // Field Injection @Component public class ServiceA { @Autowired private RepositoryA repositoryA; public void performTask() { repositoryA.doSomething(); } } // Setter Injection @Component public class ServiceB { private RepositoryB repositoryB; @Autowired public void setRepositoryB(RepositoryB repositoryB) { this.repositoryB = repositoryB; } } // Constructor Injection @Component public class ServiceB { private RepositoryB repositoryB; @Autowired public void setRepositoryB(RepositoryB repositoryB) { this.repositoryB = repositoryB; } } @Qualifier The @Qualifier annotation in Spring is used for resolve ambiguities when multiple beans of the same type are available in the application context.\nSHOW CODE Java @Component(\"repositoryImpl1\") public class RepositoryImpl1 implements Repository {} @Component(\"repositoryImpl2\") public class RepositoryImpl2 implements Repository {} @Component public class Service { @Autowired @Qualifier(\"repositoryImpl2\") private Repository repository; } Components of Spring Boot Spring Boot Starter: Simplifies dependency management by building commonly used dependencies, reducing the need for manual configuration.\nAuto Configuration: Automatically configures Spring Boot application beans and settings based on the libraries on the classpath, eliminating the need for extensive configuration in application.properties or XML files.\nSpring Boot Atuator: Provides production-ready features like monitoring, metrics, and health checks to ensure better application insights and management.\nEmbedded Server: Includes servers like Tomcat and Jetty, allowing applications to run as standalone programs, simplifying development and deployment.\nSpring Boot DevTools: A collection of tools that enhance the development experience by enabling features like hot reload and live reload for faster feedback.\nSpring Boot Auto Configuration Spring Boot looks for classes annotated with @Configuration and examines the dependencies in the classpath. The @Configuration annotation triggers the logic that looks for @Bean declarations within the class and registers those beans to be managed by the Spring container.\nIn a Spring Boot application, the main method typically calls the SpringApplication.run() method. This method takes the main application class (e.g., XXXApplication.class) as a parameter. The XXXAplication class is annotated with @SpringBootApplication which includes three key annotations: @SpringBootConfiguration, @EnableAutoConfiguration, and @ComponentScan.\n@SpringBootConfiguration is an alias for @Configurition. It indicates that the class contains Spring bean definitions, and Spring Boot will scan it for @Bean declarations.\n@EnableAutoConfiguration annotation tells Spring Boot to enable its auto-configuration mechanism. It looks for the file AutoConfiguration.imports inside the spring-boot-autoconfigure.jar dependency, which lists auto-configuration classes. Spring Boot automatically imports and executes every class that has the AutoConfiguration name at the end of the class name.\n# META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration org.springframework.boot.autoconfigure.aop.AopAutoConfiguration org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration ... @ComponentScan annotation tells Spring Boot to scan for Spring components (such as @Component, @Service, @Repository, etc.) in the specified packages or the entire classpath. By default, it scans from the package of the class that contains the annotation. To specify a different base package, the basePackages parameter can be set, like this:\n@ComponentScan(basePackages = {\u0026#34;com.mycompany\u0026#34;}) Common Annotations @Component vs. @Bean The @Component annotation is applied to a class to mark it as a bean managed by the Spring container. There are several specialized variants of this annotation: @Controller (for web controllers), @Service (for service layer components), and @Repository (for DAO layer components). In contrast, the @Bean annotation is used to mark a method within a class annotated with @Configuration, indicating that the method should return an object to be managed by the Spring container. This apporpach provides more control over bean creation and configuration, allowing for more explicit customization of the bean.\nSHOW CODE Java // Spring will detect UserService during classpath // scanning and manage it as a bean. @Component public class UserService { public String getUser() { return \"User\"; } } @Configuration public class AppConfig { @Bean public UserService userService() { // Explicitly creating and returning the bean return new UserService(); } } @ResposeBody The @ResponseBody annotation in Spring is used to indicate that a method\u0026rsquo;s return value should be written directly to the HTTP response body, rather than being treated as a view name, which is the default behavior in traditional Spring MVC controllers. The return value is automatically serialized into a format like JSON or XML, typically using Jackson, depending on the request\u0026rsquo;s Accept header.\nSHOW CODE Java @Controller public class MyRestController { @RequestMapping(\"/user\") @ResponseBody public User getUser() { return new User(\"John\", \"Doe\"); } } public class User { private String firstName; private String lastName; // Constructor, getters, and setters } In the above code, the User object will be automatically serialized into JSON format by Jackson when returned from the getUser() method. The @ResponseBody annotation ensures that the method\u0026rsquo;s return value is written directly to the HTTP response body, and Jackson handles the conversion to JSON.\n@Controller vs. @RestController The @Controller annotation is used to declare a class as a controller in Spring MVC. By default, methods within a @Controller-annotated class return a view name (e.g., home.jsp). If a method needs to return a value directly (such as JSON or XML), it should be annotated with @ResponseBody. In contrast, the @RestController annotation is a specialized version of @Controller used to define a controller for RESTful web services. It combines @Controller and @ResponseBody, meaning that the methods in a RestController-annotated class automatically return values written directly to the HTTP response body. This response is typically serialized into JSON or XML format by Jackson.\nSHOW CODE Java @Controller public class WebController { @RequestMapping(\"/home\") public String home() { return \"home\"; // returns home.jsp } } @Controller public class MyController { @RequestMapping(\"/greeting\") @ResponseBody public String greeting() { return \"Hello, World!\"; // The return value is written directly to the response body } } @RestController public class UserController { @RequestMapping(\"/api/user\") public User getUser() { return new User(\"Alice\", \"Smith\"); } } public class User { private String firstName; private String lastName; // Constructor, getters, and setters } @RequestBody, @RequestParam, @PathVariable The @RequestBody annotation is used to bind the body of an HTTP request to a method parameter. It is typically used with HTTP methods like POST, PUT, or PATCH to send data in formats such as JSON or XML. Spring automatically deserializes the request body into an obejct using a message converter, liek Jakson.\nSHOW CODE Java @RestController public class UserController { @PostMapping(\"/user\") public ResponseEntity\u0026lt;String\u0026gt; createUser(@RequestBody User user) { // User is automatically deserialized from the JSON request body return ResponseEntity.ok(\"User created: \" + user.getName()); } } The @RequestParam annotation binds a query parameter or form data to a method parameter. It is commonly used in GET or POST requests to retrive single query parameters. The annotation has optional attributes such as required (to specify if the parameter is mandatory) and defaultValue (to provide a default value when the parameter is absent).\nSHOW CODE Java @RestController public class SearchController { @GetMapping(\"/search\") public ResponseEntity\u0026lt;String\u0026gt; search(@RequestParam String query, @RequestParam(defaultValue = \"10\") int limit) { // query: the search term from the query string // limit: the number of results (defaults to 10 if not provided) return ResponseEntity.ok(\"Searching for: \" + query + \", Limit: \" + limit); } } The @PathVariable annotation binds a URL path variable to a method parameter, commonly used in RESTful web service to capture dynamic segments in the URL. For example, int the URL /user/{id}, the {id} part is dynamic, and the value of {id} will be extracted and passed to the method parameter.\nSHOW CODE Java @RestController public class UserController { // Regular expression to match both with and without the path variable @GetMapping(\"/user/{id:[a-zA-Z0-9]*}\") public ResponseEntity\u0026lt;String\u0026gt; getUser(@PathVariable(required = false) String id) { if (id == null) { return ResponseEntity.ok(\"Default User\"); } return ResponseEntity.ok(\"User ID: \" + id); } } Transformation between Object and Spring In Spring Boot, the transformation between objects and JSON is handled by the Jackson library which allows for easy serialization (converting an object to JSON) and deserialization (converting JSON to an object).\nSHOW CODE Java // When a controller returns an object, Spring Boot automatically // converts it to JSON @RestController public class UserController { @GetMapping(\"/user\") public User getUser() { return new User(1, \"John Doe\", \"john.doe@example.com\"); } } // When accessed via /user, the response is: { \"id\": 1, \"name\": \"John Doe\", \"email\": \"john.doe@example.com\" } // Spring Boot automatically converts the incoming JSON data into // an object when the object is a parameter in the controller method. @RestController public class UserController { @PostMapping(\"/user\") public String createUser(@RequestBody User user) { return \"User \" + user.getName() + \" created!\"; } } // Input JOSN: { \"id\": 2, \"name\": \"Jane Doe\", \"email\": \"jane.doe@example.com\" } ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/framework-and-tools/framework/backend/spring/1-spring-notes/","summary":"Core Concepts Loose Coupling Loose Coupling is a design principle that aims to reduce the dependencies between components within a system.\nInversion of Control (IoC) Inversion of Control is a design principle where the control of object creation and lifecycle management is transferred from the application code to an external container or framework.\nDependency Injection (DI) Dependency Injection is a design pattern commonly used in object-oriented programming, where the dependecies of a class are provided externally rather than being created within the class itself.","title":"Spring Notes"},{"content":"Enum In Java, an enum (short for \u0026ldquo;enumeration\u0026rdquo;) is used to define a collection of constants, such as days of the week or months of the year. An enum provides a type-safe way to handle constant values, and it can be used in a switch statement or for comparison using ==. Compared to a final constant in Java, an enum can contain fields, methods, and constructors. The values() method is used to retrive all the constants in an enum, and the valueOf() method is used to convert a string into an enum constant.\nSHOW CODE Java enum Day { SUNDAY(1), MONDAY(2), TUESDAY(3), WEDNESDA(4), THURSDAY(5), FRIDAY(6), SATURDAY(7); private final int dayNum; Day(int dayNum) { this.dayNum = dayNum; } public int getDayNum() { return dayNum; } public static Day fromNumber(int num) { for (Day day : Day.values()) { if (day.getDayNum() == num) { return day; } } throw new IllegalArgumentException(\"Invalid day number: \" + num); } @Override public String toString() { return name() + \"(\" + dayNum + \")\"; } } public class Solution { public static void main(String[] args) { for (Day d : Day.values()) { System.out.print(d + \"\\t\"); } System.out.println(\"\\n\" + Day.fromNumber(1)); // System.out.println(Day.fromNumber(8)); // Converts a string to enum constant System.out.println(Day.valueOf(\"MONDAY\")); } } Generics In Java, Generics is a mechanism that allows writing classes, interfaces, and methods with type parameters, often represented by T, E, K, and V, and allows calling them with different type parameters. It provides strong type safety checks at compile time, enhances code reusability, and eliminates the need for casting.\nBasic Generics SHOW CODE Java interface Pair { K getKey(); V getValue(); } class SimplePair\u0026lt;K,V\u0026gt; implements Pair\u0026lt;K,V\u0026gt; { private final K key; private final V value; public SimplePair(K key, V value) { this.key = key; this.value = value; } @Override public K getKey() { return key; } @Override public V getValue() { return value; } @Override public String toString() { return \"(\" + key + \",\" + value + \")\"; } } public class Main { public static void main(String[] args) { SimplePair\u0026lt;String, Integer\u0026gt; pair = new SimplePair\u0026lt;\u0026gt;(\"Signal\", 27); System.out.println(\"pair = \" + pair); String key = pair.getKey(); System.out.println(\"key = \" + key); Integer value = pair.getValue(); System.out.println(\"value = \" + value); } } Bounded Type Parameters Bounded Type Parameters in Java allow restricting the range of types when writing generic code. It can be categorized into four types: Upper Bounded Type, Lower Bounded Type, Unbounded Type, and Multiple Bounds.\nUpper Bounded Type In Java, Upper Bounded Wildcards are used to define upper bounded types. The syntax for an upper bounded wildcard is \u0026lt;T extends SomeClassOrInterface\u0026gt;, which indicates that the argument type T must be a subclass of SomeClassOrInterface or SomeClassOrInterface itself.\nSHOW CODE Java import java.util.List; public class Main { // Method that accepts a list of elements that are of type Number or its subclasses public static void printNumbers(List\u0026lt;? extends Number\u0026gt; list) { for (Number number : list) { System.out.println(number); } } public static void main(String[] args) { List\u0026lt;Integer\u0026gt; intList = List.of(1, 2, 3, 4); List\u0026lt;Double\u0026gt; doubleList = List.of(1.1, 2.2, 3.3); printNumbers(intList); // Valid, Integer is a subclass of Number printNumbers(doubleList); // Valid, Double is a subclass of Number } } Lower Bounded Type In Java, Lower Bounded Wildcards are used to define lower bounded types. The syntax for a lower bounded wildcard is \u0026lt;T super SomeClassOrInterface\u0026gt;, which indicates that the argument type T must be a super class of SomeClassOrInterface or SomeClassOrInterface itself.\nSHOW CODE Java import java.util.ArrayList; import java.util.List; // Custom class Person class Person { String name; Person(String name) { this.name = name; } @Override public String toString() { return \"Person{name='\" + name + \"'}\"; } } // Subclass Employee extends Person class Employee extends Person { double salary; Employee(String name, double salary) { super(name); this.salary = salary; } @Override public String toString() { return \"Employee{name='\" + name + \"', salary=\" + salary + \"}\"; } } public class Main { // Method that accepts a list of Person or its superclasses (e.g., Object) // This method can add Employee objects to the list. public static void addEmployees(List\u0026lt;? super Employee\u0026gt; list) { list.add(new Employee(\"Alice\", 50000)); list.add(new Employee(\"Bob\", 60000)); list.add(new Employee(\"Charlie\", 70000)); } public static void main(String[] args) { // Create a list of Person, which is a superclass of Employee List\u0026lt;Person\u0026gt; personList = new ArrayList\u0026lt;\u0026gt;(); // Add Employee objects to the personList using the addEmployees method addEmployees(personList); // Print the list to see the added Employee objects for (Person person : personList) { System.out.println(person); } } } SHOW OUTPUT Output Employee{name='Alice', salary=50000.0} Employee{name='Bob', salary=60000.0} Employee{name='Charlie', salary=70000.0} Unbounded Type In Java, the Unbounded Type is represented by using the unbounded wildcard ?, which indicates that no restrictions are placed on the type of an argument passed to the method. It is commonly used when passing a collection of elements to a method where the specific type of the elements is not important. With an unbounded wildcard, elements can be read but cannot be added to the collection (except null) inside the methods.\nSHOW CODE Java import java.util.ArrayList; import java.util.List; class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } @Override public String toString() { return \"Person(\" + name + \", \" + age + \")\"; } } public class Main { public static void printList(List\u0026lt;?\u0026gt; list) { // Iterate over the list and print each element list.add(null); // list.add(1); for (Object element : list) { System.out.println(element); } } public static void main(String[] args) { // Create lists of different types List\u0026lt;String\u0026gt; stringList = new ArrayList\u0026lt;\u0026gt;(); stringList.add(\"Hello\"); stringList.add(\"World\"); List\u0026lt;Integer\u0026gt; intList = new ArrayList\u0026lt;\u0026gt;(); intList.add(10); intList.add(20); List\u0026lt;Object\u0026gt; objectList = new ArrayList\u0026lt;\u0026gt;(); objectList.add(\"Some String\"); objectList.add(100); objectList.add(1.1); objectList.add('a'); objectList.add(true); objectList.add(new Person(\"Signal\", 18)); objectList.add(null); // Call the printList method for each list System.out.println(\"String List:\"); printList(stringList); // Works with List\u0026lt;String\u0026gt; System.out.println(\"\\nInteger List:\"); printList(intList); // Works with List\u0026lt;Integer\u0026gt; System.out.println(\"\\nObject List:\"); printList(objectList); // Works with List\u0026lt;Object\u0026gt; } } SHOW OUTPUT Output String List: Hello World Integer List: 10 20 Object List: Some String 100 1.1 a true Person(Signal, 18) null null Multiple Bounds In Java, a Multiple Bounds constraint allows the argument type T passed to a method to extend multiple types or implement multiple interfaces. This is commonly achieved using the \u0026amp; operator. The syntax for multiple bounds is \u0026lt;T extends classType \u0026amp; Interface1 \u0026amp; Interface2\u0026gt;, indicating that the argument type T must extend the class classType and implement both Interface1 and Interface2.\nSHOW CODE Java // Interface 1 interface CanFly { void fly(); } // Interface 2 interface CanSwim { void swim(); } // A base class for animals class Animal { String name; Animal(String name) { this.name = name; } } // Class that implements both interfaces class Duck extends Animal implements CanFly, CanSwim { Duck(String name) { super(name); } @Override public void fly() { System.out.println(name + \" is flying.\"); } @Override public void swim() { System.out.println(name + \" is swimming.\"); } } // A class that uses multiple bounds in its type parameter class AnimalAction\u0026lt;T extends Animal \u0026 CanFly \u0026 CanSwim\u0026gt; { T animal; AnimalAction(T animal) { this.animal = animal; } void performActions() { animal.fly(); animal.swim(); } } public class Main { public static void main(String[] args) { // Create a Duck object Duck duck = new Duck(\"Dodo\"); // Create an AnimalAction object for Duck, which extends Animal and implements CanFly and CanSwim AnimalAction\u0026ltDuck\u0026gt; action = new AnimalAction\u0026lt;\u0026gt;(duck); // Perform actions on the Duck action.performActions(); } } Reflection Reflection in Java is a feature that allows inspecting and manipulating the properties or behaviors of classes, methods, fields, and constructors at runtime. It is commonly used to examine class information, access private methods and fields, invoke methods dynamically, and create objects dynamically using the Java Reflection API. The Java Reflection API is provided by the java.lang.reflect package and the java.lang.Class class. Some of the key classes and methods in this API include:\nClass: Represents the class of an object and provides methods like getName(), getDeclaredMethods(), getDeclaredFields(), and others to examine the class\u0026rsquo;s metadata. Method: Represents a method of a class and allows invoking it dynamically using methods like invoke(). Field: Represents a field (variable) in a class and allows accessing or modifying its value dynamically. Constructor: Represents a constructor in a class and allows creating new instances dynamically using methods like newInstance(). SHOW CODE Java package dev.signalyu.warmup; import java.lang.reflect.*; class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } private void sayHello() { System.out.println(\"Hello, \" + name); } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } } public class Main { public static void main(String[] args) throws Exception { // Create a new Person object Person person = new Person(\"John\", 30); // Get the Class object associated with the Person class Class\u003c?\u003e clazz = person.getClass(); // Get class name System.out.println(\"Class name: \" + clazz.getName()); // Get declared methods Method[] methods = clazz.getDeclaredMethods(); for (Method method : methods) { System.out.println(\"Method: \" + method.getName()); } // Get declared fields Field[] fields = clazz.getDeclaredFields(); for (Field field : fields) { System.out.println(\"Field: \" + field.getName()); } // Accessing a private field via reflection Field field = clazz.getDeclaredField(\"name\"); field.setAccessible(true); // Make the private field accessible System.out.printf(\"Private field: 'name'=%s\\n\", field.get(person)); // Get the 'sayHello' method Method method = clazz.getDeclaredMethod(\"sayHello\"); // Make the private method accessible method.setAccessible(true); // Invoke the method on the 'person' object method.invoke(person); // Dynamically load the Person class Class\u003c?\u003e clazz2 = Class.forName(\"dev.signalyu.warmup.Person\"); // Get the constructor that takes a String argument Constructor\u003c?\u003e constructor = clazz2.getConstructor(String.class, int.class); // Create an instance of Person using reflection Person Signal = (Person) constructor.newInstance(\"Signal\", 18); System.out.println(\"Signal = \" + Signal); } } SHOW OUTPUT Output Class name: dev.signalyu.warmup.Person Method: getName Method: toString Method: setName Method: sayHello Method: getAge Field: name Field: age Private field: 'name'=John Hello, John Signal = Person{name='Signal', age=18} Annotations Annotations in Java are a form of metadata used to provide additional information that does not directly affect the execution of the code. They are commonly used to convey instructions to the compiler (such as detecting errors or supressing warnings) or to support runtime processing. Annotations are prefixed with the @ symbol and can be applied to classes, methods, firlds, and other program elements.\nCommon meta annotations, such as @Target adn @Retension, are used to specify how and where an annotation can be applied. The @Target annotation defines the valid program elements for an annotation, including:\nElementType.TYPE: The annotation can be applied to a class or interface. ElementType.METHOD: The annotation can be applied to a method. ElementType.FIELD: The annotation can be applied to a field. The @Retention annotation specifies the lifespan of the annotation. Foe example, using @Retention(RetentionPolicy).RUNTIME indicates that the annotation is available at runtime for reflection.\nTo customize an annotation in Java, the first step is to define its basic structure using the @interface keyword. Elements (parameters) can be included in the annotation, with or without default values, depending on the requirements.\nNext, meta-annotation such as @Target and @Retention are added to specify where the annotation can be applied and how long it will be retained.\nOnce the annotation is defined, it can be applied according to the specified @Target (e.g., on methods, classes, or fields).\nThe final step is to define the logic for processing the annotation, typically achieved through reflection at runtime.\nSHOW CODE: Login Interception Login Interception @Getter public enum ResultCodeEnum { LOGIN_AUTH(208, \"Not logged in\"); private final int code; private final String message; ResultCodeEnum(int code, String message) { this.code = code; this.message = message; } } public class RedisConstant { /** * The prefix for user login keys in Redis. */ public static final String USER_LOGIN_KEY_PREFIX = \"user:login:\"; } public class AuthContextHolder { private static final ThreadLocal\u0026lt;Long\u0026gt; userId = new ThreadLocal\u0026lt;\u0026gt;(); /** * Sets the user ID in the thread-local context. * * @param _userId The user ID to set. */ public static void setUserId(Long _userId) { userId.set(_userId); } /** * Gets the user ID from the thread-local context. * * @return The current user ID. */ public static Long getUserId() { return userId.get(); } /** * Removes the user ID from the thread-local context. */ public static void removeUserId() { userId.remove(); } } @Target({ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Inherited @Documented public @interface AppLogin { /** * Indicates if login is required for the annotated method. * Default is true. */ boolean required() default true; } @Aspect @Component public class AppLoginAspect { @Autowired private RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate; /** * Intercepts methods annotated with @AppLogin to enforce login validation. * * @param joinPoint The proceeding join point for the intercepted method. * @param appLogin The AppLogin annotation instance. * @return The result of the intercepted method execution. * @throws Throwable If an error occurs during method execution. */ @SneakyThrows @Around(\"execution(* com.atApp.tingshu.*.api.*.*(..)) \u0026\u0026 @annotation(appLogin)\") public Object loginAspect(ProceedingJoinPoint joinPoint, AppLogin appLogin) { // Extract the token from the request header String token = getTokenFromRequest(); // Check login status in Redis String loginKey = RedisConstant.USER_LOGIN_KEY_PREFIX + token; UserInfoVo userInfoVo = (UserInfoVo) redisTemplate.opsForValue().get(loginKey); // If login is required and user is not authenticated, throw exception if (appLogin.required() \u0026\u0026 userInfoVo == null) { throw new AppException(ResultCodeEnum.LOGIN_AUTH); } // If user is authenticated, set the user ID in the thread-local context if (userInfoVo != null) { AuthContextHolder.setUserId(userInfoVo.getId()); } try { // Proceed with the method execution return joinPoint.proceed(); } finally { // Ensure that user ID is cleared after the method execution AuthContextHolder.removeUserId(); } } /** * Extracts the token from the HTTP request header. * * @return The token string. */ private String getTokenFromRequest() { RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes(); ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes) requestAttributes; HttpServletRequest request = servletRequestAttributes.getRequest(); return request.getHeader(\"token\"); } } Serialization \u0026amp; Deserialization In Java, Serialization and Deserialzation are processes used to convert objects into a byte stream and restore them back into objects, respectively. These processes are essential for storing objects in files, transmitting them over a network, or preserving their state.\nSerialization involves converting an object into a byte stream. To serialize an object, its class must implement the java.io.Serializable interface, which is a marker interface without any methods. The ObjectOutputStream class is used to write the serialized object to a file or another output stream. A serialVersionUID is automatically generated if not explicitly defined, but it is recommended to provide one manually to ensure compatibility during deserialization. Fields marked as transcient are not serialized. Additionally, any objects regerenced by the serialized object are also serialized, provided they implement the Serializable interface.\nDeserialization is the process of reconstructing a serialized object back into a Java object. For deserialization to succeed, the class must be available in the classpath. This process is performed using the ObjectInputStream class, which reads the byte stream and restores the object to its original state.\nSHOW CODE Java import java.io.*; // Define a Serializable class class Person implements Serializable { private static final long serialVersionUID = 1L; // Ensures class compatibility during deserialization private String name; private int age; // Transient field will not be serialized private transient String password; public Person(String name, int age, String password) { this.name = name; this.age = age; this.password = password; } @Override public String toString() { return \"Person{name='\" + name + \"', age=\" + age + \", password='\" + password + \"'}\"; } } public class Main { public static void main(String[] args) { Person person = new Person(\"Signal Yu\", 18, \"securePassword\"); // Serialize the object try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"person.ser\"))) { oos.writeObject(person); System.out.println(\"Object serialized successfully.\"); } catch (IOException e) { e.printStackTrace(); } // Deserialize the object try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"person.ser\"))) { Person deserializedPerson = (Person) ois.readObject(); System.out.println(\"Deserialized object: \" + deserializedPerson); } catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } } } SHOW OUTPUT Output Object serialized successfully. Deserialized object: Person{name='Signal Yu', age=18, password='null'} Lambda Expression Runnable SHOW CODE Java public class Test { public static void main(String[] args) { // Java 8 之前 Runnable runnable = new Runnable() { @Override public void run() { System.out.println(\"Inside Runnable 1\"); } }; new Thread(runnable).start(); // Java 8 - Lambda 语法 Runnable runnableLambda = () -\u003e {System.out.println(\"Inside Runnable 2\");}; new Thread(runnableLambda).start(); new Thread(() -\u003e System.out.println(\"Inside Runnable 3\")).start(); } } Comparator SHOW CODE Java public class Test { public static void main(String[] args) { // JAVA 8 之前 Comparator\u0026lt;Integer\u0026gt; comparator = new Comparator\u0026lt;Integer\u0026gt;() { @Override public int compare(Integer o1, Integer o2) { /** * o1 \u003c o2 -\u003e -1 * o1 == o2 -\u003e 0 * o1 \u003e o2 -\u003e 1 */ return o1.compareTo(o2); } }; System.out.println(comparator.compare(1, 2)); // -1 /** * JAVA 8 */ // Comparator\u0026lt;Integer\u0026gt; comparatorLambda1 = (Integer a, Integer b) -\u003e a.compareTo(b); Comparator\u0026lt;Integer\u0026gt; comparatorLambda1 = Comparator.naturalOrder(); System.out.println(comparatorLambda1.compare(1, 2)); // -1 // Comparator\u0026lt;Integer\u0026gt; comparatorLambda2 = (a, b) -\u003e b.compareTo(a); Comparator\u0026lt;Integer\u0026gt; comparatorLambda2 = Comparator.reverseOrder(); System.out.println(comparatorLambda2.compare(1, 2)); // 1 int[] nums = new int[]{2, 1, 4, 3}; System.out.println(\"nums = \" + Arrays.toString(nums)); Arrays.sort(nums); // 默认为升序排序 // 倒序排序 Integer[] newNums = Arrays.stream(nums).boxed().toArray(Integer[]::new); Arrays.sort(newNums, Comparator.reverseOrder()); } } Local Variables in Lambda Expression SHOW CODE Java public class Test { public static void main(String[] args) { /** * 1. The variable used in a lambda expression must be effectively final, * meaning its value cannot change after it has been assigned. * 2. A lambda captures the values of local variables, not the variables * themselves. * 3. Local variables in a lambda cannot have the same name as variables * in the enclosing scope to avoid shadowing. */ int num = 10; // effectively final Runnable r = () -\u003e System.out.println(num); r.run(); // Error: Variable num is already defined in the scope // Runnable r = () -\u003e { // int num = 20; // Compile-time error // System.out.println(num); // }; } } Functional Interface Consumer SHOW CODE Java import java.util.Arrays; import java.util.List; import java.util.function.Consumer; public class Test { public static void main(String[] args) { List\u0026lt;String\u0026gt; items = Arrays.asList(\"One\", \"Two\", \"Three\"); /** * Consumer 接收一个参数并执行一些操作，不返回结果 * Consumer 有 accept 和 andThen 两个方法 * accept 用于接收参数，andThen 用于链接多个 Consumer */ // 示例1：定义一个 Consumer，它将打印传入的字符串 Consumer\u0026lt;String\u0026gt; printConsumer = s -\u003e System.out.println(\"打印消息: \" + s); printConsumer.accept(\"Hello, World!\"); // 输出: 打印消息: Hello, World! // 示例 2：Consumer 链式操作 Consumer\u0026lt;String\u0026gt; printItem = item -\u003e System.out.print(\"打印: \" + item + \"\\t\"); Consumer\u0026lt;String\u0026gt; printLength = item -\u003e System.out.println(\"长度: \" + item.length()); Consumer\u0026lt;String\u0026gt; combined = printItem.andThen(printLength); // 将两个 Consumer 组合在一起 // 使用 forEach 遍历集合并执行组合操作 items.forEach(combined); // items.forEach(item -\u003e { // System.out.print(\"打印: \" + item + \"\\t\"); // System.out.println(\"长度: \" + item.length()); // }); } } BiConsumer SHOW CODE Java import java.util.Arrays; import java.util.List; import java.util.function.BiConsumer; // 定义 Student 记录类，包含学生的姓名和活动列表 record Student(String name, List\u0026lt;String\u0026gt; activities) { } //class Student { // private final String name; // private final List\u0026lt;String\u0026gt; activities; // // public Student(String name, List\u0026lt;String\u0026gt; activities) { // this.name = name; // this.activities = activities; // } // // public String getName() { // return name; // } // // public List\u0026lt;String\u0026gt; getActivities() { // return activities; // } //} class StudentDataBase { // 提供学生数据，返回一个包含多个学生的列表 public static List\u0026lt;Student\u0026gt; getAllStudents() { return Arrays.asList( new Student(\"Alice\", Arrays.asList(\"Swimming\", \"Basketball\")), new Student(\"Bob\", Arrays.asList(\"Cycling\", \"Chess\")), new Student(\"Charlie\", Arrays.asList(\"Running\", \"Reading\")) ); } } class Test { public static void main(String[] args) { /** * BiConsumer 适用于对两个参数执行操作，但不需要返回结果的场景。 */ // BiConsumer 接口用于处理学生姓名和活动列表 BiConsumer\u0026lt;\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; studentBiConsumer = (name, activities) -\u003e System.out.println(name + \" : \" + activities); // 获取学生列表 List\u0026lt;Student\u0026gt; students = StudentDataBase.getAllStudents(); // 使用 forEach 遍历每个学生对象并输出其姓名和活动列表 students.forEach(student -\u003e studentBiConsumer.accept(student.name(), student.activities())); } } Predicate SHOW CODE Java import java.util.Arrays; import java.util.List; import java.util.function.Predicate; class Test { public static void main(String[] args) { /* Predicate 用于测试输入对象是否满足某种条件，常用于过滤、条件判断等场景 Predicate 提供了 and, or 和 negate 三个默认方法 Predicate 提供了 isEqual 和 not (Java 11) 两个静态方法 */ // 示例 1: Predicate\u0026lt;Integer\u0026gt; isEven = num -\u003e num % 2 == 0; List\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6); List\u0026lt;Integer\u0026gt; evenNumbers = numbers.stream() .filter(isEven) .toList(); System.out.println(\"偶数: \" + evenNumbers); // 输出: 偶数: [2, 4, 6] // 示例 2: Predicate\u0026lt;Integer\u0026gt; isOdd = num -\u003e num % 2 == 0; Predicate\u0026lt;Integer\u0026gt; isGreaterThanFive = num -\u003e num \u003e 5; // 使用 and() 方法组合两个条件 Predicate\u0026lt;Integer\u0026gt; isOddAndGreaterThanFive = isOdd.and(isGreaterThanFive); System.out.println(isOddAndGreaterThanFive.test(7)); // 输出: true System.out.println(isOddAndGreaterThanFive.test(3)); // 输出: false // 示例 3 List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\", \"Alice\"); // 使用 isEqual 和 not 来筛选出不等于 \"Alice\" 的名字 List\u0026lt;String\u0026gt; filteredNames = names.stream() .filter(Predicate.not(Predicate.isEqual(\"Alice\"))) .toList(); System.out.println(filteredNames); // Output: [Bob, Charlie] } } BiPredicate SHOW CODE Java import java.util.function.BiPredicate; class Test { public static void main(String[] args) { // BiPredicate 适合需要对两个参数进行测试或判断的情况 // 示例 1 BiPredicate\u0026lt;Integer, Integer\u0026gt; isSumGreaterThanTen = (a, b) -\u003e (a + b) \u003e 10; BiPredicate\u0026lt;Integer, Integer\u0026gt; isProductEven = (a, b) -\u003e (a * b) % 2 == 0; BiPredicate\u0026lt;Integer, Integer\u0026gt; combined = isSumGreaterThanTen.and(isProductEven); System.out.println(combined.test(5, 6)); // 输出: true，因为和大于10且乘积为偶数 System.out.println(combined.test(5, 5)); // 输出: false，因为乘积为奇数 } } Function SHOW CODE Java import java.util.function.Function; class Test { public static void main(String[] args) { /** * Function 接受一个参数并返回一个结果 * apply(T t)：对给定的参数执行函数操作并返回结果 * andThen()：在当前函数之后执行另一个函数 * compose()：在当前函数之前执行另一个函数 */ // 示例 1 Function\u0026lt;Integer, Integer\u0026gt; squareFunction = x -\u003e x * x; Integer result = squareFunction.apply(5); System.out.println(\"5 的平方是: \" + result); // 示例 2 Function\u0026lt;Integer, Integer\u0026gt; multiplyBy2 = x -\u003e x * 2; Function\u0026lt;Integer, Integer\u0026gt; add3 = x -\u003e x + 3; // 使用 andThen：先乘以 2，再加 3 Integer result1 = multiplyBy2.andThen(add3).apply(5); System.out.println(\"(5 * 2) + 3 的结果是: \" + result1); // 使用 compose：先加 3，再乘以 2 Integer result2 = multiplyBy2.compose(add3).apply(5); System.out.println(\"(5 + 3) * 2 的结果是: \" + result2); } } BiFunction SHOW CODE Java import java.util.function.BiFunction; class Test { public static void main(String[] args) { // BiFunction takes two arguments and returns a result BiFunction\u0026lt;Integer, Integer, Integer\u0026gt; sum = (a, b) -\u003e a + b; int result = sum.apply(5, 3); // Returns 8 System.out.println(\"Result: \" + result); } } Method Reference SHOW CODE Java import java.util.Arrays; import java.util.List; import java.util.function.Function; import java.util.function.Supplier; public class Test { public static void main(String[] args) { /** * Method reference is a shortcut for writing the lambda function */ // 示例 1 List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"); // 使用 Lambda 表达式 names.stream().map(name -\u003e name.toUpperCase()).forEach(name -\u003e System.out.println(name)); // 使用Method Reference names.stream().map(String::toUpperCase).forEach(System.out::println); /** * 构造器引用是Method Reference的特例 * 用法如下： * () -\u003e new Person() \u003c--\u003e Person::new; * (name) -\u003e new Person() \u003c--\u003e Person::new; */ // 示例 2 // Using () -\u003e new Person() Supplier\u0026lt;Person\u0026gt; personSupplier = () -\u003e new Person(); Person p1 = personSupplier.get(); System.out.println(p1); // Output: Person{name='Default'} // Using Person::new Supplier\u0026lt;Person\u0026gt; personSupplierRef = Person::new; Person p2 = personSupplierRef.get(); System.out.println(p2); // Output: Person{name='Default'} // 示例 3 // Using (name) -\u003e new Person(name) Function\u0026lt;String, Person\u0026gt; personFunction = (name) -\u003e new Person(name); Person p3 = personFunction.apply(\"Alice\"); System.out.println(p3); // Output: Person{name='Alice'} // Using Person::new Function\u0026lt;String, Person\u0026gt; personFunctionRef = Person::new; Person p4 = personFunctionRef.apply(\"Bob\"); System.out.println(p4); // Output: Person{name='Bob'} } } class Person { private String name; // Default constructor public Person() { this.name = \"Default\"; } // Constructor with a parameter public Person(String name) { this.name = name; } @Override public String toString() { return \"Person{name='\" + name + \"'}\"; } } Stream API Introduction to Stream API A Stream is a sequence of elements designed for processing in a functional and sequential manner. Stream operations are lazy, meaning they are not executed until a terminal operation (e.g., collect, forEach, reduce, count) is invoked. Streams are immutable, allowing access to elements without modifying the source. Java provides two types of streams: stream (for sequential processing) and parallel stream (for concurrent processing).\nCollections V.S. Stream\nIn Java, Collections are data structures designed for storing and manipulating data, whereas Streams are a sequence of elements which enable functional-style operations on data. Collections allow data modification, whereas Streams provide read-only access to elements. Operations on Collections are executed eagerly, while Streams operations are lazy and only executed when a terminal operation is invoked. Collections can be reused multiple times, but Streams are single-use and cannot be reused after processing. Debugging Streams: the peek() method can be used to inspect the intermediate results during stream operations.\nArrays.asList(\u0026#34;hello\u0026#34;, \u0026#34;hi\u0026#34;).stream() .peek(System.out::println) .filter(s -\u0026gt; s.length() \u0026gt; 2) .peek(s -\u0026gt; System.out.println(\u0026#34;Filtered: \u0026#34; + s)) .map(String::toUpperCase) .peek(s -\u0026gt; System.out.println(\u0026#34;Mapped: \u0026#34; + s)) .collect(Collectors.toList()); hello Filtered: hello Mapped: HELLO hi flatMap The flatMap method is used to transform each element in a stream into another stream and then flatten the resulting streams into a single stream.\nSHOW CODE Java import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class Test { public static void main(String[] args) { List\u0026lt;List\u0026lt;String\u0026gt; nestedList = Arrays.asList( Arrays.asList(\"A\", \"B\"), Arrays.asList(\"C\", \"D\"), Arrays.asList(\"E\", \"F\") ); List\u0026lt;String\u0026gt; flattenedList = nestedList.stream() .flatMap(List::stream) // Flatten the nested lists .map(String::toLowerCase) // Convert each string to lowercase .collect(Collectors.toList()); System.out.println(flattenedList); // Output: [a, b, c, d, e, f] } } The map method transforms each element into another type, while the flatMap method transforms and flaten streams into a single stream.\ndistinct(), count(), sorted() The distinct() method eliminates duplicate elements from the stream. The count() method calculates the total number of elements in the stream. The sorted() method sorts the elements of the stream.\nSHOW CODE Java List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Alice\", \"Charlie\"); long count = names.stream() .distinct() // Optional: Count unique elements .count(); System.out.println(count); // Output: 3 List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"); List\u0026lt;String\u0026gt; sortedByLength = names.stream() .sorted(Comparator.comparingInt(String::length)) .collect(Collectors.toList()); System.out.println(sortedByLength); // Output: [Bob, Alice, Charlie] reduce() The reduce() method in Java 8 Streams is a terminal operation used to combine elements in a stream into a single result by repeatedly applying a binary operator.\nSHOW CODE Java // Summing numbers List\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5); int sum = numbers.stream().reduce(0, Integer::sum); System.out.println(sum); // Output: 15 // Finding maximum values List\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5); int max = numbers.stream().reduce(Integer.MIN_VALUE, Integer::max); System.out.println(max); // Output: 5 // Concatenating Strings List\u0026lt;String\u0026gt; words = Arrays.asList(\"Java\", \"Stream\", \"Reduce\"); String concatenated = words.stream().reduce(\"\", String::concat); System.out.println(concatenated); // Output: JavaStreamReduce // Product of numbers List\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4); int product = numbers.stream().reduce(1, (a, b) -\u003e a * b); System.out.println(product); // Output: 24 limit(), skip() The limit() method retrieves a specified number of elements from a stream. The skip() method discards the first specified number of elements in a stream.\nSHOW CODE Java List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\", \"David\", \"Eve\"); List\u0026lt;String\u0026gt; paginatedNames = names.stream() .skip(2) // Skip the first 2 elements .limit(2) // Take the next 2 elements .collect(Collectors.toList()); System.out.println(paginatedNames); // Output: [Charlie, David] allMatch(), anyMatch(), noneMatch() The allMatch() method verifies if all elements in a stream satisfy the given predicate. The anyMatch() method determines if any element in the stream matches the specified predicate. The noneMatch() method confirms if no element in the stream matches the specified predicate.\nSHOW CODE Java List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"); // Check if all names are longer than 3 characters boolean allLongNames = names.stream().allMatch(name -\u003e name.length() \u003e 3); System.out.println(allLongNames); // Output: true // Check if any name starts with 'A' boolean anyStartsWithA = names.stream().anyMatch(name -\u003e name.startsWith(\"A\")); System.out.println(anyStartsWithA); // Output: true // Check if no name is shorter than 3 characters boolean noneShortNames = names.stream().noneMatch(name -\u003e name.length() \u003c 3); System.out.println(noneShortNames); // Output: true findAny(), findFirst() The findAny() method retrieves an arbitrary element from a stream, particularly useful for parallel processing. The findFirst() method fetches the first element from a stream based on its encounter order.\nSHOW CODE Java List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"); Optional\u0026lt;String\u0026gt; anyName = names.stream().findAny(); System.out.println(anyName.orElse(\"No names found\")); // Output: Alice (or any other element) List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"); Optional\u0026lt;String\u0026gt; firstName = names.stream().findFirst(); System.out.println(firstName.orElse(\"No names found\")); // Output: Alice Factory Methods: Of(), generate(), iterate() Stream.of() is used to create a stream from a fixed set of elements.\nSHOW CODE Java import java.util.stream.Stream; public class Main { public static void main(String[] args) { Stream\u0026lt;String\u0026gt; stream = Stream.of(\"Apple\", \"Banana\", \"Cherry\"); stream.forEach(System.out::println); } } Stream.generate() method is used to create an infinite stream of elements generated by a Supplier.\nSHOW CODE Java import java.util.stream.Stream; public class Main { public static void main(String[] args) { Stream\u0026lt;String\u0026gt; infiniteStream = Stream.generate(() -\u003e \"Hello\"); infiniteStream.limit(5).forEach(System.out::println); } } Stream.iterate() is used to create an infinite stream by applying a function repeatedly to a seed value.\nSHOW CODE Java import java.util.Random; Stream\u0026lt;Integer\u0026gt; randomNumbers = Stream.generate(() -\u003e new Random().nextInt(100)); randomNumbers.limit(5).forEach(System.out::println); When working with infinite streams, such as those created by Stream.generate() or Stream.iterate(), always use operations like limit() to prevent infinite processing.\nTerminal Operations: joining(), counting(), mapping() The joining method is a terminal operation used to concatenate the elements of a stream into a single String. By default, the elements are joined without a delimiter, but a custom delimiter, prefix, and suffix can also be specified.\nSHOW CODE Java import java.util.*; import java.util.stream.Collectors; public class JoiningExample { public static void main(String[] args) { List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"); // Simple joining String result1 = names.stream().collect(Collectors.joining()); System.out.println(result1); // AliceBobCharlie // Joining with a delimiter String result2 = names.stream().collect(Collectors.joining(\", \")); System.out.println(result2); // Alice, Bob, Charlie // Joining with delimiter, prefix, and suffix String result3 = names.stream().collect(Collectors.joining(\", \", \"[\", \"]\")); System.out.println(result3); // [Alice, Bob, Charlie] } } The counting() method is a terminal operation used to count the number of elements in a stream and return the count as a long.\nSHOW CODE Java import java.util.*; import java.util.stream.Collectors; public class CountingExample { public static void main(String[] args) { List\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5); // Counting the elements in the stream long count = numbers.stream().collect(Collectors.counting()); System.out.println(count); // 5 } } The mapping() method is an intermediate collector that applies a function to the elements of a stream before passing the transformed elements to another collector for final processing.\nSHOW CODE Java import java.util.*; import java.util.stream.Collectors; public class MappingExample { public static void main(String[] args) { List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"); // Convert names to uppercase and join them String result = names.stream() .collect(Collectors.mapping(String::toUpperCase, Collectors.joining(\", \"))); System.out.println(result); // ALICE, BOB, CHARLIE } } Terminal Operations: minBy(), maxBy(), groupingBy() The minBy() collector finds the minimum element in a stream based on a specified Comparator and returns the result as an Optional.\nSHOW CODE Java Optional min = Stream.of(3, 5, 1, 2) .collect(Collectors.minBy(Comparator.naturalOrder())); System.out.println(min.orElse(-1)); // Output: 1 The maxBy() collector finds the maximum element in a stream based on a specified Comparator and returns the result as an Optional.\nSHOW CODE Java Optional max = Stream.of(3, 5, 1, 2) .collect(Collectors.maxBy(Comparator.naturalOrder())); System.out.println(max.orElse(-1)); // Output: 5 The groupingBy() collector groups the elements of a stream based on a classification function and returns the grouped data as a Map.\nSHOW CODE Java Map\u0026lt;Integer, List\u0026lt;String\u0026gt;\u0026gt; groupedByLength = Stream.of(\"cat\", \"dog\", \"bird\", \"fox\") .collect(Collectors.groupingBy(String::length)); System.out.println(groupedByLength); // Output: {3=[cat, dog, fox], 4=[bird]} Numeric Stream A Numeric Stream in Java is a specialized type of stream that operates specifically on numeric values. There are three types of numeric streams: IntStream, LongStream, and Double Stream, which handle int, long, and double values, respectively. Numeric streams eliminate the overhead of autoboxing and provide commonly used methods such as sum() and max() for performing operations on numeric data, making them more efficient compared to regular Stream types.\nSHOW CODE Java IntStream.range(1, 5).forEach(System.out::println); // Output: 1 2 3 4 IntStream.rangeClosed(1, 5).forEach(System.out::println); // Output: 1 2 3 4 5 long count = IntStream.range(1, 10).count(); System.out.println(count); // Output: 9 int sum = IntStream.range(1, 5).sum(); System.out.println(sum); // Output: 10 (1 + 2 + 3 + 4) OptionalInt max = IntStream.range(1, 5).max(); max.ifPresent(System.out::println); // Output: 4 OptionalInt min = IntStream.range(1, 5).min(); min.ifPresent(System.out::println); // Output: 1 OptionalDouble average = IntStream.range(1, 5).average(); average.ifPresent(System.out::println); // Output: 2.5 List\u0026lt;String\u0026gt; numbers = Arrays.asList(\"1\", \"2\", \"3\", \"4\"); IntStream intStream = numbers.stream().mapToInt(Integer::parseInt); intStream.forEach(System.out::println); // Output: 1, 2, 3, 4 List\u0026lt;String\u0026gt; numbers = Arrays.asList(\"1.1\", \"2.2\", \"3.3\", \"4.4\"); DoubleStream doubleStream = numbers.stream().mapToDouble(Double::parseDouble); doubleStream.forEach(System.out::println); // Output: 1.1, 2.2, 3.3, 4.4 List\u0026lt;String\u0026gt; numbers = Arrays.asList(\"10\", \"20\", \"30\", \"40\"); LongStream longStream = numbers.stream().mapToLong(Long::parseLong); longStream.forEach(System.out::println); // Output: 10, 20, 30, 40 IntStream intStream = IntStream.range(1, 5); Stream\u0026lt;String\u0026gt; stringStream = intStream.mapToObj(Integer::toString); stringStream.forEach(System.out::println); // Output: \"1\", \"2\", \"3\", \"4\" ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/programming/java/1-java-programming-notes/","summary":"Enum In Java, an enum (short for \u0026ldquo;enumeration\u0026rdquo;) is used to define a collection of constants, such as days of the week or months of the year. An enum provides a type-safe way to handle constant values, and it can be used in a switch statement or for comparison using ==. Compared to a final constant in Java, an enum can contain fields, methods, and constructors. The values() method is used to retrive all the constants in an enum, and the valueOf() method is used to convert a string into an enum constant.","title":"Java Programming Notes"}]