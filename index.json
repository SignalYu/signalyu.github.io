[{"content":"1. Solid Principle 1.1 Single Responsibility Principle A class should have only one reason to change, meaning each class should focus on a single functionality or responsibility.\nSHOW CODE Single Responsibility Principle import java.io.IOException; import java.util.*; import java.util.regex.*; import com.fasterxml.jackson.databind.ObjectMapper; /** * 1. User class is only used to represent entity. * 2. UserValidator class is solely responsible for validating user objects. * 3. Store class is only used to manage user objects storage. * 4. UserPersistenceService class is dedicated to save the user data. * 5. UserController is solely used to handle incoming requests (in this case, creating users form JSON input). */ /* \u0026lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.18.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; */ /** * Represents a user with basic details. * User class is only used to represent entity. */ class User { private String name; private String email; private String address; public User() {} public User(String name, String email, String address) { this.name = name; this.email = email; this.address = address; } // Getters and setters public String getName() { return name; } public void setName(String name) { this.name = name; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } @Override public String toString() { return \"User [name=\" + name + \", email=\" + email + \", address=\" + address + \"]\"; } } /** * Handles incoming JSON requests that work on User. * UserController is solely used to handle incoming requests (in this case, creating users form JSON input). */ class UserController { private final UserPersistenceService persistenceService = new UserPersistenceService(); public String createUser(String userJson) throws IOException { ObjectMapper mapper = new ObjectMapper(); User user = mapper.readValue(userJson, User.class); UserValidator validator = new UserValidator(); if (!validator.validateUser(user)) { return \"ERROR\"; } persistenceService.saveUser(user); return \"SUCCESS\"; } } /** * Handles persistence of User objects. * UserPersistenceService class is dedicated to save the user data. */ class UserPersistenceService { private final Store store = new Store(); public void saveUser(User user) { store.store(user); } } /** * Validates User data. * UserValidator class is solely responsible for validating user objects. */ class UserValidator { public boolean validateUser(User user) { if (!isPresent(user.getName()) || !isValidAlphaNumeric(user.getName())) { return false; } user.setName(user.getName().trim()); user.setEmail(user.getEmail().trim()); return isValidEmail(user.getEmail()); } private boolean isPresent(String value) { return value != null \u0026\u0026 value.trim().length() \u003e 0; } private boolean isValidAlphaNumeric(String value) { Pattern pattern = Pattern.compile(\"[^A-Za-z0-9]\"); Matcher matcher = pattern.matcher(value); return !matcher.find(); } private boolean isValidEmail(String value) { Pattern pattern = Pattern.compile(\"^[\\\\w-\\\\.]+@[\\\\w-]+(\\\\.[\\\\w-]+)+$\"); Matcher matcher = pattern.matcher(value); return matcher.find(); } } /** * Stores User data in memory. * Store class is only used to manage user objects storage. */ class Store { private static final Map\u0026lt;String, User\u0026gt; STORAGE = new HashMap\u0026lt;\u0026gt;(); public void store(User user) { synchronized (STORAGE) { STORAGE.put(user.getName(), user); } } public User getUser(String name) { synchronized (STORAGE) { return STORAGE.get(name); } } } /** * Main class for demonstrating the Single Responsibility Principle. */ public class Main { private static final String VALID_USER_JSON = \"{\\\"name\\\": \\\"Signal\\\", \\\"email\\\": \\\"signalyu999@gmail.com\\\", \\\"address\\\":\\\"999 Sugar lane\\\"}\"; private static final String INVALID_USER_JSON = \"{\\\"name\\\": \\\"Sam\\\", \\\"email\\\": \\\"sam@email\\\", \\\"address\\\":\\\"111 Sugar lane\\\"}\"; public static void main(String[] args) throws IOException { UserController controller = new UserController(); String response = controller.createUser(VALID_USER_JSON); System.out.println(\"Valid JSON response: \" + response); response = controller.createUser(INVALID_USER_JSON); System.out.println(\"Invalid JSON response: \" + response); } } Each class in the above code strictly adheres to the Single Responsibility Principle by focusing on a specific responsibility:\nUser for representing the user entity UserController for request handling UserPersistenceService for data persistence UserValidator for user data validation Store for managing in-memory data storage --- title: Single Responsibility Principle - Class Diagram --- classDiagram class User { - String name - String email - String address + String toString() } class Store { + void store(User user) + User getUser(String name) } class UserPersistenceService { + void saveUser(User user) } class UserValidator { - boolean isPresent(String value) - boolean isValidAlphaNumeric(String value) - boolean isValidEmail(String value) + boolean validateUser(User user) } class UserController { + String createUser(String userJson) } class Main { + void main(String[] args) } User --* Store Store --* UserPersistenceService UserPersistenceService --* UserController UserController --\u003e UserValidator : create Main --\u003e UserController : create 1.2 Open-Closed Principle A software entity (class, module, function, etc.) should be open for extension but closed for modification.\n点击查看代码 Java import java.time.LocalDateTime; import java.util.*; // Abstract base class, closed for modification but open for extension abstract class Subscriber { protected Long subscriberId; protected String address; protected Long phoneNumber; protected int baseRate; // Getter and Setter methods public Long getSubscriberId() { return subscriberId; } public void setSubscriberId(Long subscriberId) { this.subscriberId = subscriberId; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } public Long getPhoneNumber() { return phoneNumber; } public void setPhoneNumber(Long phoneNumber) { this.phoneNumber = phoneNumber; } public int getBaseRate() { return baseRate; } public void setBaseRate(int baseRate) { this.baseRate = baseRate; } // Abstract method to calculate the bill; implementation is defined in subclasses public abstract double calculateBill(); } // PhoneSubscriber class extends Subscriber, calculates the phone bill class PhoneSubscriber extends Subscriber { @Override public double calculateBill() { List\u0026lt;CallHistory.Call\u0026gt; calls = CallHistory.getCurrentCalls(subscriberId); long totalDuration = calls.stream().mapToLong(CallHistory.Call::getDuration).sum(); return (totalDuration * baseRate) / 100.0; } } // ISPSubscriber class extends Subscriber, calculates the internet bill class ISPSubscriber extends Subscriber { private long freeUsage; // Free usage limit in data units @Override public double calculateBill() { List\u0026lt;InternetSessionHistory.InternetSession\u0026gt; sessions = InternetSessionHistory.getCurrentSessions(subscriberId); long totalData = sessions.stream().mapToLong(InternetSessionHistory.InternetSession::getDataUsed).sum(); long chargeableData = totalData - freeUsage; return chargeableData \u003c= 0 ? 0 : (chargeableData * baseRate) / 100.0; } public long getFreeUsage() { return freeUsage; } public void setFreeUsage(long freeUsage) { this.freeUsage = freeUsage; } } // InternetSessionHistory class to manage internet usage records class InternetSessionHistory { public static class InternetSession { private final LocalDateTime begin; private final Long subscriberId; private final Long dataUsed; public InternetSession(Long subscriberId, LocalDateTime begin, long dataUsed) { this.subscriberId = subscriberId; this.begin = begin; this.dataUsed = dataUsed; } public LocalDateTime getBegin() { return begin; } public long getDataUsed() { return dataUsed; } public Long getSubscriberId() { return subscriberId; } } private static final Map\u0026lt;Long, List\u0026lt;InternetSession\u0026gt;\u0026gt; SESSIONS = new HashMap\u0026lt;\u0026gt;(); // Retrieves the current sessions for a subscriber, returns an empty list if none found public static synchronized List\u0026lt;InternetSession\u0026gt; getCurrentSessions(Long subscriberId) { return SESSIONS.getOrDefault(subscriberId, Collections.emptyList()); } // Adds a new internet session record for a subscriber public static synchronized void addSession(Long subscriberId, LocalDateTime begin, long dataUsed) { SESSIONS.computeIfAbsent(subscriberId, k -\u003e new LinkedList\u0026lt;\u0026gt;()).add(new InternetSession(subscriberId, begin, dataUsed)); } } // CallHistory class to manage call records class CallHistory { public static class Call { private final LocalDateTime begin; private final long duration; private final Long subscriberId; public Call(Long subscriberId, LocalDateTime begin, long duration) { this.subscriberId = subscriberId; this.begin = begin; this.duration = duration; } public LocalDateTime getBegin() { return begin; } public long getDuration() { return duration; } public Long getSubscriberId() { return subscriberId; } } private static final Map\u0026lt;Long, List\u0026lt;Call\u0026gt; CALLS = new HashMap\u0026lt;\u0026gt;(); // Retrieves the current calls for a subscriber, returns an empty list if none found public static synchronized List\u0026lt;Call\u0026gt; getCurrentCalls(Long subscriberId) { return CALLS.getOrDefault(subscriberId, Collections.emptyList()); } // Adds a new call record for a subscriber public static synchronized void addSession(Long subscriberId, LocalDateTime begin, long duration) { CALLS.computeIfAbsent(subscriberId, k -\u003e new LinkedList\u0026lt;\u0026gt;()).add(new Call(subscriberId, begin, duration)); } } public class Main { public static void main(String[] args) { // Initialize PhoneSubscriber and ISPSubscriber with sample data PhoneSubscriber phoneSubscriber = new PhoneSubscriber(); phoneSubscriber.setSubscriberId(1L); phoneSubscriber.setBaseRate(10); ISPSubscriber ispSubscriber = new ISPSubscriber(); ispSubscriber.setSubscriberId(2L); ispSubscriber.setBaseRate(5); ispSubscriber.setFreeUsage(1000); // Add call records for PhoneSubscriber CallHistory.addSession(1L, LocalDateTime.now().minusMinutes(5), 300); // 300 seconds call CallHistory.addSession(1L, LocalDateTime.now().minusMinutes(10), 600); // 600 seconds call // Calculate and print the phone subscriber's bill double phoneBill = phoneSubscriber.calculateBill(); System.out.println(\"Phone Subscriber's Bill: \" + phoneBill); // Add internet session records for ISPSubscriber InternetSessionHistory.addSession(2L, LocalDateTime.now().minusHours(1), 500); // 500 data units InternetSessionHistory.addSession(2L, LocalDateTime.now().minusHours(2), 800); // 800 data units // Calculate and print the ISP subscriber's bill double ispBill = ispSubscriber.calculateBill(); System.out.println(\"ISP Subscriber's Bill: \" + ispBill); } } The above code demonstrates the Open/Closed Principle (OCP) by separating the base Subscriber class from its specific implementations, PhoneSubscriber and ISPSubscriber, allowing for new functionalities to be added without modifying the existing code structure.\nClosed for Modification: The Subscriber base class is closed for modification. It defines common properties (like subscriberId, address, and baseRate) and an abstract calculateBill method that acts as a placeholder for billing logic. This base class remains unchanged even as new types of subscribers or billing strategies are introduced.\nOpen for Extension: The calculateBill method in Subscriber can be extended by subclasses, like PhoneSubscriber and ISPSubscriber, to implement custom billing calculations. Each subclass overrides calculateBill according to its unique billing requirements (e.g., PhoneSubscriber calculates based on call duration, while ISPSubscriber uses data usage with free data allowances). This enables additional subscriber types to be created without altering the base class or existing subclasses.\nFlexible to New Requirements: By following OCP, any new type of subscriber can be added—such as PremiumSubscriber or CorporateSubscriber—with its own billing logic without affecting the existing structure. This ensures that the core system remains stable, extensible, and easily maintainable as new features or subscriber types are introduced.\n--- title: Open Closed Principle - Class Diagram --- classDiagram class Subscriber { +Long subscriberId +String address +Long phoneNumber +int baseRate +double calculateBill() } class PhoneSubscriber { +double calculateBill() } class ISPSubscriber { +double calculateBill() +long freeUsage +void setFreeUsage(long freeUsage) +long getFreeUsage() } Subscriber \u003c|-- PhoneSubscriber Subscriber \u003c|-- ISPSubscriber 1.3 Liskov Substitution Principle Objects of a superclass should be replaceable with objects of a subclass without altering the correctness of the program.\nSHOW CODE: Violation of LSP Violation of LSP package dev.signalyu.solid.lsp; class Rectangle { private int width; private int height; public Rectangle(int width, int height) { this.width = width; this.height = height; } public int getWidth() { return width; } public void setWidth(int width) { this.width = width; } public int getHeight() { return height; } public void setHeight(int height) { this.height = height; } public int computeArea() { return width * height; } } class Square extends Rectangle { public Square(int side) { super(side, side); } @Override public void setWidth(int width) { setSide(width); } @Override public void setHeight(int height) { setSide(height); } public void setSide(int side) { super.setWidth(side); super.setHeight(side); } } public class Main { public static void main(String[] args) { Rectangle rectangle = new Rectangle(10, 20); System.out.println(rectangle.computeArea()); // 200 = 10 * 20 Square square = new Square(10); System.out.println(square.computeArea()); // 100 = 10 * 10 useRectangle(rectangle); System.out.println(rectangle.computeArea()); // 600 = 20 * 30 useRectangle(square); // Violates Liskov Substitution Principle System.out.println(square.computeArea()); // 900 = 30 * 30 } private static void useRectangle(Rectangle rectangle) { rectangle.setHeight(20); rectangle.setWidth(30); assert rectangle.getHeight() == 20 : \"Height Not equal to 20\"; assert rectangle.getWidth() == 30 : \"Width Not equal to 30\"; } } In the above code, the useRectangle method assumes that it can independently set the width and height of a Rectangle. However, when a Square (a subclass of Rectangle) object is passed to it, unexpected behavior will occur.\nSHOW CODE: After Refactoring After Refactoring package dev.signalyu.solid.lsp; interface Shape { int computeArea(); } class Rectangle implements Shape { private int width; private int height; public Rectangle(int width, int height) { this.width = width; this.height = height; } public int getWidth() { return width; } public void setWidth(int width) { this.width = width; } public int getHeight() { return height; } public void setHeight(int height) { this.height = height; } @Override public int computeArea() { return width * height; } } class Square implements Shape { private int side; public Square(int side) { this.side = side; } public void setSide(int side) { this.side = side; } public int getSide() { return side; } @Override public int computeArea() { return side * side; } } public class Main { public static void main(String[] args) { Rectangle rectangle = new Rectangle(10, 20); System.out.println(rectangle.computeArea()); Square square = new Square(10); System.out.println(square.computeArea()); useRectangle(rectangle); } private static void useRectangle(Rectangle rectangle) { rectangle.setHeight(20); rectangle.setWidth(30); assert rectangle.getHeight() == 20 : \"Height Not equal to 20\"; assert rectangle.getWidth() == 30 : \"Width Not equal to 30\"; } } After refactoring, the useRectangle method is now dedicated exclusively to the Rectangle class.\n1.4 Interface Segregation Principle No client should be forced to depend on methods it does not use.\nSHOW CODE: Violation of ISP Violation of ISP package dev.signalyu.solid.isp; import java.time.LocalDateTime; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.stream.Collectors; // Abstract Entity Class abstract class Entity { private Long id; public Long getId() { return id; } public void setId(Long id) { this.id = id; } } // Order Entity class Order extends Entity { private LocalDateTime orderPlacedOn; private double totalValue; public LocalDateTime getOrderPlacedOn() { return orderPlacedOn; } public void setOrderPlacedOn(LocalDateTime orderPlacedOn) { this.orderPlacedOn = orderPlacedOn; } public double getTotalValue() { return totalValue; } public void setTotalValue(double totalValue) { this.totalValue = totalValue; } } // User Entity class User extends Entity { private String name; private LocalDateTime lastLogin; public String getName() { return name; } public void setName(String name) { this.name = name; } public LocalDateTime getLastLogin() { return lastLogin; } public void setLastLogin(LocalDateTime lastLogin) { this.lastLogin = lastLogin; } } // Persistence Service Interface interface PersistenceService\u0026lt;T extends Entity\u0026gt; { void save(T entity); void delete(T entity); T findById(Long id); /** * ISP VIOLATION!!! * * Order entity doesn't have a name property and hence doesn't * need to implement the findByName method */ List\u0026lt;T\u0026gt; findByName(String name); } // User Persistence Service class UserPersistenceService implements PersistenceService\u0026lt;User\u0026gt; { private static final Map\u0026lt;Long, User\u0026gt; USERS = new HashMap\u0026lt;\u0026gt;(); @Override public void save(User entity) { synchronized (USERS) { USERS.put(entity.getId(), entity); } } @Override public void delete(User entity) { synchronized (USERS) { USERS.remove(entity.getId()); } } @Override public User findById(Long id) { synchronized (USERS) { return USERS.get(id); } } @Override public List findByName(String name) { synchronized (USERS) { return USERS.values().stream() .filter(u -\u003e u.getName().equalsIgnoreCase(name)) .collect(Collectors.toList()); } } } The above code violates the Interface Segregation Principle because the PersistenceService interface defines methods that are not applicable to all entities. For instance, the Order entity does not have a name property and therefore does not require the findByName method.\nSHOW CODE: After Refactoring After Refactoring import java.time.LocalDateTime; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.stream.Collectors; // Abstract Entity Class abstract class Entity { private Long id; public Long getId() { return id; } public void setId(Long id) { this.id = id; } } // User Entity class User extends Entity { private String name; private LocalDateTime lastLogin; public String getName() { return name; } public void setName(String name) { this.name = name; } public LocalDateTime getLastLogin() { return lastLogin; } public void setLastLogin(LocalDateTime lastLogin) { this.lastLogin = lastLogin; } } // Order Entity class Order extends Entity { private LocalDateTime orderPlacedOn; private double totalValue; public LocalDateTime getOrderPlacedOn() { return orderPlacedOn; } public void setOrderPlacedOn(LocalDateTime orderPlacedOn) { this.orderPlacedOn = orderPlacedOn; } public double getTotalValue() { return totalValue; } public void setTotalValue(double totalValue) { this.totalValue = totalValue; } } // Persistence Service Interface interface PersistenceService\u0026lt;T extends Entity\u0026gt; { void save(T entity); void delete(T entity); T findById(Long id); } // Order Persistence Service class OrderPersistenceService implements PersistenceService\u0026lt;Order\u0026gt; { private static final Map\u0026lt;Long, Order\u0026gt; ORDERS = new HashMap\u0026lt;\u0026gt;(); @Override public void save(Order entity) { synchronized (ORDERS) { ORDERS.put(entity.getId(), entity); } } @Override public void delete(Order entity) { synchronized (ORDERS) { ORDERS.remove(entity.getId()); } } @Override public Order findById(Long id) { synchronized (ORDERS) { return ORDERS.get(id); } } } // User Persistence Service class UserPersistenceService implements PersistenceService\u0026lt;User\u0026gt; { private static final Map\u0026lt;Long, User\u0026gt; USERS = new HashMap\u0026lt;\u0026gt;(); @Override public void save(User entity) { synchronized (USERS) { USERS.put(entity.getId(), entity); } } @Override public void delete(User entity) { synchronized (USERS) { USERS.remove(entity.getId()); } } @Override public User findById(Long id) { synchronized (USERS) { return USERS.get(id); } } public List findByName(String name) { synchronized (USERS) { return USERS.values().stream() .filter(u -\u003e u.getName().equalsIgnoreCase(name)) .collect(Collectors.toList()); } } } After refactoring, the PersistenceService interface includes only the generic methods (save, findById, and delete) that are applicable to all entities.\n1.5 Dependency Inversion Principle High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions\nSHOW CODE: Violation of DIP Violation of DIP package dev.signalyu.solid.dip; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.ObjectMapper; import java.io.FileWriter; import java.io.IOException; import java.io.PrintWriter; import java.time.LocalDateTime; import java.time.ZoneId; // Common interface for classes formatting Message object interface Formatter { String format(Message message) throws FormatException; } // Thrown by formatter class FormatException extends IOException { public FormatException(Exception cause) { super(cause); } } // Formats message to JSON format class JSONFormatter implements Formatter { public String format(Message message) throws FormatException { ObjectMapper mapper = new ObjectMapper(); try { return mapper.writeValueAsString(message); } catch (JsonProcessingException e) { e.printStackTrace(); throw new FormatException(e); } } } // Message class with content and timestamp class Message { private String msg; private LocalDateTime timestamp; public Message(String msg) { this.msg = msg; this.timestamp = LocalDateTime.now(ZoneId.of(\"UTC\")); } public String getMsg() { return msg; } public LocalDateTime getTimestamp() { return timestamp; } } // Writes message to a file class MessagePrinter { /** * MessagePrinter directly instantiates the JSONFormatter object inside the * writeMessage method, which violates the Dependency Inversion Principle. */ public void writeMessage(Message msg, String fileName) throws IOException { Formatter formatter = new JSONFormatter(); // creates formatter try (PrintWriter writer = new PrintWriter(new FileWriter(fileName))) { // creates print writer writer.println(formatter.format(msg)); // formats and writes message writer.flush(); } } } // Main class public class Main { public static void main(String[] args) throws IOException { Message msg = new Message(\"This is a message again\"); MessagePrinter printer = new MessagePrinter(); printer.writeMessage(msg, \"test_msg.txt\"); } } In the above code, the MessagePrinter class directly instanitiates the JSONFormatter object inside the writeMessage method, which violates the Dependency Inversion Principle. This tight coupling means that if a new formatter, such as TextFormatter, needs to be added, the writeMessage method must be modified. This violates the Open-Closed Principle, which states that classes should be open for extension but closed for modification. According to the Dependency Inversion Principle, the high-level module (MessagePrinter) should not depend on the low-level module (JSONFormatter). Instead, both should depend on abstractions, such as the Formatter interface.\nSHOW CODE: After Refactoring After Refactoring import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule; import java.io.IOException; import java.io.PrintWriter; import java.time.LocalDateTime; import java.time.ZoneId; // Common interface for classes formatting Message objects interface Formatter { String format(Message message) throws FormatException; } // Custom exception thrown by Formatter class FormatException extends IOException { public FormatException(Exception cause) { super(cause); } } // Formats a Message object to JSON format class JSONFormatter implements Formatter { public String format(Message message) throws FormatException { ObjectMapper mapper = new ObjectMapper(); mapper.registerModule(new JavaTimeModule()); try { return mapper.writeValueAsString(message); } catch (JsonProcessingException e) { e.printStackTrace(); throw new FormatException(e); } } } // Represents a message with content and a timestamp class Message { private String msg; private LocalDateTime timestamp; public Message(String msg) { this.msg = msg; this.timestamp = LocalDateTime.now(ZoneId.of(\"UTC\")); } public String getMsg() { return msg; } public LocalDateTime getTimestamp() { return timestamp; } } // Responsible for writing a formatted Message to a file or output stream class MessagePrinter { public void writeMessage(Message msg, Formatter formatter, PrintWriter writer) throws IOException { writer.println(formatter.format(msg)); // Formats and writes the message writer.flush(); } } // Main class demonstrating functionality public class Main { public static void main(String[] args) throws IOException { Message msg = new Message(\"This is a message again\"); MessagePrinter printer = new MessagePrinter(); try (PrintWriter writer = new PrintWriter(System.out)) { // Writing to console output printer.writeMessage(msg, new JSONFormatter(), writer); } } } After refactoring, the MessagePrinter class now depends on the Formatter abstraction rather than its concrete implementations. This makes it easier to replace JSONFormatter with any other implementation of Formatter without modifying the existing code, adhering to the Open-Closed Principle.\n2. Creational Design Patterns Creational Design Patterns focus on the process of object creation, ensuring flexibility and promoting code reuse.\n2.1 Builder The Builder Design Pattern is a creational design pattern that enables the step-by-step construction of complex objects. It separates the construction process form the object\u0026rsquo;s representation, allowing the same process to produce different representations. This pattern is often used to build complex or immutable obejcts.\n❔❔❔ Same Construction Process Creates Different Representations:\nConsider building a meal in a fast-food restaurant, where the construction steps include:\nAdd a main dish (e.g., burger, sandwich, or pizza). Add a side dish (e.g., fries, salad, or breadsticks). Add a drink (e.g., soda, coffee, or juice). The construction process remains consistent: (main dish + side dish + drink). However, the final representation varies based on the choices:\nVeggie Meal: Sandwich + Salad + Juice. Classic Meal: Burger + Fries + Soda. Kids\u0026rsquo; Meal: Mini Pizza + Fries + Milk. --- title: UML Diagram of Builder Pattern --- classDiagram class Builder { +buildPartA() +buildPartB() +getResult() } class ConcreteBuilder1 { +buildPartA() +buildPartB() +getResult() } class ConcreteBuilder2 { +buildPartA() +buildPartB() +getResult() } class Director { +construct(builder: Builder) } class Product { +PartA +PartB } Builder \u003c|-- ConcreteBuilder1 Builder \u003c|-- ConcreteBuilder2 Director --\u003e Builder : uses ConcreteBuilder1 --\u003e Product : creates ConcreteBuilder2 --\u003e Product : creates ℹ️ In a context of design patterns, UML (Unified Modeling Language) is commonly used to represent the structure and behavior of the patterns in a clear and simple manner.\nSHOW CODE: Director Java import java.time.LocalDate; import java.time.Period; import java.util.Objects; // Address class class Address { private String houseNumber; private String street; private String city; private String zipcode; private String state; public Address(String houseNumber, String street, String city, String state, String zipcode) { this.houseNumber = houseNumber; this.street = street; this.city = city; this.state = state; this.zipcode = zipcode; } public String getFullAddress() { return houseNumber + \", \" + street + \"\\n\" + city + \"\\n\" + state + \" \" + zipcode; } } // User class class User { private String firstName; private String lastName; private LocalDate birthday; private Address address; public User(String firstName, String lastName, LocalDate birthday, Address address) { this.firstName = firstName; this.lastName = lastName; this.birthday = birthday; this.address = address; } public String getFirstName() { return firstName; } public String getLastName() { return lastName; } public LocalDate getBirthday() { return birthday; } public Address getAddress() { return address; } } // UserDTO interface interface UserDTO { String getName(); String getAddress(); String getAge(); } // UserWebDTO implementation class UserWebDTO implements UserDTO { private final String name; private final String address; private final String age; public UserWebDTO(String name, String address, String age) { this.name = name; this.address = address; this.age = age; } @Override public String getName() { return name; } @Override public String getAddress() { return address; } @Override public String getAge() { return age; } @Override public String toString() { return \"Name: \" + name + \"\\nAge: \" + age + \"\\nAddress:\\n\" + address; } } // UserDTOBuilder interface interface UserDTOBuilder { UserDTOBuilder withFirstName(String firstName); UserDTOBuilder withLastName(String lastName); UserDTOBuilder withBirthday(LocalDate birthday); UserDTOBuilder withAddress(Address address); UserDTO build(); } // Concrete builder class UserWebDTOBuilder implements UserDTOBuilder { private String firstName; private String lastName; private String age; private String address; @Override public UserDTOBuilder withFirstName(String firstName) { this.firstName = firstName; return this; } @Override public UserDTOBuilder withLastName(String lastName) { this.lastName = lastName; return this; } @Override public UserDTOBuilder withBirthday(LocalDate birthday) { if (Objects.nonNull(birthday)) { this.age = String.valueOf(Period.between(birthday, LocalDate.now()).getYears()); } return this; } @Override public UserDTOBuilder withAddress(Address address) { if (Objects.nonNull(address)) { this.address = address.getFullAddress(); } return this; } @Override public UserDTO build() { return new UserWebDTO(firstName + \" \" + lastName, address, age); } } // Client code (Director) public class Client { public static void main(String[] args) { User user = createUser(); UserDTOBuilder builder = new UserWebDTOBuilder(); UserDTO userDTO = buildUserDTO(builder, user); System.out.println(userDTO); } private static UserDTO buildUserDTO(UserDTOBuilder builder, User user) { return builder.withFirstName(user.getFirstName()) .withLastName(user.getLastName()) .withBirthday(user.getBirthday()) .withAddress(user.getAddress()) .build(); } private static User createUser() { Address address = new Address(\"100\", \"State Street\", \"Pawnee\", \"Indiana\", \"47998\"); return new User(\"Ron\", \"Swanson\", LocalDate.of(1960, 5, 6), address); } } SHOW CODE: Inner Builder Java import java.time.LocalDate; import java.time.Period; // Address class with Builder class Address { private final String houseNumber; private final String street; private final String city; private final String zipcode; private final String state; private Address(Builder builder) { this.houseNumber = builder.houseNumber; this.street = builder.street; this.city = builder.city; this.zipcode = builder.zipcode; this.state = builder.state; } public String getFullAddress() { return houseNumber + \", \" + street + \"\\n\" + city + \"\\n\" + state + \" \" + zipcode; } public static class Builder { private String houseNumber; private String street; private String city; private String zipcode; private String state; public Builder setHouseNumber(String houseNumber) { this.houseNumber = houseNumber; return this; } public Builder setStreet(String street) { this.street = street; return this; } public Builder setCity(String city) { this.city = city; return this; } public Builder setZipcode(String zipcode) { this.zipcode = zipcode; return this; } public Builder setState(String state) { this.state = state; return this; } public Address build() { return new Address(this); } } } // User class with Builder class User { private final String firstName; private final String lastName; private final LocalDate birthday; private final Address address; private User(Builder builder) { this.firstName = builder.firstName; this.lastName = builder.lastName; this.birthday = builder.birthday; this.address = builder.address; } public String getFirstName() { return firstName; } public String getLastName() { return lastName; } public LocalDate getBirthday() { return birthday; } public Address getAddress() { return address; } public static class Builder { private String firstName; private String lastName; private LocalDate birthday; private Address address; public Builder setFirstName(String firstName) { this.firstName = firstName; return this; } public Builder setLastName(String lastName) { this.lastName = lastName; return this; } public Builder setBirthday(LocalDate birthday) { this.birthday = birthday; return this; } public Builder setAddress(Address address) { this.address = address; return this; } public User build() { return new User(this); } } } // UserDTO interface interface UserDTO { String getName(); String getAddress(); String getAge(); } // UserWebDTO implementation class UserWebDTO implements UserDTO { private final String name; private final String address; private final String age; private UserWebDTO(Builder builder) { this.name = builder.name; this.address = builder.address; this.age = builder.age; } @Override public String getName() { return name; } @Override public String getAddress() { return address; } @Override public String getAge() { return age; } @Override public String toString() { return \"Name: \" + name + \"\\nAge: \" + age + \"\\nAddress:\\n\" + address; } public static class Builder { private String name; private String address; private String age; public Builder setName(String name) { this.name = name; return this; } public Builder setAddress(String address) { this.address = address; return this; } public Builder setAge(String age) { this.age = age; return this; } public UserWebDTO build() { return new UserWebDTO(this); } } } // Client code public class Client { public static void main(String[] args) { Address address = new Address.Builder() .setHouseNumber(\"100\") .setStreet(\"State Street\") .setCity(\"Pawnee\") .setState(\"Indiana\") .setZipcode(\"47998\") .build(); User user = new User.Builder() .setFirstName(\"Ron\") .setLastName(\"Swanson\") .setBirthday(LocalDate.of(1960, 5, 6)) .setAddress(address) .build(); UserWebDTO userDTO = new UserWebDTO.Builder() .setName(user.getFirstName() + \" \" + user.getLastName()) .setAddress(user.getAddress().getFullAddress()) .setAge(String.valueOf(Period.between(user.getBirthday(), LocalDate.now()).getYears())) .build(); System.out.println(userDTO); } } Summary Why builder pattern is capable of creating immutable objects?\nImplementing the builder as a static inner class facilitates the creation of immutable objects. The builder class has provileged access to the enclosing class\u0026rsquo;s internal state during the construction process. However, once the final object is built, it does not expose any setters or methods that modify its state, ensuring immutability.\nThe Director in the Builder Design Pattern is responsible for the construction process but is often not implemented as a standalone class. Instead, its responsibilities are typically handled by the client code or the consumer that requires the constructed object. This approach avoids the need for a separate director class, especially when the construction logic is simple or tailored to the client\u0026rsquo;s specific requirements.\nSHOW CODE: Without a Director Java UserDTO userDTO = new UserWebDTOBuilder() .withFirstName(\"John\") .withLastName(\"Doe\") .withBirthday(LocalDate.of(1990, 1, 1)) .withAddress(new Address(\"123\", \"Main St\", \"City\", \"State\", \"12345\")) .build(); SHOW CODE: With a Director Java public class Director { public UserDTO constructUser(UserDTOBuilder builder) { return builder.withFirstName(\"John\") .withLastName(\"Doe\") .withBirthday(LocalDate.of(1990, 1, 1)) .withAddress(new Address(\"123\", \"Main St\", \"City\", \"State\", \"12345\")) .build(); } } If a Product in the Builder Design Pattern is not part of an inheritance hierarchy, creating an abstract builder is unnecessary. The abstract builder is typically used to define method for mutiple types of builders. When there is only one type of product to construct, a concrete builder alone is sufficient to meet the requirements.\n2.2 Simple Factory The Simple Factory design pattern is a creational design pattern that delegates the responsibility of creating instances of different classes to a factory class, typically using a static method based on input parameters. This pattern centralizes object creation, simplifying the client code. However, it can violate the Open-Closed Principle (OCP), because adding a new product type requires modifying the factory class itself. This makes the code less flexible and harder to extend without altering existing source code.\nSHOW CODE Java import java.time.LocalDateTime; import java.time.LocalDate; // Abstract Post class public abstract class Post { private Long id; private String title; private String content; private LocalDateTime createdOn; private LocalDateTime publishedOn; public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } public LocalDateTime getCreatedOn() { return createdOn; } public void setCreatedOn(LocalDateTime createdOn) { this.createdOn = createdOn; } public LocalDateTime getPublishedOn() { return publishedOn; } public void setPublishedOn(LocalDateTime publishedOn) { this.publishedOn = publishedOn; } } // BlogPost class extends Post public class BlogPost extends Post { private String author; private String[] tags; public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } public String[] getTags() { return tags; } public void setTags(String[] tags) { this.tags = tags; } } // NewsPost class extends Post public class NewsPost extends Post { private String headline; private LocalDate newsTime; public String getHeadline() { return headline; } public void setHeadline(String headline) { this.headline = headline; } public LocalDate getNewsTime() { return newsTime; } public void setNewsTime(LocalDate newsTime) { this.newsTime = newsTime; } } // ProductPost class extends Post public class ProductPost extends Post { private String imageUrl; private String name; public String getImageUrl() { return imageUrl; } public void setImageUrl(String imageUrl) { this.imageUrl = imageUrl; } public String getName() { return name; } public void setName(String name) { this.name = name; } } // PostFactory class to create different types of posts public class PostFactory { public static Post createPost(String type) { switch (type) { case \"blog\": return new BlogPost(); case \"news\": return new NewsPost(); case \"product\": return new ProductPost(); default: throw new IllegalArgumentException(\"Post type is unknown\"); } } } // Client class to demonstrate the usage of Simple Factory public class Client { public static void main(String[] args) { Post post = PostFactory.createPost(\"news\"); System.out.println(post.getClass().getSimpleName()); // Prints the type of the created post (NewsPost) } } classDiagram direction RL class Post { - Long id - String title - String content - LocalDateTime createdOn - LocalDateTime publishedOn + getId() + setId(Long) + getTitle() + setTitle(String) + getContent() + setContent(String) + getCreatedOn() + setCreatedOn(LocalDateTime) + getPublishedOn() + setPublishedOn(LocalDateTime) } class BlogPost { - String author - String[] tags + getAuthor() + setAuthor(String) + getTags() + setTags(String[]) } class NewsPost { - String headline - LocalDate newsTime + getHeadline() + setHeadline(String) + getNewsTime() + setNewsTime(LocalDate) } class ProductPost { - String imageUrl - String name + getImageUrl() + setImageUrl(String) + getName() + setName(String) } class PostFactory { + createPost(String) } Post \u003c|-- BlogPost Post \u003c|-- NewsPost Post \u003c|-- ProductPost PostFactory --|\u003e BlogPost : creates PostFactory --|\u003e NewsPost : creates PostFactory --|\u003e ProductPost : creates The above code violates the Open-Closed Principle because when adding a new post type, such as EventPost, to the factory, the code must be modified by adding a new case statement, like the following:\ncase \u0026#34;event\u0026#34;: return new EventPost(); This approach breaks the OCP, which dictates that entities should be open for extension but closed for modification.\n2.3 Factory Method The Factory Method design pattern is a creational pattern that provides a method for creating objects in a superclass, while allowing subclasses to determine the type of object that will be created. This approach delegates the object creation process to the subclasses, enabling them to instantiate specific classes without the superclass needing to know the exact class being instantiated.\nSHOW CODE Java import java.util.*; /** * Abstract class representing a message, which is the \"product\". * Subclasses will provide specific content types. */ abstract class Message { public abstract String getContent(); public void addDefaultHeaders() { // Adds some default headers } public void encrypt() { // Has some code to encrypt the content } } /** * Concrete implementation of the Message class for Text messages. */ class TextMessage extends Message { @Override public String getContent() { return \"Text\"; } } /** * Concrete implementation of the Message class for JSON messages. */ class JSONMessage extends Message { @Override public String getContent() { return \"{\\\"JSON\\\":[]}\"; } } /** * Abstract creator class. The factory method createMessage() must be implemented * by subclasses to instantiate the specific message type. */ abstract class MessageCreator { public Message getMessage() { Message msg = createMessage(); msg.addDefaultHeaders(); msg.encrypt(); return msg; } // Factory method to create a message protected abstract Message createMessage(); } /** * Concrete creator for creating JSON messages. */ class JSONMessageCreator extends MessageCreator { @Override public Message createMessage() { return new JSONMessage(); } } /** * Concrete creator for creating Text messages. */ class TextMessageCreator extends MessageCreator { @Override public Message createMessage() { return new TextMessage(); } } /** * Client class demonstrating the use of the Factory Method pattern. */ public class Client { public static void main(String[] args) { printMessage(new JSONMessageCreator()); printMessage(new TextMessageCreator()); } public static void printMessage(MessageCreator creator) { Message msg = creator.getMessage(); System.out.println(msg.getContent()); } } --- title: UML Diagram of Factory Method Pattern --- classDiagram Message \u003c|-- TextMessage Message \u003c|-- JSONMessage MessageCreator \u003c|-- JSONMessageCreator MessageCreator \u003c|-- TextMessageCreator JSONMessageCreator \"1\" --\u003e \"1\" JSONMessage : creates TextMessageCreator \"1\" --\u003e \"1\" TextMessage : creates MessageCreator : +getMessage() MessageCreator : +createMessage() JSONMessageCreator : +createMessage() TextMessageCreator : +createMessage() Message : +getContent() Message : +addDefaultHeaders() Message : +encrypt() 2.4 Prototype The Prototype design pattern is a creational pattern that enables the creation of new objects by copying an existing object, known as the prototype. It is particularly useful when object creation is resource-intensive or when there is a need to dynamically create mana similar objects.\nSHOW CODE Java // Point3D class representing a 3D point class Point3D { private float x, y, z; public static final Point3D ZERO = new Point3D(0, 0, 0); public Point3D(float x, float y, float z) { this.x = x; this.y = y; this.z = z; } public Point3D normalize() { float mag = magnitude(); return new Point3D(x / mag, y / mag, z / mag); } private float magnitude() { return (float) Math.sqrt(x * x + y * y + z * z); } public Point3D multiply(float scale) { return new Point3D(x * scale, y * scale, z * scale); } public Point3D add(Point3D vector) { return new Point3D(x + vector.x, y + vector.y, z + vector.z); } @Override public String toString() { return \"(\" + x + \", \" + y + \", \" + z + \")\"; } } // Abstract GameUnit class defining the clone method abstract class GameUnit implements Cloneable { private Point3D position; public GameUnit() { position = Point3D.ZERO; } @Override public GameUnit clone() throws CloneNotSupportedException { GameUnit unit = (GameUnit) super.clone(); unit.initialize(); return unit; } protected void initialize() { this.position = Point3D.ZERO; reset(); } protected abstract void reset(); public GameUnit(float x, float y, float z) { position = new Point3D(x, y, z); } public void move(Point3D direction, float distance) { Point3D finalMove = direction.normalize(); finalMove = finalMove.multiply(distance); position = position.add(finalMove); } public Point3D getPosition() { return position; } } // Swordsman class extends GameUnit and implements specific behavior class Swordsman extends GameUnit { private String state = \"idle\"; public void attack() { this.state = \"attacking\"; } @Override public String toString() { return \"Swordsman \" + state + \" @ \" + getPosition(); } @Override protected void reset() { state = \"idle\"; } } // General class extends GameUnit but does not support cloning class General extends GameUnit { private String state = \"idle\"; public void boostMorale() { this.state = \"MoralBoost\"; } @Override public String toString() { return \"General \" + state + \" @ \" + getPosition(); } @Override public GameUnit clone() throws CloneNotSupportedException { throw new CloneNotSupportedException(\"Generals are unique\"); } @Override protected void reset() { throw new UnsupportedOperationException(\"Reset not supported\"); } } public class Main { // Client code to demonstrate the Prototype Pattern public static void main(String[] args) throws CloneNotSupportedException { // Creating and moving a Swordsman Swordsman s1 = new Swordsman(); s1.move(new Point3D(-10, 0, 0), 20); s1.attack(); System.out.println(s1); // Cloning the Swordsman Swordsman s2 = (Swordsman) s1.clone(); System.out.println(\"Cloned swordsman: \" + s2); } } Shallow Copy vs. Deep Copy: A shallow copy creates a new object but only copies the references of the original object\u0026rsquo;s fields. As a result, both the original and the copied object share references to the same inner objects. Any changes made to the inner mutable objects of the copied object will affect the original object as well. In Java, the clone method performs a shallow copy. On the other hand, a deep copy involves recursively copying the original object and all the objects it references. As a result, the copied object is entirely independent of the original, and changes made to the copied object do not affect the original one.\nSHOW CODE: Shallow Copy Java import java.util.ArrayList; import java.util.List; /** * @author Signal Yu * @since 2024-12-2 */ class Person { String name; int age; public Person(String name, int age) { this.name = name; this.age = age; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"Person{name='\" + name + \"', age=\" + age + '}'; } } public class Solution { public static void main(String[] args) { // Original list with mutable objects (Person) List\u0026lt;Person\u0026gt; originalList = new ArrayList\u0026lt;\u0026gt;(); originalList.add(new Person(\"Alice\", 30)); originalList.add(new Person(\"Bob\", 25)); // Shallow copy of the list List\u0026lt;Person\u0026gt; shallowCopyList = new ArrayList\u0026lt;\u0026gt;(originalList); // Modify the object in the shallow copy shallowCopyList.get(1).setName(\"Signal\"); // Print both lists System.out.println(\"Original List: \" + originalList); System.out.println(\"Shallow Copy List: \" + shallowCopyList); } } SHOW OUTPUT: Shallow Copy Output Original List: [Person{name='Alice', age=30}, Person{name='Signal', age=25}] Shallow Copy List: [Person{name='Alice', age=30}, Person{name='Signal', age=25}] SHOW CODE: Deep Copy Java import java.util.ArrayList; import java.util.List; class Person { String name; int age; public Person(String name, int age) { this.name = name; this.age = age; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"Person{name='\" + name + \"', age=\" + age + '}'; } // Deep copy method for Person class public Person deepCopy() { return new Person(this.name, this.age); } } public class Solution { public static void main(String[] args) { // Original list with mutable objects (Person) List\u0026lt;Person\u0026gt; originalList = new ArrayList\u0026lt;\u0026gt;(); originalList.add(new Person(\"Alice\", 30)); originalList.add(new Person(\"Bob\", 25)); // Deep copy of the list (creating new Person objects) List\u0026lt;Person\u0026gt; deepCopyList = new ArrayList\u0026lt;\u0026gt;(); for (Person person : originalList) { deepCopyList.add(person.deepCopy()); // Add a deep copy of each person } // Modify the object in the deep copy deepCopyList.get(1).setName(\"Signal\"); // Print both lists System.out.println(\"Original List: \" + originalList); System.out.println(\"Deep Copy List: \" + deepCopyList); } } SHOW OUTPUT: Deep Copy Output Original List: [Person{name='Alice', age=30}, Person{name='Bob', age=25}] Deep Copy List: [Person{name='Alice', age=30}, Person{name='Signal', age=25}] It is important to note that changes made to immutable objects in a shallow copied object will not affect the original object. For example, when performing a shallow copy of an ArrayList that contains Integer values, changes made to the Integer of the copied object will not affect the original object because Integer is immutable (since it is marked as final and its value cannot be changed).\nSHOW CODE Java import java.util.ArrayList; import java.util.List; /** * @author Signal Yu * @since 2024-12-2 */ public class Solution { public static void main(String[] args) { // Integer is an immutable class List\u0026lt;Integer\u0026gt; original = new ArrayList\u0026lt;\u0026gt;(); original.add(1); original.add(2); List\u0026lt;Integer\u0026gt; shallowCopy = new ArrayList\u0026lt;\u0026gt;(original); // Shallow copy shallowCopy.set(0, 99); // Modify the shallow copy System.out.println(original); // Output: [1, 2] System.out.println(shallowCopy); // Output: [99, 2] } } Prototype v.s. Builder\n2.5 Abstract Factory The Abstract Factory design pattern is a creational pattern that creates families of related objects without specifying their concrete classes. It allows the client to instantiate objects from a group of related products while ensuring that these objects are compatible with each other. This pattern is particularly useful when a system needs to be independent of how objects are created, composed, and represented. However, a limitation of this pattern is that when a new product type is added, the base factory typically needs to be modified, which can increase the maintainence overhead.\nSHOW CODE Java // Represents an abstract product interface Storage { String getId(); } // Represents a concrete product in a family \"Amazon Web Services\" class S3Storage implements Storage { public S3Storage(int capacityInMib) { System.out.println(\"Allocated \" + capacityInMib + \" on S3\"); } @Override public String getId() { return \"S31\"; } @Override public String toString() { return \"S3 Storage\"; } } // Represents a concrete product in a family \"Google Cloud Platform\" class GoogleCloudStorage implements Storage { public GoogleCloudStorage(int capacityInMib) { System.out.println(\"Allocated \" + capacityInMib + \" on Google Cloud Storage\"); } @Override public String getId() { return \"gcpcs1\"; } @Override public String toString() { return \"Google cloud storage\"; } } // Represents an abstract product interface Instance { enum Capacity {micro, small, large} void start(); void attachStorage(Storage storage); void stop(); } // Represents a concrete product in a family \"Amazon Web Services\" class Ec2Instance implements Instance { public Ec2Instance(Capacity capacity) { System.out.println(\"Created Ec2Instance\"); } @Override public void start() { System.out.println(\"Ec2Instance started\"); } @Override public void attachStorage(Storage storage) { System.out.println(\"Attached \" + storage + \" to Ec2Instance\"); } @Override public void stop() { System.out.println(\"Ec2Instance stopped\"); } @Override public String toString() { return \"EC2Instance\"; } } // Represents a concrete product in a family \"Google Cloud Platform\" class GoogleComputeEngineInstance implements Instance { public GoogleComputeEngineInstance(Capacity capacity) { System.out.println(\"Created Google Compute Engine instance\"); } @Override public void start() { System.out.println(\"Compute engine instance started\"); } @Override public void attachStorage(Storage storage) { System.out.println(\"Attached \" + storage + \" to Compute engine instance\"); } @Override public void stop() { System.out.println(\"Compute engine instance stopped\"); } } // Abstract factory with methods defined for each object type. interface ResourceFactory { Instance createInstance(Instance.Capacity capacity); Storage createStorage(int capMib); } // Factory implementation for Amazon Web Services resources class AwsResourceFactory implements ResourceFactory { @Override public Instance createInstance(Instance.Capacity capacity) { return new Ec2Instance(capacity); } @Override public Storage createStorage(int capMib) { return new S3Storage(capMib); } } // Factory implementation for Google Cloud Platform resources class GoogleResourceFactory implements ResourceFactory { @Override public Instance createInstance(Instance.Capacity capacity) { return new GoogleComputeEngineInstance(capacity); } @Override public Storage createStorage(int capMib) { return new GoogleCloudStorage(capMib); } } // Client class public class Client { private ResourceFactory factory; public Client(ResourceFactory factory) { this.factory = factory; } public Instance createServer(Instance.Capacity cap, int storageMib) { Instance instance = factory.createInstance(cap); Storage storage = factory.createStorage(storageMib); instance.attachStorage(storage); return instance; } public static void main(String[] args) { Client aws = new Client(new AwsResourceFactory()); Instance i1 = aws.createServer(Instance.Capacity.micro, 20480); i1.start(); i1.stop(); System.out.println(\"***************************************\"); Client gcp = new Client(new GoogleResourceFactory()); i1 = gcp.createServer(Instance.Capacity.micro, 20480); i1.start(); i1.stop(); } } SHOW OUTPUT Output Created Ec2Instance Allocated 20480 on S3 Attached S3 Storage to Ec2Instance Ec2Instance started Ec2Instance stopped *************************************** Created Google Compute Engine instance Allocated 20480 on Google Cloud Storage Attached Google cloud storage to Compute engine instance Compute engine instance started Compute engine instance stopped Adding a new product type, such as Engine, may require modifications to the base factory. This is because the new Engine product froms a new combination with Storage and Instance, and the base factory is responsible for creating all the products (i.e., Storage, Instance, and Engine). As a result, the base factory needs to include a new method, createEngine. This modification violates the Open/Closed Principle (OCP), which states that classes should be open for extension but closed for modification.\nSHOW CODE Java // Represents an abstract product for Storage interface Storage { String getId(); } // Represents a concrete product in a family \"Amazon Web Services\" for Storage class S3Storage implements Storage { public S3Storage(int capacityInMib) { System.out.println(\"Allocated \" + capacityInMib + \" on S3\"); } @Override public String getId() { return \"S31\"; } @Override public String toString() { return \"S3 Storage\"; } } // Represents a concrete product in a family \"Google Cloud Platform\" for Storage class GoogleCloudStorage implements Storage { public GoogleCloudStorage(int capacityInMib) { System.out.println(\"Allocated \" + capacityInMib + \" on Google Cloud Storage\"); } @Override public String getId() { return \"gcpcs1\"; } @Override public String toString() { return \"Google Cloud Storage\"; } } // Represents an abstract product for Engine interface Engine { String getName(); } // Represents a concrete product in a family \"Amazon Web Services\" for Engine class Ec2Engine implements Engine { String name; public Ec2Engine(String name) { this.name = name; System.out.println(name + \" engine selected.\"); } @Override public String getName() { return name; } } // Represents a concrete product in a family \"Google Cloud Platform\" for Engine class GoogleComputeEngine implements Engine { String name; public GoogleComputeEngine(String name) { this.name = name; System.out.println(name + \" engine selected.\"); } @Override public String getName() { return name; } } // Represents an abstract product for Instance interface Instance { enum Capacity {micro, small, large} void start(); void attachStorage(Storage storage); void stop(); void useEngine(Engine engine); } // Represents a concrete product in a family \"Amazon Web Services\" for Instance class Ec2Instance implements Instance { public Ec2Instance(Instance.Capacity capacity) { System.out.println(\"Created Ec2Instance\"); } @Override public void start() { System.out.println(\"Ec2Instance started\"); } @Override public void attachStorage(Storage storage) { System.out.println(\"Attached \" + storage + \" to Ec2Instance\"); } @Override public void stop() { System.out.println(\"Ec2Instance stopped\"); } @Override public void useEngine(Engine engine) { System.out.println(\"Ec2Instance uses \" + engine.getName() + \" engine.\"); } @Override public String toString() { return \"EC2Instance\"; } } // Represents a concrete product in a family \"Google Cloud Platform\" for Instance class GoogleComputeEngineInstance implements Instance { public GoogleComputeEngineInstance(Instance.Capacity capacity) { System.out.println(\"Created Google Compute Engine instance\"); } @Override public void start() { System.out.println(\"Compute engine instance started\"); } @Override public void attachStorage(Storage storage) { System.out.println(\"Attached \" + storage + \" to Compute engine instance\"); } @Override public void stop() { System.out.println(\"Compute engine instance stopped\"); } @Override public void useEngine(Engine engine) { System.out.println(\"Google compute engine instance uses \" + engine.getName() + \" engine.\"); } } // Abstract factory with methods defined for each object type interface ResourceFactory { Instance createInstance(Instance.Capacity capacity); Storage createStorage(int capMib); Engine createEngine(String name); } // Factory implementation for Amazon Web Services resources class AwsResourceFactory implements ResourceFactory { @Override public Instance createInstance(Instance.Capacity capacity) { return new Ec2Instance(capacity); // Pass engine to the Ec2Instance } @Override public Storage createStorage(int capMib) { return new S3Storage(capMib); } @Override public Engine createEngine(String name) { return new Ec2Engine(name); } } // Factory implementation for Google Cloud Platform resources class GoogleResourceFactory implements ResourceFactory { @Override public Instance createInstance(Instance.Capacity capacity) { return new GoogleComputeEngineInstance(capacity); } @Override public Storage createStorage(int capMib) { return new GoogleCloudStorage(capMib); } @Override public Engine createEngine(String name) { return new GoogleComputeEngine(name); } } // Client class to test the code public class Client { private ResourceFactory factory; public Client(ResourceFactory factory) { this.factory = factory; } public Instance createServer(Instance.Capacity cap, int storageMib, String name) { Instance instance = factory.createInstance(cap); // Pass engine to instance creation Storage storage = factory.createStorage(storageMib); Engine engine = factory.createEngine(name); instance.attachStorage(storage); instance.useEngine(engine); // Call useEngine() on instance, which delegates to engine's getName() return instance; } public static void main(String[] args) { Client aws = new Client(new AwsResourceFactory()); Instance i1 = aws.createServer(Instance.Capacity.micro, 20480, \"Ec2\"); i1.start(); i1.stop(); System.out.println(\"***************************************\"); Client gcp = new Client(new GoogleResourceFactory()); i1 = gcp.createServer(Instance.Capacity.micro, 20480, \"GCE\"); i1.start(); i1.stop(); } } 2.6 Singleton Singleton is a creational design pattern that ensures a class has only one instance and provides a global point of access to that instance (typically through a static method). To implement a Singleton, the class constructor must be private, which prevents external classes from creating instances of the class directly, and a global static method should be provided to access the instance. There are two common types of Singleton: Eager Singleton and Lazy Singleton.\n2.6.1 Eager Singleton Eager Singleton ensures that an instance is created as soon as the class is loaded, rather than being created when needed. This guarantees that the instance is ready to use but may cause unnecessary overhead if the instance is never actually used.\nSHOW CODE: Eager Singleton Eager Singleton package dev.signalyu.singleton; public class EagerRegistry { private EagerRegistry() { // Private constructor to prevent instantiation } // Eagerly initializing the single instance of EagerRegistry private static final EagerRegistry INSTANCE = new EagerRegistry(); // Public method to provide access to the instance public static EagerRegistry getInstance() { return INSTANCE; } // Main method to demonstrate usage public static void main(String[] args) { // Accessing the singleton instance EagerRegistry registry = EagerRegistry.getInstance(); System.out.println(\"Singleton instance: \" + registry); } } SHOW OUTPUT Output Singleton instance: dev.signalyu.singleton.EagerRegistry@7a81197d 2.6.2 Lazy Singleton Lazy Singleton ensures that an instance of the class is created only when it is actually needed. This approach helps avoid unnecessary overhead but requires additional mechanisms to ensure thread safety in multi-threaded environments. It is commonly implemented using techniques like Double-Checked Locking or Initialization-on-Demand Holder.\nDouble-Checked Locking is an optimization technique ensures only one instance of a class is created, even in a multi-threaded environment, while minimizing synchronization overhead. This approach involves two checks: The first check, outside the synchronized block, allows the thread to bypass synchronization if the instance has already been created. The second check, inside the synchronized block, ensures that only one thread can create the instance, even if multiple threads attempt to do so concurrently.\nSHOW CODE: Double-Checked Locking Double-Checked Locking package dev.signalyu.singleton; public class LazyRegistryWithDCL { // Private constructor to prevent external instantiation private LazyRegistryWithDCL() {} // Volatile keyword ensures visibility of changes across threads private static volatile LazyRegistryWithDCL INSTANCE; // Public method to provide access to the Singleton instance public static LazyRegistryWithDCL getInstance() { if (INSTANCE == null) { // First check (outside synchronized block) synchronized (LazyRegistryWithDCL.class) { // Synchronized block to ensure only one thread can create the instance if (INSTANCE == null) { // Second check (inside synchronized block) INSTANCE = new LazyRegistryWithDCL(); // Lazy initialization } } } return INSTANCE; } // Main method to demonstrate the usage of the Singleton public static void main(String[] args) { // Accessing the Singleton instance LazyRegistryWithDCL registry = LazyRegistryWithDCL.getInstance(); System.out.println(\"Singleton instance: \" + registry); } } SHOW OUTPUT Output Singleton instance: dev.signalyu.singleton.LazyRegistryWithDCL@7a81197d The Initialization-on-Demand Holder technique leverages the class loading mechnism to ensure that the Singleton instance is created only when it is first accessed. It takes advantages of the fact that class loading in Java inherently thread-safe. This approach relies on static inner classes, which are not loaded until they are referenced, meaning that the instance is created only when it is actually needed.\nSHOW CODE: Initialization-on-Demand Holder Initialization-on-Demand Holder package dev.signalyu.singleton; public class LazyRegistryIODH { // Private constructor to prevent external instantiation private LazyRegistryIODH() { System.out.println(\"In LazyRegistryIODH singleton\"); } // Static inner class that holds the Singleton instance private static class RegistryHolder { // The Singleton instance is created when the class is loaded static final LazyRegistryIODH INSTANCE = new LazyRegistryIODH(); } // Public method to provide access to the Singleton instance public static LazyRegistryIODH getInstance() { return RegistryHolder.INSTANCE; } // Main method to demonstrate the usage of the Singleton public static void main(String[] args) { // Accessing the Singleton instance LazyRegistryIODH registry = LazyRegistryIODH.getInstance(); System.out.println(\"Singleton instance: \" + registry); } } SHOW OUTPUT Output In LazyRegistryIODH singleton Singleton instance: dev.signalyu.singleton.LazyRegistryIODH@5ca881b5 2.7 Object Pool Object Pool Design Pattern is a creational design pattern that manages a collection of reusable objects, rather than frequently creating and destroying objects. These objects are stored in a pool, from which clients can borrow objects, use them, and return them when they are done. This pattern is particularly useful in scenerios where a large number of objects are needed temporarily, and the cost of creating these objects is high, such as resource management (e.g., database connection or thread pools).\nSHOW CODE Java import java.util.concurrent.BlockingQueue; import java.util.concurrent.LinkedBlockingQueue; import java.util.function.Supplier; // Point2D class class Point2D { private float x, y; public Point2D(float x, float y) { this.x = x; this.y = y; } @Override public String toString() { return \"Point2D [x=\" + x + \", y=\" + y + \"]\"; } } // Poolable interface interface Poolable { // state reset void reset(); } // Image interface extending Poolable interface Image extends Poolable { void draw(); Point2D getLocation(); void setLocation(Point2D location); } // Bitmap class implementing Image and Poolable class Bitmap implements Image { private Point2D location; private String name; public Bitmap(String name) { this.name = name; } @Override public void draw() { System.out.println(\"Drawing \" + name + \" @ \" + location); } @Override public Point2D getLocation() { return location; } @Override public void setLocation(Point2D location) { this.location = location; } @Override public void reset() { location = null; System.out.println(\"Bitmap is reset\"); } } // ObjectPool class for reusable objects class ObjectPool { private BlockingQueue\u0026lt;T\u0026gt; availablePool; public ObjectPool(Supplier\u0026lt;T\u0026gt; creator, int count) { availablePool = new LinkedBlockingQueue\u0026lt;\u0026gt;(); for (int i = 0; i \u003c count; i++) { availablePool.offer(creator.get()); } } public T get() { try { return availablePool.take(); } catch (InterruptedException ex) { System.err.println(\"take() was interrupted\"); } return null; } public void release(T obj) { obj.reset(); try { availablePool.put(obj); } catch (InterruptedException e) { System.err.println(\"put() was interrupted\"); } } } // Main class to demonstrate Object Pool usage public class Client { public static void main(String[] args) { // Create a pool for Bitmap objects with 5 instances ObjectPool\u0026lt;Bitmap\u0026gt; bitmapPool = new ObjectPool\u0026lt;\u0026gt;(() -\u003e new Bitmap(\"Logo.bmp\"), 5); // Borrow Bitmap objects from the pool Bitmap b1 = bitmapPool.get(); b1.setLocation(new Point2D(10, 10)); Bitmap b2 = bitmapPool.get(); b2.setLocation(new Point2D(-10, 0)); // Use the objects b1.draw(); b2.draw(); // Release the objects back to the pool bitmapPool.release(b1); bitmapPool.release(b2); } } --- title: UML Diagram of Object Pool Design Pattern --- classDiagram ObjectPool --\u003e Bitmap : uses Bitmap --\u003e Point2D : uses Poolable \u003c|-- Image : implements Image \u003c|-- Bitmap : implements Client --\u003e ObjectPool : uses class ObjectPool { +BlockingQueue~T~ availablePool +ObjectPool(Supplier~T~ creator, int count) +T get() +void release(T obj) } class Bitmap { +Point2D location +String name +Bitmap(String name) +void draw() +Point2D getLocation() +void setLocation(Point2D location) +void reset() } class Point2D { +float x +float y +Point2D(float x, float y) +String toString() } class Poolable { +void reset() } class Image { +void draw() +Point2D getLocation() +void setLocation(Point2D location) } class Client { +void main() } 3. Structural Design Patterns Structural Design Pattern focus on optimizing object composition, helping achieve better organization and efficiency.\n3.1 Adapter The Adapter Design Pattern is a structural design pattern that allows two incompatible interfaces to work together, enabling them to communicate despite differences in their method signatures. This pattern is commonly used in situations where legacy code cannot be modified but needs to integrate with a new system that has a different interface.\nSHOW CODE Java // Target Interface interface Customer { String getName(); String getDesignation(); String getAddress(); } // Client code which requires Customer interface. class BusinessCardDesigner { public String designCard(Customer customer) { String card = \"\"; card += customer.getName(); card += \"\\n\" + customer.getDesignation(); card += \"\\n\" + customer.getAddress(); return card; } } // An existing class used in our system - Adaptee class Employee { private String fullName; private String jobTitle; private String officeLocation; public String getFullName() { return fullName; } public void setFullName(String fullName) { this.fullName = fullName; } public String getJobTitle() { return jobTitle; } public void setJobTitle(String jobTitle) { this.jobTitle = jobTitle; } public String getOfficeLocation() { return officeLocation; } public void setOfficeLocation(String officeLocation) { this.officeLocation = officeLocation; } } // An object adapter using composition to translate the interface class EmployeeObjectAdapter implements Customer { private final Employee adaptee; public EmployeeObjectAdapter(Employee adaptee) { this.adaptee = adaptee; } @Override public String getName() { return adaptee.getFullName(); } @Override public String getDesignation() { return adaptee.getJobTitle(); } @Override public String getAddress() { return adaptee.getOfficeLocation(); } } public class Client { public static void main(String[] args) { // Using Object Adapter Employee employee = new Employee(); populateEmployeeData(employee); EmployeeObjectAdapter objectAdapter = new EmployeeObjectAdapter(employee); BusinessCardDesigner designer = new BusinessCardDesigner(); String card = designer.designCard(objectAdapter); System.out.println(card); } private static void populateEmployeeData(Employee employee) { employee.setFullName(\"Signal Yu\"); employee.setJobTitle(\"Software Engineer\"); employee.setOfficeLocation(\"Shenzhen, Guangdong Province\"); } } --- title: UML Diagram of Adapter Design Pattern --- classDiagram class Customer { +String getName() +String getDesignation() +String getAddress() } class BusinessCardDesigner { +String designCard(Customer customer) } class Employee { -String fullName -String jobTitle -String officeLocation +String getFullName() +String getJobTitle() +String getOfficeLocation() +setFullName(String fullName) +setJobTitle(String jobTitle) +setOfficeLocation(String officeLocation) } class EmployeeObjectAdapter { -Employee adaptee +String getName() +String getDesignation() +String getAddress() } Customer \u003c|-- EmployeeObjectAdapter : implements BusinessCardDesigner --\u003e Customer : uses EmployeeObjectAdapter --\u003e Employee : adapts 3.2 Bridge The Bridge Design Pattern is a structural design pattern that separates the abstraction and implementation, enabling them to evolve independently without affecting each other.\nIn the following example, the Queue data structure is decoupled from the implementation of LinkedList. When there is a need to change the way data is stored, this can be done without modifying the Queue class. Additionally, when a new type of list, such as Doubly Linked List, is introduced, it can be done without affecting the behavior of the Queue class.\nSHOW CODE Java // This is the implementor interface. // It defines the basic operations for a LinkedList. interface LinkedList { void addFirst(T element); T removeFirst(); void addLast(T element); T removeLast(); int getSize(); } // A concrete implementor that uses nodes to implement a Singly Linked List. // **NOT thread safe** class SinglyLinkedList implements LinkedList { private int size; private Node head; private Node last; private static class Node { private final Object data; private Node next; private Node(Object data, Node next) { this.data = data; this.next = next; } } @Override public void addFirst(T element) { if (head == null) { last = head = new Node(element, null); } else { head = new Node(element, head); } size++; } @Override public T removeFirst() { if (head == null) { return null; } @SuppressWarnings(\"unchecked\") T temp = (T) head.data; if (head.next != null) { head = head.next; } else { head = null; last = null; } size--; return temp; } @Override public void addLast(T element) { if (last == null) { last = head = new Node(element, null); } else { last.next = new Node(element, null); last = last.next; } size++; } @Override public T removeLast() { if (last == null) { return null; } if (head == last) { @SuppressWarnings(\"unchecked\") T temp = (T) head.data; head = last = null; size--; return temp; } // since we don't have a back pointer Node temp = head; while (temp.next != last) { temp = temp.next; } @SuppressWarnings(\"unchecked\") T result = (T) last.data; last = temp; last.next = null; size--; return result; } @Override public int getSize() { return size; } @Override public String toString() { StringBuilder result = new StringBuilder(\"[\"); Node temp = head; while (temp != null) { result.append(temp.data).append(temp.next == null ? \"\" : \", \"); temp = temp.next; } result.append(\"]\"); return result.toString(); } } // A concrete implementor that uses arrays to implement a LinkedList. // **NOT thread safe** class ArrayLinkedList implements LinkedList { private static final int DEFAULT_SIZE = 2; private Object[] data; private int size; public ArrayLinkedList() { data = new Object[DEFAULT_SIZE]; } @Override public void addFirst(T element) { ensureCapacity(++size); shiftOneRight(); data[0] = element; } @Override public T removeFirst() { if (size == 0) { return null; } @SuppressWarnings(\"unchecked\") T first = (T) data[0]; size--; shiftOneLeft(); return first; } @Override public void addLast(T element) { ensureCapacity(size + 1); data[size++] = element; } @Override @SuppressWarnings(\"unchecked\") public T removeLast() { if (size == 0) { return null; } return (T) data[size--]; } private void ensureCapacity(int newSize) { if (data.length \u003e newSize) { return; } Object[] temp = new Object[data.length + DEFAULT_SIZE]; System.arraycopy(data, 0, temp, 0, data.length); data = temp; } private void shiftOneRight() { System.arraycopy(data, 0, data, 1, size); } private void shiftOneLeft() { System.arraycopy(data, 1, data, 0, size); } public int getSize() { return size; } @Override public String toString() { StringBuilder result = new StringBuilder(\"[\"); for (int i = 0; i \u003c size; i++) { result.append(data[i]).append(i == size - 1 ? \"\" : \", \"); } result.append(\"]\"); return result.toString(); } } // This is the abstraction interface representing a FIFO collection. interface FifoCollection { // Adds an element to the collection void offer(T element); // Removes \u0026 returns the first element from the collection T poll(); } // A refined abstraction that uses LinkedList to implement a Queue. class Queue implements FifoCollection { private final LinkedList list; public Queue(LinkedList list) { this.list = list; } @Override public void offer(T element) { list.addLast(element); } @Override public T poll() { return list.removeFirst(); } @Override public String toString() { return \"Queue{\" + \"list=\" + list.toString() + '}'; } } // Client code to demonstrate the bridge pattern public class Client { public static void main(String[] args) { FifoCollection\u0026lt;Integer\u0026gt; arrayQueue = new Queue\u0026lt;\u0026gt;(new ArrayLinkedList\u0026lt;\u0026gt;()); arrayQueue.offer(1); arrayQueue.offer(2); arrayQueue.offer(3); System.out.print(\"Array List Queue: \"); System.out.println(arrayQueue); FifoCollection\u0026lt;Integer\u0026gt; linkedListQueue = new Queue\u0026lt;\u0026gt;(new SinglyLinkedList\u0026lt;\u0026gt;()); linkedListQueue.offer(11); linkedListQueue.offer(22); linkedListQueue.offer(33); System.out.print(\"Linked List Queue: \"); System.out.println(linkedListQueue); System.out.print(linkedListQueue.poll() + \" \"); System.out.print(linkedListQueue.poll() + \" \"); System.out.print(linkedListQueue.poll() + \"\\n\"); // Should print null as all elements are removed System.out.println(linkedListQueue.poll()); // null } } SHOW OUTPUT Output Array List Queue: Queue{list=[1, 2, 3]} Linked List Queue: Queue{list=[11, 22, 33]} 11 22 33 null --- title: UML Diagram of Adapter Design Pattern --- classDiagram class LinkedList { +addFirst(T element) +removeFirst() +addLast(T element) +removeLast() +getSize() } class SinglyLinkedList { -int size -Node head -Node last +addFirst(T element) +removeFirst() +addLast(T element) +removeLast() +getSize() +toString() } class ArrayLinkedList { -Object[] data -int size +addFirst(T element) +removeFirst() +addLast(T element) +removeLast() +getSize() +toString() } class FifoCollection { +offer(T element) +poll() } class Queue { -LinkedList list +offer(T element) +poll() +toString() } LinkedList \u003c|.. SinglyLinkedList LinkedList \u003c|.. ArrayLinkedList FifoCollection \u003c|.. Queue : implements Queue *--\u003e LinkedList : composites %% Client code class class Client { +main(String[] args) } Client --\u003e FifoCollection : Uses 3.3 Decorator Decorator Design Pattern is a structural design pattern that allows addding new behaviors to an object dynamically, without altering its structure.\nSHOW CODE Java import org.apache.commons.text.StringEscapeUtils; import java.util.Base64; // Base interface or component interface Message { String getContent(); } // Concrete component. Object to be decorated class TextMessage implements Message { private String msg; public TextMessage(String msg) { this.msg = msg; } @Override public String getContent() { return msg; } } // Decorator. Implements component interface class HtmlEncodedMessage implements Message { private Message msg; public HtmlEncodedMessage(Message msg) { this.msg = msg; } @Override public String getContent() { return StringEscapeUtils.escapeHtml4(msg.getContent()); } } // Decorator for Base64 encoding class Base64EncodedMessage implements Message { private Message msg; public Base64EncodedMessage(Message msg) { this.msg = msg; } @Override public String getContent() { // Be wary of charset!! This is platform dependent.. return Base64.getEncoder().encodeToString(msg.getContent().getBytes()); } } // Client to demonstrate the decorators public class Client { public static void main(String[] args) { Message m = new TextMessage(\"The is strong with this one!\"); System.out.println(\"Original: \" + m.getContent()); // Apply HTML encoding Message decorator = new HtmlEncodedMessage(m); System.out.println(\"HTML Encoded: \" + decorator.getContent()); // Apply Base64 encoding decorator = new Base64EncodedMessage(decorator); System.out.println(\"Base64 Encoded: \" + decorator.getContent()); } } --- title: UML Diagram of Decorator Design Pattern --- classDiagram class Message { +String getContent() } class TextMessage { -String msg +TextMessage(String msg) +String getContent() } class HtmlEncodedMessage { -Message msg +HtmlEncodedMessage(Message msg) +String getContent() } class Base64EncodedMessage { -Message msg +Base64EncodedMessage(Message msg) +String getContent() } Message \u003c|-- TextMessage Message \u003c|-- HtmlEncodedMessage Message \u003c|-- Base64EncodedMessage TextMessage --\u003e HtmlEncodedMessage : Wraps HtmlEncodedMessage --\u003e Base64EncodedMessage : Wraps 3.4 Composite The Composite Design Pattern is a structural pattern that enables treating both individual objects and compositions of objects uniformly. It is designed to represent part-whole hierarchies, where individual objects (leaf nodes) and their composites are handled in the same way. This pattern is often used for managing complex hierarchical structures, such as file systems or organization structures.\nSHOW CODE Java import java.util.ArrayList; import java.util.List; // The component base class for composite pattern // Defines operations applicable both leaf \u0026 composite abstract class File { private String name; public File(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } public abstract void ls(); public abstract void addFile(File file); public abstract File[] getFiles(); public abstract boolean removeFile(File file); } // Leaf node in composite pattern class BinaryFile extends File { private long size; public BinaryFile(String name, long size) { super(name); this.size = size; } @Override public void ls() { System.out.println(getName() + \"\\t\" + size); } @Override public void addFile(File file) { throw new UnsupportedOperationException(\"Leaf node doesn't support add operation\"); } @Override public File[] getFiles() { throw new UnsupportedOperationException(\"Leaf node doesn't support get operation\"); } @Override public boolean removeFile(File file) { throw new UnsupportedOperationException(\"Leaf node doesn't support remove operation\"); } } // Composite in the composite pattern class Directory extends File { private List\u0026lt;File\u0026gt; children = new ArrayList\u0026lt;\u0026gt;(); public Directory(String name) { super(name); } @Override public void ls() { System.out.println(getName()); children.forEach(File::ls); } @Override public void addFile(File file) { children.add(file); } @Override public File[] getFiles() { return children.toArray(new File[children.size()]); } @Override public boolean removeFile(File file) { return children.remove(file); } } // Client class that creates and displays directory structure public class Client { public static void main(String[] args) { File root1 = createTreeOne(); root1.ls(); System.out.println(\"***********************************\"); File root2 = createTreeTwo(); root2.ls(); } // Client builds tree using leaf and composites private static File createTreeOne() { File file1 = new BinaryFile(\"file1\", 1000); File file2 = new BinaryFile(\"file2\", 2000); Directory dir1 = new Directory(\"dir1\"); dir1.addFile(file1); dir1.addFile(file2); File file3 = new BinaryFile(\"file3\", 3000); Directory dir2 = new Directory(\"dir2\"); dir2.addFile(file3); dir2.addFile(dir1); return dir2; } private static File createTreeTwo() { return new BinaryFile(\"Another file\", 200); } } In the above code, the statements dir2.addFile(file3); and dir2.addFile(dir1); demonstrate how both individual objects (file3) and compositions of objects (file1 and file2) are treated in the same way.\n--- title: UML Diagram of Composite Design Pattern --- classDiagram class File { +String name +getName() +setName(String name) +ls() +addFile(File file) +getFiles() +removeFile(File file) } class BinaryFile { +long size +BinaryFile(String name, long size) +ls() +addFile(File file) +getFiles() +removeFile(File file) } class Directory { +List~File~ children +Directory(String name) +ls() +addFile(File file) +getFiles() +removeFile(File file) } File \u003c|-- BinaryFile File \u003c|-- Directory Directory *--\u003e File : contains 3.5 Facade The Facade Design Pattern is a structural design pattern that provides a simplified interface to a complex subsystem. It is often used when the client needs to interact with only a specific part of a large system, hiding its complexity and making it easier to use.\nSHOW CODE Java package dev.signalyu.facade; // Template class and related classes abstract class Template { public enum TemplateType {Email, NewsLetter} public abstract String format(Object obj); } class TemplateFactory { public static Template createTemplateFor(Template.TemplateType type) { switch (type) { case Email: return new OrderEmailTemplate(); default: throw new IllegalArgumentException(\"Unknown TemplateType\"); } } } class OrderEmailTemplate extends Template { @Override public String format(Object obj) { return \"TEMPLATE\"; } } // Stationary class and related classes interface Stationary { String getHeader(); String getFooter(); } class StationaryFactory { public static Stationary createStationary() { return new HalloweenStationary(); } } class HalloweenStationary implements Stationary { @Override public String getHeader() { return \"It's Halloween!!\"; } @Override public String getFooter() { return \"BUY MORE STUFF! It's Halloween, c'mon!!\"; } } // Email class and related classes class EmailBuilder { public EmailBuilder withTemplate(Template template) { return this; } public EmailBuilder withStationary(Stationary stationary) { return this; } public EmailBuilder forObject(Object object) { return this; } public Email build() { return new Email(); } public Email getEmail() { return new Email(); } } class Email { public static EmailBuilder getBuilder() { return new EmailBuilder(); } } // Mailer class class Mailer { private static final Mailer MAILER = new Mailer(); public static Mailer getMailer() { return MAILER; } private Mailer() { } public boolean send(Email email) { return true; } } // Order class for reference (assuming Order exists as a placeholder) class Order { private String id; private double total; public Order(String id, double total) { this.id = id; this.total = total; } public String getId() { return id; } public void setId(String id) { this.id = id; } public double getTotal() { return total; } public void setTotal(double total) { this.total = total; } } // Facade provides simple methods for the client to use class EmailFacade { public boolean sendOrderEmail(Order order) { Template template = TemplateFactory.createTemplateFor(Template.TemplateType.Email); Stationary stationary = StationaryFactory.createStationary(); Email email = Email.getBuilder() .withTemplate(template) .withStationary(stationary) .forObject(order) .build(); Mailer mailer = Mailer.getMailer(); return mailer.send(email); } } public class Client { public static void main(String[] args) { Order order = new Order(\"101\", 99.99); EmailFacade facade = new EmailFacade(); boolean result = facade.sendOrderEmail(order); System.out.println(\"Order Email \" + (result ? \"sent!\" : \"NOT sent...\")); } } --- title: UML Diagram of Facade Design Pattern --- classDiagram class EmailFacade { +sendOrderEmail(order: Order) bool } class Template { +format(obj: Object) String } class TemplateFactory { +createTemplateFor(type: TemplateType) Template } class OrderEmailTemplate { +format(obj: Object) String } class Stationary { +getHeader() String +getFooter() String } class StationaryFactory { +createStationary() Stationary } class HalloweenStationary { +getHeader() String +getFooter() String } class EmailBuilder { +withTemplate(template: Template) EmailBuilder +withStationary(stationary: Stationary) EmailBuilder +forObject(object: Object) EmailBuilder +build() Email } class Email { +getBuilder() EmailBuilder } class Mailer { +getMailer() Mailer +send(email: Email) bool } EmailFacade --\u003e TemplateFactory : uses EmailFacade --\u003e StationaryFactory : uses EmailFacade --\u003e Mailer : uses TemplateFactory --\u003e OrderEmailTemplate : creates StationaryFactory --\u003e HalloweenStationary : creates Email --\u003e EmailBuilder : has EmailBuilder --\u003e Template : uses EmailBuilder --\u003e Stationary : uses Mailer --\u003e Email : uses EmailBuilder --\u003e Email : creates OrderEmailTemplate --\u003e Template : inherits HalloweenStationary --\u003e Stationary : implements 3.6 Flyweight The Flyweight Design Pattern is a structural design pattern used to optimize memory usuage by sharing common data across multiple objects. In this pattern, an object is divided into two categories: intrinsic state and extrinsic state.\nIntrinsic state refers to the data that is shared and remains consistent across different instances. It is usually stored within the Flyweight object. Extrinsic state, on the other hand, refers to data that can vary between instances. This state is typically managed and provided by the client or the object using the Flyweight. SHOW CODE Java import java.time.Duration; import java.util.HashMap; import java.util.Map; // Interface implemented by Flyweights interface ErrorMessage { // Get error message String getText(String code); } // A concrete Flyweight. Instance is shared class SystemErrorMessage implements ErrorMessage { // some error message $errorCode private String messageTemplate; // http://somedomain.com/help?error= private String helpUrlBase; public SystemErrorMessage(String messageTemplate, String helpUrlBase) { this.messageTemplate = messageTemplate; this.helpUrlBase = helpUrlBase; } @Override public String getText(String code) { return messageTemplate.replace(\"$errorCode\", code) + helpUrlBase + code; } } // Unshared concrete flyweight. class UserBannedErrorMessage implements ErrorMessage { // All state is defined here private String caseId; private String remarks; private Duration banDuration; private String msg; public UserBannedErrorMessage(String caseId) { // Load case info from DB. this.caseId = caseId; remarks = \"You violated terms of use.\"; banDuration = Duration.ofDays(2); msg = \"You are BANNED. Sorry. \\nMore information:\\n\"; msg += caseId + \"\\n\"; msg += remarks + \"\\n\"; msg += \"Banned For:\" + banDuration.toHours() + \" Hours\"; } // We ignore the extrinsic state argument @Override public String getText(String code) { return msg; } public String getCaseNo() { return caseId; } } // Flyweight factory. Returns shared flyweight based on key class ErrorMessageFactory { // This serves as key for getting flyweight instance public enum ErrorType { GenericSystemError, PageNotFoundError, ServerError } private static final ErrorMessageFactory FACTORY = new ErrorMessageFactory(); public static ErrorMessageFactory getInstance() { return FACTORY; } private Map\u0026lt;ErrorType, SystemErrorMessage\u0026gt; errorMessages = new HashMap\u0026lt;\u0026gt;(); private ErrorMessageFactory() { errorMessages.put(ErrorType.GenericSystemError, new SystemErrorMessage(\"A genetic error of type $errorCode occurred. Please refer to:\\n\", \"https://google.com/q=\")); errorMessages.put(ErrorType.PageNotFoundError, new SystemErrorMessage(\"Page not found. An error of type $errorCode occurred. Please refer to:\\n\", \"https://google.com/q=\")); } public SystemErrorMessage getError(ErrorType type) { return errorMessages.get(type); } public UserBannedErrorMessage getUserBannedMessage(String caseId) { return new UserBannedErrorMessage(caseId); } } // Client public class Client { public static void main(String[] args) { // Accessing shared flyweight objects SystemErrorMessage msg1 = ErrorMessageFactory.getInstance().getError(ErrorMessageFactory.ErrorType.GenericSystemError); System.out.println(msg1.getText(\"4056\")); // Accessing unshared flyweight objects UserBannedErrorMessage msg2 = ErrorMessageFactory.getInstance().getUserBannedMessage(\"1202\"); System.out.println(msg2.getText(null)); } } SHOW OUTPUT Output A genetic error of type 4056 occurred. Please refer to: https://google.com/q=4056 You are BANNED. Sorry. More information: 1202 You violated terms of use. Banned For:48 Hours --- title: UML Diagram of Flyweight Design Pattern --- classDiagram class ErrorMessage { +getText(code: String): String } class SystemErrorMessage { -messageTemplate: String -helpUrlBase: String +getText(code: String): String } class UserBannedErrorMessage { -caseId: String -remarks: String -banDuration: Duration -msg: String +getText(code: String): String +getCaseNo(): String } class ErrorMessageFactory { -errorMessages: Map~ErrorType, SystemErrorMessage~ +getInstance(): ErrorMessageFactory +getError(type: ErrorType): SystemErrorMessage +getUserBannedMessage(caseId: String): UserBannedErrorMessage } class Client { +main(args: String[]): void } ErrorMessage \u003c|-- SystemErrorMessage ErrorMessage \u003c|-- UserBannedErrorMessage ErrorMessageFactory *--\u003e SystemErrorMessage ErrorMessageFactory *--\u003e UserBannedErrorMessage Client --\u003e ErrorMessageFactory 3.7 Proxy The Proxy Design Pattern is a structural design pattern that involves using a proxy object to represent another object. The proxy controls access to the real object and can add additional functionality, such aas lazy initialization, logging, or monitoring. This pattern can be primarily categorized into two types: Static Proxy and Dynamic Proxy.\nThe Static Proxy is created at compile time, where a separate proxy class is written to manage method calls to the real object. In contrast, the Dynamic Proxy is created at runtime, often using reflection techniques in languages like Java. A dynamic proxy delegates method calls to the real object without the need for manually creating a proxy class.\nSHOW CODE: Static Proxy Java // Point2D class to represent the location of the image class Point2D { private final float x; private final float y; public Point2D(float x, float y) { this.x = x; this.y = y; } @Override public String toString() { return \"Point2D [x=\" + x + \", y=\" + y + \"]\"; } } // Interface implemented by proxy and concrete objects interface Image { void setLocation(Point2D point2d); Point2D getLocation(); void render(); } // Concrete class providing actual functionality class BitmapImage implements Image { private Point2D location; private final String name; public BitmapImage(String filename) { // Loads image from file on disk System.out.println(\"Loaded from disk: \" + filename); name = filename; } @Override public void setLocation(Point2D point2d) { location = point2d; } @Override public Point2D getLocation() { return location; } @Override public void render() { // Renders to screen System.out.println(\"Rendered \" + this.name); } } // Proxy class class ImageProxy implements Image { private final String name; private BitmapImage image; private Point2D location; public ImageProxy(String name) { this.name = name; } @Override public void setLocation(Point2D point2d) { if (image != null) { image.setLocation(point2d); } else { location = point2d; } } @Override public Point2D getLocation() { if (image != null) { return image.getLocation(); } return location; } @Override public void render() { if (image == null) { image = new BitmapImage(name); if (location != null) { image.setLocation(location); } } image.render(); } } // Factory to get image objects class ImageFactory { // We'll provide proxy to caller instead of real object public static Image getImage(String name) { return new ImageProxy(name); } } // Client class to test the proxy pattern public class Client { public static void main(String[] args) { Image img = ImageFactory.getImage(\"A1.bmp\"); img.setLocation(new Point2D(10, 10)); System.out.println(\"Image location: \" + img.getLocation()); System.out.println(\"Rendering image now...\"); img.render(); } } SHOW OUTPUT Output Image location: Point2D [x=10.0, y=10.0] Rendering image now... Loaded from disk: A1.bmp Rendered A1.bmp --- title: UML Diagram of Static Proxy Design Pattern --- classDiagram class Image { + setLocation(Point2D point2d) + Point2D getLocation() + render() } class BitmapImage { - Point2D location - String name + BitmapImage(String filename) + setLocation(Point2D point2d) + getLocation(): Point2D + render() } class ImageProxy { - String name - BitmapImage image - Point2D location + ImageProxy(String name) + setLocation(Point2D point2d) + getLocation(): Point2D + render() } class ImageFactory { + getImage(String name): Image } class Client { + main(String[] args) } Image \u003c|.. BitmapImage : implements Image \u003c|.. ImageProxy : implements ImageFactory --|\u003e ImageProxy : creates Client --\u003e ImageFactory : uses ImageProxy \"1\" --\u003e \"0..1\" BitmapImage : contains SHOW CODE: Dynamic Proxy Java import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; // Point2D class to represent the location of the image class Point2D { private final float x; private final float y; public Point2D(float x, float y) { this.x = x; this.y = y; } @Override public String toString() { return \"Point2D [x=\" + x + \", y=\" + y + \"]\"; } } // Interface implemented by proxy and concrete objects interface Image { void setLocation(Point2D point2d); Point2D getLocation(); void render(); } // Concrete class providing actual functionality (BitmapImage) class BitmapImage implements Image { private Point2D location; private final String name; public BitmapImage(String filename) { // Loads image from file on disk System.out.println(\"Loaded from disk: \" + filename); name = filename; } @Override public void setLocation(Point2D point2d) { location = point2d; } @Override public Point2D getLocation() { return location; } @Override public void render() { // Renders to screen System.out.println(\"Rendered \" + this.name); } } // InvocationHandler to implement proxy behavior class ImageInvocationHandler implements InvocationHandler { private final String filename; private Point2D location; private BitmapImage image; private static final Method setLocationMethod; private static final Method getLocationMethod; private static final Method renderMethod; static { try { setLocationMethod = Image.class.getMethod(\"setLocation\", Point2D.class); getLocationMethod = Image.class.getMethod(\"getLocation\"); renderMethod = Image.class.getMethod(\"render\"); } catch (NoSuchMethodException e) { throw new NoSuchMethodError(e.getMessage()); } } public ImageInvocationHandler(String filename) { this.filename = filename; } @Override public Object invoke(Object proxy, Method method, Object[] args) { System.out.println(\"Invoking method: \" + method.getName()); if (method.equals(setLocationMethod)) { return handleSetLocation(args); } else if (method.equals(getLocationMethod)) { return handleGetLocation(); } else if (method.equals(renderMethod)) { return handleRender(); } return null; } private Object handleRender() { if (image == null) { image = new BitmapImage(filename); if (location != null) { image.setLocation(location); } } image.render(); return null; } private Point2D handleGetLocation() { if (image != null) { return image.getLocation(); } else { return this.location; } } private Object handleSetLocation(Object[] args) { if (image != null) { image.setLocation((Point2D) args[0]); } else { this.location = (Point2D) args[0]; } return null; } } // Factory to provide the proxy object class ImageFactory { public static Image getImage(String name) { return (Image) Proxy.newProxyInstance( ImageFactory.class.getClassLoader(), new Class[]{Image.class}, new ImageInvocationHandler(name) ); } } // Client class to test the proxy pattern public class Client { public static void main(String[] args) { Image img = ImageFactory.getImage(\"A.bmp\"); img.setLocation(new Point2D(-10, 0)); System.out.println(img.getLocation()); System.out.println(\"*****************************\"); img.render(); } } SHOW OUTPUT Output Invoking method: setLocation Invoking method: getLocation Point2D [x=-10.0, y=0.0] ***************************** Invoking method: render Loaded from disk: A.bmp Rendered A.bmp --- title: UML Diagram of Dynamic Proxy Design Pattern --- classDiagram class Image { +setLocation(Point2D point2d) +getLocation(): Point2D +render() } class BitmapImage { -Point2D location -String name +BitmapImage(String filename) +setLocation(Point2D point2d) +getLocation(): Point2D +render() } class ImageInvocationHandler { -String filename -Point2D location -BitmapImage image +ImageInvocationHandler(String filename) +invoke(Object proxy, Method method, Object[] args) -handleRender() -handleGetLocation(): Point2D -handleSetLocation(Object[] args) } class ImageFactory { +getImage(String name): Image } class Client { +main(String[] args) } Image \u003c|.. BitmapImage : implements Image \u003c|.. ImageInvocationHandler : delegates ImageFactory ..\u003e ImageInvocationHandler : creates Client ..\u003e ImageFactory : uses ImageInvocationHandler \"1\" -- \"1\" BitmapImage : image 4. Behavioral Design Patterns Behavioral Design Patterns focus on the communication and interaction between objects or components in a system.\n4.1 Chain of Responsibility The Chain of Responsibility Design Pattern is a behavioral design pattern that allows a request to be passed along a chain of handlers, where each handler either processes the request or passes it along to the next handler in the chain. The request will continue through the chain until it is handled by an appropriate handler or the end of the chain is reached.\nSHOW CODE Java import java.time.LocalDate; import java.time.Period; // Represents a request in our chain of responsibility class LeaveApplication { public enum Type {Sick, PTO, LOP} public enum Status {Pending, Approved, Rejected} private final Type type; private final LocalDate from; private final LocalDate to; private String processedBy; private Status status; public LeaveApplication(Type type, LocalDate from, LocalDate to) { this.type = type; this.from = from; this.to = to; this.status = Status.Pending; } public Type getType() { return type; } public LocalDate getFrom() { return from; } public LocalDate getTo() { return to; } public int getNoOfDays() { return Period.between(from, to).getDays(); } public String getProcessedBy() { return processedBy; } public Status getStatus() { return status; } public void approve(String approvalName) { this.status = Status.Approved; this.processedBy = approvalName; } public void reject(String approvalName) { this.status = Status.Rejected; this.processedBy = approvalName; } public static Builder getBuilder() { return new Builder(); } @Override public String toString() { return type + \" leave for \" + getNoOfDays() + \" day(s) \" + status + \" by \" + processedBy; } // Builder pattern for LeaveApplication public static class Builder { private Type type; private LocalDate from; private LocalDate to; private LeaveApplication application; private Builder() { } public Builder withType(Type type) { this.type = type; return this; } public Builder from(LocalDate from) { this.from = from; return this; } public Builder to(LocalDate to) { this.to = to; return this; } public LeaveApplication build() { this.application = new LeaveApplication(type, from, to); return this.application; } public LeaveApplication getApplication() { return application; } } } // This represents a handler in chain of responsibility interface LeaveApproval { void processLeaveApplication(LeaveApplication application); String getApprovalRole(); } // Abstract handler abstract class Employee implements LeaveApproval { private final String role; private final LeaveApproval successor; public Employee(String role, LeaveApproval successor) { this.role = role; this.successor = successor; } @Override public void processLeaveApplication(LeaveApplication application) { if (!processRequest(application) \u0026\u0026 successor != null) { successor.processLeaveApplication(application); } } protected abstract boolean processRequest(LeaveApplication application); @Override public String getApprovalRole() { return role; } } // A concrete handler: Manager class Manager extends Employee { public Manager(LeaveApproval nextApproval) { super(\"Manager\", nextApproval); } @Override protected boolean processRequest(LeaveApplication application) { switch (application.getType()) { case Sick: application.approve(getApprovalRole()); return true; case PTO: if (application.getNoOfDays() \u003c= 5) { application.approve(getApprovalRole()); return true; } } return false; } } // A concrete handler: ProjectLead class ProjectLead extends Employee { public ProjectLead(LeaveApproval successor) { super(\"Project Lead\", successor); } @Override protected boolean processRequest(LeaveApplication application) { if (application.getType() == LeaveApplication.Type.Sick) { if (application.getNoOfDays() \u003c= 2) { application.approve(getApprovalRole()); return true; } } return false; } } // A concrete handler: Director class Director extends Employee { public Director(LeaveApproval nextApproval) { super(\"Director\", nextApproval); } @Override protected boolean processRequest(LeaveApplication application) { if (application.getType() == LeaveApplication.Type.PTO) { application.approve(getApprovalRole()); return true; } return false; } } // Client class to test the Chain of Responsibility public class Client { public static void main(String[] args) { LeaveApplication application = LeaveApplication.getBuilder() .withType(LeaveApplication.Type.PTO) .from(LocalDate.now()) .to(LocalDate.of(2025, 1, 8)) .build(); System.out.println(application); System.out.println(\"**************************************************\"); LeaveApproval approval = createChain(); approval.processLeaveApplication(application); System.out.println(application); } private static LeaveApproval createChain() { Director director = new Director(null); Manager manager = new Manager(director); ProjectLead lead = new ProjectLead(manager); return lead; } } SHOW OUTPUT Output PTO leave for 8 day(s) Pending by null ************************************************** PTO leave for 8 day(s) Approved by Director --- title: UML Diagram of Chain of Responsibility Design Pattern --- classDiagram class LeaveApproval { +void processLeaveApplication(LeaveApplication) +String getApprovalRole() } class Employee { +String role +LeaveApproval successor +Employee(String, LeaveApproval) +void processLeaveApplication(LeaveApplication) +String getApprovalRole() +protected abstract boolean processRequest(LeaveApplication) } class Manager { +Manager(LeaveApproval) +boolean processRequest(LeaveApplication) } class ProjectLead { +ProjectLead(LeaveApproval) +boolean processRequest(LeaveApplication) } class Director { +Director(LeaveApproval) +boolean processRequest(LeaveApplication) } LeaveApproval \u003c|-- Employee : implements Employee \u003c|-- Manager : extends Employee \u003c|-- ProjectLead : extends Employee \u003c|-- Director : extends Employee *--|\u003e LeaveApproval 4.2 Command The Command Design Pattern is a behavioral design pattern that turns a request into a stand-alone object, allowing the decoupling of the sender of the request from the object that processes the request.\nSHOW CODE Java import java.util.LinkedList; import java.util.List; // Command interface implemented by all concrete command classes interface Command { void execute(); } // Concrete implementation of Command class AddMemberCommand implements Command { private String emailAddress; private String listName; private EWSService receiver; public AddMemberCommand(String email, String listName, EWSService service) { this.emailAddress = email; this.listName = listName; this.receiver = service; } @Override public void execute() { receiver.addMember(emailAddress, listName); } } // Receiver class that performs the actual action class EWSService { // Add a new member to mailing list public void addMember(String contact, String contactGroup) { System.out.println(\"Added \" + contact + \" to \" + contactGroup); } // Remove member from mailing list public void removeMember(String contact, String contactGroup) { System.out.println(\"Removed \" + contact + \" from \" + contactGroup); } } // Invoker class that executes commands on a separate thread class MailTasksRunner implements Runnable { private Thread runner; private List\u0026lt;Command\u0026gt; pendingCommands; private volatile boolean stop; private static final MailTasksRunner RUNNER = new MailTasksRunner(); public static final MailTasksRunner getInstance() { return RUNNER; } private MailTasksRunner() { pendingCommands = new LinkedList\u0026lt;\u0026gt;(); runner = new Thread(this); runner.start(); } // Run method that takes pending commands and executes them @Override public void run() { while (true) { Command cmd = null; synchronized (pendingCommands) { if (pendingCommands.isEmpty()) { try { pendingCommands.wait(); } catch (InterruptedException e) { System.out.println(\"Runner interrupted\"); if (stop) { System.out.println(\"Runner stopping\"); return; } } } cmd = pendingCommands.isEmpty() ? null : pendingCommands.remove(0); } if (cmd == null) { return; } cmd.execute(); } } // Adds a command to the pending commands list for later execution public void addCommand(Command cmd) { synchronized (pendingCommands) { pendingCommands.add(cmd); pendingCommands.notifyAll(); } } // Stops the runner thread public void shutdown() { this.stop = true; this.runner.interrupt(); } } // Client class that demonstrates how the Command pattern works public class Client { public static void main(String[] args) throws InterruptedException { EWSService service = new EWSService(); // Create commands and add them to the runner for execution Command c1 = new AddMemberCommand(\"a@a.com\", \"spam\", service); MailTasksRunner.getInstance().addCommand(c1); Command c2 = new AddMemberCommand(\"b@b\", \"spam\", service); MailTasksRunner.getInstance().addCommand(c2); // Wait for a while to let commands execute Thread.sleep(3000); // Shutdown the runner MailTasksRunner.getInstance().shutdown(); } } --- title: UML Diagram of Command Design Pattern --- classDiagram class Command { +execute() } class AddMemberCommand { -String emailAddress -String listName -EWSService receiver +AddMemberCommand(email: String, listName: String, service: EWSService) +execute() } class EWSService { +addMember(contact: String, contactGroup: String) +removeMember(contact: String, contactGroup: String) } class MailTasksRunner { -Thread runner -List~Command~ pendingCommands -volatile boolean stop -static final MailTasksRunner RUNNER +getInstance(): MailTasksRunner +addCommand(cmd: Command) +shutdown() +run() } class Client { +main(args: String[]) } Command \u003c|-- AddMemberCommand AddMemberCommand --\u003e EWSService : uses MailTasksRunner --\u003e Command : invokes Client --\u003e MailTasksRunner : uses 4.3 Interpreter The Interpreter Design Pattern is a behavioral design pattern used to define a grammatical representation for a language and provide an interpreter to evaluate sentences in that language. It is commonly used to interpret expressions in a simple language or grammar.\nSHOW CODE Java import java.util.ArrayList; import java.util.List; import java.util.Stack; import java.util.StringTokenizer; import java.util.stream.Stream; // User class class User { private List\u0026lt;String\u0026gt; permissions; private String username; public User(String username, String... permissions) { this.username = username; this.permissions = new ArrayList\u0026lt;\u0026gt;(); Stream.of(permissions).forEach(e -\u003e this.permissions.add(e.toLowerCase())); } public List\u0026lt;String\u0026gt; getPermissions() { return permissions; } public String getUsername() { return username; } } // Abstract expression interface PermissionExpression { boolean interpret(User user); } // Terminal expression class Permission implements PermissionExpression { private String permission; public Permission(String permission) { this.permission = permission.toLowerCase(); } @Override public boolean interpret(User user) { return user.getPermissions().contains(permission); } @Override public String toString() { return permission; } } // Non-terminal expression class AndExpression implements PermissionExpression { private PermissionExpression expression1; private PermissionExpression expression2; public AndExpression(PermissionExpression expression1, PermissionExpression expression2) { this.expression1 = expression1; this.expression2 = expression2; } @Override public boolean interpret(User user) { return expression1.interpret(user) \u0026\u0026 expression2.interpret(user); } @Override public String toString() { return expression1 + \" AND \" + expression2; } } // Non-terminal expression class OrExpression implements PermissionExpression { private PermissionExpression expression1; private PermissionExpression expression2; public OrExpression(PermissionExpression one, PermissionExpression two) { this.expression1 = one; this.expression2 = two; } @Override public boolean interpret(User user) { return expression1.interpret(user) || expression2.interpret(user); } @Override public String toString() { return expression1 + \" OR \" + expression2; } } // Non-terminal expression class NotExpression implements PermissionExpression { private PermissionExpression expression; public NotExpression(PermissionExpression expression) { this.expression = expression; } @Override public boolean interpret(User user) { return !expression.interpret(user); } @Override public String toString() { return \"NOT \" + expression; } } // Report class class Report { private String name; private String permission; public Report(String name, String permissions) { this.name = name; this.permission = permissions; } public String getName() { return name; } public String getPermission() { return permission; } } // Parses \u0026 builds abstract syntax tree class ExpressionBuilder { private Stack\u0026lt;PermissionExpression\u0026gt; permissions = new Stack\u0026lt;\u0026gt;(); private Stack\u0026lt;String\u0026gt; operators = new Stack\u0026lt;\u0026gt;(); public PermissionExpression build(Report report) { parse(report.getPermission()); buildExpressions(); if (permissions.size() \u003e 1 || !operators.isEmpty()) { System.out.println(\"ERROR!\"); } return permissions.pop(); } private void parse(String permission) { StringTokenizer tokenizer = new StringTokenizer(permission.toLowerCase()); while (tokenizer.hasMoreTokens()) { String token = tokenizer.nextToken(); switch (token) { case \"and\": operators.push(\"and\"); break; case \"not\": operators.push(\"not\"); break; case \"or\": operators.push(\"or\"); break; default: permissions.push(new Permission(token)); break; } } } private void buildExpressions() { while (!operators.isEmpty()) { String operator = operators.pop(); PermissionExpression perm1; PermissionExpression perm2; PermissionExpression exp; switch (operator) { case \"not\": perm1 = permissions.pop(); exp = new NotExpression(perm1); break; case \"and\": perm1 = permissions.pop(); perm2 = permissions.pop(); exp = new AndExpression(perm1, perm2); break; case \"or\": perm1 = permissions.pop(); perm2 = permissions.pop(); exp = new OrExpression(perm1, perm2); break; default: throw new IllegalArgumentException(\"Unknown operator:\" + operator); } permissions.push(exp); } } } // Client class public class Client { public static void main(String[] args) { Report report1 = new Report(\"Cash flow report\", \"FINANCE_ADMIN OR ADMIN\"); ExpressionBuilder builder = new ExpressionBuilder(); PermissionExpression exp = builder.build(report1); System.out.println(exp); User user1 = new User(\"Dave\", \"USER\"); System.out.println(\"User access report: \" + exp.interpret(user1)); } } --- title: UML Diagram of Interpreter Design Pattern --- classDiagram class PermissionExpression { + interpret(User user): boolean } class Permission { - String permission + Permission(String permission) + interpret(User user): boolean + toString(): String } class AndExpression { - PermissionExpression expression1 - PermissionExpression expression2 + AndExpression(PermissionExpression expression1, PermissionExpression expression2) + interpret(User user): boolean + toString(): String } class OrExpression { - PermissionExpression expression1 - PermissionExpression expression2 + OrExpression(PermissionExpression expression1, PermissionExpression expression2) + interpret(User user): boolean + toString(): String } class NotExpression { - PermissionExpression expression + NotExpression(PermissionExpression expression) + interpret(User user): boolean + toString(): String } class ExpressionBuilder { - Stack~PermissionExpression~ permissions - Stack~String~ operators + build(Report report): PermissionExpression - parse(String permission) - buildExpressions() } class Client { + main(String[] args) } Permission --|\u003e PermissionExpression AndExpression --|\u003e PermissionExpression OrExpression --|\u003e PermissionExpression NotExpression --|\u003e PermissionExpression ExpressionBuilder --\u003e PermissionExpression Client --\u003e ExpressionBuilder 4.4 Mediator 4.5 Iterator 4.6 Momento 4.7 Observer 4.8 State 4.9 Strategy The Strategry Design Pattern is a behavioral design pattern that encapsulates a set of algorithms and allows a client to dynamically choose one at runtime based on the context. This pattern separates the algorithm from the existing code, enabling the addition of new algorithms without modifying the existing code.\nSHOW CODE Java import java.time.LocalDate; import java.util.Collection; import java.util.HashMap; import java.util.Iterator; import java.util.LinkedList; import java.util.Map; // Order class class Order { private final String id; private final LocalDate date; private final Map\u0026lt;String, Double\u0026gt; items = new HashMap\u0026lt;\u0026gt;(); private double total; public Order(String id) { this.id = id; this.date = LocalDate.now(); } public String getId() { return id; } public LocalDate getDate() { return date; } public Map\u0026lt;String, Double\u0026gt; getItems() { return items; } public void addItem(String name, double price) { items.put(name, price); total += price; } public double getTotal() { return total; } public void setTotal(double total) { this.total = total; } } // Strategy Interface interface OrderPrinter { void print(Collection\u0026lt;Order\u0026gt; orders); } // Concrete Strategy 1: Summary Printer class SummaryPrinter implements OrderPrinter { @Override public void print(Collection\u0026lt;Order\u0026gt; orders) { System.out.println(\"*************** Summary Report *************\"); Iterator\u0026lt;Order\u0026gt; iterator = orders.iterator(); double total = 0; for (int i = 1; iterator.hasNext(); i++) { Order order = iterator.next(); System.out.println(i + \". \" + order.getId() + \"\\t\" + order.getDate() + \"\\t\" + order.getItems().size() + \"\\t\" + order.getTotal()); total += order.getTotal(); } System.out.println(\"*******************************************\"); System.out.println(\"\\t\\t\\t\\t Total \" + total); } } // Concrete Strategy 2: Detail Printer class DetailPrinter implements OrderPrinter { @Override public void print(Collection\u0026lt;Order\u0026gt; orders) { System.out.println(\"************* Detail Report ***********\"); Iterator\u0026lt;Order\u0026gt; iter = orders.iterator(); double total = 0; for (int i = 1; iter.hasNext(); i++) { double orderTotal = 0; Order order = iter.next(); System.out.println(i + \". \" + order.getId() + \"\\t\" + order.getDate()); for (Map.Entry\u0026lt;String, Double\u0026gt; entry : order.getItems().entrySet()) { System.out.println(\"\\t\\t\" + entry.getKey() + \"\\t\" + entry.getValue()); orderTotal += entry.getValue(); } System.out.println(\"----------------------------------------\"); System.out.println(\"\\t\\t Total \" + orderTotal); System.out.println(\"----------------------------------------\"); total += orderTotal; } System.out.println(\"----------------------------------------\"); System.out.println(\"\\tGrand Total \" + total); } } // PrintService class for context class PrintService { private final OrderPrinter printer; public PrintService(OrderPrinter printer) { this.printer = printer; } public void printOrders(Collection\u0026lt;Order\u0026gt; orders) { printer.print(orders); } } // Client class to simulate the creation of orders and print them public class Main { private static final LinkedList\u0026lt;Order\u0026gt; orders = new LinkedList\u0026lt;\u0026gt;(); public static void main(String[] args) { createOrders(); // Print all orders using DetailPrinter strategy PrintService service1 = new PrintService(new DetailPrinter()); service1.printOrders(orders); System.out.println(\"\\n\"); // Print all orders using DetailPrinter strategy PrintService service2 = new PrintService(new SummaryPrinter()); service2.printOrders(orders); } private static void createOrders() { Order o = new Order(\"100\"); o.addItem(\"Soda\", 2); o.addItem(\"Chips\", 10); orders.add(o); o = new Order(\"200\"); o.addItem(\"Cake\", 20); o.addItem(\"Cookies\", 5); orders.add(o); o = new Order(\"300\"); o.addItem(\"Burger\", 8); o.addItem(\"Fries\", 5); orders.add(o); } } SHOW OUTPUT Output ************* Detail Report *********** 1. 100\t2024-12-07 Chips\t10.0 Soda\t2.0 ---------------------------------------- Total 12.0 ---------------------------------------- 2. 200\t2024-12-07 Cookies\t5.0 Cake\t20.0 ---------------------------------------- Total 25.0 ---------------------------------------- 3. 300\t2024-12-07 Burger\t8.0 Fries\t5.0 ---------------------------------------- Total 13.0 ---------------------------------------- ---------------------------------------- Grand Total 50.0 *************** Summary Report ************* 1. 100\t2024-12-07\t2\t12.0 2. 200\t2024-12-07\t2\t25.0 3. 300\t2024-12-07\t2\t13.0 ******************************************* Total 50.0 --- title: UML Diagram of Strategy Design Pattern --- classDiagram class Order { +String id +LocalDate date +Map~String, Double~ items +double total +Order(String id) +String getId() +LocalDate getDate() +Map~String, Double~ getItems() +void addItem(String name, double price) +double getTotal() +void setTotal(double total) } class OrderPrinter { +void print(Collection~Order~ orders) } class SummaryPrinter { +void print(Collection~Order~ orders) } class DetailPrinter { +void print(Collection~Order~ orders) } class PrintService { +OrderPrinter printer +PrintService(OrderPrinter printer) +void printOrders(Collection~Order~ orders) } OrderPrinter \u003c|-- SummaryPrinter OrderPrinter \u003c|-- DetailPrinter PrintService *--\u003e OrderPrinter PrintService --\u003e Order 4.10 Template Method 4.11 Visitor 4.12 Null Object ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/design-patterns/1-design-patterns/","summary":"1. Solid Principle 1.1 Single Responsibility Principle A class should have only one reason to change, meaning each class should focus on a single functionality or responsibility.\nSHOW CODE Single Responsibility Principle import java.io.IOException; import java.util.*; import java.util.regex.*; import com.fasterxml.jackson.databind.ObjectMapper; /** * 1. User class is only used to represent entity. * 2. UserValidator class is solely responsible for validating user objects. * 3. Store class is only used to manage user objects storage.","title":"Design Patterns"},{"content":"Introduction to Databases A database is a collection of data that is stored, managed, and accessed electronically. It typically contains one or more tables, which resemble Excel or Google sheets, with data organized into rows and columns. As the number of tables grows, managing the database can become complex, making it essential to design a scalable and maintainable strucutre.\nDatabases can be broadly categorized into two types: Relational database, primarily used for real-time data updates and transactions, and data warehouse, optimized for data analysis and reporting purposes.\nData Modeling Data modeling is the process of creating a conceptual representation of data structures, relationships, and rule to meet business requirements. It serves as a blueprint for designing and managing a database.\nThere are three types of data models: conceptual, logical, and physical. The conceptual data model provides a high-level overview, specifying relationships between objects without technical details. The logical data model refine the conceptual data model by adding more detail, such as fields for each object. The physical data model describe the internal schema of the database, including table structures, storage details, and implementation specifics.\n--- title: Conceptual Data Model --- erDiagram Customer ||--o{ Order : places Order ||--|{ Product : contains --- title: Logical Data Model --- erDiagram Customer { int customerId string name string email } Order { int orderId date orderDate float totalAmount } Product { int productId string productName float price } Customer ||--o{ Order : places Order ||--|{ Product : contains --- title: Physical Data Model --- erDiagram Customer { int customerId PK varchar name varchar email } Order { int orderId PK date orderDate float totalAmount int customerId FK } Product { int productId PK varchar productName decimal price } OrderItem { int orderItemId PK int orderId FK int productId FK int quantity } Customer ||--o{ Order : places Order ||--|{ OrderItem : includes OrderItem ||--|{ Product : contains Example: University Enrollment Management System Entities In database design, an entity is a distinct object that typically represents real-world objects, events, or concepts. Entities are represented as tables in a relational database, and they are similar to classes in object-oriented design. Each row in the table represents an instance of the entity. Each entity has attributes that describe its characteristics. For example, a Student entity may have attributes like student_id, first_name, last_name, and date_of_birth, among others. Entities can be related to one another, and these relationships are often captured using foreign keys or relationship tables, which link entities together based on logical associations. For example, a Student might be linked to a Course through an enrollment relationship.\nIdentifying Entities Identifying entities in database design is a crucial step, as entities form the foundation of a database. A useful approach for identifying entities is to clarify the design objectives and look for nouns in the objective statement. For example, consider the University Enrollment Management System. The objective statement might be:\n\u0026ldquo;The University Enrollment Management System\u0026rdquo; is designed to help a university track enrolled students, the subjects they are taking, and the teachers assigned to those subjects\u0026quot;.\nIn this sentence, the nouns university, student, subject, and teacher are potential entities, as they represent key objects or concepts that the system needs to track.\n--- title: Identifying Entities --- erDiagram UNIVERSITY STUDENT erDiagram TEACHER SUBJECT Defining Attributes In database design, an attribute describes the characteristics of an entity. In a relational database, attributes are typically represented as columns in a table. Defining entity attributes is a crucial step in database design, as it ensures that the entity captures all the necessary details required by the system. When defining attributes, it\u0026rsquo;s important to consider what properties or characteristics the entity possesses.\nFor example, in a University Enrollment Management System, the Student entity might have attributes like first_name, last_name, date_of_birth, and address. After identifying the necessary attributes, the next step is to specify the approapriate data type for each attribute. For instance, attributes like first_name, last_name, and address would typically use the TEXT data type, while the date_of_birth attribute would be defined with the DATE data type.\n--- title: Defining Attributes --- erDiagram UNIVERSITY { string name string address } STUDENT { string first_name string last_name date date_of_birth string address } erDiagram SUBJECT { string subject_name string category string students_enrolled } TEACHER { string first_name string last_name date date_of_birth string address string subject_taught } Normalization Normalization in database design is the process of organizing the attributes of entities and their relationships to reduce data redundency, avoid operational anomalies, and improve data integrity. Normalization involves decomposing a large, complex database into smaller, simpler tables while preserving the relationships between entities. This decomposition follows a set of rules called normal forms. In real-world database design, the three most commonly used normal normal forms are First Normal Form (1NF), Second Normal Form (2NF), and Third Normal Form (3NF).\nFirst Normal Form First Normal Form (1NF) is a property of a relational database table that ensures the table is structured properly. It follows the following conditions:\nEach column must contain atomic values, meaning that the value in a field should be indivisible and not contain sets or lists of values. Each row must be unique, which can be achieved by using a primary key to uniquely identify each record. All values in single column should be of the same data type. A Primary Key is a column (or a set of columns) in a relational database table that uniquely identifies each row in that table. It satisfies the following conditions:\nThe value in the primary key must be unique for each row. The value in the primary key must not be null for any record. The value in the primary key should generally be immutable, meaning it should not change once assigned. When designing tables, assess if any combination of columns can be used to uniquely identify a record. If such a combination exists, those columns can form the primary key. If no suitable combination is found, create a new column to serve as the primary key.\nA primary key can be a set of columns when a single column is not sufficient to uniquely identify a row. For example, in the following table, neither the StudentID nor the CourseID alone can uniquely identify a row, because a student might enroll mutiple courses, and a course can have multiple students. However, the combination of both columns can uniquely identify each enrollment record.\nStudentID CourseID EnrollmentDate 1 CS101 2024-01-01 1 MATH101 2024-01-02 2 CS101 2024-01-03 1NF: Student In the following Student table, there is no single field that can uniquely identify a row. Therefore, it is necessary to add a new field. such as StudentID, to ensure each row has a unique identifier. Additionally, the Address field may contain multiple values, such as unit number, street number, street name, suburb, city, state, country, and postcode. To comply with the First Normal Form (1NF), the Address firld must be divided into multiple separate columns, ensuring that each column contains only atomic values.\n--- title: Violation of 1NF - Student --- erDiagram STUDENT { string first_name string last_name date date_of_birth string address } --- title: Comply with 1NF - Student --- erDiagram STUDENT { number student_id PK string first_name string last_name date date_of_birth number unit_number number street_number string street_name string suburb string city string state string country string postcode } 1NF: Subject --- title: Violation of 1NF - Subject --- erDiagram SUBJECT { string subject_name string category string students_enrolled } --- title: Comply with 1NF - Subject --- erDiagram SUBJECT { number subject_id PK string subject_name string category string students_enrolled } 1NF: Teacher --- title: Violation of 1NF - Teacher --- erDiagram TEACHER { string first_name string last_name date date_of_birth string address string subject_taught } --- title: Comply with 1NF - Teacher --- erDiagram TEACHER { number teacher_id PK string first_name string last_name date date_of_birth number unit_number number street_number string street_name string suburb string city string state string country string postcode string subject_taught } 1NF: University --- title: Violation of 1NF - University --- erDiagram UNIVERSITY { string name string address } --- title: Comply with 1NF - University --- erDiagram UNIVERSITY { number university_id PK string name number unit_number number street_number string street_name string suburb string city string state string country string postcode } Second Normal Form The Second Normal Form (2NF) in database design is a level of normalization that builds upon the First Normal Form (1NF). A table is in 2NF if every non-key attribute is fully functionally dependent on the entire primary key, not just part of it, particularly in tables with composite primary keys (a key made up of two or more columns).\nRelationships Relationship in database design refers to the association between different entities (tables) in a database. It defines how data in one table is related to data in another table, enabling efficient organization and retrival of data. Relationships are established through a foreign key, which is a column in one table that references the primary key of another table. There are four main types of relationships: One-to-One (1:1), One-to-Many (1:N), Many-to-Many (N:M), and Self-Reference.\nIn a One to One relationship, each record in one table is related to exactly one record in another table. For example, consider a Person table and a Passport table, where each person has one unique passport, and each passport is associated with only one person. This type of relationship is relatively rare in real-world database design.\nThe One to Many relationship is the most common type in real-world database design. In a 1:N relationship, one record in a table can be linked to multiple records in another table. For example, in a Department table and an Employee table, one department can have many employees, but each employee blongs to exactly one department. This is a typical relational model for most business applications.\nThe Many-to-Many relationship is common but often requires an intermediary table to properly represent the association. In an N:M relationship, multiple records in one table can be asoociated with multiple records in another table. For instance, in a Student table and a Course table, a student can enroll in many courses, and each course can have many students enrolled. This relationship is typically handled by a joining table, such as Student_Course.\nIn a Self-Referencing relationship, a table is related to itself. In other words, a record in the table is associated with another record in the same table. For example, in an Employee table, each employee has a Manager, and that manager may also have a manager. This type of relationship is useful for representing hierarchical structures, such as organizational charts.\nIn database design, a foreign key is a column that references the primary key of another table. It is used to establish a relationship between two tables, ensuring referential integrity and maintaining consistent data across the database.\n2NF: Subject \u0026amp; Category In the following Subject table, the subject_name is dependent on the primary key subject_id, but the category is not fully dependent on the primary key, which violates 2NF. To resolve this issue, a new Category table should be created with two fields: category_id as the primary key and subject_id as a foreign key. The two tables have a One-to-Many relationship, where each category can have many subjects, while each subject bleongs to exactly one category.\n--- title: Violation of 2NF - Subject --- erDiagram SUBJECT { number subject_id PK string subject_name string category } --- title: Comply with 2NF - Subject --- erDiagram SUBJECT { number subject_id PK string subject_name number category_id FK } CATEGORY { number category_id PK string category_name } CATEGORY ||--|{ SUBJECT : \"\" 2NF: Student \u0026amp; Subject In the following Subject table, the subject_id and students_enrolled create a Many-to-Many relationship. However, relational databases should not represent Many-to-Many relationships directly in s single table. This is because a single table cannot handle multiple instances of related data (such as multiple students enrolled in multiple subjects) within a single field. To resolve this issue, a junction table is introduced. It breaks down the Many-to-Many relationship into two One-to-Many relationships, ensuring data integrity and normalization.\n--- title: Violation of 2NF - Subject --- erDiagram SUBJECT { number subject_id PK string subject_name string students_enrolled } subject_id subject_name students_name 1 Math Alice, Bob, Charlie 2 History David, Emily, Frank, Grace 3 Science Helen, Ian In the above table, the students_enrolled field violates First Normal Form (1NF), which requires each column to contain only atomic values. Additionally, this design leads to data redundancy. For example, if the student Alice enrolls in multiple courses such as Math, History, and Science. her name will be repeated in each row, causing unnecessary duplication of data.\nFurthermore, this design makes data manipulation more complex. For instance, when a student drops a course or a new student enrolls in a course, the list of students in the students_enrolled column must be manually updated, which is error-prone and inefficient.\n--- title: Comply with 2NF - Subject --- erDiagram SUBJECT { number subject_id PK string subject_name } STUDENT { number student_id PK string students_enrolled } ENROLLMENT { number subject_id FK number student_id FK } SUBJECT ||--|{ ENROLLMENT : \"has\" STUDENT ||--|{ ENROLLMENT : \"enrolled in\" Comply with 2NF: Real-World Example 2NF: Teacher --- title: Violation of 2NF - Teacher (subject_taught) --- erDiagram TEACHER { number teacher_id string first_name string last_name date date_of_birth string subject_taught } --- title: Comply with 2NF - Teacher --- erDiagram TEACHER { number teacher_id string first_name string last_name date date_of_birth } SUBJECT { number subject_id PK string subject_name number category_id FK number teacher_id FK } TEACHER ||--|{ SUBJECT : \"teaches\" 2NF: University --- title: Comply with 2NF - UNIVERSITY --- erDiagram UNIVERSITY { number university_id PK string name } SUBJECT { number subject_id PK string subject_name number category_id FK number teacher_id FK number university_id FK } UNIVERSITY ||--|{ SUBJECT : \"\" Third Normal From Third Normal Form (3NF) is a level of normalization that satisfies Second Normal Form (2NF) and eliminates transitive dependencies. In simpler terms, a non-key attribute in a table should not depend on another non-key attrubute. For example, if A $\\rightarrow$ B and B $\\rightarrow$ C, then A $\\rightarrow$ C, which means C should be moved to a separate table to avoid redundency. This process helps reduce data redundency and improves the efficiency of relational databases.\n3NF: Student In the following Student table, the non-key attributes (unit_number, street_number, street_name, suburb, city, state, country, and postcode) are not directly dependent on the primary key student_id; instead, they depend on the student\u0026rsquo;s address. This results in a transitive dependency, which violates 3NF. Furthermore, since multiple students may share the same address, these address attributes will be repeated for each student, leading to data redundency.\n--- title: Violation of 3NF - Student --- erDiagram STUDENT { number student_id PK string first_name string last_name date date_of_birth number unit_number number street_number string street_name string suburb string city string state string country string postcode } --- title: Comply with 3NF - Student --- erDiagram STUDENT { number student_id PK string first_name string last_name date date_of_birth number address_id FK } ADDRESS { number address_id PK number unit_number number street_number string street_name string suburb string city string state string country string postcode } STUDENT ||--|{ ADDRESS : \"\" 3NF: Teacher --- title: Comply with 3NF - Teacher --- erDiagram TEACHER { number teacher_id PK string first_name string last_name date date_of_birth number address_id FK } ADDRESS { number address_id PK number unit_number number street_number string street_name string suburb string city string state string country string postcode } TEACHER ||--|{ ADDRESS : \"\" 3NF: University --- title: Comply with 3NF - University --- erDiagram UNIVERSITY { number university_id PK string name number address_id FK } ADDRESS { number address_id PK number unit_number number street_number string street_name string suburb string city string state string country string postcode } UNIVERSITY ||--|{ ADDRESS : \"\" Design Considerations Determine Data Types \u0026amp; Precision Determining data types and precision in database design is crucial for ensuring optimal storage, performance, and accuracy of data. There are typically three steps to determine the apprpriate data type and precision for a field:\nIdentifying the nature of the field: Determine the type of data the field will store—whether it\u0026rsquo;s numeric, string, or data/time. For example, the student_id field might be of type INT, while the first_time field might of type CHAR or VARCHAR. Choose the smallest sufficient data type: Select the samllest data type that can accommodate the required values. For example, if a field\u0026rsquo;s values range from -128 to 127, use TINYINT instead of INT to optimize performance and storage efficiency. Set precision and scale for numeric values: For numeric fields, it\u0026rsquo;s important to define the precision (total number of digits) and scale (number of digits after the decimal point). For example, a price field should be set to DECIMAL(10,2), which allows for 10 digits in total, with 2 digits after the decimal point. Integrity Constraints Integrity Constraints in database design are rules that ensure the accuracy, consistency, and validity of data. There are several types of integrity constraints, each serving a specific purpose:\nEntity Integrity Entity Integrity ensures that each record in a table is unique and identifiable. This is achieved by setting a column in a table as a primary key. For example, the student_id field must be unique for each record in the Student table.\nCREATE TABLE Student ( student_id INT PRIMARY KEY, first_name VARCHAR(100), last_name VARCHAR(100) ); Referencial Integrity Referencial Integrity ensures that relationships between tables are maintained consistently. Foreign keys enforce this constraint by ensuring that a value in one table corresbonds to a valid value in another table. For example, the student_id field in the Enrollment table serves as a foreign key referencing the primary key student_id in the Student table.\nCREATE TABLE Enrollment ( enrollment_id INT PRIMARY KEY, student_id INT, course_id INT, FOREIGN KEY (student_id) REFERENCES Students(student_id) ); Domain Integrity Domain Integrity ensures that the data entered in a column matches the defined data type, format, and range. This is enforced using data types. default values. and check constraints. For example, the price field should only store positive values.\nCREATE TABLE Product ( product_id INT PRIMARY KEY, product_name VARCHAR(100), price DECIMAL(10, 2) CHECK (price \u0026gt; 0) ); User-Defined Integrity User-defined integrity enforces business rules specific to the application or domain. For instance, in the Enrollment table, the combination of student_id and course_id should be unique to prevent a student from enrolling in the same course more than once.\nCREATE TABLE Enrollment ( enrollment_id INT PRIMARY KEY, student_id INT, course_id INT, UNIQUE (student_id, course_id) ); Null Integrity Null integrity ensures that certain fields cannot store NULL values. This is enforced by defining the column with the NOT NULL constraint. For example, the student_id field in the Student table must not be NULL because it is used to identify each record.\nCREATE TABLE Student ( student_id INT PRIMARY KEY NOT NULL, first_name VARCHAR(100) NOT NULL, last_name VARCHAR(100) NOT NULL ); ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/database/1-database-design/","summary":"Introduction to Databases A database is a collection of data that is stored, managed, and accessed electronically. It typically contains one or more tables, which resemble Excel or Google sheets, with data organized into rows and columns. As the number of tables grows, managing the database can become complex, making it essential to design a scalable and maintainable strucutre.\nDatabases can be broadly categorized into two types: Relational database, primarily used for real-time data updates and transactions, and data warehouse, optimized for data analysis and reporting purposes.","title":"Database Design"},{"content":"Recursion Recursion is a programming technique where a function repeatedly calls itself until it reaches a base case, whcih stops the recursion and allows it to return a result. It is a way of breaking down complex problems into smaller, simpler subproblems that are eaiser to solve.\nHead Recursion Head Recursion is a type of recursion where a function makes its recursive call first, immediately after checking the base case, and performs all other operations only after the recursive call returns.\nSHOW CODE: Head Recursion Head Recursion void printNumbers(int n) { if (n == 0) { return; // Base case } printNumbers(n - 1); // Recursive call printf(\"%d\\n\", n); // Processing after recursion } Call Stack Operation Current Value of n headRecursion(3) Call function 3 headRecursion(2) Call function 2 headRecursion(1) Call function 1 headRecursion(0) Base case, exit 0 Unwinding begins: printf(1) Print 1 1 printf(2) Print 2 2 printf(3) Print 3 3 Tail Recursion Tail Recursion is a type of recursion where a function makes its recursive call as the last operation in its body. with no further operations after the call. This type of recursion can be optimized by the compiler into an iterative loop through tail call optimization (TCO), which help reduce memory consumption by the reusing the stack frame.\nSHOW CODE: Tail Recursion Tail Recursion void tailRecursion(int n) { if (n \u003e 0) { printf(\"%d \", n); // Operation first tailRecursion(n - 1); // Recursive call at the end } } Call Stack Operation Current Value of n tailRecursion(3) Print 3 3 tailRecursion(2) Print 2 2 tailRecursion(1) Print 1 1 tailRecursion(0) Base case, exit 0 Tail recursion is generally perfered for performance when recursion depth is large because it can be optimized into an iterative process.\nSHOW CODE: Tail Recursion Optimization Tail Recursion Optimization void tailRecursionOptimized(int n) { while (n \u003e 0) { printf(\"%d \", n); // Operation first n--; // Decrement n, same as `tailRecursion(n - 1)` } } In the above code, optimized Loop replaces recursion with a loop, ensuring only a single stack frame is used.\nConditions for Tail Recursion: The recursive call must be the last operation in the function, and its result must be immediately returned without any further computation after the call.\nSHOW CODE: Tail Recursive Function Tail Recursive Function // Tail recursive function to calculate factorial int factorialTailRecursion(int n, int accumulator) { if (n == 0) { return accumulator; // Base case: return accumulated result } return factorialTailRecursion(n - 1, accumulator * n); // Recursive call is the last operation } SHOW CODE: Non-tail Recursive Function Non-tail recursive // Non-tail recursive function to calculate factorial int factorialNonTailRecursion(int n) { if (n == 0) { return 1; // Base case } return n * factorialNonTailRecursion(n - 1); // Recursive call is not the last operation } Tree Recursion Tree recursion is a type of recursion in which a function makes multiple recursive calls to itself in its body, it creates a tree-like data structure, as each call can branch into multiple additional calls.\nSHOW CODE C public int fib(int n) { if (n \u003c= 1) { return n; } return fib(n - 1) + fib(n - 2); } Recursion Tree Analysis:\n--- title: Recursion Tree Analysis - fibonacci sequence --- graph TD L0((\"fib\\(5\\)\")) --\u003e L1((\"fib\\(4\\)\")) L0 --\u003e L2((\"fib\\(3\\)\")) L1 --\u003e L3((\"fib\\(3\\)\")) L1 --\u003e L4((\"fib\\(2\\)\")) L2 --\u003e L5((\"fib\\(2\\)\")) L2 --\u003e L6((\"fib\\(1\\)\")) L3 --\u003e L7((\"fib\\(2\\)\")) L3 --\u003e L8((\"fib\\(1\\)\")) L4 --\u003e L9((\"fib\\(1\\)\")) L4 --\u003e L10((\"fib\\(0\\)\")) L5 --\u003e L11((\"fib\\(1\\)\")) L5 --\u003e L12((\"fib\\(0\\)\")) L7 --\u003e L13((\"fib\\(1\\)\")) L7 --\u003e L14((\"fib\\(0\\)\")) Array An array is a data structure that stores a collection of elements of the same type in a fixed-size, continguous block of memory. Arrays can be categorized into two types: static arrays and dynamic arrays.\nA static array has a fixed size that cannot be changed after its declaration. Memory for a static array is allocated at compile time, and its size must be explicitly specified.\nIn contrast, a dynamic array allows its size to be adjusted during runtime, enabling it to grow or shrink as needed. Unlike static arrays, the size of a dynamic array does not need to be specified at the time of declaration, and memory is allocated dynamically from the heap.\nImplementation of Static Arrays Implementation of Dynamic Arrays Compiler\u0026rsquo;s Memory Layout for Arrays The address of an array element is determined at runtime. Array elements are stored in a continguous block of memory, and the compiler calculates each element\u0026rsquo;s address using its index and the size of each element.\n1-Dimentional Array Element Access Formula (0-based index): $\\text{Addr}_{A[i]} = B + i \\times W$\nB: Base Address i: Zero-based Index of Each Element W: Size of Each Element SHOW CODE C #include \u0026lt;stdio.h\u0026gt; int main() { int arr[5] = {10, 20, 30, 40, 50}; for (int i = 0; i \u003c 5; i++) { void *addr_i = (void *) arr + (i * sizeof(int)); printf(\"Element at index %d: %d \\t Address: %p\\n\", i, arr[i], addr_i); } return 0; } SHOW OUTPUT Output Element at index 0: 10 Address: 0x7ff7bb0b7170 Element at index 1: 20 Address: 0x7ff7bb0b7174 Element at index 2: 30 Address: 0x7ff7bb0b7178 Element at index 3: 40 Address: 0x7ff7bb0b717c Element at index 4: 50 Address: 0x7ff7bb0b7180 2-Dimentional Array Element Access Formula (Row Major Order): $\\text{Addr}_{A[i][j]} = \\text{B} + [(i \\times \\text{C}) + j] \\times \\text{W}$\nB: Base Address i: Zero-based Row Index of Each Element j: Zero-based Column Index of Each ELement C: Number of Columns W: Size of Each Element SHOW CODE C #include \u0026lt;stdio.h\u0026gt; int main() { int arr[2][3] = {{1, 2, 3}, {4, 5, 6}}; for (int i = 0; i \u003c 2; i++) { for (int j = 0; j \u003c 3; j++) { void *addr_ij = (void *) \u0026arr + (i * 3 + j) * sizeof(int); printf(\"Element at [%d][%d]: %d, Address: %p\\n\", i, j, arr[i][j], addr_ij); } } return 0; } SHOW OUTPUT Output Element at [0][0]: 1, Address: 0x7ff7b2c64170 Element at [0][1]: 2, Address: 0x7ff7b2c64174 Element at [0][2]: 3, Address: 0x7ff7b2c64178 Element at [1][0]: 4, Address: 0x7ff7b2c6417c Element at [1][1]: 5, Address: 0x7ff7b2c64180 Element at [1][2]: 6, Address: 0x7ff7b2c64184 Why do most compilers use 0-based indexing? Take a 1-dimentional array as an example, the element access formula for a 0-based index is $\\text{Addr}_{A[i]} = B + i \\times W$. This formula requires two operations (multiplication and addition) to access each element in the array.\nIn contract, the formula for 1-based indexing is $\\text{Addr}_{A[i]} = B + (i - 1) \\times W$. This requires three operations (multiplication. subtraction, and addition). Compared to 0-based indexing, 1-based indexing introduces one additional operation, which becomes a significant overhead when dealing with large size arrays.\nString Matrix Linked List Stack Queue A Queue is a linear data structure that follows the First In, First Out (FIFO) principle, meaning elements are added to the back and removed from the front. There are four main types of queues: Simple Queue, Circular Queue, Double-Ended Queue (Deque), and Priority Queue.\nSimple Queue A Simple Queue is a basic type of queue data structure in which elements are added to the back and removed from the front, following the First In, First Out (FIFO) principle.\nImplementation of Simple Queue Array with a single pointer SHOW CODE Java class SimpleQueue { private final int[] queue; private final int capacity; private int rear; public SimpleQueue(int capacity) { this.queue = new int[capacity]; this.capacity = capacity; this.rear = -1; } public boolean isEmpty() { return rear == -1; } private boolean isFull() { return rear == capacity - 1; } public int size() { return rear + 1; } public void enqueue(int element) { if (this.isFull()) { System.out.println(\"Queue is full.\"); } else { rear++; queue[rear] = element; } } public int dequeue() { if (this.isEmpty()) { System.out.println(\"Queue is empty.\"); return -1; } int frontElement = queue[0]; // Shift all elements to the left for (int i = 0; i \u003c rear; i++) { queue[i] = queue[i + 1]; } rear--; return frontElement; } public int peek() { if (this.isEmpty()) { System.out.println(\"Queue is empty.\"); return -1; } return queue[0]; } } public class Main { public static void main(String[] args) { SimpleQueue queue = new SimpleQueue(5); queue.enqueue(10); queue.enqueue(20); queue.enqueue(30); System.out.println(\"Front element: \" + queue.peek()); // Expected: 10 System.out.println(\"Dequeued: \" + queue.dequeue()); // Expected: 10 queue.enqueue(40); queue.enqueue(50); System.out.println(\"Queue size: \" + queue.size()); // Expected: 4 System.out.println(\"Dequeued: \" + queue.dequeue()); // Expected: 20 } } The implementation of a queue using an array with a single pointer (rear) is inefficient for deletion because the remaining elements need to be shifted left after every dequeue operation.\nArray with two pointers SHOW CODE Java class SimpleQueue { private final int[] queue; private final int capacity; private int front; private int rear; public SimpleQueue(int capacity) { this.capacity = capacity; queue = new int[capacity]; this.front = -1; this.rear = -1; } public boolean isEmpty() { return front == -1; } private boolean isFull() { return rear + 1 == capacity; } public int size() { if (this.isEmpty()) { return 0; } return rear - front + 1; } public void enqueue(int element) { if (this.isFull()) { System.out.println(\"Queue is full.\"); } else { // Set front to 0 when the first element is added if (front == -1) { front = 0; } rear++; queue[rear] = element; } } public int dequeue() { if (this.isEmpty()) { System.out.println(\"Queue is empty.\"); return -1; } else { int frontElement = queue[front]; // Reset both pointers to -1 when the queue has only one element if (front == rear) { front = -1; rear = -1; } else { // Move front to the next element front++; } return frontElement; } } public int peek() { if (this.isEmpty()) { System.out.println(\"Queue is empty.\"); return -1; } else { return queue[front]; } } } public class Main { public static void main(String[] args) { SimpleQueue queue = new SimpleQueue(5); queue.enqueue(10); queue.enqueue(20); queue.enqueue(30); System.out.println(\"Front element: \" + queue.peek()); // Expected: 10 System.out.println(\"Dequeued: \" + queue.dequeue()); // Expected: 10 queue.enqueue(40); queue.enqueue(50); System.out.println(\"Queue size: \" + queue.size()); // Expected: 3 System.out.println(\"Dequeued: \" + queue.dequeue()); // Expected: 20 } } Implementing a queue using an array with two pointers (front and rear) is more efficient for deletion compared to using a single pointer (rear), as it eliminates the need to shift elements to the left after each dequeue operation. However, this approach has drawback: the space in front of the front pointer cannot be reused until the array is empty, leading to potential wasted memory.\nLinked List with a pointer SHOW CODE Java class Node { int data; Node next; public Node(int data) { this.data = data; this.next = null; } } class SimpleQueue { private Node front; private int size; public SimpleQueue() { front = null; size = 0; } // Check if the queue is empty public boolean isEmpty() { return size == 0; } // Get the current size of the queue public int size() { return size; } // Display the elements of the queue public void display() { if (isEmpty()) { System.out.println(\"Queue is empty.\"); return; } // Traverse through the queue and print its elements Node temp = front; // Use StringBuilder to efficiently build the string StringBuilder builder = new StringBuilder(); while (temp != null) { builder.append(temp.data).append(\"\u003c-\"); temp = temp.next; } // Remove the last \"\u003c-\" (extra arrow at the end) builder.setLength(builder.length() - 2); System.out.println(builder); } // Add an element to the rear (end) of the queue public void enqueue(int data) { Node node = new Node(data); // If the queue is empty, the new node becomes the front of the queue if (isEmpty()) { front = node; } else { Node temp = front; // Traverse the list to find the last node (rear of the queue) while (temp.next != null) { temp = temp.next; } temp.next = node; // Link the new node at the end of the queue } size++; // Increment the size of the queue } // Remove and return the element from the front of the queue public int dequeue() { if (isEmpty()) { throw new IllegalStateException(\"Queue is empty.\"); } int dequeued = front.data; front = front.next; size--; return dequeued; } // Return the element from the front of the queue without removing it public int peek() { if (isEmpty()) { throw new IllegalStateException(\"Queue is empty.\"); } return front.data; } } public class Main { public static void main(String[] args) { SimpleQueue queue = new SimpleQueue(); // Enqueue some elements into the queue queue.enqueue(10); queue.enqueue(20); queue.enqueue(30); queue.enqueue(40); System.out.println(\"Queue after enqueuing elements:\"); queue.display(); // Display the current state of the queue // Dequeue two elements and print them System.out.println(\"Dequeued: \" + queue.dequeue()); System.out.println(\"Dequeued: \" + queue.dequeue()); System.out.println(\"Queue after dequeuing elements:\"); queue.display(); // Display the queue after dequeuing elements // Peek at the front element without removing it System.out.println(\"Peek front: \" + queue.peek()); // Print the current size of the queue System.out.println(\"Queue size: \" + queue.size()); } } Linked List with two pointers SHOW CODE Java // Node class representing each element in the queue class Node { int data; Node next; public Node(int data) { this.data = data; this.next = null; } } // SimpleQueue class implementing queue operations using a linked list class SimpleQueue { private Node front; private Node rear; private int size; // Constructor to initialize the queue public SimpleQueue() { front = rear = null; size = 0; } // Check if the queue is empty public boolean isEmpty() { return size == 0; } // Get the size of the queue public int size() { return size; } // Display the elements in the queue public void display() { if (isEmpty()) { System.out.println(\"Queue is empty.\"); return; } // Build a string representation of the queue StringBuilder builder = new StringBuilder(); Node temp = front; while (temp != null) { builder.append(temp.data).append(\"\u003c-\"); temp = temp.next; } // Remove the trailing \" \u003c- \" builder.setLength(builder.length() - 2); System.out.println(builder); } // Enqueue: Add an element to the rear of the queue public void enqueue(int data) { Node newNode = new Node(data); // If the queue is empty, both front and rear point to the new node if (isEmpty()) { front = rear = newNode; } else { // Add new node at the end and update the rear pointer rear.next = newNode; rear = newNode; } size++; } // Dequeue: Remove and return the element from the front of the queue public int dequeue() { if (isEmpty()) { throw new IllegalStateException(\"Queue is empty.\"); } // Get the front element and update the front pointer int dequeuedData = front.data; front = front.next; // If the queue becomes empty, reset the rear to null if (front == null) { rear = null; } size--; return dequeuedData; } // Peek: Get the front element without removing it public int peek() { if (isEmpty()) { throw new IllegalStateException(\"Queue is empty.\"); } return front.data; } } // Main class to test the queue implementation public class Main { public static void main(String[] args) { SimpleQueue queue = new SimpleQueue(); // Enqueue elements into the queue queue.enqueue(10); queue.enqueue(20); queue.enqueue(30); queue.enqueue(40); // Display the queue after enqueuing elements System.out.println(\"Queue after enqueuing elements:\"); queue.display(); // Dequeue elements from the queue System.out.println(\"Dequeued: \" + queue.dequeue()); System.out.println(\"Dequeued: \" + queue.dequeue()); // Display the queue after dequeuing elements System.out.println(\"Queue after dequeuing elements:\"); queue.display(); // Peek the front element and show the queue size System.out.println(\"Peek front: \" + queue.peek()); System.out.println(\"Queue size: \" + queue.size()); } } Circular Queue A Circular Queue is a variation of the standard queue data structure that reuses the space freed by dequeue operations by connecting the last position back to the front position. It overcomes the limitation of a simple fixed-size queue, where the space at the front of the queue cannot be reused after dequeueing elements.\nArray Implementation SHOW CODE Java class CircularQueue { private final int[] queue; private int front; private int rear; private final int capacity; private int size; public CircularQueue(int capacity) { this.capacity = capacity; queue = new int[capacity]; front = rear = -1; // Initialize both front and rear as -1 to indicate the queue is empty size = 0; } // Check if the queue is empty public boolean isEmpty() { return size == 0; } // Check is the queue is full public boolean isFull() { return size == capacity; } // Get the current size of the queue public int size() { return size; } // Display the elements of the queue public void display() { if (isEmpty()) { System.out.println(\"Queue is empty.\"); return; } StringBuilder builder = new StringBuilder(); for (int i = 0; i \u003c size; i++) { builder.append(queue[(front + i) % capacity]); if (i != size - 1) { builder.append(\"\u003c-\"); } } System.out.println(builder); } public void enqueue(int data) { if (isFull()) { throw new IllegalStateException(\"Queue is full.\"); } if (isEmpty()) { front = 0; } // Move the rear pointer in a circular manner rear = (rear + 1) % capacity; // Add the data to the rear of the queue queue[rear] = data; // Increase the size size++; } public int dequeue() { if (isEmpty()) { throw new IllegalStateException(\"Queue is empty.\"); } int dequeued = queue[front]; if (front == rear) { // If the queue become empty, reset both front and rear to -1 front = rear = -1; } else { // Move the front pointer in a circular manner front = (front + 1) % capacity; } size--; // Decrease the size return dequeued; } public int peek() { if (isEmpty()) { throw new IllegalStateException(\"Queue is empty.\"); } return queue[front]; } } public class Main { public static void main(String[] args) { CircularQueue queue = new CircularQueue(5); queue.enqueue(10); queue.enqueue(20); queue.enqueue(30); queue.enqueue(40); queue.enqueue(50); System.out.println(\"Queue after enqueuing 5 elements:\"); queue.display(); // Attempt to enqueue an element to a full queue (throws exception) try { queue.enqueue(60); } catch (IllegalStateException e) { System.out.println(e.getMessage()); } // Dequeue two elements System.out.println(\"Dequeued: \" + queue.dequeue()); System.out.println(\"Dequeued: \" + queue.dequeue()); System.out.println(\"Queue after dequeuing 2 elements:\"); queue.display(); // Enqueue two more elements queue.enqueue(60); queue.enqueue(70); System.out.println(\"Queue after enqueuing 2 more elements:\"); queue.display(); // Peek at the front element System.out.println(\"Front element: \" + queue.peek()); // Display the current size of the queue System.out.println(\"Queue size: \" + queue.size()); } } Linked List Implementation SHOW CODE Java class Node { int data; Node next; public Node(int data) { this.data = data; this.next = null; } } class CircularQueue { private Node front; private Node rear; private int size; public CircularQueue() { front = rear = null; size = 0; } // Check if the queue is empty public boolean isEmpty() { return size == 0; } // Get the size of the queue public int size() { return size; } // Display the elements of the queue public void display() { if (isEmpty()) { System.out.println(\"Queue is empty.\"); return; } Node temp = front; StringBuilder builder = new StringBuilder(); do { builder.append(temp.data).append(\"\u003c-\"); temp = temp.next; } while (temp != front); // Loop until reach the front newNode again builder.setLength(builder.length() - 2); System.out.println(builder); } // Add an element to the queue public void enqueue(int data) { Node newNode = new Node(data); // Both front and rear will point to the new node if queue is empty if (isEmpty()) { front = rear = newNode; } else { rear.next = newNode; // Connect the current rear to the new node rear = newNode; // Move the rear to the new node } rear.next = front; // Connect the rear's next to the front size++; } // Remove the front element in the queue public int dequeue() { if (isEmpty()) { throw new IllegalStateException(\"Queue is empty\"); } int dequeued = front.data; // Set both front and rear to null if there is only one element if (front == rear) { front = rear = null; } else { front = front.next; // Move the front node to the next rear.next = front; // Maintain the circular link } size--; return dequeued; } // Get the front element without removing it public int peek() { if (isEmpty()) { throw new IllegalStateException(\"Queue is empty.\"); } return front.data; } } public class Main { public static void main(String[] args) { CircularQueue queue = new CircularQueue(); // Enqueue elements queue.enqueue(10); queue.enqueue(20); queue.enqueue(30); queue.enqueue(40); // Display queue elements System.out.println(\"Queue after enqueuing elements:\"); queue.display(); // Dequeue elements System.out.println(\"Dequeued: \" + queue.dequeue()); System.out.println(\"Dequeued: \" + queue.dequeue()); // Display queue elements after dequeueing System.out.println(\"Queue after dequeuing elements:\"); queue.display(); // Peek front element System.out.println(\"Peek front: \" + queue.peek()); // Display the size of the queue System.out.println(\"Queue size: \" + queue.size()); } } Double Ended Queue Priority Queue Tree Graph A graph is a fundamental data structure used to represent the connections or relationships between entities. It consists of vertices (also called node) and edges (also called arcs). A vertex represents a single entity in the graph, while an edge represents a connection or relationship between two vertices. Edges may have additional properties, such as weight (to indicate the cost or distance of the connection) or direction (to indicate the direction of the relationship).\nTypes of Graph Undirected Graph vs. Directed Graph In an undirected graph, the connection between two vertices is bidrectional. For example, if there is an edge between vertex A and vertex B, traversal is possible from A to B and from B to A. In contrast, in a directed graph, the relationships are one-way. For instance, if there is an edge from vertex A to vertex B, traversal is possible from A to B, but not from B to A unless there is a separate edge in the opposite direction.\nUnweighted Graph vs. Weighted Graph In an unweighted graph, the relationships between vertices have no additional properties, and all edges are treated equally. In contrast, a weighted graph assigns a weight to each node, which can represent attributes such as distance, time, cost, eetc. The weight provides more information about the connection between vertices and is often used in problems like shortest path or network flow.\nCyclic Graph vs. Acyclic Graph A cyclic graph contains at least one cycle, which is a path that starts and ends at the same vertex. In contrast, an acyclic graph doest not contain any cycles. A special case of an acyclic graph is the directed acyclic graph (DAG), which has directed edges and no cycles.\nConnected Graph vs. Disconnected Graph A connected graph is a graph in which there is a path between every pair of vertices. In contrast, a disconnected graph is a graph where at least one pair of vertices is not connected by any path.\nGraph Terminology The degree of a vertex is the number of edges incident to that vertex. In an undirected graph, the degree is simply the number of edges connected to the vertex. In a directed graph, the degree is the sum of the in-degree (number of incoming edges) and the out-degree (number of outgoing edges) of the vertex.\nA path is a sequence of vertices where each consecutive pair of vertices is connected by an edge.\nA cycle is a path that starts and ends at the same vertex, with no repeated vertices except for the starting or ending vertex. For example, in a cycle with $A \\rightarrow B \\rightarrow C \\rightarrow D \\rightarrow A$, the path starts and ends at the same vertex $A$, but each of the other vertices $(B, C, and D)$ is visited exactly once.\nConnectivity refers to whether there exists a path between any pair of vertices in the graph.\nA subgraph is a graph formd by a subset of the vertices and edges of the original graph.\nA component is a subgraph where there is a path between every pair of vertices in that subgraph.\nGraph Representation Adjacency Matrix An Adjacency Matrix ia a 2-dimentional array where each element at position [i][j] represents an edge between vertex i and j. In a weighted graph, the value at position [i][j] stores the weight of the edge between the two vertices. In an unweight graph, the value at position [i][j] typically stores 1 to indicate an edge exists between the vertices, and 0 to indicate no edge exists. The space complexity of an adjacency matrix is $O(V^2)$, where $V$ is the number of vertices, as it requires a matrix of size $V \\times V$ to represent the graph.\nAdjacency List An Adjacency List is a collection of lists, where each position i stores a list of nerighbors of vertex i. In a weighted graph. each element in the list typically represents a pair (neighbor, weight), where neighbor is a vertex connected to i, and weight is the weight of the edge between i and neighbor. The space complexity of an adjacency list is $O(V + E)$, where $V$ is the number of vertices and $E$ is the number of edges. This is because each vertex has a list of neighbors, and the total number of entries in all lists is proportional to the number of edges.\nEdge List An Edge List is a collection of pairs, where each pair (i, j) represents an edge between vertex i and vertex j. In a weighted graph. each element may also include the weight of the edge. typically represented as (i, j, weight). The space complexity of an edge list is $O(E)$, where $E$ is the number of edges, as each edge is stored as a separate entry in the list.\nGraph Traversal Breadth First Search Breadth-First Search (BFS) explores all the neighbors of a vertex before moving on to their neighbors. It proceeds level by level, ensuring that all vertices at a given distance from the starting vertex are visited before moving on to vertices at a greater distance. BFS is commonly used to find the shortest path in an unweighted graph.\nDepth First Search Depth-First Search (DFS) explores as far as possible alone a branch of the graph before backtracking to explore other branches. It follows a path from the starting vertex to a dead end, then retrace its steps and explores alternative paths. DFS is useful for finding all paths between vertices, detecting cycles, or performing topological sorting in directed acyclic graphs (DAGs).\nSpanning Tree A spanning tree is a subset of a graph that includes all the vertices and contains exactly $V - 1$ edges, where $V$ is the number of vertices in the graph. A connected graph can have multiple spanning trees, whereas a disconnected graph does not have a spanning tree because there is at least one pair of vertices that are not connected, making it impossible to form a tree that spans all the vertices.\nMinimum Spanning Tree (MST) A minimum spanning tree is a type of spanning tree that connects all the vertices of a graph with the smallest possible total edge weight, compared to all other possible spanning trees.\nPrim\u0026rsquo;s Algorithm Prim\u0026rsquo;s Algorithm is used to find the minimum spanning tree (MST) that connects all the vertices of a graph without forming a cycle, while minimizing the total edge weight. This algorithm is efficient for solving problems related to undirected, weighted graphs. The algorithm steps are as follows:\nInitialize an inMST array to track the vertices included in the MST, and a priority queue (min-heap) to process the edges with the smallest weight. Select an arbitrary starting vertex. Add all edges connected to this vertex into the priority queue and mark the vertex as included in the inMST array. Extract the edge with the minimum weight from the priority queue. If the destination vertex of this edge is not yet in the inMST array, include it, and add all edges connected to this newly included vertex (whose destination is not in the MST) to the priority queue. Repeat step 3 until all vertices are included in the MST. SHOW CODE Java import java.util.*; /** * @author Signal Yu * @since 2024-12-1 */ class Edge implements Comparable\u0026lt;Edge\u0026gt; { int src; int dest; int weight; public Edge(int src, int dest, int weight) { this.src = src; this.dest = dest; this.weight = weight; } @Override public int compareTo(Edge other) { // Sort edges based on weight return this.weight - other.weight; } } class Graph { int vertices; int edges; List\u0026lt;List\u0026gt;Edge\u0026gt;\u0026gt; adjacencyList; public Graph(int vertices) { this.vertices = vertices; adjacencyList = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c vertices; i++) { adjacencyList.add(new ArrayList\u0026lt;\u0026gt;()); } } void addEdge(int src, int dest, int weight) { // Add edge for undirected graph Edge edge1 = new Edge(src, dest, weight); Edge edge2 = new Edge(dest, src, weight); adjacencyList.get(src).add(edge1); adjacencyList.get(dest).add(edge2); } void primMST() { // Step 1: Initialize an `inMST` array to track the vertices // included in the MST, and a priority queue (min-heap) to // process the edges with the smallest weight. boolean[] inMST = new boolean[vertices]; Queue priorityQ = new PriorityQueue\u003c\u003e(); // Step 2: Select an arbitrary starting vertex. Add all edges // connected to this vertex into the priority queue and mark // the vertex as included in the `inMST` array. int start = 0; for (Edge edge : adjacencyList.get(start)) { priorityQ.offer(edge); } inMST[start] = true; // Step 4: Repeat step 3 until all vertices are included in the MST. while (!priorityQ.isEmpty()) { // Step 3: Extract the edge with the minimum weight from the // priority queue. If the destination vertex of this edge is // not yet in the `inMST` array, include it, and add all edges // connected to this newly included vertex (whose destination // is not in the MST) to the priority queue. Edge edge = priorityQ.poll(); int u = edge.src, v = edge.dest; if (!inMST[v]) { System.out.println(u + \"---[\" + edge.weight + \"]---\" + v); inMST[v] = true; // Add all edges from the newly included vertex (whose destination // is not included in `inMST`) to the priority queue for (Edge nextEdge : adjacencyList.get(v)) { if (!inMST[nextEdge.dest]) { priorityQ.offer(nextEdge); } } } } } } public class Solution { public static void main(String[] args) { int vertices = 4; // Number of vertices in the graph Graph graph = new Graph(vertices); // Create a graph with specified vertices // Add edges to the graph graph.addEdge(0, 1, 10); graph.addEdge(0, 2, 6); graph.addEdge(0, 3, 5); graph.addEdge(1, 3, 15); graph.addEdge(2, 3, 4); // Run Prim's algorithm to construct MST graph.primMST(); } } Sorting Quick Sort The quick sort algorithm follows the divide and conquer paradigm. It selects an element from the array as a pivot and recursively partitions the array into two subarrays based on whether the elements are less than or greater than the pivot. The main steps of the quick sort algorithm generally include: picking a pivot, partitioning, recursively partitioning, and handling the base case.\nPicking a pivot: Select an element from the array to act as the pivot. A common choice is the last element. Partitioning: Rearrange the array such that: All elements smaller than the pivot are placed to its left. All elements greater than or equal to the pivot are placed to its right. Place the pivot in its correct position within the sorted array. Recursively partitioning: Recursively apply the partitioning process to the subarrays created by spliting the array around the pivot. Base case: The subarrays are considered sorted when they contain one or zero elements. SHOW CODE Java class QuickSort { public int[] sortArray(int[] nums) { quickSort(nums, 0, nums.length - 1); return nums; } private void quickSort(int[] nums, int low, int high) { if (low \u003c high) { // int pivot = nums[high]; // Runtime Error: StackOverflowError int pivot = nums[low]; int i = low - 1, j = high + 1; while (i \u003c j) { // Find the element that greater than the pivot while (nums[++i] \u003c pivot) { } // Find the element that less than the pivot while (nums[--j] \u003e pivot) { } if (i \u003c j) { swap(nums, i, j); } } quickSort(nums, low, j); quickSort(nums, j + 1, high); } } private static void swap(int[] nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } } https://www.youtube.com/watch?v=8pL_iAEm0bM 912. Sort an Array SHOW PROBLEM Problem:\nGiven an array of integers nums, sort the array in ascending order and return it.\nYou must solve the problem without using any built-in sorting functions, and the solution must have a time complexity of O(n log n) and the smallest possible space complexity.\nExample 1:\nInput: nums = [5,2,3,1] Output: [1,2,3,5] Explanation: After sorting the array, the positions of some numbers remain unchanged (for example, 2 and 3), while the positions of other numbers are rearranged (for example, 1 and 5). Example 2:\nInput: nums = [5,1,1,2,0,0] Output: [0,0,1,1,2,5] Explanation: The array may contain duplicate values. Constraints:\n1 \u0026lt;= nums.length \u0026lt;= 50,000 -50,000 \u0026lt;= nums[i] \u0026lt;= 50,000 Go to Leetcode 🔗 SHOW CODE Time Limited Expectation Passed class Solution { public int[] sortArray(int[] nums) { // quicksort(nums, 0, nums.length - 1); Arrays.sort(nums); return nums; } private static int partition(int[] nums, int low, int high) { // Select the rightmost element as the pivot int pivot = nums[high]; int i = low - 1; // pointer for the smaller element for (int j = low; j \u003c high; j++) { // If current element is smaller than or equal to the pivot if (nums[j] \u003c= pivot) { i++; swap(nums, i, j); } } // Place the pivot in its correct position swap(nums, i + 1, high); // Return the partition index return i + 1; } private static void swap(int[] nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } private static void quicksort(int[] nums, int low, int high) { if (low \u003c high) { int partitionIndex = partition(nums, low, high); // Recursive sort the left and right subarrays quicksort(nums, low, partitionIndex - 1); quicksort(nums, partitionIndex + 1, high); } } } class Solution { public int[] sortArray(int[] nums) { quickSort(nums, 0, nums.length - 1); return nums; } private void quickSort(int[] nums, int low, int high) { if (low \u003c high) { // int pivot = nums[high]; // Runtime Error: StackOverflowError int pivot = nums[low]; int i = low - 1, j = high + 1; while (i \u003c j) { // Find the element that greater than the pivot while (nums[++i] \u003c pivot) { } // Find the element that less than the pivot while (nums[--j] \u003e pivot) { } if (i \u003c j) { swap(nums, i, j); } } quickSort(nums, low, j); quickSort(nums, j + 1, high); } } private static void swap(int[] nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } } ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/1-data-structure-and-algorithms/","summary":"Recursion Recursion is a programming technique where a function repeatedly calls itself until it reaches a base case, whcih stops the recursion and allows it to return a result. It is a way of breaking down complex problems into smaller, simpler subproblems that are eaiser to solve.\nHead Recursion Head Recursion is a type of recursion where a function makes its recursive call first, immediately after checking the base case, and performs all other operations only after the recursive call returns.","title":"Data Structure \u0026 Algorithms"},{"content":"JUnit assertEquals In JUnit, assertEquals is a method used to check if the expected value and the actual value are equal in unit tests.\nSHOW CODE Java import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class UnitTest { @Test void addition() { Calculator calculator = new Calculator(); int result = calculator.add(1, 1); assertEquals(2, result, \"The result of 1 + 1 should be 2\"); } } assertTure \u0026amp; assertFalse In JUnit, the assertTrue and the assertFalse methods are used to validate boolean expressions in unit tests.\nSHOW CODE Java import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertFalse; import static org.junit.jupiter.api.Assertions.assertTrue; public class UnitTest { @Test void testIsOdd() { int n = 5; assertTrue(n % 2 == 1, \"Number should be an odd\"); assertFalse(n % 2 == 0, \"Number should not be an even\"); } } @BeforeEach \u0026amp; @AfterEach In JUnit, the @BeforeEach and @AfterEach annotations are used to specify methods that should run before or after each test method, respectively. These annotations are useful for setting up resources before each test and cleaning up resources after each test.\nSHOW CODE Java import org.junit.jupiter.api.AfterEach; import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class UnitTest { private Calculator calculator; @BeforeEach void setup() { calculator = new Calculator(); } @Test void testAddition() { assertEquals(2, calculator.add(1, 1), \"The result of 1 + 1 should be 2.\"); } @AfterEach void teardown() { calculator = null; } } @BeforeAll \u0026amp; @AfterAll In JUnit, the @BeforeAll and @AfterAll annotations are used to specify methods that run once before and after all the test methods in a test class, respectively. These methods are commonly used for expensive setup and cleanup.\nSHOW CODE Java import org.junit.jupiter.api.AfterAll; import org.junit.jupiter.api.BeforeAll; import org.junit.jupiter.api.Test; public class UnitTest { @BeforeAll public static void setUpBeforeClass() { System.out.println(\"Executed before all tests are run.\"); } @AfterAll public static void tearDownAfterClass() { System.out.println(\"Executed after all tests are run.\"); } @Test public void testMethod1() { System.out.println(\"Test 1 executed.\"); } @Test public void testMethod2() { System.out.println(\"Test 2 executed.\"); } } SHOW OUTPUT Output Executed before all tests are run. Test 1 executed. Test 2 executed. Executed after all tests are run. assertArrayEquals \u0026amp; assertNotEquals In JUnit, the assertArrayEquals and assertNotEquals methods are used to check if both arrays are equal in sizeand whether each corresponding element is equal or not. For arrays containing objects, JUnit will use the equals method of the objects for the comparison.\nSHOW CODE Java import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertArrayEquals; import static org.junit.jupiter.api.Assertions.assertNotEquals; public class UnitTest { @Test void testArrayEquality() { int[] expected = {1, 2, 3}; int[] actual = {1, 2, 3}; assertArrayEquals(expected, actual, \"Arrays should be equal\"); String[] expected2 = {\"apple\", \"banana\", \"cherry\"}; String[] actual2 = {\"apple\", \"banana\", \"cherry\"}; // Compare arrays of objects (Strings in this case) assertArrayEquals(expected2, actual2); } @Test void testArrayNotEquality() { int[] expected = {1, 2, 3}; int[] actual = {1, 2, 4}; assertNotEquals(expected, actual, \"Arrays should not be equal\"); } } assertThrows In Junit, the assertThrows is a method used to assert that a specific exception is throwing during the execution of a piece of code.\nSHOW CODE Java import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertThrows; public class UnitTest { @Test void testDivision() { Calculator calculator = new Calculator(); ArithmeticException exception = assertThrows(ArithmeticException.class, () -\u003e { calculator.divide(1, 0); }); assertEquals(\"/ by zero\", exception.getMessage()); } } assertTimeout \u0026amp; assertTimeoutPreemptively In JUnit, the assertTimeout and assertTimeoutPreemptively methods are used to ensure that a unit test finishes within a specified time limit. The key difference between them is that the assertTimeoutPreemptively method will terminate the test as soon as the excution time exceeds the specified limit. In contrast, the assertTimeout method allows the test to complete before checking if the time limit was exceeded.\nSHOW CODE Java import org.junit.jupiter.api.Test; import java.time.Duration; import static org.junit.jupiter.api.Assertions.*; public class UnitTest { @Test void testExecutionWithinTimeoutPreemptively() { assertTimeoutPreemptively(Duration.ofMillis(1000), () -\u003e { // Simulate a task that takes more time than allowed Thread.sleep(1500); // Task that takes more than 1000ms }); } @Test void testExecutionWithinTimeout() { assertTimeout(Duration.ofMillis(1000), () -\u003e { // Simulate a task that takes some time Thread.sleep(500); // Task that takes less than 1000ms }); } } Parameterized Tests In JUnit, Parameterized Tests allow a test to be run with different parameters and expected results, which reduces repetitive code and increases test coverage. Common parameter sources include @ValueSource, which passes a group of values to the test; @CsvSource, which allows passing multiple values separated by commmas; @MethodSource, which generates values dynamically from a method; and @EnumSource, which passes enum constants from an enum class.\nSHOW CODE Java import org.junit.jupiter.params.ParameterizedTest; import org.junit.jupiter.params.provider.CsvSource; import org.junit.jupiter.params.provider.EnumSource; import org.junit.jupiter.params.provider.MethodSource; import org.junit.jupiter.params.provider.ValueSource; import java.util.stream.Stream; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.junit.jupiter.api.Assertions.assertTrue; public class UnitTest { @ParameterizedTest @ValueSource(strings = {\"apple\", \"banana\", \"cherry\"}) void testWithStringParameter(String fruit) { assertTrue(fruit.length() \u003e 3); } @ParameterizedTest @CsvSource({ \"apple, 5\", \"banana, 6\", \"cherry, 6\" }) void testWithCsvSource(String fruit, int length) { assertEquals(fruit.length(), length); } static Stream\u0026lt;String\u0026gt; stringProvider() { return Stream.of(\"apple\", \"banana\", \"cherry\"); } @ParameterizedTest @MethodSource(\"stringProvider\") void testWithMethodSource(String fruit) { assertTrue(fruit.length() \u003e 3); } enum FRUIT {APPLE, BANANA, CHERRY} @ParameterizedTest @EnumSource(FRUIT.class) void testWithEnumSource(FRUIT fruit) { assertTrue(fruit.name().length() \u003e 3); } } Mockito System Under Test The System Under Test (SUT) refers to the specific part of the software being tested in a given test case. It can range from a single method in unit testing to larger components in integration or system testing based on different context. The SUT is typically isolated using mocking and stubbing to test its behavior independently.\nSHOW CODE Java public class Calculator { public int add(int a, int b) { return a + b; } } public class CalculatorTest { @Test void testAdd() { Calculator calculator = new Calculator(); // SUT int result = calculator.add(2, 3); // The add method is the System Under Test assertEquals(5, result); } } Mocking vs. Stubbing In unit testing, Mocking and Stubbing are used to simulate and control the behavior of external dependencies. Mocking is commonly used for behavior verification, where objects are created to simulate the behavior of real-world components in a controlled manner. On the other hand, Stubbing is typically used to isolate the SUT by controlling the return values or responses from dependencies.\nSHOW CODE: Mocking Java public class Calculator { private Logger logger; public Calculator(Logger logger) { this.logger = logger; } public int add(int a, int b) { int result = a + b; logger.log(\"Addition performed: \" + result); return result; } } @Test void testAdd() { Logger mockLogger = mock(Logger.class); Calculator calculator = new Calculator(mockLogger); calculator.add(2, 3); // Verifying the interaction with the mock: was log method called? verify(mockLogger).log(\"Addition performed: 5\"); } SHOW CODE: Stubbing Java public class Calculator { private DatabaseService databaseService; public Calculator(DatabaseService databaseService) { this.databaseService = databaseService; } public int getProductPrice(int productId) { Product product = databaseService.getProduct(productId); return product.getPrice(); } } @Test void testGetProductPrice() { // Stub the DatabaseService to return a fixed product DatabaseService stubbedService = mock(DatabaseService.class); Product stubProduct = new Product(1, \"Laptop\", 1000); when(stubbedService.getProduct(1)).thenReturn(stubProduct); Calculator calculator = new Calculator(stubbedService); int price = calculator.getProductPrice(1); assertEquals(1000, price); } mock(), when().thenReturn(), verify() In Mockito, the mock() method is used to create a mock object, which allows simulating the behavior of an object without invoking its real methods. The when() method is used to define the behavior of a mock object\u0026rsquo;s method when it is called with specific arguments. The thenReturn() method specifies the return value of a mocked method. The verify() method is used to check whether a specified method on a mock object was called during the test execution.\nSHOW CODE Java import org.junit.jupiter.api.Test; import java.util.List; import static org.junit.jupiter.api.Assertions.assertTrue; import static org.mockito.Mockito.*; public class UnitTest { @Test public void testMockingBehavior() { // Create a mock List object List\u0026lt;String\u0026gt; mockList = mock(List.class); // Specify behavior for when add() is called when(mockList.add(\"Hello\")).thenReturn(true); // Return true when \"Hello\" is added // Call the mock method boolean result = mockList.add(\"Hello\"); // Verify the behavior assertTrue(result); // The add method should return true verify(mockList).add(\"Hello\"); // Verify that add(\"Hello\") was called // Verify that add(\"World\") was never called verify(mockList, never()).add(\"World\"); } } Argument Matchers In Mockito, argument matchers are used to specify conditions for method arguments when stubbing methods. They are commonly used in the when() and thenReturn() methods when the exact method argument is not critical. Some commonly used argument marchers include:\nany(): Matches any argument of the specified type. eq(): Matches a specified argument. anyString(): Matches any argument of type String. anyInt(): Matches any argument of type Integer. isA(): Matches an argument of a specified class type. argThat(): Allows for custom argument matching logic. SHOW CODE Java import org.junit.jupiter.api.Test; import java.util.List; import static org.junit.jupiter.api.Assertions.*; import static org.mockito.ArgumentMatchers.anyInt; import static org.mockito.Mockito.*; public class UnitTest { @Test public void testAnyMatcher() { List mockList = mock(List.class); // Stub behavior using argument matcher when(mockList.get(anyInt())).thenReturn(\"Signal\"); // Verify that any argument passed to get will return \"Signal\" assertEquals(\"Signal\", mockList.get(9)); assertEquals(\"Signal\", mockList.get(999)); } @Test public void testEqMatcher() { Calculator calculator = mock(Calculator.class); when(calculator.add(eq(1), eq(1))).thenReturn(2); assertEquals(2, calculator.add(1, 1)); assertNotEquals(3, calculator.add(1, 1)); } @Test public void testAnyStringMatcher() { // Create a mock List List\u0026lt;String\u0026gt; mockList = mock(List.class); // Stub the method to return \"Hello\" for any string argument when(mockList.contains(anyString())).thenReturn(true); // Verify that the mock returns true for any string passed as an argument assertTrue(mockList.contains(\"Test\")); // Matches any string assertTrue(mockList.contains(\"Hello\")); // Matches any string assertTrue(mockList.contains(\"World\")); // Matches any string } @Test public void testAnyIntMatcher() { // Create a mock List List mockList = mock(List.class); // Stub the method to return \"Found\" for any integer argument when(mockList.get(anyInt())).thenReturn(\"Found\"); // Verify that the mock returns \"Found\" regardless of the argument assertEquals(\"Found\", mockList.get(1)); // Matches any integer assertEquals(\"Found\", mockList.get(999)); // Matches any integer } @Test public void testArgThatMatcher() { // Create a mock List List\u0026lt;String\u0026gt; mockList = mock(List.class); // Use argThat to match arguments that are not null and have length greater than 3 when(mockList.add(argThat(argument -\u003e argument != null \u0026\u0026 argument.length() \u003e 3))) .thenReturn(true); // Verify that the mock behaves correctly assertTrue(mockList.add(\"Hello\")); // Matches: length \u003e 3 assertFalse(mockList.add(\"\")); // Does not match: empty string } } Essential Mockito Annotaitons The key annotations in Mockito are @Mock, @InjectMocks, @ExtendWith, and @Captor. The @Mock annotation is used to create mock objects. The @InjectMocks annotation injects the objects, created with @Mock, into the specified class under test. The @ExtendWith annotation specifies a custom test runner to use when executing the test. The @Captor annotation is used to create an ArgumentCaptor instance, which captures and verifies the arguments passed to mocked methods.\nSHOW CODE Java import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.ExtendWith; import org.mockito.ArgumentCaptor; import org.mockito.Captor; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.junit.jupiter.MockitoExtension; import java.util.List; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.mockito.Mockito.verify; @ExtendWith(MockitoExtension.class) public class UnitTest { @Mock private List\u0026lt;String\u0026gt; mockList; // Mocked dependency @InjectMocks private MyClass myClass; // Class under test @Captor private ArgumentCaptor\u0026lt;String\u0026gt; captor; // Captures arguments passed to the mock @Test void testAddItem() { // Perform the action under test myClass.addItem(\"Test Item\"); // Verify that the mockList's add method was called with the argument \"Test Item\" verify(mockList).add(captor.capture()); // Capture and assert the argument String capturedArgument = captor.getValue(); System.out.println(\"capturedArgument = \" + capturedArgument); // Assert the captured item is correct assertEquals(\"Test Item\", capturedArgument); } static class MyClass { private final List\u0026lt;String\u0026gt; list; public MyClass(List\u0026lt;String\u0026gt; list) { this.list = list; } public void addItem(String item) { list.add(item); } } } Mockit Spy Mockito\u0026rsquo;s spy is a partial mock, typically created using @Spy, where real methods are used by default, and only the specified methods are stubbed.\nSHOW CODE Java import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.ExtendWith; import org.mockito.Mock; import org.mockito.Spy; import org.mockito.junit.jupiter.MockitoExtension; import java.util.ArrayList; import java.util.List; import static org.junit.jupiter.api.Assertions.assertEquals; import static org.mockito.Mockito.doReturn; import static org.mockito.Mockito.verify; @ExtendWith(MockitoExtension.class) public class UnitTest { // Create a spy for the class under test @Spy private MyClass myClass = new MyClass(); // Inject the mock dependency into the class under test @Mock private List\u0026lt;String\u0026gt; mockList; @Test public void testAddItemWithSpy() { // Use the real method to add an item myClass.addItem(\"Test Item\"); // Verify that the mock's addItem method is called with the argument // Fail the test: Actually, there were zero interactions with this mock. verify(mockList).add(\"Test Item\"); // Stub the method for testing doReturn(\"Mocked Response\").when(myClass).getGreeting(); // Now the method getGreeting() will return the mocked response String response = myClass.getGreeting(); System.out.println(response); // Output: Mocked Response // Assert the mocked behavior assertEquals(\"Mocked Response\", response); } // Class under test static class MyClass { private final List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); public void addItem(String item) { list.add(item); } public String getGreeting() { return \"Hello, World!\"; } } } In the above code, the statement verify(mockList).add(\u0026quot;Test Item\u0026quot;); will fail because mockList is a partial mock. By default, real methods are called on a spy object, and since the real method is not stubbed or tracked. the verification cannot succeed.\nMockito and SpringBoot Example SHOW CODE: pom.xml pom.xml \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.4.0\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;dev.signalyu\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springtest\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;springtest\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;springtest\u0026lt;/description\u0026gt; \u0026lt;url/\u0026gt; \u0026lt;licenses\u0026gt; \u0026lt;license/\u0026gt; \u0026lt;/licenses\u0026gt; \u0026lt;developers\u0026gt; \u0026lt;developer/\u0026gt; \u0026lt;/developers\u0026gt; \u0026lt;scm\u0026gt; \u0026lt;connection/\u0026gt; \u0026lt;developerConnection/\u0026gt; \u0026lt;tag/\u0026gt; \u0026lt;url/\u0026gt; \u0026lt;/scm\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;17\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.mockito/mockito-core --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mockito\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mockito-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.14.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-test --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.4.0\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.34\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/org.springframework.data/spring-data-commons --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.data\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-data-commons\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!--\t\u0026lt;build\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;plugins\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;plugin\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;configuration\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;annotationProcessorPaths\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;path\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;/path\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;/annotationProcessorPaths\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;/configuration\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;/plugin\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;plugin\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;configuration\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;excludes\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;exclude\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;/exclude\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;/excludes\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;/configuration\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;/plugin\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;/plugins\u0026gt;--\u0026gt; \u0026lt;!--\t\u0026lt;/build\u0026gt;--\u0026gt; \u0026lt;/project\u0026gt; SHOW CODE Java import lombok.AllArgsConstructor; import lombok.Data; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.data.repository.CrudRepository; import org.springframework.stereotype.Repository; import org.springframework.stereotype.Service; import org.springframework.test.context.bean.override.mockito.MockitoBean; import org.springframework.test.web.servlet.MockMvc; import org.springframework.test.web.servlet.result.MockMvcResultMatchers; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; import static org.mockito.Mockito.when; import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status; @Data class User { private Long id; private String name; } @Repository interface UserRepository extends CrudRepository\u0026lt;User, Long\u0026gt; { } @Service @Data class UserService { @Autowired private final UserRepository userRepository; public String getUserById(Long id) { User user = userRepository.findById(id).orElse(null); return user == null ? \"User not found\" : user.getName(); } } @RestController @AllArgsConstructor class UserController { private final UserService userService; @GetMapping(\"/user/{id}\") public String getUser(@PathVariable Long id) { return userService.getUserById(id); } } @SpringBootTest @AutoConfigureMockMvc public class UnitTest { @Autowired private MockMvc mockMvc; @MockitoBean private UserService userService; @Test public void testGetUser() throws Exception { Long userId = 1L; String mockResponse = \"Signal Yu\"; when(userService.getUserById(userId)).thenReturn(mockResponse); mockMvc.perform(get(\"/user/{id}\", userId)) .andExpect(status().isOk()) .andExpect(MockMvcResultMatchers.content().string(mockResponse)); } } ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/framework-and-tools/framework/backend/unit-testing/1-junit-and-mockito-notes/","summary":"JUnit assertEquals In JUnit, assertEquals is a method used to check if the expected value and the actual value are equal in unit tests.\nSHOW CODE Java import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class UnitTest { @Test void addition() { Calculator calculator = new Calculator(); int result = calculator.add(1, 1); assertEquals(2, result, \"The result of 1 + 1 should be 2\"); } } assertTure \u0026amp; assertFalse In JUnit, the assertTrue and the assertFalse methods are used to validate boolean expressions in unit tests.","title":"Junit \u0026 Mockito Notes"},{"content":"Synchronous Messaging VS. Asynchronous Messaging Synchronous Messaging and Asynchronous Messaging are two commnication paradigms used in distributed systems. In synchronous messaging, the sender will not continue executing until it receives the acknowledged message from the receiver. This paradigm is commonly used in situations that require immediate feedback to continue operations, such as payments or transaction processing.\nThe advantages of this paradigm include ease of implementation and usefulness in situations where immediate feedback is needed. However, the drawbacks are also obvious: it may lead to performance bottlenecks when the receiver is slow or unavailable, and it can also limit scalability.\n--- title: Synchronous Messaging --- sequenceDiagram participant Sender participant MessageBus participant MessageListener Sender-\u003e\u003eMessageBus: MessageBusUtil.sendSynchronousMessage() MessageBus-\u003e\u003eMessageListener: destination.send() MessageListener--\u003e\u003eMessageBus: return response note over Sender: (block and wait) MessageBus--\u003e\u003eSender: return response In asynchronous messaging, the sender doesn\u0026rsquo;t block after sending the message, meaning it can continue processing without waiting for the response from the receiver. It is commonly used in situations where systems can tolerate delays in response, like message notification after a successful payment. Compared to synchronous messaging, asynchronous messaging is more complex to implement. Additionaly, the sender has no guarantee of immediate feedback. It requires extra techniques, such as callback functions or message listeners, to handle the response.\nsequenceDiagram participant Sender participant MessageBus as Message Bus participant MessageListener1 as Message Listener 1 Sender-\u003e\u003eMessageBus: MessageBusUtil.sendMessage() MessageBus-\u003e\u003eMessageListener: destination.send() MessageListener--\u003e\u003eMessageBus: return response Sender-\u003e\u003eSender: (continue with processing) MessageBus--\u003e\u003eSender: return response RabbitMQ Introduction to RabbitMQ RabbitMQ is a message broker that facilitates asynchronous communication between distributed systems. Its working mechnism involves four key components:\nProducer: Responsible for sending messages Exchange: Handles the routing of messages to the appropriate queues. Queue: Stores messages until they are consumed. Consumer: Processes the messages from the queue. --- title: Introduction to RabbitMQ --- graph LR P((P)) --\u003e|send| X{{Exchange}} --\u003e|binding| Q[[Queue]] --\u003e|receive| C((C)) Example: Hello RabbitMQ SHOW CODE Producer Consumer import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import java.nio.charset.StandardCharsets; public class Producer { // Name of the queue where the message will be sent private final static String QUEUE_NAME = \"hello\"; public static void main(String[] argv) throws Exception { // Create a connection factory to configure and connect to RabbitMQ ConnectionFactory factory = new ConnectionFactory(); // Configure RabbitMQ server address (default is localhost) factory.setHost(\"localhost\"); // Configure the port for RabbitMQ (default is 5672) factory.setPort(5672); // Use try-with-resource to automatically close the connection and channel after use try (Connection connection = factory.newConnection(); // Establish a connection to RabbitMQ Channel channel = connection.createChannel()) { // Create a communication channel // Declare a queue with the specified name channel.queueDeclare(QUEUE_NAME, false, false, false, null); String message = \"Hello RabbitMQ!\"; // Publish the message to the queue channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes(StandardCharsets.UTF_8)); System.out.println(\" [P] Sent '\" + message + \"'\"); } } } import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import com.rabbitmq.client.DeliverCallback; import java.nio.charset.StandardCharsets; public class Consumer { private final static String QUEUE_NAME = \"hello\"; public static void main(String[] argv) throws Exception { // Create a connection factory to configure and connect to RabbitMQ ConnectionFactory factory = new ConnectionFactory(); // Configure RabbitMQ server address (default is localhost) factory.setHost(\"localhost\"); // Configure the port for RabbitMQ (default is 5672) factory.setPort(5672); // Establish a connection to RabbitMQ Connection connection = factory.newConnection(); // Create a communication channel Channel channel = connection.createChannel(); // Declare a queue with the specified name channel.queueDeclare(QUEUE_NAME, false, false, false, null); System.out.println(\" [*] Waiting for messages. To exit press CTRL+C\"); // Define the callback function to handle incoming message DeliverCallback deliverCallback = (consumerTag, delivery) -\u003e { // Retrieve the message body and convert it to a string using UTF-8 encoding String message = new String(delivery.getBody(), StandardCharsets.UTF_8); System.out.println(\" [C] Received '\" + message + \"'\"); }; // Start consuming messages from the queue channel.basicConsume(QUEUE_NAME, true, deliverCallback, consumerTag -\u003e { // No action required for cancellation in this example }); } } Message Acknowledgment In RabbitMQ, message acknowledgement is a mechanism that ensures messages have been received and processed successfully. There are two main types of message acknowledgement: auto ack and manual ack.\nIn auto-ack mode, RabbitMQ considers the message acknowledged as soon as it is delieved to the consumer. The consumer does not need to explictly send an acknowledgement. However, this can be risky. If the consumer fails due to a connection issue or channel break, the message may be lost, meaning it hasn\u0026rsquo;t been processed successfully.\nboolean autoAck = true; channel.basicConsume(queueName, autoAck, consumer); In manual ack mode, the consumer must send an acknowledgement back to RabbitMQ once the message has been processed successfully. If RabbitMQ does not receive the acknowledgement from the consumer within a specified time (30 minutes by default), it will redeliver the message to another consumer or the same consumer, depending on the configuration.\n// Acknowledging a message manually boolean autoAck = false; channel.basicConsume(queueName, autoAck, new DefaultConsumer(channel) { @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException { String message = new String(body, \u0026#34;UTF-8\u0026#34;); // Process the message here channel.basicAck(envelope.getDeliveryTag(), false); // Acknowledge the message } }); Message Durability In RabbitMQ, message durability refers to the ability to ensure that a message will not be lost in case of a broker failure. It involves saving both the queue and message to disk so they can be recovered after a system restart. To guarantee durability, two key components need to be considered: durable queues and persistent messages.\nWhen a queue is declared as durable, it is saved to disk. The queue will still exist even if the broker fails.\nboolean durable = true; channel.queueDeclare(\u0026#34;myQueue\u0026#34;, durable, false, false, null); To ensure a message\u0026rsquo;s persistence after a broker restart, it must be marked as persistent by setting the delieveryMode to 2 (persistent). This ensures that the message is saved to disk. However, it\u0026rsquo;s important to note that marking a message as persistent does not fully guarantee that it won\u0026rsquo;t be lost. There is still a short window in which RabbitMQ has accepted the message but has not yet saved it to disk. Additionaly, RabbitMQ does not call fsync(2) for every message, meaning it may store the message in cache rather than writing it to disk immediately. Therefore, the durability guerantee is not strong.\n// Publish the message to the queue channel.basicPublish(\u0026#34;\u0026#34;, TASK_QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, // delieveryMode = 2 message.getBytes(\u0026#34;UTF-8\u0026#34;)); Prefetch When a consumer subscribes to a message queue, RabbitMQ begins delivering messages. By default, RabbitMQ uses a Round Robin Dispatching strategy, which evenly distributes messages across multiple consumers. However, if one of the consumers processes tasks slowly, it may lead to message buildup and memory pressure.\nIn RabbitMQ, the prefetch mechnism controls the maximum number of messages a consumer can hold at a time. When the number of messages a consumer holds reaches the prefetch limit, RabbitMQ will stop sending additional messages to that consumer until it acknowledges some of the messages. This mechanism helps prevent message accumulation and reduces memory pressure.\n--- title: Worker Queue - prefetch --- graph LR P((P)) --\u003e|send| Q[[Worker]] --\u003e|prefetch = 1| C1((C1)) Q --\u003e|prefetch = 1| C2((C2)) SHOW CODE Producer Worker import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import com.rabbitmq.client.MessageProperties; public class Producer { private static final String TASK_QUEUE_NAME = \"task_queue\"; public static void main(String[] argv) throws Exception { // Create a connection factory to configure and connect to RabbitMQ ConnectionFactory factory = new ConnectionFactory(); // Configure RabbitMQ server address (default is localhost) factory.setHost(\"localhost\"); // Configure the port for RabbitMQ (default is 5672) factory.setPort(5672); // Use try-with-resource to automatically close the connection and channel after use try (Connection connection = factory.newConnection(); // Establish a connection to RabbitMQ Channel channel = connection.createChannel()) { // Create a communication channel // Declare a queue with the specified name channel.queueDeclare(TASK_QUEUE_NAME, true, false, false, null); String message = \"Hello RabbitMQ!\"; // Publish the message to the queue channel.basicPublish(\"\", TASK_QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes(\"UTF-8\")); System.out.println(\" [P] Sent '\" + message + \"'\"); } } } import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; import com.rabbitmq.client.DeliverCallback; public class Worker { // Name of the queue where the message will be sent private static final String TASK_QUEUE_NAME = \"task_queue\"; public static void main(String[] argv) throws Exception { // Create a connection factory to configure and connect to RabbitMQ ConnectionFactory factory = new ConnectionFactory(); // Configure RabbitMQ server address (default is localhost) factory.setHost(\"localhost\"); // Establish a connection to RabbitMQ final Connection connection = factory.newConnection(); // Create a communication channel final Channel channel = connection.createChannel(); // Declare a queue with the specified name channel.queueDeclare(TASK_QUEUE_NAME, true, false, false, null); System.out.println(\" [*] Waiting for messages. To exit press CTRL+C\"); // Specify the prefetch count channel.basicQos(1); // Define a callback to process incoming messages DeliverCallback deliverCallback = (consumerTag, delivery) -\u003e { String message = new String(delivery.getBody(), \"UTF-8\"); System.out.println(\" [C] Received '\" + message + \"'\"); try { try { // Simulate task processing Thread.sleep(1000); } catch (InterruptedException _ignored) { Thread.currentThread().interrupt(); } } finally { // Acknowledge the message after work is completed System.out.println(\" [C] Done\"); channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false); } }; // Start consuming messages with manual acknowledgment channel.basicConsume(TASK_QUEUE_NAME, false, deliverCallback, consumerTag -\u003e { }); } } Publish/Subscribe Publish/Subscribe is a communication pattern where a message is sent by a producer to multiple consumers. In RabbitMQ, this pattern is implemented using Exchanges and Queues.\nIn the Publish/Subscribe pattern in RabbitMQ, the producer sends a message to an Exchange, which then routes the message to multiple queues that are bound to it. There are four types of exchanges in RabbitMQ:\nfanout: Routes messages to all queues bound to it, without considering any routing key. direct: Routes messages to queues based on an exact match with the routing key. topic: Routes messages to queues based on pattern matching of the routing key. headers: Routes messages based on the attributes of message headers. Fanout Exchange --- title: Publish/Subscribe - fanout --- graph LR P((P)) --\u003e|send| Ex{{fanout}} --\u003e|binding| Q1[[Q1]] Ex --\u003e|binding| Q2[[Q2]] Q1 --\u003e C1((C1)) Q2 --\u003e C2((C2)) SHOW CODE: Fanout Exchange Publisher Subscriber import com.rabbitmq.client.BuiltinExchangeType; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; public class EmitLog { private static final String EXCHANGE_NAME = \"logs\"; public static void main(String[] argv) throws Exception { // Create a new connection factory to connect to RabbitMQ ConnectionFactory factory = new ConnectionFactory(); // Set the host (default is 'localhost') factory.setHost(\"localhost\"); // Use try-with-resource to ensures automatic resource management try (Connection connection = factory.newConnection(); // Establish a connection Channel channel = connection.createChannel()) { // Create a channel // Declare an exchange of type 'fanout' which sends messages to all bound queues channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT); String message = argv.length \u003c 1 ? \"info: Hello World!\" : String.join(\" \", argv); // Publish the message to the exchange with an empty routing key (for fanout exchange) channel.basicPublish(EXCHANGE_NAME, \"\", null, message.getBytes(\"UTF-8\")); System.out.println(\" [x] Sent '\" + message + \"'\"); } } } import com.rabbitmq.client.*; public class ReceiveLogs { private static final String EXCHANGE_NAME = \"logs\"; public static void main(String[] argv) throws Exception { // Create a new connection factory to connect to RabbitMQ ConnectionFactory factory = new ConnectionFactory(); // Set the host (default is 'localhost') factory.setHost(\"localhost\"); // Establish a connection and create a new channel for communication Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); // Declare the exchange with the same name as in the emitter (logs) and of type 'fanout' channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT); // Bind the queue to the exchange with an empty routing key (for fanout exchange) String queueName = channel.queueDeclare().getQueue(); channel.queueBind(queueName, EXCHANGE_NAME, \"\"); System.out.println(\" [*] Waiting for messages. To exit press CTRL+C\"); // Define the callback function to process incoming messages DeliverCallback deliverCallback = (consumerTag, delivery) -\u003e { String message = new String(delivery.getBody(), \"UTF-8\"); System.out.println(\" [x] Received '\" + message + \"'\"); }; // Consume messages from the queue channel.basicConsume(queueName, true, deliverCallback, consumerTag -\u003e { }); } } Direct Exchange --- title: Publish/Subscribe - direct --- graph LR P((P)) --\u003e|send| Ex{{direct}} --\u003e|error| Q1[[Q1]] Ex --\u003e|info| Q2[[Q2]] Ex --\u003e|warn| Q2[[Q2]] Ex --\u003e|error| Q2[[Q2]] Q1 --\u003e C1((C1)) Q2 --\u003e C2((C2)) SHOW CODE: Direct Exchange Publisher Subscriber import com.rabbitmq.client.BuiltinExchangeType; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; public class EmitLogDirect { private static final String EXCHANGE_NAME = \"direct_logs\"; public static void main(String[] argv) throws Exception { // Create a new connection factory to connect to RabbitMQ ConnectionFactory factory = new ConnectionFactory(); // Set the host (default is 'localhost') factory.setHost(\"localhost\"); //Use try-with-resource for automatic resource management try (Connection connection = factory.newConnection(); // Establish a new connection Channel channel = connection.createChannel()) { // Create a new channel // Declare an exchange with type of 'direct' channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT); // Get the severity level (routing key) from the command-line arguments String severity = getSeverity(argv); // Get the message content from the command-line arguments String message = getMessage(argv); // Publish the message to the exchange with given severity as the routing key channel.basicPublish(EXCHANGE_NAME, severity, null, message.getBytes(\"UTF-8\")); System.out.println(\" [x] Sent '\" + severity + \"':'\" + message + \"'\"); } } private static String getSeverity(String[] strings) { if (strings.length \u003c 1) { return \"info\"; } return strings[0]; } private static String getMessage(String[] strings) { if (strings.length \u003c 2) { return \"Hello World!\"; } return joinStrings(strings, \" \", 1); } private static String joinStrings(String[] strings, String delimiter, int startIndex) { int length = strings.length; if (length == 0) { return \"\"; } if (length \u003c= startIndex) { return \"\"; } StringBuilder words = new StringBuilder(strings[startIndex]); for (int i = startIndex + 1; i \u003c length; i++) { words.append(delimiter).append(strings[i]); } return words.toString(); } } import com.rabbitmq.client.*; public class ReceiveLogsDirect { private static final String EXCHANGE_NAME = \"direct_logs\"; public static void main(String[] argv) throws Exception { // Create a new connection factory to connect to RabbitMQ ConnectionFactory factory = new ConnectionFactory(); // Set the host (default is 'localhost') factory.setHost(\"localhost\"); // Establish a new connection Connection connection = factory.newConnection(); // Create a new channel Channel channel = connection.createChannel(); // Declare a direct exchange, where messages will be routed based on the routing key channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT); String queueName = channel.queueDeclare().getQueue(); // Exit the program if no arguments are passed (no routing keys provided) if (argv.length \u003c 1) { System.err.println(\"Usage: ReceiveLogsDirect [info] [warning] [error]\"); System.exit(1); } for (String severity : argv) { // Bind the queue to the exchange with a specific routing key channel.queueBind(queueName, EXCHANGE_NAME, severity); } System.out.println(\" [*] Waiting for messages. To exit press CTRL+C\"); // Define the callback function for processing the received messages DeliverCallback deliverCallback = (consumerTag, delivery) -\u003e { String message = new String(delivery.getBody(), \"UTF-8\"); System.out.println(\" [x] Received '\" + delivery.getEnvelope().getRoutingKey() + \"':'\" + message + \"'\"); }; // Consume messages from the queue channel.basicConsume(queueName, true, deliverCallback, consumerTag -\u003e { }); } } Topic Exchange In RabbitMQ, the Topic Exchange is a type of exchange that routes messages to queues based on pattern matching of the routing key. The routing key in a topic exchange is typically a string of words separated by dots (.). The routing key can also contain wildcards like * and #. The * wildcard matches exactly one word, while the # wildcard matches zero or more words. Compared to the direct exchange, the topic exchange offers greater flexibility and efiiciency in routing messages to queues based on more complex patterns.\nSHOW CODE: Topic Exchange Publisher Subscriber import com.rabbitmq.client.BuiltinExchangeType; import com.rabbitmq.client.Channel; import com.rabbitmq.client.Connection; import com.rabbitmq.client.ConnectionFactory; public class EmitLogTopic { private static final String EXCHANGE_NAME = \"topic_logs\"; public static void main(String[] argv) throws Exception { // Create a connection factory to connect to RabbitMQ ConnectionFactory factory = new ConnectionFactory(); // Set the host (default is 'localhost') factory.setHost(\"localhost\"); // Use try-with-resource for automatic management try (Connection connection = factory.newConnection(); // Establish a new connection Channel channel = connection.createChannel()) { // Create a new channel // Declare a topic exchange with specified name channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC); String routingKey = getRouting(argv); String message = getMessage(argv); // Publish the message to the exchange channel.basicPublish(EXCHANGE_NAME, routingKey, null, message.getBytes(\"UTF-8\")); System.out.println(\" [x] Sent '\" + routingKey + \"':'\" + message + \"'\"); } } private static String getRouting(String[] strings) { if (strings.length \u003c 1) return \"anonymous.info\"; return strings[0]; } private static String getMessage(String[] strings) { if (strings.length \u003c 2) return \"Hello World!\"; return joinStrings(strings, \" \", 1); } private static String joinStrings(String[] strings, String delimiter, int startIndex) { int length = strings.length; if (length == 0) return \"\"; if (length \u003c startIndex) return \"\"; StringBuilder words = new StringBuilder(strings[startIndex]); for (int i = startIndex + 1; i \u003c length; i++) { words.append(delimiter).append(strings[i]); } return words.toString(); } } import com.rabbitmq.client.*; public class ReceiveLogsTopic { private static final String EXCHANGE_NAME = \"topic_logs\"; public static void main(String[] argv) throws Exception { // Create a new connection factory to connect to RabbitMQ ConnectionFactory factory = new ConnectionFactory(); // Set the host (default is 'localhost') factory.setHost(\"localhost\"); // Establish a new connection Connection connection = factory.newConnection(); // Create a new channel Channel channel = connection.createChannel(); // Declare a topic exchange with the specified name channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC); String queueName = channel.queueDeclare().getQueue(); if (argv.length \u003c 1) { System.err.println(\"Usage: ReceiveLogsTopic [binding_key]...\"); System.exit(1); } for (String bindingKey : argv) { channel.queueBind(queueName, EXCHANGE_NAME, bindingKey); } System.out.println(\" [*] Waiting for messages. To exit press CTRL+C\"); // Define the callback function for process received messages DeliverCallback deliverCallback = (consumerTag, delivery) -\u003e { String message = new String(delivery.getBody(), \"UTF-8\"); System.out.println(\" [x] Received '\" + delivery.getEnvelope().getRoutingKey() + \"':'\" + message + \"'\"); }; // Consume messages from the queue channel.basicConsume(queueName, true, deliverCallback, consumerTag -\u003e { }); } } Reliability: Publisher Publisher Retry Publisher Retry in RabbitMQ refers to the mechanism where the publisher reconnects to RabbitMQ after a network issue. This mechanism improves the likelihood of a successful connection when the network is unstable. However, the retry process is executed in blocking manner, which may lead to performance issues during reconnection. Below are the relavant configurations for application.properties.\nspring.rabbitmq.listener.simple.retry.enabled=false # Whether or not publishing retries are enabled. spring.rabbitmq.listener.simple.retry.initial-interval=1000 # Interval between the first and second attempt to deliver a message. spring.rabbitmq.listener.simple.retry.max-attempts=3 # Maximum number of attempts to deliver a message. spring.rabbitmq.listener.simple.retry.max-interval=10000 # Maximum interval between attempts. spring.rabbitmq.listener.simple.retry.multiplier=1.0 # A multiplier to apply to the previous delivery retry interval. spring.rabbitmq.listener.simple.retry.stateless=true # Whether or not retry is stateless or stateful. Publisher Confirm \u0026amp; Publisher Return RabbitMQ provides two types of message confirmation mechanisms between the publisher and the broker: Publisher Confirm and Publisher Return. The Publisher Confirm mechanism allows the publisher to receive an ack from the broker when the message is successfully delivered to the broker. The Publisher Return mechanism enables the broker to notify the publisher when a message cannot be routed to any queue.\nWhen a message is sent to the broker, if the message type is temporary and can be successfully routed to the specified queue, the broker will return an ack to the publisher. If the message type if durable and the message can be delievered to the queue and successfully saved to disk, the broker will return an ack. Otherwise, the broker will return an nack (negative acknowledgement) to the publisher.\nspring.rabbitmq.publisher-confirms=false # Enable publisher confirms. spring.rabbitmq.publisher-returns=false # Enable publisher returns. The Publisher Confirm mechanism provides two types of confirmation: synchronous mode (simple) and asynchronous mode (correlated). Synchronous mode offers a strict acknowledgement process but may lead to performance issues in high-throughput environments. It is typically used when reliability is the top priority. On the other hand, asynchronous mode improves throughput but requires that the acknowledgement process be handled in the background.\nIt is important to note that using Publisher Confirm and Publisher Return mechanism incurs additional network and system resource costs. Therefore, these mechanisms should be used with caution in production systems. If they must be used, it\u0026rsquo;s recommended to rely on Publisher Confirm only, as routing issues are often caused by business logic problems, and Publisher Return is less commonly needed. Additionally, for messages that are negatively acknowledged (nack), retry them within a limited time window to avoid an infinite retry loop. If retried continue to fail, record the exception logs instead of attempting retries indefinitely.\nReliability: Broker Data Persistency LazyQueue ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/asynchronous-messaging/1-asynchronous-messaging/","summary":"Synchronous Messaging VS. Asynchronous Messaging Synchronous Messaging and Asynchronous Messaging are two commnication paradigms used in distributed systems. In synchronous messaging, the sender will not continue executing until it receives the acknowledged message from the receiver. This paradigm is commonly used in situations that require immediate feedback to continue operations, such as payments or transaction processing.\nThe advantages of this paradigm include ease of implementation and usefulness in situations where immediate feedback is needed.","title":"Asynchronous Messaging"},{"content":"Introduction to DBMS A Database Management System (DBMS) is software that provides an interface for users to interact with databases. It enables the management, storage, and manipulation of data within databases. DBMS can be broadly classified into two main types: Relational DBMS and NoSQL DBMS.\nIn a Relational DBMS, data is stored in structured tables and is manipulated using SQL (Structured Query Language). Examples of relational DBMS inlcude MySQL, Oracle, and PostgreSQL.\nIn a NoSQL DBMS, data is typically unstructured or semi-structured, offering flexibility to handle diverse data types. Examples of NoSQL DBMS include MongoDB and Redis.\nMySQL MySQL is a relational database management system (RDBMS) that uses Structured Query Language (SQL) to interact with databases. It stores data in tables made up of rows and columns, allowing for efficient organization, retrival, and manipulation of data.\nSQL Commands SQL Commands are used to interact with relational databases. These commands can be classified into five types: DDL, DQL, DML, DCL, and TCL.\nSQL Commands DDL (Data Definition Language): Used to define and manage the structure of database instances, such as creating, altering, and deleting tables, and defining constraints. DQL (Data Query Language): Used to retrive data from the database, primarily through the SELECT statement. DML (Data Manipulation Language): Used to manipulate data within tables, such as inserting, updating, and deleting records. DCL (Data Control Language): Used to control access to data, manage user priviledges, and ensure data security. It includes commands like GRANT and REVOKE. TCL (Transaction Control Language): Used to manage transactions, ensuring data consistency. It includes commands like COMMIT, ROLLBACK, and SAVEPOINT. SQL Query Execution Order MySQL Execution Order: In MySQL, the execution order of an SQL query differs from the order in which components (e.g., SELECT, FROM, WHERE) are written in the query. MySQL begins by identifying the tables or views specified in the FROM clause. If there are any JOIN operation, MySQL performs the joins first and applies the ON condition. After completing the join operations, MySQL filters the based on the conditions specified in the WHERE clause.\nIf a GROUP BY clause is present, MySQL groups the rows based on the specified column(s) and then executes any aggregation functions (e.g., SUM(), COUNT(), etc.). Following the grouping, if a HAVING clause is provided, MySQL further filters the grouped results based on the specified condition.\nAfter filtering grouped results, MySQL selects the specified columns in the SELECT clause. If the DISTINCT keyword is used, MySQL removes duplicate rows from the selected result. Once the rows are selected and duplicates are removed, MySQL sorts the result set according to the rules defined in the ORDER BY clause.\nFinally, if a LIMIT or OFFSET clause is included, MySQL limits the number of rows returned, starting from the specified OFFSET.\nSQL Query Execution Order Select Find Customer Referee SHOW PROBLEM Table: Customer\nColumn Name Type id int name varchar referee_id int The id column is the primary key. Each row represents a customer, their name, and the id of the customer who referred them. If a customer wasn\u0026rsquo;t referred by anyone, the referee_id is NULL. Problem:\nFind the names of customers who were not referred by the customer with id = 2.\nThe result can be returned in any order.\nExample:\nInput: Customer table:\nid name referee_id 1 Will NULL 2 Jane NULL 3 Alex 2 4 Bill NULL 5 Zack 1 6 Mark 2 Output:\nname Will Jane Bill Zack Go to Leetcode 🔗 SHOW CODE MySQL SELECT name FROM Customer WHERE referee_id != 2 OR referee_id IS NULL; SHOW NOTES In SQL, NULL is not equal to any value, including 2. Therefore, the condition referee_id != 2 will exclude records where referee_id is NULL, because comparisons with NULL always result in an unknown NULL value, which is neither TRUE nor FALSE. It is crucial to consider the handling of NULL values when working with databases.\nArticle Views I SHOW PROBLEM Table: Views\nColumn Name Type article_id int author_id int viewer_id int view_date date There is no primary key in this table, and the table may contain duplicate rows. Each row indicates that a viewer viewed an article, where the article is written by an author, on a specific date. If author_id and viewer_id are the same, it indicates that the author viewed their own article. Problem:\nWrite a query to find the IDs of authors who have viewed at least one of their own articles.\nReturn the result table sorted by author_id in ascending order.\nExample:\nInput:\nViews table:\narticle_id author_id viewer_id view_date 1 3 5 2019-08-01 1 3 6 2019-08-02 2 7 7 2019-08-01 2 7 6 2019-08-02 4 7 1 2019-07-22 3 4 4 2019-07-21 3 4 4 2019-07-21 Output:\nid 4 7 Go to Leetcode 🔗 SHOW CODE MySQL SELECT DISTINCT author_id AS id FROM Views WHERE author_id = viewer_id ORDER BY id ASC; SHOW NOTES In SQL, the DISTINCT keyword is used to remove duplicate records from the result set, ensuring that only unique values are returned. It is commonly used in scenarios such as aggregating distinct values and ensuring uniqueness in join queries.\n# Aggregating unique values SELECT DISTINCT product_id FROM Order_Items; # Ensuring unique results in join queries SELECT DISTINCT c.customer_id, c.name FROM Customers c JOIN Orders o ON c.customer_id = o.customer_id; Baisc Joins LEFT JOIN: Replace Employee ID With The Unique Identifier In MySQL, LEFT JOIN is used to combine rows from two or more tables based on a related column between them. It returns all rows from the left table and the matching rows from the right table. If there is no match, the result will include NULL values for the column from the right table.\nSHOW PROBLEM Tables:\nEmployees\nColumn Name Type id int name varchar id is the primary key for this table. Each row represents an employee in the company, containing their id and name. EmployeeUNI\nColumn Name Type id int unique_id int (id, unique_id) is the primary key, meaning the combination of id and unique_id is unique across the table. Each row represents an employee\u0026rsquo;s id and their corresponding unique_id in the company. Task:\nWrite a SQL query that returns the unique_id of each employee from the Employees table. If an employee does not have a corresponding unique_id, return NULL for that employee.\nQuery Requirements:\nIf an employee has a unique_id, show it. If an employee does not have a unique_id, return NULL. The result should display the unique_id and the name of each employee. The results can be returned in any order.\nExample:\nInput:\nEmployees table:\nid name 1 Alice 7 Bob 11 Meir 90 Winston 3 Jonathan EmployeeUNI table:\nid unique_id 3 1 11 2 90 3 Output:\nunique_id name NULL Alice NULL Bob 2 Meir 3 Winston 1 Jonathan Explanation:\nAlice and Bob do not have a unique_id, so NULL is shown for both. Meir has a unique_id of 2. Winston has a unique_id of 3. Jonathan has a unique_id of 1. Go to Leetcode 🔗 SHOW CODE MySQL SELECT euni.unique_id, e.name FROM Employees e LEFT JOIN EmployeeUNI euni ON e.id = euni.id; LEFT JOIN: Confirmation Rate SHOW PROBLEM Table: Signups\nColumn Name Type user_id int time_stamp datetime user_id is a unique identifier for each user. Each row represents the signup time for the user identified by user_id. Table: Confirmations\nColumn Name Type user_id int time_stamp datetime action ENUM The primary key is a combination of user_id and time_stamp. user_id is a foreign key referencing the Signups table. action is an ENUM with two possible values: 'confirmed' or 'timeout'. Each row represents a confirmation request made by the user with user_id, indicating whether the confirmation message was confirmed ('confirmed') or timed out ('timeout'). Problem Description\nThe confirmation rate of a user is calculated as the ratio of 'confirmed' actions to the total number of confirmation requests. If a user has not made any confirmation requests, the confirmation rate is 0. The rate should be rounded to two decimal places.\nGoal\nWrite a SQL query to find the confirmation rate for each user.\nReturn the result in any order.\nInput\nSignups table:\nuser_id time_stamp 3 2020-03-21 10:16:13 7 2020-01-04 13:57:59 2 2020-07-29 23:09:44 6 2020-12-09 10:39:37 Confirmations table:\nuser_id time_stamp action 3 2021-01-06 03:30:46 timeout 3 2021-07-14 14:00:00 timeout 7 2021-06-12 11:57:29 confirmed 7 2021-06-13 12:58:28 confirmed 7 2021-06-14 13:59:27 confirmed 2 2021-01-22 00:00:00 confirmed 2 2021-02-28 23:59:59 timeout Output\nuser_id confirmation_rate 6 0.00 3 0.00 7 1.00 2 0.50 Explanation:\nUser 6 did not request any confirmation messages, so their confirmation rate is 0. User 3 made two confirmation requests, but both timed out, so their confirmation rate is 0. User 7 made three requests, and all were confirmed, so their confirmation rate is 1.00. User 2 made two requests: one confirmed and one timed out, so their confirmation rate is 1/2 = 0.50. Go to Leetcode 🔗 SHOW CODE MySQL SELECT user_id, ROUND(IFNULL(SUM(action = 'confirmed') / COUNT(1), 0), 2) AS confirmation_rate FROM SignUps LEFT JOIN Confirmations USING (user_id) GROUP BY 1; SELECT s.user_id, CASE WHEN c.user_id IS NULL THEN 0.00 ELSE ROUND(SUM(CASE WHEN action = 'confirmed' THEN 1 ELSE 0 END) / COUNT(*),2) END AS confirmation_rate FROM Signups s LEFT JOIN Confirmations c ON c.user_id = s.user_id GROUP BY s.user_id SHOW NOTES SUM(action = 'confirmed'): action = 'confirmed' returns 1 for confirmed actions and 0 for 'timeout' action. COUNT(1): Counts the total number of rows. (Use COUNT(*) for counting rows is more clear and idiomatic). LEFT JOIN Confirmations USING (user_id): Joins the Signups table with the Confirmations table on the user_id column. GROUP BY 1: A shorthand for GROUP BY user_id. It groups the results by the first column in the SELECT list, which is user_id in this case. INNER JOIN: Product Sales Analysis I In MySQL, the INNER JOIN is used to combine rows from two or more tables based on a related column between them. It only returns rows where there is a match in all the joined tables.\nSHOW PROBLEM Tables:\nSales\nColumn Name Type sale_id int product_id int year int quantity int price int (sale_id, year) is the primary key, meaning this combination of columns is unique. product_id is a foreign key referencing the Product table. Each row represents a sale of a product identified by product_id in a particular year. The price is per unit of the product. Product\nColumn Name Type product_id int product_name varchar product_id is the primary key for this table. Each row represents a product with its product_name. Task:\nWrite a SQL query to report the product_name, year, and price for each sale in the Sales table.\nQuery Requirements:\nReturn the product_name from the Product table, corresponding to the product_id in the Sales table. Include the year and price from the Sales table for each sale. The result can be returned in any order. Example:\nInput:\nSales table:\nsale_id product_id year quantity price 1 100 2008 10 5000 2 100 2009 12 5000 7 200 2011 15 9000 Product table:\nproduct_id product_name 100 Nokia 200 Apple 300 Samsung Output:\nproduct_name year price Nokia 2008 5000 Nokia 2009 5000 Apple 2011 9000 Explanation:\nFrom sale_id = 1, we can conclude that Nokia was sold for 5000 in 2008. From sale_id = 2, we can conclude that Nokia was sold for 5000 in 2009. From sale_id = 7, we can conclude that Apple was sold for 9000 in 2011. Go to Leetcode 🔗 SHOW CODE MySQL SELECT p.product_name, s.year, s.price FROM Sales s INNER JOIN Product p ON s.product_id = p.product_id; LEFT JOIN: Customer Who Visited but Did Not Make Any Transactions SHOW PROBLEM Table: Visits\nColumn Name Type visit_id int customer_id int visit_id is the unique identifier for each visit. This table contains information about the customers who visited the mall. Table: Transactions\nColumn Name Type transaction_id int visit_id int amount int transaction_id is the unique identifier for each transaction. This table contains information about the transactions made during each visit. Task:\nWrite a SQL query to find the IDs of customers who visited the mall without making any transactions, and count how many times they made these visits.\nThe result should include:\ncustomer_id — the ID of the customer. count_no_trans — the number of visits where no transaction was made. Query Requirements:\nReturn the result sorted in any order. Input:\nVisits table:\nvisit_id customer_id 1 23 2 9 4 30 5 54 6 96 7 54 8 54 Transactions table:\ntransaction_id visit_id amount 2 5 310 3 5 300 9 5 200 12 1 910 13 2 970 Output:\ncustomer_id count_no_trans 54 2 30 1 96 1 Explanation:\nCustomer with id = 23 visited once and made a transaction during the visit with id = 12. Customer with id = 9 visited once and made a transaction during the visit with id = 13. Customer with id = 30 visited once and did not make any transactions. Customer with id = 54 visited three times. During two visits, they did not make any transactions, and during one visit, they made three transactions. Customer with id = 96 visited once and did not make any transactions. In the output, customers with id = 30, id = 96, and id = 54 (for two of their visits) made visits without transactions.\nGo to Leetcode 🔗 SHOW CODE MySQL SELECT v.customer_id, COUNT(v.visit_id) as count_no_trans FROM Visits v LEFT JOIN Transactions t ON v.visit_id = t.visit_id WHERE t.transaction_id IS NULL GROUP BY v.customer_id; SHOW NOTES In the above SQL query, MySQL first identifies the Visits table and performs a LEFT JOIN with the Transactions table based on the condition v.visit_id = t.visit_id. The LEFT JOIN operation combines the two tables and fills NULL in rows where there is no match in the Transactions table. The result looks like this:\nSELECT * FROM Visits v LEFT JOIN Transactions t ON v.visit_id = t.visit_id; visit_id customer_id transaction_id visit_id amount 1 23 12 1 910 2 9 13 2 970 4 30 null null null 5 54 9 5 200 5 54 3 5 300 5 54 2 5 310 6 96 null null null 7 54 null null null 8 54 null null null After joining the tables, MySQL applies the WHERE clause to filter rows where t.transaction_id IS NULL, which means visits without any transactions.\nSELECT * FROM Visits v LEFT JOIN Transactions t ON v.visit_id = t.visit_id WHERE t.transaction_id IS NULL; visit_id customer_id transaction_id visit_id amount 4 30 null null null 6 96 null null null 7 54 null null null 8 54 null null null Next, MySQL groups the filtered rows by customer_id and calculates the number of visits per customer using the COUNT(v.visit_id) function.\nSELECT *, COUNT(v.visit_id) FROM Visits v LEFT JOIN Transactions t ON v.visit_id = t.visit_id WHERE t.transaction_id IS NULL GROUP BY v.customer_id; visit_id customer_id transaction_id visit_id amount COUNT(v.visit_id) 4 30 null null null 1 6 96 null null null 1 7 54 null null null 2 Finally, MySQL selects the desired columns and renames the COUNT(v.visit_id) column using the AS clause.\nSELECT v.customer_id, COUNT(v.visit_id) AS count_no_trans FROM Visits v LEFT JOIN Transactions t ON v.visit_id = t.visit_id WHERE t.transaction_id IS NULL GROUP BY v.customer_id; customer_id count_no_trans 30 1 96 1 54 2 SELF JOIN: Rising Temperature In MySQL, a self join is an operation where a table joins itself. It is commonly used when comparing rows within the same table based on a specific condition or when working with hierarchical data, such as relating employees to their managers.\nSHOW PROBLEM Table: Weather\nColumn Name Type id int recordDate date temperature int id is a column with unique values. There are no duplicate rows for the same recordDate. This table contains information about the temperature on specific dates. Problem Statement\nWrite a solution to find the id of all dates where the temperature is higher compared to the previous day (yesterday).\nReturn\nReturn the result table in any order. Input:\nWeather Table:\nid recordDate temperature 1 2015-01-01 10 2 2015-01-02 25 3 2015-01-03 20 4 2015-01-04 30 Output:\nid 2 4 Explanation:\nOn 2015-01-02, the temperature was higher than the previous day (10 -\u0026gt; 25). On 2015-01-04, the temperature was higher than the previous day (20 -\u0026gt; 30). Go to Leetcode 🔗 SHOW CODE MySQL SELECT w1.id FROM Weather w1 JOIN Weather w2 ON DATE_ADD(w2.recordDate, INTERVAL 1 DAY) = w1.recordDate WHERE w1.temperature \u003e w2.temperature; SHOW NOTES In the above query, the DATE_ADD(w2.recordDate, INTERVAL 1 DAY) = w1.recordDate condition ensures that the recordDate of w1 matches the day following w2\u0026rsquo;s recordDate.\nSELECT * FROM Weather w1 JOIN Weather w2 ON DATE_ADD(w2.recordDate, INTERVAL 1 DAY) = w1.recordDate id recordDate temperature id recordDate temperature 1 2015-01-01 10 2 2015-01-02 25 1 2015-01-01 10 3 2015-01-03 20 2 2015-01-02 25 4 2015-01-04 30 3 2015-01-03 20 4 2015-01-04 30 Result of the Join:\nid recordDate temperature id recordDate temperature 2 2015-01-02 25 1 2015-01-01 10 3 2015-01-03 20 2 2015-01-02 25 4 2015-01-04 30 3 2015-01-03 20 when id equals to 2, 25 \u0026gt; 10, so it is selcted. when id equals to 3, 20 \u0026lt; 25, so it is not selcted. when id equals to 4, 25 \u0026gt; 10, so it is selcted. Therefore, the result will be:\nid 2 4 Example: Relating Employees to Their Managers\nEmployees Table:\nid name manager_id 1 Alice NULL 2 Bob 1 3 Charlie 1 4 David 2 SELECT e1.name AS Employee, e2.name AS Manager FROM Employees e1 JOIN Employees e2 ON e1.manager_id = e2.id; Result of the Join:\nid name manager_id id name manager_id 2 Bob 1 1 Alice NULL 3 Charlie 1 1 Alice NULL 4 David 2 2 Bob 1 Final Result:\nEmployee Manager Bob Alice Charlie Alice David Bob SELF JOIN: Managers with at Least 5 Direct Reports SHOW PROBLEM Problem Description\nTable: Employee\nColumn Name Data Type Description id int Unique identifier for each employee. name varchar Name of the employee. department varchar Department to which the employee belongs. managerId int ID of the employee\u0026rsquo;s manager. If managerId is null, the employee does not have a manager. id is the primary key, ensuring each value is unique. Each row represents an employee, including their name, department, and their manager’s ID. If managerId is null, the employee does not report to any manager. An employee cannot be their own manager. Task\nWrite a query to find the managers who have at least five direct reports.\nReturn the result in any order.\nInput:\nEmployee Table:\nid name department managerId 101 John A null 102 Dan A 101 103 James A 101 104 Amy A 101 105 Anne A 101 106 Ron B 101 Output:\nname John Go to Leetcode 🔗 SHOW CODE MySQL SELECT b.name FROM Employee a JOIN Employee b ON a.managerId = b.id GROUP BY b.id HAVING COUNT(*) \u003e= 5 SHOW NOTES Table: Employee:\nid name department managerId 101 John A null 102 Dan A 101 103 James A 101 104 Amy A 101 105 Anne A 101 106 Ron B 101 Perform a self join, the table becomes:\nSELECT * FROM Employee a JOIN Employee b ON a.managerId = b.id Table: Slef Joined Result:\nid name department managerId id name department managerId 106 Ron B 101 101 John A null 105 Anne A 101 101 John A null 104 Amy A 101 101 John A null 103 James A 101 101 John A null 102 Dan A 101 101 John A null Group the self joined result:\nSELECT * FROM Employee a JOIN Employee b ON a.managerId = b.id GROUP BY b.id Table: Grouped Result:\nid name department managerId id name department managerId 106 Ron B 101 101 John A null Filter grouped result:\nSELECT * FROM Employee a JOIN Employee b ON a.managerId = b.id GROUP BY b.id HAVING COUNT(*) \u0026gt;= 5 Table: Filtered Grouped Result:\nid name department managerId id name department managerId 106 Ron B 101 101 John A null Select the specified column(s):\nSELECT b.name FROM Employee a JOIN Employee b ON a.managerId = b.id GROUP BY b.id HAVING COUNT(*) \u0026gt;= 5 Final Result:\nname John SELF JOIN: Average Time of Process per Machine SHOW PROBLEM Table: Activity\nColumn Name Type machine_id int process_id int activity_type enum timestamp float The table records user activities for machines on a factory website. The combination of (machine_id, process_id, activity_type) is the primary key, ensuring uniqueness in the table. machine_id is the ID of the machine. process_id is the ID of the process running on the machine with ID machine_id. activity_type is an ENUM type with values 'start' and 'end', representing the start and end of a process. timestamp is a float value representing the time (in seconds) the event occurred. The 'start' timestamp is always earlier than the 'end' timestamp for each (machine_id, process_id) pair. It is guaranteed that each (machine_id, process_id) pair has a corresponding 'start' and 'end' timestamp. Problem:\nThere are several machines on a factory website, and each machine runs the same number of processes. Your task is to write a SQL query that calculates the average time each machine takes to complete a process.\nThe time to complete a process is the difference between the 'end' timestamp and the 'start' timestamp. The average time for each machine is calculated by dividing the total time for all processes on that machine by the number of processes. The result should contain the following columns:\nmachine_id — the ID of the machine. processing_time — the average processing time, rounded to 3 decimal places. Input:\nActivity table: |------------|------------|---------------|-----------| | machine_id | process_id | activity_type | timestamp | |------------|------------|---------------|-----------| | 0 | 0 | start | 0.712 | | 0 | 0 | end | 1.520 | | 0 | 1 | start | 3.140 | | 0 | 1 | end | 4.120 | | 1 | 0 | start | 0.550 | | 1 | 0 | end | 1.550 | | 1 | 1 | start | 0.430 | | 1 | 1 | end | 1.420 | | 2 | 0 | start | 4.100 | | 2 | 0 | end | 4.512 | | 2 | 1 | start | 2.500 | | 2 | 1 | end | 5.000 | |------------|------------|---------------|-----------| Output:\n|------------|-----------------| | machine_id | processing_time | |------------|-----------------| | 0 | 0.894 | | 1 | 0.995 | | 2 | 1.456 | |------------|-----------------| Explanation:\nMachine 0:\nProcess 0: End time 1.520, Start time 0.712 → Time taken = 1.520 - 0.712 = 0.808 Process 1: End time 4.120, Start time 3.140 → Time taken = 4.120 - 3.140 = 0.980 Average time = (0.808 + 0.980) / 2 = 0.894 Machine 1:\nProcess 0: End time 1.550, Start time 0.550 → Time taken = 1.550 - 0.550 = 1.000 Process 1: End time 1.420, Start time 0.430 → Time taken = 1.420 - 0.430 = 0.990 Average time = (1.000 + 0.990) / 2 = 0.995 Machine 2:\nProcess 0: End time 4.512, Start time 4.100 → Time taken = 4.512 - 4.100 = 0.412 Process 1: End time 5.000, Start time 2.500 → Time taken = 5.000 - 2.500 = 2.500 Average time = (0.412 + 2.500) / 2 = 1.456 Go to Leetcode 🔗 SHOW CODE MySQL SELECT machine_id, ROUND(AVG(end_time - start_time), 3) AS processing_time FROM ( SELECT a.machine_id, a.process_id, a.timestamp AS start_time, b.timestamp AS end_time FROM Activity a JOIN Activity b ON a.machine_id = b.machine_id AND a.process_id = b.process_id AND a.activity_type = 'start' AND b.activity_type = 'end' ) AS process_times GROUP BY machine_id; SHOW NOTES In the following SQL query, the condition a.activity_type = 'start' and b.activity_type = 'end' ensures that the start and end timestamp are correctly matched for the same process on the same machine.\nSELECT * FROM Activity a JOIN Activity b ON a.machine_id = b.machine_id AND a.process_id = b.process_id AND a.activity_type = \u0026#39;start\u0026#39; AND b.activity_type = \u0026#39;end\u0026#39; Result of the Join:\nmachine_id process_id activity_type timestamp machine_id process_id activity_type timestamp 0 0 start 0.712 0 0 end 1.52 0 1 start 3.14 0 1 end 4.12 1 0 start 0.55 1 0 end 1.55 1 1 start 0.43 1 1 end 1.42 2 0 start 4.1 2 0 end 4.512 2 1 start 2.5 2 1 end 5 The result is selected from of the joined result:\nSELECT machine_id, ROUND(AVG(end_time - start_time), 3) AS processing_time FROM ( SELECT a.machine_id, a.process_id, a.timestamp AS start_time, b.timestamp AS end_time FROM Activity a JOIN Activity b ON a.machine_id = b.machine_id AND a.process_id = b.process_id AND a.activity_type = \u0026#39;start\u0026#39; AND b.activity_type = \u0026#39;end\u0026#39; ) AS process_times GROUP BY machine_id; Final Result:\nmachine_id processing_time 0 0.894 1 0.995 2 1.456 CROSS JOIN: Students and Examinations In MySQL, a CROSS JOIN is a type of join that returns the Cartesian product of two tables. It combines each row from the first table with every row from the second table, without the need for a join condition. For example, consider two tables, Students and Subjects:\nTable 1: Students\nstudent_id student_name 1 Alice 2 Bob Table 2: Subjects\nsubject_name Math Physics When a Cross Join is performed between these two tables, the result will be:\nTable: Result of Cross Join\nstudent_id student_name subject_name 1 Alice Math 1 Alice Physics 2 Bob Math 2 Bob Physics SHOW PROBLEM Table: Students\nColumn Name Type student_id int student_name varchar student_id is the primary key (unique values) for this table. Each row represents a student with their unique ID and name. Table: Subjects\nColumn Name Type subject_name varchar subject_name is the primary key (unique values) for this table. Each row represents the name of a subject offered in the school. Table: Examinations\nColumn Name Type student_id int subject_name varchar There is no primary key for this table, and it may contain duplicates. Each row indicates that a student with student_id attended the exam for the subject subject_name. Every student takes every course from the Subjects table. Task:\nWrite a query to find the number of times each student attended each exam, ordered by student_id and subject_name.\nInput:\nStudents Table:\nstudent_id student_name 1 Alice 2 Bob 13 John 6 Alex Subjects Table:\nsubject_name Math Physics Programming Examinations Table:\nstudent_id subject_name 1 Math 1 Physics 1 Programming 2 Programming 1 Physics 1 Math 13 Math 13 Programming 13 Physics 2 Math 1 Math Output:\nstudent_id student_name subject_name attended_exams 1 Alice Math 3 1 Alice Physics 2 1 Alice Programming 1 2 Bob Math 1 2 Bob Physics 0 2 Bob Programming 1 6 Alex Math 0 6 Alex Physics 0 6 Alex Programming 0 13 John Math 1 13 John Physics 1 13 John Programming 1 Explanation:\nThe result table contains all students and all subjects.\nAlice attended the Math exam 3 times, the Physics exam 2 times, and the Programming exam 1 time. Bob attended the Math exam 1 time, the Programming exam 1 time, and did not attend the Physics exam. Alex did not attend any exams. John attended the Math exam 1 time, the Physics exam 1 time, and the Programming exam 1 time. Go to Leetcode 🔗 SHOW CODE MySQL SELECT s.student_id, s.student_name, sub.subject_name, COUNT(e.student_id) AS attended_exams FROM Students s CROSS JOIN Subjects sub LEFT JOIN Examinations e ON s.student_id = e.student_id AND sub.subject_name = e.subject_name GROUP BY s.student_id, s.student_name, sub.subject_name ORDER BY s.student_id, sub.subject_name; SHOW NOTES Table: Students\nstudent_id student_name 1 Alice 2 Bob 13 John 6 Alex Table: Subjects:\nsubject_name Math Physics Programming When a CROSS JOIN is performed between the Students and Subjects tables, the result will be:\nSELECT * FROM Students s CROSS JOIN Subjects sub Table: Result of Cross Join:\nstudent_id student_name subject_name 1 Alice Programming 1 Alice Physics 1 Alice Math 2 Bob Programming 2 Bob Physics 2 Bob Math 13 John Programming 13 John Physics 13 John Math 6 Alex Programming 6 Alex Physics 6 Alex Math Table: Examniations:\nstudent_id subject_name 1 Math 1 Physics 1 Programming 2 Programming 1 Physics 1 Math 13 Math 13 Programming 13 Physics 2 Math 1 Math Perform a LEFT JOIN on the cross-joined tables with the Examinations table:\nSELECT * FROM Students s CROSS JOIN Subjects sub LEFT JOIN Examinations e ON s.student_id = e.student_id AND sub.subject_name = e.subject_name Table: Left Join Result:\nstudent_id student_name subject_name student_id subject_name 1 Alice Programming 1 Programming 1 Alice Physics 1 Physics 1 Alice Physics 1 Physics 1 Alice Math 1 Math 1 Alice Math 1 Math 1 Alice Math 1 Math 2 Bob Programming 2 Programming 2 Bob Physics null null 2 Bob Math 2 Math 13 John Programming 13 Programming 13 John Physics 13 Physics 13 John Math 13 Math 6 Alex Programming null null 6 Alex Physics null null 6 Alex Math null null After grouping the left joined result and count the e.studentId, the table will look like:\nSELECT *, COUNT(e.student_id) AS attended_exams FROM Students s CROSS JOIN Subjects sub LEFT JOIN Examinations e ON s.student_id = e.student_id AND sub.subject_name = e.subject_name GROUP BY s.student_id, s.student_name, sub.subject_name Table: Grouped Result with Count:\nstudent_id student_name subject_name student_id subject_name attended_exams 1 Alice Programming 1 Programming 1 1 Alice Physics 1 Physics 2 1 Alice Math 1 Math 3 2 Bob Programming 2 Programming 1 2 Bob Physics null null 0 2 Bob Math 2 Math 1 13 John Programming 13 Programming 1 13 John Physics 13 Physics 1 13 John Math 13 Math 1 6 Alex Programming null null 0 6 Alex Physics null null 0 6 Alex Math null null 0 After selecting the specified columns, the result table becomes:\nSELECT s.student_id, s.student_name, sub.subject_name, COUNT(e.student_id) AS attended_exams FROM Students s CROSS JOIN Subjects sub LEFT JOIN Examinations e ON s.student_id = e.student_id AND sub.subject_name = e.subject_name GROUP BY s.student_id, s.student_name, sub.subject_name student_id student_name subject_name attended_exams 1 Alice Programming 1 1 Alice Physics 2 1 Alice Math 3 2 Bob Programming 1 2 Bob Physics 0 2 Bob Math 1 13 John Programming 1 13 John Physics 1 13 John Math 1 6 Alex Programming 0 6 Alex Physics 0 6 Alex Math 0 Sort the selcted table based on the condition s.student_id and sub.subject_name, return the final result:\nTable: Final Result:\nstudent_id student_name subject_name attended_exams 1 Alice Math 3 1 Alice Physics 2 1 Alice Programming 1 2 Bob Math 1 2 Bob Physics 0 2 Bob Programming 1 6 Alex Math 0 6 Alex Physics 0 6 Alex Programming 0 13 John Math 1 13 John Physics 1 13 John Programming 1 Basic Aggregate Functions Average Selling Price SHOW PROBLEM Table: Prices\nColumn Name Type product_id int start_date date end_date date price int The primary key for this table is the combination of (product_id, start_date, end_date), ensuring unique periods for each product. Each row represents the price of a product for a specific period, from start_date to end_date. For each product, no two periods will overlap. Table: UnitsSold\nColumn Name Type product_id int purchase_date date units int This table may contain duplicate rows. Each row represents the date, number of units, and product_id for a product sold on that date. Problem:\nWrite a SQL query to find the average selling price for each product. The average_price should be rounded to two decimal places. If a product does not have any sold units, its average selling price should be considered 0.\nReturn the result table in any order.\nInput:\nPrices table:\nproduct_id start_date end_date price 1 2019-02-17 2019-02-28 5 1 2019-03-01 2019-03-22 20 2 2019-02-01 2019-02-20 15 2 2019-02-21 2019-03-31 30 UnitsSold table:\nproduct_id purchase_date units 1 2019-02-25 100 1 2019-03-01 15 2 2019-02-10 200 2 2019-03-22 30 Output:\nproduct_id average_price 1 6.96 2 16.96 Explanation:\nFor product 1:\nFrom 2019-02-17 to 2019-02-28, 100 units were sold at a price of 5. From 2019-03-01 to 2019-03-22, 15 units were sold at a price of 20. Average price is calculated based on the total price and total units sold. For product 2:\nFrom 2019-02-01 to 2019-02-20, 200 units were sold at a price of 15. From 2019-02-21 to 2019-03-31, 30 units were sold at a price of 30. Average price is calculated based on the total price and total units sold. Go to Leetcode 🔗 SHOW CODE MySQL SELECT p.product_id, ROUND(IFNULL(SUM(price * units) / SUM(units), 0), 2) AS average_price FROM Prices AS p LEFT JOIN UnitsSold AS u ON p.product_id = u.product_id AND purchase_date BETWEEN start_date AND end_date GROUP BY 1; SHOW NOTES: Right Answer MySQL Query Walkthrough:\nTable: Prices\nproduct_id start_date end_date price 1 2019-02-17 2019-02-28 5 1 2019-03-01 2019-03-22 20 2 2019-02-01 2019-02-20 15 2 2019-02-21 2019-03-31 30 3 2019-02-21 2019-03-31 30 Table: UnitsSold\nproduct_id purchase_date units 1 2019-02-25 100 1 2019-03-01 15 2 2019-02-10 200 2 2019-03-22 30 Join the two tables based on the product_id and the purchase_date, where the purchase_date falls between the start_date and the end_date:\nSELECT * FROM Prices AS p LEFT JOIN UnitsSold AS u ON p.product_id = u.product_id AND purchase_date BETWEEN start_date AND end_date; product_id start_date end_date price product_id purchase_date units 1 2019-02-17 2019-02-28 5 1 2019-02-25 100 1 2019-03-01 2019-03-22 20 1 2019-03-01 15 2 2019-02-01 2019-02-20 15 2 2019-02-10 200 2 2019-02-21 2019-03-31 30 2 2019-03-22 30 3 2019-02-21 2019-03-31 30 null null null Group the joined result and then use aggregation functions to calculate the average price:\nSELECT *, ROUND(IFNULL(SUM(price * units) / SUM(units), 0), 2) AS average_price FROM Prices AS p LEFT JOIN UnitsSold AS u ON p.product_id = u.product_id AND purchase_date BETWEEN start_date AND end_date GROUP BY 1; product_id start_date end_date price product_id purchase_date units average_price 1 2019-02-17 2019-02-28 5 1 2019-02-25 100 6.96 2 2019-02-01 2019-02-20 15 2 2019-02-10 200 16.96 3 2019-02-21 2019-03-31 30 null null null 0 Select the desired columns:\nSELECT p.product_id, ROUND(IFNULL(SUM(price * units) / SUM(units), 0), 2) AS average_price FROM Prices AS p LEFT JOIN UnitsSold AS u ON p.product_id = u.product_id AND purchase_date BETWEEN start_date AND end_date GROUP BY 1; product_id average_price 1 6.96 2 16.96 3 0 SHOW NOTES: Wrong Answer # Wrong Answer SELECT p.product_id, ROUND(IFNULL(SUM(price * units) / SUM(units), 0), 2) AS average_price FROM Prices AS p LEFT JOIN UnitsSold AS u ON p.product_id = u.product_id WHERE purchase_date BETWEEN start_date AND end_date GROUP BY 1; Join the two tables based on the condition p.product_id = u.product_id:\nSELECT * FROM Prices AS p LEFT JOIN UnitsSold AS u ON p.product_id = u.product_id; product_id start_date end_date price product_id purchase_date units 1 2019-02-17 2019-02-28 5 1 2019-03-01 15 1 2019-02-17 2019-02-28 5 1 2019-02-25 100 1 2019-03-01 2019-03-22 20 1 2019-03-01 15 1 2019-03-01 2019-03-22 20 1 2019-02-25 100 2 2019-02-01 2019-02-20 15 2 2019-03-22 30 2 2019-02-01 2019-02-20 15 2 2019-02-10 200 2 2019-02-21 2019-03-31 30 2 2019-03-22 30 2 2019-02-21 2019-03-31 30 2 2019-02-10 200 3 2019-02-21 2019-03-31 30 null null null Filter out the rows that do not fall between start_date and end_date:\nSELECT * FROM Prices AS p LEFT JOIN UnitsSold AS u ON p.product_id = u.product_id WHERE purchase_date BETWEEN start_date AND end_date; product_id start_date end_date price product_id purchase_date units 1 2019-02-17 2019-02-28 5 1 2019-02-25 100 1 2019-03-01 2019-03-22 20 1 2019-03-01 15 2 2019-02-01 2019-02-20 15 2 2019-02-10 200 2 2019-02-21 2019-03-31 30 2 2019-03-22 30 Group the filtered result and then use aggregation functions to calculate average price:\nSELECT *, ROUND(IFNULL(SUM(price * units) / SUM(units), 0), 2) AS average_price FROM Prices AS p LEFT JOIN UnitsSold AS u ON p.product_id = u.product_id WHERE purchase_date BETWEEN start_date AND end_date GROUP BY 1; product_id start_date end_date price product_id purchase_date units average_price 1 2019-02-17 2019-02-28 5 1 2019-02-25 100 6.96 2 2019-02-01 2019-02-20 15 2 2019-02-10 200 16.96 Select the desired columns:\nSELECT p.product_id, ROUND(IFNULL(SUM(price * units) / SUM(units), 0), 2) AS average_price FROM Prices AS p LEFT JOIN UnitsSold AS u ON p.product_id = u.product_id WHERE purchase_date BETWEEN start_date AND end_date GROUP BY 1; product_id average_price 1 6.96 2 16.96 The correct answer is:\nproduct_id average_price 1 6.96 2 16.96 3 0 Summary: The LEFT JOIN operation will return NULL results for rows without without matching records in the UnitsSold table. In the condition p.product_id = u.product_id AND purchase_date BETWEEN start_date AND end_date, the date range check is applied during the join operation, while WHERE purchase_date BETWEEN start_date AND end_date is applied after the join operation. The WHERE clause exlcudes rows with NULL values, which means products with no matching sales records (i.e., where purchase_date doesn\u0026rsquo;t match) will be excluded from the result. When grouping the result, no rows containing NULL values remain, leading to an incorrect result (missing product_id = 3 with average_price = 0).\nPercentage of Users Attended a Contest SHOW PROBLEM Table: Users\nColumn Name Type user_id int user_name varchar user_id is the primary key (a unique identifier) for this table. Each row in this table represents a user, with their unique ID and name. Table: Register\nColumn Name Type contest_id int user_id int (contest_id, user_id) is the primary key (a unique combination of columns) for this table. Each row in this table represents the registration of a user in a specific contest. Task\nWrite a solution to calculate the percentage of users registered for each contest, rounded to two decimal places.\nReturn the result table sorted by percentage in descending order. If there is a tie in percentage, order by contest_id in ascending order.\nInput:\nUsers table:\nuser_id user_name 6 Alice 2 Bob 7 Alex Register table:\ncontest_id user_id 215 6 209 2 208 2 210 6 208 6 209 7 209 6 215 7 208 7 210 2 207 2 210 7 Output:\ncontest_id percentage 208 100.0 209 100.0 210 100.0 215 66.67 207 33.33 Explanation:\nContests 208, 209, and 210 had 100% user registration. The results are sorted by contest_id in ascending order. Contest 215 had a registration rate of 66.67%, as Alice and Alex registered, out of a total of three users. Contest 207 had a registration rate of 33.33%, as only Bob registered, out of a total of three users. Go to Leetcode 🔗 SHOW CODE MySQL SELECT contest_id, ROUND(COUNT(user_id) * 100 / (SELECT COUNT(user_id) FROM Users),2) percentage FROM Register a GROUP BY contest_id ORDER BY percentage DESC,contest_id ASC; SHOW NOTES $$ \\text{percentage} = \\frac{\\text{number of users attended in the contest}}{\\text{total number of users}} \\times 100 \\% $$\nCompute the total number of users: SELECT COUNT(user_id) FROM Users Compute the number of users attended in the contest: Group the table based on the column contest_id, then count the number of users in each group. Queries Quality and Percentage SHOW PROBLEM Table: Queries\nColumn Name Type query_name varchar result varchar position int rating int This table may contain duplicate rows. It contains information collected from various queries executed on a database. The position column has a value ranging from 1 to 500. The rating column has a value between 1 and 5. Queries with a rating less than 3 are considered poor queries. Definitions:\nQuery quality: The average of the ratio between the query\u0026rsquo;s rating and its position. Poor query percentage: The percentage of queries with a rating less than 3. Objective: Write a solution to find:\nThe query_name, The quality of each query (rounded to 2 decimal places), The poor_query_percentage for each query (rounded to 2 decimal places). Input: Queries table:\nquery_name result position rating Dog Golden Retriever 1 5 Dog German Shepherd 2 5 Dog Mule 200 1 Cat Shirazi 5 2 Cat Siamese 3 3 Cat Sphynx 7 4 Output:\nquery_name quality poor_query_percentage Dog 2.50 33.33 Cat 0.66 33.33 Explanation:\nDog queries:\nQuality:\n$$ \\left( \\frac{5}{1} + \\frac{5}{2} + \\frac{1}{200} \\right) / 3 = 2.50 $$ Poor query percentage:\n$$ \\frac{1}{3} \\times 100 = 33.33 $$ Cat queries:\nQuality:\n$$ \\left( \\frac{2}{5} + \\frac{3}{3} + \\frac{4}{7} \\right) / 3 = 0.66 $$ Poor query percentage:\n$$ \\frac{1}{3} \\times 100 = 33.33 $$ Go to Leetcode 🔗 SHOW CODE MySQL SELECT query_name, ROUND(AVG(rating / position), 2) AS quality, ROUND(SUM(CASE WHEN rating \u003c 3 THEN 1 ELSE 0 END) / COUNT(*) * 100, 2) AS poor_query_percentage FROM Queries GROUP BY query_name; Monthly Transactions I SHOW PROBLEM Table: Transactions\nColumn Name Type id int country varchar state enum amount int trans_date date id is the primary key of this table. The table stores information about incoming transactions. The state column is an enum with values [\u0026ldquo;approved\u0026rdquo;, \u0026ldquo;declined\u0026rdquo;]. Task:\nFor each month and country, find the following information:\nThe total number of transactions (trans_count). The total amount of all transactions (trans_total_amount). The number of approved transactions (approved_count). The total amount of approved transactions (approved_total_amount). The results should be returned in any order.\nExample Input:\nid country state amount trans_date 121 US approved 1000 2018-12-18 122 US declined 2000 2018-12-19 123 US approved 2000 2019-01-01 124 DE approved 2000 2019-01-07 Example Output:\nmonth country trans_count approved_count trans_total_amount approved_total_amount 2018-12 US 2 1 3000 1000 2019-01 US 1 1 2000 2000 2019-01 DE 1 1 2000 2000 Go to Leetcode 🔗 SHOW CODE MySQL SELECT DATE_FORMAT(trans_date, '%Y-%m') AS month, country, COUNT(*) AS trans_count, SUM(CASE WHEN state = 'approved' THEN 1 ELSE 0 END) AS approved_count, SUM(amount) AS trans_total_amount, SUM(CASE WHEN state = 'approved' THEN amount ELSE 0 END) AS approved_total_amount FROM Transactions GROUP BY month, country; SELECT DATE_FORMAT(trans_date, '%Y-%m') AS month, country, COUNT(*) AS trans_count, COUNT(IF(state = 'approved', 1, NULL)) AS approved_count, SUM(amount) AS trans_total_amount, SUM(IF(state = 'approved', amount, 0)) AS approved_total_amount FROM Transactions GROUP BY month, country; SHOW NOTES The DATE_FORMAT function in SQL is used to format a date into a specific string format. For example, DATE_FORMAT('2024-12-19', '%Y-%m') will output '2024-12', extracting the year and month from the date. The IF function in SQL returns one value if the condition is true and another value if the condition is false. For example, IF(amount \u0026gt; 1000, 1, 0) will return 1 if the amount is greater than 1000, otherwise, it will return 0. The CASE...WHEN...THEN...ELSE...END statement is similar to the switch statement in other programming languages like Java. It works like the IF function, but with the ability to handle multiple conditions. It checks each condition in sequence and returns the corresponding result for the first true condition. Immediate Food Delivery II SHOW PROBLEM Table: Delivery\nColumn Name Type delivery_id int customer_id int order_date date customer_pref_delivery_date date delivery_id is the unique identifier for each delivery. The table contains information about food deliveries, where customers place orders on a specific date and specify a preferred delivery date (either on the same day or later). If the customer_pref_delivery_date is the same as the order_date, the order is considered immediate; otherwise, it is scheduled. The first order of a customer is defined as the one with the earliest order_date. Each customer has exactly one first order. Task:\nFind the percentage of immediate orders among the first orders of all customers, rounded to two decimal places.\nThe result should follow the format shown below:\nExample Input:\ndelivery_id customer_id order_date customer_pref_delivery_date 1 1 2019-08-01 2019-08-02 2 2 2019-08-02 2019-08-02 3 1 2019-08-11 2019-08-12 4 3 2019-08-24 2019-08-24 5 3 2019-08-21 2019-08-22 6 2 2019-08-11 2019-08-13 7 4 2019-08-09 2019-08-09 Example Output:\nimmediate_percentage 50.00 Explanation:\nCustomer 1 has their first order with delivery_id 1, which is scheduled. Customer 2 has their first order with delivery_id 2, which is immediate. Customer 3 has their first order with delivery_id 5, which is scheduled. Customer 4 has their first order with delivery_id 7, which is immediate. Hence, 50% of the first orders are immediate.\nGo to Leetcode 🔗 SHOW CODE MySQL SELECT ROUND((SUM(IF(order_date = customer_pref_delivery_date, 1, 0)) / COUNT(*)) * 100, 2) AS immediate_percentage FROM (SELECT customer_id, MIN(order_date) AS first_order_date FROM Delivery GROUP BY customer_id) AS first_orders INNER JOIN Delivery AS d ON first_orders.customer_id = d.customer_id AND first_orders.first_order_date = d.order_date; Game Play Analysis IV SHOW PROBLEM Table: Activity\nColumn Name Type player_id int device_id int event_date date games_played int The combination of (player_id, event_date) is the primary key of this table, ensuring each player can only log in once per day. This table tracks the activity of players in games, where each record represents a player\u0026rsquo;s login and the number of games played (which could be zero) before logging out on a specific day using a particular device. Task:\nCalculate the fraction of players who logged in again on the day after their first login date. The result should be rounded to two decimal places.\nIn other words, identify the players who logged in on consecutive days starting from their first login date, then divide that count by the total number of players.\nExample Input:\nplayer_id device_id event_date games_played 1 2 2016-03-01 5 1 2 2016-03-02 6 2 3 2017-06-25 1 3 1 2016-03-02 0 3 4 2018-07-03 5 Example Output:\nfraction 0.33 Explanation:\nPlayer 1 logged in on 2016-03-01 and 2016-03-02, meaning they logged in for at least two consecutive days, starting from their first login. Player 2 did not log in again on the day after their first login. Player 3 did not log in on consecutive days, as there was a gap between their logins. Thus, only player 1 satisfies the condition, and the fraction is calculated as 1/3 = 0.33.\nGo to Leetcode 🔗 SHOW CODE MySQL SELECT ROUND( SUM(IF(DATEDIFF(event_date, min_event_date) = 1, 1, 0)) / COUNT(DISTINCT player_id), 2) AS fraction FROM ( SELECT player_id, event_date, MIN(event_date) OVER (PARTITION BY player_id) AS min_event_date FROM activity ) AS activity_with_min_date; SHOW NOTES The DATEDIFF function in MySQL calculates the difference in days between two dates. For example, DATEDIFF('2024-12-30', '2024-12-25') will output 5, indicating there are 5 days between the two dates. The PARTITION BY clause is used in window functions to divide the result ser into partitions (groups) based on a specified column. It applies window functions, such as RANK(), SUM(), ROW_NUMBER(), and others, to each partition. This works similarly to GROUP BY, but unlike GROUP BY, the PARTITION BY clause allows retaining the row-level data while applying the window functions. Input Table: employees\ndepartment_id employee_id salary 101 1 5000 101 2 4000 101 3 6000 102 4 4500 102 5 5500 102 6 4800 SELECT department_id, employee_id, salary, RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) AS salary_rank FROM employees; Output (Result of Query):\ndepartment_id employee_id salary salary_rank 101 3 6000 1 101 1 5000 2 101 2 4000 3 102 5 5500 1 102 6 4800 2 102 4 4500 3 Sorting and Grouping User Activity for the Past 30 Days I SHOW PROBLEM Table: Activity\nColumn Name Type user_id int session_id int activity_date date activity_type enum The activity_type column is an ENUM with values: \u0026lsquo;open_session\u0026rsquo;, \u0026rsquo;end_session\u0026rsquo;, \u0026lsquo;scroll_down\u0026rsquo;, \u0026lsquo;send_message\u0026rsquo;. This table logs user activities for a social media website, where each session is linked to exactly one user. The table may contain duplicate rows. Task:\nYou need to find the count of unique active users per day for the 30-day period ending on 2019-07-27, inclusive. A user is considered active on a particular day if they perform at least one activity on that day.\nExample:\nInput: Activity table\nuser_id session_id activity_date activity_type 1 1 2019-07-20 open_session 1 1 2019-07-20 scroll_down 1 1 2019-07-20 end_session 2 4 2019-07-20 open_session 2 4 2019-07-21 send_message 2 4 2019-07-21 end_session 3 2 2019-07-21 open_session 3 2 2019-07-21 send_message 3 2 2019-07-21 end_session 4 3 2019-06-25 open_session 4 3 2019-06-25 end_session Output:\nday active_users 2019-07-20 2 2019-07-21 2 Explanation:\nOnly the days with active users (those who performed at least one activity) are included in the output. For 2019-07-20, users 1 and 2 were active, and for 2019-07-21, users 2 and 3 were active. Go to Leetcode 🔗 SHOW CODE MySQL SELECT activity_date AS day, COUNT(DISTINCT user_id) AS active_users FROM Activity WHERE activity_date \u003c= '2019-07-27' AND DATEDIFF('2019-07-27', activity_date) \u003c 30 GROUP BY activity_date SELECT activity_date AS day, COUNT(DISTINCT user_id) AS active_users FROM Activity WHERE activity_date \u003c= '2019-07-27' AND activity_date\u003e DATE_SUB('2019-07-27',INTERVAL 30 day) GROUP BY activity_date SHOW NOTES In MySQL, both DATEDIFF and DATE_SUB are used for date calculations. DATEDIFF calculates the difference between two dates, returning the result in days. On the other hand, DATE_SUB is used to subtract a specified time interval (such as days, months, or years) from a given date.\nSELECT DATEDIFF(\u0026#39;2023-12-31\u0026#39;, \u0026#39;2023-01-01\u0026#39;); -- Result: 364 SELECT DATE_SUB(\u0026#39;2023-12-31\u0026#39;, INTERVAL 30 DAY); -- Result: \u0026#39;2023-12-01\u0026#39; SELECT DATE_SUB(\u0026#39;2023-12-31\u0026#39;, INTERVAL 2 MONTH); -- Result: \u0026#39;2023-10-31\u0026#39; Product Sales Analysis III SHOW PROBLEM Table: Sales\nColumn Name Type sale_id int product_id int year int quantity int price int The combination of sale_id and year is the primary key of this table, ensuring each record is unique for a given sale. product_id is a foreign key referencing the Product table. Each row in this table represents a sale of a specific product (product_id) in a given year. The price refers to the price per unit of the product. Table: Product\nColumn Name Type product_id int product_name varchar product_id is the primary key of this table, ensuring unique product identifiers. Each row represents the name of a product associated with the corresponding product_id. Task: Write a query to select the product_id, year, quantity, and price for the first year in which each product was sold.\nReturn the result in any order.\nExample:\nInput: Sales table\nsale_id product_id year quantity price 1 100 2008 10 5000 2 100 2009 12 5000 7 200 2011 15 9000 Product table:\nproduct_id product_name 100 Nokia 200 Apple 300 Samsung Output:\nproduct_id first_year quantity price 100 2008 10 5000 200 2011 15 9000 Explanation:\nFor product_id = 100, the first sale occurred in 2008 with a quantity of 10 and a price of 5000. For product_id = 200, the first sale occurred in 2011 with a quantity of 15 and a price of 9000. The query should return the first sale year for each product, along with the corresponding quantity and price.\nGo to Leetcode 🔗 SHOW CODE MySQL SELECT product_id, year AS first_year, quantity, price FROM Sales WHERE (product_id, year) IN ( SELECT product_id, MIN(year) AS year FROM Sales GROUP BY product_id ); SELECT product_id, first_year, quantity, price FROM ( SELECT product_id, year AS first_year, quantity, price, RANK() OVER (PARTITION BY product_id ORDER BY year) AS row_num FROM Sales ) subquery WHERE row_num = 1; SELECT s.product_id, s.year AS first_year, s.quantity, s.price FROM Sales s JOIN ( SELECT product_id, MIN(year) AS first_year FROM Sales GROUP BY product_id ) first_sale ON s.product_id = first_sale.product_id AND s.year = first_sale.first_year; SHOW NOTES Biggest Single Number SHOW PROBLEM Table: MyNumbers\nColumn Name Type num int This table may contain duplicates (i.e., there is no primary key in the SQL table). Each row contains an integer.\nProblem Description\nA single number is a number that appears only once in the MyNumbers table.\nThe task is to find the largest single number. If there is no single number, return null.\nExample 1:\nInput: MyNumbers table:\nnum 8 8 3 3 1 4 5 6 Output:\nnum 6 Explanation:\nThe single numbers are 1, 4, 5, and 6. Since 6 is the largest single number, we return it.\nExample 2:\nInput: MyNumbers table:\nnum 8 8 7 7 3 3 3 Output:\nnum null Explanation:\nThere are no single numbers in the input table, so we return null.\nGo to Leetcode 🔗 SHOW CODE MySQL SELECT MAX(num) AS num FROM ( SELECT num FROM MyNumbers GROUP BY 1 HAVING COUNT(1) = 1 ) AS t; SELECT IF(COUNT(num) = 1, num, null) AS num FROM MyNumbers GROUP BY num ORDER BY 1 DESC LIMIT 1; Advanced Select \u0026amp; Joins The Number of Employees Which Report to Each Employee SHOW PROBLEM Table: Employees\nColumn Name Type employee_id int name varchar reports_to int age int employee_id is the unique identifier for each employee in the table. This table stores information about employees and the ID of the manager they report to. Some employees may not report to anyone (reports_to is null). A manager is defined as an employee who has at least one other employee reporting to them. Problem Description\nYou are required to write a solution that reports the following information for each manager:\nThe manager\u0026rsquo;s employee_id and name. The number of employees directly reporting to the manager. The average age of these employees, rounded to the nearest integer. The results should be ordered by employee_id.\nExample 1:\nInput:\nEmployees table:\nemployee_id name reports_to age 9 Hercy null 43 6 Alice 9 41 4 Bob 9 36 2 Winston null 37 Output:\nemployee_id name reports_count average_age 9 Hercy 2 39 Explanation:\nHercy manages 2 employees (Alice and Bob). The average age of Alice and Bob is (41 + 36) / 2 = 38.5, which rounds to 39. Example 2:\nInput:\nEmployees table:\nemployee_id name reports_to age 1 Michael null 45 2 Alice 1 38 3 Bob 1 42 4 Charlie 2 34 5 David 2 40 6 Eve 3 37 7 Frank null 50 8 Grace null 48 Output:\nemployee_id name reports_count average_age 1 Michael 2 40 2 Alice 2 37 3 Bob 1 37 Explanation:\nMichael manages Alice and Bob. The average age of Alice and Bob is (38 + 42) / 2 = 40. Alice manages Charlie and David, with an average age of (34 + 40) / 2 = 37. Bob manages Eve, with an average age of 37. Go to Leetcode 🔗 SHOW CODE MySQL SELECT e1.employee_id, e1.name, COUNT(e1.employee_id) AS reports_count, ROUND(AVG(e2.age)) AS average_age FROM Employees e1 INNER JOIN Employees e2 ON e1.employee_id = e2.reports_to GROUP BY e1.employee_id ORDER BY e1.employee_id; Primary Department for Each Employee SHOW PROBLEM Table: Employee\nColumn Name Type employee_id int department_id int primary_flag varchar The combination of (employee_id, department_id) is the primary key for this table, meaning each employee can belong to multiple departments, but each (employee_id, department_id) pair is unique. employee_id: The ID of the employee. department_id: The ID of the department to which the employee belongs. primary_flag: A flag indicating whether the department is the primary department for the employee. It can be one of the following: 'Y': The department is the primary department. 'N': The department is not the primary department. Problem Description\nEmployees may belong to multiple departments, and when they do, they must designate one department as their primary. If an employee belongs to only one department, the primary_flag for that department will be 'N'.\nYou are tasked with reporting the primary department for each employee. If an employee has only one department, report that department as their primary.\nInput:\nEmployee table:\nemployee_id department_id primary_flag 1 1 N 2 1 Y 2 2 N 3 3 N 4 2 N 4 3 Y 4 4 N Output:\nemployee_id department_id 1 1 2 1 3 3 4 3 Explanation:\nFor employee 1, their only department is department 1, so it is reported as their primary department. Employee 2 belongs to two departments (1 and 2). The primary_flag for department 1 is 'Y', so department 1 is their primary department. Employee 3 only belongs to department 3, so it is reported as their primary department. Employee 4 belongs to three departments (2, 3, and 4). The primary_flag for department 3 is 'Y', so department 3 is reported as their primary department. Go to Leetcode 🔗 SHOW CODE sql SELECT employee_id, department_id FROM Employee WHERE primary_flag = 'Y' UNION SELECT employee_id, department_id FROM Employee GROUP BY employee_id HAVING COUNT(1) = 1; SHOW NOTES The UNION operator is used to combine the results of two or more SELECT queries into a single result set. By default, UNION removes duplicate rows, ensuring that the final result contains only distinct records. In contrast, UNION ALL includes all rows, even if they are duplicates. It\u0026rsquo;s important to note that each SELECT statement involved in a UNION operation must contain the same number of columns, and the corresponding columns must have compatable data types.\nTriangle Judgement SHOW PROBLEM Table: Triangle\nColumn Name Type x int y int z int Primary Key: (x, y, z)\nEach row in this table represents the lengths of three line segments. Task:\nDetermine whether the three line segments (x, y, z) from each row can form a triangle.\nReturn the result table in any order, including a column that specifies if the segments form a triangle.\nTriangle Formation Rule:\nThree segments can form a triangle if and only if the following conditions are met:\n$x + y \u0026gt; z$ $x + z \u0026gt; y$ $y + z \u0026gt; x$ Example:\nInput:\n**Triangle table: **\nx y z 13 15 30 10 20 15 Output:\nx y z triangle 13 15 30 No 10 20 15 Yes Go to Leetcode 🔗 SHOW CODE MySQL SELECT *, IF(x + y \u003e z AND x + z \u003e y AND y + z \u003e x, 'Yes', 'No') AS triangle FROM Triangle; SELECT *, CASE WHEN (x + y \u003e z) AND (x + z \u003e y) AND (y + z \u003e x) THEN 'Yes' ELSE 'No' END AS triangle FROM Triangle; Consecutive Numbers SHOW PROBLEM Table: Logs\nColumn Name Type id int num varchar id is the primary key for this table. The id column is an auto-increment column that starts from 1. Problem Statement:\nFind all numbers (num) that appear at least three times consecutively in the table.\nReturn the result table in any order.\nExample:\nInput:\nLogs table:\nid num 1 1 2 1 3 1 4 2 5 1 6 2 7 2 Output:\nConsecutiveNums 1 Explanation:\nThe number 1 is the only value that appears at least three times consecutively in the table.\nGo to Leetcode 🔗 SHOW CODE MySQL SELECT DISTINCT l1.num AS ConsecutiveNums FROM Logs l1 JOIN Logs l2 ON l1.id = l2.id - 1 JOIN Logs l3 ON l2.id = l3.id - 1 WHERE l1.num = l2.num AND l2.num = l3.num; SELECT DISTINCT l2.num AS ConsecutiveNums FROM Logs AS l1 JOIN Logs AS l2 ON l1.id = l2.id - 1 AND l1.num = l2.num JOIN Logs AS l3 ON l2.id = l3.id - 1 AND l2.num = l3.num; Product Price at a Given Date SHOW PROBLEM Table: Products\nColumn Name Type product_id int new_price int change_date date (product_id, change_date) is the primary key (a combination of columns with unique values) of this table. Each row indicates that the price of a product was changed to a new price on a specific date. Problem Statement\nWrite a query to find the prices of all products on 2019-08-16. Assume the price of all products before any change is 10.\nReturn the result in any order.\nExample:\nInput:\nProducts table:\nproduct_id new_price change_date 1 20 2019-08-14 2 50 2019-08-14 1 30 2019-08-15 1 35 2019-08-16 2 65 2019-08-17 3 20 2019-08-18 Output:\nproduct_id price 2 50 1 35 3 10 Go to Leetcode 🔗 SHOW CODE MySQL WITH T AS (SELECT DISTINCT product_id FROM Products), P AS ( SELECT product_id, new_price AS price FROM Products WHERE (product_id, change_date) IN ( SELECT product_id, MAX(change_date) AS change_date FROM Products WHERE change_date \u003c= '2019-08-16' GROUP BY 1 ) ) SELECT product_id, IFNULL(price, 10) AS price FROM T LEFT JOIN P USING (product_id); WITH P AS ( SELECT p1.product_id, new_price, change_date FROM ( SELECT DISTINCT product_id FROM Products ) AS p1 LEFT JOIN Products AS p2 ON p1.product_id = p2.product_id AND p2.change_date \u003c= '2019-08-16' ), T AS ( SELECT *, RANK() OVER ( PARTITION BY product_id ORDER BY change_date DESC ) AS rk FROM P ) SELECT product_id, IFNULL(new_price, 10) AS price FROM T WHERE rk = 1; SHOW NOTES Last Person to Fit in the Bus SHOW PROBLEM Table: Queue\nColumn Name Type person_id int person_name varchar weight int turn int The person_id column contains unique values. This table holds information about people waiting to board a bus. The person_id and turn columns contain values from 1 to n, where n is the number of rows in the table. The turn column determines the order in which people will board the bus. A turn value of 1 indicates the first person to board, and turn = n indicates the last person to board. The weight column represents the person’s weight in kilograms. The bus has a weight limit of 1000 kilograms, so some people may not be able to board if the total weight exceeds this limit. The goal is to identify the name of the last person who can board the bus without exceeding the weight limit.\nOnly one person can board the bus at any given time, based on their turn. Input:\nQueue table:\nperson_id person_name weight turn 5 Alice 250 1 4 Bob 175 5 3 Alex 350 2 6 John Cena 400 3 1 Winston 500 6 2 Marie 200 4 Output:\nperson_name John Cena Explanation:\nThe following table shows the order in which people board the bus, ordered by the turn column for simplicity:\nTurn person_id person_name weight Total Weight 1 5 Alice 250 250 2 3 Alex 350 600 3 6 John Cena 400 1000 4 2 Marie 200 1200 5 4 Bob 175 ___ 6 1 Winston 500 ___ John Cena is the last person who can board the bus without exceeding the weight limit of 1000 kilograms.\nGo to Leetcode 🔗 SHOW CODE MySQL WITH T AS ( SELECT person_name, SUM(weight) OVER (ORDER BY turn) AS acumulated_weight FROM Queue ) SELECT person_name FROM T WHERE acumulated_weight \u003c= 1000 ORDER BY acumulated_weight DESC LIMIT 1; Count Salary Categories SHOW PROBLEM Table: Accounts\nColumn Name Type account_id int income int The account_id column is the primary key, meaning it contains unique values for each row. Each row represents the monthly income of a specific bank account. Task:\nWrite a solution to calculate the number of bank accounts in each salary category. The salary categories are defined as:\n\u0026ldquo;Low Salary\u0026rdquo;: Salaries strictly less than $20,000. \u0026ldquo;Average Salary\u0026rdquo;: Salaries in the inclusive range [$20,000, $50,000]. \u0026ldquo;High Salary\u0026rdquo;: Salaries strictly greater than $50,000. The result table should contain all three categories. If no accounts fall into a category, return 0 for that category.\nThe result can be returned in any order.\nInput:\nAccounts table:\naccount_id income 3 108939 2 12747 8 87709 6 91796 Output:\ncategory accounts_count Low Salary 1 Average Salary 0 High Salary 3 Explanation:\nLow Salary: Account 2 has an income of $12,747, which is below $20,000. Average Salary: There are no accounts with an income between $20,000 and $50,000. High Salary: Accounts 3, 6, and 8 have incomes above $50,000. Go to Leetcode 🔗 SHOW CODE MySQL WITH S AS ( SELECT 'Low Salary' AS category UNION SELECT 'Average Salary' UNION SELECT 'High Salary' ), T AS ( SELECT CASE WHEN income \u003c 20000 THEN 'Low Salary' WHEN income \u003e 50000 THEN 'High Salary' ELSE 'Average Salary' END AS category, COUNT(1) AS accounts_count FROM Accounts GROUP BY category ) SELECT category, IFNULL(accounts_count, 0) AS accounts_count FROM S LEFT JOIN T USING (category); Subqueries Exchange Seats SHOW PROBLEM Table: Seat\nColumn Name Type id int student varchar id is the primary key for this table. Each row represents a student\u0026rsquo;s name and their seat ID. The id starts from 1 and increases consecutively. Problem Description:\nWrite a query to swap the seat IDs of every two consecutive students in the Seat table. If the number of students is odd, the last student\u0026rsquo;s seat ID should remain unchanged.\nThe result should be ordered by the id column in ascending order.\nInput:\nSeat table:\nid student 1 Abbot 2 Doris 3 Emerson 4 Green 5 Jeames Output:\nid student 1 Doris 2 Abbot 3 Green 4 Emerson 5 Jeames Explanation:\nThe students Abbot and Doris swap places, as well as Emerson and Green. Since there are an odd number of students, Jeames\u0026rsquo;s seat remains unchanged. Go to Leetcode 🔗 SHOW CODE MySQL SELECT CASE WHEN id % 2 = 1 AND id \u003c (SELECT MAX(id) FROM Seat) THEN id + 1 WHEN id % 2 = 0 THEN id - 1 ELSE id END AS id, student FROM Seat ORDER BY id; Movie Rating SHOW PROBLEM Table: Movies\nColumn Name Type movie_id int title varchar movie_id is the primary key (column with unique values) for this table. title is the name of the movie.\nTable: Users\nColumn Name Type user_id int name varchar user_id is the primary key (column with unique values) for this table. The column \u0026rsquo;name\u0026rsquo; has unique values.\nTable: MovieRating\nColumn Name Type movie_id int user_id int rating int created_at date (movie_id, user_id) is the primary key (column with unique values) for this table. This table contains the rating of a movie by a user in their review. created_at is the user\u0026rsquo;s review date.\nProblem:\nFind the name of the user who has rated the greatest number of movies. In case of a tie, return the lexicographically smaller user name. Find the movie name with the highest average rating in February 2020. In case of a tie, return the lexicographically smaller movie name. Result format:\nThe result should contain two columns:\nresults – containing the user name with the greatest number of movie ratings. results – containing the movie name with the highest average rating in February 2020. Input:\nMovies table:\nmovie_id title 1 Avengers 2 Frozen 2 3 Joker Users table:\nuser_id name 1 Daniel 2 Monica 3 Maria 4 James MovieRating table:\nmovie_id user_id rating created_at 1 1 3 2020-01-12 1 2 4 2020-02-11 1 3 2 2020-02-12 1 4 1 2020-01-01 2 1 5 2020-02-17 2 2 2 2020-02-01 2 3 2 2020-03-01 3 1 3 2020-02-22 3 2 4 2020-02-25 Output:\nresults Daniel Frozen 2 Explanation:\nDaniel and Monica have rated 3 movies (\u0026ldquo;Avengers\u0026rdquo;, \u0026ldquo;Frozen 2\u0026rdquo; and \u0026ldquo;Joker\u0026rdquo;), but Daniel is lexicographically smaller. \u0026ldquo;Frozen 2\u0026rdquo; and \u0026ldquo;Joker\u0026rdquo; both have an average rating of 3.5 in February, but \u0026ldquo;Frozen 2\u0026rdquo; is lexicographically smaller. Go to Leetcode 🔗 SHOW CODE MySQL ( SELECT name AS results FROM Users JOIN MovieRating USING (user_id) GROUP BY user_id ORDER BY COUNT(1) DESC, name LIMIT 1 ) UNION ALL ( SELECT title FROM MovieRating JOIN Movies USING (movie_id) WHERE DATE_FORMAT(created_at, '%Y-%m') = '2020-02' GROUP BY movie_id ORDER BY AVG(rating) DESC, title LIMIT 1 ); Index In MySQL, an index is a database structure that improves the speed of data retrival operations on a table. Indexes are created on one or more columns of a table and allow the database to quickly locate data without scanning the entire table. Indexes are typically implemented using data structures, with the B+ tree being the most common.\nThere are four main types of indexes in MySQL: primary index, unique index, ordinary index, and full-text index.\nA primary index is a unique index that identifies each row in a table. It is automatically created when a primary key is defined. A unique index ensures that all values in the indexed columns(s) are unique. An ordinary index improves query performance but does not enforce uniqueness. A full-text index is used for full-text searches on text-based columns. SHOW CODE SQL -- Primary Index CREATE TABLE employees ( id INT PRIMARY KEY, -- Primary index name VARCHAR(100) ); -- Unique Index CREATE UNIQUE INDEX idx_email ON employees(email); -- Ordinary Index CREATE INDEX idx_name ON employees(name); -- Full Text Index CREATE FULLTEXT INDEX idx_description ON products(description); SELECT * FROM products WHERE MATCH(description) AGAINST('database'); Clustered Index vs. Secondary Index In MySQL, indexes can be categorized into two types: clustered index and secondary index.\nA clustered index determines the physical order of data rows in a table. The table data is stored in the order of the clustered index. A secondary index does not affect the physical order of data rows in a table. Instead, it stores a separate structure that points to the actual data rows. Clustered Index vs. Secondary Index SHOW CODE SQL CREATE TABLE employees ( id INT PRIMARY KEY, -- Clustered index name VARCHAR(100), salary DECIMAL(10, 2), INDEX idx_name (name) -- Secondary index ); Back-to-Table Queries SQL Performance Analysis:\nSQL Execution Frequency Slow Query Log show profiles explain Stored Procedure A stored procedure is a precompiled SQL code block that is stored in a database and can be executed repeatedly. It is particularly useful in scenarios involving complex SQL logic, as it helps streamline operations, improve performance, and enhance code reusability.\nSHOW CODE SQL -- Create a Stored Procedure: DELIMITER // CREATE PROCEDURE get_all_users() BEGIN SELECT * FROM users; END // DELIMITER ; -- Call a Procedure**: CALL get_all_users(); -- List all procedures show procedure status where db = 'mydatabase'; -- View the specific stored procedure show create procedure get_all_users; -- Delete a Stored Procedure: drop procedure get_all_users; Variables Variables in MySQL can be categorized into four types based on their scope: global, session, user-defined, and local.\nGlobal variables and session variables are used to control server behavior. Global variables affect all sessions connected to the server. Session variables apply only to the current session. User-defined variables are defined within a session and persist until the session ends. Local variables are used within stored procedures and have a scope limited to the procedure in which they are declared. SHOW CODE SQL # Global Variables SET GLOBAL max_connections = 200; -- Session Variables SET SESSION sql_mode = 'STRICT_TRANS_TABLES'; -- User-Defined Variables SET @my_var = 100; SELECT @my_var; -- Local Variables DELIMITER // CREATE PROCEDURE test_proc() BEGIN DECLARE my_local_var INT DEFAULT 10; SELECT my_local_var; END // DELIMITER ; Control Flow Statements MySQL supports various control flow statements, including IF, CASE...WHEN, WHILE, REPEAT, and LOOP.\nSHOW CODE SQL # IF statement DELIMITER // CREATE PROCEDURE check_salary(IN emp_id INT) BEGIN DECLARE emp_salary INT; SELECT salary INTO emp_salary FROM employees WHERE id = emp_id; IF emp_salary \u003e 5000 THEN SELECT 'High Salary'; ELSEIF emp_salary BETWEEN 3000 AND 5000 THEN SELECT 'Medium Salary'; ELSE SELECT 'Low Salary'; END IF; END // DELIMITER ; -- CASE WHEN statement DELIMITER // CREATE PROCEDURE check_grade(IN marks INT) BEGIN DECLARE grade CHAR(1); CASE WHEN marks \u003e= 90 THEN SET grade = 'A'; WHEN marks \u003e= 80 THEN SET grade = 'B'; WHEN marks \u003e= 70 THEN SET grade = 'C'; ELSE SET grade = 'F'; END CASE; SELECT grade; END // DELIMITER ; -- WHILE DELIMITER // CREATE PROCEDURE count_down() BEGIN DECLARE x INT DEFAULT 5; WHILE x \u003e 0 DO SELECT x; SET x = x - 1; END WHILE; END // DELIMITER ; -- REPEAT (similar to do...while in Java) DELIMITER // CREATE PROCEDURE repeat_example() BEGIN DECLARE x INT DEFAULT 1; REPEAT SELECT x; SET x = x + 1; UNTIL x \u003e 5 END REPEAT; END // DELIMITER ; -- LOOP (Use an explicit LEAVE to exit) DELIMITER // CREATE PROCEDURE loop_example() BEGIN DECLARE x INT DEFAULT 1; my_loop: LOOP SELECT x; SET x = x + 1; IF x \u003e 5 THEN LEAVE my_loop; END IF; END LOOP; END // DELIMITER ; Curosor and Handler In MySQL, a cursor is a database object that enables row-by-row processing of a result set. On the other hand, a handler is used to manage exceptions or errors that may occur during execution. Cursors and handlers are commonly used in stored procedures when dealing with result sets that contain multiple rows and require row-by-row processing.\nSHOW CODE SQL DELIMITER // CREATE PROCEDURE fetch_salaries() BEGIN DECLARE done INT DEFAULT 0; DECLARE emp_name VARCHAR(100); DECLARE emp_salary INT; DECLARE emp_cursor CURSOR FOR SELECT name, salary FROM employees; DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1; OPEN emp_cursor; read_loop: LOOP FETCH emp_cursor INTO emp_name, emp_salary; IF done THEN LEAVE read_loop; END IF; SELECT emp_name, emp_salary; END LOOP; CLOSE emp_cursor; END // DELIMITER ; Trigger In MySQL, a trigger is a data object that automatically executes a specified set of sql statements before or after certain events occurred, such as INSERT, UPDATE, or DELETE. It is commonly used in audit logging. MySQL only supports row-level trigger, meaning a trigger is activated FOR EACH ROW affected by INSERT, UPDATE, or DELETE operation.\nSHOW CODE SQL -- Create a trigger CREATE TRIGGER before_employee_update BEFORE UPDATE ON employees FOR EACH ROW BEGIN INSERT INTO audit_log (employee_id, action, change_date) VALUES (OLD.id, 'UPDATE', NOW()); END; -- View triggers SHOW TRIGGERS; SHOW TRIGGERS FROM database_name; -- Delete a trigger DROP TRIGGER IF EXISTS before_employee_update; Locking In MySQL, locking is a mechanism used to control database access, ensuring data integrity and consistency when multiple sessions interact with the databases. MySQL supports three main types of locks: global-level locks, table-level locks, and low-level locks.\nGlobal-Level Lock The global-level lock is a coarse-grained lock that blocks the entire database. It is commonly used during operations like data backups. Due to its coarse granularity, any updates to the database are blocked while the lock is active. Additionally, when the global lock is in place, secondary databases cannot read the binary log (binlog) from the primary database, leading to replication delays between the primary and secondary databases.\nFor InnoDB tables, it is generally recommended to use the --single-transaction option during data backups. This approach ensures data consistency without acquiring a global read lock, allowing updates to continue uninterrupted.\nSHOW CODE SQL -- From mysql client FLUSH TABLES WITH READ LOCK; -- From bash mysqldump -u username -p --single-transaction database_name \u003e backup.sql UNLOCK TABLES; Table-Level Lock The table-level lock is a mechanism that locks an entire table to control database access when multiple sessions interact with the database. There are three main types of table-level locks: table locks, metadata locks, and intention locks.\nTable locks include read locks and write locks: When a session acquires a read lock, other sessions can also read data but cannot modify it. When a session acquire a write lock, other sessions cannot read or write data from the locked table. Metadata lock is a type of lock that protects the structure of a database object when it is being accessed or modified by a session. It it automatically managed by MySQL. There are two main types of metadata locks: shared metadata locks and exclusive metadata locks. Shared metadata locks include SHARED_READ and SHARED_WRITE locks. These are acquired by queries, modification, or transactions. A SHARED_READ lock allows other sessions to read the locked data. A SHARED_WRITE lock allows other sessions to read but not modify the locked data. The exclusive metadata lock is acquired by operations that modify the table\u0026rsquo;s structure, such as ALTER TABLE. It prevents other sessions from accessing the table until the operation completes. An intention lock is a type of lock used by the InnoDB storage engine to indicate a transaction\u0026rsquo;s intention to acquire row-level locks at a finer granularity. It works in conjunction with row-level locks, helping to avoid confilicts between transactions that might lock the same table at different levels (e.g., table-level vs. row-level locks). There are two main types of intention locks: Intention Shared Lock (IS) and Intention Exclusive Lock (IX). The Intention Shared Lock (IS) indicates that a transaction intends to place shared wor-level locks on some rows in the table. It allows other transactions to acquire IS locks or table-level shared locks but blocks table-level exclusive locks. The Intention Exclusive Lock (IX) indicates that a transaction intends to place exlcusive row-level locks on some rows in the table. It allows other transactions to acquire IS locks but blocks table-level shared locks and table-level exclusive locks. Lock Type IS IX S X IS ✅ ✅ ✅ ❌ IX ✅ ✅ ❌ ❌ S (Shared) ✅ ❌ ✅ ❌ X (Exclusive) ❌ ❌ ❌ ❌ SHOW CODE TABLE LOCK META DATA LOCK INTENTION LOCK --- TABLE LOCK --- -- Read lock LOCK TABLES sales READ; SELECT * FROM sales WHERE sale_date = '2023-10-01'; UNLOCK TABLES; -- Write lock LOCK TABLES products WRITE; UPDATE products SET price = price * 1.1; UNLOCK TABLES; --- META DATA LOCK --- -- Session 1 starts a transaction and reads from a table START TRANSACTION; SELECT * FROM employees; -- Session 2 attempts to alter the table ALTER TABLE employees ADD COLUMN salary DECIMAL(10, 2); -- Session 2 will block until Session 1 releases its shared metadata lock -- Session 1 starts an `ALTER TABLE` operation ALTER TABLE employees ADD COLUMN department VARCHAR(50); -- session 2 attempts to query the table SELECT * FROM employees; -- Session 2 will block until Session 1 comoletes the `ALTER TABLE` operation --- INTENSION LOCK --- -- Transaction A -- Transaction A acquires an Intention Shared Lock (IS) on the employees table. -- It then acquires a Shared Row-Level Lock (S) on the row with id = 1. START TRANSACTION; SELECT * FROM employees WHERE id = 1 LOCK IN SHARE MODE; -- Transaction B -- Transaction B acquires an Intention Exclusive Lock (IX) on the employees table. -- It then acquires an Exclusive Row-Level Lock (X) on the row with id = 2. START TRANSACTION; UPDATE employees SET salary = 65000 WHERE id = 2; -- Transaction C -- Transaction C attempts to acquire an Exclusive Table-Level Lock (X) on the employees table. -- It will block until Transaction A and Transaction B release their locks. ALTER TABLE employees ADD COLUMN department VARCHAR(50); Row-Level Lock In MySQL, a row-level lock is a fine-grained locking mechanism that locks individual rows instead of the entire table. There are two main types of row-level locks: Shared Lock and Exclusive Lock.\nA Shared Lock allows other transactions to read the same row but prevents them from modifying it. An **Exclusive Lock prevents other transactions from reading or modifying the same row until the lock is released. Row-level locks are supported by the InnoDB storage engine to ensure data consistency and integrity. They are automatically acquired and released based on the transaction\u0026rsquo;s operations.\nSHOW CODE Shared Lock Exclusive Lock -- Transaction A reads a row with a shared lock START TRANSACTION; SELECT * FROM employees WHERE id = 1 LOCK IN SHARE MODE; -- Transaction B can also reads the same row START TRANSACTION; SELECT * FROM employees WHERE id = 1 LOCK IN SHARE MODE; -- Transaction C cannot modify the same row until the lock is released START TRANSACTION; UPDATE employees SET salary = 55000 WHERE id = 1; -- Blocks -- Transaction A updates a row with an exclusive lock START TRANSACTION; UPDATE employees SET salary = 55000 WHERE id = 1; -- Transaction B cannot read or modify the same row until the lock is released START TRANSACTION; SELECT * FROM employees WHERE id = 1 LOCK IN SHARE MODE; -- Blocks InnoDB provides additional locking mechanisms, such as gap locks and next-key locks, to ensure data consistency and integrity and prevent issues like phantom reads. By default, InnoDB operates at the REPEATABLE READ isolation level, where it uses next-key locks for searches and index scans to avoid phantom reads.\nA gap lock locks the intervals between rows in an index, preventing new rows from being inserted into those gaps. It does not lock the rows themselves but rather the gaps between them. The primary purpose of a gap lock is to prevent other transactions from inseting data into the blocked gap. Gap locks are coexistent, meaning they do not block other transactions from locking the same gap. A next-key lock is a combination of a row lock and a gap lock. It locks both the row and the gap before it. SHOW CODE employees table Gap Lock Next-key Lock | id | name | salary | |-----|-----------|---------| | 1 | John Doe | 50000 | | 3 | Jane Smith| 60000 | | 5 | Alice Lee | 55000 | SELECT * FROM employees WHERE id BETWEEN 2 AND 4 FOR UPDATE; -- The gap lock will be placed on the interval (1, 3) and (3, 5) SELECT * FROM employees WHERE id = 3 FOR UPDATE; -- The next-key lock will be placed on the row with id = 3 and the gap (1, 3) ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/database/2-database-management-system/","summary":"Introduction to DBMS A Database Management System (DBMS) is software that provides an interface for users to interact with databases. It enables the management, storage, and manipulation of data within databases. DBMS can be broadly classified into two main types: Relational DBMS and NoSQL DBMS.\nIn a Relational DBMS, data is stored in structured tables and is manipulated using SQL (Structured Query Language). Examples of relational DBMS inlcude MySQL, Oracle, and PostgreSQL.","title":"Database Management Systems"},{"content":"Introduction to Multithreading Program, Process, and Thread A program is a static set of instructions that stores on a disk. A process is an instance of a program that is currently being executed by the operating system. A thread is a small unit of process that can be scheduled and executed by the operating system. In simpler terms, a program is the code, a process is the excution of the code, a thread is a unit of execution within a process. Their relationships are illustrated in the following image:\nProgram, Process, and Thread Thread Life Cycle Within Concurrency A thread goes through various states in its life cycle, from creation to its termination. The life cycle of a thread typically includes five states: New, Runnable, Running, Blocked/Waiting, and Terminated.\nNew: This refers to the state where a thread instance is created but has not yet started running. In Java, this is commonly achieved by using new Thread(). Runnable: This refers to the state where a thread instance is ready to run but is waiting for CPU time. In Java, this is commonly achieved by ivoking start() on the thread instance. Running: This is refers to the state where the thread instance is actively executing its task. Blocked/Waiting: This refers to the state where a thread instance is waiting for other threads to complete their tasks, or it is waiting for a particular condition to be met. Terminated: This refers to the state where the thread instance has completed its task and has exited. Thread Life Cycle Within Concurrency Fork/Join Model The Fork/Join Model is an effective strategy commonly used in scenarios where a task can be recursively divided into multiple smaller, independent subtasks. This strategy typically involves the following steps:\nThe process begins with a single master thread. When it encounters a task that can be broken down into smaller subtasks, the master thread forks (spawns) multiple subsidiary threads, each of which takes on a portion of the task.\nOnce the subsidiary threads have completed their respective tasks, they join back with the master thread. Joining involves terminating the subsidiary threads and consolidating their results into the master thread. Afterward, the master thread continues its execution.\nFork/Join Model SHOW CODE Java import java.util.Arrays; import java.util.concurrent.RecursiveTask; import java.util.concurrent.ForkJoinPool; public class Solution { // RecursiveTask to compute the sum of a part of an array static class SumTask extends RecursiveTask { private final int[] array; private final int start; private final int end; // Threshold for splitting the task into smaller subtasks private static final int THRESHOLD = 1000; public SumTask(int[] array, int start, int end) { this.array = array; this.start = start; this.end = end; } @Override protected Long compute() { // If the task is small enough, calculate the sum directly if (end - start \u003c= THRESHOLD) { long sum = 0; for (int i = start; i \u003c end; i++) { sum += array[i]; } return sum; } // Otherwise, split the task into two subtasks int middle = (start + end) / 2; SumTask leftTask = new SumTask(array, start, middle); SumTask rightTask = new SumTask(array, middle, end); // Fork the subtasks leftTask.fork(); rightTask.fork(); // Join the results of the subtasks long leftResult = leftTask.join(); long rightResult = rightTask.join(); // Combine the results and return return leftResult + rightResult; } } public static void main(String[] args) { int[] array = new int[10000]; // Initialize all elements to 1 Arrays.fill(array, 1); // Create a ForkJoinPool to execute the tasks ForkJoinPool pool = new ForkJoinPool(); // Submit the task to the ForkJoinPool SumTask task = new SumTask(array, 0, array.length); long result = pool.invoke(task); System.out.println(\"Sum: \" + result); // Output the result } } SHOW OUTPUT Output Sum: 10000 Critical Section \u0026amp; Race Condition Critical Section refers to a portion of a program where shared resources are accessed and modified. A Race Condition occurs when the program\u0026rsquo;s behavior depends on the non-deterministic execution order of threads. Since multiple threads can access a critical section concurrently, it is essential to synchronize their access to avoid data inconsistency.\nFor example, suppose there are four threads trying to read a value of 20 from memory. Each thread increments the value by 1 and writes it back to memory. Without synchronization mechanisms, after all threads complete their writes, the final value might be 21 instead of the expected 24. This leads to an unexpected outcome, as illustrated below.\nCritical Section \u0026amp; Race Condition To resolve this issue, access to the critical section must be exclusive. This is commonly achieved by using mutexes, read/write locks, semaphores, conditional variables or barriers to ensure that only one thread can modify the shared resource at a time.\nSynchronization Mechanisms Synchronization Mechanisms are rules used to coordinate the execution of threads in a program, ensuring safe access to shared resources. These mechanisms can be primarily classified into five types: Mutexes, Read/Write Locks, Semaphores, Conditional Variables, and Barriers.\nMutex Mechanism The mutex mechanism ensures that only one thread can access the critical section at a time. Other threads will be blocked until the mutex is released. The key logic behind the mutex mechanism is as follows:\nLock lock = new ReentrantLock(); lock.lock(); // Acquire the lock try { // Critical section code } finally { lock.unlock(); // Release the lock } Mutex Mechanism SHOW CODE Java public class Mutex { private static int counter = 0; private static final Object lock = new Object(); public static void runExperiment(String experimentName, Runnable task) { counter = 0; Thread t1 = new Thread(task); Thread t2 = new Thread(task); t1.start(); t2.start(); try { t1.join(); t2.join(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"Final counter value \" + experimentName + \": \" + counter + \"\"); } public static void incrementCounterWithMutex() { for (int i = 0; i \u003c 100; i++) { synchronized (lock) { int temp = counter; try { Thread.sleep(1); // Sleep for 1 millisecond } catch (InterruptedException e) { e.printStackTrace(); } counter = temp + 1; } } } public static void incrementCounterNoMutex() { for (int i = 0; i \u003c 100; i++) { int temp = counter; try { Thread.sleep(1); // Sleep for 1 millisecond } catch (InterruptedException e) { e.printStackTrace(); } counter = temp + 1; } } public static void main(String[] args) { runExperiment(\"With Mutex Experiment\", Mutex::incrementCounterWithMutex); runExperiment(\"No Mutex Experiment\", Mutex::incrementCounterNoMutex); } } SHOW OUTPUT Output Final counter value With Mutex Experiment: 200 Final counter value No Mutex Experiment: 100 Read/Write Lock Mechanism The Read/Write Lock Mechanism allows threads read the shared resources concurrently, but ensures exclusive access for write operations. This mechanism is useful in scenarios where there are many read operations and fewer write operations, such as caching systems or databases. The key logic behind the read/write lock mechanism is as follows:\nReadWriteLock rwLock = new ReentrantReadWriteLock(); rwLock.readLock().lock(); // Acquire read lock try { // Read operation } finally { rwLock.readLock().unlock(); // Release read lock } rwLock.writeLock().lock(); // Acquire write lock try { // Write operation } finally { rwLock.writeLock().unlock(); // Release write lock } Under the Read/Write Lock mechanism, multiple threads can access the critical section simultaneously without blocking each other. When a writer thread is accessing the critical section, other writer threads and reader threads are blocked. Similarly, when a reader thread is accessing the critical section, the writer thread is blocked.\nRead/Write Lock Mechanism SHOW CODE Java import java.util.ArrayList; import java.util.List; import java.util.concurrent.locks.ReentrantReadWriteLock; public class ReadWriteLock { private static volatile int counter = 0; private static final int TARGET_VALUE = 1000; private static final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(); public static int incrementValue() { lock.writeLock().lock(); try { Thread.sleep(1); if (counter \u003c TARGET_VALUE) { counter++; } } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.writeLock().unlock(); } return counter; } public static int readValue() { lock.readLock().lock(); try { Thread.sleep(1); return counter; } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.readLock().unlock(); } return 0; } public static void main(String[] args) { long start = System.currentTimeMillis(); List readers = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u003c 8; i++) { readers.add(new Thread(() -\u003e { while (readValue() \u003c TARGET_VALUE) { try { Thread.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } } })); } List writers = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u003c 2; i++) { writers.add(new Thread(() -\u003e { while (incrementValue() \u003c TARGET_VALUE) { try { Thread.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } } })); } readers.forEach(Thread::start); writers.forEach(Thread::start); readers.forEach(t -\u003e { try { t.join(); } catch (InterruptedException e) { e.printStackTrace(); } }); writers.forEach(t -\u003e { try { t.join(); } catch (InterruptedException e) { e.printStackTrace(); } }); long end = System.currentTimeMillis(); System.out.println(\"Time taken: \" + (end - start) / 1000.0 + \" seconds\"); } } SHOW OUTPUT Output Time taken: 1.787 seconds In the above code, the readValue method uses a read lock, allowing multiple reader threads to access the counter (critical section) simultaneously without blocking each other. If the method used a write lock instead of a read lock, the execution time would be higher. This is because when a writer thread is accessing the counter, all other threads would be blocked.\npublic static int readValue() { // lock.readLock().lock(); lock.writeLock().lock(); try { Thread.sleep(1); return counter; } catch (InterruptedException e) { e.printStackTrace(); } finally { // lock.readLock().unlock(); lock.writeLock().unlock(); } return 0; } Time taken: 6.793 seconds # Use write lock Semaphore Mechanism The Semaphore mechanism uses an integer to manage a set of permits, allowing multiple threads to access shared resources simultaneously, but only up to a predetermined limit. There are two types of semaphores: Binary Semaphore and Counting Semaphore.\nBinary Semaphore: Similar to a mutex, it operates with two states (0 and 1), ensuring mutual exclusion in critical sections. Counting Semaphore: Allows a count greater than 1, permitting multiple threads to access shared resources concurrently, as long as the permit limit is not exceeded. Semaphores are useful in controlling access to a pool of resources, such as limiting the number of threads that can access a database connection or a server. The key logic behind the semaphore mechanism is as follows:\nSemaphore semaphore = new Semaphore(3); // Allow 3 threads at once semaphore.acquire(); // Acquire a permit try { // Critical section code } finally { semaphore.release(); // Release a permit } Semaphore Mechanism SHOW CODE Java import java.util.concurrent.Semaphore; import java.util.concurrent.atomic.AtomicInteger; public class SemaphoreTest { // Global shared resource // AtomicInteger allows multiple threads to read/write value of counter without requiring synchronization private static final AtomicInteger counter = new AtomicInteger(0); // Semaphore with a count of 5 private static final Semaphore semaphore = new Semaphore(5); private static final int TARGET_VALUE = 5000; public static void main(String[] args) { long startTime = System.currentTimeMillis(); Thread[] workers = new Thread[10]; for (int i = 0; i \u003c workers.length; i++) { workers[i] = new Thread(SemaphoreTest::worker); workers[i].start(); } for (Thread worker : workers) { try { worker.join(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); System.out.println(\"Thread was interrupted\"); } } long endTime = System.currentTimeMillis(); System.out.println(\"Time taken: \" + (endTime - startTime) / 1000.0 + \" seconds\"); } private static void worker() { while (true) { try { semaphore.acquire(); // Acquire the semaphore if (counter.get() \u003e= TARGET_VALUE) { break; } counter.incrementAndGet(); // Atomically increments the counter Thread.sleep(1); // Simulate work } catch (InterruptedException e) { Thread.currentThread().interrupt(); System.out.println(\"Thread was interrupted\"); } finally { semaphore.release(); // Release the semaphore } } } } Conditional Variable Mechanism The Conditional Variable Mechanism allows a thread to suspend its execution until other threads signal that a certain condition has been met. It is often used in conjunction with mutexes to implement synchronization patterns, such as the producer-consumer pattern.\nIn this mechanism, a thread can wait on a condition variable until it is notified by other threads that the condition has been satisfied. When the condition is fulfilled, one or more threads can be signaled to wake up and proceed. Condition variables are commonly used in scenarios like the producer-consumer problem, where one thread produces data and another consumes it, with both threads needing to wait for each other under specific conditions.\nThe key logic behind the Conditional Variable Mechanism is as follows:\nsynchronized (lock) { while (!condition) { lock.wait(); // Wait until condition is true } // Proceed with critical section } synchronized (lock) { condition = true; lock.notify(); // Notify waiting threads } Conditional Variable Mechanism SHOW CODE Wait \u0026amp; Notify Busy Waiting public class ConditionalVariable { private static final Object mutex = new Object(); private static int sharedNumber; private static boolean ready = false; public static void producer() { synchronized (mutex) { sharedNumber = 9; // Producing a number ready = true; System.out.println(\"Producer has produced the number: \" + sharedNumber); mutex.notify(); // Notify the consumer } } public static void consumer() { synchronized (mutex) { while (!ready) { try { mutex.wait(); // Wait until the number is ready } catch (InterruptedException e) { Thread.currentThread().interrupt(); System.out.println(\"Consumer thread was interrupted.\"); } } System.out.println(\"Consumer has consumed the number: \" + sharedNumber); } } public static void main(String[] args) { Thread producerThread = new Thread(ConditionalVariable::producer); Thread consumerThread = new Thread(ConditionalVariable::consumer); producerThread.start(); consumerThread.start(); try { producerThread.join(); consumerThread.join(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); System.out.println(\"Main thread was interrupted.\"); } } } public class Solution { private static final Object mutex = new Object(); private static int sharedNumber; private static boolean ready = false; private static void producer() { synchronized (mutex) { sharedNumber = 9; // Producing a number ready = true; System.out.println(\"Producer has produced the number: \" + sharedNumber); } } private static void consumer() { // Busy waiting loop while (true) { synchronized (mutex) { if (ready) { System.out.println(\"Consumer has consumed the number: \" + sharedNumber); break; } } try { Thread.sleep(1); // Sleep for a short time } catch (InterruptedException e) { Thread.currentThread().interrupt(); System.out.println(\"Thread was interrupted\"); } } } public static void main(String[] args) { Thread producerThread = new Thread(Solution::producer); Thread consumerThread = new Thread(Solution::consumer); producerThread.start(); consumerThread.start(); try { producerThread.join(); consumerThread.join(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); System.out.println(\"Main thread was interrupted\"); } } } Barrier Mechanism The Barrier Mechanism allows threads to wait for each other at a specified point in their execution. It ensures that threads cannot proceed to the subsequent code until all threads have reached the barrier, as illustrated in the following image.\nBarrier Mechanism Barrier Mechanism are useful in parallel algorithms where multiple threads need to work in phases, and the next phase cannot begin until all threads complete the current one.\nThe key logic behind this mechanism is as follows:\nCyclicBarrier barrier = new CyclicBarrier(4, new Runnable() { public void run() { System.out.println(\u0026#34;All threads reached the barrier!\u0026#34;); } }); // Threads: barrier.await(); // Wait at the barrier SHOW CODE Java import java.util.concurrent.CyclicBarrier; class Barriers { private static final CyclicBarrier barrier = new CyclicBarrier(2, () -\u003e System.out.println(\"All threads have reached the barrier. Continue execution.\")); public static void main(String[] args) { Thread t1 = new Thread(Barriers::work); Thread t2 = new Thread(Barriers::work); // Start both threads. t1.start(); t2.start(); } private static void work() { System.out.println(\"Thread \" + Thread.currentThread().getName() + \" is waiting at the barrier\"); try { // Wait for the specified number of threads (2 in this case) to reach the barrier. barrier.await(); System.out.println(\"Thread \" + Thread.currentThread().getName() + \" is released\"); } catch (Exception e) { // Handle exceptions, if any. } } } SHOW OUTPUT Output Thread Thread-0 is waiting at the barrier Thread Thread-1 is waiting at the barrier All threads have reached the barrier. Continue execution. Thread Thread-1 is released Thread Thread-0 is released Thread Creation In Java Extending Thread Class SHOW CODE Java class MyThread extends Thread { @Override public void run() { System.out.println(this.getName() + \" is running.\"); } } public class Main { public static void main(String[] args) { MyThread myThread = new MyThread(); myThread.setName(\"MYTHREAD-0\"); myThread.start(); } } Implementing Runnable Interface SHOW CODE Java public class Main { public static void main(String[] args) { Thread thread = new Thread(() -\u003e System.out.println(Thread.currentThread().getName() + \" is running.\")); thread.start(); } } //class MyRunnable implements Runnable { // @Override // public void run() { // System.out.println(\"Thread is running\"); // } //} // //public class Main { // public static void main(String[] args) { // Thread thread = new Thread(new MyRunnable()); // thread.start(); // Starts a new thread // } //} Using the Callable Interface SHOW CODE Java import java.util.concurrent.*; public class Main { public static void main(String[] args) throws Exception { ExecutorService executor = Executors.newSingleThreadExecutor(); Future\u0026lt;String\u0026gt; future = executor.submit(() -\u003e Thread.currentThread().getName() + \" is running.\"); System.out.println(future.get()); executor.shutdown(); } } class MyCallable implements Callable\u0026lt;String\u0026gt; { // @Override // public String call() { // return \"Thread executed\"; // } //} // //public class Main { // public static void main(String[] args) throws Exception { // ExecutorService executor = Executors.newSingleThreadExecutor(); // Future\u0026lt;String\u0026gt; future = executor.submit(new MyCallable()); // System.out.println(future.get()); // Retrieves the result // executor.shutdown(); // } //} Using Executors SHOW CODE Java import java.util.concurrent.*; public class Main { public static void main(String[] args) { ExecutorService executor = Executors.newFixedThreadPool(2); Runnable task1 = () -\u003e System.out.println(Thread.currentThread().getName() + \" executed\"); Runnable task2 = () -\u003e System.out.println(Thread.currentThread().getName() + \" executed\"); executor.execute(task1); executor.execute(task2); executor.shutdown(); } } Thread Termination In Java Using a flag SHOW CODE Java class Task implements Runnable { // Use volatile to ensure visibility between thread private volatile boolean running = true; @Override public void run() { while (running) { System.out.println(\"Thread is running.\"); try { Thread.sleep(1000); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } System.out.println(\"Thread is stopping.\"); } public void stop() { running = false; } } public class Main { public static void main(String[] args) throws InterruptedException { Task task = new Task(); Thread thread = new Thread(task); thread.start(); Thread.sleep(3000); // Allow thread to run for a while task.stop(); // Signal thread to stop } } Interrupting a Thread SHOW CODE Java public class Main { public static void main(String[] args) throws InterruptedException { Thread thread = new Thread(() -\u003e { try { while (!Thread.currentThread().isInterrupted()) { System.out.println(\"Thread is running\"); Thread.sleep(1000); } } catch (InterruptedException e) { System.out.println(\"Thread is interrupted\"); } }); thread.start(); Thread.sleep(3000); // Allow thread to run for a while thread.interrupt(); // Interrupt the thread } } Daemon Threads A daemon thread in Java is a low-priority thread that runs in the background, typically handling tasks such as garbage collection or other housekeeping operations. The JVM terminates when all non-daemon threads have completed execution, even if daemon threads are still active. To create a daemon thread, the setDaemon(true) method is used on a Thread object before it is started.\nSHOW CODE Java public class Main { public static void main(String[] args) { Thread daemonThread = new Thread(() -\u003e { while (true) { System.out.println(\"Daemon thread is running\"); try { Thread.sleep(1000); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } }); daemonThread.setDaemon(true); // Mark as daemon daemonThread.start(); System.out.println(\"Main thread is ending\"); } } SHOW OUTPUT Output Main thread is ending Daemon thread is running Performance Optimization When it comes to multithreading, performance optimization typically focuses on two key areas: latency reduction and throughput improvement.\nLatency reduction refers to minimizing the time it takes to complete a single task, measured in time units. This is often achieved by breaking a task into smaller subtasks that can be executed concurrently by multiple threads.\nThroughput, on the other hand, measures the number of tasks completed within a specific time frame, typically expressed as tasks / time unit. Throughput improvement is commonly achieved by utilizing thread pooling, which reduces the overhead of creating and destroying threads for each task.\nSHOW CODE: Latency Reduction Java import javax.imageio.ImageIO; import java.awt.image.BufferedImage; import java.io.File; import java.io.IOException; import java.util.ArrayList; import java.util.List; public class Main { private static final String SOURCE_FILE = \"src/main/resources/1-flower.jpg\"; private static final String DESTINATION_FILE = \"./out/1-flower.jpg\"; public static void main(String[] args) throws IOException { BufferedImage originalImage = ImageIO.read(new File(SOURCE_FILE)); BufferedImage resultImage = new BufferedImage(originalImage.getWidth(), originalImage.getHeight(), BufferedImage.TYPE_INT_RGB); long startTime = System.currentTimeMillis(); // recolorSingleThreaded(originalImage, resultImage); int numberOfThreads = 1; recolorMultithreaded(originalImage, resultImage, numberOfThreads); long endTime = System.currentTimeMillis(); long duration = endTime - startTime; File outputFile = new File(DESTINATION_FILE); File parentDir = outputFile.getParentFile(); if (parentDir != null \u0026\u0026 !parentDir.exists()) { parentDir.mkdirs(); // Create the directory if it doesn't exist } ImageIO.write(resultImage, \"jpeg\", outputFile); System.out.println(\"duration = \" + duration); } public static void recolorMultithreaded(BufferedImage originalImage, BufferedImage resultImage, int numberOfThreads) { List\u0026lt;Thread\u0026gt; threads = new ArrayList\u0026lt;\u0026gt;(); int width = originalImage.getWidth(); int height = originalImage.getHeight() / numberOfThreads; for(int i = 0; i \u003c numberOfThreads ; i++) { final int threadMultiplier = i; Thread thread = new Thread(() -\u003e { int xOrigin = 0 ; int yOrigin = height * threadMultiplier; recolorImage(originalImage, resultImage, xOrigin, yOrigin, width, height); }); threads.add(thread); } for(Thread thread : threads) { thread.start(); } for(Thread thread : threads) { try { thread.join(); } catch (InterruptedException e) { } } } private static void recolorSingleThreaded(BufferedImage originalImage, BufferedImage resultImage) { recolorImage(originalImage, resultImage, 0, 0, originalImage.getWidth(), originalImage.getHeight()); } private static void recolorImage(BufferedImage originalImage, BufferedImage resultImage, int leftCorner, int topCorner, int width, int height) { for (int x = leftCorner; x \u003c leftCorner + width \u0026\u0026 x \u003c originalImage.getWidth(); x++) { for (int y = topCorner; y \u003c topCorner + height \u0026\u0026 y \u003c originalImage.getHeight(); y++) { recolorPixel(originalImage, resultImage, x, y); } } } private static void recolorPixel(BufferedImage originalImage, BufferedImage resultImage, int x, int y) { int rgb = originalImage.getRGB(x, y); int red = getRed(rgb); int green = getGreen(rgb); int blue = getBlue(rgb); int newRed; int newGreen; int newBlue; if (isShadeOfGray(red, green, blue)) { newRed = Math.min(255, red + 10); newGreen = Math.max(0, green - 80); newBlue = Math.max(0, blue - 20); } else { newRed = red; newGreen = green; newBlue = blue; } int newRGB = createRGBFromColors(newRed, newGreen, newBlue); setRGB(resultImage, x, y, newRGB); } public static void setRGB(BufferedImage image, int x, int y, int rgb) { image.getRaster().setDataElements(x, y, image.getColorModel().getDataElements(rgb, null)); } public static boolean isShadeOfGray(int red, int green, int blue) { return Math.abs(red - green) \u003c 30 \u0026\u0026 Math.abs(red - blue) \u003c 30 \u0026\u0026 Math.abs(green - blue) \u003c 30; } public static int createRGBFromColors(int red, int green, int blue) { int rgb = 0; rgb |= blue; rgb |= green \u003c\u003c 8; rgb |= red \u003c\u003c 16; rgb |= 0xFF000000; return rgb; } public static int getRed(int rgb) { return (rgb \u0026 0x00FF0000) \u003e\u003e 16; } public static int getGreen(int rgb) { return (rgb \u0026 0x0000FF00) \u003e\u003e 8; } public static int getBlue(int rgb) { return rgb \u0026 0x000000FF; } } SHOW IMAGE: BEFORE PROCESSING SHOW IMAGE: AFTER PROCESSING Single Threaded VS. Multithreaded SHOW CODE: Throughput vs. Threads Throughput vs. Threads import com.sun.net.httpserver.HttpExchange; import com.sun.net.httpserver.HttpHandler; import com.sun.net.httpserver.HttpServer; import java.io.IOException; import java.io.OutputStream; import java.net.InetSocketAddress; import java.nio.file.Files; import java.nio.file.Paths; import java.util.concurrent.Executor; import java.util.concurrent.Executors; public class ThroughputHttpServer { private static final String INPUT_FILE = \"./resources/war_and_peace.txt\"; private static final int NUMBER_OF_THREADS = 8; public static void main(String[] args) throws IOException { String text = new String(Files.readAllBytes(Paths.get(INPUT_FILE))); startServer(text); } public static void startServer(String text) throws IOException { HttpServer server = HttpServer.create(new InetSocketAddress(8000), 0); server.createContext(\"/search\", new WordCountHandler(text)); Executor executor = Executors.newFixedThreadPool(NUMBER_OF_THREADS); server.setExecutor(executor); server.start(); } private static class WordCountHandler implements HttpHandler { private String text; public WordCountHandler(String text) { this.text = text; } @Override public void handle(HttpExchange httpExchange) throws IOException { String query = httpExchange.getRequestURI().getQuery(); String[] keyValue = query.split(\"=\"); String action = keyValue[0]; String word = keyValue[1]; if (!action.equals(\"word\")) { httpExchange.sendResponseHeaders(400, 0); return; } long count = countWord(word); byte[] response = Long.toString(count).getBytes(); httpExchange.sendResponseHeaders(200, response.length); OutputStream outputStream = httpExchange.getResponseBody(); outputStream.write(response); outputStream.close(); } private long countWord(String word) { long count = 0; int index = 0; while (index \u003e= 0) { index = text.indexOf(word, index); if (index \u003e= 0) { count++; index++; } } return count; } } } SHOW IMAGE: Throughput VS. Threads Problems Linear Search with Finding One Occurrence SHOW PROBLEM Problem Statement:\nThe input consists of a large array (or list) of elements and a target value to search for. The goal is to utilize multiple threads to divide the search space and concurrently search for the target value, ultimately returning the index of the first occurrence of the target or -1 indicating that the target is not present.\nRequirements:\nMultithreading: Divide the array into multiple segments, with each thread searching a specific segment of the array. Each thread should operate independently and search its assigned segment. Return First Occurrence: Once the target value is found by any thread, it should return the index of the first occurrence, and other threads should stop searching. Constraints:\nThe array can be large (millions of elements). The number of threads used should be adjustable. The target value may appear multiple times in the array, but only the index of the first occurrence should be returned. SHOW CODE Java public class Solution { private static final int SIZE = 280000; private static final int NUM_THREADS = 4; private static final Object mtx = new Object(); // Mutex for controlling access to foundIndex private static volatile int foundIndex = -1; private static void linearSearch(int threadId, int[] arr, int key) { int chunkSize = arr.length / NUM_THREADS; int start = threadId * chunkSize; int end = (threadId == NUM_THREADS - 1) ? arr.length : start + chunkSize; for (int i = start; i \u003c end; ++i) { // Early exit if foundIndex is set by another thread synchronized (mtx) { if (foundIndex != -1) { break; } } if (arr[i] == key) { synchronized (mtx) { if (foundIndex == -1) { foundIndex = i; break; // Exit after setting foundIndex } } } } } public static void main(String[] args) { // Fill array with random numbers between 0-99 int[] arr = new int[SIZE]; for (int i = 0; i \u003c SIZE; ++i) { arr[i] = (int) (Math.random() * 100); } Thread[] threads = new Thread[NUM_THREADS]; int key = 9; for (int i = 0; i \u003c NUM_THREADS; ++i) { final int threadId = i; threads[i] = new Thread(() -\u003e linearSearch(threadId, arr, key)); threads[i].start(); } for (Thread thread : threads) { try { thread.join(); } catch (InterruptedException e) { e.printStackTrace(); } } if (foundIndex == -1) { System.out.println(\"Element not found in the array.\"); } else { System.out.println(\"Element found at index: \" + foundIndex); } } } Linear Search for All Occurrences SHOW PROBLEM Problem Statement:\nThe input consists of a large array (or list) of elements and a target value to search for. The goal is to utilize multiple threads to divide the search space and concurrently search for the target value, ultimately returning the index of all occurrences of the target or an empty list indicating that the target is not present.\nRequirements:\nMultithreading: Divide the array into multiple segments, with each thread searching a specific segment of the array. Each thread should operate independently and search its assigned segment. Return All Occurrences: Once the target value is found, the thread should store the index. All threads should continue searching, and their results (all indices of the target’s occurrences) should be combined and returned. Constraints:\nThe array can be large (millions of elements). The number of threads used should be adjustable. The target value may appear multiple times in the array, and all indices where the target is found should be returned. SHOW CODE Java import java.util.ArrayList; import java.util.List; import java.util.Random; public class Solution { private static final int SIZE = 4000; private static final int NUM_THREADS = 4; // Mutex for controlling access to foundPlaces private static final Object lockObj = new Object(); private static List\u0026lt;Integer\u0026gt; foundPlaces = new ArrayList\u0026lt;\u0026gt;(); private static void linearSearch(int threadId, int[] arr, int key) { int chunkSize = arr.length / NUM_THREADS; int start = threadId * chunkSize; int end = (threadId == NUM_THREADS - 1) ? arr.length : start + chunkSize; for (int i = start; i \u003c end; ++i) { if (arr[i] == key) { synchronized (lockObj) { // Lock when modifying foundPlaces foundPlaces.add(i); // Append the index to foundPlaces } } } } public static void main(String[] args) { // Create an array and fill it with random numbers between 0 and 99 int[] arr = new int[SIZE]; Random random = new Random(); for (int i = 0; i \u003c SIZE; ++i) { arr[i] = random.nextInt(100); } Thread[] threads = new Thread[NUM_THREADS]; // List to hold the threads int key = 9; // Element to find // Start the threads for (int i = 0; i \u003c NUM_THREADS; ++i) { final int threadId = i; threads[i] = new Thread(() -\u003e linearSearch(threadId, arr, key)); threads[i].start(); } // Join the threads with the main thread for (Thread thread : threads) { try { thread.join(); } catch (InterruptedException e) { e.printStackTrace(); } } // Display the result if (foundPlaces.isEmpty()) { System.out.println(\"Element not found in the array.\"); } else { System.out.print(\"Element found at indices: \"); synchronized (lockObj) { // Lock when reading from foundPlaces for (int index : foundPlaces) { System.out.print(index + \" \"); } } System.out.println(); } } } SHOW NOTES The synchonization block can be removed when reading values from foundPlaces, as no threads modify the foundPlaces after the join() method is called.\n// Display the result if (foundPlaces.isEmpty()) { System.out.println(\u0026#34;Element not found in the array.\u0026#34;); } else { System.out.print(\u0026#34;Element found at indices: \u0026#34;); // No need for synchronization here, as no threads are modifying foundPlaces now // synchronized (lockObj) { // Lock when reading from foundPlaces for (int index : foundPlaces) { System.out.print(index + \u0026#34; \u0026#34;); } // } System.out.println(); } Linear Search with Indices and Occurrences SHOW PROBLEM Problem Statement:\nYou are given a large array (or list) of elements and a target value to search for. Your task is to implement a linear search that finds all occurrences of the target value in the array using multiple threads. Each thread should search a specific segment of the array, and the results (indices where the target is found) should be stored in a shared collection (e.g., a list). Additionally, a shared variable should keep track of the count of occurrences of the target value.\nRequirements:\nMultithreading: Divide the array into equal segments based on the number of threads. Each thread should independently search its assigned segment for the target value. The number of threads should be adjustable to optimize performance depending on the size of the array. Return: A list of integers representing the indices of all occurrences of the target value. An integer representing the total count of occurrences of the target value. Constraints:\nThe array can be very large, potentially containing millions of elements. The number of threads used should be adjustable, allowing the program to scale with the size of the array and the system\u0026rsquo;s available resources. The target value may appear multiple times, and all occurrences should be included in the final result. SHOW CODE Java import java.util.ArrayList; import java.util.List; import java.util.Random; public class Solution { private static final int SIZE = 4000; private static final int NUM_THREADS = 4; private static final List\u0026lt;Integer\u0026gt; foundIndices = new ArrayList\u0026lt;\u0026gt;(); // Shared list to store the indices of all occurrences private static int occurrencesCount = 0; // Shared variable to store the count of occurrences private static final Object indicesLock = new Object(); // Lock for synchronizing access to foundIndices private static final Object countLock = new Object(); // Lock for synchronizing access to occurrencesCount // Function executed by each thread to search for indices and occurrences private static void searchIndicesOccurrences(int threadId, int[] arr, int key) { int chunkSize = arr.length / NUM_THREADS; int start = threadId * chunkSize; int end = (threadId == NUM_THREADS - 1) ? arr.length : start + chunkSize; List\u0026lt;Integer\u0026gt; localIndices = new ArrayList\u0026lt;\u0026gt;(); int localCount = 0; for (int i = start; i \u003c end; ++i) { if (arr[i] == key) { localIndices.add(i); localCount++; } } if (!localIndices.isEmpty()) { synchronized (indicesLock) { foundIndices.addAll(localIndices); } } if (localCount \u003e 0) { synchronized (countLock) { occurrencesCount += localCount; } } } public static void main(String[] args) { // Create an array and fill it with random numbers between 0 and 99 int[] arr = new int[SIZE]; Random random = new Random(); for (int i = 0; i \u003c SIZE; ++i) { arr[i] = random.nextInt(100); } Thread[] threads = new Thread[NUM_THREADS]; // Array of threads int key = 9; // Element to find // Start the threads for (int i = 0; i \u003c NUM_THREADS; ++i) { int threadId = i; threads[i] = new Thread(() -\u003e searchIndicesOccurrences(threadId, arr, key)); threads[i].start(); } // Wait for all threads to complete for (Thread thread : threads) { try { thread.join(); } catch (InterruptedException e) { e.printStackTrace(); } } // Output the results if (foundIndices.isEmpty()) { System.out.println(\"Element not found in the array.\"); } else { System.out.print(\"Element found \" + occurrencesCount + \" times at indices: \"); for (int index : foundIndices) { System.out.print(index + \" \"); } System.out.println(); } } } Min/Max/Sum SHOW PROBLEM Problem Statement:\nThe input consists of a large array (or list) of elements. The goal is to efficiently calculate the minimum, maximum, and sum of elements in the array using multithreading. The array is divided into multiple segments, with each thread processing a specific segment. The threads will then return partial results (minimum, maximum, and sum for their respective segments), which will be combined to compute the final values for the entire array.\nRequirements:\nMultithreading: Divide the array into multiple segments, with each thread processing a specific portion of the array. Each thread should independently compute the minimum, maximum, and sum for its assigned segment.\nCombine Results: Once each thread has finished processing, their partial results (min, max, and sum for the segment) should be combined to compute the final minimum, maximum, and sum for the entire array.\nEfficiency: The program should use multithreading to optimize the processing time, especially when dealing with large arrays containing millions of elements. The number of threads should be adjustable for optimal performance.\nConstraints:\nThe array can be large (millions of elements).\nThe number of threads used should be adjustable based on the size of the array and the system’s capabilities.\nThe array can contain both positive and negative numbers, and the minimum, maximum, and sum should be computed accurately, including for arrays with all negative values.\nSHOW CODE Java import java.util.Random; public class Solution { private static final int DATA_SIZE = 100; private static final int NUMBER_OF_THREADS = 4; private static int[] data = new int[DATA_SIZE]; private static int[] threadResultsSum = new int[NUMBER_OF_THREADS]; private static int[] threadResultsMin = new int[NUMBER_OF_THREADS]; private static int[] threadResultsMax = new int[NUMBER_OF_THREADS]; public static void main(String[] args) throws InterruptedException { // Initialize data array Random random = new Random(); for (int i = 0; i \u003c DATA_SIZE; i++) { data[i] = random.nextInt(500); } Thread[] threads = new Thread[NUMBER_OF_THREADS * 3]; // Start threads for sum, min, and max calculations for (int i = 0; i \u003c NUMBER_OF_THREADS; i++) { final int threadId = i; final int start = threadId * (DATA_SIZE / NUMBER_OF_THREADS); final int end = (threadId + 1) * (DATA_SIZE / NUMBER_OF_THREADS); threads[threadId] = new Thread(() -\u003e threadedSum(threadId, start, end)); threads[threadId + NUMBER_OF_THREADS] = new Thread(() -\u003e threadedMin(threadId, start, end)); threads[threadId + NUMBER_OF_THREADS * 2] = new Thread(() -\u003e threadedMax(threadId, start, end)); threads[threadId].start(); threads[threadId + NUMBER_OF_THREADS].start(); threads[threadId + NUMBER_OF_THREADS * 2].start(); } // Wait for threads to finish for (Thread thread : threads) { thread.join(); } // Aggregate results from threads int totalSum = 0; for (int sum : threadResultsSum) { totalSum += sum; } int min = Integer.MAX_VALUE; for (int minResult : threadResultsMin) { min = Math.min(min, minResult); } int max = Integer.MIN_VALUE; for (int maxResult : threadResultsMax) { max = Math.max(max, maxResult); } System.out.println(\"Sum is \" + totalSum); System.out.println(\"Min is \" + min); System.out.println(\"Max is \" + max); } private static void threadedSum(int threadId, int start, int end) { int sum = 0; for (int i = start; i \u003c end; i++) { sum += data[i]; } threadResultsSum[threadId] = sum; } private static void threadedMin(int threadId, int start, int end) { int min = Integer.MAX_VALUE; for (int i = start; i \u003c end; i++) { min = Math.min(min, data[i]); } threadResultsMin[threadId] = min; } private static void threadedMax(int threadId, int start, int end) { int max = Integer.MIN_VALUE; for (int i = start; i \u003c end; i++) { max = Math.max(max, data[i]); } threadResultsMax[threadId] = max; } } Pi Calculation SHOW PROBLEM Problem Statement\nThe problem is to estimate the value of Pi using the Monte Carlo simulation method. In this method, we randomly generate points within a square and check how many of these points fall inside a circle inscribed within the square. The ratio of points inside the circle to the total points generated provides an approximation of Pi.\nRequirements:\nRandom Point Generation:\nGenerate a large number of random points within a square. The square should have side lengths of 2 (i.e., points with coordinates ranging from -1 to 1 on both the x and y axes). Each point has coordinates $(x, y)$, where $x$ and $y$ are randomly generated floating-point values between -1 and 1. Circle Inside the Square:\nA circle is inscribed within the square, with a radius of 1 and centered at the origin (0, 0). A point $(x, y)$ lies inside the circle if the following condition is true: $$ x^2 + y^2 \\leq 1 $$ Monte Carlo Estimation of Pi:\nCount how many of the generated points fall inside the circle. The ratio of the points inside the circle to the total number of points can be used to estimate Pi. Specifically, the approximation of Pi is given by: $$ \\pi \\approx 4 \\times \\frac{\\text{points inside the circle}}{\\text{total number of points}} $$ Multithreading:\nTo speed up the simulation, divide the task of generating points and checking whether they lie inside the circle into multiple threads. Each thread should be responsible for generating a subset of points and counting how many fall inside the circle. Once all threads finish their work, their results should be combined to compute the final approximation of Pi. Output:\nReturn the estimated value of Pi based on the simulation. Constraints:\nThe number of points to generate can be very large (millions of points). The number of threads used should be adjustable. The accuracy of the approximation improves with more points, but the simulation should be efficient enough to handle large numbers of points and multiple threads. SHOW CODE Java import java.util.Random; public class Solution { private static final int NUM_THREADS = 10; private static final int NUMBER_OF_TOSSES = 100000000; private static int[] results = new int[NUM_THREADS]; public static void main(String[] args) throws InterruptedException { Thread[] threads = new Thread[NUM_THREADS]; for (int i = 0; i \u003c NUM_THREADS; i++) { final int threadId = i; threads[i] = new Thread(() -\u003e { Random rand = new Random(); int start = threadId * NUMBER_OF_TOSSES / NUM_THREADS; int end = (threadId + 1) * NUMBER_OF_TOSSES / NUM_THREADS; int count_in_circle = 0; for (int j = start; j \u003c end; j++) { double x = rand.nextDouble() * 2 - 1; // Random x in range [-1, 1] double y = rand.nextDouble() * 2 - 1; // Random y in range [-1, 1] if (x * x + y * y \u003c= 1) { // If point is inside the circle count_in_circle++; } } results[threadId] = count_in_circle; }); threads[i].start(); } for (Thread thread : threads) { thread.join(); } // Compute final estimate of Pi int total_inside = 0; for (int result : results) { total_inside += result; } double pi_estimate = 4.0 * total_inside / NUMBER_OF_TOSSES; System.out.println(\"PI = \" + pi_estimate); } } SHOW NOTES Introduction to Monte Carlo Estimation of $\\pi$\nSuppose a square with a circle inscribed inside it, as shown in the image below. The circle has a radius of $r$, and the square has side length $2r$. The area of the circle is $A_{\\text{circle}} = \\pi r^2$, and the area of the square is $A_{\\text{square}} = (2r)^2 = 4r^2$\nThe ratio of the area of the circle to the area of the square is $$ \\frac{A_{\\text{circle}}}{A_{\\text{square}}} = \\frac{\\pi r^2}{4 r^2} = \\frac{\\pi}{4} $$\nTherefore, the value of $\\pi$ can be estimated by the formula:\n$$ \\pi \\approx 4 \\times \\frac{\\text{Number of points inside the circle}}{\\text{Total number of points inside the square}} $$\nVisulization:\nJUC CompletableFuture Future Interface The Future interface in Java defines several methods for managing asynchronous tasks, such as retriving the execution result, canceling a task, and checking if a task has been canceled or completed. It includes four commonly used methods: get(), isDone(), cancel(), and isCancelled().\nThe get() mthod retrives the result of computation. Note: If the computation is not yet complete, this method will block until the result is available. The isDone() method checks whether the computation has finished executing. The cancel() method attempts to cancel the task execution. The isCancelled() method checks if the task has been canceled before completion. The FutureTask class is a concrete implementation of the Future interface. It implements both the Runnable and Future interfaces, allowing it to be executed by a thread while also returning a result. Its constructor takes a Callable\u0026lt;V\u0026gt;, enabling the task to return a value. The class diagram is shown below: The Future combined with a thread pool enhances execution performance efficiently. However, its drarback lies in the get() method, which is blocking, and the isDone() method, whose polling behavior consumes CPU resources.\nSHOW CODE FutureGetBlocking FutureIsDonePolling import java.util.concurrent.ExecutionException; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Future; class Main { public static void main(String[] args) throws ExecutionException, InterruptedException { ExecutorService executor = Executors.newSingleThreadExecutor(); Future\u0026lt;String\u0026gt; future = executor.submit(() -\u003e { Thread.sleep(3000); // Simulate a long running task return \"Task Completed\"; }); System.out.println(\"Waiting for result...\"); // Block the main thread until the result is available String result = future.get(); System.out.println(\"Result: \" + result); executor.shutdown(); } } import java.util.concurrent.ExecutionException; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Future; class Main { public static void main(String[] args) throws ExecutionException, InterruptedException { ExecutorService executor = Executors.newSingleThreadExecutor(); Future\u0026lt;String\u0026gt; future = executor.submit(() -\u003e { Thread.sleep(3000); // Simulate a long-running task return \"Task Completed\"; }); // Busy-waiting, consuming CPU cycles while (!future.isDone()) { System.out.println(\"Checking if task is done...\"); Thread.sleep(100); // Reducing CPU usage slightly, but still inefficient } System.out.println(\"Result: \" + future.get()); executor.shutdown(); } } CompletableFuture The CompletableFuture implements both the Future and CompletionStage interfaces. The CompletionStage represents a computation step that can be completed asynchronously. Unlike Future, CompletableFuture provides advanced mechanisms for handling asynchronous tasks, including non-blocking execution, method chaining, exception handling, combining futures, and thread pool customization.\nNon-blocking Execution: Unlike Future.get(), whcih blocks until the result is available, CompletableFuture enables asynchronous execution without blocking the main thread. Chaining Supports method chaining with thenApply, thenCompose, and thenRun to process results sequently. Exception Handling: Provides exceptionally and handle methods to gracefully handle errors. Combining Futures: Supports combining multiple futures using thenCombine, allOf, and anyOf for parallel execution. Thread Pool Customization: Allows executing tasks in a custom thread pool for better resource management. SHOW CODE Without Blocking Chaining Tasks ExceptionHandling CombiningFutures import java.util.concurrent.*; class Main { public static void main(String[] args) throws ExecutionException, InterruptedException { CompletableFuture\u0026lt;Void\u0026gt; future = CompletableFuture.runAsync(() -\u003e { try { Thread.sleep(2000); System.out.println(\"Task executed in a separate thread\"); } catch (InterruptedException e) { e.printStackTrace(); } }); System.out.println(\"Main thread is not blocked.\"); future.join(); } } import java.util.concurrent.*; class Main { public static void main(String[] args) throws ExecutionException, InterruptedException { CompletableFuture\u0026lt;String\u0026gt; future = CompletableFuture.supplyAsync(() -\u003e \"Hello\") .thenApply(result -\u003e result + \", World!\") .thenApply(String::toUpperCase); System.out.println(future.join()); // Output: HELLO, WORLD! } } import java.util.concurrent.*; class Main { public static void main(String[] args) throws ExecutionException, InterruptedException { CompletableFuture\u0026lt;String\u0026gt; future = CompletableFuture.supplyAsync(() -\u003e { if (true) { throw new RuntimeException(\"Something went wrong!\"); } return \"Success\"; }).exceptionally(ex -\u003e \"Recovered from: \" + ex.getMessage()); // Recovered from: java.lang.RuntimeException: Something went wrong! System.out.println(future.join()); } } import java.util.concurrent.*; class Main { public static void main(String[] args) throws ExecutionException, InterruptedException { CompletableFuture\u0026lt;String\u0026gt; future1 = CompletableFuture.supplyAsync(() -\u003e \"Task 1\"); CompletableFuture\u0026lt;String\u0026gt; future2 = CompletableFuture.supplyAsync(() -\u003e \"Task 2\"); CompletableFuture\u0026lt;String\u0026gt; future3 = CompletableFuture.supplyAsync(() -\u003e \"Task 3\"); CompletableFuture allFutures = CompletableFuture.allOf(future1, future2, future3); // Retrieve results from individual futures String result1 = future1.get(); String result2 = future2.get(); String result3 = future3.get(); System.out.println(result1); System.out.println(result2); System.out.println(result3); allFutures.join(); // Wait for all tasks to complete System.out.println(\"All tasks completed!\"); } } The advantage of CompletableFuture is that when an asynchronous task completes, it automatically invokes the callback method. Once the main thread sets up the callback, it no longer needs to monitor the asynchronous task, and allows execution to proceed in sequence. Additionally, if the asynchronous task fails, it automatically triggers the corresponding error-handling method.\nBy default, CompletableFuture.supplyAsync() and runAsync() utilize the ForkJoinPool.commonPool(), a shared thread pool based on the ForkJoin framework. To use a custom thread pool, you need to provide a custom Executor when calling these methods.\nSHOW CODE ForkJoinPool.commonPool() Custom Thread Pool import java.util.concurrent.*; class Main { public static void main(String[] args) throws ExecutionException, InterruptedException { CompletableFuture.runAsync(() -\u003e { // Running in: ForkJoinPool.commonPool-worker-1 System.out.println(\"Running in: \" + Thread.currentThread().getName()); }); // Sleep to allow async task to execute try { Thread.sleep(100); } catch (InterruptedException e) { } } } import java.util.concurrent.*; class Main { public static void main(String[] args) throws ExecutionException, InterruptedException { ExecutorService executor = Executors.newFixedThreadPool(5); CompletableFuture.runAsync(() -\u003e // Custom pool: pool-1-thread-1 System.out.println(\"Custom pool: \" + Thread.currentThread().getName()), executor); } } The main difference between CompletableFuture.get() and CompletableFuture.join() is exception handling. get() throws checked exceptions (ExecutionException, InterruptedException), requiring explicit handling, while join() throws an unchecked CompletionException, eliminating the need for explicit exception handling.\nThe main differences between thenRun(), thenAccept(), and thenApply are\nthenRun() runs a task after previous stage completes, but does not take its result as input. thenAccept() runs a task after previous stage completes and consumes its result. thenApply() runs a task after previous stage completes and transform its result. CompletableFuture.supplyAsync(() -\u0026gt; \u0026#34;Task Completed\u0026#34;) .thenRun(() -\u0026gt; System.out.println(\u0026#34;Follow-up action executed!\u0026#34;)); CompletableFuture.supplyAsync(() -\u0026gt; \u0026#34;Hello, World!\u0026#34;) .thenAccept(result -\u0026gt; System.out.println(\u0026#34;Result: \u0026#34; + result)); CompletableFuture\u0026lt;String\u0026gt; future = CompletableFuture.supplyAsync(() -\u0026gt; \u0026#34;Hello\u0026#34;) .thenApply(result -\u0026gt; result + \u0026#34;, World!\u0026#34;); System.out.println(future.join()); // Output: Hello, World! Method Takes Previous Result? Returns a Value? Use Case thenRun ❌ No ❌ No (Void) Just run a task after completion thenAccept ✅ Yes ❌ No (Void) Consume the result without returning a new one thenApply ✅ Yes ✅ Yes (R) Transform the result and return a new value Java Locks Optimistic Lock vs. Pessimistic Lock Optimistic Lock assumes minimal contention, allowing multiple threads to read and write data concurrently. Instead of using locks, it relies on versioning or CAS (Compare-And-Swap) to detect conflicts during updates. If a conflict is detected (i.e., another thread has modified the data), the operation is retried. It is particularly effective in high-read, low-write scenarios.\nSHOW CODE Use versioning in SQL Use CAS in Java # Use versioning in SQL UPDATE products SET stock = stock - 1, version = version + 1 WHERE id = 1 AND version = 5; import java.util.concurrent.*; import java.util.concurrent.atomic.AtomicInteger; class Main { public static void main(String[] args) throws ExecutionException, InterruptedException { AtomicInteger count = new AtomicInteger(0); int expectedValue, newValue; do { expectedValue = count.get(); newValue = expectedValue + 1; } while (!count.compareAndSet(expectedValue, newValue)); System.out.println(\"Updated Count: \" + count.get()); } } Pessimistic Lock assumes high contention and prevents concurrent modification by blocking the resource. Other threads must wait until the lock is released. It is suitable for high-write, low-read scenerios. In Java, the synchronized and ReentrantLock are implementations of pessimistic lock.\nSHOW CODE synchronized ReentrantLock class PessimisticLockExample { private int count = 0; public synchronized void increment() { count++; } } import java.util.concurrent.locks.ReentrantLock; public class PessimisticLockExample { private int count = 0; private final ReentrantLock lock = new ReentrantLock(); public void increment() { lock.lock(); try { count++; } finally { lock.unlock(); } } } synchronized Related Problems SHOW CODE Java class Phone { public synchronized void sendEmail() { System.out.println(\"send email\"); } public synchronized void sendSMS() { System.out.println(\"send SMS\"); } } class Main { public static void main(String[] args) { Phone phone = new Phone(); new Thread(() -\u003e { phone.sendEmail(); }, \"A\").start(); // Ensure thread A starts first try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -\u003e { phone.sendSMS(); }, \"B\").start(); } } The above code first outputs send email, followed by send SMS. This happens because both sendEmail() and sendSMS() are synchronized methods that lock the same object. As a result, the thread that acquires the lock first executes first, while other threads must wait until the lock is released.\nSHOW CODE Java class Phone { public synchronized void sendEmail() { try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"send email\"); } public synchronized void sendSMS() { System.out.println(\"send SMS\"); } } class Main { public static void main(String[] args) { Phone phone = new Phone(); new Thread(() -\u003e { phone.sendEmail(); }, \"A\").start(); // Ensure thread A starts first try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -\u003e { phone.sendSMS(); }, \"B\").start(); } } The above code first outputs send email, followed by send SMS. This happens because both sendEmail() and sendSMS() are synchronized methods that lock the same object and executes sleep() method doesn\u0026rsquo;t release a lock. Therefore, the thread that acquires the lock first executes first, while other threads must wait until the lock is released.\nSHOW CODE Java class Phone { public synchronized void sendEmail() { try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"send email\"); } public synchronized void sendSMS() { System.out.println(\"send SMS\"); } public void hello() { System.out.println(\"hello\"); } } class Main { public static void main(String[] args) { Phone phone = new Phone(); new Thread(phone::sendEmail, \"A\").start(); // Ensure thread A starts first try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -\u003e { phone.hello(); }, \"B\").start(); } } The above code outputs hello immediately, followed by send email. This is because the hello() method is not synchronized and does not require a lock, allowing it to execute without waiting.\nSHOW CODE Java import java.util.concurrent.TimeUnit; class Phone { public synchronized void sendEmail() { try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"send email\"); } public synchronized void sendSMS() { System.out.println(\"send SMS\"); } } class Main { public static void main(String[] args) { Phone phone1 = new Phone(); Phone phone2 = new Phone(); new Thread(() -\u003e { phone1.sendEmail(); }, \"A\").start(); // Ensure thread A starts first try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -\u003e { phone2.sendSMS(); }, \"B\").start(); } } The above code outputs send SMS first, followed by send email. This happens because the synchronized keyword locks the object instances (phone1 and phone2), not the class itself. Since phone1 and phone2 are different objects, their locks do not interfere with each other.\nIn this case, Thread A starts first and acquires the lock on phone1, but sleep for 3 seconds inside the sendEmail() method. Meanwhile, Thread B starts shortly after and acquires the lock on phone2. Since Thread B does not need to wait for Thread A to release its lock (as they operate on different objects), it executes sendSMS() immediately. As a result, Thread B outputs send SMS first, while Thread A outputs send email after its sleep period ends.\nSHOW CODE Java import java.util.concurrent.TimeUnit; class Phone { public static synchronized void sendEmail() { try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"send email\"); } public static synchronized void sendSMS() { System.out.println(\"send SMS\"); } } class Main { public static void main(String[] args) { Phone phone = new Phone(); new Thread(() -\u003e { phone.sendEmail(); }, \"A\").start(); // Ensure thread A starts first try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -\u003e { phone.sendSMS(); }, \"B\").start(); } } The above code outputs send email first, followed by send SMS. This happens because the static synchronized keyword locks the Phone.class object, not individual instances of the class. Since both methods (sendEmail and send SMS) are static synchronized, they share the same lock on the Phone.class object. As a result, their execution is sequential.\nSHOW CODE Java import java.util.concurrent.TimeUnit; class Phone { public static synchronized void sendEmail() { try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"send email\"); } public static synchronized void sendSMS() { System.out.println(\"send SMS\"); } } class Main { public static void main(String[] args) { Phone phone1 = new Phone(); Phone phone2 = new Phone(); new Thread(() -\u003e { phone1.sendEmail(); }, \"A\").start(); // Ensure thread A starts first try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -\u003e { phone2.sendSMS(); }, \"B\").start(); } } The above code outputs send email first, followed by send SMS. Even though there are two different objects (phone1 and phone2), the static synchronized keyword locks the Phone.class object, not the individual instances. This means that both sendEmail() and sendSMS() share the same lock at the class level, ensuring sequential execution.\nSHOW CODE Java import java.util.concurrent.TimeUnit; class Phone { public static synchronized void sendEmail() { try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"send email\"); } public synchronized void sendSMS() { System.out.println(\"send SMS\"); } } class Main { public static void main(String[] args) { Phone phone = new Phone(); new Thread(() -\u003e { phone.sendEmail(); }, \"A\").start(); // Ensure thread A starts first try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -\u003e { phone.sendSMS(); }, \"B\").start(); } } The above code outputs send SMS first, followed by send email. This happens because the synchronized keyword locks individual object instance, while static synchronized locks the class-level object. In this case, sendSMS() locks the phone object, and sendEmail() locks the Phone.class object. Since these locks are independent, Thread B does not need to wait for Thread A to release its lock. As a result, send SMS is printed first, while send email is printed after the 3-second sleep.\nSHOW CODE Java import java.util.concurrent.TimeUnit; class Phone { public static synchronized void sendEmail() { try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"send email\"); } public static synchronized void sendSMS() { System.out.println(\"send SMS\"); } public void hello() { System.out.println(\"hello\"); } } class Main { public static void main(String[] args) { Phone phone1 = new Phone(); Phone phone2 = new Phone(); new Thread(() -\u003e { phone1.sendEmail(); }, \"A\").start(); // Ensure thread A starts first try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -\u003e { phone2.hello(); phone2.sendSMS(); }, \"B\").start(); } } The above code outputs hello first, followed by send email and send SMS. This is because sendEmail() and sendSMS() are both static synchronized, meaning they lock the Phone.class object, enforcing sequential execution. In contrast, the hello() method is a regular method that does not require a lock, allowing it to execute immediately.\nsynchronized Byte Code Analysis SHOW CODE Source Code Source Code class Main { private final Object mtx = new Object(); public void f() { synchronized (mtx) { System.out.println(\"hello...\"); } } } public void f(); Code: 0: aload_0 1: getfield #7 // Field mtx:Ljava/lang/Object; 4: dup 5: astore_1 🌟 6: monitorenter 7: getstatic #13 // Field java/lang/System.out:Ljava/io/PrintStream; 10: ldc #19 // String hello... 12: invokevirtual #21 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 15: aload_1 🌟 16: monitorexit 17: goto 25 20: astore_2 21: aload_1 🌟 22: monitorexit 23: aload_2 24: athrow 25: return From the above bytecode, the synchronized block translates into monitorenter and monitorexit instructions. The lock is acquired before entering the block and released before exiting. The second monitorexit ensures that the lock is properly released if an exception occurs, as shown in the following code:\nSHOW CODE Source Code Byte Code class Main { private final Object mtx = new Object(); public void f() { synchronized (mtx) { System.out.println(\"hello...\"); throw new RuntimeException(\"Exception occurred\"); } } } public void f(); Code: 0: aload_0 1: getfield #7 // Field mtx:Ljava/lang/Object; 4: dup 5: astore_1 🌟 6: monitorenter 7: getstatic #13 // Field java/lang/System.out:Ljava/io/PrintStream; 10: ldc #19 // String hello... 12: invokevirtual #21 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 15: new #27 // class java/lang/RuntimeException 18: dup 19: ldc #29 // String Exception occurred 21: invokespecial #31 // Method java/lang/RuntimeException.\"\u0026lt;init\u0026gt;\":(Ljava/lang/String;)V 24: athrow 25: astore_2 26: aload_1 🌟 27: monitorexit 28: aload_2 29: athrow SHOW CODE Source Code Byte Code class Main { public synchronized void f() { System.out.println(\"hello...\"); } public static synchronized void m() { System.out.println(\"HELLO...\"); } } public synchronized void f(); descriptor: ()V flags: (0x0021) ACC_PUBLIC, 🌟ACC_SYNCHRONIZED🌟 Code: stack=2, locals=1, args_size=1 0: getstatic #7 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #13 // String hello... 5: invokevirtual #15 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LineNumberTable: line 3: 0 line 4: 8 public static synchronized void m(); descriptor: ()V flags: (0x0029) ACC_PUBLIC, 🌟ACC_STATIC, ACC_SYNCHRONIZED🌟 Code: stack=2, locals=0, args_size=0 0: getstatic #7 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #21 // String HELLO... 5: invokevirtual #15 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LineNumberTable: line 7: 0 line 8: 8 From the above bytecode, the JVM checks if the ACC_SYNCHRONIZED flag is set. If the flag is present, the thread acquires the appropriate monitor lock before executing the method. For instance methods, the lock is acquired on the object instance (this), while for static methods, the lock is acquired on the class object (e.g., Main.class). After the method completes execution, the thread releases the lock. The ACC_STATIC flag is used to determine whether the method is static, which in turn determines whether the lock is applied at the class level or the instance level.\nWhy any object in Java can be a lock?\nAny object in Java can be a lock because every object has an intrinsic monitor lock managed by the JVM. The ObjectMonitor structure is part of the JVM\u0026rsquo;s implementation of this mechanism, tracking details like the lock owner, EntryList, etc. For example, when a thread calls synchronized(obj), the JVM checks the ObjectMonitor associated with obj. If the lock is available, the thread acquires it and sets itself as the owner. If the lock is held by another thread, the current thread waits in the EntryList. When the lock is released, the JVM wakes up a waiting thread (if any) to acquire the lock.\nObjectMonitor() { _header = NULL; _count = 0; _waiters = 0; _recursions = 0; _object = NULL; _owner = NULL; _MailSet = NULL; _MailSetLock = 0; _Responsible = NULL; _succ = NULL; _cxq = NULL; FreeNext = NULL; _EntryList = NULL; _SpinFreq = 0; _SpinClock = 0; OwnerIsThread = 0; _previous_owner_tid = 0; } Fair Lock vs. Unfair Lock In Java, locks can be calssified into fair locks and unfair locks based on their approach to thread scheduling. A fair lock ensures that threads acquire the lock in the exact order they requested it, following a first-come, first-served priciple. While this prevents thread starvation, it incurs additional overhead to maintain the order of threads. On the other hand, an unfair lock does not guarantee any specific order for thread access. A thread can acquire the lock even if it arrived later than others. This eliminates the need to maintain a strict order, improving efficiency, but it may result in thread starvation, where some threads could wait indefinitely for access.\nSHOW CODE Java import java.util.concurrent.locks.ReentrantLock; public class Main { private static final ReentrantLock unfairLock = new ReentrantLock(); // Unfair lock private static final ReentrantLock fairLock = new ReentrantLock(true); // Fair lock public static void main(String[] args) { System.out.print(\"Testing Unfair Lock: \"); testLock(unfairLock); System.out.print(\"Testing Fair Lock: \"); testLock(fairLock); } private static void testLock(ReentrantLock lock) { long startTime = System.currentTimeMillis(); Runnable task = () -\u003e { for (int i = 0; i \u003c 10000; i++) { lock.lock(); try { // Simulate work } finally { lock.unlock(); } } }; Thread[] threads = new Thread[10]; for (int i = 0; i \u003c threads.length; i++) { threads[i] = new Thread(task); threads[i].start(); } for (Thread thread : threads) { try { thread.join(); } catch (InterruptedException e) { e.printStackTrace(); } } long endTime = System.currentTimeMillis(); System.out.println(\"Time taken: \" + (endTime - startTime) + \" ms\"); } } SHOW OUTPUT Output Testing Unfair Lock: Time taken: 11 ms Testing Fair Lock: Time taken: 560 ms Recursive Lock A recursive lock in Java allows a thread to acquire the same lock multiple times without causing a deadlock. It is particularly useful in scenarios where a thread holding a lock calls another method or enters a synchronized block that requires the same lock. By default, the synchronized keyword and ReentrantLock class support recursive locking mechanism.\nThe recursive lock maintains a hold count, which tracks how many times a thread has acquired the lock. Each time the thread acquires the lock, the hold count is incremented, and it is decremented when the lock is released. The lock is fully released only when the hold count reaches zero.\nUnder the hood, when the monitorenter command is executed, the JVM checks the MonitorObject\u0026rsquo;s _count field. If _count is zero, it means the lock is not held by any other thread. In this case, the JVM sets the _owner field to the current thread and increments the _count. If _count is not zero and the _owner is the current thread, the JVM increments the _count (indicating reentrancy). Otherwise, if the lock is held by another thread, the current thread must wait until the lock is released (i.e., _count reaches zero).\nWhen the monitorexit command is executed, the JVM decrements the _count. Once _count reaches zero, the lock is considered fully released, and the _owner field is cleared, allowing other threads to acquire the lock.\nSHOW CODE Java import java.util.concurrent.locks.ReentrantLock; public class Main { private static final ReentrantLock lock = new ReentrantLock(); public static void main(String[] args) { recursiveMethod(3); } public static void recursiveMethod(int count) { lock.lock(); // Acquire the lock try { System.out.println(Thread.currentThread().getName() + \" acquired the lock. Hold count: \" + lock.getHoldCount()); if (count \u003e 0) { recursiveMethod(count - 1); // Recursive call } } finally { lock.unlock(); // Release the lock System.out.println(Thread.currentThread().getName() + \" released the lock. Hold count: \" + lock.getHoldCount()); } } } SHOW OUTPUT Output main acquired the lock. Hold count: 1 main acquired the lock. Hold count: 2 main acquired the lock. Hold count: 3 main acquired the lock. Hold count: 4 main released the lock. Hold count: 3 main released the lock. Hold count: 2 main released the lock. Hold count: 1 main released the lock. Hold count: 0 Deadlock A deadlock is a situation where two or more threads are permanently blcoked, each waiting for a resource held by another, preventing further progress. For a deadlock to occur, four conditions must be met simultaneously: mutual exclusion, hold and wait, no preemption, and circular wait.\nMutual Exclusion: A resource must be non-sharable, meaning only one thread can use it at a time. Hold and Wait: A thread holding at least one resource must be waiting to acquire additional resources held by other threads. No Preemption: Resources cannot be forcibly taken from a thread; they must be released voluntarily. Circular Wait: A circular chain of two or more threads must exist, where each thread is waiting for a resource held by the next in the chain. To detect a deadlock in Java, use the jps command to get the process ID, then run jstack process_id to analyze thread states and identify deadlocks.\nSHOW CODE Deadlock Detecting a Deadlock public class Main { private static final Object lock1 = new Object(); private static final Object lock2 = new Object(); public static void main(String[] args) { Thread thread1 = new Thread(() -\u003e { synchronized (lock1) { System.out.println(\"Thread 1: Holding lock 1...\"); try { Thread.sleep(100); // Simulate work } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"Thread 1: Waiting for lock 2...\"); synchronized (lock2) { System.out.println(\"Thread 1: Acquired lock 2!\"); } } }); Thread thread2 = new Thread(() -\u003e { synchronized (lock2) { System.out.println(\"Thread 2: Holding lock 2...\"); try { Thread.sleep(100); // Simulate work } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"Thread 2: Waiting for lock 1...\"); synchronized (lock1) { System.out.println(\"Thread 2: Acquired lock 1!\"); } } }); thread1.start(); thread2.start(); } } $ jps 76995 Launcher 76996 Main 77127 Jps 2327 Main -------------- $ jstack 76996 \"Thread-0\": at dev.signalyu.warmup.Main.lambda$main$0(Main.java:18) 🌟 - waiting to lock \u003c0x000000070ffce280\u003e (a java.lang.Object) 🌟 - locked \u003c0x000000070ffce270\u003e (a java.lang.Object) at dev.signalyu.warmup.Main$$Lambda$14/0x000000012d001208.run(Unknown Source) at java.lang.Thread.run(java.base@17.0.9/Thread.java:842) \"Thread-1\": at dev.signalyu.warmup.Main.lambda$main$1(Main.java:33) 🌟 - waiting to lock \u003c0x000000070ffce270\u003e (a java.lang.Object) 🌟 - locked \u003c0x000000070ffce280\u003e (a java.lang.Object) at dev.signalyu.warmup.Main$$Lambda$15/0x000000012d001428.run(Unknown Source) at java.lang.Thread.run(java.base@17.0.9/Thread.java:842) Found 1 deadlock. 🌟 Thread Interruption In Java, thread interruption is a mechanism that allows one thread to signal another to stop its execution. The three common approaches to interrupt a thread are using a volatile flag, an AtomicBoolean, or the interrupt() method.\nSHOW CODE volatile AtomicBoolean interrupt() import java.util.concurrent.TimeUnit; public class Main { private static volatile boolean isStop = false; public static void main(String[] args) { new Thread(() -\u003e { while (!isStop) { try { TimeUnit.MILLISECONDS.sleep(500); System.out.println(\"isStop: \" + isStop); } catch (InterruptedException e) { throw new RuntimeException(e); } } System.out.println(\"isStop --\u003e \" + isStop); }, \"t1\").start(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } // Signal threads to stop new Thread(() -\u003e { isStop = true; }, \"t2\").start(); } } import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicBoolean; public class Main { private static final AtomicBoolean atomicBoolean = new AtomicBoolean(false); public static void main(String[] args) { new Thread(() -\u003e { while (!atomicBoolean.get()) { try { TimeUnit.MILLISECONDS.sleep(500); } catch (InterruptedException e) { throw new RuntimeException(e); } System.out.println(\"Atomic Boolean: \" + atomicBoolean); } System.out.println(\"Atomic Boolean --\u003e \" + atomicBoolean); }, \"t1\").start(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } // Signal threads to stop new Thread(() -\u003e { atomicBoolean.set(true); }, \"t2\").start(); } } public class Main { private static volatile boolean isStop = false; public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { while (!Thread.currentThread().isInterrupted()) { System.out.println(\"Is interrupted: \" + Thread.currentThread().isInterrupted()); } System.out.println(\"Is interrupted --\u003e \" + Thread.currentThread().isInterrupted()); }, \"t1\"); t1.start(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } // Signal threads to stop new Thread(() -\u003e { t1.interrupt(); }, \"t2\").start(); } } SHOW OUTPUT volatile AtomicBoolean interrupt() isStop: false isStop: true isStop --\u003e true Atomic Boolean: false Atomic Boolean: true Atomic Boolean --\u003e true ...... Is interrupted: false Is interrupted: false Is interrupted: false Is interrupted --\u003e true The common methods for managing thread interruption in Java include interrupt(), interrupted(), and isInterrupted():\ninterrupt(): An instance method that sets the thread\u0026rsquo;s interrupted status to true. It does not forcibly stop the thread. If the thread is blocked (e.g., in sleep(), wait(), or join()), it throws an InterruptedException. interrupted(): A static method that checks if the current thread has been interrupted. If it has, the method resets the interrupted status to false. isInterrupted(): An instance method that checks if the thread has been interrupted without resetting its interrupted status. What\u0026rsquo;s the following code output?\nSHOW CODE (Wrong Interruption) Java import java.util.concurrent.TimeUnit; public class Main { public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { while (true) { if (Thread.currentThread().isInterrupted()) { System.out.println(\"isInterrupted --\u003e true\"); break; } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"INTERRUPTED...\"); } }, \"t1\"); t1.start(); try { TimeUnit.SECONDS.sleep(3); // Sleep 3 seconds } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -\u003e { t1.interrupt(); // Set interrupted status of thread 't1' to true }, \"t2\").start(); } } SHOW OUTPUT (Wrong Interruption) Output INTERRUPTED... INTERRUPTED... java.lang.InterruptedException: sleep interrupted at java.base/java.lang.Thread.sleep(Native Method) at dev.signalyu.warmup.Main.lambda$main$0(Main.java:14) at java.base/java.lang.Thread.run(Thread.java:842) INTERRUPTED... INTERRUPTED... ...... When a thread is interrupted while blocked, the blocking method throws an InterruptedException and clears the interrupted status.\nSHOW CODE (Correct Interruption) Java import java.util.concurrent.TimeUnit; public class Main { public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { while (true) { if (Thread.currentThread().isInterrupted()) { System.out.println(\"isInterrupted --\u003e true\"); break; } try { Thread.sleep(1000); } catch (InterruptedException e) { Thread.currentThread().interrupt(); // 🌟🌟🌟 Restore its interrupted status 🌟🌟🌟 e.printStackTrace(); } System.out.println(\"INTERRUPTED...\"); } }, \"t1\"); t1.start(); try { TimeUnit.SECONDS.sleep(3); // Sleep 3 seconds } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -\u003e { t1.interrupt(); // Set interrupted status of thread 't1' to true }, \"t2\").start(); } } SHOW OUTPUT (Correct Interruption) Output INTERRUPTED... INTERRUPTED... java.lang.InterruptedException: sleep interrupted at java.base/java.lang.Thread.sleep(Native Method) at dev.signalyu.warmup.Main.lambda$main$0(Main.java:14) at java.base/java.lang.Thread.run(Thread.java:842) INTERRUPTED... isInterrupted --\u003e true After restoring the thread\u0026rsquo;s interrupted status by adding Thread.currentThread().interrupt();, it exits the while loop gracefully.\nLockSupport wait()/nofity() related problems There are two common issues when using wait() and notify() in Java:\nSynchronization Requirement: Both wait() and notify() must be called within a synchronized block or method. This is because these methods rely on the object\u0026rsquo;s intrinsic lock (monitor). If they are called outside a synchronized context, the program will throw an IllegalMonitorStateException. Missed Notifications: If notify() is called before wait(), the notification will be missed, and the thread calling wait() may block indefinitely. This happens because notify() does not have any effect if no thread is currently waiting on the object\u0026rsquo;s monitor. SHOW CODE Synchronization Requirement Missed Notifications public class Main { private static final Object lock = new Object(); public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { // synchronized (lock) { try { System.out.println(\"Thread 1 is waiting...\"); lock.wait(); // Thread 1 waits } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"Thread 1 is resumed.\"); // } }); Thread t2 = new Thread(() -\u003e { // synchronized (lock) { System.out.println(\"Thread 2 is notifying...\"); lock.notify(); // Thread 2 notifies // } }); t1.start(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } t2.start(); } } public class Main { private static final Object lock = new Object(); public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } // Acquire the lock after 1 second, notify() executes first synchronized (lock) { try { System.out.println(\"Thread 1 is waiting...\"); lock.wait(); // Thread 1 waits } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"Thread 1 is resumed.\"); } }); Thread t2 = new Thread(() -\u003e { synchronized (lock) { System.out.println(\"Thread 2 is notifying...\"); lock.notify(); // Thread 2 notifies } }); t1.start(); t2.start(); } } SHOW OUTPUT Synchronization Requirement Missed Notifications Thread 1 is waiting... Exception in thread \"Thread-0\" java.lang.IllegalMonitorStateException: current thread is not owner at java.base/java.lang.Object.wait(Native Method) at java.base/java.lang.Object.wait(Object.java:338) at dev.signalyu.warmup.Main.lambda$main$0(Main.java:11) at java.base/java.lang.Thread.run(Thread.java:842) Thread 2 is notifying... Exception in thread \"Thread-1\" java.lang.IllegalMonitorStateException: current thread is not owner at java.base/java.lang.Object.notify(Native Method) at dev.signalyu.warmup.Main.lambda$main$1(Main.java:22) at java.base/java.lang.Thread.run(Thread.java:842) Thread 2 is notifying... Thread 1 is waiting... // WAIT INDEFINITELY await()/signal() related problems Similar to wait()/notify(), when using await()/signal() from the Condition interface, the thread must hold the associated lock. If the lock is not held, the program will throw an IllegalMonitorStateException. Additionally, if signal() is called before await(), the notification will be missed, and the thread calling await() may wait indefinitely. To avoid this, always use a loop to recheck the condition after waking up from await(). This ensures that thread only proceeds when the condition is truly met, even if a spurious wakeup occurs or notification is missed.\nSHOW CODE Synchronization Requirement Missed Notifications import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.ReentrantLock; public class Main { private static final ReentrantLock lock = new ReentrantLock(); private static final Condition condition = lock.newCondition(); public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { // lock.lock(); try { System.out.println(\"Thread 1 is waiting...\"); condition.await(); // Thread 1 waits System.out.println(\"Thread 1 is resumed.\"); } catch (InterruptedException e) { e.printStackTrace(); } finally { // lock.unlock(); } }); Thread t2 = new Thread(() -\u003e { // lock.lock(); try { System.out.println(\"Thread 2 is signaling...\"); condition.signal(); // Thread 2 signals } finally { // lock.unlock(); } }); t1.start(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } t2.start(); } } import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.ReentrantLock; public class Main { private static final ReentrantLock lock = new ReentrantLock(); private static final Condition condition = lock.newCondition(); public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } // Acquire the lock after 1 second, signal() executes first lock.lock(); try { System.out.println(\"Thread 1 is waiting...\"); condition.await(); // Thread 1 waits System.out.println(\"Thread 1 is resumed.\"); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } }); Thread t2 = new Thread(() -\u003e { lock.lock(); try { System.out.println(\"Thread 2 is signaling...\"); condition.signal(); // Thread 2 signals } finally { lock.unlock(); } }); t1.start(); t2.start(); } } SHOW OUTPUT Synchronization Requirement Missed Notifications Thread 1 is waiting... Exception in thread \"Thread-0\" java.lang.IllegalMonitorStateException at java.base/java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.enableWait(AbstractQueuedSynchronizer.java:1516) at java.base/java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1611) at dev.signalyu.warmup.Main.lambda$main$0(Main.java:15) at java.base/java.lang.Thread.run(Thread.java:842) Thread 2 is signaling... Exception in thread \"Thread-1\" java.lang.IllegalMonitorStateException at java.base/java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.signal(AbstractQueuedSynchronizer.java:1473) at dev.signalyu.warmup.Main.lambda$main$1(Main.java:28) at java.base/java.lang.Thread.run(Thread.java:842) Thread 2 is signaling... Thread 1 is waiting... // WAIT INDEFINITELY LockSupport: park()/unpark(Thread) LockSupport is a utility class in Java that provides a low-level mechanism for thread synchronization. Unlike synchronized blocks or explicit Lock objects, LockSupport does not require explicit locking and unblocking. Instead, it operates using a permit mechanism, which makes it more flexible and lightweight. The most commonly used methods in LockSupport are park() and unpark(Thread). The park() method blocks the current thread if the permit is unavailable, while the unpark(Thread) method makes the permit available for a specific thread, unblocking if it was parked.\nThe key points about LockSupport include:\nThe permit is a binary semaphore, meaning it can either be available or unavailable. If a permit is available when park() is called, the thread continues execution without blocking. If no permit is available, the thread blocks until one is made available via unpark(). Unlike synchronized and Lock, LockSupport does not suffer from spurious wakeups. This means that a thread will only unblock when explicitly unparked, providing more predictable behavior compared to wait()/notify() or await()/signal(). The unpark(Thread) method targets a specific thread, making it more precise than notify() or signal(), which wake up any waiting thread. SHOW CODE park()/unpark(Thread) wait()/notify() await()/signal() import java.util.concurrent.locks.LockSupport; public class Main { public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { System.out.println(\"Thread 1 is parking...\"); LockSupport.park(); // Thread 1 parks System.out.println(\"Thread 1 is unparked.\"); }); Thread t2 = new Thread(() -\u003e { System.out.println(\"Thread 2 is unparking Thread 1...\"); LockSupport.unpark(t1); // Thread 2 unparks Thread 1 }); t1.start(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } t2.start(); } } public class Main { private static final Object lock = new Object(); public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { synchronized (lock) { try { System.out.println(\"Thread 1 is waiting...\"); lock.wait(); // Thread 1 waits } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"Thread 1 is resumed.\"); } }); Thread t2 = new Thread(() -\u003e { synchronized (lock) { System.out.println(\"Thread 2 is notifying...\"); lock.notify(); // Thread 2 notifies } }); t1.start(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } t2.start(); } } import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.ReentrantLock; public class Main { private static final ReentrantLock lock = new ReentrantLock(); private static final Condition condition = lock.newCondition(); public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { lock.lock(); try { System.out.println(\"Thread 1 is waiting...\"); condition.await(); // Thread 1 waits System.out.println(\"Thread 1 is resumed.\"); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } }); Thread t2 = new Thread(() -\u003e { lock.lock(); try { System.out.println(\"Thread 2 is signaling...\"); condition.signal(); // Thread 2 signals } finally { lock.unlock(); } }); t1.start(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } t2.start(); } } SHOW OUTPUT park()/unpark(Thread) wait()/notify() await()/signal() Thread 1 is parking... Thread 2 is unparking Thread 1... Thread 1 is unparked. Thread 1 is waiting... Thread 2 is notifying... Thread 1 is resumed. Thread 1 is waiting... Thread 2 is signaling... Thread 1 is resumed. Java Memory Model The Java Memory Model (JMM) is a specification that governs how threads interact with memory in a multi-threaded environment. It establishes rules that determine how and when change made by one thread to shared variables become visible to other threads, ensuring consistency and predictability in concurrent execution.\nJMM classifies memory into two types: Main Memory and Working Memory. Main Memory is the central storage where all variables, including instance fields, static fields, and array elements, reside. Working Memory, on the other hand, is a thread\u0026rsquo;s local memory that holds copies of variables it accesses. Threads do not interact with main memory directly; instead, they load variables into their working memory and write back updates when necessary. A fundamental concept in JMM is the happens-before relationship, which defines the order of operations between threads to maintain memory consistency. If one action happens-before another, the effects of the first action are guaranteed to be visible to the second. Examples include:\nA write to a volatile variable happens-before every subsequent read of that variable. Unlocking a monitor happens-before the next lock on the same monitor. The key characteristics of JMM include Atomicity, Visibility, and Ordering.\nAtomicity: Certain operations, such as reads and writes to volatile variables, are atomic, meaning they execute as indivisible units. Visibility: Changes made by one thread to shared variables are guaranteed to be seen by other threads under proper synchronization mechanisms. Ordering: JMM defines strict rules for instruction ordering, but without synchronization, the JVM may reorder instructions for optimization, potentially causing unpredictable behavior in a multi-threaded environment. happens-before The happens-before relationship in the Java Memory Model (JMM) establishes rules that dictate the ordering and visibility of actions in multithreaded programs. It ensures that certain operations performed in one thread become predictably visible to another, preventing issues like instruction reordering and inconsistent data access. Below are the eight key priciples of the happens-before relationship:\nProgram Order Rule: Within a single thread, actions occur in program order. For example, earlier statements happen-before later ones. int a = 10; // Happens-before int b = a + 5; // This sees the updated value of `a` Monitor Lock Rule: An unlock (unlock()) on a monitor lock happens-before any subsequent lock (lock()) on the same monitor. synchronized (lock) { sharedVar = 10; // Happens-before the next lock } synchronized (lock) { System.out.println(sharedVar); // Guaranteed to see updated value } Volatile Variable Rule: A write to a volatile variable happens-before any subsequent read of that same variable. private volatile boolean flag = false; flag = true; // Happens-before the next read System.out.println(flag); // Guaranteed to see true Thread Start Rule: A call to Thread.start() on a new thread happens-before any actions in that thread. Thread t = new Thread(() -\u0026gt; System.out.println(\u0026#34;Running\u0026#34;)); t.start(); // Happens-before the thread executes the print statement Thread Termination Rule: All actions in a thread happen-before other threads detecting its termination. In other words, after a thread terminates, all its actions are visible to the thread that joins it. Thread t = new Thread(() -\u0026gt; counter = 100); t.start(); t.join(); // Ensures all writes in t happen-before main thread continues System.out.println(counter); // Guaranteed to see 100 A call to Thread.interrupt() happens-before the interrupted thread detects the interruption via isInterrupted() or InterruptedException. Thread t = new Thread(() -\u0026gt; { while (!Thread.currentThread().isInterrupted()) { // Looping until interrupted } }); t.start(); t.interrupt(); // Happens-before the thread detects the interruption Final Field Rule: Writes to final fields in a constructor happen-before the object is seen by any other thread. class Example { final int x; Example() { x = 42; // Happens-before any other thread sees this object } } If action A happens-before action B, and action B happens-before action C, then action A happens-before action C. volatile int a = 0; a = 1; // A happens-before B (write to volatile) int b = a; // B happens-before C (read from volatile) volatile ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/multithreading-and-concurrency/1-multithreading-and-concurrency/","summary":"Introduction to Multithreading Program, Process, and Thread A program is a static set of instructions that stores on a disk. A process is an instance of a program that is currently being executed by the operating system. A thread is a small unit of process that can be scheduled and executed by the operating system. In simpler terms, a program is the code, a process is the excution of the code, a thread is a unit of execution within a process.","title":"Multithreading \u0026 Concurrency"},{"content":"Introduction to System Design SHOW CONTENTS System Design is the process of defining the architecture, components, modules, interfaces, and data for a system to fulfill specific business requirements, while ensuring scalability, maintainability, and performance.\nLoad Balancing SHOW CONTENTS In System Design, Load Balancing refers to the practice of distributing incoming network traffic or workload across multiple servers or resources to optimize resource use and ensure high availability.\nTo fullly leverage scalability and redundency, load balancing can occur at different layers: between user and the web server, between web server and an internal platform serve, between internal platform server and database as illustrated in the following image:\nThe typical process of load balancing involves the following steps:\nThe load balancer recerves a request from the client. The load balancer evaluates the request and routes it to a server based on the chosen load balancing algorithm. The selected server or resource processes the request and sends the response back to the load balancer. The load balancer receives the response and forwards it to the client. Load Balancing Algorithms SHOW CONTENTS A load balancing algorithm is a method used by a load balancer to determine how an incoming request should be distributed across multiple servers. Commonly used load balancing algorithms include Round Robin, Least Connections, Weight Round Robin, Weighted Least Connections, IP Hash, Least Response Time, Random, and Least Bandwidth.\nRound Robin SHOW CONTENTS The Round Robin algorithm distributes requests evenly across multiple servers in a circular manner. This algorithm does not consider the current load or capabilities of each server. It is commonly used in environments where servers have similar capacity and performance, or in applications where each request can be handled independently.\nLeast Connections SHOW CONTENTS The Least Connections algorithm distributes requests to servers with the fewest active connections. It takes into account the server\u0026rsquo;s current workload, helping to prevent any single server from becoming overwhelmed. This algorithm is particularly useful in scenerios where traffic or workload is unpredictable, servers have varying capabilities, or maintaining session state is important.\nWeighted Round Robin SHOW CONTENTS The Weighted Round Robin algorithm is an enhanced version of Round Robin, where each server is assigned a weight based on its capability and workload. Servers with higher weights process more requests, helping to prevent overloading less powerful servers. This algorithm is ideal for scenarios where servers have varying processing abilities, such as in a database cluster, where nodes with higher processing power can handle more queries.\nWeighted Least Connections SHOW CONTENTS The Weighted Least Connections algorithm is a combination of the Least Connections and the Weighted Round Robin algorithms. It takes into account the number of active connections of each server and the weight assigned to a server based on its capability. Requests are routed to servers based on the load factor, which is commonly calculated using the formular: the number of active connections of a server divided by its weight.\n$$ \\text{Load Factor} = \\frac{\\text{Number of Active Connections}}{\\text{Weight of the Server}} $$\nIP Hash SHOW CONTENTS The IP Hash algorithm routes requests to servers based on a hash of the client\u0026rsquo;s IP address. The load balancer applies a hash function to the client\u0026rsquo;s IP address to calculate the hash value, which is then used to determined which server will handle the current request. If the distribution of client IP addresses is uneven, some servers may receive more requests than others, leading to an imbalanced load. This algorithm is ideal for scenarios where maintaining state is important, such as online shopping carts or user sessions.\nLeast Response Time SHOW CONTENTS The Least Response Time algorithm routes incoming requests to the server with the lowest response time, ensuring efficient resource utilization and optimal client experience. It is ideal for scenerios where low latancy and fast response times are crucial, such as online gaming and financial trading.\nRandom SHOW CONTENTS The Random load balancing algorithm routes incoming requests to servers randomly. It is commonly used in scenarios where the load is relatively uniform and the servers have similar capabilities.\nLeast Bandwidth SHOW CONTENTS The Least Bandwidth algorithm routes incoming requests to the server that is consuming the least amount of bandwidth. It is ideal for applications with high bandwidth usage, such as vedio streaming, file downloads, and large file transfers.\nRedundent Load Balancers SHOW CONTENTS The Single Point of Failure (SPOF) refers to any component in a system or infrastructure that, if it fails, causes the entire system or a significant portion of it to become unavailable. For instance, if a load balancer is responsible for routing all incoming requests to servers, its faulure would result in the entire system or application becoming inoperable. To mitigate this risk, redundent load balancers can be deployed.\nFor example, in an active-passive setup, two load balancers are used, where both are capable of routing traffic and detecting failures. The active load balancer handles all incoming requests, and if it fails, the passive load balancer takes over to ditribute requests, ensuring continuous availability. This approach helps prevent the system from being dependent on a single point of failure, as illustrated in the following diagram.\nAPI Gateway SHOW CONTENTS An API Gateway is a server-side component that acts as a central entry point for clients to access as a collection of microservices. It receives client requests, forwards them to the appropriate microservice, and then returns the response from the server to the client. The API Gateway is responsible for various tasks, such as request routing, authentication, rate limiting.\nThe key difference between an API Gateway and a load balancer lies in their core functions. An API Gateway focuses on routing requests to specific microservices. In contrast, a Load Balancer is responsible for distributing incoming traffic across multiple backend servers. Additionally, while an API Gateway typically deals with requests that target specific APIs identified by unique URLs, a load balancer generally handles requests directed to a single, well-known IP address, distributing those requests to one of serveral backend servers based on load-balancing algorithms.\nKey Characteristics of Distributed System Scalability SHOW CONTENTS Scalability refers to a system\u0026rsquo;s ability to handle increasing workloads. In system design, there are two primary types of scaling: horizontal and vertical. Horizontal scaling involves adding more machines to distribute the load across multiple servers, while vertical scaling typically involves upgrading the hardware of a single machine.\nAvailability SHOW CONTENTS In system design, availability refers to the ability of a system to remain operational even in the face of faulures or high demand. Factors that affect availability include redundency, failover mechanisms, and load balancing. Redundency involves duplicating critical components to ensure that if one fails, another can take over. Failover mechanisms refer to the ability to quickly switch to a backup system during failure. Load balancing distributes requests across multiple servers to prevent any single point from becoming overwhelmed.\nIn distributed systems, there is often a trade-off between availability and consistency. The three common types of consistency models are strong, weak, and eventual consistency. The strong consistency model ensure that all replicas have the same data at all times, which can reduce availability and performance. The weak consistency model allows for temporary inconsistencies between replicas, offering improved availability and performance. The eventual consistency model guarantees that all replicas will eventually converge to the same data, balancing consistency and availability over time.\nMonitoring SHOW CONTENTS Monitoring in distributed systems is crucial for identifying issues and ensuring the overall health of the system. It typically involves four key components: metrics collection, distributed tracing, logging, and anomaly detection.\nMetrics collection involves gathering and analyzing key performance indicators such as latency, throughput, error rates, and resource utilization. This helps identify performance bottlenecks, potential issues, and areas for optimization. Common tools for metrics collection inculde Prometheus, Graphite, and InfluxDB.\nDistributed tracing is a technique for tracking and analyzing requests as they pass through various services, helping identify issues within specific services. Common tools for distributed tracing include Zipkin.\nLogging refers to the collection, centralization, and analysis of logs from all services in a distributed system. It provides valuable insights into system behavior, aiding in debugging and troubleshooting. Tools like the ELK Stack (Elasticsearch, Logstash, Kibana) are used for logging.\nAnomaly detection involves monitoring for unusual behaviors or patterns and notifying the appropriate team when such events occur. Tools like Grafana can be used for anomaly detection in distributed systems.\nCaching Introduction to Caching SHOW CONTENTS In system design, caching is a high-speed storage layer positioned between the application and the original data source, such as a database or a remote web service. The primary goal of caching is to minimize access to the original data source, thereby improving application performance. Caching can be implemented in various forms, including in-memory caching, disk caching, database caching, and CDN caching:\nIn-memory caching stores data directly in the computer\u0026rsquo;s memory, offering faster access than disk storage. Disk caching stores data on disk, which is slower than memory but faster than fetching data from an external source. Database caching stores data within the database itself, reducing the need to access external storage systems. CDN caching stores data on a distributed network of servers, minimizing latency when accessing data from remote locations. Here are some key caching terms:\nCache Hit: Occurs when the requested data is found in the cache. Cache Miss: Happens when the requested data is not found in the cache, requiring a fetch from the original data source. Cache Eviction: The process of removing data from the cache, often to make room for new data based on a predefined cache eviction policy. Cache Staleness: Refers to the situation where the cached data is outdated compared to the original data source. Here are some of the most common types of caching:\nCaching Replacement Policies SHOW CONTENTS When caching data becomes outdated, it should be removed. Therefore, specifying a cache replacement policy is crucial when implementing caching. Common cache replacement policies include: LRU (Least Recently Used), LFU (Least Frequently Used), FIFO (First In, First Out), and Random Replacement.\nLRU (Least Recently Used) removes the least recently accessed data when the cache becomes full. It ensures that data that have been accessed more recently are more likely to be accessed again in the future. LFU (Least Frequently Used) removes the least frequently accessed data when the cache is full. It ensures that data that have been accessed more frequently are more likely to be accessed again in the futrue. FIFO (First In, First Out) removes the oldest data when the cache becomes full. It assumes that the oldest data are least likely to be accessed in the future. Random Replacement removes random data when the cache is full. This policy can be useful when the data access pattern is unpredictable. Cache Invalidation SHOW CONTENTS Cache Invalidation is the process of marking data in the cache as stale or directly removing it from the cache, ensuring that the cache doesn\u0026rsquo;t serve outdated or incorrect data. Common cache invalidation schemes include write-through cache, write-around cache, write-back cache, and write-behind cache.\nWrite-Through Cache: In a write-through scheme, data is written to both the cache and the data store simultaneously. This ensures that the cached always serves the most up-to-date data, but it introduces latency, as each write operation must be performed twice before the data is returned. Write-Around Cache: In a write-around scheme, data is directly written to the underlying data store, bypassing the cache. This prevents the cache from becoming flooded with less frequently accessed data, while ensuring that the data store always holds the most recent data. However, this can result in a cache miss when requesting data that was recently written. Write-Back Cache: In a write-back scheme, data is written only to the cache, and the write operation is immediately confirmed. The data is written to the data store only when the cached data is evicted. This ensures low latency and high throughput but may lead to data loss in the event of a crash, as the data is stored only in the cache. Write-Behind Cache: Similar to the write-back scheme, the write-behind cache writes data to the underlying store after a specified delay. The key difference is that in a write-back cache, data is only written to the data store when necessary (e.g., upon eviction). In contrast, in a write-behind cache, data is written to the data store at regular intervals. Here are some of the most commonly used cache invalidation methods:\nPurge: The purge method removes cached data immediately. When a purge request is received, the cached data is deleted, and the next time the key is requested, the cache fetches a fresh copy from the original data store, stores it, and returns it. Refresh: The refresh method updates the cached data with the latest data from the original data store. This ensures the cache always holds the most up-to-date data. Ban: The ban method blocks access to certain cached data. When a ban command is issued, the key is added to a ban list. From then on, every request is checked against the ban list. If the requested resource matches an invalidation rule, the cache treats it as stale, fetches a fresh copy from the original data store, and updates the cache. Unlike purge, which removes the cache entry immediately, ban simply marks the entry as stale, and the data remains in the cache until it is evicted. Time To Live (TTL) Expiration: This method involves setting a time-to-live (TTL) value for cached data. Once the TTL expires, the data is considered stale. When a request is made, the cache checks the TTL of the cached data and serves it only if if hasn\u0026rsquo;t expired. If expired, the cache fetches the fresh copy from the original data store and returns it. Stale-While-Revalidate: This method serves the cached data to the client immediately when a request is received. Meanwhile, the cache asynchronously updates itself with the latest version of the data from the original data store. This approach ensures a qucik response, even if the cached data is slightly outdated, and is commonly used in CDN caching. Cache Read Strategies SHOW CONTENTS Cache read strategies define how the cache behaves when a cache miss occurs. The most common cache read strategies are read-through and read-aside.\nIn a read-through cache strategy, the cache is responsible for fetching fresh data from the original data store when a cache miss occurs. If the requested data is not found in the cache, the cache automatically retrives the data from the data store, stores it in the cache, and returns it to the client. In a read-aside cache strategy, the application first requests the data from the cache. If the data is found, the cached data is used. However, if the data is not found, the application fetches the data from the underlying data store, updates the cache with the retrived data, and then uses it. Cache Coherence and Cache Consistence SHOW CONTENTS Cache coherence refers to the consistency of data stored in multiple caches that are part of the same system, particularly in multi-core systems. In a distributed system, each cache may store a local copy of shared data. When one cache modifies its copy, all other caches holding a copy of that data must be updated or invalidated to maintain consistency. The most common protocols for achieving cache coherence are write-invalidate and write-update.\nWrite-Invalidate: When a cache writes to its copy of shared data, it broadcasts a message to all other caches, invalidating their copies. When another cache needs the updated data, it fetches the new data from memory or from the cache that made the update. Write-Update: When a cache writes to its copy of shared data, it broadcasts a message to all other caches, prompting them to update their local copies accordingly. Cache consistency focuses on maintaining the consistency of data between the cache and the original data source. Cache consistency models define the rules governing how data is updated and accessed in a distributed system with multiple caches. These models vary in terms of their strictness, and include strict consistency, sequential consistency, casual consistency, and eventual consistency.\nStrict Consistency: In a strict consistency model, any write to a data item is immediately visible to all caches. While this ensures data is always up-to-date, it may lead to performance issues due to the significant synchronization overhead required. Sequential Consistency: In a sequential consistency model, all operations on data items must appear in a specific, sequential order across all caches. This model ensures a predictable order of operations but may not guarantee the exact real-time visibility of changes. Casual Consistency: In a casual consistency model, operations that are casually related (e.g., one operation depends on the outcome of another) are guaranteed to appear in order across multiple caches. Operations that are not casually related can occur in any order. This model strikes a balance between on consistency and performance. Eventual Consistency: In an eventual consistency model, updates to a data item will eventually propagate to all caches, but there is no guarantee regarding the order or timing of these updates. This model offers the best performance but the weakest consistency guarantees, making it ideal for distributed systems where performance and scalability are prioritized over strict consistency. Caching Challenges SHOW CONTENTS The main cache-related issues include Thundering Herd, Cache Penetration, Cache Stampede, and Cache Pollution.\nThundering Herd: This problem arises when a popular piece of data expires, leading to a sundden surge of requests to the original server, resulting in performance degradation. Solutions include staggered expiration times, cache locking, or background updates before expiration.\nCache Penetration: This occurs when multiple requests for non-existent data bypass the cache, querying the original data store directly. Solutions include negative caching (caching \u0026ldquo;not found\u0026rdquo; responses) or using a Bloom Filter to check the existence of data before querying the cache.\nCache Stampede: This happens when multiple requests for the same data arrive after cache expires, causing a heavy load on the original data source. Solutions typically involve request coalescing (letting on request fetch the data while others wait) or implementing a read-through cache, where the cache itself fetches missing data. Cache Pollution: This occurs when less frequently accessed data displaces more frequently accessed data, reducing cache hit rates. To mitigate cache pollution, eviction policies such as LRU (Least Recently Used) or LFU (Least Frequently Used) can be implemented.\nData Partitioning SHOW CONTENTS In system design, data partitioning is a technique used to break large datasets into smaller, more manageable units called partitions. Each partition is independent and contains a subset of the overall data. Common data partitioning methods include horizontal partitioning and vertical partitioning.\nHorizontal partitioning, also known as sharding, involves dividing a database into multiple shards, with each shard containing a subset of rows. These shards are typically stored on different database servers, allowing for parallel processing and improving query execution times. Vertical partitioning divides a database into multiple partitions based on columns, with each partition containing a subset of the columns. This technique is commonly used when some fields are accessed more frequently than others, optimizing performance for specific queries. Data sharding splits table horizontally, here are some common sharding techniques.\nRange-Based Sharding: Data is divided based on a specific range, such as numeric ranges or dates. For example, an e-commerce platform may partition the order table by order date. Hash-Based Sharding: Data is partitioned by applying a hash function to a partition key. The hash value determines which shard will store the data. Directory-Based Sharding: Data is partitioned based on a lookup table that tracks which shard contains which data. Geographical Sharding: Data is divided based on geographical locations, such as countries or regions. Hybrid-Based Sharding: A combination of multiple sharding strategies to optimize system performance. Proxy SHOW CONTENTS A proxy is an intermediary server or software that sits between the client and the internet, typically used for tasks like filtering, caching, or security checks. Proxies can consolidate multiple client requests into a single request, a process known as collapsed forwarding. For instance, if multiple clients request the same resource, the proxy can cache the resource and serve it to those clients without having to forward the request to the origin server each time. There are two main types of proxies: forward proxy and reverse proxy.\nA forward proxy acts on behalf of the client, hiding its identity by forwarding requests from the client to the server. It is often used to mask the client’s IP address, bypass geo-restrictions, or cache content for faster access.\nA reverse proxy, on the other hand, acts on behalf of the server, intercepting incoming requests from clients and directing them to the appropriate backend server. This type of proxy is commonly used for load balancing, caching, and enhancing security by hiding the backend server details from clients.\nReplication SHOW CONTENTS Replication Methods SHOW CONTENTS CAP Theorem SHOW CONTENTS Database Federation SHOW CONTENTS Security SHOW CONTENTS Distributed Messaging System SHOW CONTENTS Distributed File System SHOW CONTENTS Misc Concepts Bloom Filters SHOW CONTENTS Long-Polling, WebSockets, and Server-Sent Events SHOW CONTENTS Quorum SHOW CONTENTS Heartbeat SHOW CONTENTS Leader and Follower SHOW CONTENTS Message Queues vs. Service Bus SHOW CONTENTS Stateful vs. Stateless Architecture SHOW CONTENTS Event-Driven vs. Polling Architecture SHOW CONTENTS ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/system-design/1-system-design/","summary":"Introduction to System Design SHOW CONTENTS System Design is the process of defining the architecture, components, modules, interfaces, and data for a system to fulfill specific business requirements, while ensuring scalability, maintainability, and performance.\nLoad Balancing SHOW CONTENTS In System Design, Load Balancing refers to the practice of distributing incoming network traffic or workload across multiple servers or resources to optimize resource use and ensure high availability.\nTo fullly leverage scalability and redundency, load balancing can occur at different layers: between user and the web server, between web server and an internal platform serve, between internal platform server and database as illustrated in the following image:","title":"System Design"},{"content":"1. Introduction to Linux SHOW CONTENTS Open Source refers to software whose source code is freely available to the public for anyone to view, modify, and distribute. It encourages coolaboration, transparency, and community-driven improvements.\nOpen Source Licenses are legal agreements that define how software can be used, modified, and distributed. There are two main types of Copyleft and Permissive.\nCopyleft licenses require that any modified versions of the software also be open source, under the same terms as the original. Popular examples include the GPL (GNU General Public License) and AGPL (Affero GPL). Permissive licenses are more relaxed, allowing users to modify, distribute, and even close-source the software if desired. Well-known examples of permissive licenses include the MIT License, Apache License 2.0, and BSD License (Berkeley Software Distribution). The differences between Fedora, CentOS Stream, and Red Hat Enterprise Linux (RHEL) are primarily based on their release cycles, stability, and target audiences. Fedora is a cutting-edge distribution that always features the latest software and technologies, making it ideal for developers and enthusiasts who want to experience the newest features. CentOS Stream serves as a rolling preview of future RHEL versions, acting as a middle ground between Fedora and RHEL. Finally, RHEL is the most stable and secure option, designed for enterprise environments that require long-term support and paid services. RHEL is commonly used in production systems that demand reliability and robust commercial support. 2. Manage Files From the Command Line Linux File System Hierarchy SHOW CONTENTS The Linux File System Hierarchy defines the directory structure and directory contents in Linux-based operating systems. It stores all files which organized into a single incerted tree structure.\nHere’s an overview of the key directories in the Linux file system hierarchy:\nLocation Purpose /boot Files to start the boot process. /dev Special device files that the system uses to access hardware. /etc System-specific configuration files. /home Home directory, where regular users store their data and configuration files. /root Home directory for the administrative superuser, root. /run Runtime data for processes that started since the last boot. This data includes process ID files and lock files. The contents of this directory are re-created on reboot. This directory consolidates the /var/run and /var/lock directories from earlier versions of Red Hat Enterprise Linux. /tmp A world-writable space for temporary files. Files that are not accessed, changed, or modified for 10 days are deleted from this directory automatically. The /var/tmp directory is also a temporary directory, in which files that are not accessed, changed, or modified in more than 30 days are deleted automatically. /usr Installed software, shared libraries, including files, and read-only program data. Significant subdirectories include: /usr/bin: User commands; /usr/sbin: System administration commands; /usr/local: Locally customized software /var System-specific variable data that should persist between boots. Files that dynamically change, such as databases, cache directories, log files, printer-spooled documents, and website content, might be found under /var. static, dynamic(variable), persistent, runtime: Static content remains unchanged until explicitly edited or reconfigured; Dynamic (Variable) content might be modified or appended by active processes; Persistent content remains after a reboot, such as configuration settings; Runtime content from a process or from the system is deleted on reboot.\nCommon Directory and File Management Commands SHOW CONTENTS pwd: Prints the current working directory (path) to the terminal. cd: Changes the current working directory to the home directory of the current user. cd -: Changes the directory to the previous directory. cd ../..: Moves up two levels in the directory structure. cd ..: Moves up one level in the directory structure (to the parent directory). ls -l: Lists files and directories in the current directory in long format, showing details such as permissions, owner, group, size, and last modification time. ls -al: Lists all files (including hidden files) in the current directory in long format. ls -lR: Lists files and directories recursively in the current directory and all its subdirectories, in long format. ls -l file*.txt: Lists files that start with the word file and end with .txt. cp hello.py HELLO.py: Copies the file hello.py to HELLO.py. The original file remains unchanged. mv -v hello.py HELLO.py: Moves (or renames) the file hello.py to HELLO.py. The -v option prints verbose output showing the operation. rm HELLO.py: Removes (deletes) the file HELLO.py. Be careful, as this is a permanent deletion. mkdir HOME: Creates a new directory named HOME in the current directory. rmdir HOME: Removes an empty directory named HOME. If the directory contains any files, it cannot be removed with rmdir. Create Links Between Files SHOW CONTENTS In Linux, there are two types of links that can be created for files: hard links and soft links. A hard link is a direct reference to the data of a file. It creates another name for an existing file, pointing directly to the file\u0026rsquo;s inode (the underlying data structure that holds the file\u0026rsquo;s metadata and data.) A soft link, on the other hand, is a reference to the original file\u0026rsquo;s path, rather than directly pointing to the file\u0026rsquo;s inode.\nHard links that reference the same file share the same inode struct with the link count, access permissions, user and group ownership, time stamps, and file content. Therefore, when any of this information is changed for one hard link, the changes are reflected in all other hard links pointing to the same file.\nCommands for creating links between files are as follows:\nln file.txt file_link.txt # Create a hard link ls -i file.txt file_link.txt # Show the inode number for both files ln -s file.txt file_soft.txt # Create a soft link ls -l file_soft.txt # Check if the soft link work (file_soft.txt -\u0026gt; file.txt) 3 Get Help Using man Command SHOW CONTENTS The man command in Linux is used to display the manual pages for various commands, programs, system calls, etc. The man pages are divided into 9 sections: executable programs or shell commands, system calls, library calls, special files, file formats and conventions, games, miscellaneous, system administration commands, and kernel routines (non standard).\nExecutable programs or shell commands: Commands executed by regular users (e.g., ls, cp). System calls: Functions that the kernel provides for programs to interact with the system (e.g., open, read). Library calls: Functions that can be used in programs written in C and other languages (e.g., printf). Special files: Usually found in /dev(e.g., /dev/sda). File formats and conventions: Descriptions of file formats (e.g., /etc/passwd). Games: Information about games available on the system. Miscellaneous: including macro packages and conventions (e.g. man(7), groff(7)). System administration commands: Commands for system administrators (e.g., useradd, systemctl). Kernel routines: Non standard The most common way to use man command including:\nman open or man open.3: Displays the manual page for the open command. (open exists in Section 2 (System Calls) and Section 3 (Library Functions), man open display the System Call documentation while man open.3 display the Library Function manual.) man -f ls: Displays a brief description of the ls command, equivalent to whatis ls. man -k ls: Searches the manual page database for the term ls, equivalent to apropos ls. Note that before running man -f ls or man -k ls, it is important to ensure that the mandb database has been built. This can be done by running sudo mandb.\n4. I/O Redirection \u0026amp; Pipelines I/O Redirection SHOW CONTENTS A process reads input and writes output. By default, it reads input from the keyboard and sends its output to the terminal window. Processes use numbered channels called file descriptors to manage input and output. Every process starts with at least three file descriptors:\nStandard Input (channel 0): Reads input from the keyboard. Standard Output (channel 1): Sends normal output to the terminal. Standard Error (channel 2): Sends error messages to the terminal. Number Channel Name Description Default Connection Usage 0 stdin Standard input Keyboard Read only 1 stdout Standard output Terminal Write only 2 stderr Standard error Terminal Write only 3+ filename Other files None Read/write or both By default, a process takes input from the keyboard and displays its output on the terminal. Redirection refers to changing the default input or output of a command. The following table summarizes the different types of redirection available:\nUsage Explanation Vitulization \u0026gt; file Redirect stdout to overwrite a file \u0026gt;\u0026gt; file Redirect stdout ot append to a file 2\u0026gt; file Redirect stderr to overwrite a file 2\u0026gt; /dev/null Discard stderr error messages by redirecting them to /dev/null \u0026gt; file 2\u0026gt;\u0026amp;1 or \u0026amp;\u0026gt; file Redirect stdout and stderr to overwrite the same file \u0026gt;\u0026gt; file 2\u0026gt;\u0026amp;1 or \u0026amp;\u0026gt;\u0026gt; file Redirect stdout and stderr to append the same file sort \u0026lt; file \u0026gt; sorted_file Redirects the stdin to a file and redirect stdout to overwrite a different file It is important to note that the order of redirection operations is crucial. For example:\nThe command \u0026gt; output.log 2\u0026gt;\u0026amp;1 redirects both standard output and standard error messages to the same file, output.log. On the other hand, 2\u0026gt;\u0026amp;1 \u0026gt; output.log redirects standard error messages to the default standard output (the terminal), and then redirects only the standard output to output.log. Additionally, the command \u0026gt; output.log 2\u0026gt;\u0026amp;1 can be shortened to \u0026amp;\u0026gt; output.log. However, it is important to note that \u0026amp;\u0026gt; is not standardized and may not be implemented in all shells.\nPipelines SHOW CONTENTS A pipeline is a sequence of one or more commands that are connected by the vertical bar character (|). In a pipeline, the standard output of one command is passed directly as the standard input to the next command.\nThe main difference between pipelines and I/O redirection lies in how they handle data. I/O redirection refers to sending standard output to a file or receiving standard input from a file. In contrast, pipelines are used to send the standard output of one process directly to the standard input of another process.\nThe following are some commonly used pipeline examples:\ncat file.txt | grep \u0026quot;pattern\u0026quot;: Searches for patterns within text. cat file.txt | sort: Sorts the lines of text in a specified order (alphabetically by default). cat file.txt | wc -l: Counts the number of lines in a file. cat file.txt | tee output.txt: Outputs the content of a file to both the terminal and a specified file. find / -name \u0026quot;passwd\u0026quot; 2\u0026gt;\u0026amp;1 | less: find / -name \u0026quot;passwd\u0026quot;: Searches for a file or directory named passwd starting from the root directory (/). 2\u0026gt;\u0026amp;1: Redirects standard error (file descriptor 2) to standard output (file descriptor 1). This ensures that any error messages, such as permission denials, are also passed along with the normal output. | less: Pipes the combined output (standard output and error messages) into the less command. 5. Bash Environment Configuration SHOW CONTENTS When Bash starts, several initialization scripts are executed to configure the shell environment, with the specific scripts depending on whether the shell is interactive, non-interactive, login, or non-login. An interactive shell allows users to enter commands directly, while a non-interactive shell runs in the background. A login shell is invoked when a user logs in via terminal or SSH, while non-login shell is opened from an existing session, like when launching a terminal in a GUI.\nFor interactive login shells, the environment is configured by the /etc/profile and ~/.bash_profile files, which also source /etc/bashrc and ~/.bashrc respectively. For interactive non-login shells, only /etc/bashrc and ~/.bashrc are used. System-wide configurations are stored in /etc/profile and /etc/bashrc, while user-specific configurations are in ~/.bash_profile and ~/.bashrc.\n6. Manage Local Users and Groups User \u0026amp; Group Concepts SHOW CONTENTS A user is an individual account created on a Linux system that can own files, execute commands, and interact with the system. User details are typically stored in the /etc/passwd file, where each line represents a user account with specific information like username, UID, home directory, and default shell.\nIn Linux, there are three primary types of users:\nSuperuser: The superuser account is responsible for administering the system. Its name is root with a UID of 0. It has full system access. System User: These accounts are used by processes or daemons that provide system services (e.g., web servers, databases). System users are non-privileged and are created to isolate and secure the services they support. Regular User: The regular user is the typical user who do not have root priviledges and have limited access to the system. A group is a collection of users that can be assigned a common set of permissions. The group details are typically stored in etc/group, which contains information about group names, GIDs, and the list of users that belong to each group.\nIn Linux, there two main types of group: the primary group and the secondary group.\nPrimary Group: The primary group is the default group assigned to a user. It is used as the group ownership for files and directories the user creates. By default, a user’s primary group often shares the same name as the username. Secondary Groups: These are additional groups to which a user can belong. Secondary groups provide users with access to shared resources or enable them to perform tasks that require specific group-level permissions. Gain Superuser Access SHOW CONTENTS In RHEL 9, to switch from a regular user to a superuser (root), the su command is used. To switch back from the root account to a regular user, the command su - user_name can be used, or alternatively, typing exit will return to the previous user account.\nIf a regular user is not in the sudoers file, an error message such as \u0026quot;user_name is not in the sudoers file. This incident will be reported.\u0026quot; will appear when trying to run a command with sudo. To enable full sudo access for a specific user, switch to the root account and then add the line user_name ALL=(ALL) ALL to the /etc/sudoers file. Similarly, to provide users in a specific group full sudo access, the line %group_name ALL=(ALL) ALL should be added.\nIt’s important to use the visudo command to edit the /etc/sudoers file, as it performs syntax checks to avoid errors that could lock out users from using sudo.\nManage Local User Accounts SHOW CONTENTS To create a user, use the useradd command. When executing useradd user_name, it creates the user\u0026rsquo;s home directory, sets up the account information, and generates a private group for the user named user_name. The default configuration for creating a new user is defined in the /etc/login.defs file. Note that at this point, the user account does not have a valid password set, so the user cannot log in until a password is assigned. To set a password for the user, the passwd command should be used. To delete a user, the userdel command is used. The userdel user_name command removes the user_name from the /etc/passwd file but leaves the user\u0026rsquo;s home directory intact. If it is necessary to delete the home directory as well, the userdel -r user_name option should be used. It’s important to note that when deleting a user without the -r option, the files owned by the user will be left with an unassigned UID. If a new account is later assigned to the same UID, that account will inherit the old user\u0026rsquo;s files, which poses a security risk. For this reason, many organizations prefer to lock user accounts instead of deleting them, in accordance with security policies.\nManage Local Group Accounts SHOW CONTENTS The commands for managing local group accounts include groupadd, groupmod, and groupdel.\ngroupadd: This command is used to create a new group. By default, it assigns the next available GID from the range specified by the GID_MIN and GID_MAX variables in the /etc/login.defs file. groupmod: This command is used to modify an existing group, such as changing its group name or GID. groupdel: This command is used to delete an existing group. However, it\u0026rsquo;s important to note that the primary group of an existing user cannot be removed. Here are some commonly used commands for managing local group accounts:\ngroupadd -g group_id group_name: Creates a new group with a specified GID. groupmod -n old_group_name new_group_name: Renames an existing group from old_group_name to new_group_name. groupmod -g group_id group_name: Changes the GID of an existing group (group_name) to a specified group id. usermod -aG group_name user_name: Adds a user (user_name) to an additional group (group_name) without removing the user from their existing groups. The -aG option ensures the user is appended to the group list rather than replacing the existing group memberships. groupdel group_name: Deletes the specified group (group_name). Note that the primary group of any existing users cannot be deleted. Manage User Passwords SHOW CONTENTS In Linux, /etc/passwd and /etc/shadow are critical system files that store user account information and password data, repectively. The /etc/passwd file contains basic information about user accounts on the system, while the /etc/shadow file is used to store encrypted user password information, as well as other related data such as password expiration and account locking details.\nHere is the breakdown of the line from /etc/shadow:\nThe chage command is used to configure password aging parameters for user accounts, allowing administrators to manage password expiration, warning periods, and other related settings (as shown in the following image).\nMin Days (Minimum Days Between Password Changes): The minimum days (default is 0) parameter specifies the minimum number of days that must pass before a user can change their password after setting it for the first time or after a password change. For example, if min days is set to 7, then after changing their password, the user will not be able to change it again until 7 days have passed. Max Days (Maximum Days Between Password Changes): The maximum days (default is 99999) parameter defines the maximum number of days that a user is allowed to use the current password. After this period, the user will be required to change the password. For example, If max days is set to 30, the user must change their password every 30 days. After 30 days, they will be prompted to change it. Warn Days (Warning Period Before Password Expiration): The warn days (default is 7) parameter specifies how many days before the password expires the user will be warned to change their password. The warning is displayed when the user logs in. For example, If warn days is set to 7, the user will receive a warning 7 days before the password expiration. Expiration Date/Inactivity Days: The expiration date (default is None) specifies the date when the user’s account will be locked. If the inactivity days is set to 0, the account will be locked immediately after the expiration date. The inactivity days parameter (default is 7) defines the grace period after a password expires during which the user can still log in. During this period, the user is required to change the expired password using the passwd command before the account is locked. If the password is not changed within this grace period, the account will be locked. For example, if the expiration date is set to 2024-12-01 and the inactivity days is set to 7, the user can continue logging in until 2024-12-08. After 2024-12-08, the user’s account will be locked, and contact with an administrator will be necessary to reactivate the account. Below are some commonly used chage commands:\nchage -E $(date -d \u0026quot;+30 days\u0026quot; +%F) user_name: This command sets the expiration date of a user\u0026rsquo;s account to 30 days from the current date. chage -d 0 user_name: This command forces the user to change their password immediately. There are common scenarios where user access needs to be restricted, such as temporarily blocking a user or disabling access for a former employee. Below are some common methods for restricting user access.\nHere are the descriptions for the mentioned commands:\nusermod -L user_name: This command locks the user account by disabling the password. It works by placing an exclamation mark (!) in front of the password hash in the /etc/shadow file, preventing the user from logging in. usermod -L -e 2024-12-31 user_name: This command locks the user account and also sets an expiration date for the account. usermod -s /sbin/nologin user_name: This command changes the login shell for the user to /sbin/nologin, which prevents the user from logging in interactively. It\u0026rsquo;s important to note that this command does not prevent all types of access. Users may still be able to authenticate and upload or retrieve files through applications like file transfer programs or mail clients, as long as the user knows the password. 7. Control Access to Files File System Permissions Concepts SHOW CONTENTS In Linux, file system permissions control the access and actions that users can perform on files and directories. These permissions help manage security and determine who can read (r), write (w), or execute (x) a file. Permissions are typically displayed in a 10-character string, such as -rwxr-xr--. The 10 characters consist of a file type and three sets of permissions (User, Group, and Others):\nThe first character in the file permission string represents the file type. Common file types include - for regular files, d for directories, l for symbolic links, c for character device files, b for block device files, p for named pipe files, and s for local socket files.\nThe first set represents the user (owner) permissions. The second set represents the group permissions. The third set represents the others (everyone else) permissions. Each set of permissions is made up of three characters, corresponding to read (r), write (w), and execute (x). For example, rwx indicates full permissions (read, write, execute) and r-- stands for read-only permissions.\nManage File System Permissions SHOW CONTENTS The chmod command is used to modify file system permissions for files and directories. The standard syntax is chmod [options] mode file_or_directory_name. The mode can be specified in either symbolic mode (e.g., r, w, x) or numeric mode (e.g., 755, 644). In numeric mode, permissions are represented by a three-digit number, where each digit corresponds to a set of permissions for the user, group, and others. Each permission is assigned a value: 4 for read, 2 for write, and 1 for execute. The sum of these values determines the permissions for each set. Below are some commonly used commands for changing file system permissions:\nchmod 755 file: Grants read, write, and execute permissions to the user, and read and execute permissions to the group and others. chmod 644 file: Grants read and write permissions to the user, and read-only permissions to the group and others. chmod +x file: Adds execute permission for all user categories (user, group, and others). chmod -x file: Removes execute permission for all user categories. chmod u+x file: Adds execute permission for the user (owner) only. chmod g-w file: Removes write permission from the group. chmod o+r file: Grants read permission to others. To change the user or group ownership of a file or directory in Linux, the chown command is used. Only the root user can change the ownership of a file. However, both the file\u0026rsquo;s owner and the root user can modify the file\u0026rsquo;s group ownership. While the root user can assign file ownership to any group, regular users can change the group ownership of a file only if they are members of the target group. Below are some commonly used commands for changing the user or group ownership of a file or directory.\nchown user_name file_name: Changes the owner of a file or directory to the specified user_name. chown user_name:group_name file_name: Changes both the owner and the group of a file or directory. chown :group_name file_name: Changes only the group ownership of the file or directory. chown -R user_name directory_name: Recursively changes the ownership of files and directories within the specified directory. chgrp group_name file_name: Changes only the group ownership of a file or directory to the specified group_name. chgrp -R group_name directory_name: Recursively changes the group ownership of files and directories within the specified directory. Sepcial Permissions \u0026amp; Default Permissions SHOW CONTENTS In Linux, special file permissions provide advanced control over file and directory access. These permissions include setuid, setgid, and the sticky bit.\nsetuid: This permission is represented with s in the user permission set. When set on an executable file, it allows the program to be executed with the privileges of the file owner (usually root) rather than the privileges of the user running the file. For example, the file /usr/bin/passwd is owned by the root user, but it can be executed by a regular user without sudo because it has the setuid permission in the user permission set (-rwsr-xr-x. 1 root root 32648 Aug 10 2021 /usr/bin/passwd). setgid (Group ID): This permission is represented with s in the group permission set. When applied to a file, it causes the program to run with the group privileges of the file\u0026rsquo;s group. For directories, it ensures that files created within the directory will inherit the directory\u0026rsquo;s group rather than the user\u0026rsquo;s group. For example, the file /usr/bin/locate (-rwx--s--x. 1 root slocate 41032 Aug 10 2021 /usr/bin/locate) has the setgid permission in the group permission set, allowing it to run with the group privileges of the file\u0026rsquo;s group. Similarly, the directory /run/log/journal (drwxr-sr-x+ 3 root systemd-journal 60 Apr 15 09:44 /run/log/journal/) has the setgid permission in the group permission set. This ensures that files created within the directory will inherit the systemd-journal group. sticky bit: This permission is represented with t in the others\u0026rsquo; permission set. When applied to a directory, it allows only the file owner to delete or modify their files, preventing other users from tampering with them. For example, the directory /tmp (drwxrwxrwt. 20 root root 4096 Apr 17 08:32 /tmp) has the sticky bit set in the others\u0026rsquo; permission set. This ensures that a user can only modify or delete the files in the /tmp directory that they own. In Linux, when a file or directory is created, its default permission is determined by the combination of the initial permission and the umask (user file creation mask). By default, files are created with initial permissions of 0666 (-rw-rw-rw-), and directories with 0777 (drwxrwxrwx). The umask defines which permission bits should be removed from these initial values, Typically, the default umask is 0022. This value can be modified in /etc/bashrc. For example, if the umask is set to 0022, a newly created file will have permissions 0644 (-rw-r--r--) because 0666 - 0022 = 0644. Similarly, a newly created directory will have permissions 0755 (drwxr-xr-x) because 0777 - 0022 = 0755.\n8. Monitor \u0026amp; Manage Linux Processes Process Life Cycle \u0026amp; States SHOW CONTENTS A process is a running instance of an executable program. Once created, a process includes several key components: an address space for allocated memory, security properties such as ownership and privileges, one or more execution threads for running code, and a process state that reflects its current status.\nThe environment of a process contains important contextual information, including local and global variables, the current scheduling context, and system resources like file descriptors and network ports that are assigned to the process.\nA new process is typically created when an existing parent process duplicates its own address space through a mechanism called a process fork. The resulting child process is assigned a unique Process ID (PID) for identification and security purposes. The child process also records the Parent Process ID (PPID) as part of its environment. On systems like Red Hat, all processes ultimately descend from the first system process, systemd.\nThrough the fork operation, the child process inherits the parent’s security credentials, file descriptors, resource privileges, environment variables, and program code. Once forked, the child process can continue running the same code or replace it with its own program logic using an exec family function.\nTypically, after creating a child process, the parent process enters a waiting state, pausing its own execution until the child finishes. When the child process exits, it releases its resources, but its process table entry remains temporarily as a zombie process. Once the parent receives a termination signal from the child, it performs cleanup by removing the zombie entry from the process table, freeing the last of the child’s resources, and then resumes its own execution.\nIn Linux, every process moves through a series of well-defined states during its lifecycle. The following image and table describe Linux process states in detail.\nTASK_INTERRUPTIBLE: TASK_UNINTERRUPTIBLE: TASK_KILLABLE: TASK_REPORT_IDLE: Flags TASK_UNINTERRUPTIBLE and TASK_NOLOAD are set. Similar to TASK_KILLABLE, also a subset of state D. It accepts fatal signals.\nName Flag Kernel-defined state name and description Running R TASK_RUNNING: The process is either executing on a CPU or waiting to run. The process can be executing user routines or kernel routines (system calls), or be queued and ready when in the Running (or Runnable) state. Sleeping S TASK_INTERRUPTIBLE: The process is waiting for some condition: a hardware request, system resource access, or signal. When an event or signal satisfies the condition, the process returns to Running. D TASK_UNINTERRUPTIBLE: This process is also sleeping, but unlike S state, does not respond to signals. Used only when process interruption might cause an unpredictable device state. K TASK_KILLABLE: Identical to the uninterruptible D state, but modified to allow a waiting task to respond to the signal that it should be killed (exit completely). Utilities frequently display Killable processes as D state. I TASK_REPORT_IDLE: A subset of state D. The kernel does not count these processes when calculating load average. Used for kernel threads. Flags TASK_UNINTERRUPTIBLE and TASK_NOLOAD are set. Similar to TASK_KILLABLE, also a subset of state D. It accepts fatal signals. Stopped T TASK_STOPPED: The process is stopped (suspended), usually by being signaled by a user or another process. The process can be continued (resumed) by another signal to return to running. T TASK_TRACED: A process that is being debugged is also temporarily stopped and shares the same T state flag. Zombie Z EXIT_ZOMBIE: A child process signals to its parent as it exits. All resources except for the process identity (PID) are released. X EXIT_DEAD: When the parent cleans up (reaps) the remaining child process structure, the process is now released completely. This state cannot be observed in process-listing utilities. In Linux, the ps and top commands are commonly used to inspect processes. The ps command displays information about active processes and is typically used to capture a snapshot of the processes running at a specific moment. In contrast, the top command provides a real-time, dynamic view of system processes, continuously updating to show CPU usage, memory usage, uptime, load average, and resource consumption for each process.\nControl Jobs SHOW CONTENTS In Linux, a job refers to a command or a group of commands initiated from a terminal by a user. Jobs can run in two modes: as a foreground job or a background job. A foreground job occupies the terminal until it completes, while a background job runs independently, allowing the terminal to remain available for other tasks. For example, executing vim file.txt starts a foreground job, which holds the terminal until the editor is closed. Running sleep 300 \u0026amp; starts a background job, allowing the terminal to remain usable while the command runs for 300 seconds in th e background.\nA process is a running instance of a program. When a job is initiated, one or more processes are created to perform the assigned tasks. For example, typing ls -l creates a new process to handle the application.\nA pipeline is a sequence of commands connected by the | operator, where the output of one command is passed directly as input to the next. For example, the command ps aux | grep nginx | sort forms a pipeline involving three separate processes working in succession. In this case, a pipeline runs as one job, but each part is a separate process.\nA session is a collection of processes initiated from a single user login. The first process created in a session is known as the session leader. For example, when a user logs in to a server via ssh user_name@ip_address, the shell process (bash, zsh, etc.) acts as the session leader. All jobs and processes started from that terminal belong to the same session.\nIn Linux, job control allows management of multiple jobs (commands or processes) within a single terminal session. Job control makes it possible to pause, resume, move jobs between the foreground and background, or terminate them. Below are the common-use commands for job control:\nCtrl + Z: Suspends the current foreground job and puts it into the background in a stopped state. bg: Resumes a suspended job in the background. fg: Brings a background job back to the foreground. jobs: Lists all jobs associated with the current terminal session, showing each job’s ID and status (e.g., running, stopped). In the output, a + next to a job ID denotes the current default job, which is the target of any bg or fg command issued without a %jobID. A - marks the previous job, which will become the default once the current default job completes or is removed. For example: [1] Running sleep 100 \u0026amp; [2] Running sleep 100 \u0026amp; [3]- Running sleep 100 \u0026amp; [4]+ Running sleep 100 \u0026amp; kill %job_number: Sends a signal (default is SIGTERM) to terminate a job, identified by its job number. Ctrl + C: Terminates a foreground job. Kill Processes SHOW CONTENTS In Linux, processes can be terminated using signals. A signal is a software interrupt that is delivered to a process. The following table describes common signals.\nSignal Number Description SIGTERM 15 Graceful termination (default) SIGKILL 9 Forcefully kill (non-catchable) SIGINT 2 Interrupt from keyboard (Ctrl+C) SIGHUP 1 Hang up / restart daemon SIGSTOP 19 Stop (pause) a process SIGCONT 18 Resume a stopped process Note that while signal numbers may vary across different Linux hardware platforms, signal names and their meanings remain consistent. It is generally recommended to use signal names rather than numbers when sending signals. Additionally, Red Hat advises sending SIGTERM first to allow the process to terminate gracefully, followed by SIGINT if necessary. If both signals fail, SIGKILL should be used as a last resort. The SIGKILL signal cannot be caught or ignored, and it forcibly terminates the process without giving it an opportunity to perform any self-cleanup.\nHere are some commonly used commands related to terminating processes:\nkill PID: Sends the SIGTERM signal to the specified process, requesting it to terminate gracefully. kill -SIGKILL PID: Sends the SIGKILL signal to forcefully terminate the specified process immediately (cannot be caught or ignored). killall process_name: Sends SIGTERM to all processes matching the given name, attempting a graceful termination. killall -SIGKILL process_name: Sends SIGKILL to all processes matching the given name, forcing termination. pgrep process_name: Searches for processes matching the given name and returns their PIDs. pgrep -u user_name process_name: Searches for processes with the specified name owned by a specific user. pkill process_name: Sends SIGTERM to all processes matching the given name, similar to killall. pkill -SIGKILL process_name: Sends SIGKILL to all processes matching the given name, forcing termination. pkill -u user_name: Sends a signal to all processes owned by the specified user. pstree -p: Displays the process tree with PIDs included. pstree -u: Displays the process tree with associated user names. In real-world scenarios, system administrators can forcibly terminate a user\u0026rsquo;s session to log them out. The following example demonstrates this process:\nwho -u # Lists all active user sessions along with their associated PIDs. pkill -t pts/0 # Sends SIGTERM (default) to processes attached to terminal pts/0. pkill -SIGINT -t pts/0 # If necessary, sends SIGINT to the same terminal. pkill -SIGKILL -t pts/0 # As a last resort, sends SIGKILL to forcefully terminate the session. Monitor Process Activity SHOW CONTENTS In Linux, the load average indicates the system\u0026rsquo;s workload over a period of time, measuring how many processes are either actively running or waiting to be executed by the CPU. The load average is typically represented by three numbers, corresponding to the system load over the past 1, 5, and 15 minutes. A load average of 1.0 per CPU is considered fully utilized, meaning that each CPU is handling one process at a time. For example, if a system has 2 CPUs, a load average of 2.0 would mean that the system is fully utilized. To inspect the number of CPUs in the system, the lscpu command can be used.\nFor instance, if a system has 2 CPUs and the uptime command returns:\n20:41:31 up 5:29, 3 users, load average: 3.32, 1.90, 0.32 The load average for the last minute is 3.32, which means the total load on the system is 3.32. With 2 CPUs, the per-CPU load average for the last minute is 1.66 (3.32 ÷ 2). This suggests the system is overloaded since the per-CPU load exceeds 1.0. The load average for the last 5 minutes is 1.90, and the per-CPU load average for this period is 0.95 (1.90 ÷ 2), indicating that the system is closer to optimal usage during this time. The load average for the last 15 minutes is 0.30, and the per-CPU load average is 0.16 (0.32 ÷ 2), suggesting the system is underutilized. 9. Control Services \u0026amp; Daemons SHOW CONTENTS In Linux, systemd daemon is the system and service mamager repsonsible for initializing the system during boot and managing processes throughout the machine\u0026rsquo;s lifetime. It handles the startup sequence, maintains service states, sepervises processes, and managees logging and dependencies.\nsystemd uses the concept of units to manage and control system resources. A unit represents a single object that systemd knows how to manage, such as a service, a device, a mount point, or a socket.\nEach unit is defined by a unit file, which describes how systemd should handle it — including how to start, stop, reload, and manage dependencies. Unit files are typically stored in directories like /usr/lib/systemd/system/ or /etc/systemd/system/.\nUnits are categorized by type, and the type is reflected in the file extension. Common unit types include:\n.service: for system services (e.g., nginx.service) .socket: for socket activation .target: for grouping units into milestones or states (like multi-user.target, graphical.target) .mount: for filesystem mount points .timer: for time-based activation, like a cron replacement .device: for hardware devices .path: for path-based activation To interact with systemd, the systemctl is used. It allows administrators to manage services, check system states, enable or disable services at boot, and control system targets. Here are some commonly used commands:\nsystemctl status nginx: Displays the status of the nginx service. systemctl start nginx: Starts the nginx service. systemctl stop nginx: Stops the nginx service. systemctl restart nginx: Restarts the nginx service. systemctl enable nginx: Configures nginx to start automatically at boot. systemctl disable nginx: Disables automatic start at boot for nginx. systemctl reload-or-restart nginx: Reload the configuration if supported; otherwise, restart the service. systemctl is-enabled nginx: Check if the service is enabled to start at boot. systemctl is-active nginx: Check if the service is currently running. systemctl list-dependencies nginx: List the dependencies of the service. systemctl mask sendmail.service: Mask the service to prevent it from being started. systemctl unmask sendmail.service: Unmask the service to allow it to be started again. systemctl list-units --type=service: Lists all active services. systemctl reboot: Reboots the system. systemctl poweroff: Powers off the machine. 10. Configure \u0026amp; Secure SSH SHOW CONTENTS SSH (Secure Shell) is a protocol used to securely access and manage remote systems over an unsecured network. It provides encrypted communication between a client and a server, allowing for secure login, command execution, and file transfer. Here are common SSH usage examples:\nssh user@host: Connect to a remote server using the specified user account. ssh user@host command: Execute a command on the remote server without opening an interactive shell. scp file.txt user@host:/path/: Copy a file to a remote server using SSH. SSH also allows passwordless login to a remote server by using a pair of cryptographic keys: A private key and a public key. A private key is kept on the client machine while the public key is stored on the remote server in ~/.ssh/authorized_keys. When connecting, the server uses the public key to verify the client\u0026rsquo;s private key. If the key match, the connection is granted without prompting for a paasword. To enable this feature, following the following steps:\nssh-keygen -t rsa -b 4096 -C \u0026quot;RHEL 9 ON Virtual Machine\u0026quot;: Generate a key pair on the client. ssh-copy-id user_name@ip_address: Copy the public key to the remote server. ssh user_name@ip_address: Connect to the server. The default configuration of the SSH server works well for many use cases. To apply custom settings (e.g., disable remote login as root), edit the /etc/ssh/sshd_config file, modify the field PermitRootLogin to no. After modifying the configuration, apply the changes by running systemctl reload ssh.\n11. Analyze \u0026amp; Store Logs System Log Architecture SHOW CONTENTS In Red Hat Enterprise Linux, the standard logging system is based on the Syslog protocol, and the systemd-journald and rsyslog services are responsible for handling syslog messages.\nThe systemd-journald service forms the core of the operating system\u0026rsquo;s event logging architecture. It collects event messages from multiple sources, such as the system kernel, output from the early stages of the boot process, standard output and standard error from daemons, and Syslog events. systemd-journald restructures these logs into a standard format and writes them into a structured, indexed system journal. By default, this journal is stored in a file system that does not persist across reboots.\nOn the other hand, the rsyslog service reads syslog messages that systemd-journald receives from the journal as they arrive. It then processes the syslog events and records them to log files or forwards them to other services according to its configuration. The rsyslog service sorts and writes syslog messages to log files in the /var/log directory, which are persistent across reboots. This directory not only contains syslog message files but also log files from other services on the system. Below is a list of some useful log files located in the /var/log directory:\nLog File Description /var/log/messages Logs most system messages, including general syslog messages. Exceptions include authentication-related messages, email processing, scheduled job execution, and debug information. /var/log/secure Logs security-related messages, including authentication events and user access information. /var/log/maillog Logs messages related to the mail server, including both mail delivery and other mail-related operations. /var/log/cron Logs messages related to the execution of scheduled jobs (cron jobs). /var/log/boot.log Logs non-syslog console messages related to system startup and boot processes. Review Syslog Files SHOW CONTENTS In Linux, each log message is categorized by facility (which subsystem produces the message) and priority (the message\u0026rsquo;s severity). The following table lists the standard syslog facilities.\nCode Facility Description 0 kern Kernel messages 1 user User-level messages 2 mail Mail system messages 3 daemon System daemons messages 4 auth Authentication and security messages 5 syslog Internal syslog messages 6 lpr Printer messages 7 news Network new messages 8 uucp UUCP protocol messages 9 cron Clock daemon messages 10 authpriv Non-system authorization messages 11 ftp FTP protocol messages 16-23 local0 to local7 Custom local messages The following table lists the standard syslog priorities in descending order.\nCode Priority Description 0 emerg System is unusable 1 alert Action must be taken immediately 2 crit Critical condition 3 err Non-critical error condition 4 warning Warning condition 5 notice Normal but significant event 6 info Informational event 7 debug Debugging-level message The rsyslog service uses the facility and priority of log messages to determine how to handle them. Rules configure this facility and priority in the /etc/rsyslog.conf file and in any file in the /etc/rsyslog.d directory with the .conf extension.\nTo prevent log files from consuming too much disk space, Linux uses log rotation, a utility that automatically handles the archiving, compressing, and deletion of old log files. A scheduled job runs the logrotate command daily to check if any log files need to be rotated. When a log file is rotated, it is renamed with an extension indicating the rotation date. For example, the old /var/log/messages file might be renamed to /var/log/messages-20250419 when it is rotated on April 19, 2025. After rotations, typically over four weeks, the oldest log files are discarded to free up disk space.\nThe tail -f command in Linux is commonly used for monitoring log files in real time. It allows users to continuously view the latest entries being added to a log file, which is especially useful for monitoring system events and troubleshooting. Here is a sample example:\ntail -f /var/log/secure # In the first terminal ssh signalyu999@ip_address # In the second terminal The logger command sends messages to the rsyslog service, which is useful for testing changes to the rsyslog configuration. By default, it logs messages with the user facility and notice priority (user.notice), unless specified otherwise using the -p option. For example, to send a message to the rsyslog service and have it recorded in the /var/log/boot.log log file, the following logger command can be used:\n# /etc/rsyslog.conf # Save boot messages also to boot.log # local7.* /var/log/boot.log logger -p local7.notice \u0026#34;Log entry created on host\u0026#34; # TEST # 1. In the first terminal: tail -f /var/log/boot.log # 2. In the second terminal: logger -p local7.notice \u0026#34;Log entry created on host\u0026#34; Review System Journal Entries SHOW CONTENTS The systemd-journald service stores log data in a structured, indexed binary file called the journal. To retrieve log messages from the journal, the journalctl command is used. Below are some commonly used commands:\njournalctl --since \u0026quot;2025-04-18\u0026quot; --until \u0026quot;2025-04-19\u0026quot;: Shows logs from April 18, 2025, to April 19, 2025. journalctl --since \u0026quot;today\u0026quot;: Displays logs from the current day (since midnight). journalctl --since \u0026quot;-1 hour\u0026quot;: Shows logs from the last hour. journalctl --since \u0026quot;-10 minutes\u0026quot;: Displays logs from the last 10 minutes. journalctl -n 50: Shows the last 50 log entries. journalctl -u sshd: Displays logs related to the sshd service (SSH daemon). journalctl -f: Continuously shows the latest log entries in real-time. journalctl -p err: Filters and shows logs with \u0026ldquo;error\u0026rdquo; priority or higher. journalctl _PID=1234: Shows logs related to the process with PID 1234. journalctl _SYSTEMD_UNIT=sshd.service: Displays logs related to the sshd.service systemd unit. journalctl -b: Shows logs from the current boot session. Preserve the System Journal SHOW CONTENTS The systemd-journald service stores log data in a structured, indexed binary format known as the system journal. By default, Red Hat Enterprise Linux 9 stores the system journal in the /run/log directory, and the system clears the system journal after a reboot. To change this behavior and retain logs across reboots, the Storage parameter in the /etc/systemd/journald.conf file can be set to persistent. After modifying the configuration, the systemd-journald service must be restarted for the changes to take effect.\nThe Storage parameter has four options:\npersistent: Stores journals in the /var/log/journal directory, ensuring logs persist across reboots. If the /var/log/journal directory does not exist, the systemd-journald service creates it automatically. volatile: Stores journals in the volatile /run/log/journal directory. These logs are lost upon reboot. auto: If the /var/log/journal directory exists, logs are stored persistently. If the directory does not exist, volatile storage is used. This is the default behavior of the Storage parameter. none: Disables journal storage entirely, meaning no logs are stored. Maintain Accute Time SHOW CONTENTS In Linux, maintaining accurate system time is crucial for tasks such as logging, scheduling, and ensuring syschronization across different systems. Time syschronization is typically achieved through the use of the NTP (Network Time Protocol). The NTP is a standard way for machines to provide and obtain correct time information over the internet.\nMaintaing accurate time commonly involves two commands: tzselect and timedatectl. The tzslect command is an interactive utility used to select a time zone on Linux systems. It guides users through a series of prompts to set the time zone by selecting regions and cities form a list. It is helpful when users do not know the exact time zone string. The timedatectl command is provided by systemd to manage time and time zone settings on Linux systems. It allows users to query and set the system\u0026rsquo;s time, date, and time zone, as well as synchronize the system clock with NTP. Here are some common sample examples of timedatectl:\ntimedatectl status: Displays the current time zone, NTP status, and system time information. sudo timedatectl set-time \u0026quot;YYYY-MM-DD HH:MM:SS\u0026quot;: Sets the system date and time manually. sudo timedatectl set-timezone \u0026lt;timezone\u0026gt;: Changes the system\u0026rsquo;s time zone. timedatectl list-timezones: Lists all available time zones. sudo timedatectl set-ntp true: Enables NTP (Network Time Protocol) synchronization. sudo timedatectl set-ntp false: Disables NTP synchronization. sudo timedatectl set-local-rtc true: Sets the system clock to local time (RTC). sudo timedatectl set-local-rtc false: Sets the system clock to UTC (coordinated universal time). timedatectl show: Displays detailed information about the time and date settings. The chrond service keeps on track the usually inaccurate local Real-Time-Clock (RTC) by synchronizing it to the configured NTP servers. If network connectivity is unavailable, it calculates the RTC drift and stores the data in a file specified by the driftfile parameter in the /etc/chrony.conf configuration file. By default, chronyd uses servers from the NTP Pool Project but can be configured to use different servers for isolated networks. NTP servers are categorized by their stratum, with stratum 0 being a reference clock and higher strata representing servers that sync with other NTP servers. In the configuration file, servers and peers are defined, with the server being one stratum above the local server and peers at the same level. The iburst option is recommended for faster and more accurate initial synchronization.\n12. Manage Networking Networking Related Commands SHOW CONTENTS ip: A versatile tool for managing network interfaces, routing, and tunneling. ip addr pr ip a: Show IP addresses assigned to all interfaces. ip addr add 192.168.1.100/24 dev eth0: Assign an IP address to an interface. ip link or ip l: Show network interfaces and their status. ip link set eth0 up: Enable (bring up) a network interface. ip link set eth0 down: Disable (bring down) a network interface. ip route or ip r: Display the current routing table. ip route add 192.168.2.0/24 via 192.168.1.1: Add a static route. ip route del 192.168.2.0/24: Delete a route. ip neigh: Show the ARP table (neighbor cache). ss: A utility to investigate sockets. It is used for displaying information about network connections, listening ports, etc. ss: Display all established sockets and connections. ss -t: Show only TCP connections. ss -u: Show only UDP connections. ss -l: Show listening sockets. ss -tunlp: Show TCP/UDP listening ports with process info (-p). ss -s: Display a summary of socket statistics. ss -t state established: Show established TCP connections. ss -an: Show all sockets (listening and non-listening) in numeric format. ss -o state established: Show established connections with timers. ping: A tool used to test network connectivity between the client and the remote host by sending ICMP echo requests. ping baidu.com traceroute: A tool to trace the path packets take to reach a network destination, showing each hop along the way. traceroute \u0026lt;hostname/IP\u0026gt;: Trace the route packets take to reach the target host. traceroute -n \u0026lt;hostname/IP\u0026gt;: Show IP addresses only, skip hostname resolution (faster). traceroute -m 20 \u0026lt;hostname/IP\u0026gt;: Set maximum number of hops to 20. traceroute -p 80 \u0026lt;hostname/IP\u0026gt;: Use destination port 80 (helpful for testing web servers). traceroute -I \u0026lt;hostname/IP\u0026gt;: Use ICMP ECHO instead of UDP packets. traceroute -T \u0026lt;hostname/IP\u0026gt;: Use TCP SYN packets instead of UDP (helpful for firewalled networks). tracepath: A simpler version of traceroute that shows the path packets take to a destination but also provides information about packet loss and latency along the way. tracepath \u0026lt;hostname/IP\u0026gt;: Trace the path to a destination, showing each network hop along the way. tracepath -n \u0026lt;hostname/IP\u0026gt;: Display IP addresses only, skip reverse DNS lookup (faster). tracepath6 \u0026lt;hostname/IP\u0026gt;: Use IPv6 to trace the route to the target. host: A simple DNS lookup tool that resolves domain names to IP addresses. host \u0026lt;domain\u0026gt;: Resolve a domain name to its IP address. dig: A DNS lookup tool that queries the Domain Name System (DNS) for information about hostnames, IP addresses, and other DNS records. dig \u0026lt;domain\u0026gt;: Query the default DNS records (usually A records) for a domain. nmcli: A command-line interface for NetworkManager, used for manageing network connections and settings, such as configuring interfaces, VPNs, and Wi-Fi. nmcli device status or dev con status: Show the status of all network interfaces. nmcli connection show or nmcli con show: List all saved network connections. nmcli connection up \u0026lt;connection-name\u0026gt;: Activate a network connection. nmcli connection down \u0026lt;connection-name\u0026gt;: Deactivate a network connection. nmcli device connect \u0026lt;device\u0026gt;: Connect a network device. nmcli device disconnect \u0026lt;device\u0026gt;: Disconnect a network device. getent: A command used to query various system databases, including DNS, password, group, and hosts. It is useful for retriving information that\u0026rsquo;s typically stored in files like /etc/hosts or through services like DNS. getent hosts \u0026lt;hostname\u0026gt;: Resolve a hostname to its IP address (similar to host or nslookup). getent services \u0026lt;service\u0026gt;: Lookup port and protocol for a service (e.g., getent services ssh). getent protocols: List network protocols. getent passwd: List all user account entries from /etc/passwd or configured name service. getent passwd \u0026lt;username\u0026gt;: Query information for a specific user. getent group: List all group entries from /etc/group or configured name service. getent group \u0026lt;groupname\u0026gt;: Query information for a specific group. Configure Network SHOW CONTENTS 13. Archive \u0026amp; Transfer Files SHOW CONTENTS 14. Install \u0026amp; Update Software Packages SHOW CONTENTS 15. Access Linux File System SHOW CONTENTS 16. ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/linux/1-red-hat-enterprise-linux/","summary":"1. Introduction to Linux SHOW CONTENTS Open Source refers to software whose source code is freely available to the public for anyone to view, modify, and distribute. It encourages coolaboration, transparency, and community-driven improvements.\nOpen Source Licenses are legal agreements that define how software can be used, modified, and distributed. There are two main types of Copyleft and Permissive.\nCopyleft licenses require that any modified versions of the software also be open source, under the same terms as the original.","title":"Red Hat Enterprise Linux"},{"content":"Introduction to Docker SHOW CONTENTS Docker was developed to address the challenges of software deployment across various environments by providing a lightweight, consistent, and portable solution. Prior to Docker, developers often faced issues like \u0026ldquo;it works on my machine, but not in production,\u0026rdquo; caused by inconsistencies in dependencies, libraries, and configurations. Docker resolves this by containerizing applications, ensuring they run uniformly across any infrastructure. Its primary goal is to simplify development, testing, and deployment by encapsulating applications and their dependencies into isolated, reproducible containers. These containers are user-space instances that package code, runtime, system tools, and libraries, ensuring consistency across environments.\nThe key difference between Docker and Virtual Machines (VMs) lies in their architecture. VMs emulate entire hardware stacks, requiring a full operating system for each instance, which results in significant overhead. In contrast, Docker uses containers that share the host OS kernel, offering a more lightweight and efficient solution by isolating applications at the process level. Docker has three core components: images, containers, and registries. Images are read-only templates that contain application code and dependencies. Containers are runnable instances of these images; they are isolated, lightweight, and ephemeral. Registries are repositories that store and share Docker images. Docker Architecture SHOW CONTENTS Docker follows a Client/Server (C/S) architecture with a loosely coupled backend where various components perform specific functions. The basic workflow of Docker is as follows: Docker Client: The user interacts with the Docker Client, which communicates with the Docker Daemon to send requests. Docker Daemon: This is the core component of Docker\u0026rsquo;s architecture. It provides the Docker Server functionality, enabling it to accept requests from the Docker Client. Docker Engine: The Docker Engine executes a series of internal tasks. Each task is represented as a \u0026ldquo;Job.\u0026rdquo; Job Execution: Each Job performs a specific function, such as building an image, starting a container, or managing storage. Graph Driver: If a Job requires a container image, the Engine fetches it from a Docker Registry. The Graph driver stores the downloaded image as a Graph (a layered filesystem) and manages its dependencies. Network Creation: When a network environment needs to be created for Docker, the Network Driver is used to create and configure the network for Docker containers. Resource Management and Execution: If Docker needs to limit resources or execute user commands within containers, the Exec Driver is responsible for completing these operations. Libcontainer: Libcontainer is an independent container management package. Both the Network Driver and the Exec Driver rely on Libcontainer to perform specific container management operations. Common Docker Commands Basic Commands SHOW CONTENTS Start/Stop/Restart Docker: sudo systemctl start docker sudo systemctl stop docker sudo systemctl restart docker View Docker Status: sudo systemctl status docker View Docker Info: docker info View Docker Help Documentation: docker --help View Docker Version: docker -v Docker Image Commands SHOW CONTENTS Search for a Docker Image: docker search \u0026lt;image_name\u0026gt; docker search nginx Pull a Docker Image: docker pull \u0026lt;image_name\u0026gt; docker pull nginx List Docker Images: docker images docker image ls Inspect a Docker Image: docker inspect \u0026lt;image_name_or_id\u0026gt; docker inspect nginx Tag a Docker Image: docker tag \u0026lt;image_id_or_name\u0026gt; \u0026lt;new_image_name\u0026gt;:\u0026lt;new_tag\u0026gt; docker tag nginx:latest nginx:1.27.4 Remove a Docker Image: docker rmi \u0026lt;image_name_or_id\u0026gt; docker rmi nignx:1.27.4 Build a Docker Image: docker build -t \u0026lt;image_name\u0026gt;:\u0026lt;tag\u0026gt; \u0026lt;path_to_dockerfile\u0026gt; docker build -t myapp:latest . Save a Docker Image to a File: docker save -o \u0026lt;output_file_name\u0026gt;.tar \u0026lt;image_name\u0026gt;:\u0026lt;tag\u0026gt; docker save -o myapp.tar myapp:latest Load a Docker Image from a File: docker load -i \u0026lt;file_name\u0026gt;.tar docker load -i myapp.tar Prune Unused Docker Images: docker image prune docker image prune -a Docker Container Commands SHOW CONTENTS ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/devops/docker/1-docker/","summary":"Introduction to Docker SHOW CONTENTS Docker was developed to address the challenges of software deployment across various environments by providing a lightweight, consistent, and portable solution. Prior to Docker, developers often faced issues like \u0026ldquo;it works on my machine, but not in production,\u0026rdquo; caused by inconsistencies in dependencies, libraries, and configurations. Docker resolves this by containerizing applications, ensuring they run uniformly across any infrastructure. Its primary goal is to simplify development, testing, and deployment by encapsulating applications and their dependencies into isolated, reproducible containers.","title":"Docker"},{"content":"Japanese 1 Your browser does not support the audio element. SHOW NOTES 食料を買うためにお店に行きます。（I will go to the store to buy some food.） 遅れるのは良くない。（It is not good to be late.） 私は日本に行ったことがあります。（I have been to Japan before.） これを手伝（てつだ）ってくれますか？（Can you help me with this?） この店は安くておいしい、だからおすすめです。（This store is cheap and delicious, therefore it is recommended.） 母は、私に勉強しなさいと言いました。（My mother told me to study. ） 鍵はテーブルの上にあることに気がつきました。（I realized that I left my keys on the table.） 雨が止んだら、公園に行きます。（I will go to the park if it stops raining.） 辛い食べ物は食べられない。（I can\u0026rsquo;t eat spicy food.） この本は面白いように見える。（This book looks interesting.） 彼は私に部屋を掃除させました。（He made me clean the room.） 授業中は注意深く聞かなければなりません。（You must listen carefully in class.） 明日やるので、あなたはやらなくてもいいです。（I\u0026rsquo;ll do it tomorrow, so it\u0026rsquo;s not necessary for you to do it.） 2 Your browser does not support the audio element. SHOW NOTES 彼女は新しい家に引っ越すそうだ。(I heard that she is moving to a new house.) 彼女は宿題をしたばかりだ。(She just finished her homework.) 時間があったら、手伝っていただけますか？(If you have time, could you help me?) 映画を見たらどうですか。(Why don’t you go to the movies?) 彼にはパーティに一緒に来てほしい。(I want him to come with me to the party.) 窓を開けていただけませんか。(Could you please open the window?) これをしてあげる。(I\u0026rsquo;ll do this for you.) 昼ご飯を食べているところだ。(I\u0026rsquo;m in the middle of eating lunch.) 彼は日本語を2年間勉強している。(He has been studying Japanese for two years.) もっと日本語を話してみてください。(Please try speaking in Japanese more often.) 3 Your browser does not support the audio element. SHOW NOTES この仕事を今日中に終わらせることにした。（I decided to finish this work by the end of today.） 雨が降った場合は、ピクニックを中止します。（In the event of rain, we will cancel the picnic.） このボタンを押すだけで、全ての設定が完了します。（Just by pressing this button, all settings will be completed.） 会議が始まると、彼は突然質問を出した。（As the meeting started, he suddenly asked a question.） 子どもは遊びたがっている。（The child seems to want to play.） この花は良い匂（にお）いがする。（This flower smells good.） そんなに簡単に成功するはずがない。（It’s impossible to succeed that easily.） 彼は今どこにいるのかしら？（I wonder where he is now.） 彼はすごく疲れているみたいだ。（He seems to be really tired.） 歩きながら電話をしている。（I am talking on the phone while walking.） 4 Your browser does not support the audio element. SHOW NOTES 彼女は自分の間違いに気がついた。（She realized her mistake.） この問題は解きにくい。（This problem is difficult to solve.） 勉強のために毎日図書館に行くのに、今日は行けなかった。（I go to the library every day for studying, but I couldn’t go today.） 彼はまるで映画の主人公のように見える。（He looks like the protagonist of a movie.） 彼女は女優のような美しさを持っている。（She has the beauty like an actress.） 会議は1ヶ月おきに行われます。（The meetings are held every month.） 疲れているのに、彼は最後まで頑張った。（Although he was tired, he worked hard until the end.） 日本語が話せる。（I can speak Japanese.） 今日は暑いらしいですね。（It seems like it’s hot today.） 私はその映画を見られなかった。（I couldn’t watch that movie.） 彼は先生に褒められた。（He was praised by the teacher.） 先生は私たちに宿題をさせた。（The teacher made us do homework.） 彼は上司に遅くまで働かせられた。（He was forced to work late by his boss.） さすがプロの選手、すごいプレーだった。（As expected from a professional player, that was an amazing play.） お金が100円しかない。（I only have 100 yen.） 5 Your browser does not support the audio element. SHOW NOTES 彼は旅行に行きたがっている。（He wants to go on a trip.） これからも日本語を勉強していきます。（From now on, I will keep studying Japanese.） 昼ごはんを食べたばかりなので、もうお腹が空いていません。（I just ate lunch, so I’m not hungry yet.） 今出発するところです。（I am about to leave now.） 今レポートを書いているところです。（I am in the middle of writing the report.） もっと早く寝たらどうですか？（Why don’t you go to bed earlier?） 後で使うためにこの資料を取っておきます。（I will keep this document for later use.） 彼女にプレゼントを買ってあげた。（I bought her a present.） 彼は私に車を貸してくれる。（He is lending me his car.） 明日早く来てほしい。（I want you to come early tomorrow.） 財布を忘れてしまった。（I accidentally forgot my wallet.） 彼が来ないということを聞いた。（I heard that he isn’t coming.） この方法は最も簡単だといってもいい。（You could say this method is the easiest.） 彼は明日来るときいた。（I heard that he is coming tomorrow.） ","permalink":"https://signalyu.github.io/posts/3-humanities/personal-growth/practice/area-for-improvement/japanese/1-area-for-improvement/","summary":"Japanese 1 Your browser does not support the audio element. SHOW NOTES 食料を買うためにお店に行きます。（I will go to the store to buy some food.） 遅れるのは良くない。（It is not good to be late.） 私は日本に行ったことがあります。（I have been to Japan before.） これを手伝（てつだ）ってくれますか？（Can you help me with this?） この店は安くておいしい、だからおすすめです。（This store is cheap and delicious, therefore it is recommended.） 母は、私に勉強しなさいと言いました。（My mother told me to study. ） 鍵はテーブルの上にあることに気がつきました。（I realized that I left my keys on the table.） 雨が止んだら、公園に行きます。（I will go to the park if it stops raining.","title":"Areas For Improvement"},{"content":"2025-04-07 20:26:39 PM subject: Japanese desc: Japanese grammar 1-50 weakness: な, ないでください, にする, たことがある, なら, ながら, てから, に行く 2025-04-08 20:46:57 PM subject: Japanese desc: Japanese grammar 51-75 weakness: なさる、のように、させる、させられる、てはいけない、なさい、のに、に気がつく、たら、られる 2025-04-09 21:05:38 PM subject: Japanese desc: Japanese grammar 76-100 weakness: たがる、ていく、たばかり、ところ、てみる、ているところ、たらどうですか、ておく、てあげる、てほしい 2025-04-14 15:23:06 PM subject: Japanese desc: Japanese grammar 1-50 weakness: area for improvement #3 2025-04-15 09:19:34 AM subject: Japanese desc: Japanese Grammar 51-75 weakness: area for improvement #4 2025-04-16 08:51:12 AM subject: Japanese desc: Japanese grammar 76-100 weakness: area for improvement #5 ","permalink":"https://signalyu.github.io/posts/3-humanities/personal-growth/practice/logs/logs/","summary":"2025-04-07 20:26:39 PM subject: Japanese desc: Japanese grammar 1-50 weakness: な, ないでください, にする, たことがある, なら, ながら, てから, に行く 2025-04-08 20:46:57 PM subject: Japanese desc: Japanese grammar 51-75 weakness: なさる、のように、させる、させられる、てはいけない、なさい、のに、に気がつく、たら、られる 2025-04-09 21:05:38 PM subject: Japanese desc: Japanese grammar 76-100 weakness: たがる、ていく、たばかり、ところ、てみる、ているところ、たらどうですか、ておく、てあげる、てほしい 2025-04-14 15:23:06 PM subject: Japanese desc: Japanese grammar 1-50 weakness: area for improvement #3 2025-04-15 09:19:34 AM subject: Japanese desc: Japanese Grammar 51-75 weakness: area for improvement #4 2025-04-16 08:51:12 AM subject: Japanese desc: Japanese grammar 76-100 weakness: area for improvement #5 ","title":"Practice Logs"},{"content":"Function Function arguments refer to data passed to the function. In python, there four main types of arguments: positional arguments, keyword arguments, default arguments, and variable length arguments.\nPositional arguments are passed to a function in a specific order, and the values are assigned to parameters based on their position. Keyword arguments are passed to a function by explicitly specifying the parameter name. Any keyword arguments must be put after the last positional argument. A default argument allows a function to accept values for parameters that are not provided by the caller. If no argument is passed for a parameter with a default value, the default will be used. Any default arguments must be put after the last positional argument. Variable length arguments allow a function to accept any number of positional arguments. *args accepts all arguments into a tuple, while **kwargs accepts all arguments into a dictionary. SHOW CODE Python def function_arguments(a, b=2, *args, c=3, **kwargs): print(f\"a: {a}, b: {b}, args: {args}, c: {c}, kwargs: {kwargs}\") function_arguments(1, 1997, 9, 99, 999, name=\"Signal\", age=27) SHOW OUTPUT Output a: 1, b: 1997, args: (9, 99, 999), c: 3, kwargs: {'name': 'Signal', 'age': 27} In Python, functions always return a value, if no return is specified, they return None.\nSHOW CODE Python def check_even(num): if num % 2 == 0: return True # No else clause, so returns None if odd print(check_even(3)) # None In Python, a variable defined outside a function is accessible within the function\u0026rsquo;s body, but only for reading its value. If a value is assigned to the variable inside the function, a new local variable with the same name is created, and the external variable remains unchanged.\nSHOW CODE Python Python x = 1 def fun(): print(x) fun() # 1 x = 1 def fun(): x = 2 print(x) fun() # 2 To modify a variable defined outside a function, the global keyword can be used, extending the variable\u0026rsquo;s scope into the function and allowing both reading and modification.\nSHOW CODE Python x = 1 def fun(): global x x = 2 print(x) print(x) # 1 fun() # 2 print(x) # 2 For function arguments, if the argument is a list, modifying the parameter itself doesn\u0026rsquo;t affect the original list, but modifying the list\u0026rsquo;s contents will affect the original list.\nSHOW CODE Python Python def fun(list_1): print(\"Before modification...\") print(f\"list_1: {list_1}\") print(f\"list_2: {list_2}\") list_1 = [0, 0] # Modify the parameter itself print(\"After modification...\") print(f\"list_1: {list_1}\") print(f\"list_2: {list_2}\") list_2 = [1, 2] fun(list_2) print(f\"Outside the funtion: list_2 = {list_2}\") ######################### Output ######################### Before modification... list_1: [1, 2] list_2: [1, 2] After modification... list_1: [0, 0] list_2: [1, 2] Outside the function: list_2 = [1, 2] ########################################################## ##################### Memory Diagram ##################### +-----------+ +--------+ +-----------+ | list_2 | ----\u003e | [1, 2] | \u003c---- | list_1 | +-----------+ +--------+ +-----------+ ############### Executing list_1 = [0, 0] ################ +-----------+ +--------+ | list_2 | ----\u003e | [1, 2] | +-----------+ +--------+ +-----------+ +--------+ | list_1 | ----\u003e | [0, 0] | +-----------+ +--------+ ########################################################## def fun(list_1): print(\"Before modification...\") print(f\"list_1: {list_1}\") print(f\"list_2: {list_2}\") list_1[0] = 999 # Modify the list's content print(\"After modification...\") print(f\"list_1: {list_1}\") print(f\"list_2: {list_2}\") list_2 = [1, 2] fun(list_2) print(f\"Outside the function: list_2 = {list_2}\") ######################### Output ######################### Before modification... list_1: [1, 2] list_2: [1, 2] After modification... list_1: [999, 2] list_2: [999, 2] Outside the funtion: list_2 = [999, 2] ########################################################## ##################### Memory Diagram ##################### +-----------+ +--------+ +-----------+ | list_2 | ----\u003e | [1, 2] | \u003c---- | list_1 | +-----------+ +--------+ +-----------+ ############### Executing list_1[0] = 999 ################ +-----------+ +----------+ +-----------+ | list_2 | ----\u003e | [999, 2] | \u003c---- | list_1 | +-----------+ +----------+ +-----------+ ########################################################## Operators Floor division // rounds down the result of the division, truncating any fractional part. For example, -6 // 4 outputs -2. Left-sided binding refers to the way operators or expressions are evaluated from left to right. Most operators evaluate left-to-right. For example, 9 % 6 % 2 returns 1. Right-sided binding refers to expressions where the evaluation happens from right to left. The exponentiation operator (**) and the chained assignment evaluate right-to-left. Compound assignment operators allow performing an operation and then assign the result of it to a variable in a single step. For example, the expression a /= 2 * 3 evaluates 2 * 3 to 6, and then performs a = a / 6 that returns 1.0. List When assinging a list to a new variable, both variables reference the same list object in memory, meaning modifying one variable affects the other because they point to the same data.\nSHOW CODE Python list_1 = [\"A\", \"B\", \"C\"] list_2 = list_1 list_3 = list_2 ###################### Memory Diagram ##################### +-----------+ +-----------------+ +-----------+ | list_1 | ----\u003e | [\"A\", \"B\", \"C\"] | \u003c---- | list_2 | +-----------+ +-----------------+ +-----------+ ^ | +-----------+ | list_3 | +-----------+ ########################################################### del list_1[0] ################### Memory Diagram ################### +-----------+ +------------+ +-----------+ | list_1 | ----\u003e | [\"B\", \"C\"] | \u003c---- | list_2 | +-----------+ +------------+ +-----------+ ^ | +-----------+ | list_3 | +-----------+ ###################################################### del list_2 ####### Memory Diagram ########### +-----------+ +------------+ | list_1 | ----\u003e | [\"B\", \"C\"] | +-----------+ +------------+ ^ | +-----------+ | list_3 | +-----------+ ################################## print(list_3) # [\"B\", \"C\"] To copy the contents of the original list, slicing is commonly used.\nSHOW CODE Python list_1 = [\"A\", \"B\", \"C\"] list_2 = list_1[:] list_3 = list_2[:] ############ Memory Diagram ########### +-----------+ +-----------------+ | list_1 | ----\u003e | [\"A\", \"B\", \"C\"] | +-----------+ +-----------------+ +-----------+ +-----------------+ | list_2 | ----\u003e | [\"A\", \"B\", \"C\"] | +-----------+ +-----------------+ +-----------+ +-----------------+ | list_3 | ----\u003e | [\"A\", \"B\", \"C\"] | +-----------+ +-----------------+ ####################################### del list_1[0] ############ Memory Diagram ########### +-----------+ +-----------------+ | list_1 | ----\u003e | [\"B\", \"C\"] | +-----------+ +-----------------+ +-----------+ +-----------------+ | list_2 | ----\u003e | [\"A\", \"B\", \"C\"] | +-----------+ +-----------------+ +-----------+ +-----------------+ | list_3 | ----\u003e | [\"A\", \"B\", \"C\"] | +-----------+ +-----------------+ ####################################### del list_2[0] ############ Memory Diagram ########### +-----------+ +-----------------+ | list_1 | ----\u003e | [\"B\", \"C\"] | +-----------+ +-----------------+ +-----------+ +-----------------+ | list_2 | ----\u003e | [\"B\", \"C\"] | +-----------+ +-----------------+ +-----------+ +-----------------+ | list_3 | ----\u003e | [\"A\", \"B\", \"C\"] | +-----------+ +-----------------+ ####################################### print(list_3) # [\"A\", \"B\", \"C\"] List comprehension in Python provides a concise way to create lists by applying an expression to each item in an iterable and optionally filtering items based on a condition. It is typically faster than using loops for constructing lists.\nSHOW CODE Python # [expression for item in iterable if condition] squares = [x**2 for x in range(10) if x % 2 == 0] print(squares) # [0, 4, 16, 36, 64] Tuple \u0026amp; Dictionary Tuples are immutable sequences. A tuple with a single item must have a trailing comma (tup = (5, )) to differentiate it from a regular parentheses-enclosed expression.\nTuple unpacking allows extracting elements of a tuple into variables. The number of variables must match the number of elements in the tuple.\nSHOW CODE Python sides = (1, 2, 2) a, b, c = sides print(a, b, c) # 1 2 2 Dictionaries are mutable and unordered collections of key-value pairs. In Python 3.6x, dictionaries have become ordered by default, meaning the order of item is preserved based on the order of insertion.\nKeys in a dictionary must be of a type that is immutable (e.g., strings, numbers, or tuples). Mutable types like lists or dictionaries themselves cannot be used as dictionary keys.\nSHOW CODE Python valid = {('a', 'b'): 'tuple_key'} # OK invalid = {['a', 'b']: 'list_key'} # TypeError ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/programming/python/1-python-programming/","summary":"Function Function arguments refer to data passed to the function. In python, there four main types of arguments: positional arguments, keyword arguments, default arguments, and variable length arguments.\nPositional arguments are passed to a function in a specific order, and the values are assigned to parameters based on their position. Keyword arguments are passed to a function by explicitly specifying the parameter name. Any keyword arguments must be put after the last positional argument.","title":"Python Programming"},{"content":"1. Introduction to CCNA Exam Exam Topics CCNA Exam Topics Exam Instructions Cisco Exam Tutorial Question Types YOU CAN\u0026rsquo;T GO BACK AFTER ANSWERING OR SKIPPING A QUESTION.\nCCNA Question Types Online Testing A PRIVATE and QUITE place for AT LEAST 2 HOURS must be needed.\nOnline Testing Cisco Packet Tracer Installation Cisco Packet Tracer Installation (Login First) Schduling and Taking the Exam Scheduling And Taking the Exam Exam Prep: Binary Game Binary Game 2. Network Devices Network Devices Local Area Network (LAN): A network that connects computers and devices within a limited geographical area, such as a home, office, or school. Wide Area Network (WAN): A network that spans a large geographical area, often connecting multiple LANs. Computer Network: A system of interconnected computers and devices that communicate and share resources. Node: Any device connected to a network, such as a computer, printer, or phone. Resources: Assets shared over a network, including hardware (e.g., printers, storage) and software (e.g., applications, files). Client-Server: A network model where clients request services or resources from servers. Switches Devices provide connectivity between devices in a local area network (LAN). Routers: Devices that provide connectivity between LANs or external network. Wireless Router: A device that provides wireless connectivity to a network, allowing devices to connect without physical cables. Network Firewall: A security system that monitors and controls incoming and outgoing network traffic based on predefined security rules, protecting against unauthorized access. 3. Cables, Connectors, and Ports Ethernet: A widely used wired networking technology that connects devices in a LAN using cables such as twisted pair or fiber optics. It follows standards like IEEE 802.3. IEEE (Institude of Electrical and Electronics Engineers): An organization that defines networking standards, including Ethernet (IEEE 802.3) and Wi-Fi (IEEE 802.11). Unshilded Twisted Pair (UTP) Cables: A type of Ethernet cable with twisted copper wire pairs that reduce electromagnetic interference (EMI). Common categories include Cat5e, Cat6e, and Cat6a. Shielded Twisted Pair (STP) Cables: A type of Ethernet cable that includes additional shieding to protect against electromagnetic interference (EMI) and crosstalk (an interference caused by signal leakage between adjacent cables or wire pairs in a network). UTP Cables vs. STP Cables Electromagnetic Interference (EMI): Disruptions in signal transmission caused by external electromagnetic sources, such as power lines or other electronic devices. Shielded cables (STP) help reduce EMI. 8 Position 8 Contact (8P8C) Connector: The standard modular connector used for Ethernet cables, often incorrectly called an RJ45 connector. 8P8C vs. RJ45 Fiber Optic Cables: High-speed network cables that use light instead of electrical signals, offering faster speeds and resistance to EMI. Fiber Optic Cable Structure Single Mode Fiber (SMF): A fiber optic cable type designed for long-distance transimission using a single light beam, reducing signal loss and allowing for higher speeds. Multimode Fiber (MMF): A fiber optic cable type that carries multiple light beams, suitable for shorter distances due to higher dispersion. Single Mode vs. Multimode 4. Networking Models Networking models are conceptual models that define how different layers of a network should interact to achieve communication between devices. The two most common models are the OSI Model and the TCP/IP Model.\nThe OSI Reference Model The OSI (Open Systems Interconnection) Model is a conceptual framework that divides network communication into seven layers. These layers are the Physical Layer, Data Link Layer, Network Layer, Transport Layer, Session Layer, Presentation Layer, and Application Layer. Each layer has a specific function and interacts with adjacent layers to ensure smooth and efficient data transmission.\nPhysical Layer: Transmits raw bits over a physical medium (e.g., cables). Data Link Layer: Handles data frames and ensures error-free transmission between adjacent nodes (e.g., MAC addresses, switches). Network Layer: Determines the best path for data and handles addressing and routing (e.g., IP addresses, routers). Transport Layer: Ensures reliable data transfer with error correction and flow control (e.g., TCP, UDP). Session Layer: Manages and controls communication sessions between applications. Presentation Layer: Converts data formats for compatibility (e.g., encryption, compression). Application Layer: Provides network services directly to applications (e.g., HTTP, FTP, SMTP). OSI Reference Model OSI Reference Model The TCP/IP Model The TCP/IP Model (Transmission Control Protocol/Internet Protocol) is a practical framework used for internet communication. It consists of four layers: the Network Interface Layer, Internet Layer, Transport Layer, and Application Layer.\nNetwork Interface Layer: Handles physical data transmission over a network medium. It is equivalent to the Physical and Data Link Layers of the OSI model. Internet Layer: Routes packets across networks using IP addresses, similar to the Network Layer in the OSI model. Transport Layer: Ensures reliable (TCP) or fast (UDP) data delivery between devices, corresponding to the Transport Layer in the OSI model. Application Layer: Supports network applications and protocols like HTTP, FTP, and SMTP. It combines the functions of the Application, Presentation, and Session Layers in the OSI model. TCP/IP Model The 5-Layer Network Model The 5-Layer Network Model is a simplified version of the OSI Reference Model, commonly used to understand networking concepts. It merges the Session, Presentation, and Application Layers of the OSI model into a single Application Layer. Below is the diagram illustrating this model:\nThe 5-Layer Network Model Key Notes In networking, adjacent layer interaction refers to the communication and collaboration between two neighboring layers in a networking model. Each layer provides service to the layer above it and relies on the layer below it to perform its functions. 5. The Cisco ISO CLI EXEC, Privileged EXEC, and Global Configuration Modes In Cisco devices (such as routers and switches), there are three main modes that allow interaction with the device: EXEC, Privileged EXEC, and Global Configuration modes.\nEXEC, Privileged EXEC, and Global Configuration Modes EXEC Mode: This is the initial mode when first logging into a Cisco device. It provides basic access to the device and allows running simple monitoring and diagnostic commands. Privileged EXEC Mode: This mode provides more advanced commands to view detailed information about the device. To enter Privileged EXEC Mode, type enable from EXEC Mode. To exit Privileged EXEC Mode, type disable to return to EXEC Mode. Global Configuration Mode: This mode allows modification of the system configuration. To Global Configuration Mode, type configure terminal or conf t (shorthand). To return to Privileged EXEC Mode, type end or exit. 6. Ethernet LAN Switching Ethernet Frame Format An Ethernet frame is the fundamental unit of data transmission in Ethernet networks. It is used to encapsulate and transmit data over a Local Area Network (LAN). The Ethernet frame format is defined by the IEEE 802.3 standard and consists of several fields. Here is a detailed breakdown of the Ethernet frame format:\nEthernet Frame Format Preamble (7 bytes): A series f alternating 1s and 0s used for synchonization. SFD (Start Frame Delimiter, 1 byte): Uses a one byte bit pattern (10101011) to mark the end of the preamble and the start of the actual data. Destination MAC Address (6 bytes): The MAC address of the device receiving the frame. Source MAC Address (6 bytes): The MAC address of the device sending the frame. EtherType/Length (2 bytes): Indicates the type of protocol (e.g., IPv4, ARP) or the length of the payload. Payload/Data (46 - 1500 bytes): The actual data being transmitted, such as an IP packet or other protocol data. FCS (Frame Check Sequence, 4 bytes): A 32-bit CRC (Cyclic Redundency Check) for error detection. Note that the Ethernet header includes the Destination MAC Address, Source MAC Address, and Type/Length fields. It does not include the Preamble and Start Frame Delimiter (SFD) fields. The Ethernet trailer only includes the Frame Check Sequence (FCS) field.\nMAC Address A MAC address (Media Access Control Address) is a unique identifier assigned to a network interface controller (NIC) for communication on a network. It is a 6-byte address, typically represented in hexadecimal format. The MAC address is divided into two parts: OUI (Organizationally Unique Identifier) and NIC (Network Interface Controller) Specific. The OUI is assigned by the IEEE to identify the manufacturer or vendor of the device, while the NIC Specific part is assigned by the manufacturer to uniquely identify the network interface device.\nMAC Address Format Frame Switching In computer networks, switches help forward data by using a MAC (Media Access Control) address table. This table stores the MAC addresses of devices connected to the switch and the ports through which those devices are connected.\nWhen a switch receives a data frame, it checks the source MAC address in the frame. The switch then adds the MAC address to its MAC address table and associates it with the port from which the frame arrived. This process is called MAC address learning, and the MAC addresses added in this way are called dynamic MAC addresses.\nTo keep the MAC address table up-to-date, the switch uses MAC address aging. If the switch doesn\u0026rsquo;t receive a frame from a particular MAC address for five minutes, it removes that MAC address from the table. This helps avoid outdated or unnecessary entries.\nSwitches handle two types of frames: unicast and unknown unicast. A unicast frame is addressed to a specific device. If the switch knows the destination device\u0026rsquo;s MAC address, it forwards the frame to the correct port. This is called a known unicast frame. If the switch doesn\u0026rsquo;t know the destination MAC address, it treats the frame as an unknown unicast frame. In this case, the switch sends the frame to all its ports, except the one it received the frame on, in an attempt to reach the correct device. This is called flooding.\nHere are some common commands for managing MAC address table:\nshow mac address-table: Shows all learned MAC addresses. clear mac address-table dynamic: Deletes all dynamic MAC addresses. clear mac address-table dynamic address \u0026lt;mac-address\u0026gt;: Removes a specific MAC address. clear mac address-table dynamic interface \u0026lt;interface-name\u0026gt;: Clears MAC addresses on a specific port. ARP (Address Resolution Protocol) The Address Resolution Protocol (ARP) helps devices find the MAC addresses of another when they only know its IP address.\nARP works through two key messages: the ARP request and the ARP reply.\nARP Request: A device sends a broadcast message to FFFF.FFFF.FFFF, and asks \u0026ldquo;who has this IP address? Tell me your MAC address!\u0026rdquo; Since the ARP Request is a broadcast, the switch floods it to all devices in the same boradcast domain. ARP Reply: The device with the matching IP responds with its MAC address in a unicast message. A broadcast domain is a group of devices that receive each other\u0026rsquo;s broadcast messages. If multiple switches are connected, all devices on those switches are in the same broadcast domain.\nTo avoid sending ARP requests every time they communicate, devices store IP-to-MAC mappings in an ARP table. This table keeps entries for a short time before refreshing them.\nPing Ping is a widely used utility that helps test the connectivity between two devices on a network. It is part of the Internet Control Message Protocol (ICMP) and is a critical tool for diagnosing network issues and ensuring that devices can communicate with each other.\nPing is part of ICMP (Internet Control Message Protocol) and uses two messages:\nICMP Echo Request: The sender asks, \u0026ldquo;Are you there?\u0026rdquo; by sending a unicast message to the target device. ICMP Echo Reply: If the destination device is reachable, it responds with a unicast message confirming connectivity. Ping is commonly used for troubleshooting network connectivity issues. To use ping, simple type ping \u0026lt;ip-address\u0026gt;.\n7. IPv4 IPv4 Header Format IPv4 Header Format The IPv4 header format consists of several fields that help rout the packet from the source to the destination. Here\u0026rsquo;s a breakdown of the IPv4 header structure:\nVersion: Specifies the version of the IP protocol. For IPv4, the value is 4. IHL (Internet Header Length): Specifies the length of the header in 32-bit words. The minimum value is 5, which corresponds to a 20-byte header. Type of Service (ToS): Defines the priority or quality of service (delay, throughput, reliability) for the packet. Total Length: Specifies the entire packet size (header + data) in bytes. Identification: A unique identifier for the packet, used for reassembling fragmented packets. Flags: Used for fragmentation control. It has the following fields: Bit 0 (Reserved): Must be 0. Bit 1 (DF - Don\u0026rsquo;t Fragment): If set, fragmentation is disabled. Bit 2 (MF - More Fragments): If set more fragments follow. Fragmentation Offset: Specifies the position of the fragment\u0026rsquo;s data in the original packet. It is used for reassembling fragmented packets. TTL (Time To Live): Specifies the maximum number of hops the packet can traverse before being discarded. Decrease by 1 at each hop. Protocol: Specifies the protocol used in the data portion of the IP packet, such as: 1 for ICMP 6 for TCP 17 for UDP Header Checksum: A checksum value used for error-checking the header to ensure it has not been corrupted. Source IP Address: The IP address of the source of the packet. Destination IP Address: The IP address of the intended destination of the packet. Options: Optional fields for additional settings, such as security, timestamp, and routing information. Requires padding to align to 32 bits. IPv4 Addressing IPv4 addresses are 32-bit numbers that identify devices on a network. They are written in dotted decimal notation (e.g., 192.168.1.1), divided into four groups of 8 bits called octets. An IPv4 addresss is split into two parts: the network portion and the host portion.\nNetwork Portion: This part identifies the network where a device belongs. All devices in the same network share the same network portion. Host Portion: This part identifies the specific device in the network. Each device has a unique host portion. The network portion is usually indicated with a prefix (e.g., /24), which shows how many bits are used for the network. Alternatively, a netmask (e.g., 255.255.255.0) can also define the network portion. A netmask uses 1s for the network part and 0s for the host part.\nThe IP addresses can be categorized into three types: Network Address, Broadcast Address, and Usable Addresses.\nNetwork Address: The first address in a network (host portion is all 0s). It identifies the network and can\u0026rsquo;t be assigned to a device. Broadcast Address: The last address in a network (host portion is all 1s). It\u0026rsquo;s used to send messages to all devices in the network. However, to send a message to all hosts on the local network, the address 255.255.255.255 is usually used. Usable Addresses: These are the addresses that can be assigned to devices. The number of usable addresses is calculated as $2^y - 2$, where $y$ is the number of bits in the host portion. Subtracting 2 accounts for the exclusion of the network address and the broadcast address. IPv4 addresses can be organized into five classes: A, B, C, D, and E.\nClassful IPv4 Addresses Class A: For large networks. (First octet: 0-127, uses a /8 prefix) Class B: For medium-sized networks. (First octet: 128-191, uses a /16 prefix) Class C: For small networks. (First octet: 192-233, uses /24 prefix) Class D: For multicast addresses. Class E: For experimental purposes. Note that the classful addressing are obsolete, most modern networks use classless addressing (e.g., 192.168.1.0/28).\nConfiguring IPv4 Addresses On a Router Routers use interfaces with IPv4 addresses to commnunicate between networks. Here are some common use commands:\nshow ip interface brief: Shows a summary of interface statuses and their IP addresses. show ip interface [interface-name]: Shows detailed settings for a specific interface. no shutdown: Enables an interface (router interfaces are turned off by default.) ip address [ip-address] [netmask]: Assigns an IP address and a subnet mask to the interface. 8. Routing \u0026amp; Switch Interfaces ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/computer-networking/1-ccna/","summary":"1. Introduction to CCNA Exam Exam Topics CCNA Exam Topics Exam Instructions Cisco Exam Tutorial Question Types YOU CAN\u0026rsquo;T GO BACK AFTER ANSWERING OR SKIPPING A QUESTION.\nCCNA Question Types Online Testing A PRIVATE and QUITE place for AT LEAST 2 HOURS must be needed.\nOnline Testing Cisco Packet Tracer Installation Cisco Packet Tracer Installation (Login First) Schduling and Taking the Exam Scheduling And Taking the Exam Exam Prep: Binary Game Binary Game 2.","title":"Cisco Certified Networking Associate (CCNA)"},{"content":"リスニング 音楽 ブルー・ライト・ヨコハマ Your browser does not support the audio element. 歌詞見せて 街（まち『き』）の灯（あか）りが　とてもきれいね\nThe city lights are so beautiful\n城市的灯光如此美丽\nヨコハマ　ブルー・ライト・ヨコハマ\nYokohama, Blue Light Yokohama\n横滨，蓝色之光横滨\nあなたと二人　幸せよ\nWith you, I\u0026rsquo;m so happy\n与你在一起 多么幸福\nいつものように　愛のことばを\nAs always, whisper words of love\n像往常一样 请对我说爱的蜜语\nヨコハマ　ブルー・ライト・ヨコハマ\nYokohama, Blue Light Yokohama\n横滨，蓝色之光横滨\n私にください　あなたから\nPlease say them to me, my darling\n请对我说 亲爱的\n歩いても　歩いても\nNo matter how far we walk\n无论走多远\n小舟（こぶね）（）のように　わたしはゆれて\nI sway like a little boat\n我像小船般摇曳\nゆれて　あなたの腕の中\nSwaying in your arms\n摇曳在你怀中\n足音（あしおと）だけが　ついて来るのよ\nOnly our footsteps follow us\n唯有脚步声相随\nヨコハマ　ブルー・ライト・ヨコハマ\nYokohama, Blue Light Yokohama\n横滨，蓝色之光横滨\nやさしいくちづけ　もういちど\nGive me your tender kiss once more\n请再给我一个温柔的吻\n歩いても　歩いても\nNo matter how far we walk\n无论走多远\n小舟（こぶね）のように　わたしはゆれて\nI sway like a little boat\n我像小船般摇曳\nゆれて　あなたの腕の中\nSwaying in your arms\n摇曳在你怀中\nあなたの好きな　タバコの香（かお）り\nThe scent of your favorite tobacco\n你喜爱的烟草香气\nヨコハマ　ブルー・ライト・ヨコハマ\nYokohama, Blue Light Yokohama\n横滨，蓝色之光横滨\n二人の世界　いつまでも\nMay our world last forever\n愿我们的世界永存\n文法 １−５ SHOW NOTES だげ：だげ is used to express that something is the only thing. これだけください。（Just this one, please.） お酒が飲めません、ダイエットコーラだけ飲みます。（I can\u0026rsquo;t drink wine, I only drink diet coke.） だろう：だろう is often used to show a guess or assumption. It\u0026rsquo;s a more casual form of でしょう. 彼は来るでしょう。（He will probably come.） 彼女は10年も韓国に住んでいるので韓国語は上手だろう。（She has been living in Korea for 10 years, so she\u0026rsquo;s probably good at Korean.） でしょう：でしょう is used to express probability or expectation. 彼は忙しいでしょう。（He is probably busy.） 日本人が晩ごはんによく食べるものは寿司でしょう。（Japanese people probably eat sushi a lot for dinner.） が：が is a conjunction used to introduce a contrast or contradiction. It is used between two clauses to show contrast. 新しいパソコンを買いたいが、お金がない。（I want to buy a new computer, but I have no money.） 行きたいが、時間がない。（I want to go, but I don\u0026rsquo;t have time.） がある：がある is used to express the existence of something, particularly for inanimate objects or abstract things. その町には古いお城がある。（There is an old castle in that town.） 公園に大きな木がある。（There is a big tree in the park.） ６−１０ Your browser does not support the audio element. SHOW NOTES ほうがいい：ほうがいい is used to suggest that something is the better choice or the more advisable action. 早く寝たほうがいい。（It\u0026rsquo;d be better to go to bed early.） 願書（がんしょ）を早く送るほうがいいですよ。（You should better send your application form quickly.） けれども：けれども is used to contrast two ideas. It can be shortened to けど or けれど in casual speech. 今日は忙しいけれども、手伝います。（I\u0026rsquo;m busy today, but I\u0026rsquo;ll help.） 雨が降っているけど、出かけなければならない。（It\u0026rsquo;s raining, but I have to go out.） くらい/ぐらい：くらい/ぐらい is used to indicate an approximate amount or degree of something. ２時間くらいかかると思います。（I think it will take about two hours.） ここから新高円寺駅まで歩いでどのくらいかかりますか？（How long does it take to walk from here to Shinkoenji station?） 前に：前に is used to indicate that something happened or should happen before another action. 寝る前に薬を飲んでください。（Please take the medicine before you go to bed.） 出発する前に確認してください。（Please check before you depart.） ませんか：ませんか is a polite way to invite someone to do something or to suggest an action. お茶を飲みませんか？（Won\u0026rsquo;t you have some tea?） 明日東京ディズニーランドに行くませんか。（Won\u0026rsquo;t you go to Tokyo Disneyland tomorrow?） １１−１５ SHOW NOTES な：な is a casual or firm way to tell someone not to do something. It\u0026rsquo;s often used in commands or warnings. ここにいるな！（Don\u0026rsquo;t enter here!） 俺の息子を虐（いじ）めるな！（Don\u0026rsquo;t bully my son!） ないでください：ないでください is a polite way to ask someone not to do something. 写真を撮らないでください。（Please don\u0026rsquo;t take photos.） ここでタバコを吸わないでください。（Please don\u0026rsquo;t smoke here.） なる：なる means \u0026ldquo;to become\u0026rdquo; and is used when something changes into a different state. 日本語が上手なりました。（I became good at Japanese.） １５時間も寝たので、頭が痛くなった。（I slept for 15 hours so I have a headache.） に行く：に行く is used when going somewhere to do something. It\u0026rsquo;s commonly used to express purpose. コンビニへパンを買いに行きます。（I\u0026rsquo;m going to the convenience store to buy bread.） 薪（まき）を集（あつ）めに行こう！（Let\u0026rsquo;s go pick up firewood!） にする：にする means to decide on something, it\u0026rsquo;s commonly used when making a choice. どれにしますか？（Which one will you choose?） 僕はコーヒーにします。（I\u0026rsquo;ll have coffee.） １６−２０ SHOW NOTES のが上手：のが上手 is used to express being good at something. 私は料理を作るのが上手です。（I\u0026rsquo;m good at cooking.） 彼はピアノを弾くのが上手だ。（He\u0026rsquo;s good at playing the piano.） のが下手：のが下手 is used to express being bad at something. 私はスポーツをするのが下手です。（I\u0026rsquo;m bad at sports.） 私は絵を描くのがすごく下手です。（I\u0026rsquo;m terrible at painting.） すぎる：すぎる is used to express that something is too much or excessive. It is attached to the stem of an adjective or verb to indicate that something goes beyond what is normal or acceptable. この料理は辛すぎる。（This food is too spicy.） その鞄は高すぎるから、買えない。（I can\u0026rsquo;t buy that bag because it\u0026rsquo;s too expensive.） たことがある：たことがある is used to express that you have done something before. 日本に行ったことがあります。（I have been to Japan before.） 寿司を食べたことがありますか？（Have you ever eaten sushi?） てもいい：てもいい is used to give permission or to say that is okay to do something. ここで写真を撮ってもいいですか？（Is it okay to take photos here?） この本を借りてもいいですか？（Can I borrow this book?） ２１−２５ Your browser does not support the audio element. SHOW NOTES てから：てから is used to express that one action happens after another. ご飯を食べてから勉強します。（I will study after eating.） 家に帰ってから電話をかけます。（I will make a call after I get home.） てはいけない：てはいけない is used to indicate that something is forbidden. ここて写真を撮ってはいけません。（You must not take pictures here.） 嘘をついてはいけない。（You must not tell lies.） つもりだ：つもりだ is used to express that you plan to do something. 今夜は早く寝るつもりです。（I plan to sleep early tonight.） 週末に映画を見に行くつもりだ。（I plan to go watch a movie this weekend.） より〜方が〜：より〜方が〜 is used to compare two things, indicating that one thing is more than the other in some way. この本の方があの本より面白い。（This book is more interesting than that book.） 英語より日本語の方が難しいと思う。（I think Japanese is more difficult than English.） あまり〜ない：あまり〜ない is used to express that something is not very much or not very often. It\u0026rsquo;s typically used with negative verbs to indicate a low frequency or degree of something. 鶏肉はあまり好きじゃないです。（I don\u0026rsquo;t like chicken very much.） 私はあまり映画を見ない。（I don\u0026rsquo;t watch movies very often.） ２６−３０ Your browser does not support the audio element. SHOW NOTES ば：ば is used to indicate a conditional situation, meaning \u0026ldquo;if\u0026hellip;then.\u0026rdquo; For る-verbs, drop る and add れば; for う-verbs, change the last syllable to the corresponding え-column sound and add ば; For い-adjective, drop the い and add ければ; For noun or な-adjectives, add であれば. 雨が降れば、行きません。（If it rains, I won\u0026rsquo;t go.） もっと勉強すれば、合格するでしょう。（If you study more, you will probably pass.） ばあい（場合）は：ばあい（場合）は is used to describe a situation or condition, especially when considering what happens in certain circumstances. It\u0026rsquo;s similar to \u0026ldquo;in the event of\u0026rdquo; or \u0026ldquo;if\u0026rdquo; in English. 急な用事がある場合は、連絡してください。（In the event of an emergency, please contact me.） 天気が悪い場合は、外に出ない方がいいです。（If the weather is bad, it\u0026rsquo;s better not to go outside.） だけて：だけて is used to express that something is possible just by doing or simply by doing something. It emphasizes that the action alone is enough to achieve the result. このボタンを押（お）すだけで、機械が動（うご）きます。（Just by pressing this button, the machine will start.） 彼は笑（わら）うだけで、みんなを幸せにします。（Just by smilling, he makes everyone happy.） 出（だ）す：出（だ）す is used to indicate that something suddenly begins or appears. It can also be used for starting an action unexpectedly or without warning. 彼女は怒（おこ）り出した。（She suddenly got angry.） 彼は急に走り出した。（He suddenly started running.） でも：でも is used to give a suggestion in a casual way. It\u0026rsquo;s used to list examples when you\u0026rsquo;re not sure or to make a suggestion about a possible action. 映画でも見ませんか？（How about watching a movie or something?） コーヒーでも飲みましょうか？（Shall we drink coffee or something?） ３１−３５ Your browser does not support the audio element. SHOW NOTES でございます：でございます is a polite form of です. 私はサラリーマンでございます。（I am a salaryman.） こちらは私の友人でございます。（This is my friend.） がる：がる is used when talking about someone\u0026rsquo;s feelings, emotions, or desires. It is attached to the stem of an adjective to indicate that someone else appears to feel or shows signs of that emotion. 彼は怖がっているようです。（He seems to be scared.） 子供はおもちゃを欲しがっている。（The child seems to want a toy.） がする：がする is used when perceiving something through five senses (taste, smell, hearing, etc.). 何かの音がする。（I hear some sound.） このスープは苦い味がする。（This soup tastes bitter.） 始める：始める is used to express the beginning of an action. 明日からダイエットを始める予定です。（I plan to start dieting from tomorrow.） 生け花（いけばな）を習（なら）い始めて、もう半年経った。（It\u0026rsquo;s been half a year since I started learning flower arrangement.） はず（筈）がない：はず（筈）がない is used to express that something is impossible or cannot possibly be the case. そんな難しい問題は小学生ができるはずがない。（There\u0026rsquo;s no way an elementary school student can answer such a difficult question.） 彼女はそんなことをするはずがない。（There\u0026rsquo;s no way she would do such a thing.） ３６−４０ Your browser does not support the audio element. SHOW NOTES 必要：必要 means \u0026ldquo;necessary\u0026rdquo; or \u0026ldquo;need\u0026rdquo;. It\u0026rsquo;s used to describe something that is required or essential. この手続（てつづ）きは必要です。（This procedure is necessary.） あなたには助（たす）けが必要です。（You need help.） 必要がある：必要がある means \u0026ldquo;it is necessary to\u0026rdquo; or \u0026ldquo;there is a need to\u0026rdquo;. It\u0026rsquo;s used when talking about something that is required or essential. 彼と話す必要がありますか？（Is it necessary to talk to him?） 報告書を提出する必要がある。（It is necessary to submit the report.） いらっしゃる：いらっしゃる is a polite version of the verbs いる, 来る, and 行く. It is a polite way to express the idea of someone else\u0026rsquo;s presence, arrival, and departure. 先生がいらっしゃいました。（The teacher has arrived.） 今日は何時にいらっしゃいますか？（What time will you come today?） いたす：いたす is a polite version of する, and it\u0026rsquo;s often used in customer service, business, and formal speech. この仕事は私がいたします。（I\u0026rsquo;ll do this job.） 荷物は私が来週の月曜日にお届（とど）けいたします。（I\u0026rsquo;ll send the luggages next Monday.） かどうか：かどうか is used to express \u0026ldquo;whether or not\u0026rdquo; something happens or is the case. It\u0026rsquo;s used when someone unsures about something and want to ask about or talk about the uncertainty. 彼が来るかどうか分からない。（I don\u0026rsquo;t know whether or not he will come.） それが本当かどうか教えてください。（Please tell me whether or not that is true.） ４１−４５ Your browser does not support the audio element. SHOW NOTES かい：かい is a casual way of turning a sentence into a yes/no question. It\u0026rsquo;s commonly used in informal scenarios. 君はこの仕事を好きかい？（Do you like this job?） 心配事（しんぱいごと）があるのかい？（Anything worrying you?） かもしれない：かもしれない is used to express possibility or uncertainty. 雨が降るかもしれない。（It might rain.） これは難しいかもしれません。（This might be difficult.） 方：方 is used to indicate how to do something or to give directions on how to do something. It\u0026rsquo;s often used with verbs to explain the way of doing something. この料理の作り方を知りたい。（I want to know how to make this dish.） 彼はピアノの弾き方を教えています。（He is teaching how to play the piano.） かしら：かしら is a feminine and somewhat casual expression used to convey a sense of wondering or uncertainty. It\u0026rsquo;s often used when the speaker is unsure or curious about something. It is mainly used by women, but can also used in certain contexts by men in informal speech. 明日天気はどうかしら。（I wonder what the weather will be like tomorrow.） これで大丈夫かしら。（I wonder if this is okay.） ことができる：ことができる is used to express ability or possibility and means \u0026ldquo;can\u0026rdquo; or \u0026ldquo;be able to\u0026rdquo; in English. 日本語を話すことができる。（I can speak Japanese.） 明日早く起きることができない。（I can\u0026rsquo;t wake up early tomorrow.） ４６−５０ Your browser does not support the audio element. SHOW NOTES までに：までに is used to indicate a deadline or the latest time by which something must be done. 夜10時までに帰ります。（I will return home by 10 PM.） レポートを金曜日までに提出してください。（Please submit the report by Friday.） みたい：みたい is used to say that something looks like, seems like, or resembles something else. 彼は子供みたいです。（He\u0026rsquo;s like a child.） 雨が降るみたいよ。（It looks like it\u0026rsquo;s going to rain.） など is used to list examples or suggest that there are other similar things not explicitly mentioned. It means \u0026ldquo;such as,\u0026rdquo; \u0026ldquo;things like,\u0026rdquo; or \u0026ldquo;etc.\u0026rdquo; 寿司やラーメンなど好きです。（I like sushi, ramen and things like that.） 果物はリンゴやバナナなど好きです。（I like fruits such as apple and banana.） ながら：ながら is used to indicate two actions happening at the same time. 音楽を聞きながら勉強します。（I study while listening to music.） 彼はテレビを見ながらご飯を食べている。（He is eating while watching TV.） ないで：ないで is used to indicate doing something without another action happening. 宿題をしないで寝ました。（I went to sleep without doing my homework.） 傘を持たないで出かけた。（I went out without bringing an umbrella.） ５１−５５ Your browser does not support the audio element. SHOW NOTES なければいけない/なければならない：なければいけない/なければならない are used to express that something is necessary or that someone must do something. 早く起きなければいけない。（I must wake up early.） 宿題を終わらせなければならない。（I have to finish my homework.） なくてはいけない/なくてはならない：なくてはいけない/なくてはならない are used to express that something is necessary or that someone must do something. このレポートを提出しなくてはいけない。（I must submit this report.） パソコンを修理しなくてはならない。（I have to fix the computer.） なくてもいい：なくてもいい is used to express that something is not necessary or that someone doesn\u0026rsquo;t have to do something. 遅くまで勉強しなくてもいい。（You don\u0026rsquo;t have to study until late.） 今日は仕事に行かなくてもいい。（You don\u0026rsquo;t have to go to work today.） なら：なら is used to express conditional situations, similar to \u0026ldquo;if\u0026rdquo; in English. It can also imply a situation where something will happen or be true under certain conditions. 行くなら、早く行った方がいいよ。（If you are going, you should go early.） その話なら、知っている。（As for that story, I know it.） なさい：なさい is a polite imperative used to give an order or instruction. It is often used by adults when giving commands to chindren or subordinates. 早く寝なさい。（Go to bed early.） 野菜も食べなさい。（Eat your vegetables too!） ５６−６０ Your browser does not support the audio element. SHOW NOTES なさる：なさる is the polite version of する. お飲み物は何になさいますか？（What would you like to drink?） 先生は何をお話しなさっていますか？（What is the teacher talking about?） に気がつく：に気がつく means \u0026ldquo;to notice\u0026rdquo; pr \u0026ldquo;to realize\u0026rdquo; something. It is used when someone becomes aware of something that they hadn\u0026rsquo;t noticed before. 彼のミスに気がついた。（I noticed his mistake.） 日本に来てから、自分の日本語が上達していることに気がついた。（After coming to Japan, I realized that my Japanese was improving.） にくい：にくい indicates that something is difficult to do. この漢字は覚えにくい。（This kanji is hard to remember.） 彼の話し方は聞きにくい。（His way of speaking is hard to understand.） に見える：に見える is used to describe how something appears or looks like based on its appearance. 彼は若く見える。（He looks young.） この料理は美味しく見えるけど、あまり美味しくない。（This dish looks delicious, but it\u0026rsquo;s not very tasty.） の中で：の中で is used to indicate something inside a place. この三つの中で、どれが一番好きですか？（Among these three, which do you like the most?） クラスの中で、彼が一番背が高い。（Among the class, he is the tallest.） ６１−６５ Your browser does not support the audio element. SHOW NOTES のに：のに is used to indicate a reason or purpose, similar to \u0026ldquo;for the purpose of\u0026rdquo; in English. 旅行に行くのにお金がかかる。（It costs money to go on a trip.） 日本語を話すのに練習が必要です。（You need to practice to speak Japanese.） のように/のような：のように/のような are used to compare something to another thing, meaning \u0026ldquo;like\u0026rdquo; or \u0026ldquo;similar to\u0026rdquo;.　のように is used with verbs or adjectives while のような is used with nouns. 彼女は天使のように優しい。（She is as kind as an angel.） あなたのような人は珍しい。（A person like you is rare.） おきに：おきに is used to express repetition of an event at regular intervals, such as \u0026ldquo;every\u0026rdquo; in English. ２時間おきに休憩を取る。（Take a break every two hours.） 一週間おきに会議を開きます。（We hold meetings every week.） のに：のに is used to express contradiction or contrast. It means \u0026ldquo;although\u0026rdquo; or \u0026ldquo;in spite of\u0026rdquo;, often leading to an outcome that is unexpected or goes against the initial expectation. 彼は日本に住んでいるのに、全然日本語が話せない。（Although he lives in Japan, he can\u0026rsquo;t speak Japanese at all.） あんなに勉強するしたのに、テストに合格しなかった。（Even though I studied so much, I didn\u0026rsquo;t pass the test.） 終わる：終わる means \u0026ldquo;to finish\u0026rdquo; or \u0026ldquo;to end\u0026rdquo;, used when something is completed or comes to an end. 授業が終わった。（The class ended.） 仕事が終わるのが楽しみだ。（I\u0026rsquo;m looking forward to finish work.） ６６−７０ Your browser does not support the audio element. SHOW NOTES られる：られる is used to express the ability to do something. 日本語が話せられますか？（Can you speak Japanese?） ピアノが弾ける。（I can play the piano.） らしい：らしい is used to express a sense of hearsay or something that seems like or appears to be based on indirect information or impression. あの人はとても優しいらしい。（That person seems to be very kind.） 彼女は旅行に行くらしいです。（I heard that she\u0026rsquo;s going on a trip.） さ：さ is a nominalizer used to turn an adjective into a noun. It converts the quality or state expressed by the adjective into a concept or thing. 富士山の高さは３７７６メートルだ。（Mount Fuji\u0026rsquo;s height is 3776 meters.） 彼女の優しさに感動した。（I was moved by her kindness.） られる：られる can also be used to express the passive voice, meaning that the subject of the sentence is the receipient of an action rather than the one performing it. 私は先生に褒められた。（I was praised by the teacher.） この本は多くの人に読まれている。（This book is being read by many people.） させる：させる is the causative form, meaning \u0026ldquo;to make\u0026rdquo; someone do something. It expresses the idea of forcing or allowing someone to perform an action. 母は私に掃除させる。（My mother makes me do the cleaning.） 先生は学生に宿題をさせる。（The teacher makes the students do homework.） ７１−７５ Your browser does not support the audio element. SHOW NOTES させられる：させられる is the passive causative form, meaning \u0026ldquo;to be made to do something\u0026rdquo; or \u0026ldquo;to be forced to do something\u0026rdquo;. It is used to express that someone is forced or made to perform an action by someone else. 毎日残業させられる。（I\u0026rsquo;m made to work overtime every day.） 子供の時、嫌いな野菜を食べさせられだ。（As a child, I was made to eat vegetables I hated.） さすが：さすが is used to express admiration or to indicate that something or someone is worthy of praise or recognition, just as expected. It\u0026rsquo;s used when the result or behavior is exactly what one would expect from the person or thing in question. さすがプロだね。（As expected of a professional!） さすが日本の料理は美味しい。（As expected, Japanese food is delicious.） しか〜ない：しか〜ない means \u0026ldquo;only\u0026rdquo; or \u0026ldquo;nothing but\u0026rdquo;. It is used to emphasize a limitation or a small quantity of something. １００円しか持っていない。（I only have 100 yen.） この店にはケーキしかない。（This shop only has cake.） し〜し：し〜し is used to like multiple reasons or actions, similar to \u0026ldquo;and\u0026rdquo; in English. 彼女は親切だし、頭もいいし、頼りにしている。（She\u0026rsquo;s kind, smart, and I rely on her.） この映画は面白い、感動的だし、みんなにおすすめだ。（This movie is interesting, emotional, and I recommend it to everyone.） そんなに：そんなに is used to refer to something that is \u0026ldquo;like that\u0026rdquo; or \u0026ldquo;so much\u0026rdquo;. It can be used to indicate a large extent or degree of something, usually negative in tone. そんなに急がなくてもいいよ。（You don\u0026rsquo;t need to hurry so much.） そんなにたくさん食べるの？（Are you going to eat that much?） ７６−８０ Your browser does not support the audio element. SHOW NOTES それでも：それでも is used to express a contradiction or unexpected continuation of an action or situation despite the circumstances. It means \u0026ldquo;but still\u0026rdquo; or \u0026ldquo;and yet\u0026rdquo; in English. 雨が降っている。それでも、彼は外に出た。（It\u0026rsquo;s raining, but still, he went outside.） お金が足りない。それでも、旅行に行きたい。（I don\u0026rsquo;t have enough money. And yet, I want to go on a trip.） そうだ：そうだ is used to report hearsay or something heard from others. It can be used to confirm something that have been seen or heard. It\u0026rsquo;s similar to saying \u0026ldquo;I heard that\u0026rdquo; or \u0026ldquo;It seems that\u0026rdquo; in English. 明日は雨が降るそうだ。（I heard that it will rain tomorrow.） あの店のケーキは美味しいそうだ。（I heard that the cake at that shop is delicious.） たばかり：たばかり is used to indicate that something just happened or was just completed. It\u0026rsquo;s used to describe a recent action. 彼は家に帰ったばかりだ。（He just got home.） 私は昼ご飯を食べたばかりだ。（I just ate lunch.） たがる：たがる is used to express that someone else wants to do something. It\u0026rsquo;s often used when talking about other people\u0026rsquo;s desires. 彼は映画に行きたがっている。（He wants to go to the movie.） 彼女は新しい服を買いたがっている。（She wants to buy new clothes.） たら：たら is a conditional form that means \u0026ldquo;if\u0026rdquo; or \u0026ldquo;when\u0026rdquo;. It is used to express a condition or hypothetical situation. It can also mean \u0026ldquo;after doing\u0026rdquo; when the action is completed. もしお金があったら、旅行に行きたい。（If I had money, I would want to go on a trip.） 終わったら、帰ってもいいですか。（Can I go home after I finish?） ８１−８５ Your browser does not support the audio element. SHOW NOTES たらどうですか：たらどうですか is used to give a suggestion or advice to someone. It means \u0026ldquo;Why don\u0026rsquo;t you\u0026hellip;?\u0026rdquo; or \u0026ldquo;How about\u0026hellip;?\u0026rdquo; in English. It is a way to encourage someone to take a certain action. もっと休んだらどうですか。（Why don\u0026rsquo;t you rest more?） それを試してみたらどうですか。（Why don\u0026rsquo;t you try that?） たり〜たり：たり〜たり is used to list multiple actions or states, indicating that the speaker is talking about things that happen intermittently or alternately. 週末は映画を見たり、友達と遊んだりします。（On weekends, I watch movies and hang out with friends.） 夏休みには海に行ったり、山に登ったりしました。（During summer vacation, I went to the beach and climbed mountains.） たところ：たところ is used to indicate that something has just happened or just finished. It often emphasizes that the action was completed recently. 今昼ごはんを食べたところです。（I just finished eating lunch.） 彼はテストを終えたところです。（He just finished the test.） てあげる：てあげる is used when doing something for someone else, often to be helpful or show kindness. It\u0026rsquo;s used in situations where the speaker is performing an action for the benefit of someone else. 彼に本を貸してあげる。（I\u0026rsquo;ll lend him a book.） 私はあなたにその問題を説明してあげます。（I\u0026rsquo;ll explain the problem to you.） てほしい：てほしい is used to express that you want or need someone to do something. It shows a desire for someone to perform an action, often related to the speaker\u0026rsquo;s own wishes. 私に手伝ってほしい。（I want you to help me.） 彼女には元気になってほしい。（I want her to get better.） ８６−９０ Your browser does not support the audio element. SHOW NOTES ていく：ていく is used when an action begins now and continues into the future, or when something moves away from the speaker\u0026rsquo;s point of view. これからも日本語を勉強していきます。（From now on, I will keep studying Japanese.） 子供達は走って行った。（The children ran off.） ているところ：ているところ is used to describe that someone is right in the middle of doing something. 今昼ごはんを食べているところです。（I\u0026rsquo;m in the middle of eating lunch right now.） レポートを書いているところだった。（I was just writing the report.） ていただけませんか：ていただけませんか is a polite way to make a request, similar to \u0026ldquo;Could you please\u0026hellip;?\u0026rdquo; in English. これを見ていただけませんか。（Could you please look at this?） もう一度説明していただけませんか。（Could you please explain that one more time?） てくれる：てくれる is used when someone does something beneficial for the speaker. 母がセーターを編んでくれました。（My mother knitted me a sweater.） 友達が空港まで送ってくれた。（My friend drove me to the airport.） てくる：てくる is used to describe an action coming toward the speaker, a change or development over time, or an action/state that has continued up until the present. わかってきました。（It\u0026rsquo;s becoming clear.） 最近寒くなってきましたね。（It\u0026rsquo;s been getting colder lately.） ９１−９５ Your browser does not support the audio element. SHOW NOTES てみる：てみる is used to express trying out or attempting an action to see how it works, often implying the result is uncertain or the action is experimental. 新しいレストランに行ってみる。（I\u0026rsquo;ll try going to the new restaurant.） この方法を試してみてください。（Please try this method.） てもらう：てもらう is used when someone does something for the speaker, often implying a favor or request. The focus is on receiving the action done by someone else. 先生に教えてもらった。（I got the teacher to teach me.） 友達に手伝ってもらいました。（I got my friend to help me.） ておく：ておく is used to indicate that an action will be done in preparation for something, or to indicate that an action is done in advance to be ready for a future situation. 明日の会議のために資料を作っておきます。（I will prepare the materials in advance for tomorrow\u0026rsquo;s meeting.） 出かける前にお金を置いておく。（I\u0026rsquo;ll leave the money here before going out.） てしまう：てしまう is used when doing something unintentionally or finishing an action completely. 宿題を忘れてしまった。（I accidentally forgot my homework.） 本を全部読んでしまった。（I finished reading the whole book.） てよかった：てよかった is used to express relief, happiness, or gratitude for something that has already happened. It reflects a positive outcome or a favorable result. 傘を持ってきてよかった。（I\u0026rsquo;m glad I brought an umbrella.） あなたに会えてよかった。（I\u0026rsquo;m glad I could meet you.） ９６−１００ Your browser does not support the audio element. SHOW NOTES ということ：ということ is used to turn a statement or action into a noun, often referring to the content of the sentence. 彼が来ないということを聞きました。（I heard that he won\u0026rsquo;t come.） 日本に行くということはとても楽しみです。（The fact that I will go to Japan is very exciting.） といってもいい：といってもいい is used to suggest that something is valid or acceptable way to express something. これは簡単だといってもいいです。（You could say this is easy.） 彼はプロフェッショナルだといってもいいでしょう。（You might say he is a professional.） とか〜とか：とか〜とか is used to list examples of things, usually with the implication that there are more examples not explicitly mentioned. It can be translated as \u0026ldquo;such as\u0026rdquo; or \u0026ldquo;among other things.\u0026rdquo; 映画とか音楽とかが好きです。（I like things such as movies and music.） 休日は映画を見るとか、買い物するとかしています。（On holidays I do things like watching movies and shopping.） ときいた：ときいた is used to report something that was heard from another person, typically in casual or indirect speech. This expression can be used when sharing information learned from someone else. 彼がもうすぐ帰ると聞いた。（I heard that he is going home soon.） 明日雨が降ると聞いたんですが、本当ですか。（I heard it will rain tomorrow, is that true?） ところ：ところ is used to express that something is about to happen, indicating that an action is just about to start or is on the verge of happening. It can also be used in the past tense to show that something was just about to happen at a certain moment. 食事を始めるところです。（We\u0026rsquo;re about to start eating.） テレビを見ているところに電話がかかってきた。（Just when I was watching TV, the phone rang.） １０１ SHOW NOTES In Japanese, verbs are categorized into three groups based on their conjugation patterns. Group 1(五段動詞, ごだんどうし) verbs end in a u sound, such as 書く (to write) and 話す (to speak). Group 2 (一段動詞, いちだんどうし) verbs end in \u0026ldquo;ru\u0026rdquo; and the preceding vowel is either from the i or e row, such as 食べる (to eat) and 見る (to see). Group 3 (不規則動詞, ふきそくどうし) consists of irregular verbs, including する (to do) and 来る (to come). To form the ます-form of Japanese verbs, the conjugation rules differ depending on the verb group. For Group 1(五段動詞, ごだんどうし) verbs, the final u sound is replaced with the corresponding i sound followed by ます. For example, 書く (to write) becomes 書きます (to write, polite). For Group 2 (一段動詞, いちだんどうし) verbs, which end in ru, simply drop the ru and add ます. For example, 食べる (to eat) becomes 食べます (to eat, polite). For Group 3 (不規則動詞, ふきそくどうし) irregular verbs, する (to do) becomes します (to do, polite), and 来る (to come) becomes 来ます (to come, polite). To form the て-form of Japanese verbs, the conjunction rules differ depend on the verb group. For Group 1(五段動詞, ごだんどうし) verbs, the final sound of the verb is replaced with a specific pattern: verbs ending in く become いて (e.g., 書く → 書いて, an exception for 行く『行って』), ぐ becomes いで (e.g., 泳ぐ → 泳いで), and verbs ending in う, つ, or る become って (e.g., 買う → 買って, 待つ → 待って, 帰る → 帰って). For verbs ending in ぬ, ぶ, or む, the final sound changes to んで (e.g., 死ぬ → 死んで, 遊ぶ → 遊んで, 読む → 読んで). For Group 2 (一段動詞, いちだんどうし) verbs, which end in ru, the ru is dropped and replaced with て. For example, 食べる (to eat) becomes 食べて (eating). For Group 3 (不規則動詞, ふきそくどうし) irregular verbs, する (to do) becomes して (doing), and 来る (to come) becomes 来て (coming). To form the た-form of Japanese verbs, the conjunction rules differ depend on the verb group. For Group 1(五段動詞, ごだんどうし) verbs, the final sound of the verb is replaced with a specific pattern: verbs ending in く become いた (e.g., 書く → 書いた), ぐ becomes いだ (e.g., 泳ぐ → 泳いだ), and verbs ending in う, つ, or る become った (e.g., 買う → 買った, 待つ → 待った, 帰る → 帰った). For verbs ending in ぬ, ぶ, or む, the final sound changes to んだ (e.g., 死ぬ → 死んだ, 遊ぶ → 遊んだ, 読む → 読んだ). For Group 2 (一段動詞, いちだんどうし) verbs, the \u0026ldquo;ru\u0026rdquo; ending is dropped, and ta is added directly. For example, 食べる (to eat) becomes 食べた (ate) and 見る (to see) becomes 見た (saw). For Group 3 (不規則動詞, ふきそくどうし) irregular verbs, する (to do) becomes した (did), and 来る (to come) becomes 来た (came). To form the ない-form of Japanese verbs, the conjugation rules vary depending on the verb group. For Group 1(五段動詞, ごだんどうし) verbs, the final u sound is replaced with the corresponding a sound, followed by ない. For example, 書く (kaku) becomes 書かない (to not write). An exception is the verb ある (to exist, for inanimate objects), which becomes ない (does not exist). For Group 2 (一段動詞, いちだんどうし) verbs, the ru is droupped and ない is added directly, such as 食べる (to eat) becomeing 食べない (to not eat). For Group 3 (不規則動詞, ふきそくどうし) irregular verbs, する (to do) becomes しない (to not do), and　来る (to come) becomes 来ない (to not come). To form the potential form of Japanese verbs, the conjugation rules differ by verb group. For Group 1(五段動詞, ごだんどうし) verbs, the final u sound is replaced with the corresponding e sound, followed by る. For example, 書く (to write) becomes 書ける (can write). For Group 2 (一段動詞, いちだんどうし) verbs, the ru is dropped and られる is added, such as 食べる (to eat) becoming 食べられる (can eat). For Group 3 (不規則動詞, ふきそくどうし) irregular verbs, する (to do) becomes できる (can do), and 来る (to come) becomes 来られる (can come). To form the imperative form of Japanese verbs, the conjugation rules vary depending on the verb group. For Group 1(五段動詞, ごだんどうし) verbs, the final u sound is replaced with the corresponding e sound. For example, 書く (to write) becomes 書け (write!). For Group 2 (一段動詞, いちだんどうし) verbs, the ru is dropped and ろ and よ is added, such as 食べる (to eat) becoming 食べろ (eat!). For Group 3 (不規則動詞, ふきそくどうし) irregular verbs, する (to do)　becomes しろ or せよ (do!), and 来る (to come) becomes 来い (come!) To form the volitional form (intended action or suggestion) of Japanese verbs, the conjugation rules depend on the verb group. For Group 1(五段動詞, ごだんどうし) verbs, the final u sound is replaced with the corresponding o sound, followed by う. For example, 書く (to write) becomes 書こう (let\u0026rsquo;s write). For Group 2 (一段動詞, いちだんどうし) verbs, the ru is dropped and よう is added, such as 食べる　(to eat) becoming 食べよう (let\u0026rsquo;s eat). For Group 3 (不規則動詞, ふきそくどうし) irregular verbs, する (to do) becomes しよう (let\u0026rsquo;s do), and 来る (to come) becomes こよう (let\u0026rsquo;s come). Here are the top 30 most commonly used verbs:\nVerb (Infinitive) Polite Form (ます) Te-Form Past Tense (た) Negative (ない) Potential (できる) Imperative (Command) Volitional (Intentional) 行く (いく, to go) 行きます 行って 行った 行かない 行ける 行け 行こう 話す (はなす, to speak) 話します 話して 話した 話さない 話せる 話せ 話そう 聞く (きく, to listen) 聞きます 聞いて 聞いた 聞かない 聞ける 聞け 聞こう 書く (かく, to write) 書きます 書いて 書いた 書かない 書ける 書け 書こう 読む (よむ, to read) 読みます 読んで 読んだ 読まない 読める 読め 読もう 飲む (のむ, to drink) 飲みます 飲んで 飲んだ 飲まない 飲める 飲め 飲もう 買う (かう, to buy) 買います 買って 買った 買わない 買える 買え 買おう 会う (あう, to meet) 会います 会って 会った 会わない 会える 会え 会おう 待つ (まつ, to wait) 待ちます 待って 待った 待たない 待てる 待て 待とう 立つ (たつ, to stand) 立ちます 立って 立った 立たない 立てる 立て 立とう 遊ぶ (あそぶ, to play) 遊びます 遊んで 遊んだ 遊ばない 遊べる 遊べ 遊ぼう 帰る (かえる, to return) 帰ります 帰って 帰った 帰らない 帰れる 帰れ 帰ろう 死ぬ (しぬ, to die) 死にます 死んで 死んだ 死なない 死ねる 死ね 死のう 飛ぶ (とぶ, to fly) 飛びます 飛んで 飛んだ 飛ばない 飛べる 飛べ 飛ぼう 呼ぶ (よぶ, to call) 呼びます 呼んで 呼んだ 呼ばない 呼べる 呼べ 呼ぼう 泳ぐ (およぐ, to swim) 泳ぎます 泳いで 泳いだ 泳がない 泳げる 泳げ 泳ごう 急ぐ (いそぐ, to hurry) 急ぎます 急いで 急いだ 急がない 急げる 急げ 急ごう 笑う (わらう, to laugh) 笑います 笑って 笑った 笑わない 笑える 笑え 笑おう 洗う (あらう, to wash) 洗います 洗って 洗った 洗わない 洗える 洗え 洗おう 歌う (うたう, to sing) 歌います 歌って 歌った 歌わない 歌える 歌え 歌おう 食べる (たべる, to eat) 食べます 食べて 食べた 食べない 食べられる 食べろ/食べよ 食べよう 見る (みる, to see/look) 見ます 見て 見た 見ない 見られる 見ろ/見よ 見よう 寝る (ねる, to sleep) 寝ます 寝て 寝た 寝ない 寝られる 寝ろ/寝よ 寝よう 起きる (おきる, to wake up) 起きます 起きて 起きた 起きない 起きられる 起きろ/起きよ 起きよう 教える (おしえる, to teach) 教えます 教えて 教えた 教えない 教えられる 教えろ/教えよ 教えよう 出る (でる, to go out) 出ます 出て 出た 出ない 出られる 出ろ/出よ 出よう 着る (きる, to wear) 着ます 着て 着た 着ない 着られる 着ろ/着よ 着よう 借りる (かりる, to borrow) 借ります 借りて 借りた 借りない 借りられる 借りろ/借りよ 借りよう 降りる (おりる, to get off) 降ります 降りて 降りた 降りない 降りられる 降りろ/降りよ 降りよう 閉める (しめる, to close) 閉めます 閉めて 閉めた 閉めない 閉められる 閉めろ/閉めよ 閉めよう Your browser does not support the audio element. SHOW CONTENTS 彼は毎日、学校に行く。（He goes to school every day.） 明日、私は京都に行きます。（Tomorrow, I will go to Kyoto.） この道をまっすぐ行って、右に曲がってください。（Go straight on this road, then turn right.） 彼女は日本語で話すことができる。（She can speak Japanese.） 会議で詳しく話します。（I will talk in detail at the meeting.） 何か問題があれば、すぐに話して下さい。（If you have any problems, please speak up immediately.） 毎日、日記を書く。（I write in my diary every day.） このレポートを明日までに書きます。（I will write this report by tomorrow.） ノートに名前を書いてください。（Please write your name in the notebook.） 彼は海で泳ぐのが好きだ。（He likes to swim in the sea.） 夏休みに海で泳ぎます。（I will swim in the sea during summer vacation.） プールで泳いでから、シャワーを浴びます。（After swimming in the pool, I will take a shower.） 週末に新しい本を買う予定だ。（I plan to buy a new book this weekend.） 昨日、オンラインで服を買いました。（I bought clothes online yesterday.） スーパーで牛乳を買ってきてください。（Please buy some milk at the supermarket.） 彼を駅で待つつもりだ。（I intend to wait for him at the station.） ここで少し待ちます。（I will wait here for a while.） ちょっと待っていてください。（Please wait a moment.） 学校が終わったら、家に帰る。（After school is over, I will go home.） もうすぐ仕事が終わるので、家に帰ります。（Work is almost over, so I will go home.） 友達の家に行って、すぐに帰ってきた。（I went to my friend\u0026rsquo;s house and came back right away.） 毎朝、新聞を読むことにしている。（I make it a habit to read the newspaper every morning.） 彼女はよく小説を読みます。（She often reads novels.） 本を読んでから、映画を見に行こう。（Let\u0026rsquo;s read a book, then go watch a movie.） あなたをケパと呼ぶことにします。（I will call you \u0026lsquo;Kepa.\u0026rsquo;） 私は先生を呼びます。（I will call the teacher.） その名前を呼んでください。（Please call that name.） あの小さな花は死ぬかもしれない。（That small flower might die.） 老犬が静かに死にました。（The old dog passed away peacefully.） 彼は戦争で死んでしまった。（He died in the war.） 彼は部屋を出るとき、ドアを閉めました。（He closed the door when he left the room.） 彼女は駅で電車を出ます。（She will take the train at the station.） ちょっと出てくるから、待っていて。（I\u0026rsquo;ll step out for a moment, so please wait.） 新しいシャツを着ると気分が良くなる。（I feel good when I wear a new shirt.） 今日、きれいなドレスを着ます。（I will wear a beautiful dress today.） そのドレスを着て、パーティーに行きます。（I will wear that dress and go to the party.） 語彙 文字語彙 1. 家 Your browser does not support the audio element. SHOW NOTES 家計（かけい）：family finances 家計簿をつけることが大切です。（It\u0026rsquo;s important to keep a household budget.） 家で（する）（いえで）: to do something at home 家で勉強するのが好きです。（I like to study at home.） 実家（じっか）：one\u0026rsquo;s parents\u0026rsquo; house or family home 週末は実家に帰ります。（I will go back to my parents\u0026rsquo; house for the weekend.） 専門家（せんもんか）：expert 彼は専門家としてこの問題を解決しました。（He solved the problem as an expert.） 政治家（せいじか）：politician 政治家は国の未来を決める重要な役割を持っています。（Politicians play an important role in deciding the future of the country.） 建築家（けんちくか）：architect 彼は有名な建築家で、高層ビルを設計しました。（He is a famous architect who designed the skyscraper.） 農家（のうか）：farmer 農家の人々は自然とともに働いています。（Farmers work together with nature.） 起業家（きぎょうか）：entrepreneur 彼は起業家として新しいビジネスを立ち上げました。（He started a new business as an entrepreneur.） 家畜（かちく）：livestock 農場では家畜がたくさん飼われています。（There are many livestock on the farm.） 家柄（いえがら）：family background 彼は良い家柄の出身です。（He comes from a good family background.） 家来（けらい）：servant, retainer 戦国時代、大名には多くの家来がいた。（During the Warring States period, feudal lords had many retainers.） 家路（いえじ）：the way home 仕事が終わり、家路につきました。（After work, I headed home.） 大家（おおや）：landlord 大家さんに家賃を払いました。（I paid rent to the landlord.） 家賃（やちん）：rent このアパートの家賃は高いです。（The rent for this apartment is expensive.） 家具（かぐ）：furniture 新しいアパートに家具を揃えました。（I furnished my new apartment.） 核家族（かくかぞく）：nuclear family (A nuclear family refers to a family unit consisting of two parents (mother and father) and their children, living together independently from extended relatives like grandparents, uncles, or aunts.) 現代では核家族が増えています。（Nowadays, nuclear families are increasing.） 彼は核家族で両親と二人の子供と暮らしています。（He lives in a nuclear family with his parents and two children.） 家庭（かてい）：home, household 家庭を大切にすることが大事です。（It is important to value the home.） 家事（かじ）：household chores 毎日、家事を手伝っています。（I help with the household chores every day.） 家電（かでん）：home appliances 新しい家電製品を購入しました。（I purchased new home appliances.） 自家製（じかせい）：homemade 自家製のパンを作るのが好きです。（I like to make homemade bread.） 国家（こっか）：nation, state 国家の発展には教育が重要です。（Education is important for the development of a nation.） 2. 意 SHOW NOTES 意図（する）（いと）: intention, to intend 彼は意図的にその質問を避けました。（He intentionally avoided that question.） 意向（いこう）: intention, will 彼の意向を尊重するべきです。（We should respect his intentions.） 意識（する）（いしき）: awareness, to be conscious of 環境問題についてもっと意識する必要があります。（We need to be more aware of environmental issues.） 意欲（いよく）: willingness, eagerness 彼は新しいプロジェクトに強い意欲を持っています。（He has strong enthusiasm for the new project.） 決意（する）（けつい）: determination, to decide firmly 彼は新しい目標に向かって決意しました。（He made a firm decision to pursue a new goal.） 合意（する）（ごうい）: agreement, to agree 皆が合意してこのプランを実行することにしました。（Everyone agreed to implement this plan.） 用意（する）（ようい）: preparation, to prepare 旅行に行く前にしっかり用意をしておきましょう。（Let\u0026rsquo;s prepare thoroughly before going on the trip.） 意外な（いがいな）: unexpected, surprising 彼の意外な提案に驚きました。（I was surprised by his unexpected suggestion.） 意義（いぎ）: meaning, significance この研究の意義は非常に大きいです。（The significance of this research is very important.） 意地（いじ）: will, stubbornness 彼は意地を張って、謝ることを拒否しました。（He was stubborn and refused to apologize.） 極意（ごくい）: secret, essence 書道の極意を学ぶのは時間がかかります。（Learning the essence of calligraphy takes time.） 好意（こうい）: goodwill, favor 彼女は私に好意を持っているようです。（It seems like she has goodwill towards me.） 誠意（せいい）: sincerity 彼の誠意が伝わってきました。（His sincerity was conveyed.） 任意（にんい）: optional, voluntary このセミナーへの参加は任意です。（Participation in this seminar is optional.） 熱意（ねつい）: enthusiasm, zeal 彼の熱意に感動しました。（I was moved by his enthusiasm.） 不意（ふい）: sudden, unexpected 不意に雨が降り始めました。（Suddenly, it started to rain.） 意気込む（いきごむ）: to be eager, to be enthusiastic 彼は新しいプロジェクトに意気込んでいます。（He is enthusiastic about the new project.） 意気投合する（いきとうごうする）: to hit it off, to be of one mind 私たちはすぐに意気投合しました。（We hit it off right away.） 意地悪い（いじわるい）: mean, spiteful 彼は意地悪いことを言っていた。（He was saying mean things.） 注意深い（ちゅういぶかい）: careful, cautious 彼は注意深く周りを見ていました。（He was carefully observing his surroundings.） 不用意な（ふよういな）: careless, thoughtless 不用意な発言が問題を引き起こしました。（A careless remark caused the problem.） 故意に（こいに）: intentionally 彼は故意にその仕事を遅らせました。（He intentionally delayed the work.） 不注意（ふちゅうい）: negligence, carelessness 不注意で電話を落としてしまいました。（I dropped the phone due to carelessness.） 無意味（むいみ）: meaningless その議論は無意味でした。（That discussion was meaningless.） 厚意（こうい）: kindness, favor 彼の厚意に感謝します。（I appreciate his kindness.） 意見（いけん）: opinion あなたの意見を聞かせてください。（Please share your opinion.） 意志（いし）: will, intention 彼は強い意志を持っています。（He has a strong will.） 同意（どうい）: consent, agreement その提案に同意しました。（I agreed to the proposal.） 得意（とくい）: proficiency, skill 彼は数学が得意です。（He is good at math.） 3. 感 SHOW NOTES 感謝（する）（かんしゃ）: gratitude, to be thankful あなたの助けに感謝しています。（I am grateful for your help.） 感心（する）（かんしん）: admiration, to be impressed 彼の演技に感心しました。（I was impressed by his performance.） 直感（ちょっかん）: intuition 直感でその問題を解決しました。（I solved the problem by intuition.） 反感（はんかん）: antipathy, resentment 彼の態度に反感を持っています。（I have resentment towards his attitude.） 予感（する）（よかん）: premonition, to have a feeling 何か悪いことが起こりそうな予感がします。（I have a feeling that something bad is about to happen.） 直感的な（ちょっかんてきな）: intuitive 彼女の直感的な判断は正しかった。（Her intuitive judgment was correct.） 感触（かんしょく）: feeling, sensation この布の感触はとても柔らかいです。（The feeling of this fabric is very soft.） 感染（する）（かんせん）: infection, to infect 風邪が感染してしまいました。（I caught a cold.） 感銘（かんめい）: deep impression 彼の演説に感銘を受けました。（I was deeply impressed by his speech.） 感度（かんど）: sensitivity この機械は高い感度を持っています。（This machine has high sensitivity.） 感動（かんどう）: emotion, being moved その映画に感動しました。（I was moved by that movie.） 痛感（する）（つうかん）: to feel keenly この問題の重要性を痛感しています。（I feel keenly the importance of this issue.） 感無量（かんむりょう）: feeling deeply moved 卒業式での感無量な気持ちを忘れません。（I will never forget the deeply moved feeling at the graduation ceremony.） 敏感な（びんかんな）: sensitive 彼は敏感な人なので、少しのことでも気にします。（He is a sensitive person, so he worries about small things.） 鈍感な（どんかんな）: insensitive, dull 彼は鈍感だから、気になる人の気持ちに気づかないことがあります。（He is insensitive, so sometimes he doesn\u0026rsquo;t notice the feelings of others.） 使命感（しめいかん）: sense of mission 彼は仕事に強い使命感を持っています。（He has a strong sense of mission in his work.） 拒否感（きょひかん）: feeling of rejection 彼の提案に拒否感を感じました。（I felt a sense of rejection towards his proposal.） 感じる（かんじる）: to feel この音楽を聞くと、幸せな気持ちを感じます。（When I listen to this music, I feel happy.） 感情（かんじょう）: emotion, feeling 彼の言葉には強い感情が込められていました。（His words were full of strong emotions.） 連帯感（れんたいかん）: sense of solidarity チームでの連帯感が勝利を生みました。（The sense of solidarity within the team led to victory.） 一体感（いったいかん）: sense of unity みんなで歌うと一体感が生まれる。（Singing together creates a sense of unity.） 共感（きょうかん）: empathy, to empathize 彼の話に共感しました。（I empathized with his story.） 同感（する）（どうかん）: agreement, to agree 彼の意見に同感です。（I agree with his opinion.） 感激（かんげき）: deep emotion, being moved 彼の親切に感激しました。（I was deeply moved by his kindness.） 実感（じっかん）: real feeling, tangible feeling このプロジェクトの成功を実感しています。（I can really feel the success of this project.） 感想（かんそう）: thoughts, impressions 映画を見た後の感想を教えてください。（Please tell me your impressions after watching the movie.） 五感（ごかん）: five senses 五感を使って自然を楽しむことができます。（You can enjoy nature using your five senses.） 体感（たいかん）: physical sensation 山登りで体感する大自然の力はすごいです。（The physical sensation of nature’s power while mountain climbing is amazing.） 解放感（かいほうかん）: sense of liberation 仕事を終えた後の解放感が最高です。（The sense of liberation after finishing work is the best.） 4. 予 SHOW NOTES 5. 物 SHOW NOTES 6. 目 SHOW NOTES 本 SHOW NOTES SHOW NOTES SHOW NOTES SHOW NOTES SHOW NOTES SHOW NOTES SHOW NOTES SHOW NOTES SHOW NOTES SHOW NOTES SHOW NOTES SHOW NOTES SHOW NOTES SHOW NOTES SHOW NOTES SHOW NOTES SHOW NOTES 読解 １、日本の寿司の種類と作り方 SHOW CONTENTS 今日有名な寿司屋に行きました、沢山の寿司食べました。日本の寿司には、沢山の種類があります。代表的な物は、握り寿司、ちらし寿司、巻き寿司、稲荷寿司、箱寿司、そして回転寿司です。これらの寿司は、それぞれ異なる材料と作り方を使います。\nToday, I went to a famous sushi restaurant and ate a lot of sushi. Japanese sushi has many varieties. The most representative types are nigiri sushi, chirashi sushi, maki sushi, inari sushi, oshi sushi (pressed sushi), and kaiten sushi (conveyor belt sushi). Each of these sushi types uses different ingredients and preparation methods.\nYour browser does not support the audio element. SHOW NOTES 沢山（たくさん）：a lot 種類（しゅるい）：variety, kind, type, category 代表的（だいひょうてき）：representitive 握り寿司（にぎりすし）：Nigiri-zushi is the most common type of sushi. It consists of a small mound of vinegared rice topped with a slice of fish or other seafood. ちらし寿司（ちらしずし）：Chirashi means \u0026ldquo;scattered,\u0026rdquo; and this sushi is made by scattering sushi ingredients, such as fish, vegetables, and egg over a bowl of sushi rice. 巻き寿司（まきずし）：Maki-zushi refers to sushi that\u0026rsquo;s rolled in sheet of nori (seaweed) with rice, fish, and vegetables inside. The roll is then sliced into bite-sized pieces. 稲荷寿司（いなりずし）：Inari-zushi consists of vinegared rice stuffed inside a pocket of sweet, marinated tofu skin called \u0026ldquo;aburaage\u0026rdquo;. It\u0026rsquo;s often served as a snack or appetizer. 箱寿司（はこずし）：Oshi-zushi is a type of pressed sushi from the Kansai region. The ingredients (fish, vegetables, and rice) are arranged in a box and then pressed together to form a compact, rectangular shape. It\u0026rsquo;s sliced into blocks for serving. 回転寿司（かいてんずし）：Kaiten-zushi is a style of sushi restaurant where plates of sushi are placed on a rotating conveyor belt. Customers can pick the plates they want as they pass by. それぞれ：each, respectively 異なる（ことなる）：to be different, to vary 材料（ざいりょう）：materials, ingredients 作り方（つくりかた）：way of making SHOW CONTENTS まず、握り寿司は、小さなお米を手で握る方法で作ります。その上に新鮮な魚介類、例えばマグロやサーモン、鯛、烏賊などが乗せられます。海苔やわさびが付け合わせとして使われることもあります。お米は、特別な方法で炊く必要があります。炊き立てのお米に酢を混ぜて、寿司の材料と合わせます。\nFirst, nigiri sushi is made by hand-pressing small portions of vinegared rice. On top of the rice, fresh seafood such as tuna, salmon, sea bream, or squid is placed. Sometimes, nori (seaweed) or wasabi is added as a garnish. The rice must be prepared in a specific way—freshly steamed rice is mixed with vinegar and then paired with the sushi toppings.\nYour browser does not support the audio element. SHOW NOTES お米（おこめ）：rice 握る（にぎる）：to grasp, to clutch 魚介類（ぎょかいるい）：marine products, seafood 例えば（たとえば）：for example, e.g. 鮪（マグロ）：tuna　サーモン：salmon　鯛（たい）：sea bream　烏賊（いか）：squid 乗せられ（のせられ）：place on 海苔（のり）：Nori 山葵（わさび）：Wasabi 付け合わせ（つけあわせ）：garnish 特別（とくべつ）：special, particular 方法（ほうほう）：method, way 炊く（たく）：to cook 炊き立て（たきたて）：freshly boiled (rice), steaming 酢（す）：vinegar 混ぜ（まぜ）：to mix, to stir 合わせます（あわせます）：to mix, to combine SHOW CONTENTS 次に、ちらし寿司は、寿司のお米の上にたくさんの魚介類を散らして作ります。イクラや海胆、蛸や帆立もよく使われます。この寿司は見た目がとてもきれいで、食べるのが楽しいです。\nNext, chirashi sushi is made by artfully scattering various seafood over sushi rice. Ingredients like salmon roe (ikura), sea urchin (uni), octopus, and scallops are commonly used. This sushi is visually stunning and makes for a delightful eating experience.\nYour browser does not support the audio element. SHOW NOTES 散らし（ちらし）：scattering イクラ：salted salmon roe 海胆（うに）：sea urchin 蛸（たこ）：octopus 帆立（ほたて）：Japanese scallop 見た目（みため）：appearance, look SHOW CONTENTS 巻き寿司は、海苔の上にお米と魚介類を乗せ、巻くことで作ります。中に胡麻やわかめを入れることもあります。\nMaki sushi is made by placing rice and seafood on nori seaweed and rolling it tightly. Sesame seeds or wakame seaweed are sometimes added inside for extra flavor and texture.\nYour browser does not support the audio element. SHOW NOTES 巻く（まく）：to roll 胡麻（ごま）：sesame seeds 若布（わかめ）：若布 is a type of edible seaweed commonly used in Japanese cuisine. It is often found in dishes such as miso soup, seaweed salad, ramen, and sushi. SHOW CONTENTS また、稲荷寿司は、甘く味付けされた油揚げにお米を詰めたものです。箱寿司は、特に関西地方で人気があり、箱に詰めたお米と魚を固めることで作ります。\nInari sushi features sweetly seasoned fried tofu pouches stuffed with vinegared rice. Oshi sushi (pressed sushi), particularly popular in the Kansai region, is made by compacting layers of rice and fish in a wooden mold.\nYour browser does not support the audio element. SHOW NOTES 味付けされた（あじつけされた）：seasoned (flavor). 油揚げ（あぶらあげ）: deep-frying 詰めた（つめた）：to stuff into, to fill 関西（かんさい）：Kansai (関西) is a region in Japan that includes major cities such as 大阪（Osaka）, 京都（Kyoto）, 神戸（Kobe）, 奈良（Nara）, and 和歌山（Wakayama）. 地方（ちほう）：district, region 固める（かためる）：to press firmly, to solidify. SHOW CONTENTS 回転寿司は、レストランでよく見かけます。回るコンベアの上に様々な寿司が乗っていて、食べたいものを選ぶことができます。\nKaiten-zushi (conveyor belt sushi) is commonly seen in Japanese restaurants. Various sushi plates travel on a rotating conveyor belt, allowing customers to pick whatever they desire.\nYour browser does not support the audio element. SHOW NOTES 回る（まわる）：to turn, to rotate コンベア：conveyor 様々（さまざま）：various 選ぶ（えらぶ）：to choose, to select, to pick out SHOW CONTENTS 寿司に使う材料は、魚だけでなく、昆布や生姜（ガリ）もあります。塩っぱい味や酸っぱい味、そして甘味がバランスよく組み合わさるのが寿司の魅力です。わさびや胡椒でちょっとした辛さを加えることもあります。\nIngredients for sushi include not only fish, but also kelp and ginger (gari). Sushi is a well-balanced combination of salty, sour, and sweet flavors. Wasabi and pepper are sometimes used to add a little spiciness.\nYour browser does not support the audio element. SHOW NOTES 昆布（こんぶ）：kelp 生姜（しょうが）：ginner ガリ：sliced ginger prepared in vinegar (served with sushi); pickled ginger. バランス：balance 組み合わさる（くみあわさる）：to fit together, to combine 魅力（みりょく）：charm, appeal 胡椒（こしょう）：pepper ちょっとした（一寸した）：a touch of, a slight amount of 辛さ（つらさ）：spiciness 加える（くわえる）：to add SHOW CONTENTS 寿司を作る方法は、とてもシンプルですが、どれも新鮮な材料が大事です。最初に材料を準備し、混ぜることや飾ることが大切です。できあがると、どれも美味しいお寿司が完成します。\nThe methods for making sushi are quite simple, but fresh ingredients are essential. First, you prepare the components—mixing and arranging them carefully. When done right, the result is always delicious sushi.\nYour browser does not support the audio element. SHOW NOTES シンプル：simple 大事（だいじ）：important 最初（さいしょ）：beginning 準備（じゅんび）：preparation 飾る（かざる）：to decorate 大切（たいせつ）：important できあがると（出来上がると）：to be completed 完成（かんせい）：completion; perfection ","permalink":"https://signalyu.github.io/posts/3-humanities/languages/japanese/1-jlpt-n1/","summary":"リスニング 音楽 ブルー・ライト・ヨコハマ Your browser does not support the audio element. 歌詞見せて 街（まち『き』）の灯（あか）りが　とてもきれいね\nThe city lights are so beautiful\n城市的灯光如此美丽\nヨコハマ　ブルー・ライト・ヨコハマ\nYokohama, Blue Light Yokohama\n横滨，蓝色之光横滨\nあなたと二人　幸せよ\nWith you, I\u0026rsquo;m so happy\n与你在一起 多么幸福\nいつものように　愛のことばを\nAs always, whisper words of love\n像往常一样 请对我说爱的蜜语\nヨコハマ　ブルー・ライト・ヨコハマ\nYokohama, Blue Light Yokohama\n横滨，蓝色之光横滨\n私にください　あなたから\nPlease say them to me, my darling\n请对我说 亲爱的\n歩いても　歩いても\nNo matter how far we walk","title":"Japanese-Language Proficiency Test — N1"},{"content":"1. Order Food in Restaurant https://youtu.be/_izDbJ45Q5I SHOW NOTES I'm still working on it. This sentence expresses that an action is ongoing and not yet completed. It also suggests that more time is needed to finish it. Did you finish reading? — I\u0026rsquo;m still working on it. Did you fix my car? — I\u0026rsquo;m still working on it. Coke and Fries This refers to a popular combination of fast food: Coca-cola and French Fries. Complimentary This word is used to describe something that is free of charge or offered as a gift. For example: The hotel offers complimentary breakfast. (The breakfast is free of charge.) I'll go with This phrase means to choose or select something from available options. For example: I\u0026rsquo;ll go with pizza. (Pizza is the chosen option over others.) Grab This word means to qucikly take hold of something or pick something up in a hurry. For example: On your way home, can you grab some milk? Wait for me, please. I need to grab my coat. Let\u0026rsquo;s grab a cup of coffee. 2. Calling in Sick https://youtu.be/UCtpnO9r7pQ SHOW NOTES I'm feeling quite ill today. This phrase indicates that the person is experiencing discomfort or sickness. I'm coming down with the flu. This sentence means the person is starting to get sick with the flu. \u0026ldquo;Coming down with\u0026rdquo; is an informal way to say that someone is begining to show symptoms of disease. Calling in sick This phrase is commonly used to notify the employer by phone or email that the person will be absent due to illness. I was hoping to take the day off. This sentence means that the person wants to have a break from work for the day, usually because of personal reasons or illness. 3. Describe Someone\u0026rsquo;s Appearance https://youtu.be/KRysx-guzlw SHOW NOTES Description of Someone's Appearance: He\u0026rsquo;s good looking, he\u0026rsquo;s quite tall, around 6'1. He\u0026rsquo;s in his early 30s, and he get the most beautiful dark brown eyes. Heard is the past tense of the verb hear, which means to listen or become aware of something through the sense of hearing. I heard you\u0026rsquo;re dating a new guy. Julie told me she heard that you\u0026rsquo;re pregnant. What! You got fired? I heard that you quit. Fill me in This phrase means to provide someone with the details or information about something, especially if they missed out on it. For example: Can you fill me in on what happened during the meeting? Career path refers to the direction of someone\u0026rsquo;s career over time. It\u0026rsquo;s the journey someone follows in their professional life. For example: She\u0026rsquo;s thinking about changing her career path and moving into marketing. Goodlooking is used to describe someone who is attractive. It\u0026rsquo;s more natural than handsome. Hot is an informal term used to describe someone who is very attractive, typically in a physical or sexual way. However, it\u0026rsquo;s important to note that it is not always appropriate to use it directly when describing someone, as it can be considered somewhat impolite. It is more commonly used among friends or in casual settings as a comment or compliment. 4. Road Trip https://youtu.be/X8ch6GxkG7I SHOW NOTES Munchies refers to snacks or small amounts of food, often eaten casually or between meals. Fill up the tank means to fill the gas tank of a car with fuel. It\u0026rsquo;s often used when someone is getting ready to drive somewhere. A Pit Stop originally refers to a quick stop made by race cars during a race or refuel or change tires. In everyday language, it can refer to any quick stop made during a journey, such as for food, a bathroom break, etc. For example: Let\u0026rsquo;s make a pit stop for some coffee before we continue driving. We've got all our bases covered. This phrase means that all possible situations or needs have been thought about and planned for. For example: Don\u0026rsquo;t worry about the trip, we\u0026rsquo;ve got all our bases covered. We\u0026rsquo;ve got all our bases covered in case the Hurricane hits. Okay, I have my keys, wallet and passport, looks like I have all my bases covered. Let's get ... This is a common expression used to start something or make it happen. It can be used in many contexts, such as starting a project, meal, or activity. For example: I have a chicken, so let\u0026rsquo;s get cooking. This house is really scary, let\u0026rsquo;s get out of here. I have another meeting in 20 minutes, so let\u0026rsquo;s get down to business. Are we ready to go? This is a question asking if everything is prepared and if it\u0026rsquo;s time to start or leave. It\u0026rsquo;s often used when you\u0026rsquo;re about to start a trip, a task, or an activity. For example: Are we ready to go? The car is packed! It's all set. This means that everything is prepared or ready to go. It suggests that no further work is needed and everything is in order. For example: Don\u0026rsquo;t worry about the meeting, it\u0026rsquo;s all set. 5. Computer Viruses https://youtu.be/1Ic3G-KyEzQ SHOW NOTES Froze refers to something especially a computer or software that suddenly stopped responding and is no longer working, For example: My computer froze when I was trying to open the file. Infected file refers to a file on a computer that has been corrupted or infected by a virus or malware. Up to date means that something is current, recent, and has the latest information or updates. For example: I need to buy a new computer, because mine isn\u0026rsquo;t up to date. I can\u0026rsquo;t find the street, are you sure this map is up to date. Sarah has just finished the reports and all the information is up to date. I'll be right... It is an informal way to describe someone will return or be ready very soon. For example: Can you help me with my computer. — I\u0026rsquo;ll be right there. Come downstairs, dinner is ready. — I\u0026rsquo;ll be right down. Hurry up! I need to use the bathroom. — I\u0026rsquo;ll be right out. It turns out that This phrase is used to reveal a surprising or unexpected result or discovery. It often introduces new information. For example: Frank didn\u0026rsquo;t come to work today, and it turns out that he was sick. I\u0026rsquo;ve been feeling really sick recently, it turns out that I\u0026rsquo;m pregnant. It's acting up again. When something \u0026ldquo;acts up,\u0026rdquo; it means it\u0026rsquo;s behaving in an unusual or malfunctioning way. It is commonly used to describe a technical problem. For example: Oh great! That stupid computer froze again, that\u0026rsquo;s the third time today. 6. Embarrassing Situation https://youtu.be/yFAepMyEIWM SHOW NOTES In a bit of a hurry This phrase means that someone need to do something quickly. For example: Can you drive fast, I\u0026rsquo;m in a bit of a hurry. I can\u0026rsquo;t talk right now, I\u0026rsquo;m in a bit of a hurry. I\u0026rsquo;m in a bit of a hurry, so I\u0026rsquo;ll check these files later. Slipped my mind This means that someone forgot something unintentionally. For example: I\u0026rsquo;m sorry I forgot to respond to your email, it just slipped my mind. I meant to call you but it completely slipped my mind. Don\u0026rsquo;t you know what day is it today? — Oh, it\u0026rsquo;s your birthday. It completely slipped my mind. around here This refers to the local area or the place where someone is currently. For example: Are there any good restaurants around here? Is there a bank around here? Extention: Los Angeles is a great city, I used to live around there. terrible with This means someone is not good at something. For example, You\u0026rsquo;re terrible with numbers, you can\u0026rsquo;t even remember your own telephone number. I\u0026rsquo;m teribble with directions, I\u0026rsquo;m always getting lost. I\u0026rsquo;m teribble with faces, I can never remember what people look like. how's it going? This sentence is a casual, native way to greet someone. For example, How\u0026rsquo;s it going? Everything is going well. 7. Watch a Movie https://youtu.be/8LwCV7IHgss SHOW NOTES inconsiderate This word describes someone who is thoughtless or doesn\u0026rsquo;t consider how their actions affect others. For example: It was inconsiderate of him to interrupt during the meeting. keep it down This phrase is used to ask someone to lower the volume or make less noise. For example: I\u0026rsquo;m trying to study, do you mind keeping it down? not such a big deal This phrase is used to suggest that something is not as important or serious as it may seem. For example: Don\u0026rsquo;t worry about the mistake; it\u0026rsquo;s not such a big deal. I can\u0026rsquo;t get these files to you by tomorrow. — It\u0026rsquo;s OK, it\u0026rsquo;s not such a big deal. switch it off This means to turn something off, usually referring to electronics or devices. For example: Please switch it off when you\u0026rsquo;re done using the computer. can't hear a thing This phrase means that it is so noisy that it is impossible to hear anything clearly. For example: What? This music is too loud, I can\u0026rsquo;t hear a thing. Do you mind... This is a polite way to ask if someone is okay with something or if something would be a problem. For example: Do you mind holding my coat for me? I forgot my wallet. Do you mind paying for dinner? Do you mind turning off your phone? 8. In Debt https://youtu.be/QHeOq0D4zjU SHOW NOTES recession refers to a period of economic decline when businesses slow down and unemployment rises. For example: The country is going through a recession, and many people are losing their jobs. mortgagerefers to a loan taken out to buy property, where the property itself serves as collateral until the loan is paid off. For example: He has a mortgage on his house, and he\u0026rsquo;s paying it off monthly. hit me pretty hard This phrase means something had a strong, negative impact on someone emotionally or financially. For example: My divorce hit me pretty hard, I\u0026rsquo;m so depressed. This cold hit me pretty hard, I\u0026rsquo;ve been in bed for a week. The news of Fluffy\u0026rsquo;s death hit me pretty hard, I\u0026rsquo;ve been crying for days. what can I do for you: This is a polite way to ask how to help someone or what they need. I'm sorry to trouble you This is a polite way of apologizing for causing inconvenience or bothering someone. For example: Can I trouble you for a moment, I just need you to sign this form for me. I\u0026rsquo;m sorry to trouble you, but may I go home early today. Can I trouble you for a pen, mine is not working anymore. On top of all that This phrase is commonly used to add something additional to make things worse, but it can also be used in positive things. For example: Today I lost my job, my car got stolen, and on top of all that, my girl friend broke up with me. Today was a really great day, it was my birthday and all my friends came to visit me, and on top of all that, I received a surprising gift! 9. In a Rush https://youtu.be/DjgpFzIWCRs SHOW NOTES step on it This phrase means to go faster or speed up, especially when driving or in a hurry. For example: We\u0026rsquo;re running late, step on it. have a fit This means to become very angry, upset, or emotional about something. For example: Jeez, you don\u0026rsquo;t need to have a fit, nothing is going to happen if we\u0026rsquo;re five minutes late. My boss is going to have a fit if I don\u0026rsquo;t finish this on time. I almost had a fit when my boss told me I had to work this weekend. cut through means to go through a path that helps save time or provides a shortcut, often through an area that isn\u0026rsquo;t typically a main route. For example: I\u0026rsquo;ll cut through the park to get to the other side of the neighborhood faster. make a left/right/U-turn: These are driving directions. For example: Make a left at the light, then a right at the next stop sign. I missed my exit. I need to make a U-turn. are you nuts This is a casual, humorous, shocked way to ask if someone is crazy or acting irrationally. For example: You want to get married now? Are you nuts? You only met her 3 weeks ago. Are you nuts? I\u0026rsquo;m not going to cheat on the exam, what if I get caught? Let's take a side street/Wilson Avenue/the freeway These phases are used to suggest an alternative route or road. For example: The main road is too congested. Let\u0026rsquo;s take a side street to avoid the traffic. We can get there faster if we take Wilson Avenue. Let\u0026rsquo;s take the freeway to avoid getting stuck in traffic. 10. Visiting the Eye Doctor https://youtu.be/lJLgLQWmpBI SHOW NOTES 2020 vision refers to the normal vision in United States. It\u0026rsquo;s often used to indicate perfect or ideal eyesight. Far-sighted/Near-sighted Far-sighted refers to hyperopia, a condition where distant objects are clear, but nearby objects appear blurry. People with this condition have difficulty seeing things close up. Near-sighted refers to myopia, a condition where nearby objects are clear, but distant objects appear blurry. People with this condition have trouble seeing things far away. make out means to be able to see or understand something, especially when it is difficult to do so. For example: I can barely make out the words on the sign. If you look carefully , you almost make out a few of the stars in the sky. Can you see what\u0026rsquo;s written on the sign there — No, I can\u0026rsquo;t quite make it out. Blind as a bat is a fugurative expression used to describe someone who has very poor vision or is unable to see well. What seems to be the problem/matter/trouble These are used to ask what the issue or difficulty is. What seems to be the problem? (asking about a difficulty or issue) What seems to be the matter? (asking about what is troubling someone) What seems to be the trouble? (asking about a specific difficulty or issue) head on/in/out/up are informal expressions that typically refer to moving or going in a certain direction. head on in: It’s getting late; let’s head on in. head on out: We’ll head on out after lunch. head on up: We’re going to head on up to the second floor. 11. Scheduling an Appointment https://youtu.be/E8vH3YpcFfg SHOW NOTES double check means to verify or check something again to make sure it is correct or accurate. For example: I\u0026rsquo;ll double check my schedule to make sure I\u0026rsquo;m free tomorrow. scheduled means that something has been planned or arranged to happen at a specific time. For example: I have a meeting scheduled for 2 PM. booked solid means that all available time slots are taken, and there are no open appointments or spaces left. For example: I can\u0026rsquo;t get a hotel room, they\u0026rsquo;re booked solid until after the New Year. I\u0026rsquo;m pretty sorry there are no seats available on this flight, we booked solid over the Christmas holidays. Sorry, I can\u0026rsquo;t meet you today, I\u0026rsquo;m booked solid. Sentence Collecting: Appointment: I\u0026rsquo;m calling to arrange an appointment with Ms Mcneely. Please book an appointment for next week. Please schedule an appointment for next week. Dialogue: A: How\u0026rsquo;s Thursday? Does she have any time available then? B: Unfortunately, she\u0026rsquo;s booked solid on Thursday. How does next Monday work for you? A: Actually, I\u0026rsquo;ve got something scheduled on Monday. Can she do Tuesday? B: Let me see, sure, Tuesday\u0026rsquo;s perfect. 12. Going Out to Eat https://youtu.be/VpsxLnJ52ME SHOW NOTES food poisoning refers to an illness caused by consuming food or drink that is contaminated with harmful bacteria, viruses, or toxins. For example: I think I have food poisoning from the salad I ate yesterday. allergic refers to having an allergy, which is an immunue system reaction to certain substances, such as food, pollen, or pet dander. For example: She is allegic to peanuts, so she has to be careful about what she eats. check out This phrase usually means to look at or examine something, or visit a place. For example: Have you been to new cafe next door. — Yeah, I checked it out yesterday, the food was great. I\u0026rsquo;m going to check out that new shopping mall this weekend. bistro refers to a small, casual restaurant or cafe, often offering simple, home-style meals. For example: We went to a charming bistro for dinner last night. not all that crazy about is an informal expression that means not very interested in or not particularly fond of something. Do you want to go shopping with me tomorrow? — I\u0026rsquo;m not all that crazy about shopping, I don\u0026rsquo;t like spending money. I\u0026rsquo;m not all that crazy about Jazz music. Can I change this song? in the mood for This expression means desiring or wanting something at a particular moment, usually referring to food or activities. For example: We always eat hamburgers for dinner, I\u0026rsquo;m in the mood for something different. Let\u0026rsquo;s watch movie. How about Texas Chainsaw Massacre. — I\u0026rsquo;m not in the mood for a horrible movie. Sentence Collecting Ask Suggestions Do you have any suggestions? Do you have any ideas? Do you have any thoughts? Giving Suggestions I\u0026rsquo;d recommend giving it a try. You\u0026rsquo;ve gotta give them a try. You could give them a try. 13. Cancelling an Appointment https://youtu.be/lcZA5FeM2_I SHOW NOTES reschedule means to change the time or date of an event or appointment to a later time. For example: We need to reschedule the meeting for next week. postpone means to delay or push something to a later time, often with a specific future date in mind. For example: The concert was postponed due to the rain. can't make it is a casual way of saying that attending or participating in an event or meeting is not possible. For example: I\u0026rsquo;m sorry, I can\u0026rsquo;t make it to the party tonight. this thing came up This phrase is used to explain that something unexpected or urgent has happened, preventing attendence or participation in a planned activity. I\u0026rsquo;m sorry that I\u0026rsquo;m late this thing came up at work, and I had to stay to take care of it. I can\u0026rsquo;t talk right now, something came up. The meeting at 3 PM had to be rescheduled because this thing came up at work. Sentence Collecting What\u0026rsquo;s up? — Not much./Nothing. 14. Asking for More Time https://youtu.be/IKm6ceWu1IU SHOW NOTES press kit refers to a collection of materials, such as photos, press releases, or information about a company, product, or event, that is given to journalists or media for publicity purpose. deadline/extension deadline is the final date by which something must be completed or submitted. For example: The deadline for the report is Friday at 5 PM. extension is an extra period of time given to complete something after the original deadline. For example: She requested an extension on the project deadline. ran into means to unexpectedly meet someone or experience something, usually a problem. For example: We ran into a storm on our way home. If you\u0026rsquo;re not careful now, you\u0026rsquo;re going to run into a lot of problems later. I ran into some trouble with my computer. I've been meaning to... This is used to express an intention to do something that has not yet been done. For example: I\u0026rsquo;m sorry I haven\u0026rsquo;t called you yet, I\u0026rsquo;ve been meaning to but I\u0026rsquo;ve been busy. I\u0026rsquo;ve been meaning to tell you but John quit yesterday. I\u0026rsquo;ve been meaning to see that film for a while. beyond my control refers to something that cannot be influenced or changed by the person, usually an event or situation. For example: The delay was beyond my control because of the weather. put this off means to delay or postpone something to a later time. For example: I\u0026rsquo;ve been putting off this project for a week, and it\u0026rsquo;s due tomorrow. Can we put off our meeting till next week, I\u0026rsquo;m too busy right now. I\u0026rsquo;ve been putting off my email all day, and now I have 50 messages to respond to. 15. Complimentary Upgrade https://youtu.be/vJlvav_HThc SHOW NOTES under the name refers to something that is registered or listed in someone\u0026rsquo;s name. For example: Do you have a reservation under the name Smith? mix up means to confuse or mistake one thing for another. For example: There was a mix up at the airport, and my bags were sent to Antarctica. I\u0026rsquo;m sorry sir, there\u0026rsquo;s been a terrible mix up with giving you the wrong baby. overlooked means more reservations or tickets have been sold than there is capacity to accommodate. For example: The hotel was overbooked, and they didn\u0026rsquo;t have a room for us when we arrived. complimentary upgrade refers to a free improvement. For example: We received a complimentary upgrade to a presidential suite at the hotel. 16. Cutting in Line https://youtu.be/79cfTb94tHU SHOW NOTES there's no way... This phrase is used to express that something is impossible to happen. For example: There\u0026rsquo;s no way I can have those reports finished today. The stadium is so crowded that there\u0026rsquo;s no way we\u0026rsquo;ll find a seat. Do you think Michael\u0026rsquo;s gonna buy that house? — There\u0026rsquo;s no way he has enough money to buy it. cut in line means to move ahead of others in a line or queue, usually in an unfair or rude manner. For example: Excuse me, I\u0026rsquo;m really late, can I cut in line, please? I hate it when people cut in line at the bank, it\u0026rsquo;s so rude. I think it\u0026rsquo;s okay when a pregnant woman cuts in line. sue me is a casual or somewhat sarcastic expression used to suggest that someone is free to take legal action, often when the speaker does not care about the consequences. It can also be used humorously when someone is being accused of something. For example: I forgot your birthday. Sue me! (Used in a joking way) 17. Wedding Day https://youtu.be/MCtwK8KGtBk SHOW NOTES it's about time. is commonly used to express that something finally happens after a long wait. For example: Dinner\u0026rsquo;s ready. — It\u0026rsquo;s about time, I\u0026rsquo;m starving. Guess what. I finally got a job. — It\u0026rsquo;s about time, you\u0026rsquo;ve been unemployeed for two years. We\u0026rsquo;re almost there, just a couple more minutes. — It\u0026rsquo;s about time, we\u0026rsquo;ve been driving for 12 hours. bridesmaids are women who are chosen to assist the bride on her wedding day. flower girl is a young girl who walks down the aisle before the bride, scattering flower petals. ring bearer is a young boy who carries the wedding rings down the aisle. gorgeous is a uni-sex adjective, it can be used to describe both people and things. For example: She looks gorgeous in that dress. The sunset was absolutely gorgeous. Common Mistake Wrong: Let\u0026rsquo;s marry. Right: Let\u0026rsquo;s get married. Flower Girl \u0026amp; Ring Bearer 18. Asking for Time Off https://youtu.be/Ds5zwyfLyqI SHOW NOTES notice refers to the information that gived someone in advance about something, often referring to leaving a job or ending an agreement. For example: If you want to quit your job, make sure you give enough notice, you\u0026rsquo;ll need to tell us four weeks in advance. You didn\u0026rsquo;t give me enough notice about this project, I didn\u0026rsquo;t have enough time to finish it. Sentence Collecting: Do you have a sec/second/minute? — Sure, what can I do for you? Would you be okay with that? — I\u0026rsquo;m fine with that. Are you alright with that? / Will you Ok with this? I was just wondering/thinking/hoping... is more polite than I want to... 19. Hiring an Assistant https://youtu.be/JZFIdKbnZCU SHOW NOTES understaffed means that there are not enough employees or workers to handle the work or tasks. For example: Our team is understaffed right now, so we need to delay the project deadline. the timing is just not right means that it\u0026rsquo;s not the right moment or situation to do something. For example: I was gonna sell my house, but the timing is just not right. Honey, I think we should have a baby. — The timing is just not right. weight off my shoulders phrase means feeling relieved from stress or worry. After I finished my final exam, it felt like a weight was off my shoulders. give me a hand is an informal way of asking for help. For example: Can you give me a hand with these boxes. Neil, I\u0026rsquo;ll need you to give me a hand with the sales reports. Let me give you a hand with your suitcase. keep our costs down means to reduce or control expenses. We need to keep our costs down if we want to make a profit this quarter. 20. Bargain https://youtu.be/I4ivQUabfyo SHOW NOTES bargain refers to a good deal or something you buy at a lower price than usual. It can also refer to negotiating for a better price. For example: I found a great bargain on these shoes—they were 50% off! price range refers to the range of prices within which something is available, or the amount someone is willing to pay. For example: I\u0026rsquo;m looking for a new phone, but my price range is between $200 and $400. shop around means to look at different stores or options to compare prices before making a purchase. For example: Before you buy that jacket, shop around and see if you can find a better deal at another store. Can you give me a better deal? This is a request for a lower price or a better offer, often used during negotiations. For example: I really like this shirt, but it\u0026rsquo;s too expensive. Can you give me a better deal? Can you give me a better price on this car, I really don\u0026rsquo;t have that much money. That's still more than I wanted to spend. This is commonly used in situations where the price is still too high even after trying to negotiate or considering different options. For example: I know the dress is on sale, but that\u0026rsquo;s still more than I wanted to spend. That's my last offer This is commonly used in situations where the final price someone is willing to accept; no further negotiations will be made. For example: I can\u0026rsquo;t go lower than $500 for the laptop. That\u0026rsquo;s my last offer. 21. Watching Basketball https://youtu.be/O-BvPcJfX1w SHOW NOTES foul refers to a violation of the rules in a sport, usually resulting in a penalty. For example: He committed a foul by pushing the opponent during the game. ref is short for referee, refers to an official who oversees a game or match to enforce the rules. For example: The ref called a foul on that play because the defender hit the shooter. free throw refers to a shot taken from the free-throw line without any defense, usually awarded after a foul. For example: She made both of her free throws after the foul was committed. make the shot means to successfully score by getting the ball into the hoop or goal. For example: If Gretzky make a shot, they\u0026rsquo;re gonna win the Stanley Cup. 3-pointer refers to a basketball shot taken from beyond the three-point line, worth three points if successful. For example: He hit a 3-pointer to tie the game in the final seconds. travel refers to a vilation in basketball where a player takes too many steps without dribbling the ball. For example: The ref called a travel because the player took five steps without dribbling. beer run informally refers to going to get beer, usually in a group or as part of a social activity. For example: We\u0026rsquo;re running out of drinks—time for a beer run. screw up means to make a mistake or do something badly, often in a way that causes problems or difficulties. For example: Jill, you really screwed up this time, you\u0026rsquo;re fired. This game is important, if you screw it up again, we\u0026rsquo;re out of the finals. I\u0026rsquo;m sorry, I know I screwed up, will you forgive me? 22. Ending a Relationship https://youtu.be/HjXbEHvwskM SHOW NOTES get a hold of means to contact or reach someone. For example: I tried calling her all day, but I couldn\u0026rsquo;t get a hold of her. stood me up means to fail to meet someone as planned, especially when they were expecting you. For example: I waited for an hour, but she stood me up and never showed. priority refers to something that is considered more important to be done or dealt with first. For example: Getting the report finished is my top priority today. heading is commonly used to express the future direction, outcome, or progress. For example: I don\u0026rsquo;t know where our relationship is heading. Where is this bus heading? Where is this project heading? Do you have any idea...? This is commonly used to ask if someone knows or has any information about something. For example: You forgot my birthday. Do you have any idea how angry I am? Julie kiss my borfriend, does she have any idea how mean that was? I just broke up with my boyfriend, don\u0026rsquo;t you have any idea how sad I am? I've heard it all before. This phrase is used when someone is tired of hearing the same things or excuses. For example: You say you\u0026rsquo;ll change, but I\u0026rsquo;ve heard it all before. I\u0026rsquo;m not buying it. 23. New Year\u0026rsquo;s Resolution https://youtu.be/I9k50oVZPHA SHOW NOTES transform means to change something completely in appearance, form, or nature, often for the better. For example: She used to be shy, but the experience completely transformed her. stuffed means to be very full, especially after eating too much. For example: I ate so much pizza, I\u0026rsquo;m completely stuffed! stick to it means to continue with something especially when it\u0026rsquo;s difficult. For example: I can\u0026rsquo;t solve this math problem. — Stick to it. I\u0026rsquo;m sure you\u0026rsquo;ll get it. I mean it. This phrase emphasizes seriousness in what someone is saying. For example: If you don\u0026rsquo;t finish your homework by tonight, there will be consequences. I mean it! cut out means to remove something entirely. For example: It\u0026rsquo;s time for me to focus on my work, I\u0026rsquo;m going to cut out everything else from my life. You have to cut out the salt and carbon from your diet, no more chips, no more French fries, no more popcorn. 24. Ordering Pizza https://youtu.be/yaeLbz_NK4U SHOW NOTES pepperoni is a type of spicy Italian sausage made from cured pork and beef, often used as a topping for pizza. olives are small, oval-shaped fruits that are typically green or black. They are often used in salads, pasta dishes, or as pizza toppings. martini is a classic cocktail typically made with gin and vermouth, garnished with an olive or a twist of lemon peel. thick crust / thin crust Thick crust is soft and doughy, while thin crust is crispy and light. ham is a type of cured or smoked meat, often made from the thigh of a pig. It is commonly used as a topping for pizzas or in sandwiches. Regina Margarita is a variation of the famous Margherita pizza, typically with tomato, mozzarella, and basil, but may also include other toppings or slightly different variations depending on the restaurant. This is Marty speaking. This is a way to introduce oneself on the phone, letting the other person know who is speaking. For example: Hello, this is Marty speaking. How can I help you? 2 for 1 special is a promotional offer where customers get two items for the price of one. This is commonly seen in restaurants, stores, or fast-food promotions. 25. Receptionist https://youtu.be/sgxrbqyGonE SHOW NOTES May I take your name? This is a polite way of asking for someone\u0026rsquo;s name, typically when answering the phone or greeting someone in an office or service setting. Miss Stevens will be with you momentarily. This is a polite way to inform someone that Miss Stevens will arrive or be ready to speak with them shortly. For example: Please take a seat. Miss Stevens will be with you momentarily. Miss Stenvens is ready for you now. This is used to inform someone that the person they are waiting to see is now available to meet them. For example: Miss Stevens is ready for you now. Please follow me. I'll show you to her office. This is used to guide someone to another person\u0026rsquo;s office or location. For example: Please follow me. I\u0026rsquo;ll show you to her office. right this way is a polite way of directing someone to go in a certain direction. watch your step is a cautionary phrase used to warn someone to be careful of their footing, often when walking on uneven ground or stairs. 26. Swimming https://youtu.be/kGopb2awYiM SHOW NOTES anchor the boat means to secure a boat in place by dropping an anchor into the water, preventing it from drifting. For example: We need to anchor the boat before we go swimming. doggy padding is a simple swimming stroke where the swimmer uses a paddling motion with their arms and legs, similar to how a dog swims. It is often used by beginners as it\u0026rsquo;s an easy and natural way to stay afloat. breaststroke is a swimming stroke where the swimmer moves their arms in a half-circle motion while pulling their legs in a frog-like kick. backstroke is a swimming stroke done on the back, where the swimmer alternates arm strokes in a circular motion while kicking their legs. take a dip means to go into the water for a quick swim. For example: It\u0026rsquo;s such a hot day; let\u0026rsquo;s take a dip in the pool to cool off. for a little while means for a short period of time. I\u0026rsquo;m going to take a dip for little while before the sunset. 27. Eggs Preparation https://youtu.be/e-z7jc3B4zg SHOW NOTES picky means being very selective or particular, especially when it comes to food, preferences, or choices. He\u0026rsquo;s really picky about his food—he doesn\u0026rsquo;t like vegetables. yolk/egg white yolk is the yellow part of an egg, which is surrounded by the egg white. egg white is the clear part of an egg that surrounds the yolk sunny side up is a way of cooking eggs where the egg is fried on one side only, leaving the yolk exposed and not flipped. soft/hard boiled eggs soft boiled egg is an egg that has been boiled for a short time, resulting in a runny yolk and slightly firm white. hard boiled egg is an egg that has been boiled for a longer period, making both the yolk and white firm. eggs and soldiers is a British dish where soft-boiled eggs are served with strips of toast (called soldiers) for dipping into the yolk. I feel like... This is often used to express a desire, mood, or inclination to do something. I feel like baking. I feel like eating pizza. drives me crazy means to cause frustration or annoyance, often in a way that is hard to ignore. This music is driving me crazy, turn it down. Don\u0026rsquo;t leave garbage in my car, it drives me crazy. Your mom is driving me crazy, she keeps calling me. 28. At the Bar https://youtu.be/l-IL4mtzye0 SHOW NOTES on tap refers to beverages, especially beer, that are available from a keg. When something is \u0026ldquo;on tap\u0026rdquo;, it means that it\u0026rsquo;s being served from a tap at a bar or restaurant. happy hour refers a time when drinks and appetizers are sold at discounted, usually in the late afternoon or early evening. a special refers to a discounted item, usually in a restaurant or bar. Today\u0026rsquo;s special is a burger and fries for only $5. pint is a unit of measurement for liquids, commonly for beer. a pint = 473 milliliters appetizer is a small dish served before the main course to stimulate appetite. Nachos /ˈnɑːtʃoʊz/ is a popular snack made from tortilla chips covered with melted cheese and often topped with things like salsa, guacamole, sour cream, etc. Heineken /ˈhaɪnɪkən/ is a popular brand of beer originally from the Netherlands. Budweiser /ˈbʌdˌwaɪzər/ is a well-known American beer brand. Mozzarella /ˌmɑːtsəˈrɛlə/ is an Italian cheese that is soft, white, and commonly used in salads, pizzas, and pasta dishes. how/what about are used to suggest or inquire about something. What about these dirty clothes, you said you would wash them days ago. What about going to the mall instead. I\u0026rsquo;m tired of going to the movies. How about we go to the new restaurant tonight? 29. Fingers https://youtu.be/y-eo1VNedcQ SHOW NOTES pinky, ring finger, middle finger, index finger, thumb pinky: The smallest finger. ring finger: The fourth finger, typically where a ring is worn. middle finger: The third finger, located in the center of the hand. index finger: The second finger, next to the thumb, often used for pointing. thumb: The first and thickest finger, opposable to the other fingers, making grasping objects easier. may this ring be blessed This phrase refers to a wish or prayer for the ring to be blessed or sactified, often said during a wedding ceremony. abide in peace This phrase means to live or remain in peace, suggesting calmness and harmony. with this ring, I thee wed This is a traditional phrase spoken during a wedding ceremony, where one person declares their intention to marry the other by placing a ring on their finger. wear it as a symbol of our love and commitment This phrase explains that the ring represents the love and promise made between two people in marriage. 30. Math https://youtu.be/8uLJQnZROyI SHOW NOTES teacher's pet refers to a student who is overly favored by the teacher, often because they try to please the teacher. It common have a negative connotation, implying that the student is trying too hard to gain the teacher\u0026rsquo;s approval. scuk up means someone who is overly flattering someone, usually a person in power, like a teacher or boss, in an insincere way to gain favor. smarty pants is a playful or teasing way to describe someone who is very clever or shows off their intelligence, often in a way that annoys others. know-it-all refers to a person who believes they know everything. It\u0026rsquo;s usually used in negative or sarcastic way to describe someone who is seen as arrogant about their knowledge. 31. Sci-fi https://youtu.be/hdcGDXFFiq4 SHOW NOTES blaster is a type of weapon, often seen in science fiction or action movies. break through means to make progress or succeed after overcoming obstacles, which can refer to physical barriers like wall, or more abstract challenges like tough problems. After 15 minutes, the workers broke through the wall, and rescued everyone from the fire. He is such a good player, he broke through the entire defense. They are breaking through our impenetrable wall. settle this means to solve a disagreement or issue. It can be used when there\u0026rsquo;s need to come to a final decision or conclusion about something. I\u0026rsquo;m fed up with arguing about this, let\u0026rsquo;s just settle the argument once and for all. tractor beam is a concept from science fiction, usually referring to a powerful beam used to pull or attract objects toward a spacecraft. no longer be means that something is no longer happening, or someone is no longer in a particular role. I\u0026rsquo;ll no longer be your boyfriend. know nothing of This phrase is often used to express that someone is ignorant or uninformed about a topic. You think you can understand what I\u0026rsquo;m going through, but you know nothing of the struggles I\u0026rsquo;ve faced. once and for all means to finally resolve or finish something, often in a definitive or conclusive way. He claims that his photographs prove once and for all that UFOs do exist. I told him once and for all that I don\u0026rsquo;t want to be his girlfriend anymore. 32. Barber Shop/Hair Salon https://youtu.be/l4jdN_P3UjE SHOW NOTES trim means to cut something or small adjustments, usually to hair. silky is commonly used to describe hair that very soft and smooth to touch. shiny is used to describe something that has a bright, smooth surface, such as shiny hair or a shiny car. grow out means to let something, such as hair or nails, become longer naturally without cutting them. sideburn is the strip of hair that grows along the sides of the face, in front of the ears. take a little off the top is commonly used when someone wants to trim a small amount of hair from the top part of their head. nothing too fancy means something is simple, not elaborate, or not showing off. don't just stand there is used to tell people to take action instead of staying still or doing nothing. Don\u0026rsquo;t just stand there, help me take these boxes into the house. The house is on fire, don\u0026rsquo;t just stand there, call the fire department. look like a million buck means to look very attractive, stylish, or impressive. It\u0026rsquo;s a compliment often used when someone is well-dressed or appears confident and radiant. Mullet is a hairstyle where the front of the hair is short, and the back is left long. It bacame popular in the 1980s. Hockey Hair is a term for a hairstyle similar to the mullet, often associated with hockey players. It’s characterized by long hair in the back and shorter hair in the front. Afro refers to a hairstyle where the hair is naturally grown out and styled into a rounded shape, often associated with African heritage. Mohawk is a hairstyle where the hair is shaved or very short on the sides, with a strip of longer hair running from the front to the back of the head. Flat Top is a hairstyle where the hair is cut short on the sides and top, creating a flat, even surface. crew cut is very short and simple style where the hair on the sides and top is cut short and uniform in length. Dreadlocks is a hairstyle where the hair is matted or twisted into long, rope like strands. It is often associated with various cultures, especially in the Caribbean and African communities. 33. Pharmacy/Drug Store/Chemist https://youtu.be/5J2cwx5gHUI SHOW NOTES price check refers to checking the price of an item, usually at a store or supermarket. Can you do a price check on this shirt? I\u0026rsquo;m not sure if it\u0026rsquo;s on sale. capsule is a medication enclosed in a soft or hard shell, usually made of gelatin. tablet is a solid form of medication that is typically swallowed. overdose means to take more than the recommended or safe amount of a drug. eyedrops means a liquid medication that is applied to the eyes. Prozac is a brand name for the medication fluoxetine, which is used to treat depression, anxiety, and other disorders. be sure means to be certain about something. Be sure not to forget your unbrella, it\u0026rsquo;s raining today. hang on generally means to wait for a short time or hold something tightly. wait: Hang on, I\u0026rsquo;ll be right there. hold: Hang on to the railing while going down the stairs. 34. Baseball https://youtu.be/Uc1GjEKoPZI SHOW NOTES national anthem is a patriotic song officially recognized by a country, often sing at the begining of public events like sports games. hymn is a religous song, typically sing during religious ceremonies or services. pitcher is a player in baseball who throws the ball to the batter from the pitcher\u0026rsquo;s mound. outfielder is a player in baseball who is positioned in the outfield (the area fartest from the home plate) and is responsible for catching fly balls and making throws back to the infield. line drive is a type of hit in baseball where the ball is hit sharply and traight, usually at a low angle. scrambling refers to a player in baseball quickly and awkwardly to avoid being tagged or to regain control of the ball. inning is a division of a baseball game where both teams have a chance to bat and field. The game went into extra innings, and the home team won in the 12th inning. up to bat refers to the player who is currently batting or next in line to the bat in a baseball game. It\u0026rsquo;s your turn, you\u0026rsquo;re up to bat now. strike one refers to a term used in baseball when the batter misses a pitched ball, or doesn\u0026rsquo;t swing at a ball that\u0026rsquo;s in the strike zone. curve ball is a type of pitch in baseball that curves or breaks as it approaches the batter, making it harder to hit. Also used figuratively to mean something unexpected. The pitcher threw a curve ball, and the batter couldn\u0026rsquo;t hit it. My boss threw me a curve ball today, so I have to stay and work late. hit a home run A home run is a term from baseball that refers to a hit in which the batter hits the ball out of the playing field, typically over the outfield fence, without it being caught. In a figurative sense, it means achieving a significant success or accomplishing something exceptionally well. Great job on that sales presentation, you really hit home run. Our sales team hit a home run this month by doubling our revenue. 35. Confess Love https://youtu.be/74FmjXrg0t8 SHOW NOTES here's the thing is used to introduce something important or to explain a situation. Here\u0026rsquo;s the thing, we need to leave in 10 minutes if we want to catch the train. I can't take it anymore is used when someone feels overwhelmed, frustrated, or exhausted by a situation and can no longer handle it. The man next door has been so loud, I can\u0026rsquo;t take it anymore. My boss always yells at me, I can\u0026rsquo;t take it anymore. I can\u0026rsquo;t take it anymore, I\u0026rsquo;m going to quit. are you serious is similar to really, it\u0026rsquo;s often used when something is surprising, unbelievable, or hard to believe. Are you serious? You just won the lottery?! have the guts means having the courage to do something difficult, dangerous, or challenging. I don\u0026rsquo;t think I have the guts to go skydiving. I don\u0026rsquo;t have the guts to give a speech. I\u0026rsquo;ve never had the guts to say no to my boss. just for the two of us means something is meant for only two people, often implying exclusivity or intimacy. I booked a small table at the restaurant, just for the two of us. give me a shot means to give someone a chance to try or attempt something. I know I can do this drawing better, just give me a shot. The HR manager wasn\u0026rsquo;t going to hire me, but he decided to give me a shot. 36. Back In 1950 https://youtu.be/9Ox9lC_Jbuk SHOW NOTES A Sock Hop is a type of informal dance event that was popular in the 1950s and 1960s. A Sadie Hawkins Dance is a type of dance where girls ask the boys to be their dates, instead of the traditional way where boys ask girls. I'm swell is an old-fashioned, informal way of saying \u0026ldquo;I\u0026rsquo;m doing great\u0026rdquo; or \u0026ldquo;I\u0026rsquo;m fine.\u0026rdquo; It was popular in the 1930s and 1940s. How are you feeling today?—I\u0026rsquo;m swell. cool it means to relax or calm down, especially if someone is getting overly excited or angry. It\u0026rsquo;s a way to tell someone to take it easy. Just cool it. Now is not the right time to get angry. You need to cool it and stop yelling at me. knuckle sandwich is a humorous or exaggerated way of referring to a punch in the face. It\u0026rsquo;s a playful way of saying someone might get hit. If you keep talking like that, you might end up with a knuckle sandwich! pipsqueak is a playful term or slightly insulting term for someone who is small or weak, often used for children or someone who\u0026rsquo;s being annoying in a harmless way. Stop being such a pipsqueak and help me carry these boxes. It'll be blast means that something is going to be a lot of fun or exciting. Don\u0026rsquo;t worry, the party\u0026rsquo;s going to be a blast. have my eyes on means to be interested in or focused on something, whether it\u0026rsquo;s a person, a goal, or an object. I\u0026rsquo;ve had my eyes on that new phone for a while. ease off means to reduce the intensity, pressure, or effort being applied to something or someone. It’s used when someone is doing something too forcefully, and you suggest they should stop being so intense or give more space. You\u0026rsquo;re pushing Susie too much, you need to ease off a bit. You need to ease off the junk food. Matt is putting so much pressure on me these days, I wish he would ease off. Scok Hop Sadie Hawkins Dance 37. Back In 1970 https://youtu.be/lJqo8PYZbBc SHOW NOTES roller rink ia a place where people go to skate. A roller skate is a type of skate with four wheels arranged in two rows, like a small car\u0026rsquo;s wheels. A roller blade is a type of skate with wheels arranged in a single line. groovy is a slang term from the 1960s-70s meaning \u0026ldquo;cool\u0026rdquo; or \u0026ldquo;awesome\u0026rdquo;. far out ia slang term in 1970s meaning \u0026ldquo;amazing\u0026rdquo; or \u0026ldquo;incredible\u0026rdquo;. foxy is used to describe someone as very attractive or sexy. mellow out means to relax or calm down. You need to mellow out after a stressful day. right on is a phrase showing aggrement or excitement, similar to saying \u0026ldquo;exactly\u0026rdquo; or \u0026ldquo;that\u0026rsquo;s great\u0026rdquo;. Right on, you got a high score, that\u0026rsquo;s amazing. gravy is a slang for something extra good or easy, like a bonus. This raise was gravy on top of the promotion. to book is a casual way to say \u0026ldquo;leave quickly\u0026rdquo; or \u0026ldquo;run away\u0026rdquo;. We need to book before it gets too late. how's it hanging is a casual way of saying \u0026ldquo;how are you?\u0026rdquo; chat her up is a british slang phrase meaning to start a conversation with someone, usually flirting. hit someone up is a casual way to say \u0026ldquo;contact someone\u0026rdquo;, often to ask for something, either by calling, texting, or meeting. Can you believe Patrick, he came up to me a month ago, and tried to hit me up for some money. When I was a kid, I used to always hit my dead up for lunch money. This is the last time I lend you money, don\u0026rsquo;t even try to hit me up for more. grab some grub is a casual phrase meaning \u0026ldquo;get something to eat.\u0026rdquo; Grub is a slang term for food. Let\u0026rsquo;s grab some grub before the movie. ","permalink":"https://signalyu.github.io/posts/3-humanities/languages/english/1-learning-english-with-podcasts/","summary":"1. Order Food in Restaurant https://youtu.be/_izDbJ45Q5I SHOW NOTES I'm still working on it. This sentence expresses that an action is ongoing and not yet completed. It also suggests that more time is needed to finish it. Did you finish reading? — I\u0026rsquo;m still working on it. Did you fix my car? — I\u0026rsquo;m still working on it. Coke and Fries This refers to a popular combination of fast food: Coca-cola and French Fries.","title":"Learning English With Podcasts"},{"content":"IDEA Postfix Completion Postfix completion allows writing code faster by adding expressions after a variable or value. It can be customized to suit specific coding needs.\n\u0026#34;Hello\u0026#34;.var → String s = \u0026#34;Hello\u0026#34;; Live Templates Live Templates are predefined code snippets that can be inserted quickly using a shortcut. It can be customized to suit specific coding needs.\nsout → System.out.println(); Keyboard Shortcuts Show Hint: Alt + Enter Show Parameter Info: Ctrl + P Surround with Selected Code Block: Ctrl + Alt + J Start a New Line: Shift + Enter Start a New Line Before Current: Ctrl + Alt + Enter Show Live Template: Ctrl + J Rename in Batch: Shift + F6 Extract Method: Ctrl + Alt + M Override Methods: Ctrl + O Implement Methods: Ctrl + I Optimize Imports: Ctrl + Alt + O View Source Code: Ctrl + N → Ctrl + F12 Go to Previous Edit Location: Ctrl + Alt + ← Go to Next Edit Location: Ctrl + Alt + → Show Inheritance Tree: Ctrl + H Show Quick Documentation: Ctrl + Q Show UML Diagram: Ctrl + Alt + U Go to Specified Line: Ctrl + G → Enter line number Go to Variable Definition: Ctrl + Alt + B Expand Code Block: Ctrl + Shift + + Collapse Code Block: Ctrl + Shift + - Debug Method Breakpoints Field Breakpoints Conditional Breakpoints Thread Debug Custom Data Views Config Tomcat Create Maven Java Project Create Maven Java Web Maven Introduction to Maven Maven is a build automation and project management tool primarily used for Java projects. It follows the concept of Project Object Model (POM), which is defined in an XML file (pom.xml) at the root of the project.\nsettings.xml Configuration SHOW CODE settings.xml ./ ├── bin/ │ ├── m2.conf │ ├── mvn* │ ├── mvn.cmd │ ├── mvnDebug* │ ├── mvnDebug.cmd │ └── mvnyjp* ├── boot/ │ ├── plexus-classworlds-2.7.0.jar │ └── plexus-classworlds.license ├── conf/ │ ├── logging/ │ │ └── simplelogger.properties │ ├── settings.xml # CUSTOMIZE DEFAULT BEHAVIOR IN THIS FILE │ └── toolchains.xml ├── ... The settings.xml file in Maven is typically used to customize the default behavior according to user needs. Common modifications include configuring repository locations, setting up mirrors, and defining profiles.\nSHOW CODE: Configuring Repository Location Configuring Repository Location \u0026lt;!-- localRepository | The path to the local repository maven will use to store artifacts. | | Default: ${user.home}/.m2/repository \u0026lt;localRepository\u0026gt;/path/to/local/repo\u0026lt;/localRepository\u0026gt; --\u0026gt; \u0026lt;localRepository\u0026gt;/Users/signalfish/maven-repository\u0026lt;/localRepository\u0026gt; SHOW CODE: Setting Up Mirrors Setting Up Mirrors \u0026lt;mirrors\u0026gt; \u0026lt;!-- mirror | Specifies a repository mirror site to use instead of a given repository. The repository that | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used | for inheritance and direct lookup purposes, and must be unique across the set of mirrors. | \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;mirrorId\u0026lt;/id\u0026gt; \u0026lt;mirrorOf\u0026gt;repositoryId\u0026lt;/mirrorOf\u0026gt; \u0026lt;name\u0026gt;Human Readable Name for this Mirror.\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://my.repository.com/repo/path\u0026lt;/url\u0026gt; \u0026lt;/mirror\u0026gt; --\u0026gt; \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;alimaven\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;aliyun maven\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://maven.aliyun.com/nexus/content/groups/public/\u0026lt;/url\u0026gt; \u0026lt;mirrorOf\u0026gt;central\u0026lt;/mirrorOf\u0026gt; \u0026lt;/mirror\u0026gt; \u0026lt;/mirrors\u0026gt; SHOW CODE: Defining Profiles Defining Profiles \u0026lt;profiles\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;env-dev\u0026lt;/id\u0026gt; \u0026lt;activation\u0026gt; \u0026lt;property\u0026gt; \u0026lt;name\u0026gt;target-env\u0026lt;/name\u0026gt; \u0026lt;value\u0026gt;dev\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/activation\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;tomcatPath\u0026gt;/path/to/tomcat/instance\u0026lt;/tomcatPath\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/profile\u0026gt; --\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;jdk-1.8\u0026lt;/id\u0026gt; \u0026lt;activation\u0026gt; \u0026lt;activeByDefault\u0026gt;true\u0026lt;/activeByDefault\u0026gt; \u0026lt;jdk\u0026gt;1.8\u0026lt;/jdk\u0026gt; \u0026lt;/activation\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;1.8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;1.8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;maven.compiler.compilerVersion\u0026gt;1.8\u0026lt;/maven.compiler.compilerVersion\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;jdk-17\u0026lt;/id\u0026gt; \u0026lt;activation\u0026gt; \u0026lt;activeByDefault\u0026gt;true\u0026lt;/activeByDefault\u0026gt; \u0026lt;jdk\u0026gt;17\u0026lt;/jdk\u0026gt; \u0026lt;/activation\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;17\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;17\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;maven.compiler.compilerVersion\u0026gt;17\u0026lt;/maven.compiler.compilerVersion\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/profiles\u0026gt; GAVP In Maven, GAVP refers to four key components that are used to uniquely identify and describe an artifact (e.g., WAR, JAR, or POM) in a Maven repository.\nG stands for GroupID, which represents the organization or group responsible for the artifact. It typically follows the reverse domain name convention, such as \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; or \u0026lt;groupId\u0026gt;dev.signalyu\u0026lt;/groupId\u0026gt;. A stands for ArtifactID, which identifies the specific artifact within the group. It usually matches the project name or module name, such as \u0026lt;artifactId\u0026gt;my-app\u0026lt;/artifactId\u0026gt;. V stands for Version, which specifies the version of the artifact, such as \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt;. P stands for Packaging, which specifies the type of artifact. It tells Maven what kind of output to expect from the project, such as a JAR file for a library or a WAR file for a web application, such as \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt;. Common Maven Commands mvn compile: Compiles the source code of the project. mvn test: Compiles the source code, runs unit tests, and reports the results. mvn package: Compiles the source code, runs unit tests, and packages the compiled code into desired artifact. mvn clean: Removes the previously compiled files and generated artifacts. mvn install: Compiles the source code, runs unit tests, packages the compiled code into an artifact, and installs it into local Maven repository. mvn deploy: Compiles the source code, runs unit tests, packages the compiled code into an artifact, and deploys the artifact to a remote repository. Maven Dependency Download Failure When Maven fails to download dependencies, follow these steps to resolve the issue:\nCheck the network connection: Ensure a stable internet connection. If an internal network is used, verify the mirror configuration in settings.xml to ensure it\u0026rsquo;s correctly set up. Verify the dependency version: Double-check the version of the dependency specified in pom.xml. Clean the local repository: If the previous steps don\u0026rsquo;t resolve the issue, try cleaning the local Maven repository or deleting the specific dependency directory in the repository. Invalidate caches in the IDE: In IntelliJ IDEA, navigate to File -\u0026gt; Invalidate Caches to clear any cached information that might be causing issues. Then, restart the IntelliJ IDEA. Dependency Inheritence In Maven, dependency inheritance refers to the ability to inherit dependencies from a parent project. This feature enables better management of dependencies in multi-module projects, where a child module can inherit dependency configurations from the parent POM.\nSHOW CODE Parent POM Child POM \u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;parent-project\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; \u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;child-project1\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;child-project2\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.12\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- These dependencies can be inherited by child projects --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.commons\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-lang3\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.12.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; \u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;parent-project\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;relativePath\u0026gt;../pom.xml\u0026lt;/relativePath\u0026gt; \u0026lt;!-- Path to the parent POM --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;artifactId\u0026gt;child-project1\u0026lt;/artifactId\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- Child module can use the dependency inherited from the parent --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-core\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; In the above code, The spring-core dependency is inherited from the parent, and the version is automatically resolved by Maven from the parent’s dependencyManagement section. The commons-lang3 dependency from the parent is also inherited, but does not need to be re-declared in the child POM.\nThe difference between dependencyManagement and dependencies is that dependencies directly add dependencies to the project build, meaning they are included in the project\u0026rsquo;s final artifact. On the other hand, dependencyManagement specifies the version and configuration of dependencies for inheritance in child modules, without directly adding them to the project build.\nGit Backend Development Microservices Architecture Class Design Features Read Base Attribute ER Diagram SHOW CODE Java @RestController @RequestMapping(value = \u0026quot;/api/album\u0026quot;) public class BaseCategoryApiController { @Autowired BaseCategoryService baseCategoryService; @GetMapping(\u0026quot;/category/findAttribute/{category1Id}\u0026quot;) public Result\u0026lt;List\u0026lt;BaseAttribute\u0026gt;\u0026gt; getAttributeByCategory1Id(@PathVariable @Min(1) Long category1Id) { List\u0026lt;BaseAttribute\u0026gt; list = baseCategoryService.getAttributeByCategory1Id(category1Id); return Result.ok(list); } } public interface BaseCategoryService extends IService\u0026lt;BaseCategory1\u0026gt; { List\u0026lt;BaseAttribute\u0026gt; getAttributeByCategory1Id(Long category1Id); } public class BaseCategoryServiceImpl extends ServiceImpl\u0026lt;BaseCategory1Mapper, BaseCategory1\u0026gt; implements BaseCategoryService { @Autowired private BaseAttributeMapper baseAttributeMapper; public List\u0026lt;BaseAttribute\u0026gt; getAttributeByCategory1Id(Long category1Id) { return baseAttributeMapper.getAttributeByCategory1Id(category1Id); } } @Mapper public interface BaseAttributeMapper extends BaseMapper\u0026lt;BaseAttribute\u0026gt; { List\u0026lt;BaseAttribute\u0026gt; getAttributeByCategory1Id(@Param(\u0026quot;category1Id\u0026quot;) Long category1Id); } \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026quot;-//mybatis.org//DTD Mapper 3.0//EN\u0026quot; \u0026quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026quot; \u0026gt; \u0026lt;mapper namespace=\u0026quot;dev.signalyu.tingshu.album.mapper.BaseAttributeMapper\u0026quot;\u0026gt; \u0026lt;resultMap id=\u0026quot;baseAttributeMap\u0026quot; type=\u0026quot;dev.signalyu.tingshu.model.album.BaseAttribute\u0026quot; autoMapping=\u0026quot;true\u0026quot;\u0026gt; \u0026lt;id column=\u0026quot;id\u0026quot; property=\u0026quot;id\u0026quot; /\u0026gt; \u0026lt;collection property=\u0026quot;attributeValueList\u0026quot; ofType=\u0026quot;dev.signalyu.tingshu.model.album.BaseAttributeValue\u0026quot; autoMapping=\u0026quot;true\u0026quot;\u0026gt; \u0026lt;id column=\u0026quot;base_attribute_value_id\u0026quot; property=\u0026quot;id\u0026quot; /\u0026gt; \u0026lt;/collection\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;select id=\u0026quot;getAttributeByCategory1Id\u0026quot; resultMap=\u0026quot;baseAttributeMap\u0026quot;\u0026gt; select ba.id, ba.category1_id, ba.attribute_name, bav.id as base_attribute_value_id, bav.value_name from base_attribute as ba left join base_attribute_value bav on ba.id = bav.attribute_id where category1_id = #{category1Id} and ba.is_deleted = 0; \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; @Data @TableName(\u0026quot;base_attribute\u0026quot;) public class BaseAttribute extends BaseEntity { private static final long serialVersionUID = 1L; @Schema(description = \u0026quot;Category 1 ID\u0026quot;) @TableField(\u0026quot;category1_id\u0026quot;) private Long category1Id; @Schema(description = \u0026quot;Attribute display name\u0026quot;) @TableField(\u0026quot;attribute_name\u0026quot;) private String attributeName; @TableField(exist = false) private List\u0026lt;BaseAttributeValue\u0026gt; attributeValueList; } @Data @TableName(\"base_attribute_value\") public class BaseAttributeValue extends BaseEntity { private static final long serialVersionUID = 1L; @Schema(description = \"Attribute ID\") @TableField(\"attribute_id\") private Long attributeId; @Schema(description = \"Attribute value name\") @TableField(\"value_name\") private String valueName; } SHOW RESULT SET id category1_id attribute_name base_attribute_value_id value_name 1 2 Audiobook Type 1 Male-oriented Novels 1 2 Audiobook Type 2 Female-oriented Novels 2 2 Payment Type 3 Paid 2 2 Payment Type 4 Free SHOW NOTES Architecture Flow: Controller → BaseCategoryService (Interface) → BaseCategoryServiceImpl (Implementation) → Uses: - baseMapper (for BaseCategory1 CRUD) - baseAttributeMapper (for custom queries) namespace: The namespace defines the Java interface that the XML mapper is associated with. It is used to uniquely identify the mapper in the context of MyBatis. In the above code, dev.signalyu.tingshu.album.mapper.BaseAttributeMapper represents the fully qualified name of the Java interface that the mapper belongs to. This means that the methods declared in the interface BaseAttributeMapper will use the SQL statements defined in the XML file. resultMap/collection/autoMapping: The resultMap is used to define how the result set from a query is mapped to Java objects. The collection element is used to map a collection of objects (e.g., List, Set) that are related to the main object being mapped. The autoMapping attribute tells MyBatis to automatically map the fields of the result set to the properties of the Java object. In the above code, The id=\u0026quot;baseAttributeMap\u0026quot; defines a mapping for BaseAttribute class, where the columns of the result set are mapped to the fields of the BaseAttribute class. The column=\u0026quot;id\u0026quot; in result set maps to the property=\u0026quot;id\u0026quot; field in BaseAttribute. The column=\u0026quot;base_attribute_value_id\u0026quot; inside the collection tag maps to the property=\u0026quot;id\u0026quot; field in BaseAttributeValue. The select statement inside the mapper doesn\u0026rsquo;t query attribute_id field. When mybatis performs mapping, the attributeId in BaseAttributeValue objects will be null. Update ER Diagram: album_info \u0026amp; album_stat SHOW CODE Java @RestController @RequestMapping(\u0026quot;api/album\u0026quot;) public class AlbumInfoApiController { @Autowired private AlbumInfoService albumInfoService; @PostMapping(\u0026quot;/albumInfo/saveAlbumInfo\u0026quot;) public Result saveAlbumInfo(@RequestBody @Validated AlbumInfoVo albumInfoVo){ Long userId = AuthContextHolder.getUserId(); albumInfoService.saveAlbumInfo(userId, albumInfoVo); return Result.ok(); } } public interface AlbumInfoService extends IService\u0026lt;AlbumInfo\u0026gt; { void saveAlbumInfo(Long userId, AlbumInfoVo albumInfoVo); void saveAlbumStat(Long albumId, String statType, int statNum); } @Service public class AlbumInfoServiceImpl extends ServiceImpl\u0026lt;AlbumInfoMapper, AlbumInfo\u0026gt; implements AlbumInfoService { @Autowired private AlbumInfoMapper albumInfoMapper; @Autowired private AlbumAttributeValueMapper albumAttributeValueMapper; @Autowired private AlbumStatMapper albumStatMapper; @Override @Transactional(rollbackFor = Exception.class) public void saveAlbumInfo(Long userId, AlbumInfoVo albumInfoVo) { AlbumInfo albumInfo = BeanUtil.copyProperties(albumInfoVo, AlbumInfo.class); albumInfo.setUserId(userId); albumInfo.setIncludeTrackCount(0); albumInfo.setIsFinished(\u0026quot;0\u0026quot;); albumInfo.setTracksForFree(5); albumInfo.setStatus(SystemConstant.ALBUM_STATUS_PASS); albumInfoMapper.insert(albumInfo); Long albumId = albumInfo.getId(); List\u0026lt;AlbumAttributeValueVo\u0026gt; albumAttributeValueVoList = albumInfoVo.getAlbumAttributeValueVoList(); if (CollectionUtil.isNotEmpty(albumAttributeValueVoList)) { for (AlbumAttributeValueVo albumAttributeValueVo : albumAttributeValueVoList) { AlbumAttributeValue albumAttributeValue = BeanUtil.copyProperties(albumAttributeValueVo, AlbumAttributeValue.class); albumAttributeValue.setAlbumId(albumId); albumAttributeValueMapper.insert(albumAttributeValue); } } this.saveAlbumStat(albumId, SystemConstant.ALBUM_STAT_PLAY, 0); this.saveAlbumStat(albumId, SystemConstant.ALBUM_STAT_SUBSCRIBE, 0); this.saveAlbumStat(albumId, SystemConstant.ALBUM_STAT_BUY, 0); this.saveAlbumStat(albumId, SystemConstant.ALBUM_STAT_COMMENT, 0); } @Override public void saveAlbumStat(Long albumId, String statType, int statNum) { AlbumStat albumStat = new AlbumStat(); albumStat.setAlbumId(albumId); albumStat.setStatType(statType); albumStat.setStatNum(statNum); albumStatMapper.insert(albumStat); } } SHOW NOTES public interface AlbumInfoService extends IService\u0026lt;AlbumInfo\u0026gt; {} public class ServiceImpl\u0026lt;M extends BaseMapper\u0026lt;T\u0026gt;, T\u0026gt; implements IService\u0026lt;T\u0026gt; {} public interface BaseMapper\u0026lt;T\u0026gt; extends Mapper\u0026lt;T\u0026gt; {} public interface AlbumInfoMapper extends BaseMapper\u0026lt;AlbumInfo\u0026gt; {} public interface AlbumAttributeValueMapper extends BaseMapper\u0026lt;AlbumAttributeValue\u0026gt; {} public interface AlbumStatMapper extends BaseMapper\u0026lt;AlbumStat\u0026gt; {} public class AlbumInfoServiceImpl extends ServiceImpl\u0026lt;AlbumInfoMapper, AlbumInfo\u0026gt; implements AlbumInfoService { // ... albumInfoMapper.insert(albumInfo); // ... albumAttributeValueMapper.insert(albumAttributeValue); // ... albumStatMapper.insert(albumStat); } The BaseMapper\u0026lt;T\u0026gt; interface provides ready-to-use database operations, eliminating the need for a mapper.xml file. As a result, the three mappers—albumInfoMapper, albumAttributeValueMapper, and albumStatMapper—can utilize the insert method without the need to write a mapper.xml file.\nDelete Using Views Views are useful in several scenarios, including when complex queries are frequently used or when providing controlled access to specific data for security purposes.\nCategory ER Diagram SHOW CODE SQL CREATE OR REPLACE VIEW base_category_view AS SELECT bc3.id, bc1.id category1_id, bc1.name category1_name, bc2.id category2_id, bc2.name category2_name, bc3.id category3_id, bc3.name category3_name, bc3.is_deleted, bc3.create_time, bc3.update_time FROM base_category1 bc1 LEFT JOIN base_category2 bc2 ON bc2.category1_id = bc1.id LEFT JOIN base_category3 bc3 ON bc3.category2_id = bc2.id; -- Basic query SELECT * FROM base_category_view; -- Filtered query SELECT category1_name, category2_name, category3_name FROM base_category_view WHERE is_deleted = 0; Grouping Show Data category1_id category1_name category2_id category2_name category3_id category3_name 1 Music 101 Music Effects 1001 Hypnotic Music 1 Music 101 Music Effects 1002 Relaxation Music 1 Music 101 Music Effects 1003 Energizing Music 1 Music 101 Music Effects 1004 Prenatal Music 1 Music 101 Music Effects 1005 Workout Music 1 Music 101 Music Effects 1006 Leisure Music 1 Music 102 Course Guidance 1007 Sleep Assistance Guide 1 Music 102 Course Guidance 1008 Relaxation Guide 1 Music 102 Course Guidance 1009 Focus Guide 1 Music 102 Course Guidance 1010 Children Sleep Guide 1 Music 102 Course Guidance 1011 Other 1 Music 103 Host Music Show 1012 Classic Music Recommendation 1 Music 103 Host Music Show 1013 Hot Song Roundup 1 Music 103 Host Music Show 1014 Cover Songs 1 Music 103 Host Music Show 1015 Music Education 1 Music 103 Host Music Show 1016 Music Stories 2 Audiobook 104 Male Frequency Novels 1018 Military Novels 2 Audiobook 104 Male Frequency Novels 1019 Sports Novels 2 Audiobook 104 Male Frequency Novels 1020 Alternate Dimensions 2 Audiobook 104 Male Frequency Novels 1021 Fantasy 2 Audiobook 104 Male Frequency Novels 1022 Suspense \u0026amp; Paranormal 2 Audiobook 104 Male Frequency Novels 1023 Martial Arts 2 Audiobook 104 Male Frequency Novels 1024 Urban 2 Audiobook 104 Male Frequency Novels 1025 Immortal Heroes 2 Audiobook 104 Male Frequency Novels 1026 Fantasy Fiction 2 Audiobook 104 Male Frequency Novels 1027 Historical Novels 2 Audiobook 104 Male Frequency Novels 1028 Game Novels 2 Audiobook 104 Male Frequency Novels 1029 Science Fiction 2 Audiobook 105 Female Frequency Novels 1030 Fantasy Romance 2 Audiobook 105 Female Frequency Novels 1031 Romantic Youth 2 Audiobook 105 Female Frequency Novels 1032 Modern Romance 2 Audiobook 105 Female Frequency Novels 1033 Ancient Romance SHOW CODE Java Json @RestController @RequestMapping(value = \u0026quot;/api/album\u0026quot;) public class BaseCategoryApiController { @Autowired private BaseCategoryService baseCategoryService; @GetMapping(\u0026quot;/category/getBaseCategoryList\u0026quot;) public Result\u0026lt;List\u0026lt;JSONObject\u0026gt;\u0026gt; getBaseCategoryList() { List\u0026lt;JSONObject\u0026gt; list = baseCategoryService.getBaseCategoryList(); return Result.ok(list); } } public interface BaseCategoryService extends IService\u0026lt;BaseCategory1\u0026gt; { List\u0026lt;JSONObject\u0026gt; getBaseCategoryList(); } @Service public class BaseCategoryServiceImpl extends ServiceImpl\u0026lt;BaseCategory1Mapper, BaseCategory1\u0026gt; implements BaseCategoryService { @Autowired private BaseCategory1Mapper baseCategory1Mapper; @Autowired private BaseCategory2Mapper baseCategory2Mapper; @Autowired private BaseCategory3Mapper baseCategory3Mapper; @Autowired private BaseCategoryViewMapper baseCategoryViewMapper; @Override public List\u0026lt;JSONObject\u0026gt; getBaseCategoryList() { // Create target collection List\u0026lt;JSONObject\u0026gt; allList = new ArrayList\u0026lt;\u0026gt;(); // Query all category data from view List\u0026lt;BaseCategoryView\u0026gt; allCategoryList = baseCategoryViewMapper.selectList(null); // Process level 1 categories - group by level 1 category ID // Using Stream to group into Map where key=level1Id, value=list of categories Map\u0026lt;Long, List\u0026lt;BaseCategoryView\u0026gt;\u0026gt; category1Map = allCategoryList.stream() .collect(Collectors.groupingBy(BaseCategoryView::getCategory1Id)); if (CollectionUtil.isNotEmpty(category1Map)) { for (Map.Entry\u0026lt;Long, List\u0026lt;BaseCategoryView\u0026gt;\u0026gt; entry1 : category1Map.entrySet()) { // Process each level 1 category Long category1Id = entry1.getKey(); String category1Name = entry1.getValue().get(0).getCategory1Name(); // Build level 1 category JSON object JSONObject jsonObject1 = new JSONObject(); jsonObject1.put(\u0026quot;categoryId\u0026quot;, category1Id); jsonObject1.put(\u0026quot;categoryName\u0026quot;, category1Name); // Process level 2 categories within current level 1 category Map\u0026lt;Long, List\u0026lt;BaseCategoryView\u0026gt;\u0026gt; category2Map = entry1.getValue().stream() .collect(Collectors.groupingBy(BaseCategoryView::getCategory2Id)); if (CollectionUtil.isNotEmpty(category2Map)) { List\u0026lt;JSONObject\u0026gt; jsonObject2List = new ArrayList\u0026lt;\u0026gt;(); for (Map.Entry\u0026lt;Long, List\u0026lt;BaseCategoryView\u0026gt;\u0026gt; entry2 : category2Map.entrySet()) { // Get level 2 category ID and name Long category2Id = entry2.getKey(); String category2Name = entry2.getValue().get(0).getCategory2Name(); // Build level 2 category JSON object JSONObject jsonObject2 = new JSONObject(); jsonObject2.put(\u0026quot;categoryId\u0026quot;, category2Id); jsonObject2.put(\u0026quot;categoryName\u0026quot;, category2Name); // Process level 3 categories within current level 2 category List\u0026lt;JSONObject\u0026gt; jsonObject3List = new ArrayList\u0026lt;\u0026gt;(); for (BaseCategoryView baseCategoryView : entry2.getValue()) { // Get level 3 category ID and name Long category3Id = baseCategoryView.getCategory3Id(); String category3Name = baseCategoryView.getCategory3Name(); // Build level 3 category JSON object JSONObject jsonObject3 = new JSONObject(); jsonObject3.put(\u0026quot;categoryId\u0026quot;, category3Id); jsonObject3.put(\u0026quot;categoryName\u0026quot;, category3Name); jsonObject3List.add(jsonObject3); } // Add level 3 categories to level 2 object's \u0026quot;categoryChild\u0026quot; jsonObject2.put(\u0026quot;categoryChild\u0026quot;, jsonObject3List); jsonObject2List.add(jsonObject2); } // Add level 2 categories to level 1 object's \u0026quot;categoryChild\u0026quot; jsonObject1.put(\u0026quot;categoryChild\u0026quot;, jsonObject2List); } // Add level 1 category to final result list allList.add(jsonObject1); } } return allList; } } @Mapper public interface BaseCategoryViewMapper extends BaseMapper\u0026lt;BaseCategoryView\u0026gt; { } [ { \"categoryName\": \"Music\", \"categoryId\": 1, \"categoryChild\": [ { \"categoryName\": \"Music \u0026 Sound Effects\", \"categoryId\": 101, \"categoryChild\": [ {\"categoryName\": \"Hypnotic Music\", \"categoryId\": 1001}, {\"categoryName\": \"Relaxation Music\", \"categoryId\": 1002}, {\"categoryName\": \"Energizing Music\", \"categoryId\": 1003}, {\"categoryName\": \"Prenatal Music\", \"categoryId\": 1004}, {\"categoryName\": \"Workout Music\", \"categoryId\": 1005}, {\"categoryName\": \"Leisure Music\", \"categoryId\": 1006} ] }, { \"categoryName\": \"Guided Courses\", \"categoryId\": 102, \"categoryChild\": [ {\"categoryName\": \"Sleep Guidance\", \"categoryId\": 1007}, {\"categoryName\": \"Relaxation Guidance\", \"categoryId\": 1008}, {\"categoryName\": \"Focus Guidance\", \"categoryId\": 1009}, {\"categoryName\": \"Children's Sleep Guidance\", \"categoryId\": 1010}, {\"categoryName\": \"Others\", \"categoryId\": 1011} ] }, { \"categoryName\": \"Host Music Programs\", \"categoryId\": 103, \"categoryChild\": [ {\"categoryName\": \"Classic Music Recommendations\", \"categoryId\": 1012}, {\"categoryName\": \"Hot Songs Highlights\", \"categoryId\": 1013}, {\"categoryName\": \"Song Covers\", \"categoryId\": 1014}, {\"categoryName\": \"Music Lessons\", \"categoryId\": 1015}, {\"categoryName\": \"Music Stories\", \"categoryId\": 1016} ] } ] }, { \"categoryName\": \"Audiobooks\", \"categoryId\": 2, \"categoryChild\": [ { \"categoryName\": \"Male-Oriented Fiction\", \"categoryId\": 104, \"categoryChild\": [ {\"categoryName\": \"Military Fiction\", \"categoryId\": 1018}, {\"categoryName\": \"Sports Fiction\", \"categoryId\": 1019}, {\"categoryName\": \"N-Dimensional\", \"categoryId\": 1020}, {\"categoryName\": \"Fantasy\", \"categoryId\": 1021}, {\"categoryName\": \"Suspense \u0026 Supernatural\", \"categoryId\": 1022}, {\"categoryName\": \"Martial Arts\", \"categoryId\": 1023}, {\"categoryName\": \"Urban Fiction\", \"categoryId\": 1024}, {\"categoryName\": \"Xianxia\", \"categoryId\": 1025}, {\"categoryName\": \"Xuanhuan\", \"categoryId\": 1026}, {\"categoryName\": \"Historical Fiction\", \"categoryId\": 1027}, {\"categoryName\": \"Gaming Fiction\", \"categoryId\": 1028}, {\"categoryName\": \"Science Fiction\", \"categoryId\": 1029} ] }, { \"categoryName\": \"Female-Oriented Fiction\", \"categoryId\": 105, \"categoryChild\": [ {\"categoryName\": \"Fantasy Romance\", \"categoryId\": 1030}, {\"categoryName\": \"Youth Romance\", \"categoryId\": 1031}, {\"categoryName\": \"Modern Romance\", \"categoryId\": 1032}, {\"categoryName\": \"Historical Romance\", \"categoryId\": 1033} ] } ] } ] Paging Query, Dynamic Query, Row-to-Column Transformation ER Diagram: album_info \u0026amp; album_stat SHOW DATA SETS album_info Table: id album_title cover_url include_track_count create_time 1 Night Piano Melodies https://imagev2...xxx.png 55 2023-04-04 09:05:02 2 Classic Gramophone https://imagev2...yyy.png 55 2023-04-04 09:05:27 album_stat Table: album_id stat_type stat_num 1 0401 1 1 0402 0 1 0403 0 1 0404 999 2 0401 1 2 0402 0 2 0403 0 2 0404 0 SHOW CODE Java @RestController @RequestMapping(\u0026quot;api/album\u0026quot;) public class AlbumInfoApiController { @PostMapping(\u0026quot;/albumInfo/findUserAlbumPage/{page}/{limit}\u0026quot;) @TingshuLogin public Result\u0026lt;Page\u0026lt;AlbumListVo\u0026gt;\u0026gt; getUserAlbumPage(@RequestBody AlbumInfoQuery albumInfoQuery, @PathVariable int page, @PathVariable int limit) { // Get user ID and set it to query object Long userId = AuthContextHolder.getUserId(); albumInfoQuery.setUserId(userId); // Use MyBatisPlus pagination at controller level Page\u0026lt;AlbumListVo\u0026gt; pageInfo = new Page\u0026lt;\u0026gt;(page, limit); pageInfo = albumInfoService.getUserAlbumPage(pageInfo, albumInfoQuery); return Result.ok(pageInfo); } } public interface AlbumInfoService extends IService\u0026lt;AlbumInfo\u0026gt; { Page\u0026lt;AlbumListVo\u0026gt; getUserAlbumPage(Page\u0026lt;AlbumListVo\u0026gt; pageInfo, AlbumInfoQuery albumInfoQuery); } @Service public class AlbumInfoServiceImpl extends ServiceImpl\u0026lt;AlbumInfoMapper, AlbumInfo\u0026gt; implements AlbumInfoService { @Override public Page\u0026lt;AlbumListVo\u0026gt; getUserAlbumPage(Page\u0026lt;AlbumListVo\u0026gt; pageInfo, AlbumInfoQuery albumInfoQuery) { return albumInfoMapper.getUserAlbumPage(pageInfo, albumInfoQuery); } } @Mapper public interface AlbumInfoMapper extends BaseMapper\u0026lt;AlbumInfo\u0026gt; { Page\u0026lt;AlbumListVo\u0026gt; getUserAlbumPage(Page\u0026lt;AlbumListVo\u0026gt; pageInfo, @Param(\u0026quot;vo\u0026quot;) AlbumInfoQuery albumInfoQuery); } \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026quot;-//mybatis.org//DTD Mapper 3.0//EN\u0026quot; \u0026quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026quot; \u0026gt; \u0026lt;mapper namespace=\u0026quot;dev.signalyu.tingshu.album.mapper.AlbumInfoMapper\u0026quot;\u0026gt; \u0026lt;select id=\u0026quot;getUserAlbumPage\u0026quot; resultType=\u0026quot;dev.signalyu.tingshu.vo.album.AlbumListVo\u0026quot;\u0026gt; select ai.id albumId, ai.album_title, ai.cover_url, ai.include_track_count, ai.create_time, max(if(stat.stat_type = '0401', stat_num, 0)) playStatNum, max(if(stat.stat_type = '0402', stat_num, 0)) subscribeStatNum, max(if(stat.stat_type = '0403', stat_num, 0)) buyStatNum, max(if(stat.stat_type = '0404', stat_num, 0)) commentStatNum from album_info ai inner join album_stat stat on stat.album_id = ai.id \u0026lt;where\u0026gt; \u0026lt;if test=\u0026quot;vo.userId != null\u0026quot;\u0026gt; ai.user_id = #{vo.userId} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026quot;vo.status != null and vo.status != ''\u0026quot;\u0026gt; and ai.status = #{vo.status} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026quot;vo.albumTitle != null and vo.albumTitle != ''\u0026quot;\u0026gt; and ai.album_title like concat('%', #{vo.albumTitle} ,'%') \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; and ai.is_deleted = 0 group by ai.id order by ai.id desc \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; SHOW RESULT SETS Result Sets: albumId album_title cover_url include_track_count create_time playStatNum subscribeStatNum buyStatNum commentStatNum 1 Night Piano Melodies https://imagev2...xxx.png 55 2023-04-04 09:05:02 1 0 0 999 2 Classic Gramophone https://imagev2...yyy.png 55 2023-04-04 09:05:27 1 0 0 0 SHOW NOTES MyBatis-Plus dynamically modifies SQL statements for pagination using the PaginationInnerInterceptor. The standard implementation flow is as follows: // Configuration Setup @Configuration @MapperScan(\u0026#34;dev.signalyu.tingshu.*.mapper\u0026#34;) public class MybatisPlusConfig { @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() { MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); // Add pagination interceptor with MySQL dialect interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; } } // Pagination Query Execution public class AlbumInfoApiController { Page\u0026lt;AlbumListVo\u0026gt; pageInfo = new Page\u0026lt;\u0026gt;(page, limit); pageInfo = albumInfoService.getUserAlbumPage(pageInfo, albumInfoQuery); } public interface AlbumInfoService extends IService\u0026lt;AlbumInfo\u0026gt; { Page\u0026lt;AlbumListVo\u0026gt; getUserAlbumPage(Page\u0026lt;AlbumListVo\u0026gt; pageInfo, AlbumInfoQuery albumInfoQuery); } public class AlbumInfoServiceImpl extends ServiceImpl\u0026lt;AlbumInfoMapper, AlbumInfo\u0026gt; implements AlbumInfoService { @Override public Page\u0026lt;AlbumListVo\u0026gt; getUserAlbumPage(Page\u0026lt;AlbumListVo\u0026gt; pageInfo, AlbumInfoQuery albumInfoQuery) { return albumInfoMapper.getUserAlbumPage(pageInfo, albumInfoQuery); } } public interface AlbumInfoMapper extends BaseMapper\u0026lt;AlbumInfo\u0026gt; { Page\u0026lt;AlbumListVo\u0026gt; getUserAlbumPage(Page\u0026lt;AlbumListVo\u0026gt; pageInfo, @Param(\u0026#34;vo\u0026#34;) AlbumInfoQuery albumInfoQuery); } Dynamic Query in MyBatis and MyBatisPlus --- MyBatis --- \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;vo.userId != null\u0026#34;\u0026gt; ai.user_id = #{vo.userId} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;vo.status != null and vo.status != \u0026#39;\u0026#39;\u0026#34;\u0026gt; and ai.status = #{vo.status} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;vo.albumTitle != null and vo.albumTitle != \u0026#39;\u0026#39;\u0026#34;\u0026gt; and ai.album_title like concat(\u0026#39;%\u0026#39;, #{vo.albumTitle} ,\u0026#39;%\u0026#39;) \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; --- MyBatisPlus --- QueryWrapper\u0026lt;AlbumInfo\u0026gt; queryWrapper = new QueryWrapper\u0026lt;\u0026gt;(); // \u0026#34;vo\u0026#34; represents an object of AlbumInfoQuery class queryWrapper.eq(vo.getUserId() != null, \u0026#34;user_id\u0026#34;, vo.getUserId()) .eq(vo.getStatus() != null \u0026amp;\u0026amp; !vo.getStatus().isEmpty(), \u0026#34;status\u0026#34;, vo.getStatus()) .like(vo.getAlbumTitle() != null \u0026amp;\u0026amp; !vo.getAlbumTitle().isEmpty(), \u0026#34;album_title\u0026#34;, vo.getAlbumTitle()) .eq(\u0026#34;is_deleted\u0026#34;, 0) .orderByDesc(\u0026#34;id\u0026#34;); albumInfoService.list(queryWrapper); Row-to-Column Transformation --- Use MAX() and IF() --- select ai.id AS albumId, ai.album_title, ai.cover_url, ai.include_track_count, ai.create_time, --- Even though IF() returns only one value (0 or stat_type), --- --- it is necessary to use an aggregate function like MAX() to --- --- ensure proper behavior in the GROUP BY clause --- max(if(stat.stat_type = \u0026#39;0401\u0026#39;, stat_num, 0)) playStatNum, max(if(stat.stat_type = \u0026#39;0402\u0026#39;, stat_num, 0)) subscribeStatNum, max(if(stat.stat_type = \u0026#39;0403\u0026#39;, stat_num, 0)) buyStatNum, max(if(stat.stat_type = \u0026#39;0404\u0026#39;, stat_num, 0)) commentStatNum from album_info ai inner join album_stat stat on stat.album_id = ai.id group by ai.id; --- Use MAX() and CASE...WHEN --- SELECT ai.id AS albumId, ai.album_title, ai.cover_url, ai.include_track_count, ai.create_time, --- Even though IF() returns only one value (0 or stat_type), --- --- it is necessary to use an aggregate function like MAX() to --- --- ensure proper behavior in the GROUP BY clause --- MAX(CASE WHEN stat.stat_type = \u0026#39;0401\u0026#39; THEN stat.stat_num ELSE 0 END) AS playStatNum, MAX(CASE WHEN stat.stat_type = \u0026#39;0402\u0026#39; THEN stat.stat_num ELSE 0 END) AS subscribeStatNum, MAX(CASE WHEN stat.stat_type = \u0026#39;0403\u0026#39; THEN stat.stat_num ELSE 0 END) AS buyStatNum, MAX(CASE WHEN stat.stat_type = \u0026#39;0404\u0026#39; THEN stat.stat_num ELSE 0 END) AS commentStatNum FROM album_info ai INNER JOIN album_stat stat ON stat.album_id = ai.id GROUP BY ai.id, ai.album_title, ai.cover_url, ai.include_track_count, ai.create_time; --- Use GROUP_CONCAT() and IF() --- SELECT ai.id AS albumId, ai.album_title, ai.cover_url, ai.include_track_count, ai.create_time, GROUP_CONCAT(IF(stat.stat_type = \u0026#39;0401\u0026#39;, stat.stat_num, 0) ORDER BY stat.stat_type) AS playStatNum, GROUP_CONCAT(IF(stat.stat_type = \u0026#39;0402\u0026#39;, stat.stat_num, 0) ORDER BY stat.stat_type) AS subscribeStatNum, GROUP_CONCAT(IF(stat.stat_type = \u0026#39;0403\u0026#39;, stat.stat_num, 0) ORDER BY stat.stat_type) AS buyStatNum, GROUP_CONCAT(IF(stat.stat_type = \u0026#39;0404\u0026#39;, stat.stat_num, 0) ORDER BY stat.stat_type) AS commentStatNum FROM album_info ai INNER JOIN album_stat stat ON stat.album_id = ai.id GROUP BY ai.id; It is important to note that when performing row-to-column transformation, applying an aggregate function such as MAX() or GROUP_CONCAT() is necessary. Otherwise, MySQL will raise an exception similar to \u0026ldquo;nonaggregated column is not functionally dependent on columns in GROUP BY clause.\u0026rdquo; For example, running the following query will result in an error message like: SELECT list is not in GROUP BY clause and contains nonaggregated column 'tingshu_album.stat.stat_type' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by.\nSELECT ai.id AS albumId, ai.album_title, ai.cover_url, ai.include_track_count, ai.create_time, if(stat.stat_type = \u0026#39;0401\u0026#39;, stat_num, 0) AS playStatNum, if(stat.stat_type = \u0026#39;0402\u0026#39;, stat_num, 0) AS subscribeStatNum, if(stat.stat_type = \u0026#39;0403\u0026#39;, stat_num, 0) AS buyStatNum, if(stat.stat_type = \u0026#39;0404\u0026#39;, stat_num, 0) AS commentStatNum FROM album_info ai INNER JOIN album_stat stat ON stat.album_id = ai.id GROUP BY ai.id; Database Caching ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/development-manual/1-development-manual/","summary":"IDEA Postfix Completion Postfix completion allows writing code faster by adding expressions after a variable or value. It can be customized to suit specific coding needs.\n\u0026#34;Hello\u0026#34;.var → String s = \u0026#34;Hello\u0026#34;; Live Templates Live Templates are predefined code snippets that can be inserted quickly using a shortcut. It can be customized to suit specific coding needs.\nsout → System.out.println(); Keyboard Shortcuts Show Hint: Alt + Enter Show Parameter Info: Ctrl + P Surround with Selected Code Block: Ctrl + Alt + J Start a New Line: Shift + Enter Start a New Line Before Current: Ctrl + Alt + Enter Show Live Template: Ctrl + J Rename in Batch: Shift + F6 Extract Method: Ctrl + Alt + M Override Methods: Ctrl + O Implement Methods: Ctrl + I Optimize Imports: Ctrl + Alt + O View Source Code: Ctrl + N → Ctrl + F12 Go to Previous Edit Location: Ctrl + Alt + ← Go to Next Edit Location: Ctrl + Alt + → Show Inheritance Tree: Ctrl + H Show Quick Documentation: Ctrl + Q Show UML Diagram: Ctrl + Alt + U Go to Specified Line: Ctrl + G → Enter line number Go to Variable Definition: Ctrl + Alt + B Expand Code Block: Ctrl + Shift + + Collapse Code Block: Ctrl + Shift + - Debug Method Breakpoints Field Breakpoints Conditional Breakpoints Thread Debug Custom Data Views Config Tomcat Create Maven Java Project Create Maven Java Web Maven Introduction to Maven Maven is a build automation and project management tool primarily used for Java projects.","title":"Development Manual"},{"content":"Core Concepts Loose Coupling Loose Coupling is a design principle that aims to reduce the dependencies between components within a system.\nInversion of Control (IoC) Inversion of Control is a design principle where the control of object creation and lifecycle management is transferred from the application code to an external container or framework.\nDependency Injection (DI) Dependency Injection is a design pattern commonly used in object-oriented programming, where the dependecies of a class are provided externally rather than being created within the class itself.\nBeans Beans are objects that are managed by the Spring framework.\nContainer A Spring Container is responsible for managing the life cycle, configuration, and dependencies injection of the beans in a Spring Application.\nLife Cycle of Beans Beans are objects that are managed by the Spring framework. Bean Definition includes configuration meta data required by the Spring container to create and manage the bean. Bean Configurations can be provided in various way, including XML configuration files, annotations, and Java-based configuration. Bean Instantiation $\\rightarrow$ Population of Properties $\\rightarrow$ Initialization $\\rightarrow$ Ready for Use $\\rightarrow$ Destruction The Difference between instantiation and initiation?\nInstantiation occurs when a new keyword is used to create an object. It focus on constructing the object\u0026rsquo;s structure and allocating memory. In contrast, initialization focus on assigning values to the object\u0026rsquo;s fields and setting up its initial state after instantiation.\nConstructor Injection \u0026amp; Setter Injection \u0026amp; Field Injection Constructor Injection Constructor Injection in Spring is a type of dependency injection where the Spring framework provides the required dependency to a class by invoking its constructor. Since dependencies are supplied via the constructor, they cannot be changed after object creation \u0026ndash; promoting immutability. However, this approach may cause circular dependency issues if two or more beans depend on each other in a circular manner.\nSHOW CODE Java @Component public class ServiceA { private final RepositoryA repositoryA; // Constructor injection @Autowired public ServiceA(RepositoryA repositoryA) { this.repositoryA = repositoryA; } } Setter Injection Setter Injection in Spring is a form of dependency injection where the Spring framework injects dependencies into a bean by calling the bean\u0026rsquo;s setter method. This approach is flexible and commonly used to inject optional dependencies or when the dependency might change after the object is initialized.\nSHOW CODE Java @Component public class ServiceB { private RepositoryB repositoryB; // Setter injection @Autowired public void setRepositoryB(RepositoryB repositoryB) { this.repositoryB = repositoryB; } } Field Injection Field Injection in Spring is a form of dependency injection where the Spring framework directly injects dependencies into a class\u0026rsquo;s fields. Like constructor injection, the dependencies remain immutable after being injected. Under the hood. Spring uses reflection to assign values to private fields.\nSHOW CODE Java @Component public class ServiceC { @Autowired private RepositoryC repositoryC; public void performAction() { repositoryC.doSomething(); } } @Component \u0026amp; @ComponentScan The @Component annotation in Spring is used to mark a class as spring-managed bean, allowing Spring to detect and register it as a bean in the application context. The @ComponentScan annotation is used to specify base packages that Spring should scan for @Component-annotated during configuration.\nSHOW CODE Java package com.example.myapp @Component public class MyService { public void performTask() { System.out.println(\"Task performed!\"); } } @Configuration @ComponentScan(basePackages = \"com.example.myapp\") public class AppConfig { } @Value \u0026amp; @Autowired \u0026amp; @Qualifier @Value The @Value annotation is used to inject values into fields, mathod parameters, and constructor arguments.\nSHOW CODE Java // Injects literal values @Value(\"Hello, World!\") private String message; // Injects from a properties file app.name=MySpringApp @Value(\"${app.name}\") private String appName; // Injects default values @Value(\"${app.version:1.0.0}\") private String appVersion; // Injects expression @Value(\"#{T(java.lang.Math).random() * 100}\") private double randomValue; @Autowired The @Autowired annotation is used for automatic dependency injection. It allows Spring resolve and inject the required bean into a class automatically by type.\nSHOW CODE Java // Field Injection @Component public class ServiceA { @Autowired private RepositoryA repositoryA; public void performTask() { repositoryA.doSomething(); } } // Setter Injection @Component public class ServiceB { private RepositoryB repositoryB; @Autowired public void setRepositoryB(RepositoryB repositoryB) { this.repositoryB = repositoryB; } } // Constructor Injection @Component public class ServiceB { private RepositoryB repositoryB; @Autowired public void setRepositoryB(RepositoryB repositoryB) { this.repositoryB = repositoryB; } } @Qualifier The @Qualifier annotation in Spring is used for resolve ambiguities when multiple beans of the same type are available in the application context.\nSHOW CODE Java @Component(\"repositoryImpl1\") public class RepositoryImpl1 implements Repository {} @Component(\"repositoryImpl2\") public class RepositoryImpl2 implements Repository {} @Component public class Service { @Autowired @Qualifier(\"repositoryImpl2\") private Repository repository; } Components of Spring Boot Spring Boot Starter: Simplifies dependency management by building commonly used dependencies, reducing the need for manual configuration.\nAuto Configuration: Automatically configures Spring Boot application beans and settings based on the libraries on the classpath, eliminating the need for extensive configuration in application.properties or XML files.\nSpring Boot Atuator: Provides production-ready features like monitoring, metrics, and health checks to ensure better application insights and management.\nEmbedded Server: Includes servers like Tomcat and Jetty, allowing applications to run as standalone programs, simplifying development and deployment.\nSpring Boot DevTools: A collection of tools that enhance the development experience by enabling features like hot reload and live reload for faster feedback.\nSpring Boot Auto Configuration Spring Boot looks for classes annotated with @Configuration and examines the dependencies in the classpath. The @Configuration annotation triggers the logic that looks for @Bean declarations within the class and registers those beans to be managed by the Spring container.\nIn a Spring Boot application, the main method typically calls the SpringApplication.run() method. This method takes the main application class (e.g., XXXApplication.class) as a parameter. The XXXAplication class is annotated with @SpringBootApplication which includes three key annotations: @SpringBootConfiguration, @EnableAutoConfiguration, and @ComponentScan.\n@SpringBootConfiguration is an alias for @Configurition. It indicates that the class contains Spring bean definitions, and Spring Boot will scan it for @Bean declarations.\n@EnableAutoConfiguration annotation tells Spring Boot to enable its auto-configuration mechanism. It looks for the file AutoConfiguration.imports inside the spring-boot-autoconfigure.jar dependency, which lists auto-configuration classes. Spring Boot automatically imports and executes every class that has the AutoConfiguration name at the end of the class name.\n# META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration org.springframework.boot.autoconfigure.aop.AopAutoConfiguration org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration ... @ComponentScan annotation tells Spring Boot to scan for Spring components (such as @Component, @Service, @Repository, etc.) in the specified packages or the entire classpath. By default, it scans from the package of the class that contains the annotation. To specify a different base package, the basePackages parameter can be set, like this:\n@ComponentScan(basePackages = {\u0026#34;com.mycompany\u0026#34;}) Common Annotations @Component vs. @Bean The @Component annotation is applied to a class to mark it as a bean managed by the Spring container. There are several specialized variants of this annotation: @Controller (for web controllers), @Service (for service layer components), and @Repository (for DAO layer components). In contrast, the @Bean annotation is used to mark a method within a class annotated with @Configuration, indicating that the method should return an object to be managed by the Spring container. This apporpach provides more control over bean creation and configuration, allowing for more explicit customization of the bean.\nSHOW CODE Java // Spring will detect UserService during classpath // scanning and manage it as a bean. @Component public class UserService { public String getUser() { return \"User\"; } } @Configuration public class AppConfig { @Bean public UserService userService() { // Explicitly creating and returning the bean return new UserService(); } } @ResposeBody The @ResponseBody annotation in Spring is used to indicate that a method\u0026rsquo;s return value should be written directly to the HTTP response body, rather than being treated as a view name, which is the default behavior in traditional Spring MVC controllers. The return value is automatically serialized into a format like JSON or XML, typically using Jackson, depending on the request\u0026rsquo;s Accept header.\nSHOW CODE Java @Controller public class MyRestController { @RequestMapping(\"/user\") @ResponseBody public User getUser() { return new User(\"John\", \"Doe\"); } } public class User { private String firstName; private String lastName; // Constructor, getters, and setters } In the above code, the User object will be automatically serialized into JSON format by Jackson when returned from the getUser() method. The @ResponseBody annotation ensures that the method\u0026rsquo;s return value is written directly to the HTTP response body, and Jackson handles the conversion to JSON.\n@Controller vs. @RestController The @Controller annotation is used to declare a class as a controller in Spring MVC. By default, methods within a @Controller-annotated class return a view name (e.g., home.jsp). If a method needs to return a value directly (such as JSON or XML), it should be annotated with @ResponseBody. In contrast, the @RestController annotation is a specialized version of @Controller used to define a controller for RESTful web services. It combines @Controller and @ResponseBody, meaning that the methods in a RestController-annotated class automatically return values written directly to the HTTP response body. This response is typically serialized into JSON or XML format by Jackson.\nSHOW CODE Java @Controller public class WebController { @RequestMapping(\"/home\") public String home() { return \"home\"; // returns home.jsp } } @Controller public class MyController { @RequestMapping(\"/greeting\") @ResponseBody public String greeting() { return \"Hello, World!\"; // The return value is written directly to the response body } } @RestController public class UserController { @RequestMapping(\"/api/user\") public User getUser() { return new User(\"Alice\", \"Smith\"); } } public class User { private String firstName; private String lastName; // Constructor, getters, and setters } @RequestBody, @RequestParam, @PathVariable The @RequestBody annotation is used to bind the body of an HTTP request to a method parameter. It is typically used with HTTP methods like POST, PUT, or PATCH to send data in formats such as JSON or XML. Spring automatically deserializes the request body into an obejct using a message converter, liek Jakson.\nSHOW CODE Java @RestController public class UserController { @PostMapping(\"/user\") public ResponseEntity\u0026lt;String\u0026gt; createUser(@RequestBody User user) { // User is automatically deserialized from the JSON request body return ResponseEntity.ok(\"User created: \" + user.getName()); } } The @RequestParam annotation binds a query parameter or form data to a method parameter. It is commonly used in GET or POST requests to retrive single query parameters. The annotation has optional attributes such as required (to specify if the parameter is mandatory) and defaultValue (to provide a default value when the parameter is absent).\nSHOW CODE Java @RestController public class SearchController { @GetMapping(\"/search\") public ResponseEntity\u0026lt;String\u0026gt; search(@RequestParam String query, @RequestParam(defaultValue = \"10\") int limit) { // query: the search term from the query string // limit: the number of results (defaults to 10 if not provided) return ResponseEntity.ok(\"Searching for: \" + query + \", Limit: \" + limit); } } The @PathVariable annotation binds a URL path variable to a method parameter, commonly used in RESTful web service to capture dynamic segments in the URL. For example, int the URL /user/{id}, the {id} part is dynamic, and the value of {id} will be extracted and passed to the method parameter.\nSHOW CODE Java @RestController public class UserController { // Regular expression to match both with and without the path variable @GetMapping(\"/user/{id:[a-zA-Z0-9]*}\") public ResponseEntity\u0026lt;String\u0026gt; getUser(@PathVariable(required = false) String id) { if (id == null) { return ResponseEntity.ok(\"Default User\"); } return ResponseEntity.ok(\"User ID: \" + id); } } Transformation between Object and Spring In Spring Boot, the transformation between objects and JSON is handled by the Jackson library which allows for easy serialization (converting an object to JSON) and deserialization (converting JSON to an object).\nSHOW CODE Java // When a controller returns an object, Spring Boot automatically // converts it to JSON @RestController public class UserController { @GetMapping(\"/user\") public User getUser() { return new User(1, \"John Doe\", \"john.doe@example.com\"); } } // When accessed via /user, the response is: { \"id\": 1, \"name\": \"John Doe\", \"email\": \"john.doe@example.com\" } // Spring Boot automatically converts the incoming JSON data into // an object when the object is a parameter in the controller method. @RestController public class UserController { @PostMapping(\"/user\") public String createUser(@RequestBody User user) { return \"User \" + user.getName() + \" created!\"; } } // Input JOSN: { \"id\": 2, \"name\": \"Jane Doe\", \"email\": \"jane.doe@example.com\" } ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/framework-and-tools/framework/backend/spring/1-spring-notes/","summary":"Core Concepts Loose Coupling Loose Coupling is a design principle that aims to reduce the dependencies between components within a system.\nInversion of Control (IoC) Inversion of Control is a design principle where the control of object creation and lifecycle management is transferred from the application code to an external container or framework.\nDependency Injection (DI) Dependency Injection is a design pattern commonly used in object-oriented programming, where the dependecies of a class are provided externally rather than being created within the class itself.","title":"Spring"},{"content":"Enum In Java, an enum (short for \u0026ldquo;enumeration\u0026rdquo;) is used to define a collection of constants, such as days of the week or months of the year. An enum provides a type-safe way to handle constant values, and it can be used in a switch statement or for comparison using ==. Compared to a final constant in Java, an enum can contain fields, methods, and constructors. The values() method is used to retrive all the constants in an enum, and the valueOf() method is used to convert a string into an enum constant.\nSHOW CODE Java enum Day { SUNDAY(1), MONDAY(2), TUESDAY(3), WEDNESDA(4), THURSDAY(5), FRIDAY(6), SATURDAY(7); private final int dayNum; Day(int dayNum) { this.dayNum = dayNum; } public int getDayNum() { return dayNum; } public static Day fromNumber(int num) { for (Day day : Day.values()) { if (day.getDayNum() == num) { return day; } } throw new IllegalArgumentException(\"Invalid day number: \" + num); } @Override public String toString() { return name() + \"(\" + dayNum + \")\"; } } public class Solution { public static void main(String[] args) { for (Day d : Day.values()) { System.out.print(d + \"\\t\"); } System.out.println(\"\\n\" + Day.fromNumber(1)); // System.out.println(Day.fromNumber(8)); // Converts a string to enum constant System.out.println(Day.valueOf(\"MONDAY\")); } } Generics In Java, Generics is a mechanism that allows writing classes, interfaces, and methods with type parameters, often represented by T, E, K, and V, and allows calling them with different type parameters. It provides strong type safety checks at compile time, enhances code reusability, and eliminates the need for casting.\nBasic Generics SHOW CODE Java interface Pair { K getKey(); V getValue(); } class SimplePair\u0026lt;K,V\u0026gt; implements Pair\u0026lt;K,V\u0026gt; { private final K key; private final V value; public SimplePair(K key, V value) { this.key = key; this.value = value; } @Override public K getKey() { return key; } @Override public V getValue() { return value; } @Override public String toString() { return \"(\" + key + \",\" + value + \")\"; } } public class Main { public static void main(String[] args) { SimplePair\u0026lt;String, Integer\u0026gt; pair = new SimplePair\u0026lt;\u0026gt;(\"Signal\", 27); System.out.println(\"pair = \" + pair); String key = pair.getKey(); System.out.println(\"key = \" + key); Integer value = pair.getValue(); System.out.println(\"value = \" + value); } } Bounded Type Parameters Bounded Type Parameters in Java allow restricting the range of types when writing generic code. It can be categorized into four types: Upper Bounded Type, Lower Bounded Type, Unbounded Type, and Multiple Bounds.\nUpper Bounded Type In Java, Upper Bounded Wildcards are used to define upper bounded types. The syntax for an upper bounded wildcard is \u0026lt;T extends SomeClassOrInterface\u0026gt;, which indicates that the argument type T must be a subclass of SomeClassOrInterface or SomeClassOrInterface itself.\nSHOW CODE Java import java.util.List; public class Main { // Method that accepts a list of elements that are of type Number or its subclasses public static void printNumbers(List\u0026lt;? extends Number\u0026gt; list) { for (Number number : list) { System.out.println(number); } } public static void main(String[] args) { List\u0026lt;Integer\u0026gt; intList = List.of(1, 2, 3, 4); List\u0026lt;Double\u0026gt; doubleList = List.of(1.1, 2.2, 3.3); printNumbers(intList); // Valid, Integer is a subclass of Number printNumbers(doubleList); // Valid, Double is a subclass of Number } } Lower Bounded Type In Java, Lower Bounded Wildcards are used to define lower bounded types. The syntax for a lower bounded wildcard is \u0026lt;T super SomeClassOrInterface\u0026gt;, which indicates that the argument type T must be a super class of SomeClassOrInterface or SomeClassOrInterface itself.\nSHOW CODE Java import java.util.ArrayList; import java.util.List; // Custom class Person class Person { String name; Person(String name) { this.name = name; } @Override public String toString() { return \"Person{name='\" + name + \"'}\"; } } // Subclass Employee extends Person class Employee extends Person { double salary; Employee(String name, double salary) { super(name); this.salary = salary; } @Override public String toString() { return \"Employee{name='\" + name + \"', salary=\" + salary + \"}\"; } } public class Main { // Method that accepts a list of Person or its superclasses (e.g., Object) // This method can add Employee objects to the list. public static void addEmployees(List\u0026lt;? super Employee\u0026gt; list) { list.add(new Employee(\"Alice\", 50000)); list.add(new Employee(\"Bob\", 60000)); list.add(new Employee(\"Charlie\", 70000)); } public static void main(String[] args) { // Create a list of Person, which is a superclass of Employee List\u0026lt;Person\u0026gt; personList = new ArrayList\u0026lt;\u0026gt;(); // Add Employee objects to the personList using the addEmployees method addEmployees(personList); // Print the list to see the added Employee objects for (Person person : personList) { System.out.println(person); } } } SHOW OUTPUT Output Employee{name='Alice', salary=50000.0} Employee{name='Bob', salary=60000.0} Employee{name='Charlie', salary=70000.0} Unbounded Type In Java, the Unbounded Type is represented by using the unbounded wildcard ?, which indicates that no restrictions are placed on the type of an argument passed to the method. It is commonly used when passing a collection of elements to a method where the specific type of the elements is not important. With an unbounded wildcard, elements can be read but cannot be added to the collection (except null) inside the methods.\nSHOW CODE Java import java.util.ArrayList; import java.util.List; class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } @Override public String toString() { return \"Person(\" + name + \", \" + age + \")\"; } } public class Main { public static void printList(List\u0026lt;?\u0026gt; list) { // Iterate over the list and print each element list.add(null); // list.add(1); for (Object element : list) { System.out.println(element); } } public static void main(String[] args) { // Create lists of different types List\u0026lt;String\u0026gt; stringList = new ArrayList\u0026lt;\u0026gt;(); stringList.add(\"Hello\"); stringList.add(\"World\"); List\u0026lt;Integer\u0026gt; intList = new ArrayList\u0026lt;\u0026gt;(); intList.add(10); intList.add(20); List\u0026lt;Object\u0026gt; objectList = new ArrayList\u0026lt;\u0026gt;(); objectList.add(\"Some String\"); objectList.add(100); objectList.add(1.1); objectList.add('a'); objectList.add(true); objectList.add(new Person(\"Signal\", 18)); objectList.add(null); // Call the printList method for each list System.out.println(\"String List:\"); printList(stringList); // Works with List\u0026lt;String\u0026gt; System.out.println(\"\\nInteger List:\"); printList(intList); // Works with List\u0026lt;Integer\u0026gt; System.out.println(\"\\nObject List:\"); printList(objectList); // Works with List\u0026lt;Object\u0026gt; } } SHOW OUTPUT Output String List: Hello World Integer List: 10 20 Object List: Some String 100 1.1 a true Person(Signal, 18) null null Multiple Bounds In Java, a Multiple Bounds constraint allows the argument type T passed to a method to extend multiple types or implement multiple interfaces. This is commonly achieved using the \u0026amp; operator. The syntax for multiple bounds is \u0026lt;T extends classType \u0026amp; Interface1 \u0026amp; Interface2\u0026gt;, indicating that the argument type T must extend the class classType and implement both Interface1 and Interface2.\nSHOW CODE Java // Interface 1 interface CanFly { void fly(); } // Interface 2 interface CanSwim { void swim(); } // A base class for animals class Animal { String name; Animal(String name) { this.name = name; } } // Class that implements both interfaces class Duck extends Animal implements CanFly, CanSwim { Duck(String name) { super(name); } @Override public void fly() { System.out.println(name + \" is flying.\"); } @Override public void swim() { System.out.println(name + \" is swimming.\"); } } // A class that uses multiple bounds in its type parameter class AnimalAction\u0026lt;T extends Animal \u0026 CanFly \u0026 CanSwim\u0026gt; { T animal; AnimalAction(T animal) { this.animal = animal; } void performActions() { animal.fly(); animal.swim(); } } public class Main { public static void main(String[] args) { // Create a Duck object Duck duck = new Duck(\"Dodo\"); // Create an AnimalAction object for Duck, which extends Animal and implements CanFly and CanSwim AnimalAction\u0026ltDuck\u0026gt; action = new AnimalAction\u0026lt;\u0026gt;(duck); // Perform actions on the Duck action.performActions(); } } Reflection Reflection in Java is a feature that allows inspecting and manipulating the properties or behaviors of classes, methods, fields, and constructors at runtime. It is commonly used to examine class information, access private methods and fields, invoke methods dynamically, and create objects dynamically using the Java Reflection API. The Java Reflection API is provided by the java.lang.reflect package and the java.lang.Class class. Some of the key classes and methods in this API include:\nClass: Represents the class of an object and provides methods like getName(), getDeclaredMethods(), getDeclaredFields(), and others to examine the class\u0026rsquo;s metadata. Method: Represents a method of a class and allows invoking it dynamically using methods like invoke(). Field: Represents a field (variable) in a class and allows accessing or modifying its value dynamically. Constructor: Represents a constructor in a class and allows creating new instances dynamically using methods like newInstance(). SHOW CODE Java package dev.signalyu.warmup; import java.lang.reflect.*; class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } private void sayHello() { System.out.println(\"Hello, \" + name); } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } } public class Main { public static void main(String[] args) throws Exception { // Create a new Person object Person person = new Person(\"John\", 30); // Get the Class object associated with the Person class Class\u003c?\u003e clazz = person.getClass(); // Get class name System.out.println(\"Class name: \" + clazz.getName()); // Get declared methods Method[] methods = clazz.getDeclaredMethods(); for (Method method : methods) { System.out.println(\"Method: \" + method.getName()); } // Get declared fields Field[] fields = clazz.getDeclaredFields(); for (Field field : fields) { System.out.println(\"Field: \" + field.getName()); } // Accessing a private field via reflection Field field = clazz.getDeclaredField(\"name\"); field.setAccessible(true); // Make the private field accessible System.out.printf(\"Private field: 'name'=%s\\n\", field.get(person)); // Get the 'sayHello' method Method method = clazz.getDeclaredMethod(\"sayHello\"); // Make the private method accessible method.setAccessible(true); // Invoke the method on the 'person' object method.invoke(person); // Dynamically load the Person class Class\u003c?\u003e clazz2 = Class.forName(\"dev.signalyu.warmup.Person\"); // Get the constructor that takes a String argument Constructor\u003c?\u003e constructor = clazz2.getConstructor(String.class, int.class); // Create an instance of Person using reflection Person Signal = (Person) constructor.newInstance(\"Signal\", 18); System.out.println(\"Signal = \" + Signal); } } SHOW OUTPUT Output Class name: dev.signalyu.warmup.Person Method: getName Method: toString Method: setName Method: sayHello Method: getAge Field: name Field: age Private field: 'name'=John Hello, John Signal = Person{name='Signal', age=18} Annotations Annotations in Java are a form of metadata used to provide additional information that does not directly affect the execution of the code. They are commonly used to convey instructions to the compiler (such as detecting errors or supressing warnings) or to support runtime processing. Annotations are prefixed with the @ symbol and can be applied to classes, methods, firlds, and other program elements.\nCommon meta annotations, such as @Target adn @Retension, are used to specify how and where an annotation can be applied. The @Target annotation defines the valid program elements for an annotation, including:\nElementType.TYPE: The annotation can be applied to a class or interface. ElementType.METHOD: The annotation can be applied to a method. ElementType.FIELD: The annotation can be applied to a field. The @Retention annotation specifies the lifespan of the annotation. Foe example, using @Retention(RetentionPolicy).RUNTIME indicates that the annotation is available at runtime for reflection.\nTo customize an annotation in Java, the first step is to define its basic structure using the @interface keyword. Elements (parameters) can be included in the annotation, with or without default values, depending on the requirements.\nNext, meta-annotation such as @Target and @Retention are added to specify where the annotation can be applied and how long it will be retained.\nOnce the annotation is defined, it can be applied according to the specified @Target (e.g., on methods, classes, or fields).\nThe final step is to define the logic for processing the annotation, typically achieved through reflection at runtime.\nSHOW CODE: Login Interception Login Interception @Getter public enum ResultCodeEnum { LOGIN_AUTH(208, \"Not logged in\"); private final int code; private final String message; ResultCodeEnum(int code, String message) { this.code = code; this.message = message; } } public class RedisConstant { /** * The prefix for user login keys in Redis. */ public static final String USER_LOGIN_KEY_PREFIX = \"user:login:\"; } public class AuthContextHolder { private static final ThreadLocal\u0026lt;Long\u0026gt; userId = new ThreadLocal\u0026lt;\u0026gt;(); /** * Sets the user ID in the thread-local context. * * @param _userId The user ID to set. */ public static void setUserId(Long _userId) { userId.set(_userId); } /** * Gets the user ID from the thread-local context. * * @return The current user ID. */ public static Long getUserId() { return userId.get(); } /** * Removes the user ID from the thread-local context. */ public static void removeUserId() { userId.remove(); } } @Target({ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Inherited @Documented public @interface AppLogin { /** * Indicates if login is required for the annotated method. * Default is true. */ boolean required() default true; } @Aspect @Component public class AppLoginAspect { @Autowired private RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate; /** * Intercepts methods annotated with @AppLogin to enforce login validation. * * @param joinPoint The proceeding join point for the intercepted method. * @param appLogin The AppLogin annotation instance. * @return The result of the intercepted method execution. * @throws Throwable If an error occurs during method execution. */ @SneakyThrows @Around(\"execution(* com.atApp.tingshu.*.api.*.*(..)) \u0026\u0026 @annotation(appLogin)\") public Object loginAspect(ProceedingJoinPoint joinPoint, AppLogin appLogin) { // Extract the token from the request header String token = getTokenFromRequest(); // Check login status in Redis String loginKey = RedisConstant.USER_LOGIN_KEY_PREFIX + token; UserInfoVo userInfoVo = (UserInfoVo) redisTemplate.opsForValue().get(loginKey); // If login is required and user is not authenticated, throw exception if (appLogin.required() \u0026\u0026 userInfoVo == null) { throw new AppException(ResultCodeEnum.LOGIN_AUTH); } // If user is authenticated, set the user ID in the thread-local context if (userInfoVo != null) { AuthContextHolder.setUserId(userInfoVo.getId()); } try { // Proceed with the method execution return joinPoint.proceed(); } finally { // Ensure that user ID is cleared after the method execution AuthContextHolder.removeUserId(); } } /** * Extracts the token from the HTTP request header. * * @return The token string. */ private String getTokenFromRequest() { RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes(); ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes) requestAttributes; HttpServletRequest request = servletRequestAttributes.getRequest(); return request.getHeader(\"token\"); } } Serialization \u0026amp; Deserialization In Java, Serialization and Deserialzation are processes used to convert objects into a byte stream and restore them back into objects, respectively. These processes are essential for storing objects in files, transmitting them over a network, or preserving their state.\nSerialization involves converting an object into a byte stream. To serialize an object, its class must implement the java.io.Serializable interface, which is a marker interface without any methods. The ObjectOutputStream class is used to write the serialized object to a file or another output stream. A serialVersionUID is automatically generated if not explicitly defined, but it is recommended to provide one manually to ensure compatibility during deserialization. Fields marked as transcient are not serialized. Additionally, any objects regerenced by the serialized object are also serialized, provided they implement the Serializable interface.\nDeserialization is the process of reconstructing a serialized object back into a Java object. For deserialization to succeed, the class must be available in the classpath. This process is performed using the ObjectInputStream class, which reads the byte stream and restores the object to its original state.\nSHOW CODE Java import java.io.*; // Define a Serializable class class Person implements Serializable { private static final long serialVersionUID = 1L; // Ensures class compatibility during deserialization private String name; private int age; // Transient field will not be serialized private transient String password; public Person(String name, int age, String password) { this.name = name; this.age = age; this.password = password; } @Override public String toString() { return \"Person{name='\" + name + \"', age=\" + age + \", password='\" + password + \"'}\"; } } public class Main { public static void main(String[] args) { Person person = new Person(\"Signal Yu\", 18, \"securePassword\"); // Serialize the object try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"person.ser\"))) { oos.writeObject(person); System.out.println(\"Object serialized successfully.\"); } catch (IOException e) { e.printStackTrace(); } // Deserialize the object try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"person.ser\"))) { Person deserializedPerson = (Person) ois.readObject(); System.out.println(\"Deserialized object: \" + deserializedPerson); } catch (IOException | ClassNotFoundException e) { e.printStackTrace(); } } } SHOW OUTPUT Output Object serialized successfully. Deserialized object: Person{name='Signal Yu', age=18, password='null'} Lambda Expression Runnable SHOW CODE Java public class Test { public static void main(String[] args) { // Java 8 之前 Runnable runnable = new Runnable() { @Override public void run() { System.out.println(\"Inside Runnable 1\"); } }; new Thread(runnable).start(); // Java 8 - Lambda 语法 Runnable runnableLambda = () -\u003e {System.out.println(\"Inside Runnable 2\");}; new Thread(runnableLambda).start(); new Thread(() -\u003e System.out.println(\"Inside Runnable 3\")).start(); } } Comparator SHOW CODE Java public class Test { public static void main(String[] args) { // JAVA 8 之前 Comparator\u0026lt;Integer\u0026gt; comparator = new Comparator\u0026lt;Integer\u0026gt;() { @Override public int compare(Integer o1, Integer o2) { /** * o1 \u003c o2 -\u003e -1 * o1 == o2 -\u003e 0 * o1 \u003e o2 -\u003e 1 */ return o1.compareTo(o2); } }; System.out.println(comparator.compare(1, 2)); // -1 /** * JAVA 8 */ // Comparator\u0026lt;Integer\u0026gt; comparatorLambda1 = (Integer a, Integer b) -\u003e a.compareTo(b); Comparator\u0026lt;Integer\u0026gt; comparatorLambda1 = Comparator.naturalOrder(); System.out.println(comparatorLambda1.compare(1, 2)); // -1 // Comparator\u0026lt;Integer\u0026gt; comparatorLambda2 = (a, b) -\u003e b.compareTo(a); Comparator\u0026lt;Integer\u0026gt; comparatorLambda2 = Comparator.reverseOrder(); System.out.println(comparatorLambda2.compare(1, 2)); // 1 int[] nums = new int[]{2, 1, 4, 3}; System.out.println(\"nums = \" + Arrays.toString(nums)); Arrays.sort(nums); // 默认为升序排序 // 倒序排序 Integer[] newNums = Arrays.stream(nums).boxed().toArray(Integer[]::new); Arrays.sort(newNums, Comparator.reverseOrder()); } } Local Variables in Lambda Expression SHOW CODE Java public class Test { public static void main(String[] args) { /** * 1. The variable used in a lambda expression must be effectively final, * meaning its value cannot change after it has been assigned. * 2. A lambda captures the values of local variables, not the variables * themselves. * 3. Local variables in a lambda cannot have the same name as variables * in the enclosing scope to avoid shadowing. */ int num = 10; // effectively final Runnable r = () -\u003e System.out.println(num); r.run(); // Error: Variable num is already defined in the scope // Runnable r = () -\u003e { // int num = 20; // Compile-time error // System.out.println(num); // }; } } Functional Interface Consumer SHOW CODE Java import java.util.Arrays; import java.util.List; import java.util.function.Consumer; public class Test { public static void main(String[] args) { List\u0026lt;String\u0026gt; items = Arrays.asList(\"One\", \"Two\", \"Three\"); /** * Consumer 接收一个参数并执行一些操作，不返回结果 * Consumer 有 accept 和 andThen 两个方法 * accept 用于接收参数，andThen 用于链接多个 Consumer */ // 示例1：定义一个 Consumer，它将打印传入的字符串 Consumer\u0026lt;String\u0026gt; printConsumer = s -\u003e System.out.println(\"打印消息: \" + s); printConsumer.accept(\"Hello, World!\"); // 输出: 打印消息: Hello, World! // 示例 2：Consumer 链式操作 Consumer\u0026lt;String\u0026gt; printItem = item -\u003e System.out.print(\"打印: \" + item + \"\\t\"); Consumer\u0026lt;String\u0026gt; printLength = item -\u003e System.out.println(\"长度: \" + item.length()); Consumer\u0026lt;String\u0026gt; combined = printItem.andThen(printLength); // 将两个 Consumer 组合在一起 // 使用 forEach 遍历集合并执行组合操作 items.forEach(combined); // items.forEach(item -\u003e { // System.out.print(\"打印: \" + item + \"\\t\"); // System.out.println(\"长度: \" + item.length()); // }); } } BiConsumer SHOW CODE Java import java.util.Arrays; import java.util.List; import java.util.function.BiConsumer; // 定义 Student 记录类，包含学生的姓名和活动列表 record Student(String name, List\u0026lt;String\u0026gt; activities) { } //class Student { // private final String name; // private final List\u0026lt;String\u0026gt; activities; // // public Student(String name, List\u0026lt;String\u0026gt; activities) { // this.name = name; // this.activities = activities; // } // // public String getName() { // return name; // } // // public List\u0026lt;String\u0026gt; getActivities() { // return activities; // } //} class StudentDataBase { // 提供学生数据，返回一个包含多个学生的列表 public static List\u0026lt;Student\u0026gt; getAllStudents() { return Arrays.asList( new Student(\"Alice\", Arrays.asList(\"Swimming\", \"Basketball\")), new Student(\"Bob\", Arrays.asList(\"Cycling\", \"Chess\")), new Student(\"Charlie\", Arrays.asList(\"Running\", \"Reading\")) ); } } class Test { public static void main(String[] args) { /** * BiConsumer 适用于对两个参数执行操作，但不需要返回结果的场景。 */ // BiConsumer 接口用于处理学生姓名和活动列表 BiConsumer\u0026lt;\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; studentBiConsumer = (name, activities) -\u003e System.out.println(name + \" : \" + activities); // 获取学生列表 List\u0026lt;Student\u0026gt; students = StudentDataBase.getAllStudents(); // 使用 forEach 遍历每个学生对象并输出其姓名和活动列表 students.forEach(student -\u003e studentBiConsumer.accept(student.name(), student.activities())); } } Predicate SHOW CODE Java import java.util.Arrays; import java.util.List; import java.util.function.Predicate; class Test { public static void main(String[] args) { /* Predicate 用于测试输入对象是否满足某种条件，常用于过滤、条件判断等场景 Predicate 提供了 and, or 和 negate 三个默认方法 Predicate 提供了 isEqual 和 not (Java 11) 两个静态方法 */ // 示例 1: Predicate\u0026lt;Integer\u0026gt; isEven = num -\u003e num % 2 == 0; List\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6); List\u0026lt;Integer\u0026gt; evenNumbers = numbers.stream() .filter(isEven) .toList(); System.out.println(\"偶数: \" + evenNumbers); // 输出: 偶数: [2, 4, 6] // 示例 2: Predicate\u0026lt;Integer\u0026gt; isOdd = num -\u003e num % 2 == 0; Predicate\u0026lt;Integer\u0026gt; isGreaterThanFive = num -\u003e num \u003e 5; // 使用 and() 方法组合两个条件 Predicate\u0026lt;Integer\u0026gt; isOddAndGreaterThanFive = isOdd.and(isGreaterThanFive); System.out.println(isOddAndGreaterThanFive.test(7)); // 输出: true System.out.println(isOddAndGreaterThanFive.test(3)); // 输出: false // 示例 3 List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\", \"Alice\"); // 使用 isEqual 和 not 来筛选出不等于 \"Alice\" 的名字 List\u0026lt;String\u0026gt; filteredNames = names.stream() .filter(Predicate.not(Predicate.isEqual(\"Alice\"))) .toList(); System.out.println(filteredNames); // Output: [Bob, Charlie] } } BiPredicate SHOW CODE Java import java.util.function.BiPredicate; class Test { public static void main(String[] args) { // BiPredicate 适合需要对两个参数进行测试或判断的情况 // 示例 1 BiPredicate\u0026lt;Integer, Integer\u0026gt; isSumGreaterThanTen = (a, b) -\u003e (a + b) \u003e 10; BiPredicate\u0026lt;Integer, Integer\u0026gt; isProductEven = (a, b) -\u003e (a * b) % 2 == 0; BiPredicate\u0026lt;Integer, Integer\u0026gt; combined = isSumGreaterThanTen.and(isProductEven); System.out.println(combined.test(5, 6)); // 输出: true，因为和大于10且乘积为偶数 System.out.println(combined.test(5, 5)); // 输出: false，因为乘积为奇数 } } Function SHOW CODE Java import java.util.function.Function; class Test { public static void main(String[] args) { /** * Function 接受一个参数并返回一个结果 * apply(T t)：对给定的参数执行函数操作并返回结果 * andThen()：在当前函数之后执行另一个函数 * compose()：在当前函数之前执行另一个函数 */ // 示例 1 Function\u0026lt;Integer, Integer\u0026gt; squareFunction = x -\u003e x * x; Integer result = squareFunction.apply(5); System.out.println(\"5 的平方是: \" + result); // 示例 2 Function\u0026lt;Integer, Integer\u0026gt; multiplyBy2 = x -\u003e x * 2; Function\u0026lt;Integer, Integer\u0026gt; add3 = x -\u003e x + 3; // 使用 andThen：先乘以 2，再加 3 Integer result1 = multiplyBy2.andThen(add3).apply(5); System.out.println(\"(5 * 2) + 3 的结果是: \" + result1); // 使用 compose：先加 3，再乘以 2 Integer result2 = multiplyBy2.compose(add3).apply(5); System.out.println(\"(5 + 3) * 2 的结果是: \" + result2); } } BiFunction SHOW CODE Java import java.util.function.BiFunction; class Test { public static void main(String[] args) { // BiFunction takes two arguments and returns a result BiFunction\u0026lt;Integer, Integer, Integer\u0026gt; sum = (a, b) -\u003e a + b; int result = sum.apply(5, 3); // Returns 8 System.out.println(\"Result: \" + result); } } Method Reference SHOW CODE Java import java.util.Arrays; import java.util.List; import java.util.function.Function; import java.util.function.Supplier; public class Test { public static void main(String[] args) { /** * Method reference is a shortcut for writing the lambda function */ // 示例 1 List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"); // 使用 Lambda 表达式 names.stream().map(name -\u003e name.toUpperCase()).forEach(name -\u003e System.out.println(name)); // 使用Method Reference names.stream().map(String::toUpperCase).forEach(System.out::println); /** * 构造器引用是Method Reference的特例 * 用法如下： * () -\u003e new Person() \u003c--\u003e Person::new; * (name) -\u003e new Person() \u003c--\u003e Person::new; */ // 示例 2 // Using () -\u003e new Person() Supplier\u0026lt;Person\u0026gt; personSupplier = () -\u003e new Person(); Person p1 = personSupplier.get(); System.out.println(p1); // Output: Person{name='Default'} // Using Person::new Supplier\u0026lt;Person\u0026gt; personSupplierRef = Person::new; Person p2 = personSupplierRef.get(); System.out.println(p2); // Output: Person{name='Default'} // 示例 3 // Using (name) -\u003e new Person(name) Function\u0026lt;String, Person\u0026gt; personFunction = (name) -\u003e new Person(name); Person p3 = personFunction.apply(\"Alice\"); System.out.println(p3); // Output: Person{name='Alice'} // Using Person::new Function\u0026lt;String, Person\u0026gt; personFunctionRef = Person::new; Person p4 = personFunctionRef.apply(\"Bob\"); System.out.println(p4); // Output: Person{name='Bob'} } } class Person { private String name; // Default constructor public Person() { this.name = \"Default\"; } // Constructor with a parameter public Person(String name) { this.name = name; } @Override public String toString() { return \"Person{name='\" + name + \"'}\"; } } Stream API Introduction to Stream API A Stream is a sequence of elements designed for processing in a functional and sequential manner. Stream operations are lazy, meaning they are not executed until a terminal operation (e.g., collect, forEach, reduce, count) is invoked. Streams are immutable, allowing access to elements without modifying the source. Java provides two types of streams: stream (for sequential processing) and parallel stream (for concurrent processing).\nCollections V.S. Stream\nIn Java, Collections are data structures designed for storing and manipulating data, whereas Streams are a sequence of elements which enable functional-style operations on data. Collections allow data modification, whereas Streams provide read-only access to elements. Operations on Collections are executed eagerly, while Streams operations are lazy and only executed when a terminal operation is invoked. Collections can be reused multiple times, but Streams are single-use and cannot be reused after processing. Debugging Streams: the peek() method can be used to inspect the intermediate results during stream operations.\nArrays.asList(\u0026#34;hello\u0026#34;, \u0026#34;hi\u0026#34;).stream() .peek(System.out::println) .filter(s -\u0026gt; s.length() \u0026gt; 2) .peek(s -\u0026gt; System.out.println(\u0026#34;Filtered: \u0026#34; + s)) .map(String::toUpperCase) .peek(s -\u0026gt; System.out.println(\u0026#34;Mapped: \u0026#34; + s)) .collect(Collectors.toList()); hello Filtered: hello Mapped: HELLO hi flatMap The flatMap method is used to transform each element in a stream into another stream and then flatten the resulting streams into a single stream.\nSHOW CODE Java import java.util.Arrays; import java.util.List; import java.util.stream.Collectors; public class Test { public static void main(String[] args) { List\u0026lt;List\u0026lt;String\u0026gt; nestedList = Arrays.asList( Arrays.asList(\"A\", \"B\"), Arrays.asList(\"C\", \"D\"), Arrays.asList(\"E\", \"F\") ); List\u0026lt;String\u0026gt; flattenedList = nestedList.stream() .flatMap(List::stream) // Flatten the nested lists .map(String::toLowerCase) // Convert each string to lowercase .collect(Collectors.toList()); System.out.println(flattenedList); // Output: [a, b, c, d, e, f] } } The map method transforms each element into another type, while the flatMap method transforms and flaten streams into a single stream.\ndistinct(), count(), sorted() The distinct() method eliminates duplicate elements from the stream. The count() method calculates the total number of elements in the stream. The sorted() method sorts the elements of the stream.\nSHOW CODE Java List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Alice\", \"Charlie\"); long count = names.stream() .distinct() // Optional: Count unique elements .count(); System.out.println(count); // Output: 3 List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"); List\u0026lt;String\u0026gt; sortedByLength = names.stream() .sorted(Comparator.comparingInt(String::length)) .collect(Collectors.toList()); System.out.println(sortedByLength); // Output: [Bob, Alice, Charlie] reduce() The reduce() method in Java 8 Streams is a terminal operation used to combine elements in a stream into a single result by repeatedly applying a binary operator.\nSHOW CODE Java // Summing numbers List\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5); int sum = numbers.stream().reduce(0, Integer::sum); System.out.println(sum); // Output: 15 // Finding maximum values List\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5); int max = numbers.stream().reduce(Integer.MIN_VALUE, Integer::max); System.out.println(max); // Output: 5 // Concatenating Strings List\u0026lt;String\u0026gt; words = Arrays.asList(\"Java\", \"Stream\", \"Reduce\"); String concatenated = words.stream().reduce(\"\", String::concat); System.out.println(concatenated); // Output: JavaStreamReduce // Product of numbers List\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4); int product = numbers.stream().reduce(1, (a, b) -\u003e a * b); System.out.println(product); // Output: 24 limit(), skip() The limit() method retrieves a specified number of elements from a stream. The skip() method discards the first specified number of elements in a stream.\nSHOW CODE Java List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\", \"David\", \"Eve\"); List\u0026lt;String\u0026gt; paginatedNames = names.stream() .skip(2) // Skip the first 2 elements .limit(2) // Take the next 2 elements .collect(Collectors.toList()); System.out.println(paginatedNames); // Output: [Charlie, David] allMatch(), anyMatch(), noneMatch() The allMatch() method verifies if all elements in a stream satisfy the given predicate. The anyMatch() method determines if any element in the stream matches the specified predicate. The noneMatch() method confirms if no element in the stream matches the specified predicate.\nSHOW CODE Java List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"); // Check if all names are longer than 3 characters boolean allLongNames = names.stream().allMatch(name -\u003e name.length() \u003e 3); System.out.println(allLongNames); // Output: true // Check if any name starts with 'A' boolean anyStartsWithA = names.stream().anyMatch(name -\u003e name.startsWith(\"A\")); System.out.println(anyStartsWithA); // Output: true // Check if no name is shorter than 3 characters boolean noneShortNames = names.stream().noneMatch(name -\u003e name.length() \u003c 3); System.out.println(noneShortNames); // Output: true findAny(), findFirst() The findAny() method retrieves an arbitrary element from a stream, particularly useful for parallel processing. The findFirst() method fetches the first element from a stream based on its encounter order.\nSHOW CODE Java List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"); Optional\u0026lt;String\u0026gt; anyName = names.stream().findAny(); System.out.println(anyName.orElse(\"No names found\")); // Output: Alice (or any other element) List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"); Optional\u0026lt;String\u0026gt; firstName = names.stream().findFirst(); System.out.println(firstName.orElse(\"No names found\")); // Output: Alice Factory Methods: Of(), generate(), iterate() Stream.of() is used to create a stream from a fixed set of elements.\nSHOW CODE Java import java.util.stream.Stream; public class Main { public static void main(String[] args) { Stream\u0026lt;String\u0026gt; stream = Stream.of(\"Apple\", \"Banana\", \"Cherry\"); stream.forEach(System.out::println); } } Stream.generate() method is used to create an infinite stream of elements generated by a Supplier.\nSHOW CODE Java import java.util.stream.Stream; public class Main { public static void main(String[] args) { Stream\u0026lt;String\u0026gt; infiniteStream = Stream.generate(() -\u003e \"Hello\"); infiniteStream.limit(5).forEach(System.out::println); } } Stream.iterate() is used to create an infinite stream by applying a function repeatedly to a seed value.\nSHOW CODE Java import java.util.Random; Stream\u0026lt;Integer\u0026gt; randomNumbers = Stream.generate(() -\u003e new Random().nextInt(100)); randomNumbers.limit(5).forEach(System.out::println); When working with infinite streams, such as those created by Stream.generate() or Stream.iterate(), always use operations like limit() to prevent infinite processing.\nTerminal Operations: joining(), counting(), mapping() The joining method is a terminal operation used to concatenate the elements of a stream into a single String. By default, the elements are joined without a delimiter, but a custom delimiter, prefix, and suffix can also be specified.\nSHOW CODE Java import java.util.*; import java.util.stream.Collectors; public class JoiningExample { public static void main(String[] args) { List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"); // Simple joining String result1 = names.stream().collect(Collectors.joining()); System.out.println(result1); // AliceBobCharlie // Joining with a delimiter String result2 = names.stream().collect(Collectors.joining(\", \")); System.out.println(result2); // Alice, Bob, Charlie // Joining with delimiter, prefix, and suffix String result3 = names.stream().collect(Collectors.joining(\", \", \"[\", \"]\")); System.out.println(result3); // [Alice, Bob, Charlie] } } The counting() method is a terminal operation used to count the number of elements in a stream and return the count as a long.\nSHOW CODE Java import java.util.*; import java.util.stream.Collectors; public class CountingExample { public static void main(String[] args) { List\u0026lt;Integer\u0026gt; numbers = Arrays.asList(1, 2, 3, 4, 5); // Counting the elements in the stream long count = numbers.stream().collect(Collectors.counting()); System.out.println(count); // 5 } } The mapping() method is an intermediate collector that applies a function to the elements of a stream before passing the transformed elements to another collector for final processing.\nSHOW CODE Java import java.util.*; import java.util.stream.Collectors; public class MappingExample { public static void main(String[] args) { List\u0026lt;String\u0026gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"); // Convert names to uppercase and join them String result = names.stream() .collect(Collectors.mapping(String::toUpperCase, Collectors.joining(\", \"))); System.out.println(result); // ALICE, BOB, CHARLIE } } Terminal Operations: minBy(), maxBy(), groupingBy() The minBy() collector finds the minimum element in a stream based on a specified Comparator and returns the result as an Optional.\nSHOW CODE Java Optional min = Stream.of(3, 5, 1, 2) .collect(Collectors.minBy(Comparator.naturalOrder())); System.out.println(min.orElse(-1)); // Output: 1 The maxBy() collector finds the maximum element in a stream based on a specified Comparator and returns the result as an Optional.\nSHOW CODE Java Optional max = Stream.of(3, 5, 1, 2) .collect(Collectors.maxBy(Comparator.naturalOrder())); System.out.println(max.orElse(-1)); // Output: 5 The groupingBy() collector groups the elements of a stream based on a classification function and returns the grouped data as a Map.\nSHOW CODE Java Map\u0026lt;Integer, List\u0026lt;String\u0026gt;\u0026gt; groupedByLength = Stream.of(\"cat\", \"dog\", \"bird\", \"fox\") .collect(Collectors.groupingBy(String::length)); System.out.println(groupedByLength); // Output: {3=[cat, dog, fox], 4=[bird]} Numeric Stream A Numeric Stream in Java is a specialized type of stream that operates specifically on numeric values. There are three types of numeric streams: IntStream, LongStream, and Double Stream, which handle int, long, and double values, respectively. Numeric streams eliminate the overhead of autoboxing and provide commonly used methods such as sum() and max() for performing operations on numeric data, making them more efficient compared to regular Stream types.\nSHOW CODE Java IntStream.range(1, 5).forEach(System.out::println); // Output: 1 2 3 4 IntStream.rangeClosed(1, 5).forEach(System.out::println); // Output: 1 2 3 4 5 long count = IntStream.range(1, 10).count(); System.out.println(count); // Output: 9 int sum = IntStream.range(1, 5).sum(); System.out.println(sum); // Output: 10 (1 + 2 + 3 + 4) OptionalInt max = IntStream.range(1, 5).max(); max.ifPresent(System.out::println); // Output: 4 OptionalInt min = IntStream.range(1, 5).min(); min.ifPresent(System.out::println); // Output: 1 OptionalDouble average = IntStream.range(1, 5).average(); average.ifPresent(System.out::println); // Output: 2.5 List\u0026lt;String\u0026gt; numbers = Arrays.asList(\"1\", \"2\", \"3\", \"4\"); IntStream intStream = numbers.stream().mapToInt(Integer::parseInt); intStream.forEach(System.out::println); // Output: 1, 2, 3, 4 List\u0026lt;String\u0026gt; numbers = Arrays.asList(\"1.1\", \"2.2\", \"3.3\", \"4.4\"); DoubleStream doubleStream = numbers.stream().mapToDouble(Double::parseDouble); doubleStream.forEach(System.out::println); // Output: 1.1, 2.2, 3.3, 4.4 List\u0026lt;String\u0026gt; numbers = Arrays.asList(\"10\", \"20\", \"30\", \"40\"); LongStream longStream = numbers.stream().mapToLong(Long::parseLong); longStream.forEach(System.out::println); // Output: 10, 20, 30, 40 IntStream intStream = IntStream.range(1, 5); Stream\u0026lt;String\u0026gt; stringStream = intStream.mapToObj(Integer::toString); stringStream.forEach(System.out::println); // Output: \"1\", \"2\", \"3\", \"4\" ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/programming/java/1-java-programming/","summary":"Enum In Java, an enum (short for \u0026ldquo;enumeration\u0026rdquo;) is used to define a collection of constants, such as days of the week or months of the year. An enum provides a type-safe way to handle constant values, and it can be used in a switch statement or for comparison using ==. Compared to a final constant in Java, an enum can contain fields, methods, and constructors. The values() method is used to retrive all the constants in an enum, and the valueOf() method is used to convert a string into an enum constant.","title":"Java Programming"}]