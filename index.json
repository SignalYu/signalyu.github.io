[{"content":"2024 Be cautious in both speech and action.\nFirst things first.\nAvoid living a life of suffering.\nOpportunity favors the prepared mind.\nFocus on your own matters, respect others\u0026rsquo; choices, and live in harmony with destiny.\nLife is the process of cultivating your soul.\nThink first, act later.\nSpeak less of what\u0026rsquo;s unnecessary, do less of what\u0026rsquo;s pointless, and waste less energy on what\u0026rsquo;s unimportant.\nIn times of peace, prepare for challenges.\nHope for the best, but always plan for the unexpected.\n","permalink":"https://signalyu.github.io/posts/3-humanities/personal-growth/1-mottos/","summary":"2024 Be cautious in both speech and action.\nFirst things first.\nAvoid living a life of suffering.\nOpportunity favors the prepared mind.\nFocus on your own matters, respect others\u0026rsquo; choices, and live in harmony with destiny.\nLife is the process of cultivating your soul.\nThink first, act later.\nSpeak less of what\u0026rsquo;s unnecessary, do less of what\u0026rsquo;s pointless, and waste less energy on what\u0026rsquo;s unimportant.\nIn times of peace, prepare for challenges.","title":"Mottos"},{"content":"Core Concepts Loose Coupling Loose Coupling is a design principle that aims to reduce the dependencies between components within a system.\nInversion of Control (IoC) Inversion of Control is a design principle where the control of object creation and lifecycle management is transferred from the application code to an external container or framework.\nDependency Injection (DI) Dependency Injection is a design pattern commonly used in object-oriented programming, where the dependecies of a class are provided externally rather than being created within the class itself.\nBeans Beans are objects that are managed by the Spring framework.\nContainer A Spring Container is responsible for managing the life cycle, configuration, and dependencies injection of the beans in a Spring Application.\nLife Cycle of Beans Beans are objects that are managed by the Spring framework. Bean Definition includes configuration meta data required by the Spring container to create and manage the bean. Bean Configurations can be provided in various way, including XML configuration files, annotations, and Java-based configuration. Bean Instantiation $\\rightarrow$ Population of Properties $\\rightarrow$ Initialization $\\rightarrow$ Ready for Use $\\rightarrow$ Destruction The Difference between instantiation and initiation?\nInstantiation occurs when a new keyword is used to create an object. It focus on constructing the object\u0026rsquo;s structure and allocating memory. In contrast, initialization focus on assigning values to the object\u0026rsquo;s fields and setting up its initial state after instantiation.\nConstructor Injection \u0026amp; Setter Injection \u0026amp; Field Injection Constructor Injection Constructor Injection in Spring is a type of dependency injection where the Spring framework provides the required dependency to a class by invoking its constructor. Since dependencies are supplied via the constructor, they cannot be changed after object creation \u0026ndash; promoting immutability. However, this approach may cause circular dependency issues if two or more beans depend on each other in a circular manner.\nSHOW CODE Java @Component public class ServiceA { private final RepositoryA repositoryA; // Constructor injection @Autowired public ServiceA(RepositoryA repositoryA) { this.repositoryA = repositoryA; } } Setter Injection Setter Injection in Spring is a form of dependency injection where the Spring framework injects dependencies into a bean by calling the bean\u0026rsquo;s setter method. This approach is flexible and commonly used to inject optional dependencies or when the dependency might change after the object is initialized.\nSHOW CODE Java @Component public class ServiceB { private RepositoryB repositoryB; // Setter injection @Autowired public void setRepositoryB(RepositoryB repositoryB) { this.repositoryB = repositoryB; } } Field Injection Field Injection in Spring is a form of dependency injection where the Spring framework directly injects dependencies into a class\u0026rsquo;s fields. Like constructor injection, the dependencies remain immutable after being injected. Under the hood. Spring uses reflection to assign values to private fields.\nSHOW CODE Java @Component public class ServiceC { @Autowired private RepositoryC repositoryC; public void performAction() { repositoryC.doSomething(); } } @Component \u0026amp; @ComponentScan The @Component annotation in Spring is used to mark a class as spring-managed bean, allowing Spring to detect and register it as a bean in the application context. The @ComponentScan annotation is used to specify base packages that Spring should scan for @Component-annotated during configuration.\nSHOW CODE Java package com.example.myapp @Component public class MyService { public void performTask() { System.out.println(\"Task performed!\"); } } @Configuration @ComponentScan(basePackages = \"com.example.myapp\") public class AppConfig { } @Value \u0026amp; @Autowired \u0026amp; @Qualifier @Value The @Value annotation is used to inject values into fields, mathod parameters, and constructor arguments.\nSHOW CODE Java // Injects literal values @Value(\"Hello, World!\") private String message; // Injects from a properties file app.name=MySpringApp @Value(\"${app.name}\") private String appName; // Injects default values @Value(\"${app.version:1.0.0}\") private String appVersion; // Injects expression @Value(\"#{T(java.lang.Math).random() * 100}\") private double randomValue; @Autowired The @Autowired annotation is used for automatic dependency injection. It allows Spring resolve and inject the required bean into a class automatically by type.\nSHOW CODE Java // Field Injection @Component public class ServiceA { @Autowired private RepositoryA repositoryA; public void performTask() { repositoryA.doSomething(); } } // Setter Injection @Component public class ServiceB { private RepositoryB repositoryB; @Autowired public void setRepositoryB(RepositoryB repositoryB) { this.repositoryB = repositoryB; } } // Constructor Injection @Component public class ServiceB { private RepositoryB repositoryB; @Autowired public void setRepositoryB(RepositoryB repositoryB) { this.repositoryB = repositoryB; } } @Qualifier The @Qualifier annotation in Spring is used for resolve ambiguities when multiple beans of the same type are available in the application context.\nSHOW CODE Java @Component(\"repositoryImpl1\") public class RepositoryImpl1 implements Repository {} @Component(\"repositoryImpl2\") public class RepositoryImpl2 implements Repository {} @Component public class Service { @Autowired @Qualifier(\"repositoryImpl2\") private Repository repository; } Components of Spring Boot Spring Boot Starter: Simplifies dependency management by building commonly used dependencies, reducing the need for manual configuration.\nAuto Configuration: Automatically configures Spring Boot application beans and settings based on the libraries on the classpath, eliminating the need for extensive configuration in application.properties or XML files.\nSpring Boot Atuator: Provides production-ready features like monitoring, metrics, and health checks to ensure better application insights and management.\nEmbedded Server: Includes servers like Tomcat and Jetty, allowing applications to run as standalone programs, simplifying development and deployment.\nSpring Boot DevTools: A collection of tools that enhance the development experience by enabling features like hot reload and live reload for faster feedback.\nSpring Boot Auto Configuration Common Annotations Transformation between Object and Spring In Spring Boot, the transformation between objects and JSON is handled by the Jackson library which allows for easy serialization (converting an object to JSON) and deserialization (converting JSON to an object).\nSHOW CODE Java // When a controller returns an object, Spring Boot automatically // converts it to JSON @RestController public class UserController { @GetMapping(\"/user\") public User getUser() { return new User(1, \"John Doe\", \"john.doe@example.com\"); } } // When accessed via /user, the response is: { \"id\": 1, \"name\": \"John Doe\", \"email\": \"john.doe@example.com\" } // Spring Boot automatically converts the incoming JSON data into // an object when the object is a parameter in the controller method. @RestController public class UserController { @PostMapping(\"/user\") public String createUser(@RequestBody User user) { return \"User \" + user.getName() + \" created!\"; } } // Input JOSN: { \"id\": 2, \"name\": \"Jane Doe\", \"email\": \"jane.doe@example.com\" } ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/framework/backend/spring/1-spring-notes/","summary":"Core Concepts Loose Coupling Loose Coupling is a design principle that aims to reduce the dependencies between components within a system.\nInversion of Control (IoC) Inversion of Control is a design principle where the control of object creation and lifecycle management is transferred from the application code to an external container or framework.\nDependency Injection (DI) Dependency Injection is a design pattern commonly used in object-oriented programming, where the dependecies of a class are provided externally rather than being created within the class itself.","title":"Spring Notes"},{"content":"数组 数组基本概念 在 C 语言中，越界访问数组编译器并不会报错； 一维数组的长度计算：int length = sizeof(arr) / sizeof(arr[0]); sizeof 返回值的数据类型是 size_t ，所以 sizeof(a) / sizeof(a[0]) 的数据类型也是 size_t。在 printf() 里面的占位符，要用 %zd 或 %zu 。 一维数组的内存分析： 一维数组的内存分析 C 语言规定，数组变量一旦声明，数组名指向的地址就不可更改。因此，使用大括号赋值时，必须在数组声明时赋值，否则编译时会报错。 int nums[5]; nums = {1, 2, 3, 4, 5}; // 报错 int nums[5] = {1, 2, 3, 4, 5}; // 正确写法 数组的复制 使用循环复制数组： void copyArray(int src[], int dest[], int size) { for (int i = 0; i \u003c size; i++) { dest[i] = src[i]; } } 使用 memcopy() 函数复制数组： #include \u0026lt;string.h\u0026gt; int main() { // ... memcpy(dest, src, sizeof(src)); return 0; } 使用指针对数组进行赋值和遍历 使用指针变量对数组进行赋值和遍历的效率比下标法高。\n#include \u0026lt;stdio.h\u0026gt; #define N 5 int main() { int a[N]; int *p = a; printf(\"请输入%d个整数：\\n\", N); for (int i = 0; i \u003c N; i++) { scanf(\"%d\", p + i); } for (int i = 0; i \u003c N; i++) { printf(\"%d \", *(p + i)); } printf(\"\\n\"); return 0; } 点击查看题目 下列 C 语言代码是否正确？ #include \u0026lt;stdio.h\u0026gt; #define N 5 int main() { int a[N]; int *p = a; printf(\"请输入%d个整数：\\n\", N); for (int i = 0; i \u003c N; i++) { scanf(\"%d\", \u0026a[i]); } for (p = a; a \u003c (p + N); a++) { printf(\"%d\", *a); } printf(\"\\n\"); return 0; } 点击查看答案 下列代码不正确： for (p = a; a \u003c (p + N); a++) { printf(\"%d\", *a); } 数组名 a 代表数组的首地址（或数组首元素的地址），它是一个指针型常量 ，它的值在程序运行期间是固定不变的。所以 a++ 是无法实现的。必须将 a 的地址赋值给指针变量 p ，然后对 p 进行自增。正确写法为： for (p = a; p \u003c (a + N); p++) { printf(\"%d \", *p); } 指针 指针的基本概念 变量：命名的内存空间，用于存放各种类型的数据； 变量名：为标记某块内存空间而采用的便于记忆的名字； 变量值：在变量单元中存放的数据值； 指针：指针是指变量所使用的内存空间的地址； 变量名 内存地址 内容 i 0x00000001 1 0x00000002 0x00000003 0x00000004 j 0x00000005 2 0x00000006 0x00000007 0x00000008 指针变量：指针变量是一个专门用来存放另一变量在内存中数据的地址的变量。通过访问指针变量，可以访问内存中另一个变量数据。 指针变量 指针的本质及其运算 指针本质上是一个代表内存地址的无符号整数。因此它可以进行整数加减，自增自减、同类指针相减等操作，但运算规则并不是整数运算规则。 指针与整数值的加减运算：表示指针所指向内存地址的移动。指针移动的单位，与指针指向的数据类型有关。数据类型占据多少个字节，每单位就移动多少个字节。 注意：只有指向连续的同类型数据区域，指针加、减整数才有实际意义。 指针的自增与自减：指针的增加或减少是指内存地址的向前或向后移动。 int arr[] = {1, 2, 3}; int *p = \u0026amp;arr; printf(\"arr[0] = %d\\n\", *p); // arr[0] = 1 printf(\"arr[1] = %d\\n\", *(++p)); // arr[1] = 2 同类指针相减运算：相同类型的指针允许进行减法运算，返回它们之间的距离，即相隔多少个数据单位（非字节数）。返回的值属于头文件 stddef.h 里面的 ptrdiff_t 类型，这是一个带符号的整数类型别名，具体类型根据系统不同而不同。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stddef.h\u0026gt; int main() { short *ps1; short *ps2; ps1 = (short *) 0x1234; ps2 = (short *) 0x1236; ptrdiff_t dist = ps2 - ps1; printf(\"%d\\n\", dist); // 1（相差2个字节正好存放1个short类型的值） int *pi1; int *pi2; pi1 = (int *) 0x1234; pi2 = (int *) 0x1244; ptrdiff_t dist1 = pi2 - pi1; printf(\"%d\\n\",dist1); // 4（相差16个字节正好存放4个int类型的值） return 0; } 指针间的比较运算：比较各自的内存地址的大小，返回值是整数 1（true）或 0（false）。 取址运算符（\u0026amp;）：取之运算符用于取出指定变量在内存中的地址。 int num = 10; int *p; // p 为整型指针变量，建议写成 int *p = NULL; p = \u0026amp;num; // 必须为整型指针 printf(\"\u0026num = %p\", \u0026num); // 格式输出符为 %p 取值运算符（*）：取值运算符用于获取给定内存地址的数据值，它与取址运算符（\u0026amp;）互为逆运算。 int num = 10; int *p; // p 为整型指针变量，建议写成 int *p = NULL; p = \u0026amp;num; // 必须为整型指针 printf(\"\u0026num = %p\\n\", \u0026num); // 格式输出符为 %p printf(\"num = %d\", *p); // 取出指针 p 的值 野指针 野指针：野指针指的是指向未知知内存的一类指针； 野指针的成因主要有如下三种： 指针使用前未初始化：指针变量在定义时如果未初始化，其值是随机的，此时操作指针就是去访问一个不确定的地址，所以结果是不可知的。此时 p 为野指针。 int *p; // 建议写成 int *p = NULL; printf(\"%d\\n\", *p); // 输出的值每次都不一样 指针越界访问： int arr[10] = {0}; int *p = arr; for (int i = 0; i \u003c= 10; i++, p++) { *p = i; // i = 10 时越界 } 指针指向已释放的空间： test.c 输出结果 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int *test() { int a = 10; return \u0026amp;a; } int main() { int *p = test(); printf(\"*p = %d\", *p); printf(\"\\n暂停两秒...\\n\"); sleep(2); // 暂停两秒 printf(\"*p = %d\\n\", *p); return 0; } $ gcc -Wall -o test test.c test.c:6:13: warning: address of stack memory associated with local variable 'a' returned [-Wreturn-stack-address] return \u0026amp;a; ^ 1 warning generated. $ ./test *p = 10 暂停两秒... *p = 1 调用 test 函数将返回值赋给 p，test 函数的返回值是局部变量 a 的地址。由于 a 只在 test 函数内有效，出了 test 函数其内存空间就被释放，也就意味着 a 的地址编号不存在，若将其赋值给 p，导致 p 获取到的地址是无效的。如果短时间内再次利用这块地址，它的值还未被改变，此时 p 的值为 a 的地址值，*p 返回 10。如果在打印之前有其他函数调用了这块地址，这块地址的名称就会发生变化，*p 不再返回 10。 野指针的避免： 定义指针时，如果没有确切的地址赋值，应该为指针变量赋一个NULL值。即： int *p = NULL; 赋为NULL值的指针被称为空指针，NULL指针是一个定义在标准库中的值为零的常量#define NULL 0。 访问数组元素时，避免越界(0 ≤ i \u0026lt; arr.length)访问。 避免将函数返回的局部变量的地址值赋值给指针。 指针指向的空间被释放时，应该及时将指针置为NULL。 int *ptr = (int *) malloc(sizeof(int)); free(ptr); // 释放内存 ptr = NULL; // 将指针设置为 NULL 指针使用之前应进行有效性检查： if (ptr != NULL) { // ... } 二级指针 二级指针是指一个指针变量的值是另一个指针变量的地址。 int a = 20; int *pa = \u0026a; // pa是一级指针 int **ppa = \u0026pa; // ppa是二级指针，类型为int ** 二级指针 数组指针与指针数组 数组指针是指存放数组首地址的指针变量；指针数组是指存放指针的数组。 ###添加案例 数组指针与指针数组 字符数组和字符指针变量 字符数组由若干个元素组成，每个元素存放一个字符。 char str[] = \"signal\"; // 使用字符数组 字符数组 字符指针变量中存放的是地址（字符串或字符数组的首地址）。 char *pStr = \"signal\"; // 使用字符指针 字符指针 对已声明好的字符数组，只能一一对各个元素赋值，而不能对整个字符数组赋值： char str[14]; str[0] = 'i'; // 正确 str = \"signal\"; // 错误，不能对整个字符数组赋值 对已声明好的字符指针变量，可以采用如下方式赋值： char *pStr = \"\"; pStr = \"signal\"; // 正确 字符指针重新赋值 一个字符数组，因为它有确定的内存地址，所以字符数组名是一个常量 。而定义一个字符指针变量时，它在指向某个确定的字符串数据的情况下，可以多次重新赋值 。 字符串字面量存储在只读内存区域，是不可变的，不能修改其值。 char arr[] = \"hello\"; arr[1] = \"m\"; // 运行时错误 char *pStr = \"hello\"; pStr = \"hello tom\"; // 正确 pStr[1] = 'm'; // 运行时错误 ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/programming/c/1-array-and-pointer-in-c/","summary":"数组 数组基本概念 在 C 语言中，越界访问数组编译器并不会报错； 一维数组的长度计算：int length = sizeof(arr) / sizeof(arr[0]); sizeof 返回值的数据类型是 size_t ，所以 sizeof(a) / sizeof(a[0]) 的数据类型也是 size_t。在 printf() 里面的占位符，要用 %zd 或 %zu 。 一维数组的内存分析： 一维数组的内存分析 C 语言规定，数组变量一旦声明，数组名指向的地址就不可更改。因此，使用大括号赋值时，必须在数组声明时赋值，否则编译时会报错。 int nums[5]; nums = {1, 2, 3, 4, 5}; // 报错 int nums[5] = {1, 2, 3, 4, 5}; // 正确写法 数组的复制 使用循环复制数组： void copyArray(int src[], int dest[], int size) { for (int i = 0; i \u003c size; i++) { dest[i] = src[i]; } } 使用 memcopy() 函数复制数组： #include \u0026lt;string.","title":"C 语言中的数组与指针"},{"content":"静态代理 静态代理模式类图 在静态代理模式下，可以在不修改目标对象代码的前提下对其进行功能扩展； 在静态代理模式下，代理对象和目标对象都需要实现父接口或者继承父类； 由于代理对象和目标对象需要实现相同的接口或者继承相同的父类，因此容易导致很多代理类的存在； 当父接口或父类增加方法时，目标对象和代理对象都需要维护。 代码示例 代码示例类图 点击查看代码 BankAccount ConcreteBankAccount StaticBankAccountProxy StaticProxyTest 输出结果 package org.signalyu.patterns.proxy; public interface BankAccount { boolean deposit(double amount); boolean withdraw(double amount); double getBalance(); } package org.signalyu.patterns.proxy; public class ConcreteBankAccount implements BankAccount { private double balance; public ConcreteBankAccount(double balance) { this.balance = balance; } @Override public boolean deposit(double amount) { if (amount \u003e 0) { this.balance += amount; return true; } return false; } @Override public boolean withdraw(double amount) { if (balance \u003e= amount) { balance -= amount; return true; } else { return false; } } @Override public double getBalance() { return balance; } } package org.signalyu.patterns.proxy; import java.time.LocalDateTime; public class StaticBankAccountProxy implements BankAccount { private final ConcreteBankAccount target; public StaticBankAccountProxy(double initialBalance) { this.target = new ConcreteBankAccount(initialBalance); } @Override public boolean withdraw(double amount) { System.out.println(LocalDateTime.now() + \": 取款中...\"); boolean withdraw = target.withdraw(amount); if (withdraw) { System.out.println(LocalDateTime.now() + \": 取款成功！\"); return true; } else { System.out.println(LocalDateTime.now() + \": 取款失败！\"); return false; } } @Override public boolean deposit(double amount) { boolean deposited = target.deposit(amount); System.out.println(LocalDateTime.now() + \": 存款中...\"); if (deposited) { System.out.println(LocalDateTime.now() + \": 存款完毕！\"); return true; } } @Override public double getBalance() { System.out.println(LocalDateTime.now() + \": 正在查询...\"); double balance = target.getBalance(); System.out.println(\"您的账户余额为：\" + target.getBalance()); return balance; } } import org.junit.jupiter.api.Test; import org.signalyu.patterns.proxy.BankAccount; import org.signalyu.patterns.proxy.StaticBankAccountProxy; public class StaticProxyTest { @Test public void testBankAccountProxy() { BankAccount proxy = new StaticBankAccountProxy(0); proxy.deposit(999); System.out.println(\"==================\"); proxy.withdraw(666); System.out.println(\"==================\"); proxy.getBalance(); System.out.println(\"==================\"); proxy.withdraw(400); } } 2024-05-22T13:11:10.480679: 存款中... 2024-05-22T13:11:10.481097: 存款完毕！ ================== 2024-05-22T13:11:10.481258: 取款中... 2024-05-22T13:11:10.481394: 取款成功！ ================== 2024-05-22T13:11:10.481567: 正在查询... 您的账户余额为：333.0 ================== 2024-05-22T13:11:10.486958: 取款中... 2024-05-22T13:11:10.487005: 取款失败！ 动态代理（JDK） 动态代理模式类图 在动态代理模式中，代理对象不需要实现父接口（或继承父接口），但目标对象需要实现接口； 在动态代理模式下，通过 JDK 的 API 动态地在内存中创建代理对象。 代码示例 示例代码类图 点击查看代码 BankAccount ConcreteBankAccount JDkBankAccountProxy Client 输出结果 package org.signalyu.patterns.proxy; public interface BankAccount { boolean deposit(double amount); boolean withdraw(double amount); double getBalance(); } package org.signalyu.patterns.proxy; public class ConcreteBankAccount implements BankAccount { private double balance; public ConcreteBankAccount(double balance) { this.balance = balance; } @Override public boolean deposit(double amount) { if (amount \u003e 0) { this.balance += amount; return true; } return false; } @Override public boolean withdraw(double amount) { if (balance \u003e= amount) { balance -= amount; return true; } else { return false; } } @Override public double getBalance() { return balance; } } package org.signalyu.patterns.proxy; import java.lang.reflect.Proxy; import java.time.LocalDateTime; public class JDKBankAccountProxy { private final Object target; public JDKBankAccountProxy(Object target) { this.target = target; } public Object getProxyInstance() { return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), (proxy, method, args) -\u003e { String methodName = method.getName(); if (\"deposit\".equals(methodName)) { System.out.println(LocalDateTime.now() + \": 存款中...\"); boolean invoked = (boolean) method.invoke(target, args); if (invoked) { System.out.println(LocalDateTime.now() + \": 存款完毕！\"); } return invoked; } else if (\"withdraw\".equals(methodName)) { boolean invoked = (boolean)method.invoke(target, args); if (invoked){ System.out.println(LocalDateTime.now() + \": 取款中...\"); System.out.println(LocalDateTime.now() + \": 取款成功！\"); } else { System.out.println(LocalDateTime.now() + \": 取款失败！\"); } return invoked; } else { System.out.println(LocalDateTime.now() + \": 正在查询余额...\"); Object invoked = method.invoke(target, args); System.out.println(\"您的余额为：\"+ method.invoke(target, args)); return invoked; } }); } } package org.signalyu.patterns.proxy; public class Client { public static void main(String[] args) { ConcreteBankAccount target = new ConcreteBankAccount(0); BankAccount proxyInstance = (BankAccount) new JDKBankAccountProxy(target).getProxyInstance(); proxyInstance.deposit(999); System.out.println(\"==================\"); proxyInstance.withdraw(666); System.out.println(\"==================\"); proxyInstance.getBalance(); System.out.println(\"==================\"); proxyInstance.withdraw(400); } } 2024-05-22T13:02:27.648927: 存款中... 2024-05-22T13:02:27.649245: 存款完毕！ ================== 2024-05-22T13:02:27.649376: 取款中... 2024-05-22T13:02:27.649448: 取款成功！ ================== 2024-05-22T13:02:27.649523: 正在查询余额... 您的余额为：333.0 ================== 2024-05-22T13:02:27.650227: 取款失败！ ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/programming/design-patterns/2-proxy-pattern/","summary":"静态代理 静态代理模式类图 在静态代理模式下，可以在不修改目标对象代码的前提下对其进行功能扩展； 在静态代理模式下，代理对象和目标对象都需要实现父接口或者继承父类； 由于代理对象和目标对象需要实现相同的接口或者继承相同的父类，因此容易导致很多代理类的存在； 当父接口或父类增加方法时，目标对象和代理对象都需要维护。 代码示例 代码示例类图 点击查看代码 BankAccount ConcreteBankAccount StaticBankAccountProxy StaticProxyTest 输出结果 package org.signalyu.patterns.proxy; public interface BankAccount { boolean deposit(double amount); boolean withdraw(double amount); double getBalance(); } package org.signalyu.patterns.proxy; public class ConcreteBankAccount implements BankAccount { private double balance; public ConcreteBankAccount(double balance) { this.balance = balance; } @Override public boolean deposit(double amount) { if (amount \u003e 0) { this.balance += amount; return true; } return false; } @Override public boolean withdraw(double amount) { if (balance \u003e= amount) { balance -= amount; return true; } else { return false; } } @Override public double getBalance() { return balance; } } package org.","title":"设计模式——代理模式"},{"content":"简单工厂（Simple Factory） 简单工厂模式通过一个专门的工厂类基于特定的参数来创建产品类的实例； 简单工厂模式违反了开闭原则，即在需要添加新的产品类型时需要修改工厂类。 代码示例 简单工厂示例类图 点击查看代码 Pizza MargheritaPizza PepperoniPizza BeefPizza PizzaFactory SimpleFactoryTest 输出结果 package org.signalyu.patterns.factory; public interface Pizza { void prepare(); void bake(); void cut(); void box(); } package org.signalyu.patterns.factory; public class MargheritaPizza implements Pizza { @Override public void prepare() { System.out.println(\"玛格丽特比萨：1. 准备材料\"); } @Override public void bake() { System.out.println(\"玛格丽特比萨：2. 烘烤比萨 \"); } @Override public void cut() { System.out.println(\"玛格丽特比萨：3. 切比萨\"); } @Override public void box() { System.out.println(\"玛格丽特比萨：4. 披萨打包\"); } } package org.signalyu.patterns.factory; public class PepperoniPizza implements Pizza { @Override public void prepare() { System.out.println(\"意大利辣式披萨：1. 准备原料\"); } @Override public void bake() { System.out.println(\"意大利辣式披萨：2. 烘烤披萨\"); } @Override public void cut() { System.out.println(\"意大利辣式披萨：3. 切披萨\"); } @Override public void box() { System.out.println(\"意大利辣式披萨：4. 披萨打包\"); } } package org.signalyu.patterns.factory; public class BeefPizza implements Pizza { @Override public void prepare() { System.out.println(\"牛肉披萨：1. 准备原料\"); } @Override public void bake() { System.out.println(\"牛肉披萨：2. 烘烤披萨\"); } @Override public void cut() { System.out.println(\"牛肉披萨：3. 切披萨\"); } @Override public void box() { System.out.println(\"牛肉披萨：4. 披萨打包\"); } } package org.signalyu.patterns.factory; public class PizzaFactory { public Pizza createPizza(String type) { // 当需要生产新品种披萨时，需要修改下面的代码，违背开闭原则 return switch (type) { case \"Margherita\" -\u003e new MargheritaPizza(); case \"Pepperoni\" -\u003e new PepperoniPizza(); case \"Beef\" -\u003e new BeefPizza(); default -\u003e throw new IllegalArgumentException(\"请选择正确的披萨类型: \" + type); }; } } import org.junit.jupiter.api.Test; import org.signalyu.patterns.factory.Pizza; import org.signalyu.patterns.factory.PizzaFactory; public class SimpleFactoryTest { @Test public void testPizzaFactory() { PizzaFactory pizzaFactory = new PizzaFactory(); Pizza margheritaPizza = pizzaFactory.createPizza(\"Margherita\"); margheritaPizza.prepare(); margheritaPizza.bake(); margheritaPizza.cut(); margheritaPizza.box(); System.out.println(\"----------------------\"); Pizza pepperoniPizza = pizzaFactory.createPizza(\"Pepperoni\"); pepperoniPizza.prepare(); pepperoniPizza.bake(); pepperoniPizza.cut(); pepperoniPizza.box(); System.out.println(\"----------------------\"); Pizza veggiePizza = pizzaFactory.createPizza(\"Beef\"); veggiePizza.prepare(); veggiePizza.bake(); veggiePizza.cut(); veggiePizza.box(); } } 玛格丽特比萨：1. 准备材料 玛格丽特比萨：2. 烘烤比萨 玛格丽特比萨：3. 切比萨 玛格丽特比萨：4. 披萨打包 ---------------------- 意大利辣式披萨：1. 准备原料 意大利辣式披萨：2. 烘烤披萨 意大利辣式披萨：3. 切披萨 意大利辣式披萨：4. 披萨打包 ---------------------- 牛肉披萨：1. 准备原料 牛肉披萨：2. 烘烤披萨 牛肉披萨：3. 切披萨 牛肉披萨：4. 披萨打包 工厂方法（Factory Method） 工厂方法模式提供一个抽象工厂接口，具体工厂类实现该接，并为创建对象提供具体实现； 工厂方法模式使用单个工厂方法创建单个产品类型； 工厂方法模式遵循开闭原则。 代码示例 工厂方法示例类图 点击查看代码 Car BruBus Porsche Lamborghini CarFactory BruBusFactory PorscheFactory LamborghiniFactory FactoryMethodTest 输出结果 package org.signalyu.patterns.factory; public interface Car { void assemble(); void paint(); void polish(); void testDrive(); } package org.signalyu.patterns.factory; public class BruBus implements Car { @Override public void assemble() { System.out.println(\"博速：1. 组装\"); } @Override public void paint() { System.out.println(\"博速：2. 刷漆\"); } @Override public void polish() { System.out.println(\"博速：3. 抛光\"); } @Override public void testDrive() { System.out.println(\"博速：4. 驾驶测试\"); } } package org.signalyu.patterns.factory; public class Porsche implements Car { @Override public void assemble() { System.out.println(\"保时捷：1. 组装\"); } @Override public void paint() { System.out.println(\"保时捷：2. 刷漆\"); } @Override public void polish() { System.out.println(\"保时捷：3. 抛光\"); } @Override public void testDrive() { System.out.println(\"保时捷：4. 驾驶测试\"); } } package org.signalyu.patterns.factory; public class Lamborghini implements Car { @Override public void assemble() { System.out.println(\"兰博基尼：1. 组装\"); } @Override public void paint() { System.out.println(\"兰博基尼：2. 刷漆\"); } @Override public void polish() { System.out.println(\"兰博基尼：3. 抛光\"); } @Override public void testDrive() { System.out.println(\"兰博基尼：4. 驾驶测试\"); } } package org.signalyu.patterns.factory; public interface CarFactory { Car createCar(); } package org.signalyu.patterns.factory; public class BruBusFactory implements CarFactory{ @Override public Car createCar() { return new BruBus(); } } package org.signalyu.patterns.factory; public class PorscheFactory implements CarFactory{ @Override public Car createCar() { return new Porsche(); } } package org.signalyu.patterns.factory; public class LamborghiniFactory implements CarFactory{ @Override public Car createCar() { return new Lamborghini(); } } import org.junit.jupiter.api.Test; import org.signalyu.patterns.factory.*; public class FactoryMethodTest { @Test public void testCarFactory() { CarFactory bruBusFactory = new BruBusFactory(); Car bruBus = bruBusFactory.createCar(); bruBus.assemble(); bruBus.paint(); bruBus.polish(); bruBus.testDrive(); System.out.println(\"-------------------\"); CarFactory porscheFactory = new PorscheFactory(); Car porsche = porscheFactory.createCar(); porsche.assemble(); porsche.paint(); porsche.polish(); porsche.testDrive(); System.out.println(\"-------------------\"); CarFactory lamborghiniFactory = new LamborghiniFactory(); Car lamborghini = lamborghiniFactory.createCar(); lamborghini.assemble(); lamborghini.paint(); lamborghini.polish(); lamborghini.testDrive(); } } 博速：1. 组装 博速：2. 刷漆 博速：3. 抛光 博速：4. 驾驶测试 ------------------- 保时捷：1. 组装 保时捷：2. 刷漆 保时捷：3. 抛光 保时捷：4. 驾驶测试 ------------------- 兰博基尼：1. 组装 兰博基尼：2. 刷漆 兰博基尼：3. 抛光 兰博基尼：4. 驾驶测试 抽象工厂（Abstract Factory） 抽象工厂模式提供一个接口，并提供多个工厂方法用于创建相关产品系列； 具体工厂类实现抽象工厂接口，并为创建对象提供具体实现； 抽象工厂模式遵循开闭原则。 代码示例 抽象工厂示例类图 点击查看代码 AbstractChair AbstractSofa ModernChair ModernSofa VictorianChair VictorianSofa FurnitureFactory ModernFurnitureFactory VictorianFurnitureFactory AbstractFactoryTest 输出结果 package org.signalyu.patterns.factory; public abstract class AbstractChair { public abstract void sitOn(); } package org.signalyu.patterns.factory; public abstract class AbstractSofa { public abstract void lieOn(); } package org.signalyu.patterns.factory; public class ModernChair extends AbstractChair { @Override public void sitOn() { System.out.println(\"坐在现代风格椅子...\"); } } package org.signalyu.patterns.factory; public class ModernSofa extends AbstractSofa{ @Override public void lieOn() { System.out.println(\"躺在现代风格沙发...\"); } } package org.signalyu.patterns.factory; public class VictorianChair extends AbstractChair { @Override public void sitOn() { System.out.println(\"坐在维多利亚风格椅子...\"); } } package org.signalyu.patterns.factory; public class VictorianSofa extends AbstractSofa { @Override public void lieOn() { System.out.println(\"躺在维多利亚风格沙发上...\"); } } package org.signalyu.patterns.factory; public interface FurnitureFactory { AbstractChair createChair(); AbstractSofa createSofa(); } package org.signalyu.patterns.factory; public class ModernFurnitureFactory implements FurnitureFactory { @Override public AbstractChair createChair() { return new ModernChair(); } @Override public AbstractSofa createSofa() { return new ModernSofa(); } } package org.signalyu.patterns.factory; public class VictorianFurnitureFactory implements FurnitureFactory { @Override public AbstractChair createChair() { return new VictorianChair(); } @Override public AbstractSofa createSofa() { return new VictorianSofa(); } } import org.junit.jupiter.api.Test; import org.signalyu.patterns.factory.*; public class AbstractFactoryTest { @Test public void testFurnitureFactory() { FurnitureFactory modernFactory = new ModernFurnitureFactory(); AbstractChair modernChair = modernFactory.createChair(); AbstractSofa modernSofa = modernFactory.createSofa(); modernChair.sitOn(); modernSofa.lieOn(); FurnitureFactory victorianFactory = new VictorianFurnitureFactory(); AbstractChair victorianChair = victorianFactory.createChair(); AbstractSofa victorianSofa = victorianFactory.createSofa(); System.out.println(\"----------------------\"); victorianChair.sitOn(); victorianSofa.lieOn(); } } 坐在现代风格椅子... 躺在现代风格沙发... ---------------------- 坐在维多利亚风格椅子... 躺在维多利亚风格沙发上... 总结 简单工厂模式、工厂方法模式和抽象工厂模式的主要区别在于创建对象的方法和抽象程度不同。简单工厂模式为创建对象提供了一个基本的集中式工厂，违背开闭原则；工厂方法模式将创建对象的工作委托给子类，不违背开闭原则；抽象工厂模式则通过一系列工厂方法创建相关对象簇，不违背开闭原则。 ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/programming/design-patterns/1-factory-pattern/","summary":"简单工厂（Simple Factory） 简单工厂模式通过一个专门的工厂类基于特定的参数来创建产品类的实例； 简单工厂模式违反了开闭原则，即在需要添加新的产品类型时需要修改工厂类。 代码示例 简单工厂示例类图 点击查看代码 Pizza MargheritaPizza PepperoniPizza BeefPizza PizzaFactory SimpleFactoryTest 输出结果 package org.signalyu.patterns.factory; public interface Pizza { void prepare(); void bake(); void cut(); void box(); } package org.signalyu.patterns.factory; public class MargheritaPizza implements Pizza { @Override public void prepare() { System.out.println(\"玛格丽特比萨：1. 准备材料\"); } @Override public void bake() { System.out.println(\"玛格丽特比萨：2. 烘烤比萨 \"); } @Override public void cut() { System.out.println(\"玛格丽特比萨：3. 切比萨\"); } @Override public void box() { System.out.println(\"玛格丽特比萨：4. 披萨打包\"); } } package org.","title":"设计模式——工厂模式"},{"content":" 子类对象拥有父类的私有成员，但子类不继承父类的私有属性。 子类对象包含父类私有属性 首先验证子类对象包含父类的私有属性，代码如下：\n点击查看代码 class Parent { private int privateField; public Parent() { System.out.println(\"this in Parent() =\u003e \" + this); this.privateField = 666; } public Parent(int privateField) { System.out.println(\"this in Parent(int) =\u003e \" + this); this.privateField = privateField; } private void printPrivateField() { System.out.println(this.privateField); } public void accessPrivateMembers() { System.out.println(\"this in accessPrivateMembers() =\u003e \" + this); System.out.print(\"调用 this.printPrivateField() 方法 =\u003e \"); this.printPrivateField(); } } class Child extends Parent { public Child() { System.out.println(\"this in Child() =\u003e \" + this); } } public class Main { public static void main(String[] args) { Child child = new Child(); child.accessPrivateMembers(); } } 上述代码输出结果为：\nthis in Parent() =\u003e Child@372f7a8d this in Child() =\u003e Child@372f7a8d this in accessPrivateMembers() =\u003e Child@372f7a8d 调用 this.printPrivateField() 方法 =\u003e 666 上述代码的输出结果表明，执行 new Child() 后，会调用子类 Child 的无参构造器，而在子类构造器中默认会调用父类的无参构造器。而从输出结果可知，父类无参构造中的 this 指向子类 Child。并且 this.privateField = 666; 也成功执行。同样地，在调用公有（public）方法 accessPrivateMembers() 时，此时的 this 为 Child，并且通过 this 也可以访问父类的私有方法 printPrivateFields()。显然，this 中包含父类的私有属性 privateField 和私有方法 printPrivateField()。事实上，可以通过 org.openjdk.jol 工具中的 ClassLayout 来查看 child 对象在内存中的布局。代码如下：\n点击查看代码 import org.openjdk.jol.info.ClassLayout; class Parent { private int privateField; public Parent() { System.out.println(\"this in Parent() =\u003e \" + this); this.privateField = 666; } public Parent(int privateField) { System.out.println(\"this in Parent(int) =\u003e \" + this); this.privateField = privateField; } private void printPrivateField() { System.out.println(this.privateField); } public void accessPrivateMembers() { System.out.println(\"this in accessPrivateMembers() =\u003e \" + this); System.out.print(\"调用 this.printPrivateField() 方法 =\u003e \"); this.printPrivateField(); } } class Child extends Parent { public Child() { System.out.println(\"this in Child() =\u003e \" + this); } } public static void main(String[] args) { Child child = new Child(); String childLayout = ClassLayout.parseInstance(child).toPrintable(); System.out.println(childLayout); } 上述代码输出结果为：\nChild object internals: OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x000000372f7a8d01 (hash: 0x372f7a8d; age: 0) 8 4 (object header: class) 0x01001418 12 4 int Parent.privateField 666 Instance size: 16 bytes Space losses: 0 bytes internal + 0 bytes external = 0 bytes total 根据上述输出结果可以看出，child 对象中确实包含父类的私有属性。\nJava 语言规范中关于类成员的规定 Java 类成员 Java 语言规范中关于类成的部分陈述如下：\n类的成员包括以下所有成员（The members of a class type are all of the following）：\n从除 Object 类之外的直接父类继承的成员（Members inherited from its direct superclass, except in class Object, which has no direct superclass） 从任何直接父接口继承的成员（Members inherited from any direct superinterfaces） 类中声明的成员（Members declared in the body of the class） 类中声明为私有的成员不会被该类的子类继承。（Members of a class that are declared private are not inherited by subclasses of that class.）\n只有声明为受保护（protected）或公共（public）的类成员才会被本包外的子类继承。（Only members of a class that are declared protected or public are inherited by subclasses declared in a package other than the one in which the class is declared.）\n构造器（constructors）、静态初始化器（static initializers）和实例初始化器（instance initializers）不是类成员，因此不会被继承。（Constructors, static initializers, and instance initializers are not members and therefore are not inherited.）\n超类的私有成员 Oracle 官方 Java 教程中关于超类的私有成员的说明：\n子类不继承父类的私有成员。不过，如果超类有访问其私有字段的公共或保护方法，子类也可以使用这些方法（间接访问父类的私有属性）。（A subclass does not inherit the private members of its parent class. However, if the superclass has public or protected methods for accessing its private fields, these can also be used by the subclass.）\n官方已明确说明子类不继承父类的私有成员，那为什么子类对象可以访问父类的私有成员呢？博主认为，继承是发生在类之间行为，而非对象之间的行为。子类 Child 不继承父类 Parent 的私有成员，并不代表子类对象 child 不可以拥有父类的私有成员。 参考资料 知乎：java中子类有没有继承父类的私有变量？ Java Language Specification : 8.2. Class Members Oracle Java Tutorial: Private Members in a Superclass Do subclasses inherit private fields? ","permalink":"https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/programming/java/1-java-private-inheritance/","summary":"子类对象拥有父类的私有成员，但子类不继承父类的私有属性。 子类对象包含父类私有属性 首先验证子类对象包含父类的私有属性，代码如下：\n点击查看代码 class Parent { private int privateField; public Parent() { System.out.println(\"this in Parent() =\u003e \" + this); this.privateField = 666; } public Parent(int privateField) { System.out.println(\"this in Parent(int) =\u003e \" + this); this.privateField = privateField; } private void printPrivateField() { System.out.println(this.privateField); } public void accessPrivateMembers() { System.out.println(\"this in accessPrivateMembers() =\u003e \" + this); System.out.print(\"调用 this.printPrivateField() 方法 =\u003e \"); this.printPrivateField(); } } class Child extends Parent { public Child() { System.","title":"Java 私有成员继承"}]