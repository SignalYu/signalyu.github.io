<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Coding Patterns for Interview Questions | Signal&#39;s Blog</title>
<meta name="keywords" content="Coding Patterns">
<meta name="description" content="Simple Two Pointers The Simple Two Pointers technique is commonly used to solve problems involving sorted array, where a set of elements needs to be found that satisfy certain constrains. This approach is efficient in scenarios such as finding a pair that sums to a target or reversing an array or string. In the two simple two pointers technique, two pointers &ndash; typically labeled &ldquo;left&rdquo; and &ldquo;right&rdquo; &ndash; are initialized and move in a specific direction based on the problem&rsquo;s requirements.">
<meta name="author" content="Signal Yu">
<link rel="canonical" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/coding-patterns/1-coding-patterns-for-interview-questions/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.9ddf6c021b47a5a861a7c6af241af938775e0fc65a762930d3a2426fc59e9a5c.css" integrity="sha256-nd9sAhtHpahhp8avJBr5OHdeD8Zadikw06JCb8Wemlw=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://signalyu.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://signalyu.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://signalyu.github.io/favicon-32x32">
<link rel="apple-touch-icon" href="https://signalyu.github.io/apple-touch-icon">
<link rel="mask-icon" href="https://signalyu.github.io/favicon.io">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/coding-patterns/1-coding-patterns-for-interview-questions/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css"
    integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"
    integrity="sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd"
    crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js"
    integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk"
    crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: true }
            ],
            
            throwOnError: false,
            strict: false
        });
    });
</script>

  

<meta property="og:title" content="Coding Patterns for Interview Questions" />
<meta property="og:description" content="Simple Two Pointers The Simple Two Pointers technique is commonly used to solve problems involving sorted array, where a set of elements needs to be found that satisfy certain constrains. This approach is efficient in scenarios such as finding a pair that sums to a target or reversing an array or string. In the two simple two pointers technique, two pointers &ndash; typically labeled &ldquo;left&rdquo; and &ldquo;right&rdquo; &ndash; are initialized and move in a specific direction based on the problem&rsquo;s requirements." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/coding-patterns/1-coding-patterns-for-interview-questions/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-12-02T10:15:04+08:00" />
<meta property="article:modified_time" content="2024-12-02T10:15:04+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Coding Patterns for Interview Questions"/>
<meta name="twitter:description" content="Simple Two Pointers The Simple Two Pointers technique is commonly used to solve problems involving sorted array, where a set of elements needs to be found that satisfy certain constrains. This approach is efficient in scenarios such as finding a pair that sums to a target or reversing an array or string. In the two simple two pointers technique, two pointers &ndash; typically labeled &ldquo;left&rdquo; and &ldquo;right&rdquo; &ndash; are initialized and move in a specific direction based on the problem&rsquo;s requirements."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://signalyu.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Coding Patterns for Interview Questions",
      "item": "https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/coding-patterns/1-coding-patterns-for-interview-questions/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Coding Patterns for Interview Questions",
  "name": "Coding Patterns for Interview Questions",
  "description": "Simple Two Pointers The Simple Two Pointers technique is commonly used to solve problems involving sorted array, where a set of elements needs to be found that satisfy certain constrains. This approach is efficient in scenarios such as finding a pair that sums to a target or reversing an array or string. In the two simple two pointers technique, two pointers \u0026ndash; typically labeled \u0026ldquo;left\u0026rdquo; and \u0026ldquo;right\u0026rdquo; \u0026ndash; are initialized and move in a specific direction based on the problem\u0026rsquo;s requirements.",
  "keywords": [
    "Coding Patterns"
  ],
  "articleBody": "Simple Two Pointers The Simple Two Pointers technique is commonly used to solve problems involving sorted array, where a set of elements needs to be found that satisfy certain constrains. This approach is efficient in scenarios such as finding a pair that sums to a target or reversing an array or string. In the two simple two pointers technique, two pointers ‚Äì typically labeled ‚Äúleft‚Äù and ‚Äúright‚Äù ‚Äì are initialized and move in a specific direction based on the problem‚Äôs requirements.\nTwo Sum II - Input Array Is Sorted SHOW PROBLEM Problem Statement\nGiven a 1-indexed array of integers, numbers, sorted in non-decreasing order, find two numbers that add up to a specific target. Let these two numbers be numbers[index1] and numbers[index2], where 1 \u003c= index1 \u003c index2 \u003c= numbers.length.\nReturn the indices of the two numbers, index1 and index2, incremented by one, as an integer array [index1, index2] of length 2.\nThe problem guarantees that there is exactly one solution. You may not use the same element twice. Your solution must use only constant extra space. Example 1:\nInput: numbers = [2,7,11,15], target = 9 Output: [1, 2] Explanation: The sum of 2 and 7 is 9, so index1 = 1, index2 = 2. We return [1, 2]. Example 2:\nInput: numbers = [2,3,4], target = 6 Output: [1, 3] Explanation: The sum of 2 and 4 is 6, so index1 = 1, index2 = 3. We return [1, 3]. Example 3:\nInput: numbers = [-1,0], target = -1 Output: [1, 2] Explanation: The sum of -1 and 0 is -1, so index1 = 1, index2 = 2. We return [1, 2]. Constraints:\n2 \u003c= numbers.length \u003c= 30,000 -1000 \u003c= numbers[i] \u003c= 1000 numbers is sorted in non-decreasing order. -1000 \u003c= target \u003c= 1000 There is exactly one solution for each test case. Go to Leetcode üîó SHOW CODE Java class Solution { public int[] twoSum(int[] numbers, int target) { int left = 0, right = numbers.length - 1; // Iterate while left pointer is before right pointer while (left \u003c right) { int currentSum = numbers[left] + numbers[right]; // Check if the current sum matches the target if (currentSum == target) { break; } // Adjust the pointers to move towards the target sum if (currentSum \u003c target) { left++; // Increase sum by moving left pointer right } else { right--; // Decrease sum by moving right pointer left } } // Reture 1-indexed result return new int[] { left + 1, right + 1 }; } } SHOW NOTES Algorithm Walkthrough\nnums = [1, 2, 3, 4, 5, 8] target = 7 Initialize pointers: left = 0, right = 5 First iteration: currentSum = 1 + 8 = 9 (greater than the target) Decrease the right pointer to 4 Second iteration: currentSum = 1 + 5 = 6 (less than the target) Increase the left pointer to 1 Third iteration: currentSum = 2 + 4 = 6 (equals the target) Return the indices [1, 3]. Visualization\n3Sum SHOW PROBLEM Problem Statement\nGiven an integer array nums, return all unique triplets [nums[i], nums[j], nums[k]] such that:\ni != j, i != k, and j != k nums[i] + nums[j] + nums[k] == 0 The solution set must not contain duplicate triplets.\nExample 1:\nInput: nums = [-1, 0, 1, 2, -1, -4] Output: [[-1, -1, 2], [-1, 0, 1]] Explanation: nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 The distinct triplets are [-1, 0, 1] and [-1, -1, 2].\nNote: The order of the output and the order of the triplets does not matter.\nExample 2:\nInput: nums = [0, 1, 1] Output: [] Explanation: The only possible triplet does not sum up to 0. Example 3:\nInput: nums = [0, 0, 0] Output: [[0, 0, 0]] Explanation: The only possible triplet sums up to 0. Constraints:\n3 \u003c= nums.length \u003c= 3000 10^5 \u003c= nums[i] \u003c= 10^5 Go to Leetcode üîó SHOW CODE Java class Solution { public List",
  "wordCount" : "693",
  "inLanguage": "en",
  "datePublished": "2024-12-02T10:15:04+08:00",
  "dateModified": "2024-12-02T10:15:04+08:00",
  "author":{
    "@type": "Person",
    "name": "Signal Yu"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/coding-patterns/1-coding-patterns-for-interview-questions/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Signal's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://signalyu.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://signalyu.github.io/" accesskey="h" title="Signal&#39;s Blog (Alt + H)">
                <img src="https://signalyu.github.io/apple-touch-icon.png" alt="" aria-label="logo"
                    height="40">Signal&#39;s Blog</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://signalyu.github.io/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://signalyu.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://signalyu.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://signalyu.github.io/">Home</a>&nbsp;¬ª&nbsp;<a href="https://signalyu.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Coding Patterns for Interview Questions
    </h1>
    <div class="post-meta"><span title='2024-12-02 10:15:04 +0800 HKT'>Dec 2 2024</span>&nbsp;¬∑&nbsp;Signal Yu

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#simple-two-pointers" aria-label="Simple Two Pointers">Simple Two Pointers</a><ul>
                        
                <li>
                    <a href="#two-sum-ii---input-array-is-sorted" aria-label="Two Sum II - Input Array Is Sorted">Two Sum II - Input Array Is Sorted</a></li>
                <li>
                    <a href="#3sum" aria-label="3Sum">3Sum</a></li></ul>
                </li>
                <li>
                    <a href="#fast--slow-pointers" aria-label="Fast &amp; Slow Pointers">Fast &amp; Slow Pointers</a><ul>
                        
                <li>
                    <a href="#linked-list-cycle" aria-label="Linked List Cycle">Linked List Cycle</a></li>
                <li>
                    <a href="#middle-of-the-linkedlist" aria-label="Middle of the LinkedList">Middle of the LinkedList</a></li>
                <li>
                    <a href="#remove-nth-node-from-end-of-list" aria-label="Remove Nth Node From End of List">Remove Nth Node From End of List</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="simple-two-pointers">Simple Two Pointers<a hidden class="anchor" aria-hidden="true" href="#simple-two-pointers">#</a></h1>
<blockquote>
<p>The <strong>Simple Two Pointers</strong> technique is commonly used to solve problems involving <strong>sorted</strong> array, where a set of elements needs to be found that satisfy certain constrains. This approach is efficient in scenarios such as <em><strong>finding a pair that sums to a target or reversing an array or string</strong></em>. In the two simple two pointers technique, two pointers &ndash; typically labeled &ldquo;left&rdquo; and &ldquo;right&rdquo; &ndash; are initialized and move in a specific direction based on the problem&rsquo;s requirements.</p>
</blockquote>
<h2 id="two-sum-ii---input-array-is-sorted">Two Sum II - Input Array Is Sorted<a hidden class="anchor" aria-hidden="true" href="#two-sum-ii---input-array-is-sorted">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement</strong></p>
<p>Given a 1-indexed array of integers, <code>numbers</code>, sorted in non-decreasing order, find two numbers that add up to a specific target. Let these two numbers be <code>numbers[index1]</code> and <code>numbers[index2]</code>, where <code>1 &lt;= index1 &lt; index2 &lt;= numbers.length</code>.</p>
<p>Return the indices of the two numbers, <code>index1</code> and <code>index2</code>, incremented by one, as an integer array <code>[index1, index2]</code> of length 2.</p>
<ul>
<li>The problem guarantees that there is exactly one solution.</li>
<li>You may not use the same element twice.</li>
<li>Your solution must use only constant extra space.</li>
</ul>
<p><strong>Example 1:</strong></p>
<ul>
<li><strong>Input</strong>: <code>numbers = [2,7,11,15], target = 9</code></li>
<li><strong>Output</strong>: <code>[1, 2]</code></li>
<li><strong>Explanation</strong>: The sum of 2 and 7 is 9, so <code>index1 = 1</code>, <code>index2 = 2</code>. We return <code>[1, 2]</code>.</li>
</ul>
<p><strong>Example 2:</strong></p>
<ul>
<li><strong>Input</strong>: <code>numbers = [2,3,4], target = 6</code></li>
<li><strong>Output</strong>: <code>[1, 3]</code></li>
<li><strong>Explanation</strong>: The sum of 2 and 4 is 6, so <code>index1 = 1</code>, <code>index2 = 3</code>. We return <code>[1, 3]</code>.</li>
</ul>
<p><strong>Example 3:</strong></p>
<ul>
<li><strong>Input</strong>: <code>numbers = [-1,0], target = -1</code></li>
<li><strong>Output</strong>: <code>[1, 2]</code></li>
<li><strong>Explanation</strong>: The sum of -1 and 0 is -1, so <code>index1 = 1</code>, <code>index2 = 2</code>. We return <code>[1, 2]</code>.</li>
</ul>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>2 &lt;= numbers.length &lt;= 30,000</code></li>
<li><code>-1000 &lt;= numbers[i] &lt;= 1000</code></li>
<li><code>numbers</code> is sorted in non-decreasing order.</li>
<li><code>-1000 &lt;= target &lt;= 1000</code></li>
<li>There is exactly one solution for each test case.</li>
</ul>
<hr>

</details></p>


<a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted" target="_blank">
Go to Leetcode üîó
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int left = 0, right = numbers.length - 1;

        // Iterate while left pointer is before right pointer
        while (left < right) {
            int currentSum = numbers[left] + numbers[right];

            // Check if the current sum matches the target
            if (currentSum == target) {
                break;
            }

            // Adjust the pointers to move towards the target sum
            if (currentSum < target) { 
                left++; // Increase sum by moving left pointer right
            } else { 
                right--; // Decrease sum by moving right pointer left
            }
        }

        // Reture 1-indexed result
        return new int[] { left + 1, right + 1 }; 
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW NOTES</summary>
  <p><strong>Algorithm Walkthrough</strong></p>
<ul>
<li><code>nums = [1, 2, 3, 4, 5, 8]</code></li>
<li><code>target = 7</code></li>
</ul>
<ol>
<li><strong>Initialize pointers</strong>: <code>left = 0, right = 5</code></li>
<li><strong>First iteration</strong>:
<ul>
<li><code>currentSum = 1 + 8 = 9</code> (greater than the target)</li>
<li>Decrease the <code>right</code> pointer to <code>4</code></li>
</ul>
</li>
<li><strong>Second iteration</strong>:
<ul>
<li><code>currentSum = 1 + 5 = 6</code> (less than the target)</li>
<li>Increase the <code>left</code> pointer to <code>1</code></li>
</ul>
</li>
<li><strong>Third iteration</strong>:
<ul>
<li><code>currentSum = 2 + 4 = 6</code> (equals the target)</li>
<li>Return the indices <code>[1, 3]</code>.</li>
</ul>
</li>
</ol>
<p><strong>Visualization</strong></p>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/1-find-a-pair-sums-to-the-target.png" alt="Two Sum II - Input Array Is Sorted"  />
</p>

</details></p>

<hr>
<h2 id="3sum">3Sum<a hidden class="anchor" aria-hidden="true" href="#3sum">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement</strong></p>
<p>Given an integer array <code>nums</code>, return all unique triplets <code>[nums[i], nums[j], nums[k]]</code> such that:</p>
<ul>
<li><code>i != j</code>, <code>i != k</code>, and <code>j != k</code></li>
<li><code>nums[i] + nums[j] + nums[k] == 0</code></li>
</ul>
<p>The solution set must not contain duplicate triplets.</p>
<hr>
<p><strong>Example 1:</strong></p>
<ul>
<li><strong>Input</strong>: <code>nums = [-1, 0, 1, 2, -1, -4]</code></li>
<li><strong>Output</strong>: <code>[[-1, -1, 2], [-1, 0, 1]]</code></li>
<li><strong>Explanation</strong>:
<ul>
<li><code>nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0</code></li>
<li><code>nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0</code></li>
<li><code>nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0</code></li>
</ul>
</li>
</ul>
<p>The distinct triplets are <code>[-1, 0, 1]</code> and <code>[-1, -1, 2]</code>.</p>
<p>Note: The order of the output and the order of the triplets does not matter.</p>
<p><strong>Example 2:</strong></p>
<ul>
<li><strong>Input</strong>: <code>nums = [0, 1, 1]</code></li>
<li><strong>Output</strong>: <code>[]</code></li>
<li><strong>Explanation</strong>: The only possible triplet does not sum up to 0.</li>
</ul>
<p><strong>Example 3:</strong></p>
<ul>
<li><strong>Input</strong>: <code>nums = [0, 0, 0]</code></li>
<li><strong>Output</strong>: <code>[[0, 0, 0]]</code></li>
<li><strong>Explanation</strong>: The only possible triplet sums up to 0.</li>
</ul>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>3 &lt;= nums.length &lt;= 3000</code></li>
<li><code>10^5 &lt;= nums[i] &lt;= 10^5</code></li>
</ul>
<hr>

</details></p>


<a href="https://leetcode.com/problems/3sum" target="_blank">
Go to Leetcode üîó
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> triplets = new ArrayList<>();

        // Sort the array to enable the two-pointer approach
        Arrays.sort(nums);

        for (int i = 0; i < nums.length - 2; i++) {
            // Skip duplicates for 'i' to ensure unique triplets
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }

            // Find pairs that sum up to the negative of the current number
            findTwoSum(nums, -nums[i], i + 1, nums.length - 1, triplets);
        }

        return triplets;
    }

    private static void findTwoSum(int[] nums, int target, int left, int right, List<List<Integer>> triplets) {
        while (left < right) {
            int currentSum = nums[left] + nums[right];
            if (target == currentSum) {
                triplets.add(Arrays.asList(-target, nums[left], nums[right]));
                left++;
                right--;

                // Skip duplicates for 'left' and 'right' to avoid duplicate triplets
                while (left < right && nums[left] == nums[left - 1]) {
                    left++;
                }
                while (left < right && nums[right] == nums[right + 1]) {
                    right--;
                }
            } else if (currentSum < target) {
                // Move 'left' pointer to the right to increase the sum
                left++;
            } else {
                // Move 'right' pointer to the left to decrease the sum
                right--;
            }
        }
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW NOTES</summary>
  
</details></p>

<hr>
<h1 id="fast--slow-pointers">Fast &amp; Slow Pointers<a hidden class="anchor" aria-hidden="true" href="#fast--slow-pointers">#</a></h1>
<blockquote>
<p>The <strong>Fast and Slow Pointers</strong> pattern, also known as the <strong>Tortoise and Hare Algorithm</strong>, invloves using two pointers that move at different speeds over an array or linked list. It is commonly used to solve problems related to cycle detection or finding the middle element in linked lists or arrays.</p>
</blockquote>
<h2 id="linked-list-cycle">Linked List Cycle<a hidden class="anchor" aria-hidden="true" href="#linked-list-cycle">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement</strong></p>
<p>Given the head of a singly linked list, write a function to determine whether the list contains a cycle.</p>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/2-linked-list-cycle.webp" alt="Liked List Cycle"  />
</p>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the list is between 0 and 10,000.</li>
<li>Node values are in the range of [-10^5, 10^5].</li>
</ul>

</details></p>


<a href="https://leetcode.com/problems/linked-list-cycle" target="_blank">
Go to Leetcode üîó
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        // Initialize slow and fast pointers at the head of the list
        ListNode slow = head, fast = head;

        // Traverse the list with fast and slow pointers
        while (fast != null && fast.next != null) {
            // Move slow pointer by one step and fast pointer by two steps
            slow = slow.next;
            fast = fast.next.next;

            // If the two pointers meet, a cycle is detected
            if (slow == fast) {
                return true;
            }
        }

        // If fast pointer reaches the end, there's no cycle
        return false;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW NOTES</summary>
  <blockquote>
<p>The fast and slow pointers start from the same point. The fast pointer moves two steps at a time, while the slow pointer moves one step at a time. If the linked list has no cycle, the fast pointer will reach the end before the slow pointer. If the linked list has a cycle, the fast pointer will enter the cycle first, and both pointers will continue moving in the cycle. Eventually, they will meet at some point, indicating the presence of a cycle. There are two possible scenerios when both pointers are in the cycle:</p>
</blockquote>
<ol>
<li>The fast pointer is one step behind the slow pointer.</li>
<li>The fast pointer is two steps behind the slow pointer.</li>
</ol>
<blockquote>
<p>In scenerio 1, after the next move, the two pointers will meet at the same position. This is the condition that confirms the presence of a cycle, as shown in the following illustration.</p>
</blockquote>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/3-linked-list-cycle-2.webp" alt="Linked List Cycle: Slow &amp;amp; Fast Pointer"  />
</p>

</details></p>

<hr>
<h2 id="middle-of-the-linkedlist">Middle of the LinkedList<a hidden class="anchor" aria-hidden="true" href="#middle-of-the-linkedlist">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement</strong></p>
<p>Given the head of a singly linked list, write a method to return the middle node of the linked list.</p>
<p>If the total number of nodes in the list is even, return the second middle node.</p>
<p><strong>Example 1:</strong></p>
<ul>
<li><strong>Input</strong>: 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5 ‚Üí null</li>
<li><strong>Output</strong>: 3</li>
</ul>
<p><strong>Example 2:</strong></p>
<ul>
<li><strong>Input</strong>: 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5 ‚Üí 6 ‚Üí null</li>
<li><strong>Output</strong>: 4</li>
</ul>
<p><strong>Example 3:</strong></p>
<ul>
<li><strong>Input</strong>: 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5 ‚Üí 6 ‚Üí 7 ‚Üí null</li>
<li><strong>Output</strong>: 4</li>
</ul>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the list is between 1 and 100.</li>
<li>Node values are between 1 and 100.</li>
</ul>

</details></p>


<a href="https://leetcode.com/problems/middle-of-the-linked-list" target="_blank">
Go to Leetcode üîó
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode middleNode(ListNode head) {
        // Initialize slow and fast pointers at the head of the list
        ListNode slow = head, fast = head;
        
        while (fast != null && fast.next != null) {
            slow = slow.next;          // Move slow pointer by one step
            fast = fast.next.next;     // Move fast pointer by two steps
        }

        // When fast pointer reaches the end, slow pointer will be at the middle
        return slow;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW NOTES</summary>
  <p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/4-middle-of-linked-list.svg" alt="Middle of Linked List"  />
</p>
<hr>
<p>If the total number of nodes in the list is even, return <strong>the first middle node</strong>, then</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">while</span> (fast <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> fast.<span style="color:#a6e22e">next</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>    fast <span style="color:#f92672">=</span> fast.<span style="color:#a6e22e">next</span>.<span style="color:#a6e22e">next</span>;     <span style="color:#75715e">// Move fast pointer by two steps</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (fast <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    slow <span style="color:#f92672">=</span> slow.<span style="color:#a6e22e">next</span>;          <span style="color:#75715e">// Move slow pointer by one step</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
</details></p>

<hr>
<h2 id="remove-nth-node-from-end-of-list">Remove Nth Node From End of List<a hidden class="anchor" aria-hidden="true" href="#remove-nth-node-from-end-of-list">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement</strong></p>
<p>Given the head of a singly linked list, remove the nth node from the end of the list and return the head of the updated list.</p>
<p><strong>Example 1:</strong></p>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/5-remove-nth-node-from-end-of-list.jpg" alt="Remove Nth Node From End of List"  />
</p>
<ul>
<li><strong>Input</strong>: head = [1, 2, 3, 4, 5], n = 2</li>
<li><strong>Output</strong>: [1, 2, 3, 5]</li>
</ul>
<p><strong>Example 2:</strong></p>
<ul>
<li><strong>Input</strong>: head = [1], n = 1</li>
<li><strong>Output</strong>: []</li>
</ul>
<p><strong>Example 3:</strong></p>
<ul>
<li><strong>Input</strong>: head = [1, 2], n = 1</li>
<li><strong>Output</strong>: [1]</li>
</ul>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the list is between 1 and 10^5.</li>
<li>1 &lt;= n &lt;= the number of nodes in the list.</li>
</ul>

</details></p>


<a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list" target="_blank">
Go to Leetcode üîó
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // Create a dummy node to handle edge cases (e.g., removing the head)
        ListNode dummy = new ListNode(0);
        dummy.next = head;

        // Initialize slow and fast pointers at the dummy node
        ListNode slow = dummy, fast = dummy;

        // Move the fast pointer n+1 steps ahead from the dummy node
        for (int i = 0; i <= n; i++) {
            fast = fast.next;
        }

        // Move both slow and fast pointers one step at a time until fast reaches the
        // end
        while (fast != null) {
            slow = slow.next;
            fast = fast.next;
        }

        // Remove the nth node from the end by skipping it
        slow.next = slow.next.next;

        // Return the updated head
        return dummy.next;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW NOTES</summary>
  <blockquote>
<p>The goal is to remove the nth node from the end of the list. The first step in solving this problem is to determine the position of the nth node from the end. This can be achieved using the <strong>slow and fast pointers</strong> techique. Initially, two pointer, <code>slow</code> and <code>fast</code>, are both set to the head of the list. The <code>fast</code> pointer is then moved <code>n</code> steps ahead from the head node.</p>
</blockquote>
<blockquote>
<p>Once the <code>fast</code> pointer is <code>n</code> steps ahead, both the <code>slow</code> and <code>fast</code> pointers move one step at a time simultaneously. When the <code>fast</code> pointer reaches the end of the list, the <code>slow</code> pointer will be positioned at the nth node from the end. Since the task is to remove this node, the node before it must be idetified.</p>
</blockquote>
<blockquote>
<p>However, handling the edge case where the node to be removed is the head node requires special attention. To address this issue, a <strong>dummy node</strong> is introduced. The dummy node points to the head of the list, ensuring that there is always a valid node before the one to be deleted, even if the head node itself is the target.</p>
</blockquote>
<blockquote>
<p>To find the node just before the nth node from the end, the <code>fast</code> pointer is moved <code>n+1</code> steps ahead from the dummy node. This places the <code>fast</code> pointer <code>n+1</code> steps ahead of the <code>slow</code> pointer. Both pointers are then moved one step at a time until the fast pointer reaches the end of the list. At this point, the <code>slow</code> pointer will be positioned just before the nth node from the end.</p>
</blockquote>
<blockquote>
<p>The removal of the nth node is accomplished by updating the <code>slow</code> pointer&rsquo;s next reference <code>slow.next = slow.next.next;</code>. When the node to be removed is the head, the <code>slow</code> pointer remains at the dummy node without moving. After executing <code>slow.next = slow.next.next;</code>, the node after the dummy node becomes the new head of the list.</p>
</blockquote>
<hr>
<p><strong>Illustration</strong></p>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/6-remove-nth-node-from-end-of-list.png" alt="Remove Nth Node From End of List"  />
</p>
<hr>
<p><strong>Illustration: Remove Head Node</strong></p>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/7-remove-head-node-from-end-of-list.png" alt="Remove Nth Node From End of List: Remove Head Node"  />
</p>

</details></p>

<hr>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://signalyu.github.io/tags/coding-patterns/">Coding Patterns</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/programming/coding-problems/1-cocoding-problem-set/">
    <span class="title">¬´ PREV</span>
    
    <br>
    <span>Coding Problem Set</span>
  </a>
  <a class="next" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/database/1-database-notes/">
    <span class="title">NEXT ¬ª</span>
    
    <br>
    <span>Database Design Notes</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://signalyu.github.io/">Signal&#39;s Blog</a></span> ¬∑ 
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>

</body>
</html>
