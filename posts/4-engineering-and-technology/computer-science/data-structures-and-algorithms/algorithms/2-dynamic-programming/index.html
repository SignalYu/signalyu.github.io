<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>数据结构与算法：动态规划 | Signal&#39;s Blog</title>
<meta name="keywords" content="工程与技术, 计算机科学, 数据结构与算法">
<meta name="description" content="动态规划相关概念 动态规划核心思想： 将原问题划分为更简单的子问题，通过子问题的解来构建问题的解。 Memoization（自上而下法）：将原问题递归地划分为更小的子问题，并在对子问题的结果进行缓存，以避免重复计算。 Tabulation（自下而上法）：从最小的子问题开始，迭代地构建原问题的解。 动态规划例题 斐波那契数列 点击查看题目 斐波那契数（通常用 $F(n)$ 表示）形成的序列称为斐波那契数列。该数列由 $0$ 和 $1$ 开始，后面的每一项数字都是前面两项数字的和。也就是：
$F(1) = 0，F(2) = 1$
$F(n) = F(n - 1) &#43; F(n - 2)，其中\; n &gt; 2$
给定 $n$ ，请计算 $F(n)$。
示例 1：
输入：$n = 2$
输出：$1$
解释：$F(2) = 1$
示例 2：
输入：$n = 3$
输出：$2$
解释：$F(3) = F(2) &#43; F(1) = 1 &#43; 0 = 1$
示例 3：
输入：$n = 4$
输出：$3$
解释：$F(4) = F(3) &#43; F(2) = 1 &#43; 1 = 2$">
<meta name="author" content="Signal Yu">
<link rel="canonical" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/algorithms/2-dynamic-programming/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8d397153e1313fc7080fb221defd149a585e181195089458dedc0f60e27770eb.css" integrity="sha256-jTlxU&#43;ExP8cID7Ih3v0UmlheGBGVCJRY3twPYOJ3cOs=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://signalyu.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://signalyu.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://signalyu.github.io/favicon-32x32">
<link rel="apple-touch-icon" href="https://signalyu.github.io/apple-touch-icon">
<link rel="mask-icon" href="https://signalyu.github.io/favicon.io">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/algorithms/2-dynamic-programming/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css"
    integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"
    integrity="sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd"
    crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js"
    integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk"
    crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: true }
            ],
            
            throwOnError: false,
            strict: false
        });
    });
</script>

  

<meta property="og:title" content="数据结构与算法：动态规划" />
<meta property="og:description" content="动态规划相关概念 动态规划核心思想： 将原问题划分为更简单的子问题，通过子问题的解来构建问题的解。 Memoization（自上而下法）：将原问题递归地划分为更小的子问题，并在对子问题的结果进行缓存，以避免重复计算。 Tabulation（自下而上法）：从最小的子问题开始，迭代地构建原问题的解。 动态规划例题 斐波那契数列 点击查看题目 斐波那契数（通常用 $F(n)$ 表示）形成的序列称为斐波那契数列。该数列由 $0$ 和 $1$ 开始，后面的每一项数字都是前面两项数字的和。也就是：
$F(1) = 0，F(2) = 1$
$F(n) = F(n - 1) &#43; F(n - 2)，其中\; n &gt; 2$
给定 $n$ ，请计算 $F(n)$。
示例 1：
输入：$n = 2$
输出：$1$
解释：$F(2) = 1$
示例 2：
输入：$n = 3$
输出：$2$
解释：$F(3) = F(2) &#43; F(1) = 1 &#43; 0 = 1$
示例 3：
输入：$n = 4$
输出：$3$
解释：$F(4) = F(3) &#43; F(2) = 1 &#43; 1 = 2$" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/algorithms/2-dynamic-programming/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-06-16T11:35:47+08:00" />
<meta property="article:modified_time" content="2024-06-16T11:35:47+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="数据结构与算法：动态规划"/>
<meta name="twitter:description" content="动态规划相关概念 动态规划核心思想： 将原问题划分为更简单的子问题，通过子问题的解来构建问题的解。 Memoization（自上而下法）：将原问题递归地划分为更小的子问题，并在对子问题的结果进行缓存，以避免重复计算。 Tabulation（自下而上法）：从最小的子问题开始，迭代地构建原问题的解。 动态规划例题 斐波那契数列 点击查看题目 斐波那契数（通常用 $F(n)$ 表示）形成的序列称为斐波那契数列。该数列由 $0$ 和 $1$ 开始，后面的每一项数字都是前面两项数字的和。也就是：
$F(1) = 0，F(2) = 1$
$F(n) = F(n - 1) &#43; F(n - 2)，其中\; n &gt; 2$
给定 $n$ ，请计算 $F(n)$。
示例 1：
输入：$n = 2$
输出：$1$
解释：$F(2) = 1$
示例 2：
输入：$n = 3$
输出：$2$
解释：$F(3) = F(2) &#43; F(1) = 1 &#43; 0 = 1$
示例 3：
输入：$n = 4$
输出：$3$
解释：$F(4) = F(3) &#43; F(2) = 1 &#43; 1 = 2$"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://signalyu.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "数据结构与算法：动态规划",
      "item": "https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/algorithms/2-dynamic-programming/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "数据结构与算法：动态规划",
  "name": "数据结构与算法：动态规划",
  "description": "动态规划相关概念 动态规划核心思想： 将原问题划分为更简单的子问题，通过子问题的解来构建问题的解。 Memoization（自上而下法）：将原问题递归地划分为更小的子问题，并在对子问题的结果进行缓存，以避免重复计算。 Tabulation（自下而上法）：从最小的子问题开始，迭代地构建原问题的解。 动态规划例题 斐波那契数列 点击查看题目 斐波那契数（通常用 $F(n)$ 表示）形成的序列称为斐波那契数列。该数列由 $0$ 和 $1$ 开始，后面的每一项数字都是前面两项数字的和。也就是：\n$F(1) = 0，F(2) = 1$\n$F(n) = F(n - 1) + F(n - 2)，其中\\; n \u0026gt; 2$\n给定 $n$ ，请计算 $F(n)$。\n示例 1：\n输入：$n = 2$\n输出：$1$\n解释：$F(2) = 1$\n示例 2：\n输入：$n = 3$\n输出：$2$\n解释：$F(3) = F(2) + F(1) = 1 + 0 = 1$\n示例 3：\n输入：$n = 4$\n输出：$3$\n解释：$F(4) = F(3) + F(2) = 1 + 1 = 2$",
  "keywords": [
    "工程与技术", "计算机科学", "数据结构与算法"
  ],
  "articleBody": "动态规划相关概念 动态规划核心思想： 将原问题划分为更简单的子问题，通过子问题的解来构建问题的解。 Memoization（自上而下法）：将原问题递归地划分为更小的子问题，并在对子问题的结果进行缓存，以避免重复计算。 Tabulation（自下而上法）：从最小的子问题开始，迭代地构建原问题的解。 动态规划例题 斐波那契数列 点击查看题目 斐波那契数（通常用 $F(n)$ 表示）形成的序列称为斐波那契数列。该数列由 $0$ 和 $1$ 开始，后面的每一项数字都是前面两项数字的和。也就是：\n$F(1) = 0，F(2) = 1$\n$F(n) = F(n - 1) + F(n - 2)，其中\\; n \u003e 2$\n给定 $n$ ，请计算 $F(n)$。\n示例 1：\n输入：$n = 2$\n输出：$1$\n解释：$F(2) = 1$\n示例 2：\n输入：$n = 3$\n输出：$2$\n解释：$F(3) = F(2) + F(1) = 1 + 0 = 1$\n示例 3：\n输入：$n = 4$\n输出：$3$\n解释：$F(4) = F(3) + F(2) = 1 + 1 = 2$\n提示：$1 \\le n \\le 30$ 解法一：暴力递归 --- title: 斐波那契：暴力递归 --- flowchart TB f6((\"fib(6)\")) --\u003e f5((\"fib(5)\")) f6 --\u003e f4((\"fib(4)\")) f5 --\u003e f41((\"fib(4)\")) f5 --\u003e f3((\"fib(3)\")) f4 --\u003e f31((\"fib(3)\")) f4 --\u003e f2((\"fib(2)\")) f41 --\u003e f32((\"fib(3)\")) f41 --\u003e f21((\"fib(2)\")) f3 --\u003e f20((\"fib(2)\")) f3 --\u003e f10((\"fib(1)\")) f31 --\u003e f22((\"fib(2)\")) f31 --\u003e f1((\"fib(1)\")) f32 --\u003e f23((\"fib(2)\")) f32 --\u003e f11((\"fib(1)\")) style f5 fill:lightblue,color:black style f4 fill:orange,color:black style f41 fill:orange,color:black style f3 fill:red style f31 fill:red style f32 fill:red style f20 fill:purple style f2 fill:purple style f21 fill:purple style f22 fill:purple style f23 fill:purple style f1 fill:grey style f11 fill:grey style f10 fill:grey public static long fib(int n) { if (n == 1) { return 0; } if (n == 2) { return 1; } return fib(n - 1) + fib(n - 2); } 如上图所示，暴力递归过程中，只有 $fib(6)$ 和 $fib(5)$ 计算了 1 次，$fib(4)$，$fib(3)$，$fib(2)$，$fib(1)$ 都进行了重复计算。\n解法二：递归 + 缓存 Memoization（自上而下法）：在递归求解子问题时，将子问题的结果缓存起来，之后计算相同的子问题时，直接从缓存中获取结果，以避免重复计算。\n斐波那契：递归 + 缓存 import java.util.HashMap; import java.util.Map; public class Fibonacci { // 使用 HashMap 来存储已经计算过的斐波那契数 private Map cache = new HashMap\u003c\u003e(); public long fib(int n) { // 基本情况 if (n == 1) { return 0; } if (n == 2) { return 1; } // 检查缓存中是否已有结果 if (cache.containsKey(n)) { return cache.get(n); } // 递归计算斐波那契数，并存储结果到缓存中 long result = fib(n - 1) + fib(n - 2); cache.put(n, result); return result; } } 上述方法缺陷：当 $n$ 比较大时会导致栈溢出（StackOverflow）。\n解法三：迭代 Tabulation（自下而上法）：从最小的子问题 $fib(1)$ 和 $fib(2)$ 入手，迭代地计算出更大子问题的结果。\n迭代（自下而上） import java.util.HashMap; import java.util.Map; public class Solution { private static Map cache = new HashMap\u003c\u003e(); public static void main(String[] args) { System.out.println(fib(1)); System.out.println(fib(2)); System.out.println(fib(2000)); } public static long fib(int n) { cache.put(1, 0L); cache.put(2, 1L); for (int i = 3; i $\\le$ n; i++) { cache.put(i, cache.get(i - 1) + cache.get(i - 2)); } return cache.get(n); } } 解法四：迭代 + 中间变量 解法三解决了栈溢出问题，其空间复杂度为 $O(n)$，可以进一步优化为 $O(1)$。\npublic class Solution { public static void main(String[] args) { System.out.println(fib(1)); System.out.println(fib(2)); System.out.println(fib(6)); } public static long fib(int n) { if (n == 1) { return 0; } if (n == 2){ return 1; } long prev1 = 0L; // F(1) long prev2 = 1L; // F(2) long current = 0L; for (int i = 3; i $\\le$ n; i++) { current = prev1 + prev2; prev1 = prev2; prev2 = current; } return current; } } 不同路径 点击查看题目 一个机器人位于一个 m x n 网格的左上角（如下图所示）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。\n问总共有多少条不同的路径？\n走格子示意图 示例 1\n输入：m = 3, n = 7\n输出：28\n示例 2：\n输入：m = 3, n = 2\n输出：3\n解释：\n从左上角开始，总共有 3 条路径可以到达右下角。\n向右 -\u003e 向下 -\u003e 向下 向下 -\u003e 向下 -\u003e 向右 向下 -\u003e 向右 -\u003e 向下 示例 3：\n输入：m = 7, n = 3\n输出：28\n示例 4：\n输入：m = 3, n = 3\n输出：6\n$1 \\le m, n \\le 100$\n题目数据保证答案小于等于 $2 * 10^9$\n--- title: 走格子：2 × 3 --- flowchart g23((\"2,3\")) --\u003e|down| g13((\"1,3\")) g23 --\u003e|right| g22((\"2,2\")) g13 --\u003e|down| g03((\"0,3\")) g13 --\u003e|right| g12((\"1,2\")) g22 --\u003e|down| g121((\"1,2\")) g22 --\u003e|right| g21((\"2,1\")) g12 --\u003e|down| g02((\"0,2\")) g12 --\u003e|right| g11((\"1,1\")) g121 --\u003e|down| g021((\"0,2\")) g121 --\u003e|right| g111((\"1,1\")) g21 --\u003e|down| g1111((\"1,1\")) g21 --\u003e|right| g20((\"2,0\")) style g23 fill:lightgreen,color:black style g13 fill:lightgreen,color:black style g22 fill:lightgreen,color:black style g12 fill:lightgreen,color:black style g22 fill:lightgreen,color:black style g121 fill:lightgreen,color:black style g21 fill:lightgreen,color:black style g11 fill:lightgreen,color:black style g111 fill:lightgreen,color:black style g1111 fill:lightgreen,color:black 走格子（$2\\times 3$）示意图 由上图可得出基本情况：当 $n$ 为 $0$ 或者 $m$ 为 $0$ 时，返回 $0$，当 $n = 1$ 并且 $m=1$ 时，返回 $1$.\n解法一：暴力递归 public static long gridTraveller(int m, int n) { if (m == 1 \u0026\u0026 n == 1) { return 1; } if (m == 0 || n == 0) { return 0; } return gridTraveller(m - 1, n) + gridTraveller(m, n - 1); } 解法二：递归 + 缓存 gridTraveller(m, n) = gridTraveller(n, m) 暴力递归解法的重复计算 import java.util.HashMap; import java.util.Map; public class GridTraveller { public static long gridTraveller(int m, int n) { return gridTraveller(m, n, new HashMap\u003c\u003e()); } private static long gridTraveller(int m, int n, Map memo) { String key = m + \",\" + n; if (memo.containsKey(key)) { return memo.get(key); } if (m == 1 \u0026\u0026 n == 1) { return 1; } if (m == 0 || n == 0) { return 0; } long result = gridTraveller(m - 1, n, memo) + gridTraveller(m, n - 1, memo); memo.put(key, result); return result; } public static void main(String[] args) { System.out.println(gridTraveller(3, 3)); // Output: 6 System.out.println(gridTraveller(18, 18)); // Output: 2333606220 } } 动态规划方法论（先递归再优化） 问题树化 寻找基本情况 暴力递归实现 使用缓存优化 题目 组合总和（canSum） 点击查看题目 给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target，判断 target 是否可以从 candidates 中的元素求和得到。\ncandidates 中的同一个数字可以无限制重复被选取 。\n示例 1:\n输入：candidates = [2,3,6,7], target = 7\n输出：true\n示例 2：\n输入: candidates = [2,3], target = 8\n输出：true\n示例 3：\n输入: candidates = [2], target = 1\n输出：false\n提示：\n1 $\\le$ candidates.length $\\le$ 30 2 $\\le$ candidates[i] $\\le$ 40 candidates 的所有元素互不相同 1 $\\le$ target $\\le$ 40 暴力递归 --- title: 组合总和（cansum）暴力递归 --- flowchart TB l1((8))--\u003e|-2| l21((6)) l1 --\u003e|-3| l22((5)) l21 --\u003e|-2| l31((4)) l21 --\u003e|-3| l32((3)) l22 --\u003e|-2| l33((3)) l22 --\u003e|-3| l34((2)) l31 --\u003e|-2| l41((2)) l31 --\u003e|-3| l42((1)) l32 --\u003e|-2| l43((1)) l32 --\u003e|-3| l44((0)) l33 --\u003e|-2| l45((1)) l33 --\u003e|-3| l46((0)) l34 --\u003e|-2| l47((0)) l34 --\u003e|-3| l48((\"-1\")) l41 --\u003e|-2| l51((0)) l41 --\u003e|-3| l52((\"-1\")) style l32 fill:lightblue,color:black style l33 fill:lightblue,color:black style l34 fill:red style l41 fill:red public class CanSum { public static void main(String[] args) { System.out.println(canSum(7, new int[]{2, 3})); // true System.out.println(canSum(7, new int[]{5, 3, 4, 7})); // true System.out.println(canSum(7, new int[]{2, 4})); // false System.out.println(canSum(8, new int[]{2, 3})); // true System.out.println(canSum(300, new int[]{7, 14})); // false } public static boolean canSum(int targetSum, int[] numbers) { if (targetSum == 0) { return true; } if (targetSum == 1 || targetSum \u003c 0) { // targetSum \u003c= 1 return false; } for (int number : numbers) { int remainder = targetSum - number; if (canSum(remainder, numbers)) { return true; } } return false; } } 使用缓存优化 --- title: 组合总和（cansum）使用缓存优化 --- flowchart subgraph tree[递归树] l1((8))--\u003e|-2| l21((6)) l1 --\u003e|-3| l22((5)) l21 --\u003e|-2| l31((4)) l21 --\u003e|-3| l32((3)) l22 --\u003e|-2| l33((3)) l22 --\u003e|-3| l34((2)) l31 --\u003e|-2| l41((2)) l31 --\u003e|-3| l42((1)) l32 --\u003e|-2| l43((1)) l32 --\u003e|-3| l44((0)) l41 --\u003e|-2| l51((0)) l41 --\u003e|-3| l52((\"-1\")) end subgraph cache[缓存] canSum2[\"canSum(2)\"] ~~~ canSum3[\"canSum(3)\"] end canSum2 -.-\u003e|使用缓存| l34 canSum3 -.-\u003e|使用缓存| l33 style l32 fill:lightblue,color:black style l33 fill:lightblue,color:black style l34 fill:red style l41 fill:red import java.util.HashMap; import java.util.Map; public class CanSum { public static void main(String[] args) { System.out.println(canSum(7, new int[]{2, 3})); // true System.out.println(canSum(7, new int[]{5, 3, 4, 7})); // true System.out.println(canSum(7, new int[]{2, 4})); // false System.out.println(canSum(8, new int[]{2, 3})); // true System.out.println(canSum(300, new int[]{7, 14})); // false } public static boolean canSum(int targetSum, int[] numbers) { return canSum(targetSum, numbers, new HashMap\u003c\u003e()); } private static boolean canSum(int targetSum, int[] numbers, Map memo) { if (memo.containsKey(targetSum)) { return memo.get(targetSum); } if (targetSum == 0) { return true; } if (targetSum == 1 || targetSum \u003c 0) { // targetSum \u003c= 1 return false; } for (int number : numbers) { int remainder = targetSum - number; if (canSum(remainder, numbers, memo)) { memo.put(targetSum, true); return true; } } memo.put(targetSum, false); return false; } } 组合总和（howSum） 组合总和（bestSum） ",
  "wordCount" : "1202",
  "inLanguage": "en",
  "datePublished": "2024-06-16T11:35:47+08:00",
  "dateModified": "2024-06-16T11:35:47+08:00",
  "author":{
    "@type": "Person",
    "name": "Signal Yu"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/algorithms/2-dynamic-programming/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Signal's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://signalyu.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://signalyu.github.io/" accesskey="h" title="Signal&#39;s Blog (Alt + H)">
                <img src="https://signalyu.github.io/apple-touch-icon.png" alt="" aria-label="logo"
                    height="40">Signal&#39;s Blog</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://signalyu.github.io/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://signalyu.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://signalyu.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://signalyu.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://signalyu.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      数据结构与算法：动态规划
    </h1>
    <div class="post-meta"><span title='2024-06-16 11:35:47 +0800 HKT'>Jun 16 2024</span>&nbsp;·&nbsp;Signal Yu

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e7%9b%b8%e5%85%b3%e6%a6%82%e5%bf%b5" aria-label="动态规划相关概念">动态规划相关概念</a></li>
                <li>
                    <a href="#%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e4%be%8b%e9%a2%98" aria-label="动态规划例题">动态规划例题</a><ul>
                        
                <li>
                    <a href="#%e6%96%90%e6%b3%a2%e9%82%a3%e5%a5%91%e6%95%b0%e5%88%97" aria-label="斐波那契数列">斐波那契数列</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95%e4%b8%80%e6%9a%b4%e5%8a%9b%e9%80%92%e5%bd%92" aria-label="解法一：暴力递归">解法一：暴力递归</a></li>
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95%e4%ba%8c%e9%80%92%e5%bd%92--%e7%bc%93%e5%ad%98" aria-label="解法二：递归 &#43; 缓存">解法二：递归 + 缓存</a></li>
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95%e4%b8%89%e8%bf%ad%e4%bb%a3" aria-label="解法三：迭代">解法三：迭代</a></li>
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95%e5%9b%9b%e8%bf%ad%e4%bb%a3--%e4%b8%ad%e9%97%b4%e5%8f%98%e9%87%8f" aria-label="解法四：迭代 &#43; 中间变量">解法四：迭代 + 中间变量</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%b8%8d%e5%90%8c%e8%b7%af%e5%be%84" aria-label="不同路径">不同路径</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95%e4%b8%80%e6%9a%b4%e5%8a%9b%e9%80%92%e5%bd%92-1" aria-label="解法一：暴力递归">解法一：暴力递归</a></li>
                <li>
                    <a href="#%e8%a7%a3%e6%b3%95%e4%ba%8c%e9%80%92%e5%bd%92--%e7%bc%93%e5%ad%98-1" aria-label="解法二：递归 &#43; 缓存">解法二：递归 + 缓存</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e6%96%b9%e6%b3%95%e8%ae%ba%e5%85%88%e9%80%92%e5%bd%92%e5%86%8d%e4%bc%98%e5%8c%96" aria-label="动态规划方法论（先递归再优化）">动态规划方法论（先递归再优化）</a></li>
                <li>
                    <a href="#%e9%a2%98%e7%9b%ae" aria-label="题目">题目</a><ul>
                        
                <li>
                    <a href="#%e7%bb%84%e5%90%88%e6%80%bb%e5%92%8ccansum" aria-label="组合总和（canSum）">组合总和（canSum）</a><ul>
                        
                <li>
                    <a href="#%e6%9a%b4%e5%8a%9b%e9%80%92%e5%bd%92" aria-label="暴力递归">暴力递归</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8%e7%bc%93%e5%ad%98%e4%bc%98%e5%8c%96" aria-label="使用缓存优化">使用缓存优化</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%bb%84%e5%90%88%e6%80%bb%e5%92%8chowsum" aria-label="组合总和（howSum）">组合总和（howSum）</a></li>
                <li>
                    <a href="#%e7%bb%84%e5%90%88%e6%80%bb%e5%92%8cbestsum" aria-label="组合总和（bestSum）">组合总和（bestSum）</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="动态规划相关概念">动态规划相关概念<a hidden class="anchor" aria-hidden="true" href="#动态规划相关概念">#</a></h1>
<ul>
<li>动态规划核心思想：
<ol>
<li><strong>将原问题划分为更简单的子问题，通过子问题的解来构建问题的解</strong>。</li>
<li><strong>Memoization（自上而下法）</strong>：将原问题<strong>递归</strong>地划分为更小的子问题，并在对子问题的结果进行缓存，以避免重复计算。</li>
<li><strong>Tabulation（自下而上法）</strong>：从最小的子问题开始，<strong>迭代</strong>地构建原问题的解。</li>
</ol>
</li>
</ul>
<h1 id="动态规划例题">动态规划例题<a hidden class="anchor" aria-hidden="true" href="#动态规划例题">#</a></h1>
<h2 id="斐波那契数列">斐波那契数列<a hidden class="anchor" aria-hidden="true" href="#斐波那契数列">#</a></h2>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看题目</summary>
        <div>
            
<link rel="stylesheet" href="/css/notice.css">


<div class="notice info">
    <p>斐波那契数（通常用 $F(n)$ 表示）形成的序列称为斐波那契数列。该数列由 $0$ 和 $1$ 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<p>$F(1) = 0，F(2) = 1$</p>
<p>$F(n) = F(n - 1) + F(n - 2)，其中\; n &gt; 2$</p>
<p>给定 $n$ ，请计算 $F(n)$。</p>

</div>
<link rel="stylesheet" href="/css/notice.css">


<div class="notice info">
    <p>示例 1：</p>
<p>输入：$n = 2$</p>
<p>输出：$1$</p>
<p>解释：$F(2) = 1$</p>

</div>
<link rel="stylesheet" href="/css/notice.css">


<div class="notice info">
    <p>示例 2：</p>
<p>输入：$n = 3$</p>
<p>输出：$2$</p>
<p>解释：$F(3) = F(2) + F(1) = 1 + 0 = 1$</p>

</div>
<link rel="stylesheet" href="/css/notice.css">


<div class="notice info">
    <p>示例 3：</p>
<p>输入：$n = 4$</p>
<p>输出：$3$</p>
<p>解释：$F(4) = F(3) + F(2) = 1 + 1 = 2$</p>

</div>
<link rel="stylesheet" href="/css/notice.css">


<div class="notice info">
    提示：$1 \le n \le 30$
</div>

        </div>
    </details>
</div>
<h3 id="解法一暴力递归">解法一：暴力递归<a hidden class="anchor" aria-hidden="true" href="#解法一暴力递归">#</a></h3>
<pre class="mermaid">---
title: 斐波那契：暴力递归
---
flowchart TB
    f6(("fib(6)")) --> f5(("fib(5)"))
    f6 --> f4(("fib(4)"))
    f5 --> f41(("fib(4)"))
    f5 --> f3(("fib(3)"))
    f4 --> f31(("fib(3)"))
    f4 --> f2(("fib(2)"))
    f41 --> f32(("fib(3)"))
    f41 --> f21(("fib(2)"))
    f3 --> f20(("fib(2)"))
    f3 --> f10(("fib(1)"))
    f31 --> f22(("fib(2)"))
    f31 --> f1(("fib(1)"))
    f32 --> f23(("fib(2)"))
    f32 --> f11(("fib(1)"))

    style f5 fill:lightblue,color:black

    style f4 fill:orange,color:black
    style f41 fill:orange,color:black

    style f3 fill:red
    style f31 fill:red
    style f32 fill:red

    style f20 fill:purple
    style f2 fill:purple
    style f21 fill:purple
    style f22 fill:purple
    style f23 fill:purple

    style f1 fill:grey
    style f11 fill:grey
    style f10 fill:grey
</pre>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >public static long fib(int n) {
    if (n == 1) {
        return 0;
    }
    if (n == 2) {
        return 1;
    }
    return fib(n - 1) + fib(n - 2);
}
</code></pre>
    </div>
</div>
<p>如上图所示，暴力递归过程中，只有 $fib(6)$ 和 $fib(5)$ 计算了 1 次，$fib(4)$，$fib(3)$，$fib(2)$，$fib(1)$ 都进行了重复计算。</p>
<h3 id="解法二递归--缓存">解法二：递归 + 缓存<a hidden class="anchor" aria-hidden="true" href="#解法二递归--缓存">#</a></h3>
<p><strong>Memoization（自上而下法）</strong>：在递归求解子问题时，将子问题的结果缓存起来，之后计算相同的子问题时，直接从缓存中获取结果，以避免重复计算。</p>
<figure class="align-center ">
    <img loading="lazy" src="/img/cs/dsa/2-dynamic-programming-1.png#center" width="100%" height="100%"/> <figcaption>
            斐波那契：递归 &#43; 缓存
        </figcaption>
</figure>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.HashMap;
import java.util.Map;

public class Fibonacci {

    // 使用 HashMap 来存储已经计算过的斐波那契数
    private Map&lt;Integer, Long&gt; cache = new HashMap&lt;&gt;();

    public long fib(int n) {
        // 基本情况
        if (n == 1) {
            return 0;
        }
        if (n == 2) {
            return 1;
        }
        
        // 检查缓存中是否已有结果
        if (cache.containsKey(n)) {
            return cache.get(n);
        }

        // 递归计算斐波那契数，并存储结果到缓存中
        long result = fib(n - 1) + fib(n - 2);
        cache.put(n, result);
        
        return result;
    }
}
</code></pre>
    </div>
</div>
<p>上述方法缺陷：当 $n$ 比较大时会导致栈溢出（StackOverflow）。</p>
<h3 id="解法三迭代">解法三：迭代<a hidden class="anchor" aria-hidden="true" href="#解法三迭代">#</a></h3>
<p><strong>Tabulation（自下而上法）</strong>：从最小的子问题 $fib(1)$ 和 $fib(2)$ 入手，迭代地计算出更大子问题的结果。</p>
<figure class="align-center ">
    <img loading="lazy" src="/img/cs/dsa/2-dynamic-programming-2.png#center" width="100%" height="100%"/> <figcaption>
            迭代（自下而上）
        </figcaption>
</figure>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.HashMap;
import java.util.Map;

public class Solution {
    private static Map&lt;Integer, Long&gt; cache = new HashMap&lt;&gt;();

    public static void main(String[] args) {

        System.out.println(fib(1));
        System.out.println(fib(2));
        System.out.println(fib(2000));
    }

    public static long fib(int n) {
        cache.put(1, 0L);
        cache.put(2, 1L);

        for (int i = 3; i $\le$ n; i++) {
            cache.put(i, cache.get(i - 1) + cache.get(i - 2));
        }

        return cache.get(n);
    }
}
</code></pre>
    </div>
</div>
<h3 id="解法四迭代--中间变量">解法四：迭代 + 中间变量<a hidden class="anchor" aria-hidden="true" href="#解法四迭代--中间变量">#</a></h3>
<p>解法三解决了栈溢出问题，其空间复杂度为 $O(n)$，可以进一步优化为 $O(1)$。</p>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >public class Solution {

    public static void main(String[] args) {

        System.out.println(fib(1));
        System.out.println(fib(2));
        System.out.println(fib(6));
    }

    public static long fib(int n) {
        if (n == 1) {
            return 0;
        }

        if (n == 2){
            return 1;
        }

        long prev1 = 0L;  // F(1)
        long prev2 = 1L;  // F(2)
        long current = 0L;

        for (int i = 3; i $\le$ n; i++) {
            current = prev1 + prev2;
            prev1 = prev2;
            prev2 = current;
        }

        return current;
    }
}
</code></pre>
    </div>
</div>
<h2 id="不同路径">不同路径<a hidden class="anchor" aria-hidden="true" href="#不同路径">#</a></h2>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看题目</summary>
        <div>
            
<link rel="stylesheet" href="/css/notice.css">


<div class="notice info">
    <p>一个机器人位于一个 m x n 网格的左上角（如下图所示）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。</p>
<p>问总共有多少条不同的路径？</p>

</div>

<figure class="align-center ">
    <img loading="lazy" src="/img/cs/dsa/2-dynamic-programming-4.png#center" width="100%" height="100%"/> <figcaption>
            走格子示意图
        </figcaption>
</figure>


<link rel="stylesheet" href="/css/notice.css">


<div class="notice info">
    <p>示例 1</p>
<p>输入：m = 3, n = 7</p>
<p>输出：28</p>

</div>

<link rel="stylesheet" href="/css/notice.css">


<div class="notice info">
    <p>示例 2：</p>
<p>输入：m = 3, n = 2</p>
<p>输出：3</p>
<p>解释：</p>
<p>从左上角开始，总共有 3 条路径可以到达右下角。</p>
<ol>
<li>向右 -&gt; 向下 -&gt; 向下</li>
<li>向下 -&gt; 向下 -&gt; 向右</li>
<li>向下 -&gt; 向右 -&gt; 向下</li>
</ol>

</div>

<link rel="stylesheet" href="/css/notice.css">


<div class="notice info">
    <p>示例 3：</p>
<p>输入：m = 7, n = 3</p>
<p>输出：28</p>

</div>

<link rel="stylesheet" href="/css/notice.css">


<div class="notice info">
    <p>示例 4：</p>
<p>输入：m = 3, n = 3</p>
<p>输出：6</p>

</div>

<link rel="stylesheet" href="/css/notice.css">


<div class="notice info">
    <p>$1 \le m, n \le 100$</p>
<p>题目数据保证答案小于等于 $2 * 10^9$</p>

</div>

        </div>
    </details>
</div>
<pre class="mermaid">---
title: 走格子：2 × 3 
---
flowchart
    g23(("2,3")) -->|down| g13(("1,3"))
    g23 -->|right| g22(("2,2"))
    g13 -->|down| g03(("0,3"))
    g13 -->|right| g12(("1,2"))
    g22 -->|down| g121(("1,2"))
    g22 -->|right| g21(("2,1"))
    g12 -->|down| g02(("0,2"))
    g12 -->|right| g11(("1,1"))
    g121 -->|down| g021(("0,2"))
    g121 -->|right| g111(("1,1"))
    g21 -->|down| g1111(("1,1"))
    g21 -->|right| g20(("2,0"))

    style g23 fill:lightgreen,color:black
    style g13 fill:lightgreen,color:black
    style g22 fill:lightgreen,color:black
    style g12 fill:lightgreen,color:black
    style g22 fill:lightgreen,color:black
    style g121 fill:lightgreen,color:black
    style g21 fill:lightgreen,color:black
    style g11 fill:lightgreen,color:black
    style g111 fill:lightgreen,color:black
    style g1111 fill:lightgreen,color:black
</pre>
<figure class="align-center ">
    <img loading="lazy" src="/img/cs/dsa/2-dynamic-programming-3.png#center" width="100%" height="100%"/> <figcaption>
            走格子（$2\times 3$）示意图
        </figcaption>
</figure>

<p>由上图可得出基本情况：当 $n$ 为 $0$ 或者 $m$ 为 $0$ 时，返回 $0$，当 $n = 1$ 并且 $m=1$ 时，返回 $1$.</p>
<h3 id="解法一暴力递归-1">解法一：暴力递归<a hidden class="anchor" aria-hidden="true" href="#解法一暴力递归-1">#</a></h3>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >public static long gridTraveller(int m, int n) {
    if (m == 1 && n == 1) {
        return 1;
    }
    if (m == 0 || n == 0) {
        return 0;
    }
    return gridTraveller(m - 1, n) + gridTraveller(m, n - 1);
}
</code></pre>
    </div>
</div>
<h3 id="解法二递归--缓存-1">解法二：递归 + 缓存<a hidden class="anchor" aria-hidden="true" href="#解法二递归--缓存-1">#</a></h3>
<ul>
<li><code>gridTraveller(m, n) = gridTraveller(n, m)</code></li>
</ul>
<figure class="align-center ">
    <img loading="lazy" src="/img/cs/dsa/2-dynamic-programming-5.png#center" width="100%" height="100%"/> <figcaption>
            暴力递归解法的重复计算
        </figcaption>
</figure>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.HashMap;
import java.util.Map;

public class GridTraveller {

    public static long gridTraveller(int m, int n) {
        return gridTraveller(m, n, new HashMap&lt;&gt;());
    }

    private static long gridTraveller(int m, int n, Map&lt;String, Long&gt; memo) {
        String key = m + "," + n;
        if (memo.containsKey(key)) {
            return memo.get(key);
        }
        if (m == 1 && n == 1) {
            return 1;
        }
        if (m == 0 || n == 0) {
            return 0;
        }
        long result = gridTraveller(m - 1, n, memo) + gridTraveller(m, n - 1, memo);
        memo.put(key, result);
        return result;
    }

    public static void main(String[] args) {
        System.out.println(gridTraveller(3, 3));  // Output: 6
        System.out.println(gridTraveller(18, 18));  // Output: 2333606220
    }
}
</code></pre>
    </div>
</div>
<h1 id="动态规划方法论先递归再优化">动态规划方法论（先递归再优化）<a hidden class="anchor" aria-hidden="true" href="#动态规划方法论先递归再优化">#</a></h1>
<ol>
<li>问题树化</li>
<li>寻找基本情况</li>
<li>暴力递归实现</li>
<li>使用缓存优化</li>
</ol>
<h1 id="题目">题目<a hidden class="anchor" aria-hidden="true" href="#题目">#</a></h1>
<h2 id="组合总和cansum">组合总和（canSum）<a hidden class="anchor" aria-hidden="true" href="#组合总和cansum">#</a></h2>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看题目</summary>
        <div>
            
<link rel="stylesheet" href="/css/notice.css">


<div class="notice info">
    <p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target，判断 target 是否可以从 candidates 中的元素求和得到。</p>
<p>candidates 中的同一个数字可以无限制重复被选取 。</p>

</div>

<link rel="stylesheet" href="/css/notice.css">


<div class="notice info">
    <p>示例 1:</p>
<p>输入：candidates = [2,3,6,7], target = 7</p>
<p>输出：true</p>

</div>

<link rel="stylesheet" href="/css/notice.css">


<div class="notice info">
    <p>示例 2：</p>
<p>输入: candidates = [2,3], target = 8</p>
<p>输出：true</p>

</div>

<link rel="stylesheet" href="/css/notice.css">


<div class="notice info">
    <p>示例 3：</p>
<p>输入: candidates = [2], target = 1</p>
<p>输出：false</p>

</div>

<link rel="stylesheet" href="/css/notice.css">


<div class="notice info">
    <p>提示：</p>
<ul>
<li>1 $\le$ candidates.length $\le$ 30</li>
<li>2 $\le$ candidates[i] $\le$ 40</li>
<li>candidates 的所有元素互不相同</li>
<li>1 $\le$ target $\le$ 40</li>
</ul>
</div>

        </div>
    </details>
</div>
<h3 id="暴力递归">暴力递归<a hidden class="anchor" aria-hidden="true" href="#暴力递归">#</a></h3>
<pre class="mermaid">---
title: 组合总和（cansum）暴力递归
---
flowchart TB
    l1((8))-->|-2| l21((6))
    l1 -->|-3| l22((5))

    l21 -->|-2| l31((4))
    l21 -->|-3| l32((3))
    l22 -->|-2| l33((3))
    l22 -->|-3| l34((2))

    l31 -->|-2| l41((2))
    l31 -->|-3| l42((1))
    l32 -->|-2| l43((1))
    l32 -->|-3| l44((0))
    l33 -->|-2| l45((1))
    l33 -->|-3| l46((0))
    l34 -->|-2| l47((0))
    l34 -->|-3| l48(("-1"))

    l41 -->|-2| l51((0))
    l41 -->|-3| l52(("-1"))

    style l32 fill:lightblue,color:black
    style l33 fill:lightblue,color:black
    
    style l34 fill:red
    style l41 fill:red
</pre>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >public class CanSum {

    public static void main(String[] args) {
        System.out.println(canSum(7, new int[]{2, 3}));  // true
        System.out.println(canSum(7, new int[]{5, 3, 4, 7}));  // true
        System.out.println(canSum(7, new int[]{2, 4}));  // false
        System.out.println(canSum(8, new int[]{2, 3}));  // true
        System.out.println(canSum(300, new int[]{7, 14}));  // false
    }

    public static boolean canSum(int targetSum, int[] numbers) {
        if (targetSum == 0) {
            return true;
        }

        if (targetSum == 1 || targetSum < 0) {  // targetSum <= 1
            return false;
        }

        for (int number : numbers) {
            int remainder = targetSum - number;
            if (canSum(remainder, numbers)) {
                return true;
            }
        }

        return false;
    }
}
</code></pre>
    </div>
</div>
<h3 id="使用缓存优化">使用缓存优化<a hidden class="anchor" aria-hidden="true" href="#使用缓存优化">#</a></h3>
<pre class="mermaid">---
title: 组合总和（cansum）使用缓存优化
---
flowchart
    subgraph tree[递归树]
        l1((8))-->|-2| l21((6))
        l1 -->|-3| l22((5))

        l21 -->|-2| l31((4))
        l21 -->|-3| l32((3))
        l22 -->|-2| l33((3))
        l22 -->|-3| l34((2))

        l31 -->|-2| l41((2))
        l31 -->|-3| l42((1))
        l32 -->|-2| l43((1))
        l32 -->|-3| l44((0))

        l41 -->|-2| l51((0))
        l41 -->|-3| l52(("-1"))

    end

    subgraph cache[缓存]
        canSum2["canSum(2)"] ~~~ canSum3["canSum(3)"]
    end

    canSum2 -.->|使用缓存| l34
    canSum3 -.->|使用缓存| l33

    style l32 fill:lightblue,color:black
    style l33 fill:lightblue,color:black
    
    style l34 fill:red
    style l41 fill:red
</pre>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.HashMap;
import java.util.Map;

public class CanSum {

    public static void main(String[] args) {
        System.out.println(canSum(7, new int[]{2, 3}));  // true
        System.out.println(canSum(7, new int[]{5, 3, 4, 7}));  // true
        System.out.println(canSum(7, new int[]{2, 4}));  // false
        System.out.println(canSum(8, new int[]{2, 3}));  // true
        System.out.println(canSum(300, new int[]{7, 14}));  // false
    }

    public static boolean canSum(int targetSum, int[] numbers) {
        return canSum(targetSum, numbers, new HashMap&lt;&gt;());
    }

    private static boolean canSum(int targetSum, int[] numbers, Map&lt;Integer, Boolean&gt; memo) {
        if (memo.containsKey(targetSum)) {
            return memo.get(targetSum);
        }

        if (targetSum == 0) {
            return true;
        }

        if (targetSum == 1 || targetSum < 0) {  // targetSum <= 1
            return false;
        }


        for (int number : numbers) {
            int remainder = targetSum - number;
            if (canSum(remainder, numbers, memo)) {
                memo.put(targetSum, true);
                return true;
            }
        }

        memo.put(targetSum, false);
        return false;
    }
}
</code></pre>
    </div>
</div>
<h2 id="组合总和howsum">组合总和（howSum）<a hidden class="anchor" aria-hidden="true" href="#组合总和howsum">#</a></h2>
<h2 id="组合总和bestsum">组合总和（bestSum）<a hidden class="anchor" aria-hidden="true" href="#组合总和bestsum">#</a></h2>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://signalyu.github.io/tags/%E5%B7%A5%E7%A8%8B%E4%B8%8E%E6%8A%80%E6%9C%AF/">工程与技术</a></li>
      <li><a href="https://signalyu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/">计算机科学</a></li>
      <li><a href="https://signalyu.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/algorithms/3-recursion/">
    <span class="title">« PREV</span>
    
    <br>
    <span>数据结构与算法：递归</span>
  </a>
  <a class="next" href="https://signalyu.github.io/posts/1-natural-science/math/calculus/4-derivative-and-differential/">
    <span class="title">NEXT »</span>
    
    <br>
    <span>导数与微分</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://signalyu.github.io/">Signal&#39;s Blog</a></span> · 
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>

    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
        mermaid.initialize({
            startOnLoad: true,
            "flowchart": { "htmlLabels": true },
            theme: 'dark',
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
        });
    </script>
    
</body>
</html>
