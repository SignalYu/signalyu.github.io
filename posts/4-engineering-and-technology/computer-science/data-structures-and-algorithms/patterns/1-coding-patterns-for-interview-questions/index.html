<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Coding Patterns for Interview Questions | Signal&#39;s Blog</title>
<meta name="keywords" content="Data Structure &amp; Algorithms">
<meta name="description" content="Simple Two Pointers The Simple Two Pointers technique is commonly used to solve problems involving sorted array, where a set of elements needs to be found that satisfy certain constrains. This approach is efficient in scenarios such as finding a pair that sums to a target or reversing an array or string. In the two simple two pointers technique, two pointers &ndash; typically labeled &ldquo;left&rdquo; and &ldquo;right&rdquo; &ndash; are initialized and move in a specific direction based on the problem&rsquo;s requirements.">
<meta name="author" content="Signal Yu">
<link rel="canonical" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/patterns/1-coding-patterns-for-interview-questions/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5a0ace7f2dc73037e40ceea0eb0d119b5d798dba2da38d9129982a8cf9fa07a5.css" integrity="sha256-WgrOfy3HMDfkDO6g6w0Rm115jboto42RKZgqjPn6B6U=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://signalyu.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://signalyu.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://signalyu.github.io/favicon-32x32">
<link rel="apple-touch-icon" href="https://signalyu.github.io/apple-touch-icon">
<link rel="mask-icon" href="https://signalyu.github.io/favicon.io">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/patterns/1-coding-patterns-for-interview-questions/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css"
    integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"
    integrity="sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd"
    crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js"
    integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk"
    crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: true }
            ],
            
            throwOnError: false,
            strict: false
        });
    });
</script>

  

<meta property="og:title" content="Coding Patterns for Interview Questions" />
<meta property="og:description" content="Simple Two Pointers The Simple Two Pointers technique is commonly used to solve problems involving sorted array, where a set of elements needs to be found that satisfy certain constrains. This approach is efficient in scenarios such as finding a pair that sums to a target or reversing an array or string. In the two simple two pointers technique, two pointers &ndash; typically labeled &ldquo;left&rdquo; and &ldquo;right&rdquo; &ndash; are initialized and move in a specific direction based on the problem&rsquo;s requirements." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/patterns/1-coding-patterns-for-interview-questions/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-02T10:15:04+08:00" />
<meta property="article:modified_time" content="2022-12-02T10:15:04+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Coding Patterns for Interview Questions"/>
<meta name="twitter:description" content="Simple Two Pointers The Simple Two Pointers technique is commonly used to solve problems involving sorted array, where a set of elements needs to be found that satisfy certain constrains. This approach is efficient in scenarios such as finding a pair that sums to a target or reversing an array or string. In the two simple two pointers technique, two pointers &ndash; typically labeled &ldquo;left&rdquo; and &ldquo;right&rdquo; &ndash; are initialized and move in a specific direction based on the problem&rsquo;s requirements."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://signalyu.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Coding Patterns for Interview Questions",
      "item": "https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/patterns/1-coding-patterns-for-interview-questions/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Coding Patterns for Interview Questions",
  "name": "Coding Patterns for Interview Questions",
  "description": "Simple Two Pointers The Simple Two Pointers technique is commonly used to solve problems involving sorted array, where a set of elements needs to be found that satisfy certain constrains. This approach is efficient in scenarios such as finding a pair that sums to a target or reversing an array or string. In the two simple two pointers technique, two pointers \u0026ndash; typically labeled \u0026ldquo;left\u0026rdquo; and \u0026ldquo;right\u0026rdquo; \u0026ndash; are initialized and move in a specific direction based on the problem\u0026rsquo;s requirements.",
  "keywords": [
    "Data Structure \u0026 Algorithms"
  ],
  "articleBody": "Simple Two Pointers The Simple Two Pointers technique is commonly used to solve problems involving sorted array, where a set of elements needs to be found that satisfy certain constrains. This approach is efficient in scenarios such as finding a pair that sums to a target or reversing an array or string. In the two simple two pointers technique, two pointers ‚Äì typically labeled ‚Äúleft‚Äù and ‚Äúright‚Äù ‚Äì are initialized and move in a specific direction based on the problem‚Äôs requirements.\nTwo Sum II - Input Array Is Sorted SHOW PROBLEM Problem Statement\nGiven a 1-indexed array of integers, numbers, sorted in non-decreasing order, find two numbers that add up to a specific target. Let these two numbers be numbers[index1] and numbers[index2], where 1 \u003c= index1 \u003c index2 \u003c= numbers.length.\nReturn the indices of the two numbers, index1 and index2, incremented by one, as an integer array [index1, index2] of length 2.\nThe problem guarantees that there is exactly one solution. You may not use the same element twice. Your solution must use only constant extra space. Example 1:\nInput: numbers = [2,7,11,15], target = 9 Output: [1, 2] Explanation: The sum of 2 and 7 is 9, so index1 = 1, index2 = 2. We return [1, 2]. Example 2:\nInput: numbers = [2,3,4], target = 6 Output: [1, 3] Explanation: The sum of 2 and 4 is 6, so index1 = 1, index2 = 3. We return [1, 3]. Example 3:\nInput: numbers = [-1,0], target = -1 Output: [1, 2] Explanation: The sum of -1 and 0 is -1, so index1 = 1, index2 = 2. We return [1, 2]. Constraints:\n2 \u003c= numbers.length \u003c= 30,000 -1000 \u003c= numbers[i] \u003c= 1000 numbers is sorted in non-decreasing order. -1000 \u003c= target \u003c= 1000 There is exactly one solution for each test case. Go to Leetcode üîó SHOW CODE Java class Solution { public int[] twoSum(int[] numbers, int target) { int left = 0, right = numbers.length - 1; // Iterate while left pointer is before right pointer while (left \u003c right) { int currentSum = numbers[left] + numbers[right]; // Check if the current sum matches the target if (currentSum == target) { break; } // Adjust the pointers to move towards the target sum if (currentSum \u003c target) { left++; // Increase sum by moving left pointer right } else { right--; // Decrease sum by moving right pointer left } } // Reture 1-indexed result return new int[] { left + 1, right + 1 }; } } SHOW NOTES Algorithm Walkthrough\nnums = [1, 2, 3, 4, 5, 8] target = 7 Initialize pointers: left = 0, right = 5 First iteration: currentSum = 1 + 8 = 9 (greater than the target) Decrease the right pointer to 4 Second iteration: currentSum = 1 + 5 = 6 (less than the target) Increase the left pointer to 1 Third iteration: currentSum = 2 + 4 = 6 (equals the target) Return the indices [1, 3]. Visualization\n3Sum SHOW PROBLEM Problem Statement\nGiven an integer array nums, return all unique triplets [nums[i], nums[j], nums[k]] such that:\ni != j, i != k, and j != k nums[i] + nums[j] + nums[k] == 0 The solution set must not contain duplicate triplets.\nExample 1:\nInput: nums = [-1, 0, 1, 2, -1, -4] Output: [[-1, -1, 2], [-1, 0, 1]] Explanation: nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 The distinct triplets are [-1, 0, 1] and [-1, -1, 2].\nNote: The order of the output and the order of the triplets does not matter.\nExample 2:\nInput: nums = [0, 1, 1] Output: [] Explanation: The only possible triplet does not sum up to 0. Example 3:\nInput: nums = [0, 0, 0] Output: [[0, 0, 0]] Explanation: The only possible triplet sums up to 0. Constraints:\n3 \u003c= nums.length \u003c= 3000 10^5 \u003c= nums[i] \u003c= 10^5 Go to Leetcode üîó SHOW CODE Java class Solution { public List",
  "wordCount" : "693",
  "inLanguage": "en",
  "datePublished": "2022-12-02T10:15:04+08:00",
  "dateModified": "2022-12-02T10:15:04+08:00",
  "author":{
    "@type": "Person",
    "name": "Signal Yu"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/patterns/1-coding-patterns-for-interview-questions/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Signal's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://signalyu.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://signalyu.github.io/" accesskey="h" title="Signal&#39;s Blog (Alt + H)">
                <img src="https://signalyu.github.io/apple-touch-icon.png" alt="" aria-label="logo"
                    height="40">Signal&#39;s Blog</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://signalyu.github.io/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://signalyu.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://signalyu.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://signalyu.github.io/">Home</a>&nbsp;¬ª&nbsp;<a href="https://signalyu.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Coding Patterns for Interview Questions
    </h1>
    <div class="post-meta"><span title='2022-12-02 10:15:04 +0800 HKT'>Dec 2 2022</span>&nbsp;¬∑&nbsp;Signal Yu

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#simple-two-pointers" aria-label="Simple Two Pointers">Simple Two Pointers</a><ul>
                        
                <li>
                    <a href="#two-sum-ii---input-array-is-sorted" aria-label="Two Sum II - Input Array Is Sorted">Two Sum II - Input Array Is Sorted</a></li>
                <li>
                    <a href="#3sum" aria-label="3Sum">3Sum</a></li></ul>
                </li>
                <li>
                    <a href="#fast--slow-pointers" aria-label="Fast &amp; Slow Pointers">Fast &amp; Slow Pointers</a><ul>
                        
                <li>
                    <a href="#linked-list-cycle" aria-label="Linked List Cycle">Linked List Cycle</a></li>
                <li>
                    <a href="#middle-of-the-linkedlist" aria-label="Middle of the LinkedList">Middle of the LinkedList</a></li>
                <li>
                    <a href="#remove-nth-node-from-end-of-list" aria-label="Remove Nth Node From End of List">Remove Nth Node From End of List</a></li></ul>
                </li>
                <li>
                    <a href="#sliding-window" aria-label="Sliding Window">Sliding Window</a><ul>
                        
                <li>
                    <a href="#maximum-sum-subarray-of-size-k" aria-label="Maximum Sum Subarray of Size K">Maximum Sum Subarray of Size K</a></li>
                <li>
                    <a href="#longest-substring-with-at-most-k-distinct-characters" aria-label="Longest Substring with At Most K Distinct Characters">Longest Substring with At Most K Distinct Characters</a></li></ul>
                </li>
                <li>
                    <a href="#merge-intervals" aria-label="Merge Intervals">Merge Intervals</a><ul>
                        
                <li>
                    <a href="#merge-intervals-1" aria-label="Merge Intervals">Merge Intervals</a></li>
                <li>
                    <a href="#insert-interval" aria-label="Insert Interval">Insert Interval</a></li>
                <li>
                    <a href="#intervals-intersection" aria-label="Intervals Intersection">Intervals Intersection</a></li></ul>
                </li>
                <li>
                    <a href="#in-place-reversal-of-a-linked-list" aria-label="In-place Reversal of a Linked List">In-place Reversal of a Linked List</a><ul>
                        
                <li>
                    <a href="#reverse-linked-list" aria-label="Reverse Linked List">Reverse Linked List</a></li>
                <li>
                    <a href="#reverse-a-sublist" aria-label="Reverse a Sublist">Reverse a Sublist</a></li>
                <li>
                    <a href="#reverse-nodes-in-k-group" aria-label="Reverse Nodes in k-Group">Reverse Nodes in k-Group</a></li></ul>
                </li>
                <li>
                    <a href="#hash-maps" aria-label="Hash Maps">Hash Maps</a><ul>
                        
                <li>
                    <a href="#first-unique-character-in-a-string" aria-label="First Unique Character in a String">First Unique Character in a String</a></li>
                <li>
                    <a href="#maximum-number-of-balloons" aria-label="Maximum Number of Balloons">Maximum Number of Balloons</a></li>
                <li>
                    <a href="#longest-palindrome" aria-label="Longest Palindrome">Longest Palindrome</a></li></ul>
                </li>
                <li>
                    <a href="#prefix-sum" aria-label="Prefix Sum">Prefix Sum</a><ul>
                        
                <li>
                    <a href="#find-the-middle-index-in-array" aria-label="Find the Middle Index in Array">Find the Middle Index in Array</a></li>
                <li>
                    <a href="#left-and-right-sum-differences" aria-label="Left and Right Sum Differences">Left and Right Sum Differences</a></li>
                <li>
                    <a href="#subarray-sums-divisible-by-k" aria-label="Subarray Sums Divisible by K">Subarray Sums Divisible by K</a></li></ul>
                </li>
                <li>
                    <a href="#monotonic-stack" aria-label="Monotonic Stack">Monotonic Stack</a><ul>
                        
                <li>
                    <a href="#next-greater-element-i" aria-label="Next Greater Element I">Next Greater Element I</a></li></ul>
                </li>
                <li>
                    <a href="#tree-breadth-first-search" aria-label="Tree Breadth First Search">Tree Breadth First Search</a></li>
                <li>
                    <a href="#tree-depth-first-search" aria-label="Tree Depth First Search">Tree Depth First Search</a></li>
                <li>
                    <a href="#cyclic-sort" aria-label="Cyclic Sort">Cyclic Sort</a></li>
                <li>
                    <a href="#matrix-traversal" aria-label="Matrix Traversal">Matrix Traversal</a></li>
                <li>
                    <a href="#subsets" aria-label="Subsets">Subsets</a></li>
                <li>
                    <a href="#modified-binary-tree" aria-label="Modified Binary Tree">Modified Binary Tree</a></li>
                <li>
                    <a href="#bitwise-xor" aria-label="Bitwise XOR">Bitwise XOR</a></li>
                <li>
                    <a href="#greedy-algorithm" aria-label="Greedy Algorithm">Greedy Algorithm</a></li>
                <li>
                    <a href="#dynamic-programming" aria-label="Dynamic Programming">Dynamic Programming</a></li>
                <li>
                    <a href="#backtracking" aria-label="Backtracking">Backtracking</a></li>
                <li>
                    <a href="#union-find" aria-label="Union Find">Union Find</a></li>
                <li>
                    <a href="#topological-sort" aria-label="Topological Sort">Topological Sort</a></li>
                <li>
                    <a href="#ordered-set" aria-label="Ordered Set">Ordered Set</a></li>
                <li>
                    <a href="#trie" aria-label="Trie">Trie</a></li>
                <li>
                    <a href="#top-k-elements" aria-label="Top &lsquo;K&rsquo; Elements">Top &lsquo;K&rsquo; Elements</a></li>
                <li>
                    <a href="#k-way-merge" aria-label="K-way Merge">K-way Merge</a></li>
                <li>
                    <a href="#two-heaps" aria-label="Two Heaps">Two Heaps</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="simple-two-pointers">Simple Two Pointers<a hidden class="anchor" aria-hidden="true" href="#simple-two-pointers">#</a></h1>
<blockquote>
<p>The <strong>Simple Two Pointers</strong> technique is commonly used to solve problems involving <strong>sorted</strong> array, where a set of elements needs to be found that satisfy certain constrains. This approach is efficient in scenarios such as <em><strong>finding a pair that sums to a target or reversing an array or string</strong></em>. In the two simple two pointers technique, two pointers &ndash; typically labeled &ldquo;left&rdquo; and &ldquo;right&rdquo; &ndash; are initialized and move in a specific direction based on the problem&rsquo;s requirements.</p>
</blockquote>
<h2 id="two-sum-ii---input-array-is-sorted">Two Sum II - Input Array Is Sorted<a hidden class="anchor" aria-hidden="true" href="#two-sum-ii---input-array-is-sorted">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement</strong></p>
<p>Given a 1-indexed array of integers, <code>numbers</code>, sorted in non-decreasing order, find two numbers that add up to a specific target. Let these two numbers be <code>numbers[index1]</code> and <code>numbers[index2]</code>, where <code>1 &lt;= index1 &lt; index2 &lt;= numbers.length</code>.</p>
<p>Return the indices of the two numbers, <code>index1</code> and <code>index2</code>, incremented by one, as an integer array <code>[index1, index2]</code> of length 2.</p>
<ul>
<li>The problem guarantees that there is exactly one solution.</li>
<li>You may not use the same element twice.</li>
<li>Your solution must use only constant extra space.</li>
</ul>
<p><strong>Example 1:</strong></p>
<ul>
<li><strong>Input</strong>: <code>numbers = [2,7,11,15], target = 9</code></li>
<li><strong>Output</strong>: <code>[1, 2]</code></li>
<li><strong>Explanation</strong>: The sum of 2 and 7 is 9, so <code>index1 = 1</code>, <code>index2 = 2</code>. We return <code>[1, 2]</code>.</li>
</ul>
<p><strong>Example 2:</strong></p>
<ul>
<li><strong>Input</strong>: <code>numbers = [2,3,4], target = 6</code></li>
<li><strong>Output</strong>: <code>[1, 3]</code></li>
<li><strong>Explanation</strong>: The sum of 2 and 4 is 6, so <code>index1 = 1</code>, <code>index2 = 3</code>. We return <code>[1, 3]</code>.</li>
</ul>
<p><strong>Example 3:</strong></p>
<ul>
<li><strong>Input</strong>: <code>numbers = [-1,0], target = -1</code></li>
<li><strong>Output</strong>: <code>[1, 2]</code></li>
<li><strong>Explanation</strong>: The sum of -1 and 0 is -1, so <code>index1 = 1</code>, <code>index2 = 2</code>. We return <code>[1, 2]</code>.</li>
</ul>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>2 &lt;= numbers.length &lt;= 30,000</code></li>
<li><code>-1000 &lt;= numbers[i] &lt;= 1000</code></li>
<li><code>numbers</code> is sorted in non-decreasing order.</li>
<li><code>-1000 &lt;= target &lt;= 1000</code></li>
<li>There is exactly one solution for each test case.</li>
</ul>
<hr>

</details></p>


<a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted" target="_blank">
Go to Leetcode üîó
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int left = 0, right = numbers.length - 1;

        // Iterate while left pointer is before right pointer
        while (left < right) {
            int currentSum = numbers[left] + numbers[right];

            // Check if the current sum matches the target
            if (currentSum == target) {
                break;
            }

            // Adjust the pointers to move towards the target sum
            if (currentSum < target) { 
                left++; // Increase sum by moving left pointer right
            } else { 
                right--; // Decrease sum by moving right pointer left
            }
        }

        // Reture 1-indexed result
        return new int[] { left + 1, right + 1 }; 
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW NOTES</summary>
  <p><strong>Algorithm Walkthrough</strong></p>
<ul>
<li><code>nums = [1, 2, 3, 4, 5, 8]</code></li>
<li><code>target = 7</code></li>
</ul>
<ol>
<li><strong>Initialize pointers</strong>: <code>left = 0, right = 5</code></li>
<li><strong>First iteration</strong>:
<ul>
<li><code>currentSum = 1 + 8 = 9</code> (greater than the target)</li>
<li>Decrease the <code>right</code> pointer to <code>4</code></li>
</ul>
</li>
<li><strong>Second iteration</strong>:
<ul>
<li><code>currentSum = 1 + 5 = 6</code> (less than the target)</li>
<li>Increase the <code>left</code> pointer to <code>1</code></li>
</ul>
</li>
<li><strong>Third iteration</strong>:
<ul>
<li><code>currentSum = 2 + 4 = 6</code> (equals the target)</li>
<li>Return the indices <code>[1, 3]</code>.</li>
</ul>
</li>
</ol>
<p><strong>Visualization</strong></p>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/1-find-a-pair-sums-to-the-target.png" alt="Two Sum II - Input Array Is Sorted"  />
</p>

</details></p>

<hr>
<h2 id="3sum">3Sum<a hidden class="anchor" aria-hidden="true" href="#3sum">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement</strong></p>
<p>Given an integer array <code>nums</code>, return all unique triplets <code>[nums[i], nums[j], nums[k]]</code> such that:</p>
<ul>
<li><code>i != j</code>, <code>i != k</code>, and <code>j != k</code></li>
<li><code>nums[i] + nums[j] + nums[k] == 0</code></li>
</ul>
<p>The solution set must not contain duplicate triplets.</p>
<hr>
<p><strong>Example 1:</strong></p>
<ul>
<li><strong>Input</strong>: <code>nums = [-1, 0, 1, 2, -1, -4]</code></li>
<li><strong>Output</strong>: <code>[[-1, -1, 2], [-1, 0, 1]]</code></li>
<li><strong>Explanation</strong>:
<ul>
<li><code>nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0</code></li>
<li><code>nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0</code></li>
<li><code>nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0</code></li>
</ul>
</li>
</ul>
<p>The distinct triplets are <code>[-1, 0, 1]</code> and <code>[-1, -1, 2]</code>.</p>
<p>Note: The order of the output and the order of the triplets does not matter.</p>
<p><strong>Example 2:</strong></p>
<ul>
<li><strong>Input</strong>: <code>nums = [0, 1, 1]</code></li>
<li><strong>Output</strong>: <code>[]</code></li>
<li><strong>Explanation</strong>: The only possible triplet does not sum up to 0.</li>
</ul>
<p><strong>Example 3:</strong></p>
<ul>
<li><strong>Input</strong>: <code>nums = [0, 0, 0]</code></li>
<li><strong>Output</strong>: <code>[[0, 0, 0]]</code></li>
<li><strong>Explanation</strong>: The only possible triplet sums up to 0.</li>
</ul>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>3 &lt;= nums.length &lt;= 3000</code></li>
<li><code>10^5 &lt;= nums[i] &lt;= 10^5</code></li>
</ul>
<hr>

</details></p>


<a href="https://leetcode.com/problems/3sum" target="_blank">
Go to Leetcode üîó
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> triplets = new ArrayList&lt;&gt;();

        // Sort the array to enable the two-pointer approach
        Arrays.sort(nums);

        for (int i = 0; i < nums.length - 2; i++) {
            // Skip duplicates for 'i' to ensure unique triplets
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }

            // Find pairs that sum up to the negative of the current number
            findTwoSum(nums, -nums[i], i + 1, nums.length - 1, triplets);
        }

        return triplets;
    }

    private static void findTwoSum(int[] nums, int target, int left, int right, List<List<Integer>> triplets) {
        while (left < right) {
            int currentSum = nums[left] + nums[right];
            if (target == currentSum) {
                triplets.add(Arrays.asList(-target, nums[left], nums[right]));
                left++;
                right--;

                // Skip duplicates for 'left' and 'right' to avoid duplicate triplets
                while (left < right && nums[left] == nums[left - 1]) {
                    left++;
                }
                while (left < right && nums[right] == nums[right + 1]) {
                    right--;
                }
            } else if (currentSum < target) {
                // Move 'left' pointer to the right to increase the sum
                left++;
            } else {
                // Move 'right' pointer to the left to decrease the sum
                right--;
            }
        }
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW NOTES</summary>
  <p><strong>Algorithm Walkthrough:</strong></p>
<ol>
<li><strong>Initialization:</strong> <code>[2, -1, -2, 3, -5]</code></li>
<li><strong>Sort the Array:</strong>
<ul>
<li><strong>Input:</strong> <code>[2, -1, -2, 3, -5]</code></li>
<li><strong>Sorted:</strong> <code>[-5, -2, -1, 2, 3]</code></li>
</ul>
</li>
<li><strong>Iteration:</strong>
<ul>
<li><strong>Iteration 1:</strong>
<ul>
<li>Fix <code>-5</code> (at index 0), left pointer at <code>-2</code> (index 1), right pointer at <code>3</code> (index 4):</li>
<li><strong>Target Sum:</strong> <code>-(-5) = 5</code></li>
<li><strong>Sum =</strong> <code>-2 + 3 = 1</code> (less than targetSum), move left pointer to <code>-1</code> (index 2)</li>
<li><strong>Sum =</strong> <code>-1 + 3 = 2</code> (less than targetSum), move left pointer to <code>2</code> (index 3)</li>
<li><strong>Sum =</strong> <code>2 + 3 = 5</code>, found triplet <code>[-5, 2, 3]</code></li>
<li><strong>Move left pointer to 4</strong> and right pointer to 3 (end of this iteration).</li>
</ul>
</li>
<li><strong>Iteration 2:</strong>
<ul>
<li>Fix <code>-2</code> (at index 1), left pointer at <code>-1</code> (index 2), right pointer at <code>3</code> (index 4):</li>
<li><strong>Target Sum:</strong> <code>-(-2) = 2</code></li>
<li><strong>Sum =</strong> <code>-1 + 3 = 2</code>, found triplet <code>[-2, -1, 3]</code></li>
<li><strong>Move left pointer to 2</strong> and right pointer to 3 (end of this iteration).</li>
</ul>
</li>
<li><strong>Iteration 3:</strong> Fix <code>-1</code> (at index 2), left pointer at <code>2</code> (index 3), right pointer at <code>3</code> (index 4):
<ul>
<li><strong>Target Sum:</strong> <code>-(-1) = 1</code></li>
<li><strong>Sum =</strong> <code>2 + 3 = 5</code> (greater than targetSum), move right pointer to <code>2</code> (end of this iteration).</li>
</ul>
</li>
<li><strong>End of Loop:</strong> All elements are processed.</li>
</ul>
</li>
<li><strong>Result:</strong> <code>[[ -5, 2, 3], [ -2, -1, 3]]</code></li>
</ol>
<hr>
<p><strong>Visulization:</strong></p>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/1-2-3sum.png" alt="3Sum"  />
</p>

</details></p>

<hr>
<h1 id="fast--slow-pointers">Fast &amp; Slow Pointers<a hidden class="anchor" aria-hidden="true" href="#fast--slow-pointers">#</a></h1>
<blockquote>
<p>The <strong>Fast and Slow Pointers</strong> pattern, also known as the <strong>Tortoise and Hare Algorithm</strong>, invloves using two pointers that move at different speeds over an array or linked list. It is commonly used to solve problems related to cycle detection or finding the middle element in linked lists or arrays.</p>
</blockquote>
<h2 id="linked-list-cycle">Linked List Cycle<a hidden class="anchor" aria-hidden="true" href="#linked-list-cycle">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement</strong></p>
<p>Given the head of a singly linked list, write a function to determine whether the list contains a cycle.</p>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/2-linked-list-cycle.webp" alt="Liked List Cycle"  />
</p>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the list is between 0 and 10,000.</li>
<li>Node values are in the range of [-10^5, 10^5].</li>
</ul>

</details></p>


<a href="https://leetcode.com/problems/linked-list-cycle" target="_blank">
Go to Leetcode üîó
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        // Initialize slow and fast pointers at the head of the list
        ListNode slow = head, fast = head;

        // Traverse the list with fast and slow pointers
        while (fast != null && fast.next != null) {
            // Move slow pointer by one step and fast pointer by two steps
            slow = slow.next;
            fast = fast.next.next;

            // If the two pointers meet, a cycle is detected
            if (slow == fast) {
                return true;
            }
        }

        // If fast pointer reaches the end, there's no cycle
        return false;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW NOTES</summary>
  <blockquote>
<p>The fast and slow pointers start from the same point. The fast pointer moves two steps at a time, while the slow pointer moves one step at a time. If the linked list has no cycle, the fast pointer will reach the end before the slow pointer. If the linked list has a cycle, the fast pointer will enter the cycle first, and both pointers will continue moving in the cycle. Eventually, they will meet at some point, indicating the presence of a cycle. There are two possible scenerios when both pointers are in the cycle:</p>
</blockquote>
<ol>
<li>The fast pointer is one step behind the slow pointer.</li>
<li>The fast pointer is two steps behind the slow pointer.</li>
</ol>
<blockquote>
<p>In scenerio 1, after the next move, the two pointers will meet at the same position. This is the condition that confirms the presence of a cycle, as shown in the following illustration.</p>
</blockquote>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/3-linked-list-cycle-2.webp" alt="Linked List Cycle: Slow &amp;amp; Fast Pointer"  />
</p>

</details></p>

<hr>
<h2 id="middle-of-the-linkedlist">Middle of the LinkedList<a hidden class="anchor" aria-hidden="true" href="#middle-of-the-linkedlist">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement</strong></p>
<p>Given the head of a singly linked list, write a method to return the middle node of the linked list.</p>
<p>If the total number of nodes in the list is even, return the second middle node.</p>
<p><strong>Example 1:</strong></p>
<ul>
<li><strong>Input</strong>: 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5 ‚Üí null</li>
<li><strong>Output</strong>: 3</li>
</ul>
<p><strong>Example 2:</strong></p>
<ul>
<li><strong>Input</strong>: 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5 ‚Üí 6 ‚Üí null</li>
<li><strong>Output</strong>: 4</li>
</ul>
<p><strong>Example 3:</strong></p>
<ul>
<li><strong>Input</strong>: 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5 ‚Üí 6 ‚Üí 7 ‚Üí null</li>
<li><strong>Output</strong>: 4</li>
</ul>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the list is between 1 and 100.</li>
<li>Node values are between 1 and 100.</li>
</ul>

</details></p>


<a href="https://leetcode.com/problems/middle-of-the-linked-list" target="_blank">
Go to Leetcode üîó
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode middleNode(ListNode head) {
        // Initialize slow and fast pointers at the head of the list
        ListNode slow = head, fast = head;
        
        while (fast != null && fast.next != null) {
            slow = slow.next;          // Move slow pointer by one step
            fast = fast.next.next;     // Move fast pointer by two steps
        }

        // When fast pointer reaches the end, slow pointer will be at the middle
        return slow;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW NOTES</summary>
  <p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/4-middle-of-linked-list.svg" alt="Middle of Linked List"  />
</p>
<hr>
<p>If the total number of nodes in the list is even, return <strong>the first middle node</strong>, then</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">while</span> (fast <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> fast.<span style="color:#a6e22e">next</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>    fast <span style="color:#f92672">=</span> fast.<span style="color:#a6e22e">next</span>.<span style="color:#a6e22e">next</span>;     <span style="color:#75715e">// Move fast pointer by two steps</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (fast <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    slow <span style="color:#f92672">=</span> slow.<span style="color:#a6e22e">next</span>;          <span style="color:#75715e">// Move slow pointer by one step</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
</details></p>

<hr>
<h2 id="remove-nth-node-from-end-of-list">Remove Nth Node From End of List<a hidden class="anchor" aria-hidden="true" href="#remove-nth-node-from-end-of-list">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement</strong></p>
<p>Given the head of a singly linked list, remove the nth node from the end of the list and return the head of the updated list.</p>
<p><strong>Example 1:</strong></p>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/5-remove-nth-node-from-end-of-list.jpg" alt="Remove Nth Node From End of List"  />
</p>
<ul>
<li><strong>Input</strong>: head = [1, 2, 3, 4, 5], n = 2</li>
<li><strong>Output</strong>: [1, 2, 3, 5]</li>
</ul>
<p><strong>Example 2:</strong></p>
<ul>
<li><strong>Input</strong>: head = [1], n = 1</li>
<li><strong>Output</strong>: []</li>
</ul>
<p><strong>Example 3:</strong></p>
<ul>
<li><strong>Input</strong>: head = [1, 2], n = 1</li>
<li><strong>Output</strong>: [1]</li>
</ul>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the list is between 1 and 10^5.</li>
<li>1 &lt;= n &lt;= the number of nodes in the list.</li>
</ul>

</details></p>


<a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list" target="_blank">
Go to Leetcode üîó
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // Create a dummy node to handle edge cases (e.g., removing the head)
        ListNode dummy = new ListNode(0);
        dummy.next = head;

        // Initialize slow and fast pointers at the dummy node
        ListNode slow = dummy, fast = dummy;

        // Move the fast pointer n+1 steps ahead from the dummy node
        for (int i = 0; i <= n; i++) {
            fast = fast.next;
        }

        // Move both slow and fast pointers one step at a time until fast reaches the
        // end
        while (fast != null) {
            slow = slow.next;
            fast = fast.next;
        }

        // Remove the nth node from the end by skipping it
        slow.next = slow.next.next;

        // Return the updated head
        return dummy.next;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW NOTES</summary>
  <blockquote>
<p>The goal is to remove the nth node from the end of the list. The first step in solving this problem is to determine the position of the nth node from the end. This can be achieved using the <strong>slow and fast pointers</strong> techique. Initially, two pointer, <code>slow</code> and <code>fast</code>, are both set to the head of the list. The <code>fast</code> pointer is then moved <code>n</code> steps ahead from the head node.</p>
</blockquote>
<blockquote>
<p>Once the <code>fast</code> pointer is <code>n</code> steps ahead, both the <code>slow</code> and <code>fast</code> pointers move one step at a time simultaneously. When the <code>fast</code> pointer reaches the end of the list, the <code>slow</code> pointer will be positioned at the nth node from the end. Since the task is to remove this node, the node before it must be idetified.</p>
</blockquote>
<blockquote>
<p>However, handling the edge case where the node to be removed is the head node requires special attention. To address this issue, a <strong>dummy node</strong> is introduced. The dummy node points to the head of the list, ensuring that there is always a valid node before the one to be deleted, even if the head node itself is the target.</p>
</blockquote>
<blockquote>
<p>To find the node just before the nth node from the end, the <code>fast</code> pointer is moved <code>n+1</code> steps ahead from the dummy node. This places the <code>fast</code> pointer <code>n+1</code> steps ahead of the <code>slow</code> pointer. Both pointers are then moved one step at a time until the fast pointer reaches the end of the list. At this point, the <code>slow</code> pointer will be positioned just before the nth node from the end.</p>
</blockquote>
<blockquote>
<p>The removal of the nth node is accomplished by updating the <code>slow</code> pointer&rsquo;s next reference <code>slow.next = slow.next.next;</code>. When the node to be removed is the head, the <code>slow</code> pointer remains at the dummy node without moving. After executing <code>slow.next = slow.next.next;</code>, the node after the dummy node becomes the new head of the list.</p>
</blockquote>
<hr>
<p><strong>Illustration</strong></p>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/6-remove-nth-node-from-end-of-list.png" alt="Remove Nth Node From End of List"  />
</p>
<hr>
<p><strong>Illustration: Remove Head Node</strong></p>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/7-remove-head-node-from-end-of-list.png" alt="Remove Nth Node From End of List: Remove Head Node"  />
</p>

</details></p>

<hr>
<h1 id="sliding-window">Sliding Window<a hidden class="anchor" aria-hidden="true" href="#sliding-window">#</a></h1>
<blockquote>
<p>The <strong>Sliding Window Pattern</strong> is a technique used to solve problems involving arrays or sequences when computing something over a <em><strong>continguous subarray or subsequence</strong></em> is required. There are two types of sliding window: fixed-size and dynamic. The fixed-size window involves calculating something over a contiguous subarray of a given size, while the dynamic window adjusts its size based on specific constraints to handle problems over a contiguous subarray or subsequence. The key to solving sliding window problems is <em><strong>determining when to shrink the window size</strong></em>.</p>
</blockquote>
<h2 id="maximum-sum-subarray-of-size-k">Maximum Sum Subarray of Size K<a hidden class="anchor" aria-hidden="true" href="#maximum-sum-subarray-of-size-k">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement</strong></p>
<p>Given an array of positive numbers and a positive integer <code>k</code>, find the maximum sum of any contiguous subarray of size <code>k</code>.</p>
<hr>
<p><strong>Example 1:</strong></p>
<ul>
<li>
<p><strong>Input:</strong><br>
<code>arr = [2, 1, 5, 1, 3, 2]</code>, <code>k = 3</code></p>
</li>
<li>
<p><strong>Output:</strong><br>
<code>9</code></p>
</li>
<li>
<p><strong>Explanation:</strong><br>
The subarray with the maximum sum is <code>[5, 1, 3]</code>, which has a sum of 9.</p>
</li>
</ul>
<p><strong>Example 2:</strong></p>
<ul>
<li>
<p><strong>Input:</strong><br>
<code>arr = [2, 3, 4, 1, 5]</code>, <code>k = 2</code></p>
</li>
<li>
<p><strong>Output:</strong><br>
<code>7</code></p>
</li>
<li>
<p><strong>Explanation:</strong><br>
The subarray with the maximum sum is <code>[3, 4]</code>, which has a sum of 7.</p>
</li>
</ul>
<hr>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >public class Solution {
    public int findMaxSumSubArray(int k, int[] arr) {
        int windowStart = 0;
        int windowSum = 0, maxSum = Integer.MIN_VALUE;
        for (int windowEnd = 0; windowEnd < arr.length; windowEnd++) {
            windowSum += arr[windowEnd]; // Update the window sum

            // Iterate the array to expand the window
            if (windowEnd >= k - 1) {
                maxSum = Math.max(windowSum, maxSum); // Update the maximum sum
                windowSum -= arr[windowStart]; // Remove the element going out of the window
                windowStart++; // Shink the window
            }
        }

        return maxSum;
    }

    public static void main(String[] args) {
        Solution sol = new Solution();
        System.out.println("Maximum sum of a subarray of size K: "
                + sol.findMaxSumSubArray(3, new int[]{2, 1, 5, 1, 3, 2}));
        System.out.println("Maximum sum of a subarray of size K: "
                + sol.findMaxSumSubArray(2, new int[]{2, 3, 4, 1, 5}));
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW OUTPUT</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Output</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-bash" data-lang="bash" >Maximum sum of a subarray of size K: 9
Maximum sum of a subarray of size K: 7
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW NOTES</summary>
  <p><strong>Algorithm Walkthrough</strong></p>
<ul>
<li><code>arr = [2, 1, 5, 1, 3, 2]</code></li>
<li><code>k = 3</code></li>
</ul>
<ol>
<li><strong>Initialization:</strong>
<ul>
<li><code>windowSum = 0</code></li>
<li><code>maxSum = 0</code></li>
<li><code>windowStart = 0</code></li>
</ul>
</li>
<li><strong>Iteration:</strong>
<ul>
<li><strong>windowEnd = 0</strong>: Add <code>arr[0]</code> (2) to <code>windowSum</code>: <code>windowSum = 2</code></li>
<li><strong>windowEnd = 1</strong>: Add <code>arr[1]</code> (1) to <code>windowSum</code>: <code>windowSum = 3</code></li>
<li><strong>windowEnd = 2</strong>:  Add <code>arr[2]</code> (5) to <code>windowSum</code>: <code>windowSum = 8</code>
<ul>
<li>Since <code>windowEnd &gt;= k - 1</code>:</li>
<li>Update <code>maxSum = Math.max(0, 8) = 8</code></li>
<li>Subtract <code>arr[0] = 2</code> from <code>windowSum</code>: <code>windowSum = 6</code></li>
<li>Increment <code>windowStart</code>: <code>windowStart = 1</code></li>
</ul>
</li>
<li><strong>windowEnd = 3</strong>: Add <code>arr[3]</code> (1) to <code>windowSum</code>: <code>windowSum = 7</code>
<ul>
<li>Since <code>windowEnd &gt;= k - 1</code>:</li>
<li>Update <code>maxSum = Math.max(8, 7) = 8</code></li>
<li>Subtract <code>arr[1] = 1</code> from <code>windowSum</code>: <code>windowSum = 6</code></li>
<li>Increment <code>windowStart</code>: <code>windowStart = 2</code></li>
</ul>
</li>
<li><strong>windowEnd = 4</strong>: Add <code>arr[4]</code> (3) to <code>windowSum</code>: <code>windowSum = 9</code>
<ul>
<li>Since <code>windowEnd &gt;= k - 1</code>:</li>
<li>Update <code>maxSum = Math.max(8, 9) = 9</code></li>
<li>Subtract <code>arr[2] = 5</code> from <code>windowSum</code>: <code>windowSum = 4</code></li>
<li>Increment <code>windowStart</code>: <code>windowStart = 3</code></li>
</ul>
</li>
<li><strong>windowEnd = 5</strong>: Add <code>arr[5]</code> (2) to <code>windowSum</code>: <code>windowSum = 6</code>
<ul>
<li>Since <code>windowEnd &gt;= k - 1</code>:</li>
<li>Update <code>maxSum = Math.max(9, 6) = 9</code></li>
<li>Subtract <code>arr[3] = 1</code> from <code>windowSum</code>: <code>windowSum = 5</code></li>
<li>Increment <code>windowStart</code>: <code>windowStart = 4</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>Result:</strong> The final <code>maxSum</code> is 9, which is the maximum sum of any subarray of size <code>k = 3</code>.</li>
</ol>
<hr>
<p><strong>Visualization</strong></p>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/8-maximum-sum-subarray-of-size-k.webp" alt="Maximum Sum Subarray of Size K"  />
</p>

</details></p>

<hr>
<h2 id="longest-substring-with-at-most-k-distinct-characters">Longest Substring with At Most K Distinct Characters<a hidden class="anchor" aria-hidden="true" href="#longest-substring-with-at-most-k-distinct-characters">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement</strong></p>
<p>Given a string, find the length of the longest substring that contains no more than <code>K</code> distinct characters.</p>
<p>It is guaranteed that <code>K</code> will be less than or equal to the length of the given string.</p>
<hr>
<p><strong>Example 1:</strong></p>
<ul>
<li><strong>Input:</strong> <code>String = &quot;araaci&quot;</code>, <code>K = 2</code></li>
<li><strong>Output:</strong> <code>4</code></li>
<li><strong>Explanation:</strong> The longest substring with no more than 2 distinct characters is <code>&quot;araa&quot;</code>.</li>
</ul>
<p><strong>Example 2:</strong></p>
<ul>
<li><strong>Input:</strong> <code>String = &quot;araaci&quot;</code>, <code>K = 1</code></li>
<li><strong>Output:</strong> <code>2</code></li>
<li><strong>Explanation:</strong> The longest substring with no more than 1 distinct character is <code>&quot;aa&quot;</code>.</li>
</ul>
<p><strong>Example 3:</strong></p>
<ul>
<li><strong>Input:</strong> <code>String = &quot;cbbebi&quot;</code>, <code>K = 3</code></li>
<li><strong>Output:</strong> <code>5</code></li>
<li><strong>Explanation:</strong> The longest substrings with no more than 3 distinct characters are <code>&quot;cbbeb&quot;</code> and <code>&quot;bbebi&quot;</code>.</li>
</ul>
<hr>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= str.length &lt;= 50,000</code></li>
<li><code>0 &lt;= K &lt;= 50</code></li>
</ul>
<hr>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.HashMap;
import java.util.Map;

class Solution {
    public int findLength(String str, int k) {
        Map&lt;Character, Integer&gt; charFrequencyMap = new HashMap&lt;&gt;();
        int windowStart = 0;
        int maxLength = 0;

        // Iterate the char sequence to expand the window
        for (int windowEnd = 0; windowEnd < str.length(); windowEnd++) {
            char endChar = str.charAt(windowEnd);
            charFrequencyMap.put(endChar, charFrequencyMap.getOrDefault(endChar, 0) + 1);

            // Shrink the window if there are more than 'k' distinct characters
            while (charFrequencyMap.size() > k) {
                char startChar = str.charAt(windowStart);
                charFrequencyMap.put(startChar, charFrequencyMap.get(startChar) - 1);
                if (charFrequencyMap.get(startChar) == 0) {
                    charFrequencyMap.remove(startChar);
                }
                windowStart++; // Shrink the window
            }

            // Update the maximum length of the valid substring found
            maxLength = Math.max(maxLength, windowEnd - windowStart + 1);
        }

        return maxLength;
    }

    public static void main(String[] args) {
        Solution sol = new Solution();
        System.out.println("Length of the longest substring: "
                + sol.findLength("araaci", 2));
        System.out.println("Length of the longest substring: "
                + sol.findLength("araaci", 1));
        System.out.println("Length of the longest substring: "
                + sol.findLength("cbbebi", 3));
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW NOTES</summary>
  <p><strong>Algorithm Walkthrough:</strong></p>
<ul>
<li><code>str = &quot;araaci&quot;</code></li>
<li><code>K = 2</code></li>
</ul>
<ol>
<li><strong>Initialize:</strong> <code>windowStart = 0</code>, <code>windowEnd = 0</code></li>
<li><strong>Iteration:</strong>
<ul>
<li><strong>windowEnd = 0</strong>
<ul>
<li>Add <code>'a'</code> to the hash map: <code>{'a': 1}</code></li>
<li>Maximum length = <code>1</code></li>
</ul>
</li>
<li><strong>windowEnd = 1</strong>
<ul>
<li>Add <code>'r'</code> to the hash map: <code>{'a': 1, 'r': 1}</code></li>
<li>Maximum length = <code>2</code></li>
</ul>
</li>
<li><strong>windowEnd = 2</strong>
<ul>
<li>Add <code>'a'</code> to the hash map: <code>{'a': 2, 'r': 1}</code></li>
<li>Maximum length = <code>3</code></li>
</ul>
</li>
<li><strong>windowEnd = 3</strong>
<ul>
<li>Add <code>'a'</code> to the hash map: <code>{'a': 3, 'r': 1}</code></li>
<li>Maximum length = <code>4</code></li>
</ul>
</li>
<li><strong>windowEnd = 4</strong>
<ul>
<li>Add <code>'c'</code> to the hash map: <code>{'a': 3, 'r': 1, 'c': 1}</code></li>
<li>Since the hash map has more than <code>K = 2</code> distinct characters, shrink the window from the left:</li>
<li>Remove one <code>'a'</code>: <code>{'a': 2, 'r': 1, 'c': 1}</code></li>
<li>Move <code>windowStart = 1</code></li>
<li>Remove one <code>'r'</code>: <code>{'a': 2, 'c': 1}</code></li>
<li>Move <code>windowStart = 2</code></li>
<li>Maximum length = <code>4</code></li>
</ul>
</li>
<li><strong>windowEnd = 5</strong>
<ul>
<li>Add <code>'i'</code> to the hash map: <code>{'a': 2, 'c': 1, 'i': 1}</code></li>
<li>Since the hash map has more than <code>K = 2</code> distinct characters, shrink the window from the left:</li>
<li>Remove one <code>'a'</code>: <code>{'a': 1, 'c': 1, 'i': 1}</code></li>
<li>Move <code>windowStart = 3</code></li>
<li>Remove one <code>'a'</code>: <code>{'c': 1, 'i': 1}</code></li>
<li>Move <code>windowStart = 4</code></li>
<li>Maximum length = <code>4</code></li>
</ul>
</li>
</ul>
</li>
<li>Result: The maximum length of the substring with at most 2 distinct characters is <strong>4</strong>.</li>
</ol>
<hr>
<p><strong>Visulization</strong></p>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/9-logest-substring-with-at-most-k-distinct-characters.png" alt="Longest Substring with At Most K Distinct Characters"  />
</p>

</details></p>

<hr>
<h1 id="merge-intervals">Merge Intervals<a hidden class="anchor" aria-hidden="true" href="#merge-intervals">#</a></h1>
<blockquote>
<p>The <strong>Merge Interval Pattern</strong> is a technique used to solve problems involving a list of intervals, where each interval is represented by a pair $[\text{start}_i, \text{end}_i]$. Common tasks following this pattern include merging overlapping intervals, inserting a new interval into an existing list, or finding the intersection of two interval lists.</p>
</blockquote>
<blockquote>
<p>To solve problems related to the merge interval pattern, the first step is to understand how two disjoint intervals can relate to each other. Given two intervals &ldquo;a&rdquo; and &ldquo;b&rdquo;, there are six possible relationships between them, as illustrated in the following image.</p>
</blockquote>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/11-merge-interval-pattern.png" alt="Merge Interval Pattern"  />
</p>
<blockquote>
<p>Assuming <code>a.start &lt;= b.start</code> (which can be achieved by sorting the intervals based on their starting points), there are only four possible scenatios:</p>
</blockquote>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/12-merge-interval-altb.png" alt="Merge Interval Pattern: a.start &amp;lt;= b.start"  />
</p>
<blockquote>
<p>By observing the above image, for two intervals to overlap, the condition <code>a.start &lt;= b.start &amp;&amp; b.start &lt;= a.end</code> must hold true. In this case, the merged interval becomes $[\text{a.start}, \text{max}\{\text{a.end, b.end}\}]$.</p>
</blockquote>
<h2 id="merge-intervals-1">Merge Intervals<a hidden class="anchor" aria-hidden="true" href="#merge-intervals-1">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement</strong></p>
<p>Given a list of intervals, merge all overlapping intervals to produce a list of mutually exclusive intervals.</p>
<hr>
<p><strong>Example 1:</strong></p>
<ul>
<li><strong>Input</strong>: <code>[[1, 4], [2, 5], [7, 9]]</code></li>
<li><strong>Output</strong>: <code>[[1, 5], [7, 9]]</code></li>
<li><strong>Explanation</strong>: The first two intervals <code>[1, 4]</code> and <code>[2, 5]</code> overlap, so they are merged into one interval <code>[1, 5]</code>.</li>
</ul>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/10-merge-interval.png" alt="Merge Intervals"  />
</p>
<p><strong>Example 2:</strong></p>
<ul>
<li><strong>Input</strong>: <code>[[6, 7], [2, 4], [5, 9]]</code></li>
<li><strong>Output</strong>: <code>[[2, 4], [5, 9]]</code></li>
<li><strong>Explanation</strong>: The intervals <code>[6, 7]</code> and <code>[5, 9]</code> overlap, so they are merged into <code>[5, 9]</code>.</li>
</ul>
<p><strong>Example 3:</strong></p>
<ul>
<li><strong>Input</strong>: <code>[[1, 4], [2, 6], [3, 5]]</code></li>
<li><strong>Output</strong>: <code>[[1, 6]]</code></li>
<li><strong>Explanation</strong>: All the given intervals overlap, so they are merged into one interval <code>[1, 6]</code>.</li>
</ul>
<hr>
<p><strong>Constraints:</strong></p>
<ul>
<li>$1 &lt;= \text{intervals.length} &lt;= 10^4$</li>
<li>$\text{intervals[i].length} == 2$</li>
<li>$0 &lt;= \text{start}_i &lt;= \text{end}_i &lt;= 10^4$</li>
</ul>
<hr>

</details></p>


<a href="https://leetcode.com/problems/merge-intervals" target="_blank">
Go to Leetcode üîó
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int[][] merge(int[][] intervals) {
        // Sort intervals by their start point
        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);

        // List to store merged intervals
        List<int[]> mergedIntervals = new ArrayList&lt;&gt;();

        // Initialize the first interval as the current interval
        mergedIntervals.add(intervals[0]);

        // Iterate through the intervals
        for (int i = 1; i < intervals.length; i++) {
            int[] currentInterval = mergedIntervals.get(mergedIntervals.size() - 1);
            int[] nextInterval = intervals[i];

            // If the next interval overlaps with the current interval
            if (nextInterval[0] <= currentInterval[1]) {
                // Merge by updating the end point of the current interval
                currentInterval[1] = Math.max(currentInterval[1], nextInterval[1]);
            } else {
                // No overlap, add the next interval as a new interval
                mergedIntervals.add(nextInterval);
            }
        }

        // Convert the list to a 2D array and return
        return mergedIntervals.toArray(new int[mergedIntervals.size()][]);
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW NOTES</summary>
  <p><strong>Algorithm Walkthrough</strong></p>
<ul>
<li><strong>Input</strong>: <code>[[1, 4], [2, 5], [7, 9]]</code></li>
</ul>
<ol>
<li>
<p><strong>Sort Intervals</strong>:</p>
<ul>
<li><strong>Original intervals</strong>: <code>[[1, 4], [2, 5], [7, 9]]</code></li>
<li><strong>Sorted intervals</strong>: <code>[[1, 4], [2, 5], [7, 9]]</code> (already sorted)</li>
</ul>
</li>
<li>
<p><strong>Initialize Merged List</strong>:</p>
<ul>
<li><code>mergedIntervals = [[1, 4]]</code></li>
</ul>
</li>
<li>
<p><strong>Iterate Through Intervals</strong>:</p>
<ul>
<li>
<p><strong>First Iteration</strong>:</p>
<ul>
<li><strong>Current interval</strong>: <code>[1, 4]</code></li>
<li><strong>Next interval</strong>: <code>[2, 5]</code></li>
<li><strong>Check overlap</strong>: <code>2 &lt;= 4</code> (True)</li>
<li><strong>Merged intervals</strong>: <code>[[1, 5]]</code></li>
</ul>
</li>
<li>
<p><strong>Second Iteration</strong>:</p>
<ul>
<li><strong>Current interval</strong>: <code>[1, 5]</code></li>
<li><strong>Next interval</strong>: <code>[7, 9]</code></li>
<li><strong>Check overlap</strong>: <code>7 &lt;= 5</code> (False)</li>
<li><strong>Merged intervals</strong>: <code>[[1, 5], [7, 9]]</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Result</strong>:</p>
<ul>
<li><strong>Result</strong>: <code>[[1, 5], [7, 9]]</code></li>
</ul>
</li>
</ol>
<p><strong>Visulization</strong></p>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/13-merge-intervals.png" alt="Merge Intervals"  />
</p>

</details></p>

<hr>
<h2 id="insert-interval">Insert Interval<a hidden class="anchor" aria-hidden="true" href="#insert-interval">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement</strong></p>
<p>Given a list of non-overlapping intervals sorted by their start time, insert a given interval at the correct position and merge all overlapping intervals to produce a list of mutually exclusive intervals.</p>
<p><strong>Example 1:</strong></p>
<ul>
<li><strong>Input</strong>: <code>Intervals = [[1, 3], [5, 7], [8, 12]], New Interval = [4, 6]</code></li>
<li><strong>Output</strong>: <code>[[1, 3], [4, 7], [8, 12]]</code></li>
<li><strong>Explanation</strong>: After inserting <code>[4, 6]</code>, it overlaps with <code>[5, 7]</code>, so they are merged into <code>[4, 7]</code>.</li>
</ul>
<p><strong>Example 2:</strong></p>
<ul>
<li><strong>Input</strong>: <code>Intervals = [[1, 3], [5, 7], [8, 12]], New Interval = [4, 10]</code></li>
<li><strong>Output</strong>: <code>[[1, 3], [4, 12]]</code></li>
<li><strong>Explanation</strong>: After inserting <code>[4, 10]</code>, it overlaps with <code>[5, 7]</code> and <code>[8, 12]</code>, so they are merged into <code>[4, 12]</code>.</li>
</ul>
<p><strong>Example 3:</strong></p>
<ul>
<li><strong>Input</strong>: <code>Intervals = [[2, 3], [5, 7]], New Interval = [1, 4]</code></li>
<li><strong>Output</strong>: <code>[[1, 4], [5, 7]]</code></li>
<li><strong>Explanation</strong>: After inserting <code>[1, 4]</code>, it overlaps with <code>[2, 3]</code>, so they are merged into <code>[1, 4]</code>.</li>
</ul>
<hr>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= intervals.length &lt;= 10^4</code></li>
<li><code>intervals[i].length == 2</code></li>
<li><code>0 &lt;= start_i &lt;= end_i &lt;= 10^5</code></li>
<li><code>intervals</code> is sorted by <code>start_i</code> in ascending order.</li>
<li><code>newInterval.length == 2</code></li>
<li><code>0 &lt;= start &lt;= end &lt;= 10^5</code></li>
</ul>
<hr>

</details></p>


<a href="https://leetcode.com/problems/insert-interval" target="_blank">
Go to Leetcode üîó
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int[][] insert(int[][] intervals, int[] newInterval) {
        List&lt;int[]&gt; mergedIntervals = new ArrayList&lt;&gt;();

        int i = 0;
        // Add all intervals that ends before the new interval starts
        while (i < intervals.length && intervals[i][1] < newInterval[0]) {
            mergedIntervals.add(intervals[i]);
            i++;
        }

        // Merge the overlapping intervals with the new interval
        while (i < intervals.length && intervals[i][0] <= newInterval[1]) {
            newInterval[0] = Math.min(intervals[i][0], newInterval[0]);
            newInterval[1] = Math.max(intervals[i][1], newInterval[1]);
            i++;
        }

        // Add the merged new interval to the result list
        mergedIntervals.add(newInterval);

        // Add all intervals that don't overlap with the new interval to the result list
        while (i < intervals.length) {
            mergedIntervals.add(intervals[i]);
            i++;
        }

        // Convert the list to a 2-D array and return
        return mergedIntervals.toArray(new int[mergedIntervals.size()][]);
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW NOTES</summary>
  <blockquote>
<p>Since the interval list is sorted, the first step is to skip all intervals that satisfy the condition <code>intervals[i].end &lt; newInterval.start</code>. After that, there  are five possible ways the new interval can relate to the next interval in the list (where &ldquo;a&rdquo; represents <code>newInterval</code>, and &ldquo;b&rdquo; represents the next interval in the list), as shown in the following image.</p>
</blockquote>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/14-insert-interval.png" alt="Insert Interval"  />
</p>
<blockquote>
<p>By observing the above image, for two intervals to overlap, the condition <code>interval.start &lt;= newInterval.end</code> must hold true. In this case, the merged interval will be $[\text{min\{a.start, b.start\}}, \text{max\{a.end, b.end\}}]$.</p>
</blockquote>
<p><strong>Algorithm Walkthrough</strong></p>
<ul>
<li><strong>Intervals</strong> = <code>[[1, 3], [5, 7], [8, 12]]</code></li>
<li><strong>New Interval</strong> = <code>[4, 10]</code></li>
</ul>
<ol>
<li><strong>Initialize Merged List</strong>:<br>
<code>mergedIntervals = []</code></li>
<li><strong>Iterate Through Intervals:</strong>
<ol>
<li><strong>Process the first interval [1, 3]</strong>:</li>
</ol>
<ul>
<li>Ends before <code>[4, 10]</code> starts.</li>
<li>Add to <code>mergedIntervals</code>: <code>[[1, 3]]</code></li>
</ul>
<ol start="2">
<li><strong>Process the second interval [5, 7]</strong>:
<ul>
<li>Overlaps with <code>[4, 10]</code>.</li>
<li>No change to the new interval: <code>[4, 10] -&gt; [4, 10]</code></li>
<li>No change to <code>mergedIntervals</code>.</li>
</ul>
</li>
<li><strong>Process the third interval [8, 12]</strong>:
<ul>
<li>Overlaps with <code>[4, 10]</code>.</li>
<li>Adjust new interval: <code>[4, 10] -&gt; [4, 12]</code></li>
<li>Add the merged interval <code>[4, 12]</code> to <code>mergedIntervals</code>: <code>[[1, 3], [4, 12]]</code></li>
</ul>
</li>
</ol>
</li>
<li><strong>No more intervals left to process</strong>.</li>
<li><strong>Final merged intervals</strong>: <code>[[1, 3], [4, 12]]</code></li>
</ol>
<hr>
<p><strong>Visulization</strong></p>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/14-insert-interval-2.png" alt="Insert Interval"  />
</p>

</details></p>

<hr>
<h2 id="intervals-intersection">Intervals Intersection<a hidden class="anchor" aria-hidden="true" href="#intervals-intersection">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement</strong></p>
<p>Given two lists of disjoint intervals, find their intersection. Each list is sorted by the start time of the intervals.</p>
<p><strong>Example 1:</strong></p>
<ul>
<li><strong>Input:</strong> <code>arr1 = [[1, 3], [5, 6], [7, 9]], arr2 = [[2, 3], [5, 7]]</code></li>
<li><strong>Output:</strong> <code>[[2, 3], [5, 6], [7, 7]]</code></li>
<li><strong>Explanation:</strong> The output list contains the common intervals between the two lists.</li>
</ul>
<p>Example 2:</p>
<ul>
<li><strong>Input:</strong> <code>arr1 = [[1, 3], [5, 7], [9, 12]], arr2 = [[5, 10]]</code></li>
<li><strong>Output:</strong> <code>[[5, 7], [9, 10]]</code></li>
<li><strong>Explanation:</strong> The output list contains the common intervals between the two lists.</li>
</ul>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>0 &lt;= arr1.length, arr2.length &lt;= 1000</code></li>
<li><code>arr1.length + arr2.length &gt;= 1</code></li>
<li>$0 \le \text{start}_i &lt; \text{end}_i \le 10^9$</li>
<li>$end_i &lt; \text{start}_{i+1}$ for all intervals in <code>arr1</code></li>
<li>$0 \le \text{start}_j &lt; \text{end}_j \le 10^9$</li>
<li>$end_j &lt; \text{start}_{j+1}$ for all intervals in <code>arr2</code></li>
</ul>
<hr>

</details></p>


<a href="https://leetcode.com/problems/interval-list-intersections" target="_blank">
Go to Leetcode üîó
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>



<button class="tab_btn ">Optimization</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int[][] intervalIntersection(int[][] arr1, int[][] arr2) {
        List<int[]> intersections = new ArrayList&lt;&gt;();
        int i = 0, j = 0;

        // Iterate over both interval lists to find all intersections
        while (i < arr1.length && j < arr2.length) {
            // Check if both intervals are overlapped
            if ((arr1[i][0] >= arr2[j][0] && arr1[i][0] <= arr2[j][1])
                    || (arr2[j][0] >= arr1[i][0] && arr2[j][0] <= arr1[i][1])) {
                
                // Store the intersection part
                intersections.add(new int[]{Math.max(arr1[i][0], arr2[j][0]),
                        Math.min(arr1[i][1], arr2[j][1])});
            }

            // Move the pointer of the interval that ends first
            if (arr1[i][1] < arr2[j][1]) {
                i++;
            } else {
                j++;
            }
        }

        // Return the intersections as a 2D array
        return intersections.toArray(new int[intersections.size()][]);
    }
}
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int[][] intervalIntersection(int[][] arr1, int[][] arr2) {
        List&lt;int[]&gt; intersections = new ArrayList&lt;&gt;();
        int i = 0, j = 0;
        
        // Iterate over both interval lists to find all intersections
        while (i < arr1.length && j < arr2.length) {
            int start = Math.max(arr1[i][0], arr2[j][0]);
            int end = Math.min(arr1[i][1], arr2[j][1]);

            // Add the intersection to the result if valid
            if (start <= end) {
                intersections.add(new int[] { start, end });
            }

            // Move the pointer of the interval that ends first
            if (arr1[i][1] < arr2[j][1]) {
                i++;
            } else {
                j++;
            }
        }

        // Return the result as a 2D array
        return intersections.toArray(new int[intersections.size()][]);
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW NOTES</summary>
  <blockquote>
<p><strong>Two Interval List</strong>: <code>arr1</code> and <code>arr2</code></p>
</blockquote>
<blockquote>
<p><strong>Pointer Initialization</strong>: Initialize two pointers <code>i</code> and <code>j</code>, both set to 0, to track the current positions in <code>arr1</code> and <code>arr2</code>, respectively.</p>
</blockquote>
<blockquote>
<p><strong>Overlapping Check</strong>: For two intervals <code>a</code> and <code>b</code> to overlap, at least one of the following conditions must hold true:</p>
</blockquote>
<ol>
<li><code>a.start &lt;= b.start &amp;&amp; b.start &lt;= a.end</code></li>
<li><code>b.start &lt;= a.start &amp;&amp; a.start &lt;= b.end</code></li>
</ol>
<blockquote>
<p><strong>Interval Calculation</strong>: If a and b overlap (follows overlapping check), the intersection is calculated as:</p>
</blockquote>
<ul>
<li>$[\text{max}\{\text{a.start, b.start}\}, \text{min}\{\text{a.end, b.end}\}]$</li>
</ul>
<blockquote>
<p><strong>Interval Caculation (Optimization)</strong>: Based on the <strong>Overlapping Check</strong> and <strong>Interval Calculation</strong>, the calculation can be optimized as follows:</p>
</blockquote>
<ol>
<li><code>maxStart = max{a.start, b.start}</code></li>
<li><code>minEnd = min{a.end, b.end}</code></li>
<li>An intersection <code>[maxStart, minEnd]</code> exists if <code>maxStart &lt;= minEnd</code></li>
</ol>
<blockquote>
<p><strong>Pointer Movement</strong>: Increment the pointer that ends first. For example, if <code>arr1[i].end &lt; arr2[j].end</code>, increment <code>i</code>; otherwise increment <code>j</code>.</p>
</blockquote>

</details></p>

<hr>
<h1 id="in-place-reversal-of-a-linked-list">In-place Reversal of a Linked List<a hidden class="anchor" aria-hidden="true" href="#in-place-reversal-of-a-linked-list">#</a></h1>
<blockquote>
<p>The <strong>In-place Reversal of a Linked List</strong> pattern is a commonly used approach to solve linked-list-related problems efficiently without extra space. It relies on maintaining three pointers:</p>
</blockquote>
<ol>
<li><code>prev</code>: Points to the previous node. Initially set to <code>null</code> since there is no node before the <code>head</code>.</li>
<li><code>current</code>: Points to the node currently being processed.</li>
<li><code>next</code>: Points to the next node, ensuring the remaining list is not lost during the reversal process.</li>
</ol>
<blockquote>
<p>This pattern typically involves the following three steps:</p>
</blockquote>
<ol>
<li><strong>Initialization</strong>: Set <code>prev = null</code> and <code>current = head</code> to start processing from the head of list.</li>
<li><strong>Iteration</strong>:
<ul>
<li>Save the <code>next</code> node (<code>next = current.next</code>) to keep track of the remaining list.</li>
<li>Reverse the link by updating <code>current.next</code> to point to <code>prev</code>.</li>
<li>Move the <code>prev</code> pointer forward (<code>prev = current</code>).</li>
<li>Move the <code>current</code> pointer forward (<code>current = next</code>);</li>
</ul>
</li>
<li><strong>Termination</strong>: When <code>current</code> becomes <code>null</code>, the <code>prev</code> pointer will point to the new head of the reversed linked list.</li>
</ol>
<hr>
<h2 id="reverse-linked-list">Reverse Linked List<a hidden class="anchor" aria-hidden="true" href="#reverse-linked-list">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement</strong><br>
Given the head of a singly linked list, reverse the list in-place and return the new head of the reversed list.</p>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/15-reverse-linked-list.png" alt="Reverse Linked List"  />
</p>
<hr>
<p><strong>Constraints</strong></p>
<ul>
<li>The number of nodes in the list is in the range: $[0, 5000]$.</li>
<li>Each node‚Äôs value is within the range: $[-5000, 5000]$.</li>
</ul>
<hr>

</details></p>


<a href="https://leetcode.com/problems/reverse-linked-list" target="_blank">
Go to Leetcode üîó
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null; // Tracks the previous node
        ListNode current = head; // Tracks the current node

        // Traverse and reverse the list
        while (current != null) {
            ListNode next = current.next; // Save the next node
            current.next = prev; // Reverse the link
            prev = current; // Move prev forward
            current = next; // Move current forward
        }

        return prev; // New head of the reversed list
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW NOTES</summary>
  <p><strong>Visulization</strong></p>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/16-reverse-linked-list-2.png" alt="Reverse Linked List Illustration"  />
</p>

</details></p>

<hr>
<h2 id="reverse-a-sublist">Reverse a Sublist<a hidden class="anchor" aria-hidden="true" href="#reverse-a-sublist">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p>Given the head of a LinkedList and two positions, <strong>left</strong> and <strong>right</strong>, reverse the portion of the LinkedList from position <strong>left</strong> to position <strong>right</strong>.</p>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/17-reverse-a-sub-list.png" alt="Reverse a Sub List"  />
</p>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the list is <strong>n</strong>.</li>
<li><strong>1 &lt;= n &lt;= 500</strong></li>
<li><strong>-500 &lt;= Node.val &lt;= 500</strong></li>
<li><strong>1 &lt;= left &lt;= right &lt;= n</strong></li>
</ul>

</details></p>


<a href="https://leetcode.com/problems/reverse-linked-list-ii" target="_blank">
Go to Leetcode üîó
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        ListNode prev = null, current = head;
        
        // Skip the first left - 1 node to reach the node at position left
        for (int i = 1; i < left && current != null; i++) {
            prev = current;
            current = current.next;
        }

        // Save the node at position left - 1 to reconnect the reversed sublist
        ListNode lastNodeOfFirstPart = prev;
        // After reversing, the left node will become the last node of the reversed sublist
        ListNode lastNodeOfReversedList = current;

        // Reverse the node from left to right
        ListNode next = null;
        for (int i = 1; i <= right - left + 1 && current != null; i++) {
            next = current.next; // Save the next node
            current.next = prev; // Reverse the link
            prev = current; // Move the 'prev' node forward
            current = next; // Move the 'current' node forward
        }

        // Reconnect the reversed sublist with the rest of the list
        if (lastNodeOfFirstPart != null) {
            // Connect with the new head of the sublist
            lastNodeOfFirstPart.next = prev;
        } else { // left == 1 in this case
            head = prev;
        }

        // Connect the tail of the reversed sublist to the remaining list
        lastNodeOfReversedList.next = current;

        return head;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW NOTES</summary>
  <ol>
<li>Skip the first <code>left - 1</code> nodes to reach the node at position <code>left</code></li>
<li>Save the node at position <code>left - 1</code> to later reconnect it with the reversed sublist.</li>
<li>Save the node at position <code>left</code> before reversing, after reversing, the node will become the last node of the reversed sublist.</li>
<li>Reverse the nodes from position <code>left</code> to <code>right</code></li>
<li>Reconnect the node at position <code>left - 1</code> to the head of the reversed sublist, and connect the node at position <code>right + 1</code> to the tail of the reversed sublist.</li>
</ol>

</details></p>

<hr>
<h2 id="reverse-nodes-in-k-group">Reverse Nodes in k-Group<a hidden class="anchor" aria-hidden="true" href="#reverse-nodes-in-k-group">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement</strong>:</p>
<p>Given the head of a linked list, reverse the nodes of the list in groups of <strong>k</strong> at a time, and return the modified list.</p>
<ul>
<li><strong>k</strong> is a positive integer and is less than or equal to the length of the linked list.</li>
<li>If the number of nodes is not a multiple of <strong>k</strong>, then the remaining nodes at the end should remain as they are (i.e., not reversed).</li>
<li>You are not allowed to alter the values of the nodes in the list; only the nodes themselves may be rearranged.</li>
</ul>
<hr>
<p><strong>Example 1:</strong></p>
<ul>
<li><strong>Input</strong>: head = [1, 2, 3, 4, 5], k = 2</li>
<li><strong>Output</strong>: [2, 1, 4, 3, 5]</li>
</ul>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/18-reverse-nodes-in-k-group-example-1.jpg" alt="Reverse Nodes in k-Group: Example 1"  />
</p>
<p><strong>Example 2:</strong></p>
<ul>
<li><strong>Input</strong>: head = [1, 2, 3, 4, 5], k = 3</li>
<li><strong>Output</strong>: [3, 2, 1, 4, 5]</li>
</ul>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/19-reverse-nodes-in-k-group-example-2.jpg" alt="Reverse Nodes in k-Group: Example 2"  />
</p>
<hr>

</details></p>


<a href="https://leetcode.com/problems/reverse-nodes-in-k-group" target="_blank">
Go to Leetcode üîó
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        // Return the original list if the list is empty or k is 1
        if (head == null || k == 1) {
            return head;
        }

        // Count the total number of the list
        ListNode temp = head;
        int count = 0;
        while (temp != null) {
            count++;
            temp = temp.next;
        }

        ListNode prev = null, current = head, next = null;
        while (current != null && count >= k) {
            ListNode lastNodeOfPrevGroup = prev;
            // After reversing, the current node will become the last node of the reversed list
            ListNode lastNodeOfReversedList = current;

            // Reverse the list in groups of size k
            for (int i = 0; i < k; i++) {
                next = current.next;
                current.next = prev;
                prev = current;
                current = next;
                count--;
            }

            // Connect the last node of the reversed sublist to the start node of the
            // remaining list
            lastNodeOfReversedList.next = current;

            // Connect with the previous group
            if (lastNodeOfPrevGroup != null) {
                // After reversing, the prev node is the head node of the sublist
                lastNodeOfPrevGroup.next = prev;
            } else {
                // When previous group is null, the prev node becomes the head of the original list
                head = prev;
            }

            // Break the loop when current is null or count is less than k
            if (current == null || count < k) {
                break;
            }

            // Update the prev node for next iteration
            prev = lastNodeOfReversedList;
        }

        return head;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW NOTES</summary>
  <p>The first step to solve this problem is to track the last node of the previous group and the last node of the reversed sublist. When the previous group is <code>null</code>, the head of the reversed sublist becomes the new head of the original list.</p>
<p>Before reversing, the <code>current</code> node points to the head of the sublist. After reversing, the head of the sublist becomes the last node of the reversed segment. Therefore, the last node of the reversed list can be tracked by setting <code>lastNodeOfReversedList = current</code>. To track the last node of the previous group, simply setting <code>lastNodeOfPreviousGroup = prev</code>.</p>
<p>After the reversal, the <code>prev</code> node will point to the head of the reversed sublist, and the <code>current</code> node (if it&rsquo;s not <code>null</code>) will point to the head of the next sublist. To maintain the list structure, There are two key steps need to do, the first step is connecting the last node of the previous group to the head (<code>prev</code> after reversal) of the reversed sublist, the second step is connecting the last node of the reversed sublist to the remaining node (if any).</p>
<p>Finally, update the <code>prev</code> node to be the last node of the reversed sublist, preparing it for the next iteration.</p>

</details></p>

<hr>
<h1 id="hash-maps">Hash Maps<a hidden class="anchor" aria-hidden="true" href="#hash-maps">#</a></h1>
<figure class="align-center ">
    <img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/20-hash-map-data-structure.svg#center" width="100%" height="100%"/> <figcaption>
            Hash Map Data Structure
        </figcaption>
</figure>

<blockquote>
<p>A <strong>Hash Map</strong> is a data structure that stores key-value pairs, enabling efficient <em>lookup</em>, <em>insertion</em>, and <em>deletion</em> operations. Under most conditions, it provides <strong>constant time complexity (O(1))</strong> for these operations. The <strong>Hash Map Pattern</strong> takes advantage of the hash map&rsquo;s efficiency to store and retrive data quickly. It is commonly used to solve problems involving the <strong>calculation of element frequencies in a sequency or array</strong>.</p>
</blockquote>
<hr>
<h2 id="first-unique-character-in-a-string">First Unique Character in a String<a hidden class="anchor" aria-hidden="true" href="#first-unique-character-in-a-string">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement</strong></p>
<p>Given a string, find the position of the first character that appears only once. If no such character exists, return <code>-1</code>.</p>
<hr>
<p><strong>Example 1:</strong></p>
<ul>
<li><strong>Input</strong>: <code>&quot;apple&quot;</code></li>
<li><strong>Expected Output</strong>: <code>0</code></li>
<li><strong>Justification</strong>: The first character <code>'a'</code> appears only once in the string, and it is located at index 0.</li>
</ul>
<p><strong>Example 2:</strong></p>
<ul>
<li><strong>Input</strong>: <code>&quot;abcab&quot;</code></li>
<li><strong>Expected Output</strong>: <code>2</code></li>
<li><strong>Justification</strong>: The first character that appears only once is <code>'c'</code>, which is located at index 2.</li>
</ul>
<p><strong>Example 3:</strong></p>
<ul>
<li><strong>Input</strong>: <code>&quot;abab&quot;</code></li>
<li><strong>Expected Output</strong>: <code>-1</code></li>
<li><strong>Justification</strong>: All characters in the string appear more than once, so there is no character that appears only once.</li>
</ul>
<hr>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 10^5</code></li>
<li><code>s</code> consists of only lowercase English letters.</li>
</ul>
<hr>

</details></p>


<a href="https://leetcode.com/problems/first-unique-character-in-a-string" target="_blank">
Go to Leetcode üîó
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int firstUniqChar(String s) {
        // Use a HashMap to store the frequency of each character
        Map&lt;Character, Integer&gt; charFrequencyMap = new HashMap&lt;&gt;();

        // Populate the map with the frequency of each character
        for (char c : s.toCharArray()) {
            charFrequencyMap.put(c, charFrequencyMap.getOrDefault(c, 0) + 1);
        }

        // Iterate over the string to find the index of the first unique character
        for (int i = 0; i < s.length(); i++) {
            if (charFrequencyMap.get(s.charAt(i)) == 1) {
                return i; // Return the index of the first unique character
            }
        }

        // No unique character found, return -1
        return -1;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW NOTES</summary>
  <p><strong>Virsulization:</strong></p>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/21-first-unique-character.png" alt="First Unique Character in a String"  />
</p>

</details></p>

<hr>
<h2 id="maximum-number-of-balloons">Maximum Number of Balloons<a hidden class="anchor" aria-hidden="true" href="#maximum-number-of-balloons">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement</strong></p>
<p>Given a string, determine the maximum number of times the word &ldquo;balloon&rdquo; can be formed using the characters from the string. Each character in the string can be used only once.</p>
<hr>
<p><strong>Example 1:</strong></p>
<ul>
<li><strong>Input</strong>: <code>&quot;balloonballoon&quot;</code></li>
<li><strong>Expected Output</strong>: <code>2</code></li>
<li><strong>Justification</strong>: The word &ldquo;balloon&rdquo; can be formed twice from the given string.</li>
</ul>
<p><strong>Example 2:</strong></p>
<ul>
<li><strong>Input</strong>: <code>&quot;bbaall&quot;</code></li>
<li><strong>Expected Output</strong>: <code>0</code></li>
<li><strong>Justification</strong>: The word &ldquo;balloon&rdquo; cannot be formed because the character &lsquo;o&rsquo; is missing twice.</li>
</ul>
<p><strong>Example 3:</strong></p>
<ul>
<li><strong>Input</strong>: <code>&quot;balloonballoooon&quot;</code></li>
<li><strong>Expected Output</strong>: <code>2</code></li>
<li><strong>Justification</strong>: The word &ldquo;balloon&rdquo; can be formed twice, even though there are extra &lsquo;o&rsquo; characters.</li>
</ul>
<hr>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= text.length &lt;= 10^4</code></li>
<li><code>text</code> consists of lowercase English letters only.</li>
</ul>
<hr>

</details></p>


<a href="https://leetcode.com/problems/maximum-number-of-balloons" target="_blank">
Go to Leetcode üîó
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int maxNumberOfBalloons(String text) {
        // Define the required frequencies of characters to form 'balloon'
        Map&lt;Character, Integer&gt; requiredCharMap = Map.of(
                'b', 1,
                'a', 1,
                'l', 2,
                'o', 2,
                'n', 1);

        // Calculate the frequencies of characters that are part of 'balloon'
        Map&lt;Character, Integer&gt; availableCharMap = new HashMap&lt;&gt;();
        for (char c : text.toCharArray()) {
            if (requiredCharMap.containsKey(c)) {
                availableCharMap.put(c, availableCharMap.getOrDefault(c, 0) + 1);
            }
        }
        
        // Calculate the maximum available count of the word 'balloon'
        int maxCount = Integer.MAX_VALUE;
        if (availableCharMap.size() == requiredCharMap.size()) {
            for (char c : availableCharMap.keySet()) {
                int requiredCount = requiredCharMap.get(c);
                int availableCount = availableCharMap.get(c);
                maxCount = Math.min(maxCount, availableCount / requiredCount);
            }
        }

        return (maxCount == Integer.MAX_VALUE) ? 0 : maxCount;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW NOTES</summary>
  <p><strong>Virsulization:</strong></p>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/23-longest-palindrome.png" alt="Maximum Number of Balloons"  />
</p>

</details></p>

<hr>
<h2 id="longest-palindrome">Longest Palindrome<a hidden class="anchor" aria-hidden="true" href="#longest-palindrome">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement:</strong></p>
<p>Given a string, determine the length of the longest palindrome that can be constructed using the characters from the string. Return the maximum possible length of the palindromic string.</p>
<hr>
<p><strong>Example 1:</strong></p>
<ul>
<li><strong>Input</strong>: <code>&quot;applepie&quot;</code></li>
<li><strong>Expected Output</strong>: <code>5</code></li>
<li><strong>Justification</strong>: The longest palindrome that can be formed is <code>&quot;pepep&quot;</code>, which has a length of 5. Other valid palindromes are also of length 5.</li>
</ul>
<p><strong>Example 2:</strong></p>
<ul>
<li><strong>Input</strong>: <code>&quot;aabbcc&quot;</code></li>
<li><strong>Expected Output</strong>: <code>6</code></li>
<li><strong>Justification</strong>: We can form the palindrome <code>&quot;abccba&quot;</code>, which has a length of 6.</li>
</ul>
<p><strong>Example 3:</strong></p>
<ul>
<li><strong>Input</strong>: <code>&quot;bananas&quot;</code></li>
<li><strong>Expected Output</strong>: <code>5</code></li>
<li><strong>Justification</strong>: The longest palindrome that can be formed is <code>&quot;anana&quot;</code>, which has a length of 5.</li>
</ul>
<hr>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 2000</code></li>
<li><code>s</code> consists of lowercase and/or uppercase English letters only.</li>
</ul>
<hr>

</details></p>


<a href="https://leetcode.com/problems/longest-palindrome" target="_blank">
Go to Leetcode üîó
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int longestPalindrome(String s) {
        // Calculate the frequency of each character in the string
        Map&lt;Character, Integer&gt; frequencyMap = new HashMap&lt;&gt;();
        for (char c : s.toCharArray()) {
            frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1);
        }

        // Flag to track if any character has an odd frequency
        boolean oddFound = false;
        int maxLength = 0;

        // Calculate the maximum possible length of the palindrome
        for (int count : frequencyMap.values()) {
            if (count % 2 == 0) {
                // Add even counts directly to the length of the palindorme
                maxLength += count;
            } else {
                maxLength += count - 1; // Add the even parts of odd counts
                oddFound = true; // Mark an odd frequency character exists
            }
        }

        // For characters has an odd count, one can be placed in the middle of the palindrome
        return oddFound ? maxLength + 1 : maxLength;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW NOTES</summary>
  <blockquote>
<p>To solve this problem, the first step is to calculate the frequency of each character in the original string. If no character has an odd frequency, simply add the frequency of each character to the length of the palindrome. If there are characters with an odd frequency, one of those characters can be placed in the middle of the palindrome.</p>
</blockquote>
<blockquote>
<p>Therefore, to get the maximum length of the palindrome, two key steps are involved. First, add the even part of each character&rsquo;s frequency to the palindrome length. Then, if there is any character with an odd count, increment the length by 1, representing the character placed in the middle of the palindrome.</p>
</blockquote>
<hr>
<p><strong>Virsulization:</strong></p>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/23-longest-palindrome.png" alt="Longest Palindrome"  />
</p>

</details></p>

<hr>
<h1 id="prefix-sum">Prefix Sum<a hidden class="anchor" aria-hidden="true" href="#prefix-sum">#</a></h1>
<blockquote>
<p>A <strong>prefix sum</strong> refers to the cumulative sum of an array from the begining up to a specified index. The <strong>prefix sum pattern</strong> is a programming technique commonly used to solve problems related to subarrays, such as calculating the range sum, range maximum/minimum, or frequency counting.</p>
</blockquote>
<blockquote>
<p>To calculate the prefix sum, the steps typically include:</p>
</blockquote>
<ol>
<li>Initialze a <code>prefix</code> array with the same length as the original array.</li>
<li>Assign <code>prefix[0] = arr[0]</code>.</li>
<li>Iterate through the array from index <code>1</code> to <code>n - 1</code>, set <code>prefix[i] = arr[i] + prefix[i - 1]</code></li>
</ol>
<blockquote>
<p>Once the prefix sum array is constructed, the time complexity for calculating the sum of any subarray is <strong>O(1)</strong>, makeing this technique very efficient.</p>
</blockquote>
<hr>
<h2 id="find-the-middle-index-in-array">Find the Middle Index in Array<a hidden class="anchor" aria-hidden="true" href="#find-the-middle-index-in-array">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement:</strong></p>
<p>Given an integer array <code>nums</code>, return the leftmost <strong>middleIndex</strong> (i.e., the smallest index among all possible middle indices).</p>
<p>A <strong>middleIndex</strong> is an index where the sum of the numbers to the left of this index is equal to the sum of the numbers to the right of this index.</p>
<ul>
<li>You can consider the left sum to be 0 when <code>middleIndex == 0</code>, and the right sum to be 0 when <code>middleIndex == nums.length - 1</code>.</li>
<li>If no middle index exists in the array, return <code>-1</code>.</li>
</ul>
<hr>
<p><strong>Example 1:</strong></p>
<ul>
<li><strong>Input</strong>: <code>nums = [1, 7, 3, 6, 5, 6]</code></li>
<li><strong>Expected Output</strong>: <code>3</code></li>
<li><strong>Justification</strong>: The sum of the numbers to the left of index 3 (<code>1 + 7 + 3 = 11</code>) is equal to the sum of the numbers to the right of index 3 (<code>5 + 6 = 11</code>).</li>
</ul>
<p><strong>Example 2:</strong></p>
<ul>
<li><strong>Input</strong>: <code>nums = [2, 1, -1]</code></li>
<li><strong>Expected Output</strong>: <code>0</code></li>
<li><strong>Justification</strong>: The sum of the numbers to the left of index 0 is considered 0. The sum of the numbers to the right of index 0 (<code>1 + -1 = 0</code>) is also 0.</li>
</ul>
<p><strong>Example 3:</strong></p>
<ul>
<li><strong>Input</strong>: <code>nums = [2, 3, 5, 5, 3, 2]</code></li>
<li><strong>Expected Output</strong>: <code>-1</code></li>
<li><strong>Justification</strong>: There is no index in the array where the left and right sums are equal.</li>
</ul>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 100</code></li>
<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
<hr>

</details></p>


<a href="https://leetcode.com/problems/find-the-middle-index-in-array" target="_blank">
Go to Leetcode üîó
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int findMiddleIndex(int[] nums) {
        // Calculate the total sum of the array
        int totalSum = Arrays.stream(nums).sum();

        int leftSum = 0;
        // Iterate through the array to find the middle index
        for (int i = 0; i < nums.length; i++) {
            // Calculate the right sum
            int rightSum = totalSum - leftSum - nums[i];

            // Found the middle index if left sum equals to right sum
            if (leftSum == rightSum) {
                return i;
            }

            // Update the left sum for next iteration
            leftSum += nums[i];
        }

        // Return -1 if middle index is found
        return -1;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW NOTES</summary>
  <p><strong>Visualization:</strong></p>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/24-find-middle-index-of-an-array.png" alt="Find the middle index in array"  />
</p>

</details></p>

<hr>
<h2 id="left-and-right-sum-differences">Left and Right Sum Differences<a hidden class="anchor" aria-hidden="true" href="#left-and-right-sum-differences">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement</strong></p>
<p>Given an integer array <code>nums</code>, you need to find a new integer array called <code>differenceArray</code>, where each element at index <code>i</code> in <code>differenceArray</code> is the absolute difference between the sum of all elements to the left of index <code>i</code> and the sum of all elements to the right of index <code>i</code> in the original array <code>nums</code>.</p>
<p>Formally, for each index <code>i</code> in the array:</p>
<p>$$
\text{differenceArray}[i] = | \text{leftSumi} - \text{rightSumi} |
$$</p>
<p>Where:</p>
<ul>
<li>$\text{leftSum}_i$ is the sum of all elements to the left of index <code>i</code> (i.e., <code>nums[0] + nums[1] + ... + nums[i-1]</code>).</li>
<li>$\text{rightSum}_i$ is the sum of all elements to the right of index <code>i</code> (i.e., <code>nums[i+1] + nums[i+2] + ... + nums[nums.length-1]</code>).</li>
<li>If there are no elements to the left or right of <code>i</code>, treat the sum as <code>0</code>.</li>
</ul>
<hr>
<p><strong>Example 1:</strong></p>
<ul>
<li><strong>Input</strong>: <code>nums = [2, 5, 1, 6, 1]</code></li>
<li><strong>Expected Output</strong>: <code>[13, 6, 0, 7, 14]</code></li>
<li><strong>Explanation</strong>:
<ul>
<li>For <code>i = 0</code>: <code>| (0) - (5 + 1 + 6 + 1) | = | 0 - 13 | = 13</code></li>
<li>For <code>i = 1</code>: <code>| (2) - (1 + 6 + 1) | = | 2 - 8 | = 6</code></li>
<li>For <code>i = 2</code>: <code>| (2 + 5) - (6 + 1) | = | 7 - 7 | = 0</code></li>
<li>For <code>i = 3</code>: <code>| (2 + 5 + 1) - (1) | = | 8 - 1 | = 7</code></li>
<li>For <code>i = 4</code>: <code>| (2 + 5 + 1 + 6) - (0) | = | 14 - 0 | = 14</code></li>
</ul>
</li>
</ul>
<p><strong>Example 2:</strong></p>
<ul>
<li><strong>Input</strong>: <code>nums = [3, 3, 3]</code></li>
<li><strong>Expected Output</strong>: <code>[6, 0, 6]</code></li>
<li><strong>Explanation</strong>:
<ul>
<li>For <code>i = 0</code>: <code>| (0) - (3 + 3) | = | 0 - 6 | = 6</code></li>
<li>For <code>i = 1</code>: <code>| (3) - (3) | = | 3 - 3 | = 0</code></li>
<li>For <code>i = 2</code>: <code>| (3 + 3) - (0) | = | 6 - 0 | = 6</code></li>
</ul>
</li>
</ul>
<p><strong>Example 3:</strong></p>
<ul>
<li><strong>Input</strong>: <code>nums = [1, 2, 3, 4, 5]</code></li>
<li><strong>Expected Output</strong>: <code>[14, 11, 6, 1, 10]</code></li>
<li><strong>Explanation</strong>:
<ul>
<li>For <code>i = 0</code>: <code>| (0) - (2 + 3 + 4 + 5) | = | 0 - 14 | = 14</code></li>
<li>For <code>i = 1</code>: <code>| (1) - (3 + 4 + 5) | = | 1 - 12 | = 11</code></li>
<li>For <code>i = 2</code>: <code>| (1 + 2) - (4 + 5) | = | 3 - 9 | = 6</code></li>
<li>For <code>i = 3</code>: <code>| (1 + 2 + 3) - (5) | = | 6 - 5 | = 1</code></li>
<li>For <code>i = 4</code>: <code>| (1 + 2 + 3 + 4) - (0) | = | 10 - 0 | = 10</code></li>
</ul>
</li>
</ul>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^5</code></li>
</ul>
<hr>

</details></p>


<a href="https://leetcode.com/problems/left-and-right-sum-differences" target="_blank">
Go to Leetcode üîó
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int[] leftRightDifference(int[] nums) {
        int n = nums.length;

        // Calculate the total sum of nums
        int totalSum = Arrays.stream(nums).sum();

        // Construct prefix sum array based on nums
        int[] prefix = new int[n];
        prefix[0] = nums[0];
        for (int i = 1; i < n; i++) {
            prefix[i] = nums[i] + prefix[i - 1];
        }

        int[] answer = new int[n];
        // Iterate over nums to calculate the absolute difference between left and right
        // sums for each index
        for (int i = 0; i < n; i++) {
            int leftSum = prefix[i] - nums[i];
            int rightSum = totalSum - prefix[i];

            answer[i] = Math.abs(leftSum - rightSum);
        }

        return answer;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="subarray-sums-divisible-by-k">Subarray Sums Divisible by K<a hidden class="anchor" aria-hidden="true" href="#subarray-sums-divisible-by-k">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement:</strong></p>
<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return the number of non-empty subarrays whose sum is divisible by <code>k</code>.</p>
<p>A <strong>subarray</strong> is a contiguous part of an array.</p>
<hr>
<p><strong>Example 1:</strong></p>
<ul>
<li><strong>Input</strong>: <code>nums = [3, 1, 2, -2, 5, -1]</code>, <code>k = 3</code></li>
<li><strong>Output</strong>: <code>7</code></li>
<li><strong>Explanation</strong>: There are 7 subarrays whose sum is divisible by <code>k = 3</code>:
<ul>
<li><code>[3]</code>, <code>[1, 2]</code>, <code>[3, 1, 2]</code>, <code>[-2, 2]</code>, <code>[3, 1, 2, -2, 5]</code>, <code>[1, 2, -2, 5]</code>, <code>[-2, 5]</code>.</li>
</ul>
</li>
</ul>
<p><strong>Example 2:</strong></p>
<ul>
<li><strong>Input</strong>: <code>nums = [4, 5, 0, -2, -3, 1]</code>, <code>k = 5</code></li>
<li><strong>Output</strong>: <code>7</code></li>
<li><strong>Explanation</strong>: There are 7 subarrays whose sum is divisible by <code>k = 5</code>:
<ul>
<li><code>[4, 5, 0, -2, -3, 1]</code>, <code>[5]</code>, <code>[5, 0]</code>, <code>[5, 0, -2, -3]</code>, <code>[0]</code>, <code>[0, -2, -3]</code>, <code>[-2, -3]</code>.</li>
</ul>
</li>
</ul>
<p><strong>Example 2:</strong></p>
<ul>
<li><strong>Input</strong>: <code>nums = [5]</code>, <code>k = 9</code></li>
<li><strong>Output</strong>: <code>0</code>.</li>
</ul>
<hr>
<p><strong>Constraints</strong>:</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 30,000</code></li>
<li><code>-10,000 &lt;= nums[i] &lt;= 10,000</code></li>
<li><code>2 &lt;= k &lt;= 10,000</code></li>
</ul>
<hr>

</details></p>


<a href="https://leetcode.com/problems/subarray-sums-divisible-by-k" target="_blank">
Go to Leetcode üîó
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int subarraysDivByK(int[] nums, int k) {
        // Store frequency of prefix sum modulo k
        Map<Integer, Integer> prefixSumModCount = new HashMap<>();
        
        // Initialize with mod 0 having a frequency of 1 
        // (for the case where the prefix sum itself is divisible by k)
        prefixSumModCount.put(0, 1);

        // Initialize the prefix sum and the count of valid subarrays
        int prefixSum = 0, count = 0;
        for (int num : nums) {
            // Update the current prefix sum
            prefixSum += num;
            
            // Ensure the modulo is always positive
            int mod = ((prefixSum % k) + k) % k;

            // If the same mod has been seen before, 
            // it means there are subarrays whose sum is divisible by k
            count += prefixSumModCount.getOrDefault(mod, 0);

            // Update frequency of current mod
            prefixSumModCount.put(mod, prefixSumModCount.getOrDefault(mod, 0) + 1);
        }

        return count;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW NOTES</summary>
  <p>If the sum of a subarray form index $i$ to $j$ can be divisable by $k$, then:
$$
(a[0] + a[1] + \dots + a[i - 1] + a[i]) \;\text{mod} \;k
$$</p>
<p>equals to</p>
<p>$$
(a[0] + a[1] + \dots + a[i] + \dots + a[j-1] + a[j]) \;\text{mod} \;k
$$</p>
<hr>
<p><strong>Algorithm Walkthrough</strong></p>
<ul>
<li><strong>Input</strong>: <code>nums = [3, 1, 2, -2, 5, -1]</code> and <code>k = 3</code>.</li>
</ul>
<ol>
<li>
<p><strong>Initialization:</strong></p>
<ul>
<li><code>remainder_count = {0: 1}</code> (We start by initializing the count of remainders with 0, assuming a subarray sum of 0 is divisible by <code>k</code>.)</li>
<li><code>cumulative_sum = 0</code></li>
<li><code>count = 0</code></li>
</ul>
</li>
<li>
<p><strong>Iteration 1 (num = 3):</strong></p>
<ul>
<li><code>cumulative_sum = 3</code></li>
<li><code>remainder = 3 % 3 = 0</code></li>
<li><code>count += remainder_count[0] = 1</code> ‚Üí <code>count = 1</code></li>
<li>Update <code>remainder_count</code>: <code>{0: 2}</code></li>
</ul>
</li>
<li>
<p><strong>Iteration 2 (num = 1):</strong></p>
<ul>
<li><code>cumulative_sum = 4</code></li>
<li><code>remainder = 4 % 3 = 1</code></li>
<li><code>count += remainder_count.get(1, 0) = 0</code> ‚Üí <code>count = 1</code></li>
<li>Update <code>remainder_count</code>: <code>{0: 2, 1: 1}</code></li>
</ul>
</li>
<li>
<p><strong>Iteration 3 (num = 2):</strong></p>
<ul>
<li><code>cumulative_sum = 6</code></li>
<li><code>remainder = 6 % 3 = 0</code></li>
<li><code>count += remainder_count[0] = 2</code> ‚Üí <code>count = 3</code></li>
<li>Update <code>remainder_count</code>: <code>{0: 3, 1: 1}</code></li>
</ul>
</li>
<li>
<p><strong>Iteration 4 (num = -2):</strong></p>
<ul>
<li><code>cumulative_sum = 4</code></li>
<li><code>remainder = 4 % 3 = 1</code></li>
<li><code>count += remainder_count[1] = 1</code> ‚Üí <code>count = 4</code></li>
<li>Update <code>remainder_count</code>: <code>{0: 3, 1: 2}</code></li>
</ul>
</li>
<li>
<p><strong>Iteration 5 (num = 5):</strong></p>
<ul>
<li><code>cumulative_sum = 9</code></li>
<li><code>remainder = 9 % 3 = 0</code></li>
<li><code>count += remainder_count[0] = 3</code> ‚Üí <code>count = 7</code></li>
<li>Update <code>remainder_count</code>: <code>{0: 4, 1: 2}</code></li>
</ul>
</li>
<li>
<p><strong>Iteration 6 (num = -1):</strong></p>
<ul>
<li><code>cumulative_sum = 8</code></li>
<li><code>remainder = 8 % 3 = 2</code></li>
<li><code>count += remainder_count.get(2, 0) = 0</code> ‚Üí <code>count = 7</code></li>
<li>Update <code>remainder_count</code>: <code>{0: 4, 1: 2, 2: 1}</code></li>
</ul>
</li>
<li>
<p><strong>The total count of subarrays whose sum is divisible by <code>k</code> is <code>7</code>.</strong></p>
</li>
</ol>

</details></p>

<hr>
<h1 id="monotonic-stack">Monotonic Stack<a hidden class="anchor" aria-hidden="true" href="#monotonic-stack">#</a></h1>
<blockquote>
<p>A <strong>monotonic stack pattern</strong> is a technique commonly used to solve problems that involve finding the next greater or next smaller element in a sequence or array, or finding the largest rectangle in a histogram. There are two types of monotonic stacks: the <strong>increasing monotonic stack</strong> and the <strong>decreasing monotonic stack</strong>.</p>
</blockquote>
<ol>
<li>An <strong>increasing monotonic stack</strong> maintains elements in increasing order from bottom to top (i.e., each element is greater than or equal to the element below it).</li>
<li>An <strong>decreasing monotonic stack</strong> maintains elements in decreasing order from bottom to top (i.e., each element is smaller than or equal to the element below it).</li>
</ol>
<blockquote>
<p>Creating a monotonic stack commonly involves the following steps (using  increasing monotonic stack as an example):</p>
</blockquote>
<ol>
<li><strong>Initialize</strong> an empty stack.</li>
<li><strong>Iterate</strong> over the array.</li>
<li><strong>Compare</strong> the current element with the top element of the stack (if the stack is not empty).</li>
<li><strong>Pop</strong> all elements from the stack that are smaller than the current element. This ensures that the stack only contains elements greater than or equal to the current element.</li>
<li><strong>Push</strong> the current element onto the stack.</li>
</ol>
<hr>
<h2 id="next-greater-element-i">Next Greater Element I<a hidden class="anchor" aria-hidden="true" href="#next-greater-element-i">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p>The <strong>next greater element</strong> for an element <code>x</code> in an array is the first element greater than <code>x</code> that appears to the right of <code>x</code> in the same array.</p>
<p>You are given two distinct 0-indexed integer arrays, <code>nums1</code> and <code>nums2</code>, where <code>nums1</code> is a subset of <code>nums2</code>.</p>
<p>For each <code>0 &lt;= i &lt; nums1.length</code>, find the index <code>j</code> such that <code>nums1[i] == nums2[j]</code>, and then determine the <strong>next greater element</strong> of <code>nums2[j]</code> in <code>nums2</code>. If there is no next greater element, return <code>-1</code> for that query.</p>
<p>Return an array <code>ans</code> of length <code>nums1.length</code> such that <code>ans[i]</code> is the next greater element for <code>nums1[i]</code> as described above.</p>
<hr>
<p><strong>Example 1:</strong></p>
<ul>
<li><strong>Input:</strong> <code>nums1 = [4, 1, 2]</code>, <code>nums2 = [1, 3, 4, 2]</code></li>
<li><strong>Output:</strong> <code>[-1, 3, -1]</code></li>
<li><strong>Explanation:</strong>
<ul>
<li>The next greater element for <code>4</code> is not found in <code>nums2</code>, so the answer is <code>-1</code>.</li>
<li>The next greater element for <code>1</code> is <code>3</code>.</li>
<li>The next greater element for <code>2</code> is not found, so the answer is <code>-1</code>.</li>
</ul>
</li>
</ul>
<p><strong>Example 2:</strong></p>
<ul>
<li><strong>Input:</strong>  <code>nums1 = [2, 4]</code>, <code>nums2 = [1, 2, 3, 4]</code></li>
<li><strong>Output:</strong>  <code>[3, -1]</code></li>
<li><strong>Explanation:</strong>
<ul>
<li>The next greater element for <code>2</code> is <code>3</code>.</li>
<li>The next greater element for <code>4</code> is not found, so the answer is <code>-1</code>.</li>
</ul>
</li>
</ul>
<hr>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000</code></li>
<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 10‚Å¥</code></li>
<li>All integers in <code>nums1</code> and <code>nums2</code> are unique.</li>
<li>All integers of <code>nums1</code> are also present in <code>nums2</code>.</li>
</ul>
<hr>

</details></p>


<a href="https://leetcode.com/problems/next-greater-element-i" target="_blank">
Go to Leetcode üîó
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        // Initialize an empty stack to track elements in nums2
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        // Map to store the next greater element for each number in nums2
        Map&lt;Integer, Integer&gt; nextGreaterMap = new HashMap&lt;&gt;();

        // Traverse nums2 from right to left to populate the nextGreaterMap
        for (int i = nums2.length - 1; i >= 0; i--) {
            int num = nums2[i];

            // Pop elements from stack that are less than or equal to the current number
            while (!stack.isEmpty() && stack.peek() <= num) {
                stack.pop();
            }

            // If stack is empty, no greater element exists, otherwise top of stack is the next greater element
            nextGreaterMap.put(num, stack.isEmpty() ? -1 : stack.peek());

            // Push the current number onto the stack for future comparisons
            stack.push(num);
        }

        // Prepare the result array for nums1 based on nextGreaterMap
        int[] result = new int[nums1.length];
        // Find the next greater element for each number in nums1
        for (int i = 0; i < nums1.length; i++) {
            result[i] = nextGreaterMap.get(nums1[i]);
        }

        return result;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW NOTES</summary>
  <blockquote>
<p><strong>When iterating over an increasing monotonic stack from right to left, if the current element is greater than the top of the stack, it means the current element could be the next greater element for the previous ones. In this case, pop the stack.</strong></p>
</blockquote>
</details></p>

<hr>
<h2 id="heading"><a hidden class="anchor" aria-hidden="true" href="#heading">#</a></h2>
<h1 id="tree-breadth-first-search">Tree Breadth First Search<a hidden class="anchor" aria-hidden="true" href="#tree-breadth-first-search">#</a></h1>
<hr>
<h1 id="tree-depth-first-search">Tree Depth First Search<a hidden class="anchor" aria-hidden="true" href="#tree-depth-first-search">#</a></h1>
<hr>
<h1 id="cyclic-sort">Cyclic Sort<a hidden class="anchor" aria-hidden="true" href="#cyclic-sort">#</a></h1>
<hr>
<h1 id="matrix-traversal">Matrix Traversal<a hidden class="anchor" aria-hidden="true" href="#matrix-traversal">#</a></h1>
<hr>
<h1 id="subsets">Subsets<a hidden class="anchor" aria-hidden="true" href="#subsets">#</a></h1>
<hr>
<h1 id="modified-binary-tree">Modified Binary Tree<a hidden class="anchor" aria-hidden="true" href="#modified-binary-tree">#</a></h1>
<hr>
<h1 id="bitwise-xor">Bitwise XOR<a hidden class="anchor" aria-hidden="true" href="#bitwise-xor">#</a></h1>
<hr>
<h1 id="greedy-algorithm">Greedy Algorithm<a hidden class="anchor" aria-hidden="true" href="#greedy-algorithm">#</a></h1>
<hr>
<h1 id="dynamic-programming">Dynamic Programming<a hidden class="anchor" aria-hidden="true" href="#dynamic-programming">#</a></h1>
<hr>
<h1 id="backtracking">Backtracking<a hidden class="anchor" aria-hidden="true" href="#backtracking">#</a></h1>
<hr>
<h1 id="union-find">Union Find<a hidden class="anchor" aria-hidden="true" href="#union-find">#</a></h1>
<hr>
<h1 id="topological-sort">Topological Sort<a hidden class="anchor" aria-hidden="true" href="#topological-sort">#</a></h1>
<hr>
<h1 id="ordered-set">Ordered Set<a hidden class="anchor" aria-hidden="true" href="#ordered-set">#</a></h1>
<hr>
<h1 id="trie">Trie<a hidden class="anchor" aria-hidden="true" href="#trie">#</a></h1>
<hr>
<h1 id="top-k-elements">Top &lsquo;K&rsquo; Elements<a hidden class="anchor" aria-hidden="true" href="#top-k-elements">#</a></h1>
<hr>
<h1 id="k-way-merge">K-way Merge<a hidden class="anchor" aria-hidden="true" href="#k-way-merge">#</a></h1>
<hr>
<h1 id="two-heaps">Two Heaps<a hidden class="anchor" aria-hidden="true" href="#two-heaps">#</a></h1>
<hr>
<h1 id="heading-1"><a hidden class="anchor" aria-hidden="true" href="#heading-1">#</a></h1>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://signalyu.github.io/tags/data-structure--algorithms/">Data Structure &amp; Algorithms</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/design-patterns/1-design-patterns/">
    <span class="title">¬´ PREV</span>
    
    <br>
    <span>Design Patterns</span>
  </a>
  <a class="next" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/database/database-design/1-database-design-notes/">
    <span class="title">NEXT ¬ª</span>
    
    <br>
    <span>Database Design Notes</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://signalyu.github.io/">Signal&#39;s Blog</a></span> ¬∑ 
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>

</body>
</html>
