<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Coding Patterns for Interview Questions | Signal&#39;s Blog</title>
<meta name="keywords" content="Coding Patterns">
<meta name="description" content="Simple Two Pointers The Simple Two Pointers technique is commonly used to solve problems involving sorted array, where a set of elements needs to be found that satisfy certain constrains. This approach is efficient in scenarios such as finding a pair that sums to a target or reversing an array or string. In the two simple two pointers technique, two pointers &ndash; typically labeled &ldquo;left&rdquo; and &ldquo;right&rdquo; &ndash; are initialized and move in a specific direction based on the problem&rsquo;s requirements.">
<meta name="author" content="Signal Yu">
<link rel="canonical" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/patterns/1-coding-patterns-for-interview-questions/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.9ddf6c021b47a5a861a7c6af241af938775e0fc65a762930d3a2426fc59e9a5c.css" integrity="sha256-nd9sAhtHpahhp8avJBr5OHdeD8Zadikw06JCb8Wemlw=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://signalyu.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://signalyu.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://signalyu.github.io/favicon-32x32">
<link rel="apple-touch-icon" href="https://signalyu.github.io/apple-touch-icon">
<link rel="mask-icon" href="https://signalyu.github.io/favicon.io">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/patterns/1-coding-patterns-for-interview-questions/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css"
    integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"
    integrity="sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd"
    crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js"
    integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk"
    crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: true }
            ],
            
            throwOnError: false,
            strict: false
        });
    });
</script>

  

<meta property="og:title" content="Coding Patterns for Interview Questions" />
<meta property="og:description" content="Simple Two Pointers The Simple Two Pointers technique is commonly used to solve problems involving sorted array, where a set of elements needs to be found that satisfy certain constrains. This approach is efficient in scenarios such as finding a pair that sums to a target or reversing an array or string. In the two simple two pointers technique, two pointers &ndash; typically labeled &ldquo;left&rdquo; and &ldquo;right&rdquo; &ndash; are initialized and move in a specific direction based on the problem&rsquo;s requirements." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/patterns/1-coding-patterns-for-interview-questions/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-02T10:15:04+08:00" />
<meta property="article:modified_time" content="2022-12-02T10:15:04+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Coding Patterns for Interview Questions"/>
<meta name="twitter:description" content="Simple Two Pointers The Simple Two Pointers technique is commonly used to solve problems involving sorted array, where a set of elements needs to be found that satisfy certain constrains. This approach is efficient in scenarios such as finding a pair that sums to a target or reversing an array or string. In the two simple two pointers technique, two pointers &ndash; typically labeled &ldquo;left&rdquo; and &ldquo;right&rdquo; &ndash; are initialized and move in a specific direction based on the problem&rsquo;s requirements."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://signalyu.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Coding Patterns for Interview Questions",
      "item": "https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/patterns/1-coding-patterns-for-interview-questions/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Coding Patterns for Interview Questions",
  "name": "Coding Patterns for Interview Questions",
  "description": "Simple Two Pointers The Simple Two Pointers technique is commonly used to solve problems involving sorted array, where a set of elements needs to be found that satisfy certain constrains. This approach is efficient in scenarios such as finding a pair that sums to a target or reversing an array or string. In the two simple two pointers technique, two pointers \u0026ndash; typically labeled \u0026ldquo;left\u0026rdquo; and \u0026ldquo;right\u0026rdquo; \u0026ndash; are initialized and move in a specific direction based on the problem\u0026rsquo;s requirements.",
  "keywords": [
    "Coding Patterns"
  ],
  "articleBody": "Simple Two Pointers The Simple Two Pointers technique is commonly used to solve problems involving sorted array, where a set of elements needs to be found that satisfy certain constrains. This approach is efficient in scenarios such as finding a pair that sums to a target or reversing an array or string. In the two simple two pointers technique, two pointers ‚Äì typically labeled ‚Äúleft‚Äù and ‚Äúright‚Äù ‚Äì are initialized and move in a specific direction based on the problem‚Äôs requirements.\nTwo Sum II - Input Array Is Sorted SHOW PROBLEM Problem Statement\nGiven a 1-indexed array of integers, numbers, sorted in non-decreasing order, find two numbers that add up to a specific target. Let these two numbers be numbers[index1] and numbers[index2], where 1 \u003c= index1 \u003c index2 \u003c= numbers.length.\nReturn the indices of the two numbers, index1 and index2, incremented by one, as an integer array [index1, index2] of length 2.\nThe problem guarantees that there is exactly one solution. You may not use the same element twice. Your solution must use only constant extra space. Example 1:\nInput: numbers = [2,7,11,15], target = 9 Output: [1, 2] Explanation: The sum of 2 and 7 is 9, so index1 = 1, index2 = 2. We return [1, 2]. Example 2:\nInput: numbers = [2,3,4], target = 6 Output: [1, 3] Explanation: The sum of 2 and 4 is 6, so index1 = 1, index2 = 3. We return [1, 3]. Example 3:\nInput: numbers = [-1,0], target = -1 Output: [1, 2] Explanation: The sum of -1 and 0 is -1, so index1 = 1, index2 = 2. We return [1, 2]. Constraints:\n2 \u003c= numbers.length \u003c= 30,000 -1000 \u003c= numbers[i] \u003c= 1000 numbers is sorted in non-decreasing order. -1000 \u003c= target \u003c= 1000 There is exactly one solution for each test case. Go to Leetcode üîó SHOW CODE Java class Solution { public int[] twoSum(int[] numbers, int target) { int left = 0, right = numbers.length - 1; // Iterate while left pointer is before right pointer while (left \u003c right) { int currentSum = numbers[left] + numbers[right]; // Check if the current sum matches the target if (currentSum == target) { break; } // Adjust the pointers to move towards the target sum if (currentSum \u003c target) { left++; // Increase sum by moving left pointer right } else { right--; // Decrease sum by moving right pointer left } } // Reture 1-indexed result return new int[] { left + 1, right + 1 }; } } SHOW NOTES Algorithm Walkthrough\nnums = [1, 2, 3, 4, 5, 8] target = 7 Initialize pointers: left = 0, right = 5 First iteration: currentSum = 1 + 8 = 9 (greater than the target) Decrease the right pointer to 4 Second iteration: currentSum = 1 + 5 = 6 (less than the target) Increase the left pointer to 1 Third iteration: currentSum = 2 + 4 = 6 (equals the target) Return the indices [1, 3]. Visualization\n3Sum SHOW PROBLEM Problem Statement\nGiven an integer array nums, return all unique triplets [nums[i], nums[j], nums[k]] such that:\ni != j, i != k, and j != k nums[i] + nums[j] + nums[k] == 0 The solution set must not contain duplicate triplets.\nExample 1:\nInput: nums = [-1, 0, 1, 2, -1, -4] Output: [[-1, -1, 2], [-1, 0, 1]] Explanation: nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 The distinct triplets are [-1, 0, 1] and [-1, -1, 2].\nNote: The order of the output and the order of the triplets does not matter.\nExample 2:\nInput: nums = [0, 1, 1] Output: [] Explanation: The only possible triplet does not sum up to 0. Example 3:\nInput: nums = [0, 0, 0] Output: [[0, 0, 0]] Explanation: The only possible triplet sums up to 0. Constraints:\n3 \u003c= nums.length \u003c= 3000 10^5 \u003c= nums[i] \u003c= 10^5 Go to Leetcode üîó SHOW CODE Java class Solution { public List",
  "wordCount" : "693",
  "inLanguage": "en",
  "datePublished": "2022-12-02T10:15:04+08:00",
  "dateModified": "2022-12-02T10:15:04+08:00",
  "author":{
    "@type": "Person",
    "name": "Signal Yu"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/patterns/1-coding-patterns-for-interview-questions/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Signal's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://signalyu.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://signalyu.github.io/" accesskey="h" title="Signal&#39;s Blog (Alt + H)">
                <img src="https://signalyu.github.io/apple-touch-icon.png" alt="" aria-label="logo"
                    height="40">Signal&#39;s Blog</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://signalyu.github.io/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://signalyu.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://signalyu.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://signalyu.github.io/">Home</a>&nbsp;¬ª&nbsp;<a href="https://signalyu.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Coding Patterns for Interview Questions
    </h1>
    <div class="post-meta"><span title='2022-12-02 10:15:04 +0800 HKT'>Dec 2 2022</span>&nbsp;¬∑&nbsp;Signal Yu

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#simple-two-pointers" aria-label="Simple Two Pointers">Simple Two Pointers</a><ul>
                        
                <li>
                    <a href="#two-sum-ii---input-array-is-sorted" aria-label="Two Sum II - Input Array Is Sorted">Two Sum II - Input Array Is Sorted</a></li>
                <li>
                    <a href="#3sum" aria-label="3Sum">3Sum</a></li></ul>
                </li>
                <li>
                    <a href="#fast--slow-pointers" aria-label="Fast &amp; Slow Pointers">Fast &amp; Slow Pointers</a><ul>
                        
                <li>
                    <a href="#linked-list-cycle" aria-label="Linked List Cycle">Linked List Cycle</a></li>
                <li>
                    <a href="#middle-of-the-linkedlist" aria-label="Middle of the LinkedList">Middle of the LinkedList</a></li>
                <li>
                    <a href="#remove-nth-node-from-end-of-list" aria-label="Remove Nth Node From End of List">Remove Nth Node From End of List</a></li></ul>
                </li>
                <li>
                    <a href="#sliding-window" aria-label="Sliding Window">Sliding Window</a><ul>
                        
                <li>
                    <a href="#maximum-sum-subarray-of-size-k" aria-label="Maximum Sum Subarray of Size K">Maximum Sum Subarray of Size K</a></li>
                <li>
                    <a href="#longest-substring-with-at-most-k-distinct-characters" aria-label="Longest Substring with At Most K Distinct Characters">Longest Substring with At Most K Distinct Characters</a></li></ul>
                </li>
                <li>
                    <a href="#merge-intervals" aria-label="Merge Intervals">Merge Intervals</a><ul>
                        
                <li>
                    <a href="#merge-intervals-1" aria-label="Merge Intervals">Merge Intervals</a></li>
                <li>
                    <a href="#insert-interval" aria-label="Insert Interval">Insert Interval</a></li>
                <li>
                    <a href="#intervals-intersection" aria-label="Intervals Intersection">Intervals Intersection</a></li></ul>
                </li>
                <li>
                    <a href="#in-place-reversal-of-a-linked-list" aria-label="In-place Reversal of a Linked List">In-place Reversal of a Linked List</a></li>
                <li>
                    <a href="#hash-maps" aria-label="Hash Maps">Hash Maps</a></li>
                <li>
                    <a href="#prefix-sum" aria-label="Prefix Sum">Prefix Sum</a></li>
                <li>
                    <a href="#monotonic-stack" aria-label="Monotonic Stack">Monotonic Stack</a></li>
                <li>
                    <a href="#tree-breadth-first-search" aria-label="Tree Breadth First Search">Tree Breadth First Search</a></li>
                <li>
                    <a href="#tree-depth-first-search" aria-label="Tree Depth First Search">Tree Depth First Search</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="simple-two-pointers">Simple Two Pointers<a hidden class="anchor" aria-hidden="true" href="#simple-two-pointers">#</a></h1>
<blockquote>
<p>The <strong>Simple Two Pointers</strong> technique is commonly used to solve problems involving <strong>sorted</strong> array, where a set of elements needs to be found that satisfy certain constrains. This approach is efficient in scenarios such as <em><strong>finding a pair that sums to a target or reversing an array or string</strong></em>. In the two simple two pointers technique, two pointers &ndash; typically labeled &ldquo;left&rdquo; and &ldquo;right&rdquo; &ndash; are initialized and move in a specific direction based on the problem&rsquo;s requirements.</p>
</blockquote>
<h2 id="two-sum-ii---input-array-is-sorted">Two Sum II - Input Array Is Sorted<a hidden class="anchor" aria-hidden="true" href="#two-sum-ii---input-array-is-sorted">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement</strong></p>
<p>Given a 1-indexed array of integers, <code>numbers</code>, sorted in non-decreasing order, find two numbers that add up to a specific target. Let these two numbers be <code>numbers[index1]</code> and <code>numbers[index2]</code>, where <code>1 &lt;= index1 &lt; index2 &lt;= numbers.length</code>.</p>
<p>Return the indices of the two numbers, <code>index1</code> and <code>index2</code>, incremented by one, as an integer array <code>[index1, index2]</code> of length 2.</p>
<ul>
<li>The problem guarantees that there is exactly one solution.</li>
<li>You may not use the same element twice.</li>
<li>Your solution must use only constant extra space.</li>
</ul>
<p><strong>Example 1:</strong></p>
<ul>
<li><strong>Input</strong>: <code>numbers = [2,7,11,15], target = 9</code></li>
<li><strong>Output</strong>: <code>[1, 2]</code></li>
<li><strong>Explanation</strong>: The sum of 2 and 7 is 9, so <code>index1 = 1</code>, <code>index2 = 2</code>. We return <code>[1, 2]</code>.</li>
</ul>
<p><strong>Example 2:</strong></p>
<ul>
<li><strong>Input</strong>: <code>numbers = [2,3,4], target = 6</code></li>
<li><strong>Output</strong>: <code>[1, 3]</code></li>
<li><strong>Explanation</strong>: The sum of 2 and 4 is 6, so <code>index1 = 1</code>, <code>index2 = 3</code>. We return <code>[1, 3]</code>.</li>
</ul>
<p><strong>Example 3:</strong></p>
<ul>
<li><strong>Input</strong>: <code>numbers = [-1,0], target = -1</code></li>
<li><strong>Output</strong>: <code>[1, 2]</code></li>
<li><strong>Explanation</strong>: The sum of -1 and 0 is -1, so <code>index1 = 1</code>, <code>index2 = 2</code>. We return <code>[1, 2]</code>.</li>
</ul>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>2 &lt;= numbers.length &lt;= 30,000</code></li>
<li><code>-1000 &lt;= numbers[i] &lt;= 1000</code></li>
<li><code>numbers</code> is sorted in non-decreasing order.</li>
<li><code>-1000 &lt;= target &lt;= 1000</code></li>
<li>There is exactly one solution for each test case.</li>
</ul>
<hr>

</details></p>


<a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted" target="_blank">
Go to Leetcode üîó
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int left = 0, right = numbers.length - 1;

        // Iterate while left pointer is before right pointer
        while (left < right) {
            int currentSum = numbers[left] + numbers[right];

            // Check if the current sum matches the target
            if (currentSum == target) {
                break;
            }

            // Adjust the pointers to move towards the target sum
            if (currentSum < target) { 
                left++; // Increase sum by moving left pointer right
            } else { 
                right--; // Decrease sum by moving right pointer left
            }
        }

        // Reture 1-indexed result
        return new int[] { left + 1, right + 1 }; 
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW NOTES</summary>
  <p><strong>Algorithm Walkthrough</strong></p>
<ul>
<li><code>nums = [1, 2, 3, 4, 5, 8]</code></li>
<li><code>target = 7</code></li>
</ul>
<ol>
<li><strong>Initialize pointers</strong>: <code>left = 0, right = 5</code></li>
<li><strong>First iteration</strong>:
<ul>
<li><code>currentSum = 1 + 8 = 9</code> (greater than the target)</li>
<li>Decrease the <code>right</code> pointer to <code>4</code></li>
</ul>
</li>
<li><strong>Second iteration</strong>:
<ul>
<li><code>currentSum = 1 + 5 = 6</code> (less than the target)</li>
<li>Increase the <code>left</code> pointer to <code>1</code></li>
</ul>
</li>
<li><strong>Third iteration</strong>:
<ul>
<li><code>currentSum = 2 + 4 = 6</code> (equals the target)</li>
<li>Return the indices <code>[1, 3]</code>.</li>
</ul>
</li>
</ol>
<p><strong>Visualization</strong></p>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/1-find-a-pair-sums-to-the-target.png" alt="Two Sum II - Input Array Is Sorted"  />
</p>

</details></p>

<hr>
<h2 id="3sum">3Sum<a hidden class="anchor" aria-hidden="true" href="#3sum">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement</strong></p>
<p>Given an integer array <code>nums</code>, return all unique triplets <code>[nums[i], nums[j], nums[k]]</code> such that:</p>
<ul>
<li><code>i != j</code>, <code>i != k</code>, and <code>j != k</code></li>
<li><code>nums[i] + nums[j] + nums[k] == 0</code></li>
</ul>
<p>The solution set must not contain duplicate triplets.</p>
<hr>
<p><strong>Example 1:</strong></p>
<ul>
<li><strong>Input</strong>: <code>nums = [-1, 0, 1, 2, -1, -4]</code></li>
<li><strong>Output</strong>: <code>[[-1, -1, 2], [-1, 0, 1]]</code></li>
<li><strong>Explanation</strong>:
<ul>
<li><code>nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0</code></li>
<li><code>nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0</code></li>
<li><code>nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0</code></li>
</ul>
</li>
</ul>
<p>The distinct triplets are <code>[-1, 0, 1]</code> and <code>[-1, -1, 2]</code>.</p>
<p>Note: The order of the output and the order of the triplets does not matter.</p>
<p><strong>Example 2:</strong></p>
<ul>
<li><strong>Input</strong>: <code>nums = [0, 1, 1]</code></li>
<li><strong>Output</strong>: <code>[]</code></li>
<li><strong>Explanation</strong>: The only possible triplet does not sum up to 0.</li>
</ul>
<p><strong>Example 3:</strong></p>
<ul>
<li><strong>Input</strong>: <code>nums = [0, 0, 0]</code></li>
<li><strong>Output</strong>: <code>[[0, 0, 0]]</code></li>
<li><strong>Explanation</strong>: The only possible triplet sums up to 0.</li>
</ul>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>3 &lt;= nums.length &lt;= 3000</code></li>
<li><code>10^5 &lt;= nums[i] &lt;= 10^5</code></li>
</ul>
<hr>

</details></p>


<a href="https://leetcode.com/problems/3sum" target="_blank">
Go to Leetcode üîó
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> triplets = new ArrayList<>();

        // Sort the array to enable the two-pointer approach
        Arrays.sort(nums);

        for (int i = 0; i < nums.length - 2; i++) {
            // Skip duplicates for 'i' to ensure unique triplets
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }

            // Find pairs that sum up to the negative of the current number
            findTwoSum(nums, -nums[i], i + 1, nums.length - 1, triplets);
        }

        return triplets;
    }

    private static void findTwoSum(int[] nums, int target, int left, int right, List<List<Integer>> triplets) {
        while (left < right) {
            int currentSum = nums[left] + nums[right];
            if (target == currentSum) {
                triplets.add(Arrays.asList(-target, nums[left], nums[right]));
                left++;
                right--;

                // Skip duplicates for 'left' and 'right' to avoid duplicate triplets
                while (left < right && nums[left] == nums[left - 1]) {
                    left++;
                }
                while (left < right && nums[right] == nums[right + 1]) {
                    right--;
                }
            } else if (currentSum < target) {
                // Move 'left' pointer to the right to increase the sum
                left++;
            } else {
                // Move 'right' pointer to the left to decrease the sum
                right--;
            }
        }
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW NOTES</summary>
  <p><strong>Algorithm Walkthrough:</strong></p>
<ol>
<li><strong>Initialization:</strong> <code>[2, -1, -2, 3, -5]</code></li>
<li><strong>Sort the Array:</strong>
<ul>
<li><strong>Input:</strong> <code>[2, -1, -2, 3, -5]</code></li>
<li><strong>Sorted:</strong> <code>[-5, -2, -1, 2, 3]</code></li>
</ul>
</li>
<li><strong>Iteration:</strong>
<ul>
<li><strong>Iteration 1:</strong>
<ul>
<li>Fix <code>-5</code> (at index 0), left pointer at <code>-2</code> (index 1), right pointer at <code>3</code> (index 4):</li>
<li><strong>Target Sum:</strong> <code>-(-5) = 5</code></li>
<li><strong>Sum =</strong> <code>-2 + 3 = 1</code> (less than targetSum), move left pointer to <code>-1</code> (index 2)</li>
<li><strong>Sum =</strong> <code>-1 + 3 = 2</code> (less than targetSum), move left pointer to <code>2</code> (index 3)</li>
<li><strong>Sum =</strong> <code>2 + 3 = 5</code>, found triplet <code>[-5, 2, 3]</code></li>
<li><strong>Move left pointer to 4</strong> and right pointer to 3 (end of this iteration).</li>
</ul>
</li>
<li><strong>Iteration 2:</strong>
<ul>
<li>Fix <code>-2</code> (at index 1), left pointer at <code>-1</code> (index 2), right pointer at <code>3</code> (index 4):</li>
<li><strong>Target Sum:</strong> <code>-(-2) = 2</code></li>
<li><strong>Sum =</strong> <code>-1 + 3 = 2</code>, found triplet <code>[-2, -1, 3]</code></li>
<li><strong>Move left pointer to 2</strong> and right pointer to 3 (end of this iteration).</li>
</ul>
</li>
<li><strong>Iteration 3:</strong> Fix <code>-1</code> (at index 2), left pointer at <code>2</code> (index 3), right pointer at <code>3</code> (index 4):
<ul>
<li><strong>Target Sum:</strong> <code>-(-1) = 1</code></li>
<li><strong>Sum =</strong> <code>2 + 3 = 5</code> (greater than targetSum), move right pointer to <code>2</code> (end of this iteration).</li>
</ul>
</li>
<li><strong>End of Loop:</strong> All elements are processed.</li>
</ul>
</li>
<li><strong>Result:</strong> <code>[[ -5, 2, 3], [ -2, -1, 3]]</code></li>
</ol>
<hr>
<p><strong>Visulization:</strong></p>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/1-2-3sum.png" alt="3Sum"  />
</p>

</details></p>

<hr>
<h1 id="fast--slow-pointers">Fast &amp; Slow Pointers<a hidden class="anchor" aria-hidden="true" href="#fast--slow-pointers">#</a></h1>
<blockquote>
<p>The <strong>Fast and Slow Pointers</strong> pattern, also known as the <strong>Tortoise and Hare Algorithm</strong>, invloves using two pointers that move at different speeds over an array or linked list. It is commonly used to solve problems related to cycle detection or finding the middle element in linked lists or arrays.</p>
</blockquote>
<h2 id="linked-list-cycle">Linked List Cycle<a hidden class="anchor" aria-hidden="true" href="#linked-list-cycle">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement</strong></p>
<p>Given the head of a singly linked list, write a function to determine whether the list contains a cycle.</p>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/2-linked-list-cycle.webp" alt="Liked List Cycle"  />
</p>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the list is between 0 and 10,000.</li>
<li>Node values are in the range of [-10^5, 10^5].</li>
</ul>

</details></p>


<a href="https://leetcode.com/problems/linked-list-cycle" target="_blank">
Go to Leetcode üîó
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        // Initialize slow and fast pointers at the head of the list
        ListNode slow = head, fast = head;

        // Traverse the list with fast and slow pointers
        while (fast != null && fast.next != null) {
            // Move slow pointer by one step and fast pointer by two steps
            slow = slow.next;
            fast = fast.next.next;

            // If the two pointers meet, a cycle is detected
            if (slow == fast) {
                return true;
            }
        }

        // If fast pointer reaches the end, there's no cycle
        return false;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW NOTES</summary>
  <blockquote>
<p>The fast and slow pointers start from the same point. The fast pointer moves two steps at a time, while the slow pointer moves one step at a time. If the linked list has no cycle, the fast pointer will reach the end before the slow pointer. If the linked list has a cycle, the fast pointer will enter the cycle first, and both pointers will continue moving in the cycle. Eventually, they will meet at some point, indicating the presence of a cycle. There are two possible scenerios when both pointers are in the cycle:</p>
</blockquote>
<ol>
<li>The fast pointer is one step behind the slow pointer.</li>
<li>The fast pointer is two steps behind the slow pointer.</li>
</ol>
<blockquote>
<p>In scenerio 1, after the next move, the two pointers will meet at the same position. This is the condition that confirms the presence of a cycle, as shown in the following illustration.</p>
</blockquote>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/3-linked-list-cycle-2.webp" alt="Linked List Cycle: Slow &amp;amp; Fast Pointer"  />
</p>

</details></p>

<hr>
<h2 id="middle-of-the-linkedlist">Middle of the LinkedList<a hidden class="anchor" aria-hidden="true" href="#middle-of-the-linkedlist">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement</strong></p>
<p>Given the head of a singly linked list, write a method to return the middle node of the linked list.</p>
<p>If the total number of nodes in the list is even, return the second middle node.</p>
<p><strong>Example 1:</strong></p>
<ul>
<li><strong>Input</strong>: 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5 ‚Üí null</li>
<li><strong>Output</strong>: 3</li>
</ul>
<p><strong>Example 2:</strong></p>
<ul>
<li><strong>Input</strong>: 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5 ‚Üí 6 ‚Üí null</li>
<li><strong>Output</strong>: 4</li>
</ul>
<p><strong>Example 3:</strong></p>
<ul>
<li><strong>Input</strong>: 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5 ‚Üí 6 ‚Üí 7 ‚Üí null</li>
<li><strong>Output</strong>: 4</li>
</ul>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the list is between 1 and 100.</li>
<li>Node values are between 1 and 100.</li>
</ul>

</details></p>


<a href="https://leetcode.com/problems/middle-of-the-linked-list" target="_blank">
Go to Leetcode üîó
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode middleNode(ListNode head) {
        // Initialize slow and fast pointers at the head of the list
        ListNode slow = head, fast = head;
        
        while (fast != null && fast.next != null) {
            slow = slow.next;          // Move slow pointer by one step
            fast = fast.next.next;     // Move fast pointer by two steps
        }

        // When fast pointer reaches the end, slow pointer will be at the middle
        return slow;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW NOTES</summary>
  <p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/4-middle-of-linked-list.svg" alt="Middle of Linked List"  />
</p>
<hr>
<p>If the total number of nodes in the list is even, return <strong>the first middle node</strong>, then</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">while</span> (fast <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> fast.<span style="color:#a6e22e">next</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>    fast <span style="color:#f92672">=</span> fast.<span style="color:#a6e22e">next</span>.<span style="color:#a6e22e">next</span>;     <span style="color:#75715e">// Move fast pointer by two steps</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (fast <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    slow <span style="color:#f92672">=</span> slow.<span style="color:#a6e22e">next</span>;          <span style="color:#75715e">// Move slow pointer by one step</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
</details></p>

<hr>
<h2 id="remove-nth-node-from-end-of-list">Remove Nth Node From End of List<a hidden class="anchor" aria-hidden="true" href="#remove-nth-node-from-end-of-list">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement</strong></p>
<p>Given the head of a singly linked list, remove the nth node from the end of the list and return the head of the updated list.</p>
<p><strong>Example 1:</strong></p>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/5-remove-nth-node-from-end-of-list.jpg" alt="Remove Nth Node From End of List"  />
</p>
<ul>
<li><strong>Input</strong>: head = [1, 2, 3, 4, 5], n = 2</li>
<li><strong>Output</strong>: [1, 2, 3, 5]</li>
</ul>
<p><strong>Example 2:</strong></p>
<ul>
<li><strong>Input</strong>: head = [1], n = 1</li>
<li><strong>Output</strong>: []</li>
</ul>
<p><strong>Example 3:</strong></p>
<ul>
<li><strong>Input</strong>: head = [1, 2], n = 1</li>
<li><strong>Output</strong>: [1]</li>
</ul>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the list is between 1 and 10^5.</li>
<li>1 &lt;= n &lt;= the number of nodes in the list.</li>
</ul>

</details></p>


<a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list" target="_blank">
Go to Leetcode üîó
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // Create a dummy node to handle edge cases (e.g., removing the head)
        ListNode dummy = new ListNode(0);
        dummy.next = head;

        // Initialize slow and fast pointers at the dummy node
        ListNode slow = dummy, fast = dummy;

        // Move the fast pointer n+1 steps ahead from the dummy node
        for (int i = 0; i <= n; i++) {
            fast = fast.next;
        }

        // Move both slow and fast pointers one step at a time until fast reaches the
        // end
        while (fast != null) {
            slow = slow.next;
            fast = fast.next;
        }

        // Remove the nth node from the end by skipping it
        slow.next = slow.next.next;

        // Return the updated head
        return dummy.next;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW NOTES</summary>
  <blockquote>
<p>The goal is to remove the nth node from the end of the list. The first step in solving this problem is to determine the position of the nth node from the end. This can be achieved using the <strong>slow and fast pointers</strong> techique. Initially, two pointer, <code>slow</code> and <code>fast</code>, are both set to the head of the list. The <code>fast</code> pointer is then moved <code>n</code> steps ahead from the head node.</p>
</blockquote>
<blockquote>
<p>Once the <code>fast</code> pointer is <code>n</code> steps ahead, both the <code>slow</code> and <code>fast</code> pointers move one step at a time simultaneously. When the <code>fast</code> pointer reaches the end of the list, the <code>slow</code> pointer will be positioned at the nth node from the end. Since the task is to remove this node, the node before it must be idetified.</p>
</blockquote>
<blockquote>
<p>However, handling the edge case where the node to be removed is the head node requires special attention. To address this issue, a <strong>dummy node</strong> is introduced. The dummy node points to the head of the list, ensuring that there is always a valid node before the one to be deleted, even if the head node itself is the target.</p>
</blockquote>
<blockquote>
<p>To find the node just before the nth node from the end, the <code>fast</code> pointer is moved <code>n+1</code> steps ahead from the dummy node. This places the <code>fast</code> pointer <code>n+1</code> steps ahead of the <code>slow</code> pointer. Both pointers are then moved one step at a time until the fast pointer reaches the end of the list. At this point, the <code>slow</code> pointer will be positioned just before the nth node from the end.</p>
</blockquote>
<blockquote>
<p>The removal of the nth node is accomplished by updating the <code>slow</code> pointer&rsquo;s next reference <code>slow.next = slow.next.next;</code>. When the node to be removed is the head, the <code>slow</code> pointer remains at the dummy node without moving. After executing <code>slow.next = slow.next.next;</code>, the node after the dummy node becomes the new head of the list.</p>
</blockquote>
<hr>
<p><strong>Illustration</strong></p>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/6-remove-nth-node-from-end-of-list.png" alt="Remove Nth Node From End of List"  />
</p>
<hr>
<p><strong>Illustration: Remove Head Node</strong></p>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/7-remove-head-node-from-end-of-list.png" alt="Remove Nth Node From End of List: Remove Head Node"  />
</p>

</details></p>

<hr>
<h1 id="sliding-window">Sliding Window<a hidden class="anchor" aria-hidden="true" href="#sliding-window">#</a></h1>
<blockquote>
<p>The <strong>Sliding Window Pattern</strong> is a technique used to solve problems involving arrays or sequences when computing something over a <em><strong>continguous subarray or subsequence</strong></em> is required. There are two types of sliding window: fixed-size and dynamic. The fixed-size window involves calculating something over a contiguous subarray of a given size, while the dynamic window adjusts its size based on specific constraints to handle problems over a contiguous subarray or subsequence. The key to solving sliding window problems is <em><strong>determining when to shrink the window size</strong></em>.</p>
</blockquote>
<h2 id="maximum-sum-subarray-of-size-k">Maximum Sum Subarray of Size K<a hidden class="anchor" aria-hidden="true" href="#maximum-sum-subarray-of-size-k">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement</strong></p>
<p>Given an array of positive numbers and a positive integer <code>k</code>, find the maximum sum of any contiguous subarray of size <code>k</code>.</p>
<hr>
<p><strong>Example 1:</strong></p>
<ul>
<li>
<p><strong>Input:</strong><br>
<code>arr = [2, 1, 5, 1, 3, 2]</code>, <code>k = 3</code></p>
</li>
<li>
<p><strong>Output:</strong><br>
<code>9</code></p>
</li>
<li>
<p><strong>Explanation:</strong><br>
The subarray with the maximum sum is <code>[5, 1, 3]</code>, which has a sum of 9.</p>
</li>
</ul>
<p><strong>Example 2:</strong></p>
<ul>
<li>
<p><strong>Input:</strong><br>
<code>arr = [2, 3, 4, 1, 5]</code>, <code>k = 2</code></p>
</li>
<li>
<p><strong>Output:</strong><br>
<code>7</code></p>
</li>
<li>
<p><strong>Explanation:</strong><br>
The subarray with the maximum sum is <code>[3, 4]</code>, which has a sum of 7.</p>
</li>
</ul>
<hr>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >public class Solution {
    public int findMaxSumSubArray(int k, int[] arr) {
        int windowStart = 0;
        int windowSum = 0, maxSum = Integer.MIN_VALUE;
        for (int windowEnd = 0; windowEnd < arr.length; windowEnd++) {
            windowSum += arr[windowEnd]; // Update the window sum

            // Iterate the array to expand the window
            if (windowEnd >= k - 1) {
                maxSum = Math.max(windowSum, maxSum); // Update the maximum sum
                windowSum -= arr[windowStart]; // Remove the element going out of the window
                windowStart++; // Shink the window
            }
        }

        return maxSum;
    }

    public static void main(String[] args) {
        Solution sol = new Solution();
        System.out.println("Maximum sum of a subarray of size K: "
                + sol.findMaxSumSubArray(3, new int[]{2, 1, 5, 1, 3, 2}));
        System.out.println("Maximum sum of a subarray of size K: "
                + sol.findMaxSumSubArray(2, new int[]{2, 3, 4, 1, 5}));
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW OUTPUT</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Output</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-bash" data-lang="bash" >Maximum sum of a subarray of size K: 9
Maximum sum of a subarray of size K: 7
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW NOTES</summary>
  <p><strong>Algorithm Walkthrough</strong></p>
<ul>
<li><code>arr = [2, 1, 5, 1, 3, 2]</code></li>
<li><code>k = 3</code></li>
</ul>
<ol>
<li><strong>Initialization:</strong>
<ul>
<li><code>windowSum = 0</code></li>
<li><code>maxSum = 0</code></li>
<li><code>windowStart = 0</code></li>
</ul>
</li>
<li><strong>Iteration:</strong>
<ul>
<li><strong>windowEnd = 0</strong>: Add <code>arr[0]</code> (2) to <code>windowSum</code>: <code>windowSum = 2</code></li>
<li><strong>windowEnd = 1</strong>: Add <code>arr[1]</code> (1) to <code>windowSum</code>: <code>windowSum = 3</code></li>
<li><strong>windowEnd = 2</strong>:  Add <code>arr[2]</code> (5) to <code>windowSum</code>: <code>windowSum = 8</code>
<ul>
<li>Since <code>windowEnd &gt;= k - 1</code>:</li>
<li>Update <code>maxSum = Math.max(0, 8) = 8</code></li>
<li>Subtract <code>arr[0] = 2</code> from <code>windowSum</code>: <code>windowSum = 6</code></li>
<li>Increment <code>windowStart</code>: <code>windowStart = 1</code></li>
</ul>
</li>
<li><strong>windowEnd = 3</strong>: Add <code>arr[3]</code> (1) to <code>windowSum</code>: <code>windowSum = 7</code>
<ul>
<li>Since <code>windowEnd &gt;= k - 1</code>:</li>
<li>Update <code>maxSum = Math.max(8, 7) = 8</code></li>
<li>Subtract <code>arr[1] = 1</code> from <code>windowSum</code>: <code>windowSum = 6</code></li>
<li>Increment <code>windowStart</code>: <code>windowStart = 2</code></li>
</ul>
</li>
<li><strong>windowEnd = 4</strong>: Add <code>arr[4]</code> (3) to <code>windowSum</code>: <code>windowSum = 9</code>
<ul>
<li>Since <code>windowEnd &gt;= k - 1</code>:</li>
<li>Update <code>maxSum = Math.max(8, 9) = 9</code></li>
<li>Subtract <code>arr[2] = 5</code> from <code>windowSum</code>: <code>windowSum = 4</code></li>
<li>Increment <code>windowStart</code>: <code>windowStart = 3</code></li>
</ul>
</li>
<li><strong>windowEnd = 5</strong>: Add <code>arr[5]</code> (2) to <code>windowSum</code>: <code>windowSum = 6</code>
<ul>
<li>Since <code>windowEnd &gt;= k - 1</code>:</li>
<li>Update <code>maxSum = Math.max(9, 6) = 9</code></li>
<li>Subtract <code>arr[3] = 1</code> from <code>windowSum</code>: <code>windowSum = 5</code></li>
<li>Increment <code>windowStart</code>: <code>windowStart = 4</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>Result:</strong> The final <code>maxSum</code> is 9, which is the maximum sum of any subarray of size <code>k = 3</code>.</li>
</ol>
<hr>
<p><strong>Visualization</strong></p>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/8-maximum-sum-subarray-of-size-k.webp" alt="Maximum Sum Subarray of Size K"  />
</p>

</details></p>

<hr>
<h2 id="longest-substring-with-at-most-k-distinct-characters">Longest Substring with At Most K Distinct Characters<a hidden class="anchor" aria-hidden="true" href="#longest-substring-with-at-most-k-distinct-characters">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement</strong></p>
<p>Given a string, find the length of the longest substring that contains no more than <code>K</code> distinct characters.</p>
<p>It is guaranteed that <code>K</code> will be less than or equal to the length of the given string.</p>
<hr>
<p><strong>Example 1:</strong></p>
<ul>
<li><strong>Input:</strong> <code>String = &quot;araaci&quot;</code>, <code>K = 2</code></li>
<li><strong>Output:</strong> <code>4</code></li>
<li><strong>Explanation:</strong> The longest substring with no more than 2 distinct characters is <code>&quot;araa&quot;</code>.</li>
</ul>
<p><strong>Example 2:</strong></p>
<ul>
<li><strong>Input:</strong> <code>String = &quot;araaci&quot;</code>, <code>K = 1</code></li>
<li><strong>Output:</strong> <code>2</code></li>
<li><strong>Explanation:</strong> The longest substring with no more than 1 distinct character is <code>&quot;aa&quot;</code>.</li>
</ul>
<p><strong>Example 3:</strong></p>
<ul>
<li><strong>Input:</strong> <code>String = &quot;cbbebi&quot;</code>, <code>K = 3</code></li>
<li><strong>Output:</strong> <code>5</code></li>
<li><strong>Explanation:</strong> The longest substrings with no more than 3 distinct characters are <code>&quot;cbbeb&quot;</code> and <code>&quot;bbebi&quot;</code>.</li>
</ul>
<hr>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= str.length &lt;= 50,000</code></li>
<li><code>0 &lt;= K &lt;= 50</code></li>
</ul>
<hr>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.HashMap;
import java.util.Map;

class Solution {
    public int findLength(String str, int k) {
        Map&lt;Character, Integer&gt; charFrequencyMap = new HashMap&lt;&gt;();
        int windowStart = 0;
        int maxLength = 0;

        // Iterate the char sequence to expand the window
        for (int windowEnd = 0; windowEnd < str.length(); windowEnd++) {
            char endChar = str.charAt(windowEnd);
            charFrequencyMap.put(endChar, charFrequencyMap.getOrDefault(endChar, 0) + 1);

            // Shrink the window if there are more than 'k' distinct characters
            while (charFrequencyMap.size() > k) {
                char startChar = str.charAt(windowStart);
                charFrequencyMap.put(startChar, charFrequencyMap.get(startChar) - 1);
                if (charFrequencyMap.get(startChar) == 0) {
                    charFrequencyMap.remove(startChar);
                }
                windowStart++; // Shrink the window
            }

            // Update the maximum length of the valid substring found
            maxLength = Math.max(maxLength, windowEnd - windowStart + 1);
        }

        return maxLength;
    }

    public static void main(String[] args) {
        Solution sol = new Solution();
        System.out.println("Length of the longest substring: "
                + sol.findLength("araaci", 2));
        System.out.println("Length of the longest substring: "
                + sol.findLength("araaci", 1));
        System.out.println("Length of the longest substring: "
                + sol.findLength("cbbebi", 3));
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW NOTES</summary>
  <p><strong>Algorithm Walkthrough:</strong></p>
<ul>
<li><code>str = &quot;araaci&quot;</code></li>
<li><code>K = 2</code></li>
</ul>
<ol>
<li><strong>Initialize:</strong> <code>windowStart = 0</code>, <code>windowEnd = 0</code></li>
<li><strong>Iteration:</strong>
<ul>
<li><strong>windowEnd = 0</strong>
<ul>
<li>Add <code>'a'</code> to the hash map: <code>{'a': 1}</code></li>
<li>Maximum length = <code>1</code></li>
</ul>
</li>
<li><strong>windowEnd = 1</strong>
<ul>
<li>Add <code>'r'</code> to the hash map: <code>{'a': 1, 'r': 1}</code></li>
<li>Maximum length = <code>2</code></li>
</ul>
</li>
<li><strong>windowEnd = 2</strong>
<ul>
<li>Add <code>'a'</code> to the hash map: <code>{'a': 2, 'r': 1}</code></li>
<li>Maximum length = <code>3</code></li>
</ul>
</li>
<li><strong>windowEnd = 3</strong>
<ul>
<li>Add <code>'a'</code> to the hash map: <code>{'a': 3, 'r': 1}</code></li>
<li>Maximum length = <code>4</code></li>
</ul>
</li>
<li><strong>windowEnd = 4</strong>
<ul>
<li>Add <code>'c'</code> to the hash map: <code>{'a': 3, 'r': 1, 'c': 1}</code></li>
<li>Since the hash map has more than <code>K = 2</code> distinct characters, shrink the window from the left:</li>
<li>Remove one <code>'a'</code>: <code>{'a': 2, 'r': 1, 'c': 1}</code></li>
<li>Move <code>windowStart = 1</code></li>
<li>Remove one <code>'r'</code>: <code>{'a': 2, 'c': 1}</code></li>
<li>Move <code>windowStart = 2</code></li>
<li>Maximum length = <code>4</code></li>
</ul>
</li>
<li><strong>windowEnd = 5</strong>
<ul>
<li>Add <code>'i'</code> to the hash map: <code>{'a': 2, 'c': 1, 'i': 1}</code></li>
<li>Since the hash map has more than <code>K = 2</code> distinct characters, shrink the window from the left:</li>
<li>Remove one <code>'a'</code>: <code>{'a': 1, 'c': 1, 'i': 1}</code></li>
<li>Move <code>windowStart = 3</code></li>
<li>Remove one <code>'a'</code>: <code>{'c': 1, 'i': 1}</code></li>
<li>Move <code>windowStart = 4</code></li>
<li>Maximum length = <code>4</code></li>
</ul>
</li>
</ul>
</li>
<li>Result: The maximum length of the substring with at most 2 distinct characters is <strong>4</strong>.</li>
</ol>
<hr>
<p><strong>Visulization</strong></p>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/9-logest-substring-with-at-most-k-distinct-characters.png" alt="Longest Substring with At Most K Distinct Characters"  />
</p>

</details></p>

<hr>
<h1 id="merge-intervals">Merge Intervals<a hidden class="anchor" aria-hidden="true" href="#merge-intervals">#</a></h1>
<blockquote>
<p>The <strong>Merge Interval Pattern</strong> is a technique used to solve problems involving a list of intervals, where each interval is represented by a pair $[\text{start}_i, \text{end}_i]$. Common tasks following this pattern include merging overlapping intervals, inserting a new interval into an existing list, or finding the intersection of two interval lists.</p>
</blockquote>
<blockquote>
<p>To solve problems related to the merge interval pattern, the first step is to understand how two disjoint intervals can relate to each other. Given two intervals &ldquo;a&rdquo; and &ldquo;b&rdquo;, there are six possible relationships between them, as illustrated in the following image.</p>
</blockquote>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/11-merge-interval-pattern.png" alt="Merge Interval Pattern"  />
</p>
<blockquote>
<p>Assuming <code>a.start &lt;= b.start</code> (which can be achieved by sorting the intervals based on their starting points), there are only four possible scenatios:</p>
</blockquote>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/12-merge-interval-altb.png" alt="Merge Interval Pattern: a.start &amp;lt;= b.start"  />
</p>
<blockquote>
<p>By observing the above image, for two intervals to overlap, the condition <code>a.start &lt;= b.start &amp;&amp; b.start &lt;= a.end</code> must hold true. In this case, the merged interval becomes $[\text{a.start}, \text{max}\{\text{a.end, b.end}\}]$.</p>
</blockquote>
<h2 id="merge-intervals-1">Merge Intervals<a hidden class="anchor" aria-hidden="true" href="#merge-intervals-1">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement</strong></p>
<p>Given a list of intervals, merge all overlapping intervals to produce a list of mutually exclusive intervals.</p>
<hr>
<p><strong>Example 1:</strong></p>
<ul>
<li><strong>Input</strong>: <code>[[1, 4], [2, 5], [7, 9]]</code></li>
<li><strong>Output</strong>: <code>[[1, 5], [7, 9]]</code></li>
<li><strong>Explanation</strong>: The first two intervals <code>[1, 4]</code> and <code>[2, 5]</code> overlap, so they are merged into one interval <code>[1, 5]</code>.</li>
</ul>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/10-merge-interval.png" alt="Merge Intervals"  />
</p>
<p><strong>Example 2:</strong></p>
<ul>
<li><strong>Input</strong>: <code>[[6, 7], [2, 4], [5, 9]]</code></li>
<li><strong>Output</strong>: <code>[[2, 4], [5, 9]]</code></li>
<li><strong>Explanation</strong>: The intervals <code>[6, 7]</code> and <code>[5, 9]</code> overlap, so they are merged into <code>[5, 9]</code>.</li>
</ul>
<p><strong>Example 3:</strong></p>
<ul>
<li><strong>Input</strong>: <code>[[1, 4], [2, 6], [3, 5]]</code></li>
<li><strong>Output</strong>: <code>[[1, 6]]</code></li>
<li><strong>Explanation</strong>: All the given intervals overlap, so they are merged into one interval <code>[1, 6]</code>.</li>
</ul>
<hr>
<p><strong>Constraints:</strong></p>
<ul>
<li>$1 &lt;= \text{intervals.length} &lt;= 10^4$</li>
<li>$\text{intervals[i].length} == 2$</li>
<li>$0 &lt;= \text{start}_i &lt;= \text{end}_i &lt;= 10^4$</li>
</ul>
<hr>

</details></p>


<a href="https://leetcode.com/problems/merge-intervals" target="_blank">
Go to Leetcode üîó
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int[][] merge(int[][] intervals) {
        // Sort intervals by their start point
        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);

        // List to store merged intervals
        List<int[]> mergedIntervals = new ArrayList<>();

        // Initialize the first interval as the current interval
        mergedIntervals.add(intervals[0]);

        // Iterate through the intervals
        for (int i = 1; i < intervals.length; i++) {
            int[] currentInterval = mergedIntervals.get(mergedIntervals.size() - 1);
            int[] nextInterval = intervals[i];

            // If the next interval overlaps with the current interval
            if (nextInterval[0] <= currentInterval[1]) {
                // Merge by updating the end point of the current interval
                currentInterval[1] = Math.max(currentInterval[1], nextInterval[1]);
            } else {
                // No overlap, add the next interval as a new interval
                mergedIntervals.add(nextInterval);
            }
        }

        // Convert the list to a 2D array and return
        return mergedIntervals.toArray(new int[mergedIntervals.size()][]);
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW NOTES</summary>
  <p><strong>Algorithm Walkthrough</strong></p>
<ul>
<li><strong>Input</strong>: <code>[[1, 4], [2, 5], [7, 9]]</code></li>
</ul>
<ol>
<li>
<p><strong>Sort Intervals</strong>:</p>
<ul>
<li><strong>Original intervals</strong>: <code>[[1, 4], [2, 5], [7, 9]]</code></li>
<li><strong>Sorted intervals</strong>: <code>[[1, 4], [2, 5], [7, 9]]</code> (already sorted)</li>
</ul>
</li>
<li>
<p><strong>Initialize Merged List</strong>:</p>
<ul>
<li><code>mergedIntervals = [[1, 4]]</code></li>
</ul>
</li>
<li>
<p><strong>Iterate Through Intervals</strong>:</p>
<ul>
<li>
<p><strong>First Iteration</strong>:</p>
<ul>
<li><strong>Current interval</strong>: <code>[1, 4]</code></li>
<li><strong>Next interval</strong>: <code>[2, 5]</code></li>
<li><strong>Check overlap</strong>: <code>2 &lt;= 4</code> (True)</li>
<li><strong>Merged intervals</strong>: <code>[[1, 5]]</code></li>
</ul>
</li>
<li>
<p><strong>Second Iteration</strong>:</p>
<ul>
<li><strong>Current interval</strong>: <code>[1, 5]</code></li>
<li><strong>Next interval</strong>: <code>[7, 9]</code></li>
<li><strong>Check overlap</strong>: <code>7 &lt;= 5</code> (False)</li>
<li><strong>Merged intervals</strong>: <code>[[1, 5], [7, 9]]</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Result</strong>:</p>
<ul>
<li><strong>Result</strong>: <code>[[1, 5], [7, 9]]</code></li>
</ul>
</li>
</ol>
<p><strong>Visulization</strong></p>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/13-merge-intervals.png" alt="Merge Intervals"  />
</p>

</details></p>

<hr>
<h2 id="insert-interval">Insert Interval<a hidden class="anchor" aria-hidden="true" href="#insert-interval">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement</strong></p>
<p>Given a list of non-overlapping intervals sorted by their start time, insert a given interval at the correct position and merge all overlapping intervals to produce a list of mutually exclusive intervals.</p>
<p><strong>Example 1:</strong></p>
<ul>
<li><strong>Input</strong>: <code>Intervals = [[1, 3], [5, 7], [8, 12]], New Interval = [4, 6]</code></li>
<li><strong>Output</strong>: <code>[[1, 3], [4, 7], [8, 12]]</code></li>
<li><strong>Explanation</strong>: After inserting <code>[4, 6]</code>, it overlaps with <code>[5, 7]</code>, so they are merged into <code>[4, 7]</code>.</li>
</ul>
<p><strong>Example 2:</strong></p>
<ul>
<li><strong>Input</strong>: <code>Intervals = [[1, 3], [5, 7], [8, 12]], New Interval = [4, 10]</code></li>
<li><strong>Output</strong>: <code>[[1, 3], [4, 12]]</code></li>
<li><strong>Explanation</strong>: After inserting <code>[4, 10]</code>, it overlaps with <code>[5, 7]</code> and <code>[8, 12]</code>, so they are merged into <code>[4, 12]</code>.</li>
</ul>
<p><strong>Example 3:</strong></p>
<ul>
<li><strong>Input</strong>: <code>Intervals = [[2, 3], [5, 7]], New Interval = [1, 4]</code></li>
<li><strong>Output</strong>: <code>[[1, 4], [5, 7]]</code></li>
<li><strong>Explanation</strong>: After inserting <code>[1, 4]</code>, it overlaps with <code>[2, 3]</code>, so they are merged into <code>[1, 4]</code>.</li>
</ul>
<hr>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= intervals.length &lt;= 10^4</code></li>
<li><code>intervals[i].length == 2</code></li>
<li><code>0 &lt;= start_i &lt;= end_i &lt;= 10^5</code></li>
<li><code>intervals</code> is sorted by <code>start_i</code> in ascending order.</li>
<li><code>newInterval.length == 2</code></li>
<li><code>0 &lt;= start &lt;= end &lt;= 10^5</code></li>
</ul>
<hr>

</details></p>


<a href="https://leetcode.com/problems/insert-interval" target="_blank">
Go to Leetcode üîó
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int[][] insert(int[][] intervals, int[] newInterval) {
        List&lt;int[]&gt; mergedIntervals = new ArrayList&lt;&gt;();

        int i = 0;
        // Add all intervals that ends before the new interval starts
        while (i < intervals.length && intervals[i][1] < newInterval[0]) {
            mergedIntervals.add(intervals[i]);
            i++;
        }

        // Merge the overlapping intervals with the new interval
        while (i < intervals.length && intervals[i][0] <= newInterval[1]) {
            newInterval[0] = Math.min(intervals[i][0], newInterval[0]);
            newInterval[1] = Math.max(intervals[i][1], newInterval[1]);
            i++;
        }

        // Add the merged new interval to the result list
        mergedIntervals.add(newInterval);

        // Add all intervals that don't overlap with the new interval to the result list
        while (i < intervals.length) {
            mergedIntervals.add(intervals[i]);
            i++;
        }

        // Convert the list to a 2-D array and return
        return mergedIntervals.toArray(new int[mergedIntervals.size()][]);
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW NOTES</summary>
  <blockquote>
<p>Since the interval list is sorted, the first step is to skip all intervals that satisfy the condition <code>intervals[i].end &lt; newInterval.start</code>. After that, there  are five possible ways the new interval can relate to the next interval in the list (where &ldquo;a&rdquo; represents <code>newInterval</code>, and &ldquo;b&rdquo; represents the next interval in the list), as shown in the following image.</p>
</blockquote>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/14-insert-interval.png" alt="Insert Interval"  />
</p>
<blockquote>
<p>By observing the above image, for two intervals to overlap, the condition <code>interval.start &lt;= newInterval.end</code> must hold true. In this case, the merged interval will be $[\text{min\{a.start, b.start\}}, \text{max\{a.end, b.end\}}]$.</p>
</blockquote>
<p><strong>Algorithm Walkthrough</strong></p>
<ul>
<li><strong>Intervals</strong> = <code>[[1, 3], [5, 7], [8, 12]]</code></li>
<li><strong>New Interval</strong> = <code>[4, 10]</code></li>
</ul>
<ol>
<li><strong>Initialize Merged List</strong>:<br>
<code>mergedIntervals = []</code></li>
<li><strong>Iterate Through Intervals:</strong>
<ol>
<li><strong>Process the first interval [1, 3]</strong>:</li>
</ol>
<ul>
<li>Ends before <code>[4, 10]</code> starts.</li>
<li>Add to <code>mergedIntervals</code>: <code>[[1, 3]]</code></li>
</ul>
<ol start="2">
<li><strong>Process the second interval [5, 7]</strong>:
<ul>
<li>Overlaps with <code>[4, 10]</code>.</li>
<li>No change to the new interval: <code>[4, 10] -&gt; [4, 10]</code></li>
<li>No change to <code>mergedIntervals</code>.</li>
</ul>
</li>
<li><strong>Process the third interval [8, 12]</strong>:
<ul>
<li>Overlaps with <code>[4, 10]</code>.</li>
<li>Adjust new interval: <code>[4, 10] -&gt; [4, 12]</code></li>
<li>Add the merged interval <code>[4, 12]</code> to <code>mergedIntervals</code>: <code>[[1, 3], [4, 12]]</code></li>
</ul>
</li>
</ol>
</li>
<li><strong>No more intervals left to process</strong>.</li>
<li><strong>Final merged intervals</strong>: <code>[[1, 3], [4, 12]]</code></li>
</ol>
<hr>
<p><strong>Visulization</strong></p>
<p><img loading="lazy" src="/img/algorithms/patterns/coding-patterns-for-interview-questions/14-insert-interval-2.png" alt="Insert Interval"  />
</p>

</details></p>

<hr>
<h2 id="intervals-intersection">Intervals Intersection<a hidden class="anchor" aria-hidden="true" href="#intervals-intersection">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement</strong></p>
<p>Given two lists of disjoint intervals, find their intersection. Each list is sorted by the start time of the intervals.</p>
<p><strong>Example 1:</strong></p>
<ul>
<li><strong>Input:</strong> <code>arr1 = [[1, 3], [5, 6], [7, 9]], arr2 = [[2, 3], [5, 7]]</code></li>
<li><strong>Output:</strong> <code>[[2, 3], [5, 6], [7, 7]]</code></li>
<li><strong>Explanation:</strong> The output list contains the common intervals between the two lists.</li>
</ul>
<p>Example 2:</p>
<ul>
<li><strong>Input:</strong> <code>arr1 = [[1, 3], [5, 7], [9, 12]], arr2 = [[5, 10]]</code></li>
<li><strong>Output:</strong> <code>[[5, 7], [9, 10]]</code></li>
<li><strong>Explanation:</strong> The output list contains the common intervals between the two lists.</li>
</ul>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>0 &lt;= arr1.length, arr2.length &lt;= 1000</code></li>
<li><code>arr1.length + arr2.length &gt;= 1</code></li>
<li>$0 \le \text{start}_i &lt; \text{end}_i \le 10^9$</li>
<li>$end_i &lt; \text{start}_{i+1}$ for all intervals in <code>arr1</code></li>
<li>$0 \le \text{start}_j &lt; \text{end}_j \le 10^9$</li>
<li>$end_j &lt; \text{start}_{j+1}$ for all intervals in <code>arr2</code></li>
</ul>
<hr>

</details></p>


<a href="https://leetcode.com/problems/interval-list-intersections" target="_blank">
Go to Leetcode üîó
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>



<button class="tab_btn ">Optimization</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int[][] intervalIntersection(int[][] arr1, int[][] arr2) {
        List<int[]> intersections = new ArrayList<>();
        int i = 0, j = 0;

        // Iterate over both interval lists to find all intersections
        while (i < arr1.length && j < arr2.length) {
            // Check if both intervals are overlapped
            if ((arr1[i][0] >= arr2[j][0] && arr1[i][0] <= arr2[j][1])
                    || (arr2[j][0] >= arr1[i][0] && arr2[j][0] <= arr1[i][1])) {
                
                // Store the intersection part
                intersections.add(new int[]{Math.max(arr1[i][0], arr2[j][0]),
                        Math.min(arr1[i][1], arr2[j][1])});
            }

            // Move the pointer of the interval that ends first
            if (arr1[i][1] < arr2[j][1]) {
                i++;
            } else {
                j++;
            }
        }

        // Return the intersections as a 2D array
        return intersections.toArray(new int[intersections.size()][]);
    }
}
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int[][] intervalIntersection(int[][] arr1, int[][] arr2) {
        List&lt;int[]&gt; intersections = new ArrayList&lt;&gt;();
        int i = 0, j = 0;
        
        // Iterate over both interval lists to find all intersections
        while (i < arr1.length && j < arr2.length) {
            int start = Math.max(arr1[i][0], arr2[j][0]);
            int end = Math.min(arr1[i][1], arr2[j][1]);

            // Add the intersection to the result if valid
            if (start <= end) {
                intersections.add(new int[] { start, end });
            }

            // Move the pointer of the interval that ends first
            if (arr1[i][1] < arr2[j][1]) {
                i++;
            } else {
                j++;
            }
        }

        // Return the result as a 2D array
        return intersections.toArray(new int[intersections.size()][]);
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW NOTES</summary>
  <blockquote>
<p><strong>Two Interval List</strong>: <code>arr1</code> and <code>arr2</code></p>
</blockquote>
<blockquote>
<p><strong>Pointer Initialization</strong>: Initialize two pointers <code>i</code> and <code>j</code>, both set to 0, to track the current positions in <code>arr1</code> and <code>arr2</code>, respectively.</p>
</blockquote>
<blockquote>
<p><strong>Overlapping Check</strong>: For two intervals <code>a</code> and <code>b</code> to overlap, at least one of the following conditions must hold true:</p>
</blockquote>
<ol>
<li><code>a.start &lt;= b.start &amp;&amp; b.start &lt;= a.end</code></li>
<li><code>b.start &lt;= a.start &amp;&amp; a.start &lt;= b.end</code></li>
</ol>
<blockquote>
<p><strong>Interval Calculation</strong>: If a and b overlap (follows overlapping check), the intersection is calculated as:</p>
</blockquote>
<ul>
<li>$[\text{max}\{\text{a.start, b.start}\}, \text{min}\{\text{a.end, b.end}\}]$</li>
</ul>
<blockquote>
<p><strong>Interval Caculation (Optimization)</strong>: Based on the <strong>Overlapping Check</strong> and <strong>Interval Calculation</strong>, the calculation can be optimized as follows:</p>
</blockquote>
<ol>
<li><code>maxStart = max{a.start, b.start}</code></li>
<li><code>minEnd = min{a.end, b.end}</code></li>
<li>An intersection <code>[maxStart, minEnd]</code> exists if <code>maxStart &lt;= minEnd</code></li>
</ol>
<blockquote>
<p><strong>Pointer Movement</strong>: Increment the pointer that ends first. For example, if <code>arr1[i].end &lt; arr2[j].end</code>, increment <code>i</code>; otherwise increment <code>j</code>.</p>
</blockquote>

</details></p>

<hr>
<h1 id="in-place-reversal-of-a-linked-list">In-place Reversal of a Linked List<a hidden class="anchor" aria-hidden="true" href="#in-place-reversal-of-a-linked-list">#</a></h1>
<hr>
<h1 id="hash-maps">Hash Maps<a hidden class="anchor" aria-hidden="true" href="#hash-maps">#</a></h1>
<hr>
<h1 id="prefix-sum">Prefix Sum<a hidden class="anchor" aria-hidden="true" href="#prefix-sum">#</a></h1>
<hr>
<h1 id="monotonic-stack">Monotonic Stack<a hidden class="anchor" aria-hidden="true" href="#monotonic-stack">#</a></h1>
<hr>
<hr>
<h1 id="tree-breadth-first-search">Tree Breadth First Search<a hidden class="anchor" aria-hidden="true" href="#tree-breadth-first-search">#</a></h1>
<hr>
<h1 id="tree-depth-first-search">Tree Depth First Search<a hidden class="anchor" aria-hidden="true" href="#tree-depth-first-search">#</a></h1>
<hr>
<h1 id="heading"><a hidden class="anchor" aria-hidden="true" href="#heading">#</a></h1>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://signalyu.github.io/tags/coding-patterns/">Coding Patterns</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/design-patterns/1-design-patterns/">
    <span class="title">¬´ PREV</span>
    
    <br>
    <span>Design Patterns</span>
  </a>
  <a class="next" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/algorithms/1-data-structure-and-algorithms/">
    <span class="title">NEXT ¬ª</span>
    
    <br>
    <span>Data Structure &amp; Algorithms</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://signalyu.github.io/">Signal&#39;s Blog</a></span> ¬∑ 
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>

</body>
</html>
