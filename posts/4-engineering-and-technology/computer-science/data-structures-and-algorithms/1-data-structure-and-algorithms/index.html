<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Data Structure &amp; Algorithms | Signal&#39;s Blog</title>
<meta name="keywords" content="Data Structure &amp; Algorithms">
<meta name="description" content="Recursion Recursion is a programming technique where a function repeatedly calls itself until it reaches a base case, whcih stops the recursion and allows it to return a result. It is a way of breaking down complex problems into smaller, simpler subproblems that are eaiser to solve.
Head Recursion Head Recursion is a type of recursion where a function makes its recursive call first, immediately after checking the base case, and performs all other operations only after the recursive call returns.">
<meta name="author" content="Signal Yu">
<link rel="canonical" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/1-data-structure-and-algorithms/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.9ddf6c021b47a5a861a7c6af241af938775e0fc65a762930d3a2426fc59e9a5c.css" integrity="sha256-nd9sAhtHpahhp8avJBr5OHdeD8Zadikw06JCb8Wemlw=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://signalyu.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://signalyu.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://signalyu.github.io/favicon-32x32">
<link rel="apple-touch-icon" href="https://signalyu.github.io/apple-touch-icon">
<link rel="mask-icon" href="https://signalyu.github.io/favicon.io">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/1-data-structure-and-algorithms/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css"
    integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"
    integrity="sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd"
    crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js"
    integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk"
    crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: true }
            ],
            
            throwOnError: false,
            strict: false
        });
    });
</script>

  

<meta property="og:title" content="Data Structure &amp; Algorithms" />
<meta property="og:description" content="Recursion Recursion is a programming technique where a function repeatedly calls itself until it reaches a base case, whcih stops the recursion and allows it to return a result. It is a way of breaking down complex problems into smaller, simpler subproblems that are eaiser to solve.
Head Recursion Head Recursion is a type of recursion where a function makes its recursive call first, immediately after checking the base case, and performs all other operations only after the recursive call returns." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/1-data-structure-and-algorithms/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-11-14T20:29:21+08:00" />
<meta property="article:modified_time" content="2024-11-14T20:29:21+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Data Structure &amp; Algorithms"/>
<meta name="twitter:description" content="Recursion Recursion is a programming technique where a function repeatedly calls itself until it reaches a base case, whcih stops the recursion and allows it to return a result. It is a way of breaking down complex problems into smaller, simpler subproblems that are eaiser to solve.
Head Recursion Head Recursion is a type of recursion where a function makes its recursive call first, immediately after checking the base case, and performs all other operations only after the recursive call returns."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://signalyu.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Data Structure \u0026 Algorithms",
      "item": "https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/1-data-structure-and-algorithms/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Data Structure \u0026 Algorithms",
  "name": "Data Structure \u0026 Algorithms",
  "description": "Recursion Recursion is a programming technique where a function repeatedly calls itself until it reaches a base case, whcih stops the recursion and allows it to return a result. It is a way of breaking down complex problems into smaller, simpler subproblems that are eaiser to solve.\nHead Recursion Head Recursion is a type of recursion where a function makes its recursive call first, immediately after checking the base case, and performs all other operations only after the recursive call returns.",
  "keywords": [
    "Data Structure \u0026 Algorithms"
  ],
  "articleBody": "Recursion Recursion is a programming technique where a function repeatedly calls itself until it reaches a base case, whcih stops the recursion and allows it to return a result. It is a way of breaking down complex problems into smaller, simpler subproblems that are eaiser to solve.\nHead Recursion Head Recursion is a type of recursion where a function makes its recursive call first, immediately after checking the base case, and performs all other operations only after the recursive call returns.\nSHOW CODE: Head Recursion Head Recursion void printNumbers(int n) { if (n == 0) { return; // Base case } printNumbers(n - 1); // Recursive call printf(\"%d\\n\", n); // Processing after recursion } Call Stack Operation Current Value of n headRecursion(3) Call function 3 headRecursion(2) Call function 2 headRecursion(1) Call function 1 headRecursion(0) Base case, exit 0 Unwinding begins: printf(1) Print 1 1 printf(2) Print 2 2 printf(3) Print 3 3 Tail Recursion Tail Recursion is a type of recursion where a function makes its recursive call as the last operation in its body. with no further operations after the call. This type of recursion can be optimized by the compiler into an iterative loop through tail call optimization (TCO), which help reduce memory consumption by the reusing the stack frame.\nSHOW CODE: Tail Recursion Tail Recursion void tailRecursion(int n) { if (n \u003e 0) { printf(\"%d \", n); // Operation first tailRecursion(n - 1); // Recursive call at the end } } Call Stack Operation Current Value of n tailRecursion(3) Print 3 3 tailRecursion(2) Print 2 2 tailRecursion(1) Print 1 1 tailRecursion(0) Base case, exit 0 Tail recursion is generally perfered for performance when recursion depth is large because it can be optimized into an iterative process.\nSHOW CODE: Tail Recursion Optimization Tail Recursion Optimization void tailRecursionOptimized(int n) { while (n \u003e 0) { printf(\"%d \", n); // Operation first n--; // Decrement n, same as `tailRecursion(n - 1)` } } In the above code, optimized Loop replaces recursion with a loop, ensuring only a single stack frame is used.\nConditions for Tail Recursion: The recursive call must be the last operation in the function, and its result must be immediately returned without any further computation after the call.\nSHOW CODE: Tail Recursive Function Tail Recursive Function // Tail recursive function to calculate factorial int factorialTailRecursion(int n, int accumulator) { if (n == 0) { return accumulator; // Base case: return accumulated result } return factorialTailRecursion(n - 1, accumulator * n); // Recursive call is the last operation } SHOW CODE: Non-tail Recursive Function Non-tail recursive // Non-tail recursive function to calculate factorial int factorialNonTailRecursion(int n) { if (n == 0) { return 1; // Base case } return n * factorialNonTailRecursion(n - 1); // Recursive call is not the last operation } Tree Recursion Tree recursion is a type of recursion in which a function makes multiple recursive calls to itself in its body, it creates a tree-like data structure, as each call can branch into multiple additional calls.\nSHOW CODE C public int fib(int n) { if (n \u003c= 1) { return n; } return fib(n - 1) + fib(n - 2); } Recursion Tree Analysis:\n--- title: Recursion Tree Analysis - fibonacci sequence --- graph TD L0((\"fib\\(5\\)\")) --\u003e L1((\"fib\\(4\\)\")) L0 --\u003e L2((\"fib\\(3\\)\")) L1 --\u003e L3((\"fib\\(3\\)\")) L1 --\u003e L4((\"fib\\(2\\)\")) L2 --\u003e L5((\"fib\\(2\\)\")) L2 --\u003e L6((\"fib\\(1\\)\")) L3 --\u003e L7((\"fib\\(2\\)\")) L3 --\u003e L8((\"fib\\(1\\)\")) L4 --\u003e L9((\"fib\\(1\\)\")) L4 --\u003e L10((\"fib\\(0\\)\")) L5 --\u003e L11((\"fib\\(1\\)\")) L5 --\u003e L12((\"fib\\(0\\)\")) L7 --\u003e L13((\"fib\\(1\\)\")) L7 --\u003e L14((\"fib\\(0\\)\")) Array An array is a data structure that stores a collection of elements of the same type in a fixed-size, continguous block of memory. Arrays can be categorized into two types: static arrays and dynamic arrays.\nA static array has a fixed size that cannot be changed after its declaration. Memory for a static array is allocated at compile time, and its size must be explicitly specified.\nIn contrast, a dynamic array allows its size to be adjusted during runtime, enabling it to grow or shrink as needed. Unlike static arrays, the size of a dynamic array does not need to be specified at the time of declaration, and memory is allocated dynamically from the heap.\nImplementation of Static Arrays Implementation of Dynamic Arrays Compiler’s Memory Layout for Arrays The address of an array element is determined at runtime. Array elements are stored in a continguous block of memory, and the compiler calculates each element’s address using its index and the size of each element.\n1-Dimentional Array Element Access Formula (0-based index): $\\text{Addr}_{A[i]} = B + i \\times W$\nB: Base Address i: Zero-based Index of Each Element W: Size of Each Element SHOW CODE C #include int main() { int arr[5] = {10, 20, 30, 40, 50}; for (int i = 0; i \u003c 5; i++) { void *addr_i = (void *) arr + (i * sizeof(int)); printf(\"Element at index %d: %d \\t Address: %p\\n\", i, arr[i], addr_i); } return 0; } SHOW OUTPUT Output Element at index 0: 10 Address: 0x7ff7bb0b7170 Element at index 1: 20 Address: 0x7ff7bb0b7174 Element at index 2: 30 Address: 0x7ff7bb0b7178 Element at index 3: 40 Address: 0x7ff7bb0b717c Element at index 4: 50 Address: 0x7ff7bb0b7180 2-Dimentional Array Element Access Formula (Row Major Order): $\\text{Addr}_{A[i][j]} = \\text{B} + [(i \\times \\text{C}) + j] \\times \\text{W}$\nB: Base Address i: Zero-based Row Index of Each Element j: Zero-based Column Index of Each ELement C: Number of Columns W: Size of Each Element SHOW CODE C #include int main() { int arr[2][3] = {{1, 2, 3}, {4, 5, 6}}; for (int i = 0; i \u003c 2; i++) { for (int j = 0; j \u003c 3; j++) { void *addr_ij = (void *) \u0026arr + (i * 3 + j) * sizeof(int); printf(\"Element at [%d][%d]: %d, Address: %p\\n\", i, j, arr[i][j], addr_ij); } } return 0; } SHOW OUTPUT Output Element at [0][0]: 1, Address: 0x7ff7b2c64170 Element at [0][1]: 2, Address: 0x7ff7b2c64174 Element at [0][2]: 3, Address: 0x7ff7b2c64178 Element at [1][0]: 4, Address: 0x7ff7b2c6417c Element at [1][1]: 5, Address: 0x7ff7b2c64180 Element at [1][2]: 6, Address: 0x7ff7b2c64184 Why do most compilers use 0-based indexing? Take a 1-dimentional array as an example, the element access formula for a 0-based index is $\\text{Addr}_{A[i]} = B + i \\times W$. This formula requires two operations (multiplication and addition) to access each element in the array.\nIn contract, the formula for 1-based indexing is $\\text{Addr}_{A[i]} = B + (i - 1) \\times W$. This requires three operations (multiplication. subtraction, and addition). Compared to 0-based indexing, 1-based indexing introduces one additional operation, which becomes a significant overhead when dealing with large size arrays.\nString Matrix Linked List Stack Queue Tree Graph A graph is a fundamental data structure used to represent the connections or relationships between entities. It consists of vertices (also called node) and edges (also called arcs). A vertex represents a single entity in the graph, while an edge represents a connection or relationship between two vertices. Edges may have additional properties, such as weight (to indicate the cost or distance of the connection) or direction (to indicate the direction of the relationship).\nTypes of Graph Undirected Graph vs. Directed Graph In an undirected graph, the connection between two vertices is bidrectional. For example, if there is an edge between vertex A and vertex B, traversal is possible from A to B and from B to A. In contrast, in a directed graph, the relationships are one-way. For instance, if there is an edge from vertex A to vertex B, traversal is possible from A to B, but not from B to A unless there is a separate edge in the opposite direction.\nUnweighted Graph vs. Weighted Graph In an unweighted graph, the relationships between vertices have no additional properties, and all edges are treated equally. In contrast, a weighted graph assigns a weight to each node, which can represent attributes such as distance, time, cost, eetc. The weight provides more information about the connection between vertices and is often used in problems like shortest path or network flow.\nCyclic Graph vs. Acyclic Graph A cyclic graph contains at least one cycle, which is a path that starts and ends at the same vertex. In contrast, an acyclic graph doest not contain any cycles. A special case of an acyclic graph is the directed acyclic graph (DAG), which has directed edges and no cycles.\nConnected Graph vs. Disconnected Graph A connected graph is a graph in which there is a path between every pair of vertices. In contrast, a disconnected graph is a graph where at least one pair of vertices is not connected by any path.\nGraph Terminology The degree of a vertex is the number of edges incident to that vertex. In an undirected graph, the degree is simply the number of edges connected to the vertex. In a directed graph, the degree is the sum of the in-degree (number of incoming edges) and the out-degree (number of outgoing edges) of the vertex.\nA path is a sequence of vertices where each consecutive pair of vertices is connected by an edge.\nA cycle is a path that starts and ends at the same vertex, with no repeated vertices except for the starting or ending vertex. For example, in a cycle with $A \\rightarrow B \\rightarrow C \\rightarrow D \\rightarrow A$, the path starts and ends at the same vertex $A$, but each of the other vertices $(B, C, and D)$ is visited exactly once.\nConnectivity refers to whether there exists a path between any pair of vertices in the graph.\nA subgraph is a graph formd by a subset of the vertices and edges of the original graph.\nA component is a subgraph where there is a path between every pair of vertices in that subgraph.\nGraph Representation Adjacency Matrix An Adjacency Matrix ia a 2-dimentional array where each element at position [i][j] represents an edge between vertex i and j. In a weighted graph, the value at position [i][j] stores the weight of the edge between the two vertices. In an unweight graph, the value at position [i][j] typically stores 1 to indicate an edge exists between the vertices, and 0 to indicate no edge exists. The space complexity of an adjacency matrix is $O(V^2)$, where $V$ is the number of vertices, as it requires a matrix of size $V \\times V$ to represent the graph.\nAdjacency List An Adjacency List is a collection of lists, where each position i stores a list of nerighbors of vertex i. In a weighted graph. each element in the list typically represents a pair (neighbor, weight), where neighbor is a vertex connected to i, and weight is the weight of the edge between i and neighbor. The space complexity of an adjacency list is $O(V + E)$, where $V$ is the number of vertices and $E$ is the number of edges. This is because each vertex has a list of neighbors, and the total number of entries in all lists is proportional to the number of edges.\nEdge List An Edge List is a collection of pairs, where each pair (i, j) represents an edge between vertex i and vertex j. In a weighted graph. each element may also include the weight of the edge. typically represented as (i, j, weight). The space complexity of an edge list is $O(E)$, where $E$ is the number of edges, as each edge is stored as a separate entry in the list.\nGraph Traversal Breadth First Search Breadth-First Search (BFS) explores all the neighbors of a vertex before moving on to their neighbors. It proceeds level by level, ensuring that all vertices at a given distance from the starting vertex are visited before moving on to vertices at a greater distance. BFS is commonly used to find the shortest path in an unweighted graph.\nDepth First Search Depth-First Search (DFS) explores as far as possible alone a branch of the graph before backtracking to explore other branches. It follows a path from the starting vertex to a dead end, then retrace its steps and explores alternative paths. DFS is useful for finding all paths between vertices, detecting cycles, or performing topological sorting in directed acyclic graphs (DAGs).\nSpanning Tree A spanning tree is a subset of a graph that includes all the vertices and contains exactly $V - 1$ edges, where $V$ is the number of vertices in the graph. A connected graph can have multiple spanning trees, whereas a disconnected graph does not have a spanning tree because there is at least one pair of vertices that are not connected, making it impossible to form a tree that spans all the vertices.\nMinimum Spanning Tree (MST) A minimum spanning tree is a type of spanning tree that connects all the vertices of a graph with the smallest possible total edge weight, compared to all other possible spanning trees.\nMST Algorithms ",
  "wordCount" : "2153",
  "inLanguage": "en",
  "datePublished": "2024-11-14T20:29:21+08:00",
  "dateModified": "2024-11-14T20:29:21+08:00",
  "author":{
    "@type": "Person",
    "name": "Signal Yu"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/1-data-structure-and-algorithms/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Signal's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://signalyu.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://signalyu.github.io/" accesskey="h" title="Signal&#39;s Blog (Alt + H)">
                <img src="https://signalyu.github.io/apple-touch-icon.png" alt="" aria-label="logo"
                    height="40">Signal&#39;s Blog</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://signalyu.github.io/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://signalyu.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://signalyu.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://signalyu.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://signalyu.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Data Structure &amp; Algorithms
    </h1>
    <div class="post-meta"><span title='2024-11-14 20:29:21 +0800 HKT'>Nov 14 2024</span>&nbsp;·&nbsp;Signal Yu

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#recursion" aria-label="Recursion">Recursion</a><ul>
                        
                <li>
                    <a href="#head-recursion" aria-label="Head Recursion">Head Recursion</a></li>
                <li>
                    <a href="#tail-recursion" aria-label="Tail Recursion">Tail Recursion</a></li>
                <li>
                    <a href="#tree-recursion" aria-label="Tree Recursion">Tree Recursion</a></li></ul>
                </li>
                <li>
                    <a href="#array" aria-label="Array">Array</a><ul>
                        
                <li>
                    <a href="#implementation-of-static-arrays" aria-label="Implementation of Static Arrays">Implementation of Static Arrays</a></li>
                <li>
                    <a href="#implementation-of-dynamic-arrays" aria-label="Implementation of Dynamic Arrays">Implementation of Dynamic Arrays</a></li>
                <li>
                    <a href="#compilers-memory-layout-for-arrays" aria-label="Compiler&rsquo;s Memory Layout for Arrays">Compiler&rsquo;s Memory Layout for Arrays</a><ul>
                        
                <li>
                    <a href="#1-dimentional-array" aria-label="1-Dimentional Array">1-Dimentional Array</a></li>
                <li>
                    <a href="#2-dimentional-array" aria-label="2-Dimentional Array">2-Dimentional Array</a></li>
                <li>
                    <a href="#why-do-most-compilers-use-0-based-indexing" aria-label="Why do most compilers use 0-based indexing?">Why do most compilers use 0-based indexing?</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#string" aria-label="String">String</a></li>
                <li>
                    <a href="#matrix" aria-label="Matrix">Matrix</a></li>
                <li>
                    <a href="#linked-list" aria-label="Linked List">Linked List</a></li>
                <li>
                    <a href="#stack" aria-label="Stack">Stack</a></li>
                <li>
                    <a href="#queue" aria-label="Queue">Queue</a></li>
                <li>
                    <a href="#tree" aria-label="Tree">Tree</a></li>
                <li>
                    <a href="#graph" aria-label="Graph">Graph</a><ul>
                        
                <li>
                    <a href="#types-of-graph" aria-label="Types of Graph">Types of Graph</a><ul>
                        
                <li>
                    <a href="#undirected-graph-vs-directed-graph" aria-label="Undirected Graph vs. Directed Graph">Undirected Graph vs. Directed Graph</a></li>
                <li>
                    <a href="#unweighted-graph-vs-weighted-graph" aria-label="Unweighted Graph vs. Weighted Graph">Unweighted Graph vs. Weighted Graph</a></li>
                <li>
                    <a href="#cyclic-graph-vs-acyclic-graph" aria-label="Cyclic Graph vs. Acyclic Graph">Cyclic Graph vs. Acyclic Graph</a></li>
                <li>
                    <a href="#connected-graph-vs-disconnected-graph" aria-label="Connected Graph vs. Disconnected Graph">Connected Graph vs. Disconnected Graph</a></li></ul>
                </li>
                <li>
                    <a href="#graph-terminology" aria-label="Graph Terminology">Graph Terminology</a></li>
                <li>
                    <a href="#graph-representation" aria-label="Graph Representation">Graph Representation</a><ul>
                        
                <li>
                    <a href="#adjacency-matrix" aria-label="Adjacency Matrix">Adjacency Matrix</a></li>
                <li>
                    <a href="#adjacency-list" aria-label="Adjacency List">Adjacency List</a></li>
                <li>
                    <a href="#edge-list" aria-label="Edge List">Edge List</a></li></ul>
                </li>
                <li>
                    <a href="#graph-traversal" aria-label="Graph Traversal">Graph Traversal</a><ul>
                        
                <li>
                    <a href="#breadth-first-search" aria-label="Breadth First Search">Breadth First Search</a></li>
                <li>
                    <a href="#depth-first-search" aria-label="Depth First Search">Depth First Search</a></li></ul>
                </li>
                <li>
                    <a href="#spanning-tree" aria-label="Spanning Tree">Spanning Tree</a><ul>
                        
                <li>
                    <a href="#minimum-spanning-tree-mst" aria-label="Minimum Spanning Tree (MST)">Minimum Spanning Tree (MST)</a></li>
                <li>
                    <a href="#mst-algorithms" aria-label="MST Algorithms">MST Algorithms</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="recursion">Recursion<a hidden class="anchor" aria-hidden="true" href="#recursion">#</a></h1>
<blockquote>
<p><strong>Recursion</strong> is a programming technique where a function repeatedly calls itself until it reaches a <em>base case</em>, whcih stops the recursion and allows it to return a result. It is a way of breaking down complex problems into smaller, simpler subproblems that are eaiser to solve.</p>
</blockquote>
<h2 id="head-recursion">Head Recursion<a hidden class="anchor" aria-hidden="true" href="#head-recursion">#</a></h2>
<blockquote>
<p><strong>Head Recursion</strong> is a type of recursion where a function makes its recursive call first, immediately after checking the base case, and performs all other operations only after the recursive call returns.</p>
</blockquote>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE: Head Recursion</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Head Recursion</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-c" data-lang="c" >void printNumbers(int n) {
    if (n == 0) {
        return; // Base case
    }
    printNumbers(n - 1); // Recursive call
    printf("%d\n", n); // Processing after recursion
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<table>
<thead>
<tr>
<th><strong>Call Stack</strong></th>
<th><strong>Operation</strong></th>
<th><strong>Current Value of <code>n</code></strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>headRecursion(3)</code></td>
<td>Call function</td>
<td>3</td>
</tr>
<tr>
<td><code>headRecursion(2)</code></td>
<td>Call function</td>
<td>2</td>
</tr>
<tr>
<td><code>headRecursion(1)</code></td>
<td>Call function</td>
<td>1</td>
</tr>
<tr>
<td><code>headRecursion(0)</code></td>
<td>Base case, exit</td>
<td>0</td>
</tr>
<tr>
<td><strong>Unwinding begins:</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>printf(1)</code></td>
<td>Print 1</td>
<td>1</td>
</tr>
<tr>
<td><code>printf(2)</code></td>
<td>Print 2</td>
<td>2</td>
</tr>
<tr>
<td><code>printf(3)</code></td>
<td>Print 3</td>
<td>3</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="tail-recursion">Tail Recursion<a hidden class="anchor" aria-hidden="true" href="#tail-recursion">#</a></h2>
<blockquote>
<p><strong>Tail Recursion</strong> is a type of recursion where a function makes its recursive call as the last operation in its body. with no further operations after the call. This type of recursion can be optimized by the compiler into an iterative loop through <strong>tail call optimization (TCO)</strong>, which help reduce memory consumption by the reusing the stack frame.</p>
</blockquote>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE: Tail Recursion</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Tail Recursion</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-c" data-lang="c" >void tailRecursion(int n) {
    if (n > 0) {
        printf("%d ", n);       // Operation first
        tailRecursion(n - 1);   // Recursive call at the end
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<table>
<thead>
<tr>
<th><strong>Call Stack</strong></th>
<th><strong>Operation</strong></th>
<th><strong>Current Value of <code>n</code></strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tailRecursion(3)</code></td>
<td>Print 3</td>
<td>3</td>
</tr>
<tr>
<td><code>tailRecursion(2)</code></td>
<td>Print 2</td>
<td>2</td>
</tr>
<tr>
<td><code>tailRecursion(1)</code></td>
<td>Print 1</td>
<td>1</td>
</tr>
<tr>
<td><code>tailRecursion(0)</code></td>
<td>Base case, exit</td>
<td>0</td>
</tr>
</tbody>
</table>
<hr>
<blockquote>
<p><strong>Tail recursion</strong> is generally perfered for performance when recursion depth is large because it can be optimized into an iterative process.</p>
</blockquote>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE: Tail Recursion Optimization</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Tail Recursion Optimization</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-c" data-lang="c" >void tailRecursionOptimized(int n) {
    while (n > 0) {
        printf("%d ", n);  // Operation first
        n--;                // Decrement n, same as `tailRecursion(n - 1)`
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<p>In the above code, optimized Loop replaces recursion with a loop, ensuring only a single stack frame is used.</p>
<hr>
<blockquote>
<p><strong>Conditions for Tail Recursion</strong>: The recursive call must be the last operation in the function, and its result must be immediately returned without any further computation after the call.</p>
</blockquote>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE: Tail Recursive Function</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Tail Recursive Function</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-c" data-lang="c" >// Tail recursive function to calculate factorial
int factorialTailRecursion(int n, int accumulator) {
    if (n == 0) {
        return accumulator; // Base case: return accumulated result
    }
    return factorialTailRecursion(n - 1, accumulator * n); // Recursive call is the last operation
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE: Non-tail Recursive Function</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Non-tail recursive</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-c" data-lang="c" >
// Non-tail recursive function to calculate factorial
int factorialNonTailRecursion(int n) {
    if (n == 0) {
        return 1; // Base case
    }
    return n * factorialNonTailRecursion(n - 1); // Recursive call is not the last operation
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="tree-recursion">Tree Recursion<a hidden class="anchor" aria-hidden="true" href="#tree-recursion">#</a></h2>
<blockquote>
<p><strong>Tree recursion</strong> is a type of recursion in which a function makes multiple recursive calls to itself in its body, it creates a tree-like data structure, as each call can branch into multiple additional calls.</p>
</blockquote>
<hr>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">C</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-c" data-lang="c" >public int fib(int n) {
    if (n <= 1) {
        return n;
    }
    return fib(n - 1) + fib(n - 2);
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<p>Recursion Tree Analysis:</p>
<pre class="mermaid">---
title: Recursion Tree Analysis - fibonacci sequence
---
graph TD
    L0(("fib\(5\)")) --> L1(("fib\(4\)"))
    L0 --> L2(("fib\(3\)"))
    L1 --> L3(("fib\(3\)"))
    L1 --> L4(("fib\(2\)"))
    L2 --> L5(("fib\(2\)"))
    L2 --> L6(("fib\(1\)"))
    L3 --> L7(("fib\(2\)"))
    L3 --> L8(("fib\(1\)"))
    L4 --> L9(("fib\(1\)"))
    L4 --> L10(("fib\(0\)"))
    L5 --> L11(("fib\(1\)"))
    L5 --> L12(("fib\(0\)"))
    L7 --> L13(("fib\(1\)"))
    L7 --> L14(("fib\(0\)"))
</pre>
<hr>
<h1 id="array">Array<a hidden class="anchor" aria-hidden="true" href="#array">#</a></h1>
<blockquote>
<p>An <strong>array</strong> is a data structure that stores a collection of elements of the same type in a fixed-size, continguous block of memory. Arrays can be categorized into two types: <strong>static arrays</strong> and <strong>dynamic arrays</strong>.</p>
</blockquote>
<blockquote>
<p>A <strong>static array</strong> has a fixed size that cannot be changed after its declaration. Memory for a static array is allocated at compile time, and its size must be explicitly specified.</p>
</blockquote>
<blockquote>
<p>In contrast, a <strong>dynamic array</strong> allows its size to be adjusted during runtime, enabling it to grow or shrink as needed. Unlike static arrays, the size of a dynamic array does not need to be specified at the time of declaration, and memory is allocated dynamically from the heap.</p>
</blockquote>
<h2 id="implementation-of-static-arrays">Implementation of Static Arrays<a hidden class="anchor" aria-hidden="true" href="#implementation-of-static-arrays">#</a></h2>
<h2 id="implementation-of-dynamic-arrays">Implementation of Dynamic Arrays<a hidden class="anchor" aria-hidden="true" href="#implementation-of-dynamic-arrays">#</a></h2>
<h2 id="compilers-memory-layout-for-arrays">Compiler&rsquo;s Memory Layout for Arrays<a hidden class="anchor" aria-hidden="true" href="#compilers-memory-layout-for-arrays">#</a></h2>
<blockquote>
<p>The address of an array element is determined at runtime. Array elements are stored in a continguous block of memory, and the compiler calculates each element&rsquo;s address using its index and the size of each element.</p>
</blockquote>
<hr>
<h3 id="1-dimentional-array">1-Dimentional Array<a hidden class="anchor" aria-hidden="true" href="#1-dimentional-array">#</a></h3>
<p>Element Access Formula (0-based index): $\text{Addr}_{A[i]} = B + i \times W$</p>
<ul>
<li><code>B</code>: Base Address</li>
<li><code>i</code>: Zero-based Index of Each Element</li>
<li><code>W</code>: Size of Each Element</li>
</ul>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">C</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-c" data-lang="c" >#include &lt;stdio.h&gt;

int main() {
    int arr[5] = {10, 20, 30, 40, 50};

    for (int i = 0; i < 5; i++) {
        void *addr_i = (void *) arr + (i * sizeof(int));
        printf("Element at index %d: %d \t Address: %p\n", i, arr[i], addr_i);
    }

    return 0;
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW OUTPUT</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Output</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-bash" data-lang="bash" >Element at index 0: 10 	 Address: 0x7ff7bb0b7170
Element at index 1: 20 	 Address: 0x7ff7bb0b7174
Element at index 2: 30 	 Address: 0x7ff7bb0b7178
Element at index 3: 40 	 Address: 0x7ff7bb0b717c
Element at index 4: 50 	 Address: 0x7ff7bb0b7180
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h3 id="2-dimentional-array">2-Dimentional Array<a hidden class="anchor" aria-hidden="true" href="#2-dimentional-array">#</a></h3>
<p>Element Access Formula (Row Major Order): $\text{Addr}_{A[i][j]} = \text{B} + [(i \times \text{C}) + j] \times \text{W}$</p>
<ul>
<li><code>B</code>: Base Address</li>
<li><code>i</code>: Zero-based Row Index of Each Element</li>
<li><code>j</code>: Zero-based Column Index of Each ELement</li>
<li><code>C</code>: Number of Columns</li>
<li><code>W</code>: Size of Each Element</li>
</ul>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">C</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-c" data-lang="c" >#include &lt;stdio.h&gt;

int main() {
    int arr[2][3] = {{1, 2, 3}, {4, 5, 6}};

    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < 3; j++) {
            void *addr_ij = (void *) &arr + (i * 3 + j) * sizeof(int);
            printf("Element at [%d][%d]: %d, Address: %p\n", i, j, arr[i][j], addr_ij);
        }
    }

    return 0;
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW OUTPUT</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Output</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-bash" data-lang="bash" >Element at [0][0]: 1, Address: 0x7ff7b2c64170
Element at [0][1]: 2, Address: 0x7ff7b2c64174
Element at [0][2]: 3, Address: 0x7ff7b2c64178
Element at [1][0]: 4, Address: 0x7ff7b2c6417c
Element at [1][1]: 5, Address: 0x7ff7b2c64180
Element at [1][2]: 6, Address: 0x7ff7b2c64184
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h3 id="why-do-most-compilers-use-0-based-indexing">Why do most compilers use 0-based indexing?<a hidden class="anchor" aria-hidden="true" href="#why-do-most-compilers-use-0-based-indexing">#</a></h3>
<blockquote>
<p>Take a 1-dimentional array as an example, the element access formula for a 0-based index is $\text{Addr}_{A[i]} = B + i \times W$. This formula requires two operations (multiplication and addition) to access each element in the array.</p>
</blockquote>
<blockquote>
<p>In contract, the formula for 1-based indexing is $\text{Addr}_{A[i]} = B + (i - 1) \times W$. This requires three operations (multiplication. subtraction, and addition). Compared to 0-based indexing, 1-based indexing introduces one additional operation, which becomes a significant overhead when dealing with large size arrays.</p>
</blockquote>
<hr>
<h1 id="string">String<a hidden class="anchor" aria-hidden="true" href="#string">#</a></h1>
<h1 id="matrix">Matrix<a hidden class="anchor" aria-hidden="true" href="#matrix">#</a></h1>
<h1 id="linked-list">Linked List<a hidden class="anchor" aria-hidden="true" href="#linked-list">#</a></h1>
<h1 id="stack">Stack<a hidden class="anchor" aria-hidden="true" href="#stack">#</a></h1>
<h1 id="queue">Queue<a hidden class="anchor" aria-hidden="true" href="#queue">#</a></h1>
<h1 id="tree">Tree<a hidden class="anchor" aria-hidden="true" href="#tree">#</a></h1>
<h1 id="graph">Graph<a hidden class="anchor" aria-hidden="true" href="#graph">#</a></h1>
<blockquote>
<p>A <strong>graph</strong> is a fundamental data structure used to represent the connections or relationships between entities. It consists of <strong>vertices</strong> (also called <em>node</em>) and <strong>edges</strong> (also called <em>arcs</em>). A vertex represents a single entity in the graph, while an edge represents a connection or relationship between two vertices. Edges may have additional properties, such as <strong>weight</strong> (to indicate the cost or distance of the connection) or <strong>direction</strong> (to indicate the direction of the relationship).</p>
</blockquote>
<hr>
<h2 id="types-of-graph">Types of Graph<a hidden class="anchor" aria-hidden="true" href="#types-of-graph">#</a></h2>
<h3 id="undirected-graph-vs-directed-graph">Undirected Graph vs. Directed Graph<a hidden class="anchor" aria-hidden="true" href="#undirected-graph-vs-directed-graph">#</a></h3>
<blockquote>
<p>In an <strong>undirected graph</strong>, the connection between two vertices is bidrectional. For example, if there is an edge between vertex A and vertex B, traversal is possible from A to B and from B to A. In contrast, in a <strong>directed graph</strong>, the relationships are one-way. For instance, if there is an edge from vertex A to vertex B, traversal is possible from A to B, but not from B to A unless there is a separate edge in the opposite direction.</p>
</blockquote>
<hr>
<h3 id="unweighted-graph-vs-weighted-graph">Unweighted Graph vs. Weighted Graph<a hidden class="anchor" aria-hidden="true" href="#unweighted-graph-vs-weighted-graph">#</a></h3>
<blockquote>
<p>In an <strong>unweighted graph</strong>, the relationships between vertices have no additional properties, and all edges are treated equally. In contrast, a <strong>weighted graph</strong> assigns a <em>weight</em> to each node, which can represent attributes such as distance, time, cost, eetc. The weight provides more information about the connection between vertices and is often used in problems like shortest path or network flow.</p>
</blockquote>
<hr>
<h3 id="cyclic-graph-vs-acyclic-graph">Cyclic Graph vs. Acyclic Graph<a hidden class="anchor" aria-hidden="true" href="#cyclic-graph-vs-acyclic-graph">#</a></h3>
<blockquote>
<p>A <strong>cyclic graph</strong> contains at least one cycle, which is a path that starts and ends at the same vertex. In contrast, an <strong>acyclic graph</strong> doest not contain any cycles. A special case of an acyclic graph is the <strong>directed acyclic graph (DAG)</strong>, which has directed edges and no cycles.</p>
</blockquote>
<hr>
<h3 id="connected-graph-vs-disconnected-graph">Connected Graph vs. Disconnected Graph<a hidden class="anchor" aria-hidden="true" href="#connected-graph-vs-disconnected-graph">#</a></h3>
<blockquote>
<p>A <strong>connected graph</strong> is a graph in which there is a path between every pair of vertices. In contrast, a <strong>disconnected graph</strong> is a graph where at least one pair of vertices is not connected by any path.</p>
</blockquote>
<hr>
<h2 id="graph-terminology">Graph Terminology<a hidden class="anchor" aria-hidden="true" href="#graph-terminology">#</a></h2>
<blockquote>
<p>The <strong>degree of a vertex</strong> is the number of edges incident to that vertex. In an undirected graph, the degree is simply the number of edges connected to the vertex. In a directed graph, the degree is the sum of the <strong>in-degree</strong> (number of incoming edges) and the <strong>out-degree</strong> (number of outgoing edges) of the vertex.</p>
</blockquote>
<blockquote>
<p>A <strong>path</strong> is a sequence of vertices where each consecutive pair of vertices is connected by an edge.</p>
</blockquote>
<blockquote>
<p>A <strong>cycle</strong> is a path that starts and ends at the same vertex, with no repeated vertices except for the starting or ending vertex. For example, in a cycle with $A \rightarrow B \rightarrow C \rightarrow D \rightarrow A$, the path starts and ends at the same vertex $A$, but each of the other vertices $(B, C, and D)$ is visited exactly once.</p>
</blockquote>
<blockquote>
<p><strong>Connectivity</strong> refers to whether there exists a path between any pair of vertices in the graph.</p>
</blockquote>
<blockquote>
<p>A <strong>subgraph</strong> is a graph formd by a subset of the vertices and edges of the original graph.</p>
</blockquote>
<blockquote>
<p>A <strong>component</strong> is a subgraph where there is a path between every pair of vertices in that subgraph.</p>
</blockquote>
<hr>
<h2 id="graph-representation">Graph Representation<a hidden class="anchor" aria-hidden="true" href="#graph-representation">#</a></h2>
<h3 id="adjacency-matrix">Adjacency Matrix<a hidden class="anchor" aria-hidden="true" href="#adjacency-matrix">#</a></h3>
<blockquote>
<p>An <strong>Adjacency Matrix</strong> ia a 2-dimentional array where each element at position <code>[i][j]</code> represents an edge between vertex <code>i</code> and <code>j</code>. In a weighted graph, the value at position <code>[i][j]</code> stores the weight of the edge between the two vertices. In an unweight graph, the value at position <code>[i][j]</code> typically stores <code>1</code> to indicate an edge exists between the vertices, and <code>0</code> to indicate no edge exists. The space complexity of an adjacency matrix is $O(V^2)$, where $V$ is the number of vertices, as it requires a matrix of size $V \times V$ to represent the graph.</p>
</blockquote>
<hr>
<h3 id="adjacency-list">Adjacency List<a hidden class="anchor" aria-hidden="true" href="#adjacency-list">#</a></h3>
<blockquote>
<p>An <strong>Adjacency List</strong> is a collection of lists, where each position <code>i</code> stores a list of nerighbors of vertex <code>i</code>. In a weighted graph. each element in the list typically represents a pair <code>(neighbor, weight)</code>, where <code>neighbor</code> is a vertex connected to <code>i</code>, and weight is the weight of the edge between <code>i</code> and <code>neighbor</code>. The space complexity of an adjacency list is $O(V + E)$, where $V$ is the number of vertices and $E$ is the number of edges. This is because each vertex has a list of neighbors, and the total number of entries in all lists is proportional to the number of edges.</p>
</blockquote>
<hr>
<h3 id="edge-list">Edge List<a hidden class="anchor" aria-hidden="true" href="#edge-list">#</a></h3>
<blockquote>
<p>An <strong>Edge List</strong> is a collection of pairs, where each pair <code>(i, j)</code> represents an edge between vertex <code>i</code> and vertex <code>j</code>. In a weighted graph. each element may also include the weight of the edge. typically represented as <code>(i, j, weight)</code>. The space complexity of an edge list is $O(E)$, where $E$ is the number of edges, as each edge is stored as a separate entry in the list.</p>
</blockquote>
<hr>
<h2 id="graph-traversal">Graph Traversal<a hidden class="anchor" aria-hidden="true" href="#graph-traversal">#</a></h2>
<h3 id="breadth-first-search">Breadth First Search<a hidden class="anchor" aria-hidden="true" href="#breadth-first-search">#</a></h3>
<blockquote>
<p><strong>Breadth-First Search (BFS)</strong> explores all the neighbors of a vertex before moving on to their neighbors. It proceeds level by level, ensuring that all vertices at a given distance from the starting vertex are visited before moving on to vertices at a greater distance. BFS is commonly used to find the shortest path in an unweighted graph.</p>
</blockquote>
<hr>
<h3 id="depth-first-search">Depth First Search<a hidden class="anchor" aria-hidden="true" href="#depth-first-search">#</a></h3>
<blockquote>
<p><strong>Depth-First Search (DFS)</strong> explores as far as possible alone a branch of the graph before backtracking to explore other branches. It follows a path from the starting vertex to a dead end, then retrace its steps and explores alternative paths. DFS is useful for finding all paths between vertices, detecting cycles, or performing topological sorting in directed acyclic graphs (DAGs).</p>
</blockquote>
<hr>
<h2 id="spanning-tree">Spanning Tree<a hidden class="anchor" aria-hidden="true" href="#spanning-tree">#</a></h2>
<blockquote>
<p>A <strong>spanning tree</strong> is a subset of a graph that includes all the vertices and contains exactly $V - 1$ edges, where $V$ is the number of vertices in the graph. A <strong>connected graph</strong> can have multiple spanning trees, whereas a <strong>disconnected graph</strong> does not have a spanning tree because there is at least one pair of vertices that are not connected, making it impossible to form a tree that spans all the vertices.</p>
</blockquote>
<hr>
<h3 id="minimum-spanning-tree-mst">Minimum Spanning Tree (MST)<a hidden class="anchor" aria-hidden="true" href="#minimum-spanning-tree-mst">#</a></h3>
<blockquote>
<p>A <strong>minimum spanning tree</strong> is a type of spanning tree that connects all the vertices of a graph with the smallest possible total edge weight, compared to all other possible spanning trees.</p>
</blockquote>
<h3 id="mst-algorithms">MST Algorithms<a hidden class="anchor" aria-hidden="true" href="#mst-algorithms">#</a></h3>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://signalyu.github.io/tags/data-structure--algorithms/">Data Structure &amp; Algorithms</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/framework/front-end/vue/1-vue-notes/">
    <span class="title">« PREV</span>
    
    <br>
    <span>Vue Notes</span>
  </a>
  <a class="next" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/design-patterns/1-design-patterns/">
    <span class="title">NEXT »</span>
    
    <br>
    <span>Design Patterns</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://signalyu.github.io/">Signal&#39;s Blog</a></span> · 
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>

    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
        mermaid.initialize({
            startOnLoad: true,
            "flowchart": { "htmlLabels": true },
            theme: 'dark',
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
        });
    </script>
    
</body>
</html>
