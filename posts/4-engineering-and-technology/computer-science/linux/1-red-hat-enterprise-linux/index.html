<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Red Hat Enterprise Linux | Signal&#39;s Blog</title>
<meta name="keywords" content="Engineering &amp; Technology, Computer Science, Linux">
<meta name="description" content="1. Introduction to Linux SHOW CONTENTS Open Source refers to software whose source code is freely available to the public for anyone to view, modify, and distribute. It encourages coolaboration, transparency, and community-driven improvements.
Open Source Licenses are legal agreements that define how software can be used, modified, and distributed. There are two main types of Copyleft and Permissive.
Copyleft licenses require that any modified versions of the software also be open source, under the same terms as the original.">
<meta name="author" content="Signal Yu">
<link rel="canonical" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/linux/1-red-hat-enterprise-linux/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5a0ace7f2dc73037e40ceea0eb0d119b5d798dba2da38d9129982a8cf9fa07a5.css" integrity="sha256-WgrOfy3HMDfkDO6g6w0Rm115jboto42RKZgqjPn6B6U=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://signalyu.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://signalyu.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://signalyu.github.io/favicon-32x32">
<link rel="apple-touch-icon" href="https://signalyu.github.io/apple-touch-icon">
<link rel="mask-icon" href="https://signalyu.github.io/favicon.io">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/linux/1-red-hat-enterprise-linux/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
  

<meta property="og:title" content="Red Hat Enterprise Linux" />
<meta property="og:description" content="1. Introduction to Linux SHOW CONTENTS Open Source refers to software whose source code is freely available to the public for anyone to view, modify, and distribute. It encourages coolaboration, transparency, and community-driven improvements.
Open Source Licenses are legal agreements that define how software can be used, modified, and distributed. There are two main types of Copyleft and Permissive.
Copyleft licenses require that any modified versions of the software also be open source, under the same terms as the original." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/linux/1-red-hat-enterprise-linux/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2025-04-15T11:03:32+08:00" />
<meta property="article:modified_time" content="2025-04-15T11:03:32+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Red Hat Enterprise Linux"/>
<meta name="twitter:description" content="1. Introduction to Linux SHOW CONTENTS Open Source refers to software whose source code is freely available to the public for anyone to view, modify, and distribute. It encourages coolaboration, transparency, and community-driven improvements.
Open Source Licenses are legal agreements that define how software can be used, modified, and distributed. There are two main types of Copyleft and Permissive.
Copyleft licenses require that any modified versions of the software also be open source, under the same terms as the original."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://signalyu.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Red Hat Enterprise Linux",
      "item": "https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/linux/1-red-hat-enterprise-linux/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Red Hat Enterprise Linux",
  "name": "Red Hat Enterprise Linux",
  "description": "1. Introduction to Linux SHOW CONTENTS Open Source refers to software whose source code is freely available to the public for anyone to view, modify, and distribute. It encourages coolaboration, transparency, and community-driven improvements.\nOpen Source Licenses are legal agreements that define how software can be used, modified, and distributed. There are two main types of Copyleft and Permissive.\nCopyleft licenses require that any modified versions of the software also be open source, under the same terms as the original.",
  "keywords": [
    "Engineering \u0026 Technology", "Computer Science", "Linux"
  ],
  "articleBody": "1. Introduction to Linux SHOW CONTENTS Open Source refers to software whose source code is freely available to the public for anyone to view, modify, and distribute. It encourages coolaboration, transparency, and community-driven improvements.\nOpen Source Licenses are legal agreements that define how software can be used, modified, and distributed. There are two main types of Copyleft and Permissive.\nCopyleft licenses require that any modified versions of the software also be open source, under the same terms as the original. Popular examples include the GPL (GNU General Public License) and AGPL (Affero GPL). Permissive licenses are more relaxed, allowing users to modify, distribute, and even close-source the software if desired. Well-known examples of permissive licenses include the MIT License, Apache License 2.0, and BSD License (Berkeley Software Distribution). The differences between Fedora, CentOS Stream, and Red Hat Enterprise Linux (RHEL) are primarily based on their release cycles, stability, and target audiences. Fedora is a cutting-edge distribution that always features the latest software and technologies, making it ideal for developers and enthusiasts who want to experience the newest features. CentOS Stream serves as a rolling preview of future RHEL versions, acting as a middle ground between Fedora and RHEL. Finally, RHEL is the most stable and secure option, designed for enterprise environments that require long-term support and paid services. RHEL is commonly used in production systems that demand reliability and robust commercial support. 2. Manage Files From the Command Line Linux File System Hierarchy SHOW CONTENTS The Linux File System Hierarchy defines the directory structure and directory contents in Linux-based operating systems. It stores all files which organized into a single incerted tree structure.\nHere’s an overview of the key directories in the Linux file system hierarchy:\nLocation Purpose /boot Files to start the boot process. /dev Special device files that the system uses to access hardware. /etc System-specific configuration files. /home Home directory, where regular users store their data and configuration files. /root Home directory for the administrative superuser, root. /run Runtime data for processes that started since the last boot. This data includes process ID files and lock files. The contents of this directory are re-created on reboot. This directory consolidates the /var/run and /var/lock directories from earlier versions of Red Hat Enterprise Linux. /tmp A world-writable space for temporary files. Files that are not accessed, changed, or modified for 10 days are deleted from this directory automatically. The /var/tmp directory is also a temporary directory, in which files that are not accessed, changed, or modified in more than 30 days are deleted automatically. /usr Installed software, shared libraries, including files, and read-only program data. Significant subdirectories include: /usr/bin: User commands; /usr/sbin: System administration commands; /usr/local: Locally customized software /var System-specific variable data that should persist between boots. Files that dynamically change, such as databases, cache directories, log files, printer-spooled documents, and website content, might be found under /var. static, dynamic(variable), persistent, runtime: Static content remains unchanged until explicitly edited or reconfigured; Dynamic (Variable) content might be modified or appended by active processes; Persistent content remains after a reboot, such as configuration settings; Runtime content from a process or from the system is deleted on reboot.\nCommon Directory and File Management Commands SHOW CONTENTS pwd: Prints the current working directory (path) to the terminal. cd: Changes the current working directory to the home directory of the current user. cd -: Changes the directory to the previous directory. cd ../..: Moves up two levels in the directory structure. cd ..: Moves up one level in the directory structure (to the parent directory). ls -l: Lists files and directories in the current directory in long format, showing details such as permissions, owner, group, size, and last modification time. ls -al: Lists all files (including hidden files) in the current directory in long format. ls -lR: Lists files and directories recursively in the current directory and all its subdirectories, in long format. ls -l file*.txt: Lists files that start with the word file and end with .txt. cp hello.py HELLO.py: Copies the file hello.py to HELLO.py. The original file remains unchanged. mv -v hello.py HELLO.py: Moves (or renames) the file hello.py to HELLO.py. The -v option prints verbose output showing the operation. rm HELLO.py: Removes (deletes) the file HELLO.py. Be careful, as this is a permanent deletion. mkdir HOME: Creates a new directory named HOME in the current directory. rmdir HOME: Removes an empty directory named HOME. If the directory contains any files, it cannot be removed with rmdir. Create Links Between Files SHOW CONTENTS In Linux, there are two types of links that can be created for files: hard links and soft links. A hard link is a direct reference to the data of a file. It creates another name for an existing file, pointing directly to the file’s inode (the underlying data structure that holds the file’s metadata and data.) A soft link, on the other hand, is a reference to the original file’s path, rather than directly pointing to the file’s inode.\nHard links that reference the same file share the same inode struct with the link count, access permissions, user and group ownership, time stamps, and file content. Therefore, when any of this information is changed for one hard link, the changes are reflected in all other hard links pointing to the same file.\nCommands for creating links between files are as follows:\nln file.txt file_link.txt # Create a hard link ls -i file.txt file_link.txt # Show the inode number for both files ln -s file.txt file_soft.txt # Create a soft link ls -l file_soft.txt # Check if the soft link work (file_soft.txt -\u003e file.txt) 3 Get Help Using man Command SHOW CONTENTS The man command in Linux is used to display the manual pages for various commands, programs, system calls, etc. The man pages are divided into 9 sections: executable programs or shell commands, system calls, library calls, special files, file formats and conventions, games, miscellaneous, system administration commands, and kernel routines (non standard).\nExecutable programs or shell commands: Commands executed by regular users (e.g., ls, cp). System calls: Functions that the kernel provides for programs to interact with the system (e.g., open, read). Library calls: Functions that can be used in programs written in C and other languages (e.g., printf). Special files: Usually found in /dev(e.g., /dev/sda). File formats and conventions: Descriptions of file formats (e.g., /etc/passwd). Games: Information about games available on the system. Miscellaneous: including macro packages and conventions (e.g. man(7), groff(7)). System administration commands: Commands for system administrators (e.g., useradd, systemctl). Kernel routines: Non standard The most common way to use man command including:\nman open or man open.3: Displays the manual page for the open command. (open exists in Section 2 (System Calls) and Section 3 (Library Functions), man open display the System Call documentation while man open.3 display the Library Function manual.) man -f ls: Displays a brief description of the ls command, equivalent to whatis ls. man -k ls: Searches the manual page database for the term ls, equivalent to apropos ls. Note that before running man -f ls or man -k ls, it is important to ensure that the mandb database has been built. This can be done by running sudo mandb.\n4. I/O Redirection \u0026 Pipelines I/O Redirection SHOW CONTENTS A process reads input and writes output. By default, it reads input from the keyboard and sends its output to the terminal window. Processes use numbered channels called file descriptors to manage input and output. Every process starts with at least three file descriptors:\nStandard Input (channel 0): Reads input from the keyboard. Standard Output (channel 1): Sends normal output to the terminal. Standard Error (channel 2): Sends error messages to the terminal. Number Channel Name Description Default Connection Usage 0 stdin Standard input Keyboard Read only 1 stdout Standard output Terminal Write only 2 stderr Standard error Terminal Write only 3+ filename Other files None Read/write or both By default, a process takes input from the keyboard and displays its output on the terminal. Redirection refers to changing the default input or output of a command. The following table summarizes the different types of redirection available:\nUsage Explanation Vitulization \u003e file Redirect stdout to overwrite a file \u003e\u003e file Redirect stdout ot append to a file 2\u003e file Redirect stderr to overwrite a file 2\u003e /dev/null Discard stderr error messages by redirecting them to /dev/null \u003e file 2\u003e\u00261 or \u0026\u003e file Redirect stdout and stderr to overwrite the same file \u003e\u003e file 2\u003e\u00261 or \u0026\u003e\u003e file Redirect stdout and stderr to append the same file sort \u003c file \u003e sorted_file Redirects the stdin to a file and redirect stdout to overwrite a different file It is important to note that the order of redirection operations is crucial. For example:\nThe command \u003e output.log 2\u003e\u00261 redirects both standard output and standard error messages to the same file, output.log. On the other hand, 2\u003e\u00261 \u003e output.log redirects standard error messages to the default standard output (the terminal), and then redirects only the standard output to output.log. Additionally, the command \u003e output.log 2\u003e\u00261 can be shortened to \u0026\u003e output.log. However, it is important to note that \u0026\u003e is not standardized and may not be implemented in all shells.\nPipelines SHOW CONTENTS A pipeline is a sequence of one or more commands that are connected by the vertical bar character (|). In a pipeline, the standard output of one command is passed directly as the standard input to the next command.\nThe main difference between pipelines and I/O redirection lies in how they handle data. I/O redirection refers to sending standard output to a file or receiving standard input from a file. In contrast, pipelines are used to send the standard output of one process directly to the standard input of another process.\nThe following are some commonly used pipeline examples:\ncat file.txt | grep \"pattern\": Searches for patterns within text. cat file.txt | sort: Sorts the lines of text in a specified order (alphabetically by default). cat file.txt | wc -l: Counts the number of lines in a file. cat file.txt | tee output.txt: Outputs the content of a file to both the terminal and a specified file. find / -name \"passwd\" 2\u003e\u00261 | less: find / -name \"passwd\": Searches for a file or directory named passwd starting from the root directory (/). 2\u003e\u00261: Redirects standard error (file descriptor 2) to standard output (file descriptor 1). This ensures that any error messages, such as permission denials, are also passed along with the normal output. | less: Pipes the combined output (standard output and error messages) into the less command. 5. Bash Environment Configuration SHOW CONTENTS When Bash starts, several initialization scripts are executed to configure the shell environment, with the specific scripts depending on whether the shell is interactive, non-interactive, login, or non-login. An interactive shell allows users to enter commands directly, while a non-interactive shell runs in the background. A login shell is invoked when a user logs in via terminal or SSH, while non-login shell is opened from an existing session, like when launching a terminal in a GUI.\nFor interactive login shells, the environment is configured by the /etc/profile and ~/.bash_profile files, which also source /etc/bashrc and ~/.bashrc respectively. For interactive non-login shells, only /etc/bashrc and ~/.bashrc are used. System-wide configurations are stored in /etc/profile and /etc/bashrc, while user-specific configurations are in ~/.bash_profile and ~/.bashrc.\n6. Manage Local Users and Groups User \u0026 Group Concepts SHOW CONTENTS A user is an individual account created on a Linux system that can own files, execute commands, and interact with the system. User details are typically stored in the /etc/passwd file, where each line represents a user account with specific information like username, UID, home directory, and default shell.\nIn Linux, there are three primary types of users:\nSuperuser: The superuser account is responsible for administering the system. Its name is root with a UID of 0. It has full system access. System User: These accounts are used by processes or daemons that provide system services (e.g., web servers, databases). System users are non-privileged and are created to isolate and secure the services they support. Regular User: The regular user is the typical user who do not have root priviledges and have limited access to the system. A group is a collection of users that can be assigned a common set of permissions. The group details are typically stored in etc/group, which contains information about group names, GIDs, and the list of users that belong to each group.\nIn Linux, there two main types of group: the primary group and the secondary group.\nPrimary Group: The primary group is the default group assigned to a user. It is used as the group ownership for files and directories the user creates. By default, a user’s primary group often shares the same name as the username. Secondary Groups: These are additional groups to which a user can belong. Secondary groups provide users with access to shared resources or enable them to perform tasks that require specific group-level permissions. Gain Superuser Access SHOW CONTENTS In RHEL 9, to switch from a regular user to a superuser (root), the su command is used. To switch back from the root account to a regular user, the command su - user_name can be used, or alternatively, typing exit will return to the previous user account.\nIf a regular user is not in the sudoers file, an error message such as \"user_name is not in the sudoers file. This incident will be reported.\" will appear when trying to run a command with sudo. To enable full sudo access for a specific user, switch to the root account and then add the line user_name ALL=(ALL) ALL to the /etc/sudoers file. Similarly, to provide users in a specific group full sudo access, the line %group_name ALL=(ALL) ALL should be added.\nIt’s important to use the visudo command to edit the /etc/sudoers file, as it performs syntax checks to avoid errors that could lock out users from using sudo.\nManage Local User Accounts SHOW CONTENTS To create a user, use the useradd command. When executing useradd user_name, it creates the user’s home directory, sets up the account information, and generates a private group for the user named user_name. The default configuration for creating a new user is defined in the /etc/login.defs file. Note that at this point, the user account does not have a valid password set, so the user cannot log in until a password is assigned. To set a password for the user, the passwd command should be used. To delete a user, the userdel command is used. The userdel user_name command removes the user_name from the /etc/passwd file but leaves the user’s home directory intact. If it is necessary to delete the home directory as well, the userdel -r user_name option should be used. It’s important to note that when deleting a user without the -r option, the files owned by the user will be left with an unassigned UID. If a new account is later assigned to the same UID, that account will inherit the old user’s files, which poses a security risk. For this reason, many organizations prefer to lock user accounts instead of deleting them, in accordance with security policies.\nManage Local Group Accounts SHOW CONTENTS The commands for managing local group accounts include groupadd, groupmod, and groupdel.\ngroupadd: This command is used to create a new group. By default, it assigns the next available GID from the range specified by the GID_MIN and GID_MAX variables in the /etc/login.defs file. groupmod: This command is used to modify an existing group, such as changing its group name or GID. groupdel: This command is used to delete an existing group. However, it’s important to note that the primary group of an existing user cannot be removed. Here are some commonly used commands for managing local group accounts:\ngroupadd -g group_id group_name: Creates a new group with a specified GID. groupmod -n old_group_name new_group_name: Renames an existing group from old_group_name to new_group_name. groupmod -g group_id group_name: Changes the GID of an existing group (group_name) to a specified group id. usermod -aG group_name user_name: Adds a user (user_name) to an additional group (group_name) without removing the user from their existing groups. The -aG option ensures the user is appended to the group list rather than replacing the existing group memberships. newgrp group_name: Changes the current group to the named group. groupdel group_name: Deletes the specified group (group_name). Note that the primary group of any existing users cannot be deleted. Manage User Passwords SHOW CONTENTS In Linux, /etc/passwd and /etc/shadow are critical system files that store user account information and password data, repectively. The /etc/passwd file contains basic information about user accounts on the system, while the /etc/shadow file is used to store encrypted user password information, as well as other related data such as password expiration and account locking details.\nHere is the breakdown of the line from /etc/shadow:\nThe chage command is used to configure password aging parameters for user accounts, allowing administrators to manage password expiration, warning periods, and other related settings (as shown in the following image).\nMin Days (Minimum Days Between Password Changes): The minimum days (default is 0) parameter specifies the minimum number of days that must pass before a user can change their password after setting it for the first time or after a password change. For example, if min days is set to 7, then after changing their password, the user will not be able to change it again until 7 days have passed. Max Days (Maximum Days Between Password Changes): The maximum days (default is 99999) parameter defines the maximum number of days that a user is allowed to use the current password. After this period, the user will be required to change the password. For example, If max days is set to 30, the user must change their password every 30 days. After 30 days, they will be prompted to change it. Warn Days (Warning Period Before Password Expiration): The warn days (default is 7) parameter specifies how many days before the password expires the user will be warned to change their password. The warning is displayed when the user logs in. For example, If warn days is set to 7, the user will receive a warning 7 days before the password expiration. Expiration Date/Inactivity Days: The expiration date (default is None) specifies the date when the user’s account will be locked. If the inactivity days is set to 0, the account will be locked immediately after the expiration date. The inactivity days parameter (default is 7) defines the grace period after a password expires during which the user can still log in. During this period, the user is required to change the expired password using the passwd command before the account is locked. If the password is not changed within this grace period, the account will be locked. For example, if the expiration date is set to 2024-12-01 and the inactivity days is set to 7, the user can continue logging in until 2024-12-08. After 2024-12-08, the user’s account will be locked, and contact with an administrator will be necessary to reactivate the account. Below are some commonly used chage commands:\nchage -E $(date -d \"+30 days\" +%F) user_name: This command sets the expiration date of a user’s account to 30 days from the current date. chage -d 0 user_name: This command forces the user to change their password immediately. There are common scenarios where user access needs to be restricted, such as temporarily blocking a user or disabling access for a former employee. Below are some common methods for restricting user access.\nHere are the descriptions for the mentioned commands:\nusermod -L user_name: This command locks the user account by disabling the password. It works by placing an exclamation mark (!) in front of the password hash in the /etc/shadow file, preventing the user from logging in. usermod -L -e 2024-12-31 user_name: This command locks the user account and also sets an expiration date for the account. usermod -s /sbin/nologin user_name: This command changes the login shell for the user to /sbin/nologin, which prevents the user from logging in interactively. It’s important to note that this command does not prevent all types of access. Users may still be able to authenticate and upload or retrieve files through applications like file transfer programs or mail clients, as long as the user knows the password. 7. Control Access to Files File System Permissions Concepts SHOW CONTENTS In Linux, file system permissions control the access and actions that users can perform on files and directories. These permissions help manage security and determine who can read (r), write (w), or execute (x) a file. Permissions are typically displayed in a 10-character string, such as -rwxr-xr--. The 10 characters consist of a file type and three sets of permissions (User, Group, and Others):\nThe first character in the file permission string represents the file type. Common file types include - for regular files, d for directories, l for symbolic links, c for character device files, b for block device files, p for named pipe files, and s for local socket files.\nThe first set represents the user (owner) permissions. The second set represents the group permissions. The third set represents the others (everyone else) permissions. Each set of permissions is made up of three characters, corresponding to read (r), write (w), and execute (x). For example, rwx indicates full permissions (read, write, execute) and r-- stands for read-only permissions.\nManage File System Permissions SHOW CONTENTS The chmod command is used to modify file system permissions for files and directories. The standard syntax is chmod [options] mode file_or_directory_name. The mode can be specified in either symbolic mode (e.g., r, w, x) or numeric mode (e.g., 755, 644). In numeric mode, permissions are represented by a three-digit number, where each digit corresponds to a set of permissions for the user, group, and others. Each permission is assigned a value: 4 for read, 2 for write, and 1 for execute. The sum of these values determines the permissions for each set. Below are some commonly used commands for changing file system permissions:\nchmod 755 file: Grants read, write, and execute permissions to the user, and read and execute permissions to the group and others. chmod 644 file: Grants read and write permissions to the user, and read-only permissions to the group and others. chmod +x file: Adds execute permission for all user categories (user, group, and others). chmod -x file: Removes execute permission for all user categories. chmod u+x file: Adds execute permission for the user (owner) only. chmod g-w file: Removes write permission from the group. chmod o+r file: Grants read permission to others. To change the user or group ownership of a file or directory in Linux, the chown command is used. Only the root user can change the ownership of a file. However, both the file’s owner and the root user can modify the file’s group ownership. While the root user can assign file ownership to any group, regular users can change the group ownership of a file only if they are members of the target group. Below are some commonly used commands for changing the user or group ownership of a file or directory.\nchown user_name file_name: Changes the owner of a file or directory to the specified user_name. chown user_name:group_name file_name: Changes both the owner and the group of a file or directory. chown :group_name file_name: Changes only the group ownership of the file or directory. chown -R user_name directory_name: Recursively changes the ownership of files and directories within the specified directory. chgrp group_name file_name: Changes only the group ownership of a file or directory to the specified group_name. chgrp -R group_name directory_name: Recursively changes the group ownership of files and directories within the specified directory. Sepcial Permissions \u0026 Default Permissions SHOW CONTENTS In Linux, special file permissions provide advanced control over file and directory access. These permissions include setuid, setgid, and the sticky bit.\nsetuid: This permission is represented with s in the user permission set. When set on an executable file, it allows the program to be executed with the privileges of the file owner (usually root) rather than the privileges of the user running the file. For example, the file /usr/bin/passwd is owned by the root user, but it can be executed by a regular user without sudo because it has the setuid permission in the user permission set (-rwsr-xr-x. 1 root root 32648 Aug 10 2021 /usr/bin/passwd). setgid (Group ID): This permission is represented with s in the group permission set. When applied to a file, it causes the program to run with the group privileges of the file’s group. For directories, it ensures that files created within the directory will inherit the directory’s group rather than the user’s group. For example, the file /usr/bin/locate (-rwx--s--x. 1 root slocate 41032 Aug 10 2021 /usr/bin/locate) has the setgid permission in the group permission set, allowing it to run with the group privileges of the file’s group. Similarly, the directory /run/log/journal (drwxr-sr-x+ 3 root systemd-journal 60 Apr 15 09:44 /run/log/journal/) has the setgid permission in the group permission set. This ensures that files created within the directory will inherit the systemd-journal group. sticky bit: This permission is represented with t in the others’ permission set. When applied to a directory, it allows only the file owner to delete or modify their files, preventing other users from tampering with them. For example, the directory /tmp (drwxrwxrwt. 20 root root 4096 Apr 17 08:32 /tmp) has the sticky bit set in the others’ permission set. This ensures that a user can only modify or delete the files in the /tmp directory that they own. In Linux, when a file or directory is created, its default permission is determined by the combination of the initial permission and the umask (user file creation mask). By default, files are created with initial permissions of 0666 (-rw-rw-rw-), and directories with 0777 (drwxrwxrwx). The umask defines which permission bits should be removed from these initial values, Typically, the default umask is 0022. This value can be modified in /etc/bashrc. For example, if the umask is set to 0022, a newly created file will have permissions 0644 (-rw-r--r--) because 0666 - 0022 = 0644. Similarly, a newly created directory will have permissions 0755 (drwxr-xr-x) because 0777 - 0022 = 0755.\n8. Monitor \u0026 Manage Linux Processes Process Life Cycle \u0026 States SHOW CONTENTS A process is a running instance of an executable program. Once created, a process includes several key components: an address space for allocated memory, security properties such as ownership and privileges, one or more execution threads for running code, and a process state that reflects its current status.\nThe environment of a process contains important contextual information, including local and global variables, the current scheduling context, and system resources like file descriptors and network ports that are assigned to the process.\nA new process is typically created when an existing parent process duplicates its own address space through a mechanism called a process fork. The resulting child process is assigned a unique Process ID (PID) for identification and security purposes. The child process also records the Parent Process ID (PPID) as part of its environment. On systems like Red Hat, all processes ultimately descend from the first system process, systemd.\nThrough the fork operation, the child process inherits the parent’s security credentials, file descriptors, resource privileges, environment variables, and program code. Once forked, the child process can continue running the same code or replace it with its own program logic using an exec family function.\nTypically, after creating a child process, the parent process enters a waiting state, pausing its own execution until the child finishes. When the child process exits, it releases its resources, but its process table entry remains temporarily as a zombie process. Once the parent receives a termination signal from the child, it performs cleanup by removing the zombie entry from the process table, freeing the last of the child’s resources, and then resumes its own execution.\nIn Linux, every process moves through a series of well-defined states during its lifecycle. The following image and table describe Linux process states in detail.\nTASK_INTERRUPTIBLE: TASK_UNINTERRUPTIBLE: TASK_KILLABLE: TASK_REPORT_IDLE: Flags TASK_UNINTERRUPTIBLE and TASK_NOLOAD are set. Similar to TASK_KILLABLE, also a subset of state D. It accepts fatal signals.\nName Flag Kernel-defined state name and description Running R TASK_RUNNING: The process is either executing on a CPU or waiting to run. The process can be executing user routines or kernel routines (system calls), or be queued and ready when in the Running (or Runnable) state. Sleeping S TASK_INTERRUPTIBLE: The process is waiting for some condition: a hardware request, system resource access, or signal. When an event or signal satisfies the condition, the process returns to Running. D TASK_UNINTERRUPTIBLE: This process is also sleeping, but unlike S state, does not respond to signals. Used only when process interruption might cause an unpredictable device state. K TASK_KILLABLE: Identical to the uninterruptible D state, but modified to allow a waiting task to respond to the signal that it should be killed (exit completely). Utilities frequently display Killable processes as D state. I TASK_REPORT_IDLE: A subset of state D. The kernel does not count these processes when calculating load average. Used for kernel threads. Flags TASK_UNINTERRUPTIBLE and TASK_NOLOAD are set. Similar to TASK_KILLABLE, also a subset of state D. It accepts fatal signals. Stopped T TASK_STOPPED: The process is stopped (suspended), usually by being signaled by a user or another process. The process can be continued (resumed) by another signal to return to running. T TASK_TRACED: A process that is being debugged is also temporarily stopped and shares the same T state flag. Zombie Z EXIT_ZOMBIE: A child process signals to its parent as it exits. All resources except for the process identity (PID) are released. X EXIT_DEAD: When the parent cleans up (reaps) the remaining child process structure, the process is now released completely. This state cannot be observed in process-listing utilities. In Linux, the ps and top commands are commonly used to inspect processes. The ps command displays information about active processes and is typically used to capture a snapshot of the processes running at a specific moment. In contrast, the top command provides a real-time, dynamic view of system processes, continuously updating to show CPU usage, memory usage, uptime, load average, and resource consumption for each process.\nControl Jobs SHOW CONTENTS In Linux, a job refers to a command or a group of commands initiated from a terminal by a user. Jobs can run in two modes: as a foreground job or a background job. A foreground job occupies the terminal until it completes, while a background job runs independently, allowing the terminal to remain available for other tasks. For example, executing vim file.txt starts a foreground job, which holds the terminal until the editor is closed. Running sleep 300 \u0026 starts a background job, allowing the terminal to remain usable while the command runs for 300 seconds in th e background.\nA process is a running instance of a program. When a job is initiated, one or more processes are created to perform the assigned tasks. For example, typing ls -l creates a new process to handle the application.\nA pipeline is a sequence of commands connected by the | operator, where the output of one command is passed directly as input to the next. For example, the command ps aux | grep nginx | sort forms a pipeline involving three separate processes working in succession. In this case, a pipeline runs as one job, but each part is a separate process.\nA session is a collection of processes initiated from a single user login. The first process created in a session is known as the session leader. For example, when a user logs in to a server via ssh user_name@ip_address, the shell process (bash, zsh, etc.) acts as the session leader. All jobs and processes started from that terminal belong to the same session.\nIn Linux, job control allows management of multiple jobs (commands or processes) within a single terminal session. Job control makes it possible to pause, resume, move jobs between the foreground and background, or terminate them. Below are the common-use commands for job control:\nCtrl + Z: Suspends the current foreground job and puts it into the background in a stopped state. bg: Resumes a suspended job in the background. fg: Brings a background job back to the foreground. jobs: Lists all jobs associated with the current terminal session, showing each job’s ID and status (e.g., running, stopped). In the output, a + next to a job ID denotes the current default job, which is the target of any bg or fg command issued without a %jobID. A - marks the previous job, which will become the default once the current default job completes or is removed. For example: [1] Running sleep 100 \u0026 [2] Running sleep 100 \u0026 [3]- Running sleep 100 \u0026 [4]+ Running sleep 100 \u0026 kill %job_number: Sends a signal (default is SIGTERM) to terminate a job, identified by its job number. Ctrl + C: Terminates a foreground job. Kill Processes SHOW CONTENTS In Linux, processes can be terminated using signals. A signal is a software interrupt that is delivered to a process. The following table describes common signals.\nSignal Number Description SIGTERM 15 Graceful termination (default) SIGKILL 9 Forcefully kill (non-catchable) SIGINT 2 Interrupt from keyboard (Ctrl+C) SIGHUP 1 Hang up / restart daemon SIGSTOP 19 Stop (pause) a process SIGCONT 18 Resume a stopped process Note that while signal numbers may vary across different Linux hardware platforms, signal names and their meanings remain consistent. It is generally recommended to use signal names rather than numbers when sending signals. Additionally, Red Hat advises sending SIGTERM first to allow the process to terminate gracefully, followed by SIGINT if necessary. If both signals fail, SIGKILL should be used as a last resort. The SIGKILL signal cannot be caught or ignored, and it forcibly terminates the process without giving it an opportunity to perform any self-cleanup.\nHere are some commonly used commands related to terminating processes:\nkill PID: Sends the SIGTERM signal to the specified process, requesting it to terminate gracefully. kill -SIGKILL PID: Sends the SIGKILL signal to forcefully terminate the specified process immediately (cannot be caught or ignored). killall process_name: Sends SIGTERM to all processes matching the given name, attempting a graceful termination. killall -SIGKILL process_name: Sends SIGKILL to all processes matching the given name, forcing termination. pgrep process_name: Searches for processes matching the given name and returns their PIDs. pgrep -u user_name process_name: Searches for processes with the specified name owned by a specific user. pkill process_name: Sends SIGTERM to all processes matching the given name, similar to killall. pkill -SIGKILL process_name: Sends SIGKILL to all processes matching the given name, forcing termination. pkill -u user_name: Sends a signal to all processes owned by the specified user. pstree -p: Displays the process tree with PIDs included. pstree -u: Displays the process tree with associated user names. In real-world scenarios, system administrators can forcibly terminate a user’s session to log them out. The following example demonstrates this process:\nwho -u # Lists all active user sessions along with their associated PIDs. pkill -t pts/0 # Sends SIGTERM (default) to processes attached to terminal pts/0. pkill -SIGINT -t pts/0 # If necessary, sends SIGINT to the same terminal. pkill -SIGKILL -t pts/0 # As a last resort, sends SIGKILL to forcefully terminate the session. Monitor Process Activity SHOW CONTENTS In Linux, the load average indicates the system’s workload over a period of time, measuring how many processes are either actively running or waiting to be executed by the CPU. The load average is typically represented by three numbers, corresponding to the system load over the past 1, 5, and 15 minutes. A load average of 1.0 per CPU is considered fully utilized, meaning that each CPU is handling one process at a time. For example, if a system has 2 CPUs, a load average of 2.0 would mean that the system is fully utilized. To inspect the number of CPUs in the system, the lscpu command can be used.\nFor instance, if a system has 2 CPUs and the uptime command returns:\n20:41:31 up 5:29, 3 users, load average: 3.32, 1.90, 0.32 The load average for the last minute is 3.32, which means the total load on the system is 3.32. With 2 CPUs, the per-CPU load average for the last minute is 1.66 (3.32 ÷ 2). This suggests the system is overloaded since the per-CPU load exceeds 1.0. The load average for the last 5 minutes is 1.90, and the per-CPU load average for this period is 0.95 (1.90 ÷ 2), indicating that the system is closer to optimal usage during this time. The load average for the last 15 minutes is 0.30, and the per-CPU load average is 0.16 (0.32 ÷ 2), suggesting the system is underutilized. 9. Control Services \u0026 Daemons SHOW CONTENTS In Linux, systemd daemon is the system and service mamager repsonsible for initializing the system during boot and managing processes throughout the machine’s lifetime. It handles the startup sequence, maintains service states, sepervises processes, and managees logging and dependencies.\nsystemd uses the concept of units to manage and control system resources. A unit represents a single object that systemd knows how to manage, such as a service, a device, a mount point, or a socket.\nEach unit is defined by a unit file, which describes how systemd should handle it — including how to start, stop, reload, and manage dependencies. Unit files are typically stored in directories like /usr/lib/systemd/system/ or /etc/systemd/system/.\nUnits are categorized by type, and the type is reflected in the file extension. Common unit types include:\n.service: for system services (e.g., nginx.service) .socket: for socket activation .target: for grouping units into milestones or states (like multi-user.target, graphical.target) .mount: for filesystem mount points .timer: for time-based activation, like a cron replacement .device: for hardware devices .path: for path-based activation To interact with systemd, the systemctl is used. It allows administrators to manage services, check system states, enable or disable services at boot, and control system targets. Here are some commonly used commands:\nsystemctl status nginx: Displays the status of the nginx service. systemctl start nginx: Starts the nginx service. systemctl stop nginx: Stops the nginx service. systemctl restart nginx: Restarts the nginx service. systemctl enable nginx: Configures nginx to start automatically at boot. systemctl disable nginx: Disables automatic start at boot for nginx. systemctl reload-or-restart nginx: Reload the configuration if supported; otherwise, restart the service. systemctl is-enabled nginx: Check if the service is enabled to start at boot. systemctl is-active nginx: Check if the service is currently running. systemctl list-dependencies nginx: List the dependencies of the service. systemctl mask sendmail.service: Mask the service to prevent it from being started. systemctl unmask sendmail.service: Unmask the service to allow it to be started again. systemctl list-units --type=service: Lists all active services. systemctl reboot: Reboots the system. systemctl poweroff: Powers off the machine. 10. Configure \u0026 Secure SSH SHOW CONTENTS SSH (Secure Shell) is a protocol used to securely access and manage remote systems over an unsecured network. It provides encrypted communication between a client and a server, allowing for secure login, command execution, and file transfer. Here are common SSH usage examples:\nssh user@host: Connect to a remote server using the specified user account. ssh user@host command: Execute a command on the remote server without opening an interactive shell. SSH also allows passwordless login to a remote server by using a pair of cryptographic keys: A private key and a public key. A private key is kept on the client machine while the public key is stored on the remote server in ~/.ssh/authorized_keys. When connecting, the server uses the public key to verify the client’s private key. If the key match, the connection is granted without prompting for a paasword. To enable this feature, following the following steps:\nssh-keygen -t rsa -b 4096 -C \"RHEL 9 ON Virtual Machine\": Generate a key pair on the client. ssh-copy-id user_name@ip_address: Copy the public key to the remote server. ssh user_name@ip_address: Connect to the server. The default configuration of the SSH server works well for many use cases. To apply custom settings (e.g., disable remote login as root), edit the /etc/ssh/sshd_config file, modify the field PermitRootLogin to no. After modifying the configuration, apply the changes by running systemctl reload ssh.\n11. Analyze \u0026 Store Logs System Log Architecture SHOW CONTENTS In Red Hat Enterprise Linux, the standard logging system is based on the Syslog protocol, and the systemd-journald and rsyslog services are responsible for handling syslog messages.\nThe systemd-journald service forms the core of the operating system’s event logging architecture. It collects event messages from multiple sources, such as the system kernel, output from the early stages of the boot process, standard output and standard error from daemons, and Syslog events. systemd-journald restructures these logs into a standard format and writes them into a structured, indexed system journal. By default, this journal is stored in a file system that does not persist across reboots.\nOn the other hand, the rsyslog service reads syslog messages that systemd-journald receives from the journal as they arrive. It then processes the syslog events and records them to log files or forwards them to other services according to its configuration. The rsyslog service sorts and writes syslog messages to log files in the /var/log directory, which are persistent across reboots. This directory not only contains syslog message files but also log files from other services on the system. Below is a list of some useful log files located in the /var/log directory:\nLog File Description /var/log/messages Logs most system messages, including general syslog messages. Exceptions include authentication-related messages, email processing, scheduled job execution, and debug information. /var/log/secure Logs security-related messages, including authentication events and user access information. /var/log/maillog Logs messages related to the mail server, including both mail delivery and other mail-related operations. /var/log/cron Logs messages related to the execution of scheduled jobs (cron jobs). /var/log/boot.log Logs non-syslog console messages related to system startup and boot processes. Review Syslog Files SHOW CONTENTS In Linux, each log message is categorized by facility (which subsystem produces the message) and priority (the message’s severity). The following table lists the standard syslog facilities.\nCode Facility Description 0 kern Kernel messages 1 user User-level messages 2 mail Mail system messages 3 daemon System daemons messages 4 auth Authentication and security messages 5 syslog Internal syslog messages 6 lpr Printer messages 7 news Network new messages 8 uucp UUCP protocol messages 9 cron Clock daemon messages 10 authpriv Non-system authorization messages 11 ftp FTP protocol messages 16-23 local0 to local7 Custom local messages The following table lists the standard syslog priorities in descending order.\nCode Priority Description 0 emerg System is unusable 1 alert Action must be taken immediately 2 crit Critical condition 3 err Non-critical error condition 4 warning Warning condition 5 notice Normal but significant event 6 info Informational event 7 debug Debugging-level message The rsyslog service uses the facility and priority of log messages to determine how to handle them. Rules configure this facility and priority in the /etc/rsyslog.conf file and in any file in the /etc/rsyslog.d directory with the .conf extension.\nTo prevent log files from consuming too much disk space, Linux uses log rotation, a utility that automatically handles the archiving, compressing, and deletion of old log files. A scheduled job runs the logrotate command daily to check if any log files need to be rotated. When a log file is rotated, it is renamed with an extension indicating the rotation date. For example, the old /var/log/messages file might be renamed to /var/log/messages-20250419 when it is rotated on April 19, 2025. After rotations, typically over four weeks, the oldest log files are discarded to free up disk space.\nThe tail -f command in Linux is commonly used for monitoring log files in real time. It allows users to continuously view the latest entries being added to a log file, which is especially useful for monitoring system events and troubleshooting. Here is a sample example:\ntail -f /var/log/secure # In the first terminal ssh signalyu999@ip_address # In the second terminal The logger command sends messages to the rsyslog service, which is useful for testing changes to the rsyslog configuration. By default, it logs messages with the user facility and notice priority (user.notice), unless specified otherwise using the -p option. For example, to send a message to the rsyslog service and have it recorded in the /var/log/boot.log log file, the following logger command can be used:\n# /etc/rsyslog.conf # Save boot messages also to boot.log # local7.* /var/log/boot.log logger -p local7.notice \"Log entry created on host\" # TEST # 1. In the first terminal: tail -f /var/log/boot.log # 2. In the second terminal: logger -p local7.notice \"Log entry created on host\" Review System Journal Entries SHOW CONTENTS The systemd-journald service stores log data in a structured, indexed binary file called the journal. To retrieve log messages from the journal, the journalctl command is used. Below are some commonly used commands:\njournalctl --since \"2025-04-18\" --until \"2025-04-19\": Shows logs from April 18, 2025, to April 19, 2025. journalctl --since \"today\": Displays logs from the current day (since midnight). journalctl --since \"-1 hour\": Shows logs from the last hour. journalctl --since \"-10 minutes\": Displays logs from the last 10 minutes. journalctl -n 50: Shows the last 50 log entries. journalctl -u sshd: Displays logs related to the sshd service (SSH daemon). journalctl -f: Continuously shows the latest log entries in real-time. journalctl -p err: Filters and shows logs with “error” priority or higher. journalctl _PID=1234: Shows logs related to the process with PID 1234. journalctl _SYSTEMD_UNIT=sshd.service: Displays logs related to the sshd.service systemd unit. journalctl -b: Shows logs from the current boot session. Preserve the System Journal SHOW CONTENTS The systemd-journald service stores log data in a structured, indexed binary format known as the system journal. By default, Red Hat Enterprise Linux 9 stores the system journal in the /run/log directory, and the system clears the system journal after a reboot. To change this behavior and retain logs across reboots, the Storage parameter in the /etc/systemd/journald.conf file can be set to persistent. After modifying the configuration, the systemd-journald service must be restarted for the changes to take effect.\nThe Storage parameter has four options:\npersistent: Stores journals in the /var/log/journal directory, ensuring logs persist across reboots. If the /var/log/journal directory does not exist, the systemd-journald service creates it automatically. volatile: Stores journals in the volatile /run/log/journal directory. These logs are lost upon reboot. auto: If the /var/log/journal directory exists, logs are stored persistently. If the directory does not exist, volatile storage is used. This is the default behavior of the Storage parameter. none: Disables journal storage entirely, meaning no logs are stored. Maintain Accute Time SHOW CONTENTS In Linux, maintaining accurate system time is crucial for tasks such as logging, scheduling, and ensuring syschronization across different systems. Time syschronization is typically achieved through the use of the NTP (Network Time Protocol). The NTP is a standard way for machines to provide and obtain correct time information over the internet.\nMaintaing accurate time commonly involves two commands: tzselect and timedatectl. The tzslect command is an interactive utility used to select a time zone on Linux systems. It guides users through a series of prompts to set the time zone by selecting regions and cities form a list. It is helpful when users do not know the exact time zone string. The timedatectl command is provided by systemd to manage time and time zone settings on Linux systems. It allows users to query and set the system’s time, date, and time zone, as well as synchronize the system clock with NTP. Here are some common sample examples of timedatectl:\ntimedatectl status: Displays the current time zone, NTP status, and system time information. sudo timedatectl set-time \"YYYY-MM-DD HH:MM:SS\": Sets the system date and time manually. sudo timedatectl set-timezone : Changes the system’s time zone. timedatectl list-timezones: Lists all available time zones. sudo timedatectl set-ntp true: Enables NTP (Network Time Protocol) synchronization. sudo timedatectl set-ntp false: Disables NTP synchronization. sudo timedatectl set-local-rtc true: Sets the system clock to local time (RTC). sudo timedatectl set-local-rtc false: Sets the system clock to UTC (coordinated universal time). timedatectl show: Displays detailed information about the time and date settings. The chrond service keeps on track the usually inaccurate local Real-Time-Clock (RTC) by synchronizing it to the configured NTP servers. If network connectivity is unavailable, it calculates the RTC drift and stores the data in a file specified by the driftfile parameter in the /etc/chrony.conf configuration file. By default, chronyd uses servers from the NTP Pool Project but can be configured to use different servers for isolated networks. NTP servers are categorized by their stratum, with stratum 0 being a reference clock and higher strata representing servers that sync with other NTP servers. In the configuration file, servers and peers are defined, with the server being one stratum above the local server and peers at the same level. The iburst option is recommended for faster and more accurate initial synchronization.\n12. Manage Networking Networking Related Commands SHOW CONTENTS ip: A versatile tool for managing network interfaces, routing, and tunneling. ip addr pr ip a: Show IP addresses assigned to all interfaces. ip addr add 192.168.1.100/24 dev eth0: Assign an IP address to an interface. ip link or ip l: Show network interfaces and their status. ip link set eth0 up: Enable (bring up) a network interface. ip link set eth0 down: Disable (bring down) a network interface. ip route or ip r: Display the current routing table. ip route add 192.168.2.0/24 via 192.168.1.1: Add a static route. ip route del 192.168.2.0/24: Delete a route. ip neigh: Show the ARP table (neighbor cache). ss: A utility to investigate sockets. It is used for displaying information about network connections, listening ports, etc. ss: Display all established sockets and connections. ss -t: Show only TCP connections. ss -u: Show only UDP connections. ss -l: Show listening sockets. ss -tunlp: Show TCP/UDP listening ports with process info (-p). ss -s: Display a summary of socket statistics. ss -t state established: Show established TCP connections. ss -an: Show all sockets (listening and non-listening) in numeric format. ss -o state established: Show established connections with timers. ping: A tool used to test network connectivity between the client and the remote host by sending ICMP echo requests. ping baidu.com traceroute: A tool to trace the path packets take to reach a network destination, showing each hop along the way. traceroute : Trace the route packets take to reach the target host. traceroute -n : Show IP addresses only, skip hostname resolution (faster). traceroute -m 20 : Set maximum number of hops to 20. traceroute -p 80 : Use destination port 80 (helpful for testing web servers). traceroute -I : Use ICMP ECHO instead of UDP packets. traceroute -T : Use TCP SYN packets instead of UDP (helpful for firewalled networks). tracepath: A simpler version of traceroute that shows the path packets take to a destination but also provides information about packet loss and latency along the way. tracepath : Trace the path to a destination, showing each network hop along the way. tracepath -n : Display IP addresses only, skip reverse DNS lookup (faster). tracepath6 : Use IPv6 to trace the route to the target. host: A simple DNS lookup tool that resolves domain names to IP addresses. host : Resolve a domain name to its IP address. dig: A DNS lookup tool that queries the Domain Name System (DNS) for information about hostnames, IP addresses, and other DNS records. dig : Query the default DNS records (usually A records) for a domain. nmcli: A command-line interface for NetworkManager, used for manageing network connections and settings, such as configuring interfaces, VPNs, and Wi-Fi. nmcli device status or dev con status: Show the status of all network interfaces. nmcli connection show or nmcli con show: List all saved network connections. nmcli connection up : Activate a network connection. nmcli connection down : Deactivate a network connection. nmcli device connect : Connect a network device. nmcli device disconnect : Disconnect a network device. getent: A command used to query various system databases, including DNS, password, group, and hosts. It is useful for retriving information that’s typically stored in files like /etc/hosts or through services like DNS. getent hosts : Resolve a hostname to its IP address (similar to host or nslookup). getent services : Lookup port and protocol for a service (e.g., getent services ssh). getent protocols: List network protocols. getent passwd: List all user account entries from /etc/passwd or configured name service. getent passwd : Query information for a specific user. getent group: List all group entries from /etc/group or configured name service. getent group : Query information for a specific group. Configure Network SHOW CONTENTS In RHEL 9, the network can be configured through file-based settings by creating a .nmconnection file in the /etc/NetworkManager/system-connections directory. After editing the configuration, set the file permissions to restrict access to the root user for security. Update the /etc/resolv.conf file to specify DNS servers. Once the configuration is complete, reload the NetworkManager connection profiles to apply the changes. If autoconnect is set to false, manually bring the connection up.\nvim /etc/NetworkManager/system-connections/ens160-static.nmconnection: Open or create the network configuration file for editing. Edit the configuration file as below: [connection] id=ens160 uuid=62b7fd25-b5d9-3cae-8156-bc455c45b046 type=ethernet autoconnect-priority=-999 interface-name=ens160-static timestamp=1744708123 [ethernet] [ipv4] method=manual address1=192.168.254.138/24 gateway=192.168.254.2 ignore-auto-dns=true [ipv6] addr-gen-mode=eui64 method=auto [proxy] chown root:root /etc/NetworkManager/system-connections/ens160-static.nmconnection: Set the file owner and group to root. chmod 600 /etc/NetworkManager/system-connections/ens160-static.nmconnection: Restrict permissions so only the root user can read and modify the file. vim /etc/resolv.conf: Edit the configuration file as below: # Generated by NetworkManager nameserver 8.8.8.8 nameserver 8.8.4.4 nmcli con reload: Reload NetworkManager connection profiles to apply changes. nmcli con up ens160-static: Bring the ens160-static connection up manually (required if autoconnect is disabled). 13. Archive \u0026 Transfer Files Manage Compressed tar Files SHOW CONTENTS An archive is a single file that stores multiple files and directories, often used for creating backups or simplifying file transfers across a network. On Linux, the tar utility is commonly used to create, manage, and extract archives. Below are some frequently used commands:\ntar -cvf archive.tar file1 file2: Archives multiple files into a single uncompressed .tar file. tar -xvf archive.tar file1 file2 -C ./archives/: Extracts specific files from an uncompressed .tar archive to the ./archives/ directory. tar -czvf archive.tar.gz file1 file2: Creates a compressed .tar.gz archive from multiple files using gzip compression. tar -xzvf archive.tar.gz file1 file2 -C ./archives/: Extracts specific files from a .tar.gz compressed archive to the ./archives/ directory. tar -cjvf archive.tar.bz2 file1 file2: Creates a compressed .tar.bz2 archive using bzip2 compression. tar -xjvf archive.tar.bz2 file1 file2 -C ./archives/: Extracts specific files from a .tar.bz2 compressed archive to the ./archives/ directory. tar -cJvf archive.tar.xz file1 file2: Creates a compressed .tar.xz archive using xz compression. tar -xJvf archive.tar.xz file1 file2 -C ./archives/: Extracts specific files from a .tar.xz compressed archive to the ./archives/ directory. Transfer Files Using sftp SHOW CONTENTS To securely transfer files between systems, use the sftp command. Below are some commonly used sftp commands:\nsftp user_name@ip_address:/home/user_name/remote_file: Connect to the server and directly fetch a remote file to the local. sftp user_name@ip_address: Connect to the remote server via SFTP. help: Display a list of available SFTP commands. pwd: Show the current remote working directory. lpwd: Show the current local working directory. ls: List files in the remote directory. lls: List files in the local directory. cd: Change the remote directory. lcd: Change the local directory. put: Upload a file from local to remote. put -r: Recursively upload an entire directory. mput: Upload multiple files matching a pattern. get -r: Recursively download an entire remote directory. mget: Download multiple files matching a pattern. bye: Exit the SFTP session. Synchronize File Using rsync SHOW CONTENTS rsync is a fast and versatile command-line tool for copying and synchronizing files locally and remotely. It only transfers the differences between source and destination, saving time and bandwidth. Below are some commonly used rsync commands:\nrsync -avz source/ destination/: synchronize files/directories locally with compression and verbose output. rsync -avh /local/path/ /destination/path/: sync local directories with human-readable file sizes. rsync -avz /local/path/ user@remote:/remote/path/: upload files from local to remote server over SSH. rsync -avz user@remote:/remote/path/ /local/path/: download files from remote server to local machine. rsync -avz --delete /local/path/ user@remote:/remote/path/: sync local to remote and delete files on remote that don’t exist locally. rsync -avz -e ssh /local/path/ user@remote:/remote/path/: sync files over SSH, explicitly specifying the SSH protocol. 14. Install \u0026 Update Software Packages Change Repository Mirror SHOW CONTENTS By default, Red Hat Enterprise Linux (RHEL) 9 uses the official repository as its software source. To replace it with the Alibaba Cloud CentOS Stream mirror, follow these steps:\nOpen the redhat.repo file and disable the BaseOS and AppStream repositories by changing enabled=1 to enabled=0: sudo vim /etc/yum.repos.d/redhat.repo BaseOS and AppStream are two key repositories used in Red Hat-based Linux to organize and manage system software and applications. The BaseOS contains the essential operating system components, such as the kernel, system libraries, and core utilities. While the AppStream contains additional software packages that are not esssential for the base system but are needed for specific applications and use cases. Create a new repository file named aliyun.repo and add the following configuration: [AppStream] name = Aliyun Centos Stream - AppStream baseurl = https://mirrors.aliyun.com/centos-stream/9-stream/AppStream/x86_64/os/ enabled = 1 gpgcheck = 0 [BaseOS] name = Aliyun Centos Stream - BaseOS baseurl = http://mirrors.aliyun.com/centos-stream/9-stream/BaseOS/x86_64/os/ enabled = 1 gpgcheck = 0 Clean the existing DNF cache to remove outdated metadata: sudo dnf clean all Rebuild the repository cache to ensure the new mirror is loaded: sudo dnf makecache Note: If the transaction test fails when running sudo dnf update (for example, due to package conflicts), the issue can be temporarily avoided by excluding the conflicting packages:\nsudo dnf update --exclude=openssl* This allows the update process to complete for other packages while the conflict is handled separately.\nInstall \u0026 Update Software Packages with dnf SHOW CONTENTS DNF (Dandified YUM) is the default package manager for RPM-based Linux distributions such as Fedora, CentOS, and RHEL. While DNF offers improved performance and new features over YUM, its commands are largely functionally identical. For backward compatibility, YUM commands still exist as symbolic links to DNF. Below are some basic dnf commands:\ndnf install : Installs the specified package. dnf update: Updates all installed packages to their latest versions. dnf remove : Removes the specified package from the system. dnf search : Searches for a package by name or description. dnf list installed: Lists all installed packages on the system. dnf list : Lists detailed information about the specified package. dnf info : Provides detailed information about the specified package (e.g., version, repository, dependencies). dnf upgrade: Upgrades all installed packages to the latest versions, including kernel updates. dnf clean all: Cleans up the local repository cache to free up disk space. dnf makecache: Forces DNF to refresh and rebuild the metadata cache. The dnf command also has the concept of groups. A package group is a collection of related software packages that can be installed or removed together. Here are some common dnf group commands:\ndnf group list: Lists all available package groups, including those that are installed and those that can be installed from repositories. dnf group list installed: Lists only the package groups that are currently installed on the system. dnf group info : Displays detailed information about a specific package group, including the list of packages that belong to that group. dnf group install : Installs all packages within a specified group, allowing you to easily install related software at once. dnf group remove : Removes all packages in a specified group from the system. dnf group update : Updates all the packages in the specified group to their latest available versions. dnf group upgrade : Upgrades all the packages in the specified group, including dependencies and related packages. Transaction History refers to the record of package transactions, such as installations, removals, and updates. The dnf history command allows you to view past actions taken by DNF and revert to previous states when necessary. Below are some common dnf history commands:\ndnf history: Lists all past transactions, showing details such as transaction ID, date, action (install, remove, update), and affected packages. dnf history info : Displays detailed information about a specific transaction, including the packages that were installed, removed, or updated. dnf history undo : Reverts the changes made in a specific transaction, such as undoing the installation or removal of packages. dnf history rollback : Restores the system to the state it was in immediately after a specified transaction, undoing all changes made since that transaction. dnf history reset: Clears the transaction history, removing all past transaction records from the system. DNF Modularity is a feature of the DNF package manager that enables users to install different versions of software packages within a single distribution. Key concepts of DNF Modularity includes Modules, Streams, and Profiles.\nModules A module is a collection of related packages that can be installed or removed together, and each module can have multiple streams (versions) of a package. Streams: Streams represent different versions or variants of a module. For example, a module for python may have different streams for python3.6, python3.8, etc. Profiles: Profiles are predefined sets of packages that can be installed as part of a module. A profile could include a minimal installation or a development environment for a specific stream. Here are some common dnf module commands: dnf module list: Lists all available modules and their streams. dnf module enable : Enables a module, allowing the installation of its packages. dnf module disable : Disables a module, preventing its packages from being installed. dnf module install : Installs a module and its packages, using the default stream unless specified. dnf module info : Shows detailed information about a module, including its streams and profiles. dnf module update : Updates a module and its packages to the latest available versions. dnf module provides : Displays which module provdies a specific package. 15. Access Linux File System Disk Partition SHOW CONTENTS A file system is a method of organizing and storing data on storage devices. It defines how data is stored, retrieved, and managed. To examine the file system on Linux, the df command provides an overview of disk space usage, while the du command offers detailed information about the disk usage of a specific file or directory. Here are some useful commands:\ndf -h: Displays disk space usage in a human-readable format. df -T: Displays the file system type along with disk space usage. du -h : Displays disk usage for a specific directory in a human-readable format. du -sh: Displays the total disk usage of the current directory in a human-readable format. du -sh : Displays the total disk usage for a specified directory in a human-readable format. Common file systems include ext4, NTFS, and XFS. To access the contents of a file system, it must be mounted to an empty directory, known as the mount point.\nTypically, the entire storage device is not formatted into a single file system; instead, it is divided into several partitions. Each partition is considered a block device in its own right. For example:\nThe first partition on the first SATA-attached storage is /dev/sda1. The second partition on the same device is /dev/sda2. The second partition on the second device is /dev/sdb2. The third partition on the third SATA-attached storage is /dev/sdc3, and so on. To mount a file system manually, follow these steps:\nIdentify Block Devices: Use the lsblk command to identify available block devices. (Use fdisk for partition manipulation when needed.) Create a Mount Point: Create an empty directory (mount point) using the mkdir command. Mount the Device: Use the sudo mount command to mount the file system. Verify the Mount: Use the df command to verify the mount operation. Here’s an example of device mounting:\n# 1. Use lsblk to get the block device name lsblk # 2. Create a mount point mkdir /mnt/data # 3. Mount the device sudo mount /dev/sdb1 /mnt/data # 4. Verify the mount operation df -h Note that file systems are automatically unmounted when the system shuts down or reboots. To ensure a file system is mounted at boot, edit the /etc/fstab file and add the following line:\n/dev/sdb1 /mnt/data ext4 defaults 0 0 To unmount a device, ensure all processes related to it are terminated, then use the umount command:\numount /mnt/data Locate File on the System SHOW CONTENTS To locate a file on a Linux system, commonly used commands include find, locate, which, and whereis.\nThe find command searches for files in real time by parsing the file system hierarchy. Here are some commonly used find examples:\nfind /home -name \"myfile.txt\": Searches for a file named myfile.txt in the /home directory. find / -name \"*.log\": Searches for all .log files starting from the root directory. find / -iname \"*message*\": Searches for files that contain the word “message” (case-insensitive) in their names, starting from the root directory /. find /home -name \"*.txt\" -size +1M: Finds .txt files larger than 1MB in the /home directory. find /home -name \"*.txt\" -size -1G: Finds .txt files smaller than 1GB in the /home directory. The locate command searches a pre-generated index of file names and paths, making it much faster than find. However, it may not reflect recent changes in the file system until the index is updated. To update the database, use the updatedb command. Below are common locate examples:\nsudo updatedb # Updates the locate database locate file.txt # Searches for the file \"file.txt\" The which command locates executables in the directories listed in the $PATH environment variable. It is useful for determining the location of a command or executable. For example:\nwhich python # Finds the path of the python executable The whereis command is used to locate the binary, source, and manual page files associated with a command. It is commonly used to search for documentation and related files. For example:\nwhereis python # Finds binary, source, and man page for python 16. Schedule Future Tasks Schedule a User Job SHOW CONTENTS To schedule a deferred user job, the at command and the cron system can be used. The at command is suitable for one-time deferred tasks, while the cron system is better for recurring tasks.\nThe at command schedules a one-time deferred task to run at a specific time in the future. To view pending jobs, use the atq command. When there is a need to cancel or remove a scheduled job, use the atrm command along with the job ID, which can be obtained from the atq command. Below is an example of using at command:\necho \"date \u003e\u003e ~/myjob.txt\" | at now +1 minute For recurring tasks, use the crontab command. Below is an example of scheduling a job to run every day at 3 AM:\ncrontab -e 0 3 * * * date \u003e\u003e ~/myjob.txt # Schedule at 3 AM every day Schedule a System Job SHOW CONTENTS To schedule a system job, it is necessary to edit the /etc/crontab file or create a custom cron job file inside the /etc/cron.d/ directory. (Note that files in /etc/cron.d/ are not executable by default; to make them executable, run chmod +x file_name.) The shell scripts executed by these job entries are typically located in directories such as /etc/cron.hourly/, /etc/cron.daily/, etc. Below are some common examples of scheduling system jobs:\n# 1. Create a script named hourly_job.sh in /etc/cron.hourly/ sudo vim /etc/cron.hourly/hourly_job.sh # 2. Add the following content to the script #!/bin/bash echo \"Hourly job executed at $(date)\" \u003e\u003e /var/log/hourly_job.log # 3. Make the script executable sudo chmod +x /etc/cron.hourly/hourly_job.sh Anacron is used for scheduling tasks that should run periodically but not necessarily at fixed times. It ensures that a missed job is executed as soon as possible after the system starts up. Below is an sample example:\n# period delay job-identifier command # 1 5 dailybackup /usr/local/bin/backup.sh # Run a daily backup at system start (5 minutes after boot) 1 5 dailybackup /usr/local/bin/backup.sh Systemd timers provide a more flexible way of scheduling tasks on Linux systems. They integrate with the systemd service manager, which makes them more powerful and capable of handling advanced scenarios. A systemd timer works by triggering a systemd service at specific intervals. It uses two components: Timer Unit and Service Unit.\nTimer Unit: Defines when the task will be executed. Service Unit: Defines the actual task to be run. Below is an example:\n# 1. Create a service file sudo vim /etc/systemd/system/myjob.service # 2. Add the following content to the file [Unit] Description=Run my scheduled task [Service] Type=oneshot # The service runs a one-time task ExecStart=/usr/local/bin/myscript.sh # Specifies the command to execute # 3. Create a timer unit sudo vim /etc/systemd/system/myjob.timer # 4. Add the following content to the file [Unit] Description=Run my job every day at 3 AM [Timer] OnCalendar=daily # Schedules the task to run once a day Persistent=true # Ensures that if the system is off during the scheduled time, the task will run once the system boots up. [Install] WantedBy=timers.target # 5. Reload the systemd sudo systemctl daemon-reload # 6. Enable and start the timer sudo systemctl enable myjob.timer sudo systemctl start myjob.timer Manage Temporary Files SHOW CONTENTS systemd-tmpfiles is a utility provided by systemd that allows for automatic management of temporary files and directories on Linux systems. It is primarily used to clean up temporary files, manage file permissions, and enforce file creation rules. systemd-tmpfiles works based on configuration files located in /etc/tmpfiles.d/, /usr/lib/tmpfiles.d/, and /run/tmpfiles.d/. Below is an example of automatic clean up:\n# 1. Create a configuration file sudo vim /etc/tmpfiles.d/temp_cleanup.conf # 2. Add the following content to the file # Type Path Mode UID GID Age Argument # Remove any .log files in /tmp that are older than 7 days. f /tmp/*.log 0644 root root 7d - # Remove empty directories in /tmp older than 7 days. d /tmp/ 1777 root root 7d - # 3. Create a system timer for automatic cleanup sudo vim /etc/systemd/system/tmpfiles-cleanup.timer # 4. Add the following content to the file [Unit] Description=Automatic cleanup of temporary files [Timer] # Run 1 hour after boot, then once every day OnBootSec=1h OnUnitActiveSec=1d Unit=systemd-tmpfiles-clean.service [Install] WantedBy=timers.target # 5. Create the service unit for systemd-tmpfiles cleanup sudo vim /etc/systemd/system/systemd-tmpfiles-clean.service # 6. Add the following content [Unit] Description=Cleanup temporary files using systemd-tmpfiles [Service] Type=oneshot ExecStart=/usr/bin/systemd-tmpfiles --clean # 7. Reload the systemd sudo systemctl daemon-reload # 8. Enable and start the timer sudo systemctl enable tmpfiles-cleanup.timer sudo systemctl start tmpfiles-cleanup.timer 17. Tune System Performance Adjust Tuning Profiles SHOW CONTENTS The tuned utility is used to statically and dynamically adjust a system’s configuration and optimize its performance based on different use cases, such as improving I/O performance, network throughput, and power saving.\nStatic tuning configures predefined kernel parameters in a profile that the tuned daemon applies at runtime. These kernel parameters are set for overall performance expectations, but they do not change in response to system activity. Dynamic tuning allows the tuned daemon to monitor system activity and adjust settings based on runtime behavior changes. By default, dynamic tuning is disabled. To enable it, simply change the dynamic_tuning variable in the /etc/tuned/tuned-main.conf configuration file. When enabled, tuned periodically monitors the system and adjusts the tuning settings according to the observed behavior. The frequency of updates can be controlled by modifying the update_interval variable in the same configuration file (in seconds between updates). The tuned utility provides several predefined profiles and allows for the creation of custom profiles to optimize a system’s behavior for specific workloads, such as servers, laptops, or high-performance environments. Below are some common commands for managing profiles:\ntuned-adm active: Show the currently active profile. tuned-adm list: List all available profiles. tuned-adm profile_info: Show information about the active profile. tuned-adm profile_info : Show information about a specific profile. tuned-adm profile : Apply a specific tuning profile. tuned-adm recommend: Recommend an optimal profile based on the system’s current usage. tuned-adm off: Disable tuned and stop dynamic tuning. Influence Process Scheduling SHOW CONTENTS In Linux, process priorities determine the order in which processes are scheduled to run on the CPU. The scheduling policy and nice value are key factors in how the operating system manages process execution.\nCommon scheduling policies include SCHED_NORMAL/SCHED_OTHER, SCHED_FIFO, and SCHED_RR.\nSCHED_NORMAL/SCHED_OTHER (TS): This is the default policy used for most processes, where tasks are scheduled based on their priority and time-sharing behavior. SCHED_FIFO (FF): A real-time policy where processes are executed in a first-in, first-out manner. It gives higher priority to processes with lower numerical values, without time slicing. SCHED_RR (RR): Each process gets a fixed time slice before the next one is executed, providing better responsiveness. The nice value (default is 0) is an integer that can range from -20 (highest priority, maps to a 0 in the top command) to +19 (lowest priority, maps to a 39 in the top command). It allows users to influence the priority of a process, where a lower nice value gives the process higher priority in CPU scheduling. A higher nice value lowers the priority. To view the nice value of a running process, use the ps or top command. In top, the nice value is displayed under the NI column. Below is an example of using ps:\nps -eo pid,comm,ni,cls --sort=-ni By default, when a process starts from the command line, it inherits its nice value from the shell process (default value is 0). To start a new process with a specific nice value, use the nice command. Here are some examples:\nnice sleep 60 \u0026 # Start a new process with the default nice value (0) nice -n 15 sleep 60 \u0026 # Start a new process with a nice value of 15 To adjust the nice value of an existing process, use the renice command. The renice command allows users to change the nice value of a running process. Unprivileged users may only increase the nice value (lower the priority), up to a maximum of 19. Privileged users can both increase and decrease the nice value, with a minimum of -20. It is available to modify the nice value of a process from the interactive interface of top by pressing r, entering the process ID, and then specifying the new nice value. Below is an example of using renice:\nrenice -n 18 1997 # Change the nice value of the process with PID 1997 to 18 18. Manage SELinux Security Change the SELinux Environment Mode SHOW CONTENTS SELinux (Security-Enhanced Linux) is a security module for the Linux kernel that provides a mechanism for enforcing access control security policies. It ensures resource access is controlled at a granular level. Unlike traditional file permissions, which control file access for specific users or groups, SELinux prevents even authorized users with access to a file from using it for unintended purposes. SELinux operates based on application-specific policies, such as the targeted policy, which precisely defines the allowed actions and access for each binary executable, configuration file, and data file used by an application.\nSELinux policies are security rules that define how specific processes can access files, directories, and ports. Each resource entity—such as a file, process, directory, or port—has a label called an SELinux context, which can be viewed using -Z option in many commands. Each SELinux context consists of four fields: user, role, type, and security level.\nUser: Specifies the SELinux user associated with the resource. Role: Defines the role assigned to the resource, determining the permitted actions within the system. Type: Specifies the type or category of the resource, which is used for defining access controls. Security level: Indicates the security classification or sensitivity level of the resource. For example, a web server process runs with the httpd_t type context. By default, files and directories in the /var/www/html/ directory have the httpd_sys_content_t type context A web server can access the httpd_sys_content_t labeled files, but has no rules to allow access to files for other services, such as mysqld_db_t labeled files.\nSELinux supports three operational modes: enforcing, permissive, and disabled.\nEnforcing: SELinux is actively enforcing security policies. blocking any unauthorized access based on the policy. Permissive: SELinux logs any policy violations but does not block the access. This mode is helpful for testing and troubleshooting applications and rules. Disabled: SELinux is completely turned off. (Note that starting in Red Hat Enterprise Linux 9, SELinux can be fully disabled only by using the selinux=0 kernel parameter at boot.) To change the SELinux mode, the setenforce command can be used, or the /etc/selinux/config file can be edited. It is recommended to reboot the system after making changes. To enable or disable SELinux, pass selinux=1 or selinux=0 respectively during system boot. Below are some examples of how to change the SELinux mode using commands:\ngetenforce # Displays the current SELinux mode setenforce enforcing # Sets SELinux to enforcing mode setenforce 1 # Equivalent to setenforce enforcing Control SELinux File Contexts SHOW CONTENTS By default, SELinux labels files based on policies defined in the /etc/selinux/targeted/contexts/files/ directory. When creating a new file, it inherits the same label as its parent directory unless a specific label is applied. If a file is copied, its context will change, as copying a file creates a new inode. However, moving a file does not change its context, because moving a file only updates the inode’s filename without altering the inode itself. To preserve the context while copying, the -p or --preserved=context option can be used. For moving files, the -Z option is used to explicitly change the SELinux context. Below is an example:\nls /tmp # system_u:object_r:tmp_t:s0 /tmp touch /tmp/file1 /tmp/file2 /tmp/file3 ls -Z /tmp/file* # unconfined_u:object_r:user_tmp_t:s0 /tmp/file1 # unconfined_u:object_r:user_tmp_t:s0 /tmp/file2 # unconfined_u:object_r:user_tmp_t:s0 /tmp/file3 ls -Zd ~/ # unconfined_u:object_r:user_home_dir_t:s0 /home/signalyu999/ cp /tmp/file1 ~/ mv /tmp/file2 ~/ mv -Z /tmp/file3 ~/ ls -Z ~/file* # unconfined_u:object_r:user_home_t:s0 /home/signalyu999/file1 # unconfined_u:object_r:user_tmp_t:s0 /home/signalyu999/file2 # unconfined_u:object_r:user_home_t:s0 /home/signalyu999/file3 To change the SELinux context, three commands—semanage fcontext, restorecon, and chcon—are commonly used:\nsemanage fcontext: This command defines custom SELinux context rules for files or directories. It is often used to assign a specific context to files when they are created or moved to a particular location. restorecon: This command applies the SELinux context based on the rules defined by semanage fcontext. It restores the SELinux context of the file or directory to the predefined context. chcon: This command changes the SELinux context of a file or directory temporarily. Unlike semanage, which alters permanent rules, chcon applies the context change on a temporary basis and can be overwritten by restorecon. # Define a custom SELinux context for files in /home/signalyu999/test sudo semanage fcontext -a -t tmp_t \"/home/signalyu999/test(/.*)?\" mkdir ~/test # Before applying ls -Zd ~/test # unconfined_u:object_r:user_home_t:s0 /home/signalyu999/test cd test/ touch file1.txt ls -Z file1.txt # unconfined_u:object_r:user_home_t:s0 file1.txt # Apply the custom SELinux context rule using restorecon restorecon -v ~/test # After applying ls -Zd ~/test # unconfined_u:object_r:tmp_t:s0 /home/signalyu999/test ls -Zd file1.txt unconfined_u:object_r:user_home_t:s0 file1.txt touch file2.txt ls -Z file2.txt # unconfined_u:object_r:user_tmp_t:s0 file2.txt # Temporarily change the SELinux context using chcon sudo chcon -t user_home_t ~/test ls -Zd ~/test # unconfined_u:object_r:user_home_t:s0 /home/signalyu999/test touch file3.txt ls -Z file3.txt # unconfined_u:object_r:user_home_t:s0 file3.txt # Restore the original SELinux context with restorecon restorecon -v ~/test ls -Zd ~/test # unconfined_u:object_r:tmp_t:s0 /home/signalyu999/test ls -Z file* # unconfined_u:object_r:user_home_t:s0 file1.txt # unconfined_u:object_r:user_home_t:s0 file3.txt # unconfined_u:object_r:user_tmp_t:s0 file2.txt sudo semanage fcontext -l | grep \"/home/signalyu999\" /home/signalyu999/test(/.*)? all files system_u:object_r:tmp_t:s0 restorecon -Rv ~/test # Relabeled /home/signalyu999/test/file1.txt from unconfined_u:object_r:user_home_t:s0 to unconfined_u:object_r:tmp_t:s0 # Relabeled /home/signalyu999/test/file2.txt from unconfined_u:object_r:user_tmp_t:s0 to unconfined_u:object_r:tmp_t:s0 # Relabeled /home/signalyu999/test/file3.txt from unconfined_u:object_r:user_home_t:s0 to unconfined_u:object_r:tmp_t:s0 ls -Z file* # unconfined_u:object_r:tmp_t:s0 file1.txt # unconfined_u:object_r:tmp_t:s0 file3.txt # unconfined_u:object_r:tmp_t:s0 file2.txt rm -r ~/test # Delete the custom context rule sudo semanage fcontext -d \"/home/signalyu999/test(/.*)?\" Adjust SELinux with Booleans SHOW CONTENTS SELinux Booleans are runtime tunable parameters that control specific aspects of SELinux behavior. They allow administrators to enable or disable certain security features without altering the underlying SELinux policies. Some common SELinux booleans include:\nhttpd_can_network_connect: Enable it to allow Apache to access external resources over the network. httpd_enable_homedirs: Enable it to allow Apache to serve content from user home directories. allow_execmem: Enable it to allow executable memory mapping. selinuxuser_execheap: Enable it to allow SELinux users to execute files with low-security contexts. samba_enable_home_dirs: Enable it to allow Samba to share user home directories. To manage SELinux booleans, the following commands are commonly used: getsebool, setsebool, and semanage boolean. Below is an example of how to check and change SELinux boolean values:\n# List all SELinux booleans related to \"httpd_enable_\" getsebool -a | grep \"httpd_enable_\" # httpd_enable_cgi --\u003e on # httpd_enable_ftp_server --\u003e off # httpd_enable_homedirs --\u003e off # Check the current state of a specific boolean getsebool httpd_enable_homedirs # httpd_enable_homedirs --\u003e off # Use semanage to view the details of a specific boolean sudo semanage boolean -l | grep httpd_enable_homedirs # httpd_enable_homedirs (off, off) Allow httpd to enable homedirs # Change the value of a boolean (without the -P flag, the changes will only persist until the system is rebooted) sudo setsebool httpd_enable_homedirs on # Use semanage again to confirm the change sudo semanage boolean -l | grep httpd_enable_homedirs # httpd_enable_homedirs (on, off) Allow httpd to enable homedirs # Make the change persistent across reboots sudo setsebool -P httpd_enable_homedirs on # Check the persistent state of all SELinux booleans sudo semanage boolean -l -C # SELinux boolean State Default Description # httpd_enable_homedirs (on, on) Allow httpd to enable homedirs # ... sudo setsebool -P httpd_enable_homedirs off Investigate and Resolve SELinux Issues SHOW CONTENTS When SELinux denies an action, it logs an AVC (Access Vector Cache) message to the /var/log/audit/audit.log file. Additionally, a summary of the AVC event is sent to /var/log/messages. These logs provide valuable information to diagnose SELinux-related issues. Here are some common steps to troubleshoot SELinux issues:\nView SELinux Logs: The first step in troubleshooting SELinux issues is to check the SELinux logs for AVC denials. This can be done using the following command: sudo grep AVC /var/log/audit/audit.log | audit2why Check and Set SELinux Booleans: The second step is to permit SELinux behavior by setting SELinux Booleans. To list the current SELinux booleans and search for a specific one (e.g., related to HTTPD), use the following command: getsebool -a | grep httpd If a boolean needs to be modified, for example, enabling Apache to read user content, use the setsebool command with the -P option to make the change persistent:\nsudo setsebool -P httpd_read_user_content 1 Check File and Directory Contexts: The third step is to check the context of a file or directory as incorrect or missing contexts can result in access denials. This can be done using the following command: ls -Z /path/to/file If the context is incorrect, it can be fixed using the semanage fcontext command to define the correct context or restorecon to apply the default context based on the current policies:\nsudo restorecon -v /path/to/file Below is a simple example:\nsudo systemctl start httpd echo \"HELLO\" \u003e\u003e ~/index.html sudo mv ~/index.html /var/www/html/ curl http://localhost/index.html # \u003c!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\"\u003e # # 404 Not Found # # Not Found # The requested URL was not found on this server.\n# # Check the SELinux audit logs for AVC denials related to the \"httpd\" process sudo grep AVC /var/log/audit/audit.log | audit2why # type=AVC msg=audit(1746191992.345:5086): avc: denied { read } for pid=84172 comm=\"httpd\" name=\"index.html\" dev=\"dm-0\" ino=34324608 scontext=system_u:system_r:httpd_t:s0 tcontext=unconfined_u:object_r:user_home_t:s0 tclass=file permissive=0 # Was caused by: # The boolean httpd_read_user_content was set incorrectly. # Description: # Allow httpd to read user content # Allow access by executing: # # setsebool -P httpd_read_user_content 1 sudo setsebool -P httpd_read_user_content 1 curl http://localhost/index.html # HELLO 19. Manage Basic Storage Add Partitions, File Systems, and Persistent Mounts SHOW CONTENTS Disk partitioning is the process of dividing a computer’s storage device into separate, independent sections called partitions. Each partition acts like an individual disk, allowing it to be formatted with a specific file system and used for various purposes, such as system files, user data, or backups. There are two main disk partitioning schemes: MBR (Master Boot Record) and GPT (GUID Partition Table).\nMBR (Master Boot Record): MBR is an older partitioning scheme that is commonly used in BIOS-based systems. It stores partitioning information in the first sector of the disk, known as the master boot record. This sector contains both the bootloader (a small program that helps the system load the operating system) and the partition table, which holds the details about each partition. MBR supports a maximum of four primary partitions and is limited to disks up to 2 TB in size. GPT (GUID Partition Table): GPT is a newer partitioning scheme designed as part of the UEFI (Unified Extensible Firmware Interface) standard. GPT overcomes the limitations of MBR by using two partition tables: a primary GPT header located at the beginning of the disk and a backup GPT header stored at the end of the disk. This redundancy ensures protection in case the primary GPT header is damaged. GPT supports up to 128 partitions by default and can handle disks as large as 9.4 ZB. Below is an real-world example of disk partitioning:\n# 1. Shutdown the VMware machine and add the new disk device. # 2. Use parted to manage the partitions on /dev/sdb (the new disk). sudo parted /dev/sdb # 3. Create a new partition table (GPT or MSDOS). GPT is recommended for modern systems. (parted) mklabel gpt # Or use \"msdos\" for older systems. # 4. Create a new primary partition (parted) mkpart # partition name: app-data # file system type: ext4 # start: 0% # end: 50% # 5. Print the partition information to verify the partition layout. (parted) print # 6. Ensure the system create the associated device file in the /dev directory udevadm settle # 7. Format the partition sudo mkfs.ext4 /dev/sdb1 # 8. Create a mounting point and mount the newly created partition sudo mkdir /mnt/mydata sudo mount /dev/sdb1 /mnt/mydata # 9. Use blkid to get the UUID of the new partition. sudo blkid /dev/sdb1 # /dev/sdb1: UUID=\"98c3694b-5a44-4729-bc14-2987562754cd\" TYPE=\"ext4\" PARTLABEL=\"app-data\" PARTUUID=\"4c737002-504a-4206-adda-737270fc083e\" # 10. Edit the /etc/fstab sudo vim /etc/fstab # UUID=98c3694b-5a44-4729-bc14-2987562754cd /mnt/mydata ext4 defaults 0 2 # UUID: Universally Unique Identifier # defaults: include auto mount option # /mnt/mydata: mounting point # ext4: file system # 0: dump (back up option), 0 = no backup (default), 1 = enable backup # 0: fsck (file system checking), 0 = do not check, 1 = check first (usually for root), 2 = check after root (for other file systems) # 11. After editing /etc/fstab, mount all filesystems as specified in /etc/fstab. sudo mount -a # 12. Use the df command to check that the partition is correctly mounted. df -h # 13. Register new configuraation sudo systemctl daemon-reload Below is a real-world example of removing a partition:\n# 1. Ensure the partition is not mounted sudo umount /dev/sdb1 # 2. Check if it is mounted df -h # 3. Delete the partition in parted parted /dev/sdb (parted) print (parted) rm 1 # 4. Edit the /etc/fstab file Manage Swap Space SHOW CONTENTS Swap space is a portion of the disk that is used as virtual memory when the system’s physical RAM is full. It allows the operating system to move inactive pages from RAM to disk, free up memory for active processes.\nWhen creating swap partitions, administrators should size the swap space based on the memory workload on the system. Below is a practical guide line:\nRAM Size Swap (No Hibernation) Swap (With Hibernation) \u003c 2 GB Twice the RAM Three times the RAM 2–8 GB Same as RAM Twice the RAM 8–64 GB At least 4 GB 1.5 times the RAM \u003e 64 GB At least 4 GB Hibernation is not recommended Below is an real-world example of creating swap partition:\n# 1. Open parted to manage the new disk parted /dev/sdc # 2. Create a GPT partition table (parted) mklabel gpt # 3. Create a new partition (parted) mkpart # partition name: swap1 # file system type: linux-swap # start: 0% # end: 100% # 4. Ensure the system create the associated device file in the /dev directory udevadm settle # 5. Format the new partition as swap space mkswap /dev/sdc1 # 6. Activate the swap space immediately swapon /dev/sdc1 # 7. Get the UUID of the swap partition blkid /dev/sdc1 # /dev/sdc1: UUID=\"e2d9fbc3-65dc-4427-8051-c07dcc043866\" TYPE=\"swap\" PARTLABEL=\"swap1\" PARTUUID=\"4f0f1298-cf05-4440-856f-534d69aeeccc\" # 8. Edit fstab to enable swap at boot sudo vim /etc/fstab # UUID=e2d9fbc3-65dc-4427-8051-c07dcc043866 none swap defaults 0 0 # Add the following line for default swap: # UUID=e2d9fbc3-65dc-4427-8051-c07dcc043866 none swap defaults 0 0 # Or set a custom priority: # UUID=e2d9fbc3-65dc-4427-8051-c07dcc043866 none swap pri=10 0 0 # 9. Reload systemd config (optional if fstab changed) sudo systemctl daemon-reload # 10. Display swap space priorities swapon --show Below is a real-world example of removing a swap partition:\n# 1. Turn off swap sudo swapoff /dev/sdc1 # 2. Verify whether a swap is off swapon --summary # 3. Remove the partition in parted parted /dev/sdc1 (parted) print (parted) rm [number] # 4. Edit the /etc/fstab file 20. Manage Storage Stack Create and Extend Logical Volumes SHOW CONTENTS Logical Volume Manager (LVM) is a system for managing disk storage in Linux that adds a layer of abstraction between physical storage devices and file systems. It allows multiple physical volumes to be combined into a single volume group, enabling more flexible and efficient storage allocation. The key components of LVM include: Physical Devices (PD), Physical Volumes (PV), Volume Groups (VG), and Logical Volumes (LV).\n📦 Physical Devices: These are actual hardware devices or virtual disks (e.g., /dev/sda, /dev/sdb). 💽 Physical Volumes (PV): Physical devices that have been initialized for LVM using pvcreate. 🧱 Volume Groups (VG): Collections of one or more physical volumes, combined into a single logical storage pool. Created using vgcreate. 📂 Logical Volumes (LV): Flexible storage units carved out from volume groups, created using lvcreate. Creating a logical volume involves creating physical device partitions, physical volumes, and volume groups. Below is an example:\n# 1. Prepare physical devices parted /dev/sdb (parted) mklabel gpt (parted) mkpart primary 1MiB 50% (parted) set 1 lvm on parted /dev/sdc (parted) mklabel gpt (parted) mkpart primary 50% 100% (parted) set 1 lvm on udevadm settle # 2. Create Physical volumes pvcreate /dev/sdb1 /dev/sdc1 # Physical volume \"/dev/sdb1\" successfully created. # Physical volume \"/dev/sdc1\" successfully created. # 3. Create volume groups vgcreate vg01 /dev/sdb1 /dev/sdc1 # Volume group \"vg01\" successfully created # 4. Create a logical volume lvcreate -n lv01 -L 100G vg01 # Logical volume \"lv01\" created. # 5. Format the logical volume mkfs.ext4 /dev/vg01/lv01 # 6. Mount the logical volume to /mnt/app-data mount /dev/vg01/lv01 /mnt/app-data # 7. Verify whether if the logical volume is mounted df -h ",
  "wordCount" : "15201",
  "inLanguage": "en",
  "datePublished": "2025-04-15T11:03:32+08:00",
  "dateModified": "2025-04-15T11:03:32+08:00",
  "author":{
    "@type": "Person",
    "name": "Signal Yu"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/linux/1-red-hat-enterprise-linux/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Signal's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://signalyu.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://signalyu.github.io/" accesskey="h" title="Signal&#39;s Blog (Alt + H)">
                <img src="https://signalyu.github.io/apple-touch-icon.png" alt="" aria-label="logo"
                    height="40">Signal&#39;s Blog</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://signalyu.github.io/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://signalyu.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://signalyu.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://signalyu.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://signalyu.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Red Hat Enterprise Linux
    </h1>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#1-introduction-to-linux" aria-label="1. Introduction to Linux">1. Introduction to Linux</a></li>
                <li>
                    <a href="#2-manage-files-from-the-command-line" aria-label="2. Manage Files From the Command Line">2. Manage Files From the Command Line</a><ul>
                        
                <li>
                    <a href="#linux-file-system-hierarchy" aria-label="Linux File System Hierarchy">Linux File System Hierarchy</a></li>
                <li>
                    <a href="#common-directory-and-file-management-commands" aria-label="Common Directory and File Management Commands">Common Directory and File Management Commands</a></li>
                <li>
                    <a href="#create-links-between-files" aria-label="Create Links Between Files">Create Links Between Files</a></li></ul>
                </li>
                <li>
                    <a href="#3-get-help-using-man-command" aria-label="3 Get Help Using man Command">3 Get Help Using man Command</a></li>
                <li>
                    <a href="#4-io-redirection--pipelines" aria-label="4. I/O Redirection &amp; Pipelines">4. I/O Redirection &amp; Pipelines</a><ul>
                        
                <li>
                    <a href="#io-redirection" aria-label="I/O Redirection">I/O Redirection</a></li>
                <li>
                    <a href="#pipelines" aria-label="Pipelines">Pipelines</a></li></ul>
                </li>
                <li>
                    <a href="#5-bash-environment-configuration" aria-label="5. Bash Environment Configuration">5. Bash Environment Configuration</a></li>
                <li>
                    <a href="#6-manage-local-users-and-groups" aria-label="6. Manage Local Users and Groups">6. Manage Local Users and Groups</a><ul>
                        
                <li>
                    <a href="#user--group-concepts" aria-label="User &amp; Group Concepts">User &amp; Group Concepts</a></li>
                <li>
                    <a href="#gain-superuser-access" aria-label="Gain Superuser Access">Gain Superuser Access</a></li>
                <li>
                    <a href="#manage-local-user-accounts" aria-label="Manage Local User Accounts">Manage Local User Accounts</a></li>
                <li>
                    <a href="#manage-local-group-accounts" aria-label="Manage Local Group Accounts">Manage Local Group Accounts</a></li>
                <li>
                    <a href="#manage-user-passwords" aria-label="Manage User Passwords">Manage User Passwords</a></li></ul>
                </li>
                <li>
                    <a href="#7-control-access-to-files" aria-label="7. Control Access to Files">7. Control Access to Files</a><ul>
                        
                <li>
                    <a href="#file-system-permissions-concepts" aria-label="File System Permissions Concepts">File System Permissions Concepts</a></li>
                <li>
                    <a href="#manage-file-system-permissions" aria-label="Manage File System Permissions">Manage File System Permissions</a></li>
                <li>
                    <a href="#sepcial-permissions--default-permissions" aria-label="Sepcial Permissions &amp; Default Permissions">Sepcial Permissions &amp; Default Permissions</a></li></ul>
                </li>
                <li>
                    <a href="#8-monitor--manage-linux-processes" aria-label="8. Monitor &amp; Manage Linux Processes">8. Monitor &amp; Manage Linux Processes</a><ul>
                        
                <li>
                    <a href="#process-life-cycle--states" aria-label="Process Life Cycle &amp; States">Process Life Cycle &amp; States</a></li>
                <li>
                    <a href="#control-jobs" aria-label="Control Jobs">Control Jobs</a></li>
                <li>
                    <a href="#kill-processes" aria-label="Kill Processes">Kill Processes</a></li>
                <li>
                    <a href="#monitor-process-activity" aria-label="Monitor Process Activity">Monitor Process Activity</a></li></ul>
                </li>
                <li>
                    <a href="#9-control-services--daemons" aria-label="9. Control Services &amp; Daemons">9. Control Services &amp; Daemons</a></li>
                <li>
                    <a href="#10-configure--secure-ssh" aria-label="10. Configure &amp; Secure SSH">10. Configure &amp; Secure SSH</a></li>
                <li>
                    <a href="#11-analyze--store-logs" aria-label="11. Analyze &amp; Store Logs">11. Analyze &amp; Store Logs</a><ul>
                        
                <li>
                    <a href="#system-log-architecture" aria-label="System Log Architecture">System Log Architecture</a></li>
                <li>
                    <a href="#review-syslog-files" aria-label="Review Syslog Files">Review Syslog Files</a></li>
                <li>
                    <a href="#review-system-journal-entries" aria-label="Review System Journal Entries">Review System Journal Entries</a></li>
                <li>
                    <a href="#preserve-the-system-journal" aria-label="Preserve the System Journal">Preserve the System Journal</a></li>
                <li>
                    <a href="#maintain-accute-time" aria-label="Maintain Accute Time">Maintain Accute Time</a></li></ul>
                </li>
                <li>
                    <a href="#12-manage-networking" aria-label="12. Manage Networking">12. Manage Networking</a><ul>
                        
                <li>
                    <a href="#networking-related-commands" aria-label="Networking Related Commands">Networking Related Commands</a></li>
                <li>
                    <a href="#configure-network" aria-label="Configure Network">Configure Network</a></li></ul>
                </li>
                <li>
                    <a href="#13-archive--transfer-files" aria-label="13. Archive &amp; Transfer Files">13. Archive &amp; Transfer Files</a><ul>
                        
                <li>
                    <a href="#manage-compressed-tar-files" aria-label="Manage Compressed tar Files">Manage Compressed tar Files</a></li>
                <li>
                    <a href="#transfer-files-using-sftp" aria-label="Transfer Files Using sftp">Transfer Files Using sftp</a></li>
                <li>
                    <a href="#synchronize-file-using-rsync" aria-label="Synchronize File Using rsync">Synchronize File Using rsync</a></li></ul>
                </li>
                <li>
                    <a href="#14-install--update-software-packages" aria-label="14. Install &amp; Update Software Packages">14. Install &amp; Update Software Packages</a><ul>
                        
                <li>
                    <a href="#change-repository-mirror" aria-label="Change Repository Mirror">Change Repository Mirror</a></li>
                <li>
                    <a href="#install--update-software-packages-with-dnf" aria-label="Install &amp; Update Software Packages with dnf">Install &amp; Update Software Packages with dnf</a></li></ul>
                </li>
                <li>
                    <a href="#15-access-linux-file-system" aria-label="15. Access Linux File System">15. Access Linux File System</a><ul>
                        
                <li>
                    <a href="#disk-partition" aria-label="Disk Partition">Disk Partition</a></li>
                <li>
                    <a href="#locate-file-on-the-system" aria-label="Locate File on the System">Locate File on the System</a></li></ul>
                </li>
                <li>
                    <a href="#16-schedule-future-tasks" aria-label="16. Schedule Future Tasks">16. Schedule Future Tasks</a><ul>
                        
                <li>
                    <a href="#schedule-a-user-job" aria-label="Schedule a User Job">Schedule a User Job</a></li>
                <li>
                    <a href="#schedule-a-system-job" aria-label="Schedule a System Job">Schedule a System Job</a></li>
                <li>
                    <a href="#manage-temporary-files" aria-label="Manage Temporary Files">Manage Temporary Files</a></li></ul>
                </li>
                <li>
                    <a href="#17-tune-system-performance" aria-label="17. Tune System Performance">17. Tune System Performance</a><ul>
                        
                <li>
                    <a href="#adjust-tuning-profiles" aria-label="Adjust Tuning Profiles">Adjust Tuning Profiles</a></li>
                <li>
                    <a href="#influence-process-scheduling" aria-label="Influence Process Scheduling">Influence Process Scheduling</a></li></ul>
                </li>
                <li>
                    <a href="#18-manage-selinux-security" aria-label="18. Manage SELinux Security">18. Manage SELinux Security</a><ul>
                        
                <li>
                    <a href="#change-the-selinux-environment-mode" aria-label="Change the SELinux Environment Mode">Change the SELinux Environment Mode</a></li>
                <li>
                    <a href="#control-selinux-file-contexts" aria-label="Control SELinux File Contexts">Control SELinux File Contexts</a></li>
                <li>
                    <a href="#adjust-selinux-with-booleans" aria-label="Adjust SELinux with Booleans">Adjust SELinux with Booleans</a></li>
                <li>
                    <a href="#investigate-and-resolve-selinux-issues" aria-label="Investigate and Resolve SELinux Issues">Investigate and Resolve SELinux Issues</a></li></ul>
                </li>
                <li>
                    <a href="#19-manage-basic-storage" aria-label="19. Manage Basic Storage">19. Manage Basic Storage</a><ul>
                        
                <li>
                    <a href="#add-partitions-file-systems-and-persistent-mounts" aria-label="Add Partitions, File Systems, and Persistent Mounts">Add Partitions, File Systems, and Persistent Mounts</a></li>
                <li>
                    <a href="#manage-swap-space" aria-label="Manage Swap Space">Manage Swap Space</a></li></ul>
                </li>
                <li>
                    <a href="#20-manage-storage-stack" aria-label="20. Manage Storage Stack">20. Manage Storage Stack</a><ul>
                        
                <li>
                    <a href="#create-and-extend-logical-volumes" aria-label="Create and Extend Logical Volumes">Create and Extend Logical Volumes</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="1-introduction-to-linux">1. Introduction to Linux<a hidden class="anchor" aria-hidden="true" href="#1-introduction-to-linux">#</a></h1>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p><strong>Open Source</strong> refers to software whose source code is freely available to the public for anyone to view, modify, and distribute. It encourages coolaboration, transparency, and community-driven improvements.</p>
</blockquote>
<blockquote>
<p><strong>Open Source Licenses</strong> are legal agreements that define how software can be used, modified, and distributed. There are two main types of <strong>Copyleft</strong> and <strong>Permissive</strong>.</p>
</blockquote>
<ol>
<li><strong>Copyleft</strong> licenses require that any modified versions of the software also be open source, under the same terms as the original. Popular examples include the GPL (GNU General Public License) and AGPL (Affero GPL).</li>
<li><strong>Permissive</strong> licenses are more relaxed, allowing users to modify, distribute, and even close-source the software if desired. Well-known examples of permissive licenses include the MIT License, Apache License 2.0, and BSD License (Berkeley Software Distribution).</li>
</ol>
<blockquote>
<p>The differences between <strong>Fedora</strong>, <strong>CentOS Stream</strong>, and <strong>Red Hat Enterprise Linux (RHEL)</strong> are primarily based on their release cycles, stability, and target audiences. <strong>Fedora</strong> is a cutting-edge distribution that always features the latest software and technologies, making it ideal for developers and enthusiasts who want to experience the newest features. <strong>CentOS Stream</strong> serves as a rolling preview of future RHEL versions, acting as a middle ground between Fedora and RHEL. Finally, <strong>RHEL</strong> is the most stable and secure option, designed for enterprise environments that require long-term support and paid services. RHEL is commonly used in production systems that demand reliability and robust commercial support. <img loading="lazy" src="/img/linux/1-fedora-centos-stream-rhel.png" alt="Fedora, Centos Stream, and REHL"  />
</p>
</blockquote>

</details></p>

<hr>
<h1 id="2-manage-files-from-the-command-line">2. Manage Files From the Command Line<a hidden class="anchor" aria-hidden="true" href="#2-manage-files-from-the-command-line">#</a></h1>
<h2 id="linux-file-system-hierarchy">Linux File System Hierarchy<a hidden class="anchor" aria-hidden="true" href="#linux-file-system-hierarchy">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>The <strong>Linux File System Hierarchy</strong> defines the directory structure and directory contents in Linux-based operating systems. It stores all files which organized into a single incerted tree structure.</p>
</blockquote>
<p><img loading="lazy" src="/img/linux/2-rhel-file-system-hierarchy.png" alt="RHEL File System Hierarchy"  />
</p>
<blockquote>
<p>Here’s an overview of the key directories in the Linux file system hierarchy:</p>
</blockquote>
<table>
<thead>
<tr>
<th><strong>Location</strong></th>
<th><strong>Purpose</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>/boot</code></strong></td>
<td>Files to start the boot process.</td>
</tr>
<tr>
<td><strong><code>/dev</code></strong></td>
<td>Special device files that the system uses to access hardware.</td>
</tr>
<tr>
<td><strong><code>/etc</code></strong></td>
<td>System-specific configuration files.</td>
</tr>
<tr>
<td><strong><code>/home</code></strong></td>
<td>Home directory, where regular users store their data and configuration files.</td>
</tr>
<tr>
<td><strong><code>/root</code></strong></td>
<td>Home directory for the administrative superuser, root.</td>
</tr>
<tr>
<td><strong><code>/run</code></strong></td>
<td>Runtime data for processes that started since the last boot. This data includes process ID files and lock files. The contents of this directory are re-created on reboot. This directory consolidates the <code>/var/run</code> and <code>/var/lock</code> directories from earlier versions of Red Hat Enterprise Linux.</td>
</tr>
<tr>
<td><strong><code>/tmp</code></strong></td>
<td>A world-writable space for temporary files. Files that are not accessed, changed, or modified for 10 days are deleted from this directory automatically. The <code>/var/tmp</code> directory is also a temporary directory, in which files that are not accessed, changed, or modified in more than 30 days are deleted automatically.</td>
</tr>
<tr>
<td><strong><code>/usr</code></strong></td>
<td>Installed software, shared libraries, including files, and read-only program data. Significant subdirectories include: <code>/usr/bin</code>: User commands; <code>/usr/sbin</code>: System administration commands; <code>/usr/local</code>: Locally customized software</td>
</tr>
<tr>
<td><strong><code>/var</code></strong></td>
<td>System-specific variable data that should persist between boots. Files that dynamically change, such as databases, cache directories, log files, printer-spooled documents, and website content, might be found under <code>/var</code>.</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>static, dynamic(variable), persistent, runtime</strong>: Static content remains unchanged until explicitly edited or reconfigured; <strong>Dynamic (Variable)</strong> content might be modified or appended by active processes; <strong>Persistent</strong> content remains after a reboot, such as configuration settings; <strong>Runtime</strong> content from a process or from the system is deleted on reboot.</p>
</blockquote>

</details></p>

<hr>
<h2 id="common-directory-and-file-management-commands">Common Directory and File Management Commands<a hidden class="anchor" aria-hidden="true" href="#common-directory-and-file-management-commands">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <ul>
<li><code>pwd</code>: Prints the <strong>current working directory</strong> (path) to the terminal.</li>
<li><code>cd</code>: Changes the <strong>current working directory</strong> to the <strong>home</strong> directory of the current user.</li>
<li><code>cd -</code>: Changes the directory to the <strong>previous directory</strong>.</li>
<li><code>cd ../..</code>: Moves <strong>up two levels</strong> in the directory structure.</li>
<li><code>cd ..</code>: Moves <strong>up one level</strong> in the directory structure (to the parent directory).</li>
<li><code>ls -l</code>: Lists files and directories in the <strong>current directory</strong> in <strong>long format</strong>, showing details such as permissions, owner, group, size, and last modification time.</li>
<li><code>ls -al</code>: Lists <strong>all files</strong> (including hidden files) in the <strong>current directory</strong> in <strong>long format</strong>.</li>
<li><code>ls -lR</code>: Lists files and directories <strong>recursively</strong> in the <strong>current directory</strong> and all its subdirectories, in <strong>long format</strong>.</li>
<li><code>ls -l file*.txt</code>: Lists files that start with the word <code>file</code> and end with <code>.txt</code>.</li>
<li><code>cp hello.py HELLO.py</code>: Copies the file <code>hello.py</code> to <code>HELLO.py</code>. The original file remains unchanged.</li>
<li><code>mv -v hello.py HELLO.py</code>: Moves (or renames) the file <code>hello.py</code> to <code>HELLO.py</code>. The <code>-v</code> option prints verbose output showing the operation.</li>
<li><code>rm HELLO.py</code>: Removes (deletes) the file <code>HELLO.py</code>. <strong>Be careful, as this is a <em><strong>permanent deletion</strong></em>.</strong></li>
<li><code>mkdir HOME</code>: Creates a new directory named <code>HOME</code> in the current directory.</li>
<li><code>rmdir HOME</code>: Removes an <strong>empty directory</strong> named <code>HOME</code>. If the directory contains any files, it cannot be removed with <code>rmdir</code>.</li>
</ul>

</details></p>

<hr>
<h2 id="create-links-between-files">Create Links Between Files<a hidden class="anchor" aria-hidden="true" href="#create-links-between-files">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>In Linux, there are two types of links that can be created for files: <strong>hard links</strong> and <strong>soft links</strong>. A <strong>hard link</strong> is a direct reference to the data of a file. It creates another name for an existing file, pointing directly to the file&rsquo;s inode (the underlying data structure that holds the file&rsquo;s metadata and data.) A <strong>soft link</strong>, on the other hand, is a reference to the original file&rsquo;s path, rather than directly pointing to the file&rsquo;s inode.</p>
</blockquote>
<p><img loading="lazy" src="/img/linux/3-hard-link-vs-soft-link.png" alt="Hard Link vs. Soft Link"  />
</p>
<blockquote>
<p>Hard links that reference the same file share the same inode struct with the link count, access permissions, user and group ownership, time stamps, and file content. Therefore, when any of this information is changed for one hard link, the changes are reflected in all other hard links pointing to the same file.</p>
</blockquote>
<blockquote>
<p>Commands for creating links between files are as follows:</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ln file.txt file_link.txt <span style="color:#75715e"># Create a hard link</span>
</span></span><span style="display:flex;"><span>ls -i file.txt file_link.txt <span style="color:#75715e"># Show the inode number for both files</span>
</span></span><span style="display:flex;"><span>ln -s file.txt file_soft.txt <span style="color:#75715e"># Create a soft link</span>
</span></span><span style="display:flex;"><span>ls -l file_soft.txt <span style="color:#75715e"># Check if the soft link work (file_soft.txt -&gt; file.txt)</span>
</span></span></code></pre></div>
</details></p>

<hr>
<h1 id="3-get-help-using-man-command">3 Get Help Using <code>man</code> Command<a hidden class="anchor" aria-hidden="true" href="#3-get-help-using-man-command">#</a></h1>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>The <code>man</code> command in Linux is used to display the <strong>manual pages</strong> for various commands, programs, system calls, etc. The <strong>man pages</strong> are divided into 9 sections: <strong>executable programs or shell commands</strong>, <strong>system calls</strong>, <strong>library calls</strong>, <strong>special files</strong>, <strong>file formats and conventions</strong>, <strong>games</strong>, <strong>miscellaneous</strong>, <strong>system administration commands</strong>, and <strong>kernel routines (non standard)</strong>.</p>
</blockquote>
<ol>
<li><code>Executable programs or shell commands</code>: Commands executed by regular users (e.g., <code>ls</code>, <code>cp</code>).</li>
<li><code>System calls</code>: Functions that the kernel provides for programs to interact with the system (e.g., <code>open</code>, <code>read</code>).</li>
<li><code>Library calls</code>: Functions that can be used in programs written in C and other languages (e.g., <code>printf</code>).</li>
<li><code>Special files</code>: Usually found in <code>/dev</code>(e.g., <code>/dev/sda</code>).</li>
<li><code>File formats and conventions</code>: Descriptions of file formats (e.g., <code>/etc/passwd</code>).</li>
<li><code>Games</code>: Information about games available on the system.</li>
<li><code>Miscellaneous</code>: including macro packages and conventions (e.g. <code>man(7)</code>, <code>groff(7)</code>).</li>
<li><code>System administration commands</code>: Commands for system administrators (e.g., <code>useradd</code>, <code>systemctl</code>).</li>
<li><code>Kernel routines</code>: Non standard</li>
</ol>
<blockquote>
<p>The most common way to use <code>man</code> command including:</p>
</blockquote>
<ul>
<li><code>man open</code> or <code>man open.3</code>: Displays the manual page for the <code>open</code> command. (<code>open</code> exists in <strong>Section 2 (System Calls)</strong> and <strong>Section 3 (Library Functions)</strong>, <code>man open</code> display the System Call documentation while <code>man open.3</code> display the Library Function manual.)</li>
<li><code>man -f ls</code>: Displays a brief description of the <code>ls</code> command, equivalent to <code>whatis ls</code>.</li>
<li><code>man -k ls</code>: Searches the manual page database for the term <code>ls</code>, equivalent to <code>apropos ls</code>.</li>
</ul>
<blockquote>
<p>Note that before running <code>man -f ls</code> or <code>man -k ls</code>, it is important to ensure that the <code>mandb</code> database has been built. This can be done by running <code>sudo mandb</code>.</p>
</blockquote>

</details></p>

<hr>
<h1 id="4-io-redirection--pipelines">4. I/O Redirection &amp; Pipelines<a hidden class="anchor" aria-hidden="true" href="#4-io-redirection--pipelines">#</a></h1>
<h2 id="io-redirection">I/O Redirection<a hidden class="anchor" aria-hidden="true" href="#io-redirection">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>A process reads input and writes output. By default, it reads input from the <strong>keyboard</strong> and sends its output to the <strong>terminal window</strong>. Processes use numbered channels called <strong>file descriptors</strong> to manage input and output. Every process starts with at least three file descriptors:</p>
</blockquote>
<ul>
<li><strong>Standard Input (channel 0)</strong>: Reads input from the keyboard.</li>
<li><strong>Standard Output (channel 1)</strong>: Sends normal output to the terminal.</li>
<li><strong>Standard Error (channel 2)</strong>: Sends error messages to the terminal.</li>
</ul>
<p><img loading="lazy" src="/img/linux/4-process-io-channels.png" alt="Process I/O channels (file descriptors)"  />
</p>
<table>
<thead>
<tr>
<th>Number</th>
<th>Channel Name</th>
<th>Description</th>
<th>Default Connection</th>
<th>Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>stdin</td>
<td>Standard input</td>
<td>Keyboard</td>
<td>Read only</td>
</tr>
<tr>
<td>1</td>
<td>stdout</td>
<td>Standard output</td>
<td>Terminal</td>
<td>Write only</td>
</tr>
<tr>
<td>2</td>
<td>stderr</td>
<td>Standard error</td>
<td>Terminal</td>
<td>Write only</td>
</tr>
<tr>
<td>3+</td>
<td>filename</td>
<td>Other files</td>
<td>None</td>
<td>Read/write or both</td>
</tr>
</tbody>
</table>
<blockquote>
<p>By default, a process takes input from the keyboard and displays its output on the terminal. <strong>Redirection</strong> refers to changing the default input or output of a command. The following table summarizes the different types of redirection available:</p>
</blockquote>
<table>
<thead>
<tr>
<th>Usage</th>
<th>Explanation</th>
<th>Vitulization</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&gt; file</code></td>
<td>Redirect <strong>stdout</strong> to overwrite a file</td>
<td><img loading="lazy" src="/img/linux/5-output-override.png" alt="override output"  />
</td>
</tr>
<tr>
<td><code>&gt;&gt; file</code></td>
<td>Redirect <strong>stdout</strong> ot append to a file</td>
<td><img loading="lazy" src="/img/linux/6-output-append.png" alt="append outout"  />
</td>
</tr>
<tr>
<td><code>2&gt; file</code></td>
<td>Redirect <strong>stderr</strong> to overwrite a file</td>
<td><img loading="lazy" src="/img/linux/7-error-override.png" alt="override error"  />
</td>
</tr>
<tr>
<td><code>2&gt; /dev/null</code></td>
<td>Discard <strong>stderr</strong> error messages by redirecting them to <code>/dev/null</code></td>
<td><img loading="lazy" src="/img/linux/8-error-discard.png" alt="discard error"  />
</td>
</tr>
<tr>
<td><code>&gt; file 2&gt;&amp;1</code> or <code>&amp;&gt; file</code></td>
<td>Redirect <strong>stdout</strong> and <strong>stderr</strong> to overwrite the same file</td>
<td><img loading="lazy" src="/img/linux/9-output-and-error-override.png" alt="override output and error"  />
</td>
</tr>
<tr>
<td><code>&gt;&gt; file 2&gt;&amp;1</code> or <code>&amp;&gt;&gt; file</code></td>
<td>Redirect <strong>stdout</strong> and <strong>stderr</strong> to append the same file</td>
<td><img loading="lazy" src="/img/linux/10-output-and-error-append.png" alt="append output and error"  />
</td>
</tr>
<tr>
<td><code>sort &lt; file &gt; sorted_file</code></td>
<td>Redirects the <strong>stdin</strong> to a file and redirect <strong>stdout</strong> to overwrite a different file</td>
<td><img loading="lazy" src="/img/linux/11-input-redirection.png" alt="input redirection"  />
</td>
</tr>
</tbody>
</table>
<blockquote>
<p>It is important to note that <strong>the order of redirection operations is crucial</strong>. For example:</p>
</blockquote>
<ul>
<li>The command <code>&gt; output.log 2&gt;&amp;1</code> redirects both standard output and standard error messages to the same file, <code>output.log</code>.</li>
<li>On the other hand, <code>2&gt;&amp;1 &gt; output.log</code> redirects standard error messages to the default standard output (the terminal), and then redirects only the standard output to <code>output.log</code>.</li>
</ul>
<blockquote>
<p>Additionally, the command <code>&gt; output.log 2&gt;&amp;1</code> can be shortened to <code>&amp;&gt; output.log</code>. However, it is important to note that <code>&amp;&gt;</code> is not standardized and may not be implemented in all shells.</p>
</blockquote>

</details></p>

<hr>
<h2 id="pipelines">Pipelines<a hidden class="anchor" aria-hidden="true" href="#pipelines">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>A <strong>pipeline</strong> is a sequence of one or more commands that are connected by the vertical bar character (<code>|</code>). In a pipeline, the standard output of one command is passed directly as the standard input to the next command.</p>
</blockquote>
<p><img loading="lazy" src="/img/linux/12-process-io-piping.png" alt="Process I/O Piping"  />
</p>
<blockquote>
<p>The main difference between <strong>pipelines</strong> and <strong>I/O redirection</strong> lies in how they handle data. <strong>I/O redirection</strong> refers to sending standard output to a file or receiving standard input from a file. In contrast, <strong>pipelines</strong> are used to send the standard output of one process directly to the standard input of another process.</p>
</blockquote>
<blockquote>
<p>The following are some commonly used pipeline examples:</p>
</blockquote>
<ul>
<li><code>cat file.txt | grep &quot;pattern&quot;</code>: Searches for patterns within text.</li>
<li><code>cat file.txt | sort</code>: Sorts the lines of text in a specified order (alphabetically by default).</li>
<li><code>cat file.txt | wc -l</code>: Counts the number of lines in a file.</li>
<li><code>cat file.txt | tee output.txt</code>: Outputs the content of a file to both the terminal and a specified file. <img loading="lazy" src="/img/linux/13-process-io-piping-with-tee.png" alt="Process I/O Piping With tee"  />
</li>
<li><code>find / -name &quot;passwd&quot; 2&gt;&amp;1 | less</code>:
<ul>
<li><code>find / -name &quot;passwd&quot;</code>: Searches for a file or directory named <code>passwd</code> starting from the root directory (<code>/</code>).</li>
<li><code>2&gt;&amp;1</code>: Redirects standard error (file descriptor 2) to standard output (file descriptor 1). This ensures that any error messages, such as permission denials, are also passed along with the normal output.</li>
<li><code>| less</code>: Pipes the combined output (standard output and error messages) into the <code>less</code> command.</li>
</ul>
</li>
</ul>

</details></p>

<hr>
<h1 id="5-bash-environment-configuration">5. Bash Environment Configuration<a hidden class="anchor" aria-hidden="true" href="#5-bash-environment-configuration">#</a></h1>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>When Bash starts, several initialization scripts are executed to configure the shell environment, with the specific scripts depending on whether the shell is <em>interactive</em>, <em>non-interactive</em>, <em>login</em>, or <em>non-login</em>. An interactive shell allows users to enter commands directly, while a non-interactive shell runs in the background. A login shell is invoked when a user logs in via terminal or SSH, while non-login shell is opened from an existing session, like when launching a terminal in a GUI.</p>
</blockquote>
<blockquote>
<p>For <strong>interactive login shells</strong>, the environment is configured by the <code>/etc/profile</code> and <code>~/.bash_profile</code> files, which also source <code>/etc/bashrc</code> and <code>~/.bashrc</code> respectively. For <strong>interactive non-login shells</strong>, only <code>/etc/bashrc</code> and <code>~/.bashrc</code> are used. System-wide configurations are stored in <code>/etc/profile</code> and <code>/etc/bashrc</code>, while user-specific configurations are in <code>~/.bash_profile</code> and <code>~/.bashrc</code>.</p>
</blockquote>

</details></p>

<hr>
<h1 id="6-manage-local-users-and-groups">6. Manage Local Users and Groups<a hidden class="anchor" aria-hidden="true" href="#6-manage-local-users-and-groups">#</a></h1>
<h2 id="user--group-concepts">User &amp; Group Concepts<a hidden class="anchor" aria-hidden="true" href="#user--group-concepts">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>A <strong>user</strong> is an individual account created on a Linux system that can own files, execute commands, and interact with the system. User details are typically stored in the <code>/etc/passwd</code> file, where each line represents a user account with specific information like username, UID, home directory, and default shell.</p>
</blockquote>
<p><img loading="lazy" src="/img/linux/14-user-details-etc-passwd.png" alt="User Details"  />
</p>
<blockquote>
<p>In Linux, there are three primary types of users:</p>
</blockquote>
<ul>
<li><strong>Superuser</strong>: The superuser account is responsible for administering the system.  Its name is <code>root</code> with a UID of <code>0</code>. It has full system access.</li>
<li><strong>System User</strong>: These accounts are used by processes or daemons that provide system services (e.g., web servers, databases). System users are non-privileged and are created to isolate and secure the services they support.</li>
<li><strong>Regular User</strong>: The <strong>regular user</strong> is the typical user who do not have root priviledges and have limited access to the system.</li>
</ul>
<blockquote>
<p>A <strong>group</strong> is a collection of users that can be assigned a common set of permissions. The group details are typically stored in <code>etc/group</code>, which contains information about group names, GIDs, and the list of users that belong to each group.</p>
</blockquote>
<p><img loading="lazy" src="/img/linux/15-group-details-etc-group.png" alt="Group Details"  />
</p>
<blockquote>
<p>In Linux, there two main types of group: the <strong>primary group</strong> and the <strong>secondary group</strong>.</p>
</blockquote>
<ul>
<li><strong>Primary Group</strong>: The primary group is the default group assigned to a user. It is used as the group ownership for files and directories the user creates. By default, a user’s primary group often shares the same name as the username.</li>
<li><strong>Secondary Groups</strong>: These are additional groups to which a user can belong. Secondary groups provide users with access to shared resources or enable them to perform tasks that require specific group-level permissions.</li>
</ul>

</details></p>

<hr>
<h2 id="gain-superuser-access">Gain Superuser Access<a hidden class="anchor" aria-hidden="true" href="#gain-superuser-access">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>In <strong>RHEL 9</strong>, to switch from a regular user to a superuser (root), the <code>su</code> command is used. To switch back from the root account to a regular user, the command <code>su - user_name</code> can be used, or alternatively, typing <code>exit</code> will return to the previous user account.</p>
</blockquote>
<blockquote>
<p>If a regular user is not in the <strong>sudoers</strong> file, an error message such as <em>&quot;<code>user_name</code> is not in the sudoers file. This incident will be reported.&quot;</em> will appear when trying to run a command with <code>sudo</code>. To enable full <code>sudo</code> access for a specific user, switch to the root account and then add the line <code>user_name ALL=(ALL) ALL</code> to the <code>/etc/sudoers</code> file. Similarly, to provide users in a specific group full <code>sudo</code> access, the line <code>%group_name ALL=(ALL) ALL</code> should be added.</p>
</blockquote>
<blockquote>
<p>It’s important to use the <code>visudo</code> command to edit the <code>/etc/sudoers</code> file, as it performs syntax checks to avoid errors that could lock out users from using <code>sudo</code>.</p>
</blockquote>

</details></p>

<hr>
<h2 id="manage-local-user-accounts">Manage Local User Accounts<a hidden class="anchor" aria-hidden="true" href="#manage-local-user-accounts">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>To create a user, use the <code>useradd</code> command. When executing <code>useradd user_name</code>, it creates the user&rsquo;s home directory, sets up the account information, and generates a private group for the user named <code>user_name</code>. The default configuration for creating a new user is defined in the <code>/etc/login.defs</code> file. Note that at this point, the user account does not have a valid password set, so the user cannot log in until a password is assigned. To set a password for the user, the <code>passwd</code> command should be used.
To delete a user, the <code>userdel</code> command is used. The <code>userdel user_name</code> command removes the <code>user_name</code> from the <code>/etc/passwd</code> file but leaves the user&rsquo;s home directory intact. If it is necessary to delete the home directory as well, the <code>userdel -r user_name</code> option should be used. It’s important to note that when deleting a user without the <code>-r</code> option, the files owned by the user will be left with an unassigned UID. If a new account is later assigned to the same UID, that account will inherit the old user&rsquo;s files, which poses a security risk. For this reason, many organizations prefer to lock user accounts instead of deleting them, in accordance with security policies.</p>
</blockquote>
</details></p>

<hr>
<h2 id="manage-local-group-accounts">Manage Local Group Accounts<a hidden class="anchor" aria-hidden="true" href="#manage-local-group-accounts">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>The commands for managing local group accounts include <code>groupadd</code>, <code>groupmod</code>, and <code>groupdel</code>.</p>
</blockquote>
<ul>
<li><strong>groupadd</strong>: This command is used to create a new group. By default, it assigns the next available GID from the range specified by the <code>GID_MIN</code> and <code>GID_MAX</code> variables in the <code>/etc/login.defs</code> file.</li>
<li><strong>groupmod</strong>: This command is used to modify an existing group, such as changing its group name or GID.</li>
<li><strong>groupdel</strong>: This command is used to delete an existing group. However, it&rsquo;s important to note that the primary group of an existing user cannot be removed.</li>
</ul>
<blockquote>
<p>Here are some commonly used commands for managing local group accounts:</p>
</blockquote>
<ul>
<li><strong><code>groupadd -g group_id group_name</code></strong>: Creates a new group with a specified GID.</li>
<li><strong><code>groupmod -n old_group_name new_group_name</code></strong>: Renames an existing group from <code>old_group_name</code> to <code>new_group_name</code>.</li>
<li><strong><code>groupmod -g group_id group_name</code></strong>: Changes the GID of an existing group (<code>group_name</code>) to a specified group id.</li>
<li><strong><code>usermod -aG group_name user_name</code></strong>: Adds a user (<code>user_name</code>) to an additional group (<code>group_name</code>) without removing the user from their existing groups. <strong>The <code>-aG</code> option ensures the user is appended to the group list rather than replacing the existing group memberships.</strong></li>
<li><strong><code>newgrp group_name</code></strong>: Changes the current group to the named group.</li>
<li><strong><code>groupdel group_name</code></strong>: Deletes the specified group (<code>group_name</code>). Note that the primary group of any existing users cannot be deleted.</li>
</ul>

</details></p>

<hr>
<h2 id="manage-user-passwords">Manage User Passwords<a hidden class="anchor" aria-hidden="true" href="#manage-user-passwords">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>In Linux, <code>/etc/passwd</code> and <code>/etc/shadow</code> are critical system files that store user account information and password data, repectively. The <code>/etc/passwd</code> file contains basic information about user accounts on the system, while the <code>/etc/shadow</code> file is used to store encrypted user password information, as well as other related data such as password expiration and account locking details.</p>
</blockquote>
<blockquote>
<p>Here is the breakdown of the line from <code>/etc/shadow</code>:</p>
</blockquote>
<p><img loading="lazy" src="/img/linux/16-password-info-diagram-in-etc-shadow.png" alt="Password Info Diagram in /etc/shadow"  />
</p>
<blockquote>
<p>The <code>chage</code> command is used to configure <strong>password aging</strong> parameters for user accounts, allowing administrators to manage password expiration, warning periods, and other related settings (as shown in the following image).</p>
</blockquote>
<p><img loading="lazy" src="/img/linux/17-password-aging-parameters.png" alt="Password Aging Parameters"  />
</p>
<ul>
<li><strong>Min Days (Minimum Days Between Password Changes)</strong>: The <strong>minimum days</strong> (default is <code>0</code>) parameter specifies the minimum number of days that must pass before a user can change their password after setting it for the first time or after a password change. For example, if <code>min days</code> is set to 7, then after changing their password, the user will not be able to change it again until 7 days have passed.</li>
<li><strong>Max Days (Maximum Days Between Password Changes)</strong>: The <strong>maximum days</strong> (default is <code>99999</code>) parameter defines the maximum number of days that a user is allowed to use the current password. After this period, the user will be required to change the password. For example,  If <strong>max days</strong> is set to 30, the user must change their password every 30 days. After 30 days, they will be prompted to change it.</li>
<li><strong>Warn Days (Warning Period Before Password Expiration)</strong>: The <strong>warn days</strong> (default is <code>7</code>) parameter specifies how many days before the password expires the user will be warned to change their password. The warning is displayed when the user logs in. For example, If <code>warn days</code> is set to 7, the user will receive a warning 7 days before the password expiration.</li>
<li><strong>Expiration Date/Inactivity Days</strong>: The <strong>expiration date</strong> (default is <code>None</code>) specifies the date when the user’s account will be locked. If the <strong>inactivity days</strong> is set to <code>0</code>, the account will be locked immediately after the expiration date. The <strong>inactivity days</strong> parameter (default is <code>7</code>) defines the grace period after a password expires during which the user can still log in. During this period, the user is required to change the expired password using the <code>passwd</code> command before the account is locked. If the password is not changed within this grace period, the account will be locked. For example, if the <code>expiration date</code> is set to <code>2024-12-01</code> and the <code>inactivity days</code> is set to <code>7</code>, the user can continue logging in until <code>2024-12-08</code>. After <code>2024-12-08</code>, the user’s account will be locked, and contact with an administrator will be necessary to reactivate the account.</li>
</ul>
<blockquote>
<p>Below are some commonly used <code>chage</code> commands:</p>
</blockquote>
<ul>
<li><code>chage -E $(date -d &quot;+30 days&quot; +%F) user_name</code>: This command sets the <strong>expiration date</strong> of a user&rsquo;s account to 30 days from the current date.</li>
<li><code>chage -d 0 user_name</code>: This command forces the <strong>user to change their password</strong> immediately.</li>
</ul>
<blockquote>
<p>There are common scenarios where user access needs to be restricted, such as temporarily blocking a user or disabling access for a former employee. Below are some common methods for restricting user access.</p>
</blockquote>
<p>Here are the descriptions for the mentioned commands:</p>
<ul>
<li><strong><code>usermod -L user_name</code></strong>: This command locks the user account by disabling the password. It works by placing an exclamation mark (<code>!</code>) in front of the password hash in the <code>/etc/shadow</code> file, preventing the user from logging in.</li>
<li><strong><code>usermod -L -e 2024-12-31 user_name</code></strong>: This command locks the user account and also sets an expiration date for the account.</li>
<li><strong><code>usermod -s /sbin/nologin user_name</code></strong>: This command changes the login shell for the user to <code>/sbin/nologin</code>, which prevents the user from logging in interactively. <strong>It&rsquo;s important to note that this command does not prevent all types of access. Users may still be able to authenticate and upload or retrieve files through applications like file transfer programs or mail clients, as long as the user knows the password.</strong></li>
</ul>

</details></p>

<hr>
<h1 id="7-control-access-to-files">7. Control Access to Files<a hidden class="anchor" aria-hidden="true" href="#7-control-access-to-files">#</a></h1>
<h2 id="file-system-permissions-concepts">File System Permissions Concepts<a hidden class="anchor" aria-hidden="true" href="#file-system-permissions-concepts">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>In Linux, <strong>file system permissions</strong> control the access and actions that users can perform on files and directories. These permissions help manage security and determine who can read (<code>r</code>), write (<code>w</code>), or execute (<code>x</code>) a file. Permissions are typically displayed in a 10-character string, such as <code>-rwxr-xr--</code>. The 10 characters consist of a file type and three sets of permissions (<strong>User</strong>, <strong>Group</strong>, and <strong>Others</strong>):</p>
</blockquote>
<p><img loading="lazy" src="/img/linux/18-file-system-permissions.png" alt="File System Permissions"  />
</p>
<blockquote>
<p>The first character in the file permission string represents the <strong>file type</strong>. Common file types include <code>-</code> for regular files, <code>d</code> for directories, <code>l</code> for symbolic links, <code>c</code> for character device files, <code>b</code> for block device files, <code>p</code> for named pipe files, and <code>s</code> for local socket files.</p>
</blockquote>
<blockquote>
<p>The <strong>first set</strong> represents the <code>user</code> (owner) permissions. The <strong>second set</strong> represents the <code>group</code> permissions. The <strong>third set</strong> represents the <code>others</code> (everyone else) permissions. Each set of permissions is made up of three characters, corresponding to <strong>read</strong> (<code>r</code>), <strong>write</strong> (<code>w</code>), and <strong>execute</strong> (<code>x</code>). For example, <code>rwx</code> indicates full permissions (read, write, execute) and <code>r--</code> stands for read-only permissions.</p>
</blockquote>

</details></p>

<hr>
<h2 id="manage-file-system-permissions">Manage File System Permissions<a hidden class="anchor" aria-hidden="true" href="#manage-file-system-permissions">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>The <code>chmod</code> command is used to modify file system permissions for files and directories. The standard syntax is <code>chmod [options] mode file_or_directory_name</code>. The <strong>mode</strong> can be specified in either symbolic mode (e.g., <code>r</code>, <code>w</code>, <code>x</code>) or numeric mode (e.g., <code>755</code>, <code>644</code>). In numeric mode, permissions are represented by a three-digit number, where each digit corresponds to a set of permissions for the <strong>user</strong>, <strong>group</strong>, and <strong>others</strong>. Each permission is assigned a value: <code>4</code> for read, <code>2</code> for write, and <code>1</code> for execute. The sum of these values determines the permissions for each set. Below are some commonly used commands for changing file system permissions:</p>
</blockquote>
<ul>
<li><code>chmod 755 file</code>: Grants read, write, and execute permissions to the user, and read and execute permissions to the group and others.</li>
<li><code>chmod 644 file</code>: Grants read and write permissions to the user, and read-only permissions to the group and others.</li>
<li><code>chmod +x file</code>: Adds execute permission for all user categories (user, group, and others).</li>
<li><code>chmod -x file</code>: Removes execute permission for all user categories.</li>
<li><code>chmod u+x file</code>: Adds execute permission for the user (owner) only.</li>
<li><code>chmod g-w file</code>: Removes write permission from the group.</li>
<li><code>chmod o+r file</code>: Grants read permission to others.</li>
</ul>
<blockquote>
<p>To change the user or group ownership of a file or directory in Linux, the <code>chown</code> command is used. Only the root user can change the ownership of a file. However, both the file&rsquo;s owner and the root user can modify the file&rsquo;s group ownership. While the root user can assign file ownership to any group, regular users can change the group ownership of a file only if they are members of the target group.  Below are some commonly used commands for changing the user or group ownership of a file or directory.</p>
</blockquote>
<ul>
<li><code>chown user_name file_name</code>: Changes the owner of a file or directory to the specified <code>user_name</code>.</li>
<li><code>chown user_name:group_name file_name</code>: Changes both the owner and the group of a file or directory.</li>
<li><code>chown :group_name file_name</code>: Changes only the group ownership of the file or directory.</li>
<li><code>chown -R user_name directory_name</code>: Recursively changes the ownership of files and directories within the specified directory.</li>
<li><code>chgrp group_name file_name</code>: Changes only the group ownership of a file or directory to the specified <code>group_name</code>.</li>
<li><code>chgrp -R group_name directory_name</code>: Recursively changes the group ownership of files and directories within the specified directory.</li>
</ul>

</details></p>

<hr>
<h2 id="sepcial-permissions--default-permissions">Sepcial Permissions &amp; Default Permissions<a hidden class="anchor" aria-hidden="true" href="#sepcial-permissions--default-permissions">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>In Linux, special file permissions provide advanced control over file and directory access. These permissions include <strong>setuid</strong>, <strong>setgid</strong>, and the <strong>sticky bit</strong>.</p>
</blockquote>
<ul>
<li><strong>setuid</strong>: This permission is represented with <code>s</code> in the user permission set. When set on an executable file, it allows the program to be executed with the privileges of the file owner (usually <strong>root</strong>) rather than the privileges of the user running the file. For example, the file <code>/usr/bin/passwd</code> is owned by the root user, but it can be executed by a regular user without <code>sudo</code> because it has the <code>setuid</code> permission in the user permission set (<code>-rwsr-xr-x. 1 root root 32648 Aug 10  2021 /usr/bin/passwd</code>).</li>
<li><strong>setgid (Group ID)</strong>: This permission is represented with <code>s</code> in the group permission set. When applied to a file, it causes the program to run with the group privileges of the file&rsquo;s group. For directories, it ensures that files created within the directory will inherit the directory&rsquo;s group rather than the user&rsquo;s group. For example, the file <code>/usr/bin/locate (-rwx--s--x. 1 root slocate 41032 Aug 10  2021 /usr/bin/locate)</code> has the <code>setgid</code> permission in the group permission set, allowing it to run with the group privileges of the file&rsquo;s group. Similarly, the directory <code>/run/log/journal (drwxr-sr-x+ 3 root systemd-journal 60 Apr 15 09:44 /run/log/journal/)</code> has the <code>setgid</code> permission in the group permission set. This ensures that files created within the directory will inherit the <code>systemd-journal</code> group.</li>
<li><strong>sticky bit</strong>: This permission is represented with <code>t</code> in the others&rsquo; permission set. When applied to a directory, it allows only the file owner to delete or modify their files, preventing other users from tampering with them. For example, the directory <code>/tmp (drwxrwxrwt. 20 root root 4096 Apr 17 08:32 /tmp)</code> has the sticky bit set in the others&rsquo; permission set. This ensures that a user can only modify or delete the files in the <code>/tmp</code> directory that they own.</li>
</ul>
<hr>
<blockquote>
<p>In Linux, when a file or directory is created, its default permission is determined by the combination of the initial permission and the <strong>umask</strong> (user file creation mask). By default, files are created with initial permissions of <code>0666</code> (<code>-rw-rw-rw-</code>), and directories with <code>0777</code> (<code>drwxrwxrwx</code>). The <strong>umask</strong> defines which permission bits should be removed from these initial values, Typically, the default umask is 0022. This value can be modified in <code>/etc/bashrc</code>. For example, if the umask is set to <code>0022</code>, a newly created file will have permissions <code>0644</code> (<code>-rw-r--r--</code>) because <code>0666 - 0022 = 0644</code>. Similarly, a newly created directory will have permissions <code>0755</code> (<code>drwxr-xr-x</code>) because <code>0777 - 0022 = 0755</code>.</p>
</blockquote>

</details></p>

<hr>
<h1 id="8-monitor--manage-linux-processes">8. Monitor &amp; Manage Linux Processes<a hidden class="anchor" aria-hidden="true" href="#8-monitor--manage-linux-processes">#</a></h1>
<h2 id="process-life-cycle--states">Process Life Cycle &amp; States<a hidden class="anchor" aria-hidden="true" href="#process-life-cycle--states">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <p>A <strong>process</strong> is a running instance of an executable program. Once created, a process includes several key components: an address space for allocated memory, security properties such as ownership and privileges, one or more execution threads for running code, and a process state that reflects its current status.</p>
<p>The <strong>environment</strong> of a process contains important contextual information, including local and global variables, the current scheduling context, and system resources like file descriptors and network ports that are assigned to the process.</p>
<p><img loading="lazy" src="/img/linux/19-process-life-cycle.png" alt="Process Life Cycle"  />
</p>
<p>A new process is typically created when an existing <strong>parent process</strong> duplicates its own address space through a mechanism called a <strong>process fork</strong>. The resulting child process is assigned a unique Process ID (PID) for identification and security purposes. The child process also records the Parent Process ID (PPID) as part of its environment. On systems like Red Hat, all processes ultimately descend from the first system process, <code>systemd</code>.</p>
<p>Through the <strong>fork</strong> operation, the child process inherits the parent’s security credentials, file descriptors, resource privileges, environment variables, and program code. Once forked, the child process can continue running the same code or replace it with its own program logic using an <code>exec</code> family function.</p>
<p>Typically, after creating a child process, the <strong>parent process</strong> enters a waiting state, pausing its own execution until the child finishes. When the child process exits, it releases its resources, but its process table entry remains temporarily as a <strong>zombie process</strong>. Once the parent receives a termination signal from the child, it performs cleanup by removing the zombie entry from the process table, freeing the last of the child’s resources, and then resumes its own execution.</p>
<hr>
<blockquote>
<p>In Linux, every process moves through a series of well-defined <strong>states</strong> during its lifecycle. The following image and table describe Linux process states in detail.</p>
</blockquote>
<p><img loading="lazy" src="/img/linux/20-linux-process-states.png" alt="Linux Process States"  />
</p>
<p>TASK_INTERRUPTIBLE:
TASK_UNINTERRUPTIBLE:
TASK_KILLABLE:
TASK_REPORT_IDLE:
Flags TASK_UNINTERRUPTIBLE and TASK_NOLOAD are set. Similar to TASK_KILLABLE, also a subset of state D. It accepts fatal signals.</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Flag</th>
<th>Kernel-defined state name and description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Running</strong></td>
<td>R</td>
<td><code>TASK_RUNNING</code>: The process is either executing on a CPU or waiting to run. The process can be executing user routines or kernel routines (system calls), or be queued and ready when in the Running (or Runnable) state.</td>
</tr>
<tr>
<td><strong>Sleeping</strong></td>
<td>S</td>
<td><code>TASK_INTERRUPTIBLE</code>: The process is waiting for some condition: a hardware request, system resource access, or signal. When an event or signal satisfies the condition, the process returns to Running.</td>
</tr>
<tr>
<td></td>
<td>D</td>
<td><code>TASK_UNINTERRUPTIBLE</code>: This process is also sleeping, but unlike S state, does not respond to signals. Used only when process interruption might cause an unpredictable device state.</td>
</tr>
<tr>
<td></td>
<td>K</td>
<td><code>TASK_KILLABLE</code>: Identical to the uninterruptible D state, but modified to allow a waiting task to respond to the signal that it should be killed (exit completely). Utilities frequently display Killable processes as D state.</td>
</tr>
<tr>
<td></td>
<td>I</td>
<td><code>TASK_REPORT_IDLE</code>: A subset of state D. The kernel does not count these processes when calculating load average. Used for kernel threads. Flags TASK_UNINTERRUPTIBLE and TASK_NOLOAD are set. Similar to TASK_KILLABLE, also a subset of state D. It accepts fatal signals.</td>
</tr>
<tr>
<td><strong>Stopped</strong></td>
<td>T</td>
<td><code>TASK_STOPPED</code>: The process is stopped (suspended), usually by being signaled by a user or another process. The process can be continued (resumed) by another signal to return to running.</td>
</tr>
<tr>
<td></td>
<td>T</td>
<td><code>TASK_TRACED</code>: A process that is being debugged is also temporarily stopped and shares the same T state flag.</td>
</tr>
<tr>
<td><strong>Zombie</strong></td>
<td>Z</td>
<td><code>EXIT_ZOMBIE</code>: A child process signals to its parent as it exits. All resources except for the process identity (PID) are released.</td>
</tr>
<tr>
<td></td>
<td>X</td>
<td><code>EXIT_DEAD</code>: When the parent cleans up (reaps) the remaining child process structure, the process is now released completely. This state cannot be observed in process-listing utilities.</td>
</tr>
</tbody>
</table>
<blockquote>
<p>In Linux, the <code>ps</code> and <code>top</code> commands are commonly used to inspect processes. The <code>ps</code> command displays information about active processes and is typically used to capture a snapshot of the processes running at a specific moment. In contrast, the <code>top</code> command provides a real-time, dynamic view of system processes, continuously updating to show CPU usage, memory usage, uptime, load average, and resource consumption for each process.</p>
</blockquote>

</details></p>

<hr>
<h2 id="control-jobs">Control Jobs<a hidden class="anchor" aria-hidden="true" href="#control-jobs">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>In Linux, a <strong>job</strong> refers to a command or a group of commands initiated from a terminal by a user. Jobs can run in two modes: as a <strong>foreground job</strong> or a <strong>background job</strong>. A foreground job occupies the terminal until it completes, while a background job runs independently, allowing the terminal to remain available for other tasks. For example, executing <code>vim file.txt</code> starts a foreground job, which holds the terminal until the editor is closed. Running <code>sleep 300 &amp;</code> starts a background job, allowing the terminal to remain usable while the command runs for 300 seconds in th e background.</p>
</blockquote>
<blockquote>
<p>A <strong>process</strong> is a running instance of a program. When a job is initiated, one or more processes are created to perform the assigned tasks. For example, typing <code>ls -l</code> creates a new process to handle the application.</p>
</blockquote>
<blockquote>
<p>A <strong>pipeline</strong> is a sequence of commands connected by the <code>|</code> operator, where the output of one command is passed directly as input to the next. For example, the command <code>ps aux | grep nginx | sort</code> forms a pipeline involving three separate processes working in succession. In this case, a pipeline runs as one job, but each part is a separate process.</p>
</blockquote>
<blockquote>
<p>A <strong>session</strong> is a collection of processes initiated from a single user login. The first process created in a session is known as the <strong>session leader</strong>. For example, when a user logs in to a server via <code>ssh user_name@ip_address</code>, the shell process (<code>bash</code>, <code>zsh</code>, etc.) acts as the session leader. All jobs and processes started from that terminal belong to the same session.</p>
</blockquote>
<blockquote>
<p>In Linux, <strong>job control</strong> allows management of multiple jobs (commands or processes) within a single terminal session. Job control makes it possible to pause, resume, move jobs between the foreground and background, or terminate them. Below are the common-use commands for job control:</p>
</blockquote>
<ul>
<li><code>Ctrl + Z</code>: Suspends the current foreground job and puts it into the background in a <strong>stopped</strong> state.</li>
<li><code>bg</code>: Resumes a suspended job in the background.</li>
<li><code>fg</code>: Brings a background job back to the foreground.</li>
<li><code>jobs</code>: Lists all jobs associated with the current terminal session, showing each job’s ID and status (e.g., running, stopped). In the output, a <code>+</code> next to a job ID denotes the <strong>current default job</strong>, which is the target of any <code>bg</code> or <code>fg</code> command issued without a <code>%jobID</code>. A <code>-</code> marks the <strong>previous job</strong>, which will become the default once the current default job completes or is removed. For example:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">[</span>1<span style="color:#f92672">]</span>   Running                 sleep <span style="color:#ae81ff">100</span> &amp;
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>2<span style="color:#f92672">]</span>   Running                 sleep <span style="color:#ae81ff">100</span> &amp;
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>3<span style="color:#f92672">]</span>-  Running                 sleep <span style="color:#ae81ff">100</span> &amp;
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>4<span style="color:#f92672">]</span>+  Running                 sleep <span style="color:#ae81ff">100</span> &amp;
</span></span></code></pre></div></li>
<li><code>kill %job_number</code>: Sends a signal (default is <code>SIGTERM</code>) to terminate a job, identified by its job number.</li>
<li><code>Ctrl + C</code>: Terminates a foreground job.</li>
</ul>

</details></p>

<hr>
<h2 id="kill-processes">Kill Processes<a hidden class="anchor" aria-hidden="true" href="#kill-processes">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>In Linux, processes can be terminated using signals. A <strong>signal</strong> is a software interrupt that is delivered to a process. The following table describes common signals.</p>
</blockquote>
<table>
<thead>
<tr>
<th>Signal</th>
<th>Number</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SIGTERM</code></td>
<td>15</td>
<td>Graceful termination (default)</td>
</tr>
<tr>
<td><code>SIGKILL</code></td>
<td>9</td>
<td>Forcefully kill (non-catchable)</td>
</tr>
<tr>
<td><code>SIGINT</code></td>
<td>2</td>
<td>Interrupt from keyboard (<code>Ctrl+C</code>)</td>
</tr>
<tr>
<td><code>SIGHUP</code></td>
<td>1</td>
<td>Hang up / restart daemon</td>
</tr>
<tr>
<td><code>SIGSTOP</code></td>
<td>19</td>
<td>Stop (pause) a process</td>
</tr>
<tr>
<td><code>SIGCONT</code></td>
<td>18</td>
<td>Resume a stopped process</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Note that while signal numbers may vary across different Linux hardware platforms, signal names and their meanings remain consistent. It is generally recommended to use signal names rather than numbers when sending signals. Additionally, Red Hat advises sending <code>SIGTERM</code> first to allow the process to terminate gracefully, followed by <code>SIGINT</code> if necessary. If both signals fail, <code>SIGKILL</code> should be used as a last resort. The <code>SIGKILL</code> signal cannot be caught or ignored, and it forcibly terminates the process without giving it an opportunity to perform any self-cleanup.</p>
</blockquote>
<blockquote>
<p>Here are some commonly used commands related to terminating processes:</p>
</blockquote>
<ul>
<li><code>kill PID</code>: Sends the <code>SIGTERM</code> signal to the specified process, requesting it to terminate gracefully.</li>
<li><code>kill -SIGKILL PID</code>: Sends the <code>SIGKILL</code> signal to forcefully terminate the specified process immediately (cannot be caught or ignored).</li>
<li><code>killall process_name</code>: Sends <code>SIGTERM</code> to all processes matching the given name, attempting a graceful termination.</li>
<li><code>killall -SIGKILL process_name</code>: Sends <code>SIGKILL</code> to all processes matching the given name, forcing termination.</li>
<li><code>pgrep process_name</code>: Searches for processes matching the given name and returns their PIDs.</li>
<li><code>pgrep -u user_name process_name</code>: Searches for processes with the specified name owned by a specific user.</li>
<li><code>pkill process_name</code>: Sends <code>SIGTERM</code> to all processes matching the given name, similar to <code>killall</code>.</li>
<li><code>pkill -SIGKILL process_name</code>: Sends <code>SIGKILL</code> to all processes matching the given name, forcing termination.</li>
<li><code>pkill -u user_name</code>: Sends a signal to all processes owned by the specified user.</li>
<li><code>pstree -p</code>: Displays the process tree with PIDs included.</li>
<li><code>pstree -u</code>: Displays the process tree with associated user names.</li>
</ul>
<blockquote>
<p>In real-world scenarios, system administrators can forcibly terminate a user&rsquo;s session to log them out. The following example demonstrates this process:</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>who -u                  <span style="color:#75715e"># Lists all active user sessions along with their associated PIDs.</span>
</span></span><span style="display:flex;"><span>pkill -t pts/0          <span style="color:#75715e"># Sends SIGTERM (default) to processes attached to terminal pts/0.</span>
</span></span><span style="display:flex;"><span>pkill -SIGINT -t pts/0  <span style="color:#75715e"># If necessary, sends SIGINT to the same terminal.</span>
</span></span><span style="display:flex;"><span>pkill -SIGKILL -t pts/0 <span style="color:#75715e"># As a last resort, sends SIGKILL to forcefully terminate the session.</span>
</span></span></code></pre></div>
</details></p>

<hr>
<h2 id="monitor-process-activity">Monitor Process Activity<a hidden class="anchor" aria-hidden="true" href="#monitor-process-activity">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>In Linux, the <strong>load average</strong> indicates the system&rsquo;s workload over a period of time, measuring how many processes are either actively running or waiting to be executed by the CPU. The load average is typically represented by three numbers, corresponding to the system load over the past 1, 5, and 15 minutes. A load average of <strong>1.0 per CPU</strong> is considered fully utilized, meaning that each CPU is handling one process at a time. For example, if a system has 2 CPUs, a load average of <strong>2.0</strong> would mean that the system is fully utilized. To inspect the number of CPUs in the system, the <code>lscpu</code> command can be used.</p>
</blockquote>
<blockquote>
<p>For instance, if a system has 2 CPUs and the <code>uptime</code> command returns:</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>20:41:31 up 5:29, <span style="color:#ae81ff">3</span> users, load average: 3.32, 1.90, 0.32
</span></span></code></pre></div><ul>
<li>The load average for the last minute is <strong>3.32</strong>, which means the total load on the system is 3.32. With 2 CPUs, the <strong>per-CPU load average</strong> for the last minute is <strong>1.66</strong> (3.32 ÷ 2). This suggests the system is overloaded since the per-CPU load exceeds 1.0.</li>
<li>The load average for the last 5 minutes is <strong>1.90</strong>, and the <strong>per-CPU load average</strong> for this period is <strong>0.95</strong> (1.90 ÷ 2), indicating that the system is closer to optimal usage during this time.</li>
<li>The load average for the last 15 minutes is <strong>0.30</strong>, and the <strong>per-CPU load average</strong> is <strong>0.16</strong> (0.32 ÷ 2), suggesting the system is underutilized.</li>
</ul>

</details></p>

<hr>
<h1 id="9-control-services--daemons">9. Control Services &amp; Daemons<a hidden class="anchor" aria-hidden="true" href="#9-control-services--daemons">#</a></h1>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>In Linux, <strong>systemd</strong> daemon is the system and service mamager repsonsible for initializing the system during boot and managing processes throughout the machine&rsquo;s lifetime. It handles the startup sequence, maintains service states, sepervises processes, and managees logging and dependencies.</p>
</blockquote>
<blockquote>
<p><strong>systemd</strong> uses the concept of <strong>units</strong> to manage and control system resources. A unit represents a single object that <strong>systemd</strong> knows how to manage, such as a <strong>service</strong>, a <strong>device</strong>, a <strong>mount point</strong>, or a <strong>socket</strong>.</p>
</blockquote>
<blockquote>
<p>Each unit is defined by a <strong>unit file</strong>, which describes how <strong>systemd</strong> should handle it — including how to start, stop, reload, and manage dependencies. Unit files are typically stored in directories like <code>/usr/lib/systemd/system/</code> or <code>/etc/systemd/system/</code>.</p>
</blockquote>
<blockquote>
<p>Units are categorized by type, and the type is reflected in the file extension. Common unit types include:</p>
</blockquote>
<ul>
<li><code>.service</code>: for system services (e.g., <code>nginx.service</code>)</li>
<li><code>.socket</code>: for socket activation</li>
<li><code>.target</code>: for grouping units into milestones or states (like <code>multi-user.target</code>, <code>graphical.target</code>)</li>
<li><code>.mount</code>: for filesystem mount points</li>
<li><code>.timer</code>: for time-based activation, like a cron replacement</li>
<li><code>.device</code>: for hardware devices</li>
<li><code>.path</code>: for path-based activation</li>
</ul>
<p>To interact with <strong>systemd</strong>, the <strong>systemctl</strong> is used. It allows administrators to manage services, check system states, enable or disable services at boot, and control system targets. Here are some commonly used commands:</p>
<ul>
<li><code>systemctl status nginx</code>: Displays the status of the <code>nginx</code> service.</li>
<li><code>systemctl start nginx</code>: Starts the <code>nginx</code> service.</li>
<li><code>systemctl stop nginx</code>: Stops the <code>nginx</code> service.</li>
<li><code>systemctl restart nginx</code>: Restarts the <code>nginx</code> service.</li>
<li><code>systemctl enable nginx</code>: Configures <code>nginx</code> to start automatically at boot.</li>
<li><code>systemctl disable nginx</code>: Disables automatic start at boot for <code>nginx</code>.</li>
<li><code>systemctl reload-or-restart nginx</code>: Reload the configuration if supported; otherwise, restart the service.</li>
<li><code>systemctl is-enabled nginx</code>: Check if the service is enabled to start at boot.</li>
<li><code>systemctl is-active nginx</code>: Check if the service is currently running.</li>
<li><code>systemctl list-dependencies nginx</code>: List the dependencies of the service.</li>
<li><code>systemctl mask sendmail.service</code>: Mask the service to prevent it from being started.</li>
<li><code>systemctl unmask sendmail.service</code>: Unmask the service to allow it to be started again.</li>
<li><code>systemctl list-units --type=service</code>: Lists all active services.</li>
<li><code>systemctl reboot</code>: Reboots the system.</li>
<li><code>systemctl poweroff</code>: Powers off the machine.</li>
</ul>

</details></p>

<hr>
<h1 id="10-configure--secure-ssh">10. Configure &amp; Secure SSH<a hidden class="anchor" aria-hidden="true" href="#10-configure--secure-ssh">#</a></h1>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p><strong>SSH (Secure Shell)</strong> is a protocol used to securely access and manage remote systems over an unsecured network. It provides encrypted communication between a client and a server, allowing for secure login, command execution, and file transfer. Here are common SSH usage examples:</p>
</blockquote>
<ul>
<li><code>ssh user@host</code>: Connect to a remote server using the specified user account.</li>
<li><code>ssh user@host command</code>: Execute a command on the remote server without opening an interactive shell.</li>
</ul>
<blockquote>
<p><strong>SSH</strong> also allows passwordless login to a remote server by using a pair of cryptographic keys: A <strong>private key</strong> and a <strong>public key</strong>. A private key is kept on the client machine while the public key is stored on the remote server in <code>~/.ssh/authorized_keys</code>. When connecting, the server uses the public key to verify the client&rsquo;s private key. If the key match, the connection is granted without prompting for a paasword. To enable this feature, following the following steps:</p>
</blockquote>
<ol>
<li><code>ssh-keygen -t rsa -b 4096 -C &quot;RHEL 9 ON Virtual Machine&quot;</code>: Generate a key pair on the client.</li>
<li><code>ssh-copy-id user_name@ip_address</code>: Copy the public key to the remote server.</li>
<li><code>ssh user_name@ip_address</code>: Connect to the server.</li>
</ol>
<p><img loading="lazy" src="/img/linux/21-ssh-keygen.png" alt="SSH Keygen"  />
</p>
<blockquote>
<p>The default configuration of the SSH server works well for many use cases. To apply custom settings (e.g., disable remote login as <code>root</code>), edit the <code>/etc/ssh/sshd_config</code> file, modify the field <code>PermitRootLogin</code> to <code>no</code>. After modifying the configuration, apply the changes by running <code>systemctl reload ssh</code>.</p>
</blockquote>

</details></p>

<hr>
<h1 id="11-analyze--store-logs">11. Analyze &amp; Store Logs<a hidden class="anchor" aria-hidden="true" href="#11-analyze--store-logs">#</a></h1>
<h2 id="system-log-architecture">System Log Architecture<a hidden class="anchor" aria-hidden="true" href="#system-log-architecture">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>In <strong>Red Hat Enterprise Linux</strong>, the standard logging system is based on the <strong>Syslog</strong> protocol, and the <code>systemd-journald</code> and <code>rsyslog</code> services are responsible for handling syslog messages.</p>
</blockquote>
<p><img loading="lazy" src="/img/linux/22-system-log-architechture.png" alt="System Log Architecture"  />
</p>
<blockquote>
<p>The <strong>systemd-journald</strong> service forms the core of the operating system&rsquo;s event logging architecture. It collects event messages from multiple sources, such as the system kernel, output from the early stages of the boot process, standard output and standard error from daemons, and Syslog events. <code>systemd-journald</code> restructures these logs into a standard format and writes them into a structured, indexed system journal. By default, this journal is stored in a file system that does not persist across reboots.</p>
</blockquote>
<blockquote>
<p>On the other hand, the <strong>rsyslog</strong> service reads syslog messages that <code>systemd-journald</code> receives from the journal as they arrive. It then processes the syslog events and records them to log files or forwards them to other services according to its configuration. The <strong>rsyslog</strong> service sorts and writes syslog messages to log files in the <code>/var/log</code> directory, which are persistent across reboots. This directory not only contains syslog message files but also log files from other services on the system. Below is a list of some useful log files located in the <code>/var/log</code> directory:</p>
</blockquote>
<table>
<thead>
<tr>
<th>Log File</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/var/log/messages</code></td>
<td>Logs most system messages, including general syslog messages. Exceptions include authentication-related messages, email processing, scheduled job execution, and debug information.</td>
</tr>
<tr>
<td><code>/var/log/secure</code></td>
<td>Logs security-related messages, including authentication events and user access information.</td>
</tr>
<tr>
<td><code>/var/log/maillog</code></td>
<td>Logs messages related to the mail server, including both mail delivery and other mail-related operations.</td>
</tr>
<tr>
<td><code>/var/log/cron</code></td>
<td>Logs messages related to the execution of scheduled jobs (cron jobs).</td>
</tr>
<tr>
<td><code>/var/log/boot.log</code></td>
<td>Logs non-syslog console messages related to system startup and boot processes.</td>
</tr>
</tbody>
</table>

</details></p>

<hr>
<h2 id="review-syslog-files">Review Syslog Files<a hidden class="anchor" aria-hidden="true" href="#review-syslog-files">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>In Linux, each log message is categorized by facility (which subsystem produces the message) and priority (the message&rsquo;s severity). The following table lists the standard syslog facilities.</p>
</blockquote>
<table>
<thead>
<tr>
<th>Code</th>
<th>Facility</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>kern</td>
<td>Kernel messages</td>
</tr>
<tr>
<td>1</td>
<td>user</td>
<td>User-level messages</td>
</tr>
<tr>
<td>2</td>
<td>mail</td>
<td>Mail system messages</td>
</tr>
<tr>
<td>3</td>
<td>daemon</td>
<td>System daemons messages</td>
</tr>
<tr>
<td>4</td>
<td>auth</td>
<td>Authentication and security messages</td>
</tr>
<tr>
<td>5</td>
<td>syslog</td>
<td>Internal syslog messages</td>
</tr>
<tr>
<td>6</td>
<td>lpr</td>
<td>Printer messages</td>
</tr>
<tr>
<td>7</td>
<td>news</td>
<td>Network new messages</td>
</tr>
<tr>
<td>8</td>
<td>uucp</td>
<td>UUCP protocol messages</td>
</tr>
<tr>
<td>9</td>
<td>cron</td>
<td>Clock daemon messages</td>
</tr>
<tr>
<td>10</td>
<td>authpriv</td>
<td>Non-system authorization messages</td>
</tr>
<tr>
<td>11</td>
<td>ftp</td>
<td>FTP protocol messages</td>
</tr>
<tr>
<td>16-23</td>
<td>local0 to local7</td>
<td>Custom local messages</td>
</tr>
</tbody>
</table>
<blockquote>
<p>The following table lists the standard syslog priorities in descending order.</p>
</blockquote>
<table>
<thead>
<tr>
<th>Code</th>
<th>Priority</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>emerg</td>
<td>System is unusable</td>
</tr>
<tr>
<td>1</td>
<td>alert</td>
<td>Action must be taken immediately</td>
</tr>
<tr>
<td>2</td>
<td>crit</td>
<td>Critical condition</td>
</tr>
<tr>
<td>3</td>
<td>err</td>
<td>Non-critical error condition</td>
</tr>
<tr>
<td>4</td>
<td>warning</td>
<td>Warning condition</td>
</tr>
<tr>
<td>5</td>
<td>notice</td>
<td>Normal but significant event</td>
</tr>
<tr>
<td>6</td>
<td>info</td>
<td>Informational event</td>
</tr>
<tr>
<td>7</td>
<td>debug</td>
<td>Debugging-level message</td>
</tr>
</tbody>
</table>
<blockquote>
<p>The <strong>rsyslog</strong> service uses the facility and priority of log messages to determine how to handle them. Rules configure this facility and priority in the <code>/etc/rsyslog.conf</code> file and in any file in the <code>/etc/rsyslog.d</code> directory with the <code>.conf</code> extension.</p>
</blockquote>
<blockquote>
<p>To prevent log files from consuming too much disk space, Linux uses <strong>log rotation</strong>, a utility that automatically handles the archiving, compressing, and deletion of old log files. A scheduled job runs the <code>logrotate</code> command daily to check if any log files need to be rotated. When a log file is rotated, it is renamed with an extension indicating the rotation date. For example, the old <code>/var/log/messages</code> file might be renamed to <code>/var/log/messages-20250419</code> when it is rotated on April 19, 2025. After rotations, typically over four weeks, the oldest log files are discarded to free up disk space.</p>
</blockquote>
<blockquote>
<p>The <code>tail -f</code> command in Linux is commonly used for monitoring log files in real time. It allows users to continuously view the latest entries being added to a log file, which is especially useful for monitoring system events and troubleshooting. Here is a sample example:</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>tail -f /var/log/secure     <span style="color:#75715e"># In the first terminal</span>
</span></span><span style="display:flex;"><span>ssh signalyu999@ip_address  <span style="color:#75715e"># In the second terminal</span>
</span></span></code></pre></div><blockquote>
<p>The <code>logger</code> command sends messages to the <strong>rsyslog</strong> service, which is useful for testing changes to the <strong>rsyslog</strong> configuration. By default, it logs messages with the <strong>user</strong> facility and <strong>notice</strong> priority (<code>user.notice</code>), unless specified otherwise using the <code>-p</code> option. For example, to send a message to the <strong>rsyslog</strong> service and have it recorded in the <code>/var/log/boot.log</code> log file, the following <code>logger</code> command can be used:</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># /etc/rsyslog.conf</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Save boot messages also to boot.log</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># local7.*                                                /var/log/boot.log</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>logger -p local7.notice <span style="color:#e6db74">&#34;Log entry created on host&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># TEST</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 1. In the first terminal: tail -f /var/log/boot.log</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 2. In the second terminal: logger -p local7.notice &#34;Log entry created on host&#34;</span>
</span></span></code></pre></div>
</details></p>

<hr>
<h2 id="review-system-journal-entries">Review System Journal Entries<a hidden class="anchor" aria-hidden="true" href="#review-system-journal-entries">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>The <strong>systemd-journald</strong> service stores log data in a structured, indexed binary file called the <strong>journal</strong>. To retrieve log messages from the journal, the <code>journalctl</code> command is used. Below are some commonly used commands:</p>
</blockquote>
<ul>
<li><strong><code>journalctl --since &quot;2025-04-18&quot; --until &quot;2025-04-19&quot;</code></strong>: Shows logs from April 18, 2025, to April 19, 2025.</li>
<li><strong><code>journalctl --since &quot;today&quot;</code></strong>: Displays logs from the current day (since midnight).</li>
<li><strong><code>journalctl --since &quot;-1 hour&quot;</code></strong>: Shows logs from the last hour.</li>
<li><strong><code>journalctl --since &quot;-10 minutes&quot;</code></strong>: Displays logs from the last 10 minutes.</li>
<li><strong><code>journalctl -n 50</code></strong>: Shows the last 50 log entries.</li>
<li><strong><code>journalctl -u sshd</code></strong>: Displays logs related to the <code>sshd</code> service (SSH daemon).</li>
<li><strong><code>journalctl -f</code></strong>: Continuously shows the latest log entries in real-time.</li>
<li><strong><code>journalctl -p err</code></strong>: Filters and shows logs with &ldquo;error&rdquo; priority or higher.</li>
<li><strong><code>journalctl _PID=1234</code></strong>: Shows logs related to the process with PID 1234.</li>
<li><strong><code>journalctl _SYSTEMD_UNIT=sshd.service</code></strong>: Displays logs related to the <code>sshd.service</code> systemd unit.</li>
<li><strong><code>journalctl -b</code></strong>: Shows logs from the current boot session.</li>
</ul>
</details></p>

<hr>
<h2 id="preserve-the-system-journal">Preserve the System Journal<a hidden class="anchor" aria-hidden="true" href="#preserve-the-system-journal">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>The <strong>systemd-journald</strong> service stores log data in a structured, indexed binary format known as the <strong>system journal</strong>. By default, Red Hat Enterprise Linux 9 stores the system journal in the <code>/run/log</code> directory, and the system clears the system journal after a reboot. To change this behavior and retain logs across reboots, the <code>Storage</code> parameter in the <code>/etc/systemd/journald.conf</code> file can be set to <code>persistent</code>. After modifying the configuration, the <strong>systemd-journald</strong> service must be restarted for the changes to take effect.</p>
</blockquote>
<blockquote>
<p>The <strong>Storage</strong> parameter has four options:</p>
</blockquote>
<ul>
<li><strong>persistent</strong>: Stores journals in the <code>/var/log/journal</code> directory, ensuring logs persist across reboots. If the <code>/var/log/journal</code> directory does not exist, the <strong>systemd-journald</strong> service creates it automatically.</li>
<li><strong>volatile</strong>: Stores journals in the volatile <code>/run/log/journal</code> directory. These logs are lost upon reboot.</li>
<li><strong>auto</strong>: If the <code>/var/log/journal</code> directory exists, logs are stored persistently. If the directory does not exist, volatile storage is used. This is the default behavior of the <strong>Storage</strong> parameter.</li>
<li><strong>none</strong>: Disables journal storage entirely, meaning no logs are stored.</li>
</ul>

</details></p>

<hr>
<h2 id="maintain-accute-time">Maintain Accute Time<a hidden class="anchor" aria-hidden="true" href="#maintain-accute-time">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>In Linux, maintaining accurate system time is crucial for tasks such as logging, scheduling, and ensuring syschronization across different systems. Time syschronization is typically achieved through the use of the <strong>NTP (Network Time Protocol)</strong>. The NTP is a standard way for machines to provide and obtain correct time information over the internet.</p>
</blockquote>
<blockquote>
<p>Maintaing accurate time commonly involves two commands: <code>tzselect</code> and <code>timedatectl</code>. The <code>tzslect</code> command is an interactive utility used to select a time zone on Linux systems. It guides users through a series of prompts to set the time zone by selecting regions and cities form a list. It is helpful when users do not know the exact time zone string. The <code>timedatectl</code> command is provided by <code>systemd</code> to manage time and time zone settings on Linux systems. It allows users to query and set the system&rsquo;s time, date, and time zone, as well as synchronize the system clock with NTP. Here are some common sample examples of <code>timedatectl</code>:</p>
</blockquote>
<ul>
<li><code>timedatectl status</code>: Displays the current time zone, NTP status, and system time information.</li>
<li><code>sudo timedatectl set-time &quot;YYYY-MM-DD HH:MM:SS&quot;</code>: Sets the system date and time manually.</li>
<li><code>sudo timedatectl set-timezone &lt;timezone&gt;</code>: Changes the system&rsquo;s time zone.</li>
<li><code>timedatectl list-timezones</code>: Lists all available time zones.</li>
<li><code>sudo timedatectl set-ntp true</code>: Enables NTP (Network Time Protocol) synchronization.</li>
<li><code>sudo timedatectl set-ntp false</code>: Disables NTP synchronization.</li>
<li><code>sudo timedatectl set-local-rtc true</code>: Sets the system clock to local time (RTC).</li>
<li><code>sudo timedatectl set-local-rtc false</code>: Sets the system clock to UTC (coordinated universal time).</li>
<li><code>timedatectl show</code>: Displays detailed information about the time and date settings.</li>
</ul>
<blockquote>
<p>The <strong>chrond</strong> service keeps on track the usually inaccurate local <em>Real-Time-Clock (RTC)</em> by synchronizing it to the configured NTP servers. If network connectivity is unavailable, it calculates the RTC drift and stores the data in a file specified by the <code>driftfile</code> parameter in the <code>/etc/chrony.conf</code> configuration file. By default, chronyd uses servers from the NTP Pool Project but can be configured to use different servers for isolated networks. NTP servers are categorized by their <strong>stratum</strong>, with stratum 0 being a reference clock and higher strata representing servers that sync with other NTP servers. In the configuration file, servers and peers are defined, with the server being one stratum above the local server and peers at the same level. The <code>iburst</code> option is recommended for faster and more accurate initial synchronization.</p>
</blockquote>

</details></p>

<hr>
<h1 id="12-manage-networking">12. Manage Networking<a hidden class="anchor" aria-hidden="true" href="#12-manage-networking">#</a></h1>
<h2 id="networking-related-commands">Networking Related Commands<a hidden class="anchor" aria-hidden="true" href="#networking-related-commands">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <ul>
<li><code>ip</code>: A versatile tool for managing network interfaces, routing, and tunneling.
<ul>
<li><code>ip addr</code> pr <code>ip a</code>: Show IP addresses assigned to all interfaces.</li>
<li><code>ip addr add 192.168.1.100/24 dev eth0</code>: Assign an IP address to an interface.</li>
<li><code>ip link</code> or <code>ip l</code>: Show network interfaces and their status.</li>
<li><code>ip link set eth0 up</code>: Enable (bring up) a network interface.</li>
<li><code>ip link set eth0 down</code>: Disable (bring down) a network interface.</li>
<li><code>ip route</code> or <code>ip r</code>: Display the current routing table.</li>
<li><code>ip route add 192.168.2.0/24 via 192.168.1.1</code>: Add a static route.</li>
<li><code>ip route del 192.168.2.0/24</code>: Delete a route.</li>
<li><code>ip neigh</code>: Show the ARP table (neighbor cache).</li>
</ul>
</li>
<li><code>ss</code>: A utility to investigate sockets. It is used for displaying information about network connections, listening ports, etc.
<ul>
<li><code>ss</code>: Display all established sockets and connections.</li>
<li><code>ss -t</code>: Show only TCP connections.</li>
<li><code>ss -u</code>: Show only UDP connections.</li>
<li><code>ss -l</code>: Show listening sockets.</li>
<li><code>ss -tunlp</code>: Show TCP/UDP listening ports with process info (<code>-p</code>).</li>
<li><code>ss -s</code>: Display a summary of socket statistics.</li>
<li><code>ss -t state established</code>: Show established TCP connections.</li>
<li><code>ss -an</code>: Show all sockets (listening and non-listening) in numeric format.</li>
<li><code>ss -o state established</code>: Show established connections with timers.</li>
</ul>
</li>
<li><code>ping</code>: A tool used to test network connectivity between the client and the remote host by sending ICMP echo requests.
<ul>
<li><code>ping baidu.com</code></li>
</ul>
</li>
<li><code>traceroute</code>: A tool to trace the path packets take to reach a network destination, showing each hop along the way.
<ul>
<li><code>traceroute &lt;hostname/IP&gt;</code>: Trace the route packets take to reach the target host.</li>
<li><code>traceroute -n &lt;hostname/IP&gt;</code>: Show IP addresses only, skip hostname resolution (faster).</li>
<li><code>traceroute -m 20 &lt;hostname/IP&gt;</code>: Set maximum number of hops to 20.</li>
<li><code>traceroute -p 80 &lt;hostname/IP&gt;</code>: Use destination port 80 (helpful for testing web servers).</li>
<li><code>traceroute -I &lt;hostname/IP&gt;</code>: Use ICMP ECHO instead of UDP packets.</li>
<li><code>traceroute -T &lt;hostname/IP&gt;</code>: Use TCP SYN packets instead of UDP (helpful for firewalled networks).</li>
</ul>
</li>
<li><code>tracepath</code>: A simpler version of <code>traceroute</code> that shows the path packets take to a destination but also provides information about packet loss and latency along the way.
<ul>
<li><code>tracepath &lt;hostname/IP&gt;</code>: Trace the path to a destination, showing each network hop along the way.</li>
<li><code>tracepath -n &lt;hostname/IP&gt;</code>: Display IP addresses only, skip reverse DNS lookup (faster).</li>
<li><code>tracepath6 &lt;hostname/IP&gt;</code>: Use IPv6 to trace the route to the target.</li>
</ul>
</li>
<li><code>host</code>: A simple DNS lookup tool that resolves domain names to IP addresses.
<ul>
<li><code>host &lt;domain&gt;</code>: Resolve a domain name to its IP address.</li>
</ul>
</li>
<li><code>dig</code>: A DNS lookup tool that queries the Domain Name System (DNS) for information about hostnames, IP addresses, and other DNS records.
<ul>
<li><code>dig &lt;domain&gt;</code>: Query the default DNS records (usually A records) for a domain.</li>
</ul>
</li>
<li><code>nmcli</code>: A command-line interface for NetworkManager, used for manageing network connections and settings, such as configuring interfaces, VPNs, and Wi-Fi.
<ul>
<li><code>nmcli device status</code> or <code>dev con status</code>: Show the status of all network interfaces.</li>
<li><code>nmcli connection show</code> or <code>nmcli con show</code>: List all saved network connections.</li>
<li><code>nmcli connection up &lt;connection-name&gt;</code>: Activate a network connection.</li>
<li><code>nmcli connection down &lt;connection-name&gt;</code>: Deactivate a network connection.</li>
<li><code>nmcli device connect &lt;device&gt;</code>: Connect a network device.</li>
<li><code>nmcli device disconnect &lt;device&gt;</code>: Disconnect a network device.</li>
</ul>
</li>
<li><code>getent</code>: A command used to query various system databases, including DNS, password, group, and hosts. It is useful for retriving information that&rsquo;s typically stored in files like <code>/etc/hosts</code> or through services like DNS.
<ul>
<li><code>getent hosts &lt;hostname&gt;</code>: Resolve a hostname to its IP address (similar to <code>host</code> or <code>nslookup</code>).</li>
<li><code>getent services &lt;service&gt;</code>: Lookup port and protocol for a service (e.g., <code>getent services ssh</code>).</li>
<li><code>getent protocols</code>: List network protocols.</li>
<li><code>getent passwd</code>: List all user account entries from <code>/etc/passwd</code> or configured name service.</li>
<li><code>getent passwd &lt;username&gt;</code>: Query information for a specific user.</li>
<li><code>getent group</code>: List all group entries from <code>/etc/group</code> or configured name service.</li>
<li><code>getent group &lt;groupname&gt;</code>: Query information for a specific group.</li>
</ul>
</li>
</ul>

</details></p>

<h2 id="configure-network">Configure Network<a hidden class="anchor" aria-hidden="true" href="#configure-network">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>In RHEL 9, the network can be configured through file-based settings by creating a <code>.nmconnection</code> file in the <code>/etc/NetworkManager/system-connections</code> directory. After editing the configuration, set the file permissions to restrict access to the root user for security. Update the <code>/etc/resolv.conf</code> file to specify DNS servers. Once the configuration is complete, reload the NetworkManager connection profiles to apply the changes. If <code>autoconnect</code> is set to <code>false</code>, manually bring the connection up.</p>
</blockquote>
<ol>
<li><code>vim /etc/NetworkManager/system-connections/ens160-static.nmconnection</code>: Open or create the network configuration file for editing.</li>
<li>Edit the configuration file as below:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">[</span>connection<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>id<span style="color:#f92672">=</span>ens160
</span></span><span style="display:flex;"><span>uuid<span style="color:#f92672">=</span>62b7fd25-b5d9-3cae-8156-bc455c45b046
</span></span><span style="display:flex;"><span>type<span style="color:#f92672">=</span>ethernet
</span></span><span style="display:flex;"><span>autoconnect-priority<span style="color:#f92672">=</span>-999
</span></span><span style="display:flex;"><span>interface-name<span style="color:#f92672">=</span>ens160-static
</span></span><span style="display:flex;"><span>timestamp<span style="color:#f92672">=</span><span style="color:#ae81ff">1744708123</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>ethernet<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>ipv4<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>method<span style="color:#f92672">=</span>manual
</span></span><span style="display:flex;"><span>address1<span style="color:#f92672">=</span>192.168.254.138/24
</span></span><span style="display:flex;"><span>gateway<span style="color:#f92672">=</span>192.168.254.2
</span></span><span style="display:flex;"><span>ignore-auto-dns<span style="color:#f92672">=</span>true
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>ipv6<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>addr-gen-mode<span style="color:#f92672">=</span>eui64
</span></span><span style="display:flex;"><span>method<span style="color:#f92672">=</span>auto
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>proxy<span style="color:#f92672">]</span>
</span></span></code></pre></div></li>
<li><code>chown root:root /etc/NetworkManager/system-connections/ens160-static.nmconnection</code>: Set the file owner and group to <code>root</code>.</li>
<li><code>chmod 600 /etc/NetworkManager/system-connections/ens160-static.nmconnection</code>: Restrict permissions so only the root user can read and modify the file.</li>
<li><code>vim /etc/resolv.conf</code>: Edit the configuration file as below:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># Generated by NetworkManager</span>
</span></span><span style="display:flex;"><span>nameserver 8.8.8.8
</span></span><span style="display:flex;"><span>nameserver 8.8.4.4
</span></span></code></pre></div></li>
<li><code>nmcli con reload</code>: Reload NetworkManager connection profiles to apply changes.</li>
<li><code>nmcli con up ens160-static</code>: Bring the <code>ens160-static</code> connection up manually (required if <code>autoconnect</code> is disabled).</li>
</ol>
</details></p>

<hr>
<h1 id="13-archive--transfer-files">13. Archive &amp; Transfer Files<a hidden class="anchor" aria-hidden="true" href="#13-archive--transfer-files">#</a></h1>
<h2 id="manage-compressed-tar-files">Manage Compressed <code>tar</code> Files<a hidden class="anchor" aria-hidden="true" href="#manage-compressed-tar-files">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>An <strong>archive</strong> is a single file that stores multiple files and directories, often used for creating backups or simplifying file transfers across a network. On Linux, the <strong>tar</strong> utility is commonly used to create, manage, and extract archives. Below are some frequently used commands:</p>
</blockquote>
<ul>
<li><code>tar -cvf archive.tar file1 file2</code>: Archives multiple files into a single uncompressed <code>.tar</code> file.</li>
<li><code>tar -xvf archive.tar file1 file2  -C ./archives/</code>: Extracts specific files from an uncompressed <code>.tar</code> archive to the <code>./archives/</code> directory.</li>
<li><code>tar -czvf archive.tar.gz file1 file2</code>: Creates a compressed <code>.tar.gz</code> archive from multiple files using gzip compression.</li>
<li><code>tar -xzvf archive.tar.gz file1 file2  -C ./archives/</code>: Extracts specific files from a <code>.tar.gz</code> compressed archive to the <code>./archives/</code> directory.</li>
<li><code>tar -cjvf archive.tar.bz2 file1 file2</code>: Creates a compressed <code>.tar.bz2</code> archive using bzip2 compression.</li>
<li><code>tar -xjvf archive.tar.bz2 file1 file2  -C ./archives/</code>: Extracts specific files from a <code>.tar.bz2</code> compressed archive to the <code>./archives/</code> directory.</li>
<li><code>tar -cJvf archive.tar.xz file1 file2</code>: Creates a compressed <code>.tar.xz</code> archive using xz compression.</li>
<li><code>tar -xJvf archive.tar.xz file1 file2  -C ./archives/</code>: Extracts specific files from a <code>.tar.xz</code> compressed archive to the <code>./archives/</code> directory.</li>
</ul>
</details></p>

<hr>
<h2 id="transfer-files-using-sftp">Transfer Files Using <code>sftp</code><a hidden class="anchor" aria-hidden="true" href="#transfer-files-using-sftp">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>To securely transfer files between systems, use the <code>sftp</code> command. Below are some commonly used <code>sftp</code> commands:</p>
</blockquote>
<ul>
<li><code>sftp user_name@ip_address:/home/user_name/remote_file</code>: Connect to the server and directly fetch a remote file to the local.</li>
<li><code>sftp user_name@ip_address</code>: Connect to the remote server via SFTP.</li>
<li><code>help</code>: Display a list of available SFTP commands.</li>
<li><code>pwd</code>: Show the current remote working directory.</li>
<li><code>lpwd</code>: Show the current local working directory.</li>
<li><code>ls</code>: List files in the remote directory.</li>
<li><code>lls</code>: List files in the local directory.</li>
<li><code>cd</code>: Change the remote directory.</li>
<li><code>lcd</code>: Change the local directory.</li>
<li><code>put</code>: Upload a file from local to remote.</li>
<li><code>put -r</code>: Recursively upload an entire directory.</li>
<li><code>mput</code>: Upload multiple files matching a pattern.</li>
<li><code>get -r</code>: Recursively download an entire remote directory.</li>
<li><code>mget</code>: Download multiple files matching a pattern.</li>
<li><code>bye</code>: Exit the SFTP session.</li>
</ul>
</details></p>

<hr>
<h2 id="synchronize-file-using-rsync">Synchronize File Using <code>rsync</code><a hidden class="anchor" aria-hidden="true" href="#synchronize-file-using-rsync">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p><code>rsync</code> is a fast and versatile command-line tool for copying and synchronizing files locally and remotely. It only transfers the differences between source and destination, saving time and bandwidth. Below are some commonly used <code>rsync</code> commands:</p>
</blockquote>
<ul>
<li><code>rsync -avz source/ destination/</code>: synchronize files/directories locally with compression and verbose output.</li>
<li><code>rsync -avh /local/path/ /destination/path/</code>: sync local directories with human-readable file sizes.</li>
<li><code>rsync -avz /local/path/ user@remote:/remote/path/</code>: upload files from local to remote server over SSH.</li>
<li><code>rsync -avz user@remote:/remote/path/ /local/path/</code>: download files from remote server to local machine.</li>
<li><code>rsync -avz --delete /local/path/ user@remote:/remote/path/</code>: sync local to remote and delete files on remote that don’t exist locally.</li>
<li><code>rsync -avz -e ssh /local/path/ user@remote:/remote/path/</code>: sync files over SSH, explicitly specifying the SSH protocol.</li>
</ul>
</details></p>

<hr>
<h1 id="14-install--update-software-packages">14. Install &amp; Update Software Packages<a hidden class="anchor" aria-hidden="true" href="#14-install--update-software-packages">#</a></h1>
<h2 id="change-repository-mirror">Change Repository Mirror<a hidden class="anchor" aria-hidden="true" href="#change-repository-mirror">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>By default, Red Hat Enterprise Linux (RHEL) 9 uses the official repository as its software source. To replace it with the Alibaba Cloud CentOS Stream mirror, follow these steps:</p>
</blockquote>
<ol>
<li>Open the <code>redhat.repo</code> file and disable the BaseOS and AppStream repositories by changing <code>enabled=1</code> to <code>enabled=0</code>:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo vim /etc/yum.repos.d/redhat.repo
</span></span></code></pre></div><ul>
<li><strong>BaseOS</strong> and <strong>AppStream</strong> are two key repositories used in Red Hat-based Linux to organize and manage system software and applications. The <strong>BaseOS</strong> contains the essential operating system components, such as the kernel, system libraries, and core utilities. While the <strong>AppStream</strong> contains additional software packages that are not esssential for the base system but are needed for specific applications and use cases.</li>
</ul>
</li>
<li>Create a new repository file named <code>aliyun.repo</code> and add the following configuration:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">[</span>AppStream<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>name <span style="color:#f92672">=</span> Aliyun Centos Stream - AppStream
</span></span><span style="display:flex;"><span>baseurl <span style="color:#f92672">=</span> https://mirrors.aliyun.com/centos-stream/9-stream/AppStream/x86_64/os/
</span></span><span style="display:flex;"><span>enabled <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>gpgcheck <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>BaseOS<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>name <span style="color:#f92672">=</span> Aliyun Centos Stream - BaseOS
</span></span><span style="display:flex;"><span>baseurl <span style="color:#f92672">=</span> http://mirrors.aliyun.com/centos-stream/9-stream/BaseOS/x86_64/os/ 
</span></span><span style="display:flex;"><span>enabled <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>gpgcheck <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span></code></pre></div></li>
<li>Clean the existing DNF cache to remove outdated metadata:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo dnf clean all
</span></span></code></pre></div></li>
<li>Rebuild the repository cache to ensure the new mirror is loaded:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo dnf makecache
</span></span></code></pre></div></li>
</ol>
<blockquote>
<p><strong>Note:</strong> If the transaction test fails when running <code>sudo dnf update</code> (for example, due to package conflicts), the issue can be temporarily avoided by excluding the conflicting packages:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo dnf update --exclude<span style="color:#f92672">=</span>openssl*  
</span></span></code></pre></div><p>This allows the update process to complete for other packages while the conflict is handled separately.</p>
</blockquote>

</details></p>

<hr>
<h2 id="install--update-software-packages-with-dnf">Install &amp; Update Software Packages with <code>dnf</code><a hidden class="anchor" aria-hidden="true" href="#install--update-software-packages-with-dnf">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p><strong>DNF</strong> (Dandified YUM) is the default package manager for RPM-based Linux distributions such as Fedora, CentOS, and RHEL. While DNF offers improved performance and new features over YUM, its commands are largely functionally identical. For backward compatibility, YUM commands still exist as symbolic links to DNF. Below are some basic <code>dnf</code> commands:</p>
</blockquote>
<ul>
<li><strong><code>dnf install &lt;package&gt;</code></strong>: Installs the specified package.</li>
<li><strong><code>dnf update</code></strong>: Updates all installed packages to their latest versions.</li>
<li><strong><code>dnf remove &lt;package&gt;</code></strong>: Removes the specified package from the system.</li>
<li><strong><code>dnf search &lt;package&gt;</code></strong>: Searches for a package by name or description.</li>
<li><strong><code>dnf list installed</code></strong>: Lists all installed packages on the system.</li>
<li><strong><code>dnf list &lt;package&gt;</code></strong>: Lists detailed information about the specified package.</li>
<li><strong><code>dnf info &lt;package&gt;</code></strong>: Provides detailed information about the specified package (e.g., version, repository, dependencies).</li>
<li><strong><code>dnf upgrade</code></strong>: Upgrades all installed packages to the latest versions, including kernel updates.</li>
<li><strong><code>dnf clean all</code></strong>: Cleans up the local repository cache to free up disk space.</li>
<li><strong><code>dnf makecache</code></strong>: Forces DNF to refresh and rebuild the metadata cache.</li>
</ul>
<blockquote>
<p>The <code>dnf</code> command also has the concept of <strong>groups</strong>. A package group is a collection of related software packages that can be installed or removed together. Here are some common <code>dnf group</code> commands:</p>
</blockquote>
<ul>
<li><strong><code>dnf group list</code></strong>: Lists all available package groups, including those that are installed and those that can be installed from repositories.</li>
<li><strong><code>dnf group list installed</code></strong>: Lists only the package groups that are currently installed on the system.</li>
<li><strong><code>dnf group info &lt;group_name&gt;</code></strong>: Displays detailed information about a specific package group, including the list of packages that belong to that group.</li>
<li><strong><code>dnf group install &lt;group_name&gt;</code></strong>: Installs all packages within a specified group, allowing you to easily install related software at once.</li>
<li><strong><code>dnf group remove &lt;group_name&gt;</code></strong>: Removes all packages in a specified group from the system.</li>
<li><strong><code>dnf group update &lt;group_name&gt;</code></strong>: Updates all the packages in the specified group to their latest available versions.</li>
<li><strong><code>dnf group upgrade &lt;group_name&gt;</code></strong>: Upgrades all the packages in the specified group, including dependencies and related packages.</li>
</ul>
<blockquote>
<p><strong>Transaction History</strong> refers to the record of package transactions, such as installations, removals, and updates. The <code>dnf history</code> command allows you to view past actions taken by DNF and revert to previous states when necessary. Below are some common <code>dnf history</code> commands:</p>
</blockquote>
<ul>
<li><strong><code>dnf history</code></strong>: Lists all past transactions, showing details such as transaction ID, date, action (install, remove, update), and affected packages.</li>
<li><strong><code>dnf history info &lt;transaction_id&gt;</code></strong>: Displays detailed information about a specific transaction, including the packages that were installed, removed, or updated.</li>
<li><strong><code>dnf history undo &lt;transaction_id&gt;</code></strong>: Reverts the changes made in a specific transaction, such as undoing the installation or removal of packages.</li>
<li><strong><code>dnf history rollback &lt;transaction_id&gt;</code></strong>: Restores the system to the state it was in immediately after a specified transaction, undoing all changes made since that transaction.</li>
<li><strong><code>dnf history reset</code></strong>: Clears the transaction history, removing all past transaction records from the system.</li>
</ul>
<blockquote>
<p><strong>DNF Modularity</strong> is a feature of the DNF package manager that enables users to install different versions of software packages within a single distribution. Key concepts of DNF Modularity includes <strong>Modules</strong>, <strong>Streams</strong>, and <strong>Profiles</strong>.</p>
<ul>
<li><strong>Modules</strong> A module is a collection of related packages that can be installed or removed together, and each module can have multiple streams (versions) of a package.</li>
<li><strong>Streams</strong>: Streams represent different versions or variants of a module. For example, a module for <code>python</code> may have different streams for <code>python3.6</code>, <code>python3.8</code>, etc.</li>
<li><strong>Profiles</strong>: Profiles are predefined sets of packages that can be installed as part of a module. A profile could include a minimal installation or a development environment for a specific stream.
Here are some common <code>dnf module</code> commands:</li>
<li><strong><code>dnf module list</code></strong>: Lists all available modules and their streams.</li>
<li><strong><code>dnf module enable &lt;module_name&gt;</code></strong>: Enables a module, allowing the installation of its packages.</li>
<li><strong><code>dnf module disable &lt;module_name&gt;</code></strong>: Disables a module, preventing its packages from being installed.</li>
<li><strong><code>dnf module install &lt;module_name&gt;</code></strong>: Installs a module and its packages, using the default stream unless specified.</li>
<li><strong><code>dnf module info &lt;module_name&gt;</code></strong>: Shows detailed information about a module, including its streams and profiles.</li>
<li><strong><code>dnf module update &lt;module_name&gt;</code></strong>: Updates a module and its packages to the latest available versions.</li>
<li><strong><code>dnf module provides &lt;package_name&gt;</code></strong>: Displays which module provdies a specific package.</li>
</ul>
</blockquote>

</details></p>

<hr>
<h1 id="15-access-linux-file-system">15. Access Linux File System<a hidden class="anchor" aria-hidden="true" href="#15-access-linux-file-system">#</a></h1>
<h2 id="disk-partition">Disk Partition<a hidden class="anchor" aria-hidden="true" href="#disk-partition">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>A <strong>file system</strong> is a method of organizing and storing data on storage devices. It defines how data is stored, retrieved, and managed. To examine the file system on Linux, the <code>df</code> command provides an overview of disk space usage, while the <code>du</code> command offers detailed information about the disk usage of a specific file or directory. Here are some useful commands:</p>
<ul>
<li><code>df -h</code>: Displays disk space usage in a human-readable format.</li>
<li><code>df -T</code>: Displays the file system type along with disk space usage.</li>
<li><code>du -h &lt;directory_name&gt;</code>: Displays disk usage for a specific directory in a human-readable format.</li>
<li><code>du -sh</code>: Displays the total disk usage of the current directory in a human-readable format.</li>
<li><code>du -sh &lt;directory_name&gt;</code>: Displays the total disk usage for a specified directory in a human-readable format.</li>
</ul>
</blockquote>
<blockquote>
<p>Common file systems include <strong>ext4</strong>, <strong>NTFS</strong>, and <strong>XFS</strong>. To access the contents of a file system, it must be mounted to an empty directory, known as the <strong>mount point</strong>.</p>
</blockquote>
<blockquote>
<p>Typically, the entire storage device is not formatted into a single file system; instead, it is divided into several partitions. Each partition is considered a block device in its own right. For example:</p>
<ul>
<li>The first partition on the first SATA-attached storage is <code>/dev/sda1</code>.</li>
<li>The second partition on the same device is <code>/dev/sda2</code>.</li>
<li>The second partition on the second device is <code>/dev/sdb2</code>.</li>
<li>The third partition on the third SATA-attached storage is <code>/dev/sdc3</code>, and so on.</li>
</ul>
</blockquote>
<blockquote>
<p>To mount a file system manually, follow these steps:</p>
<ol>
<li><strong>Identify Block Devices</strong>: Use the <code>lsblk</code> command to identify available block devices. (Use <code>fdisk</code> for partition manipulation when needed.)</li>
<li><strong>Create a Mount Point</strong>: Create an empty directory (mount point) using the <code>mkdir</code> command.</li>
<li><strong>Mount the Device</strong>: Use the <code>sudo mount &lt;device_name&gt; &lt;mount_point&gt;</code> command to mount the file system.</li>
<li><strong>Verify the Mount</strong>: Use the <code>df</code> command to verify the mount operation.</li>
</ol>
</blockquote>
<blockquote>
<p>Here’s an example of device mounting:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#75715e"># 1. Use lsblk to get the block device name</span>
</span></span><span style="display:flex;"><span>lsblk
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 2. Create a mount point</span>
</span></span><span style="display:flex;"><span>mkdir /mnt/data
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 3. Mount the device</span>
</span></span><span style="display:flex;"><span>sudo mount /dev/sdb1 /mnt/data
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 4. Verify the mount operation</span>
</span></span><span style="display:flex;"><span>df -h
</span></span></code></pre></div></blockquote>
<blockquote>
<p>Note that file systems are automatically unmounted when the system shuts down or reboots. To ensure a file system is mounted at boot, edit the <code>/etc/fstab</code> file and add the following line:</p>
<pre tabindex="0"><code>/dev/sdb1    /mnt/data    ext4    defaults    0    0
</code></pre></blockquote>
<blockquote>
<p>To unmount a device, ensure all processes related to it are terminated, then use the <code>umount</code> command:</p>
<pre tabindex="0"><code>umount /mnt/data
</code></pre></blockquote>

</details></p>

<hr>
<h2 id="locate-file-on-the-system">Locate File on the System<a hidden class="anchor" aria-hidden="true" href="#locate-file-on-the-system">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>To locate a file on a Linux system, commonly used commands include <code>find</code>, <code>locate</code>, <code>which</code>, and <code>whereis</code>.</p>
</blockquote>
<blockquote>
<p>The <code>find</code> command searches for files in real time by parsing the file system hierarchy. Here are some commonly used <code>find</code> examples:</p>
<ul>
<li><code>find /home -name &quot;myfile.txt&quot;</code>: Searches for a file named <code>myfile.txt</code> in the <code>/home</code> directory.</li>
<li><code>find / -name &quot;*.log&quot;</code>: Searches for all <code>.log</code> files starting from the root directory.</li>
<li><code>find / -iname &quot;*message*&quot;</code>: Searches for files that contain the word &ldquo;message&rdquo; (case-insensitive) in their names, starting from the root directory <code>/</code>.</li>
<li><code>find /home -name &quot;*.txt&quot; -size +1M</code>: Finds <code>.txt</code> files larger than 1MB in the <code>/home</code> directory.</li>
<li><code>find /home -name &quot;*.txt&quot; -size -1G</code>: Finds <code>.txt</code> files smaller than 1GB in the <code>/home</code> directory.</li>
</ul>
</blockquote>
<blockquote>
<p>The <code>locate</code> command searches a pre-generated index of file names and paths, making it much faster than <code>find</code>. However, it may not reflect recent changes in the file system until the index is updated. To update the database, use the <code>updatedb</code> command. Below are common <code>locate</code> examples:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>sudo updatedb      <span style="color:#75715e"># Updates the locate database</span>
</span></span><span style="display:flex;"><span>locate file.txt    <span style="color:#75715e"># Searches for the file &#34;file.txt&#34;</span>
</span></span></code></pre></div></blockquote>
<blockquote>
<p>The <code>which</code> command locates executables in the directories listed in the <code>$PATH</code> environment variable. It is useful for determining the location of a command or executable. For example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>which python       <span style="color:#75715e"># Finds the path of the python executable</span>
</span></span></code></pre></div></blockquote>
<blockquote>
<p>The <code>whereis</code> command is used to locate the binary, source, and manual page files associated with a command. It is commonly used to search for documentation and related files. For example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>whereis python     <span style="color:#75715e"># Finds binary, source, and man page for python</span>
</span></span></code></pre></div></blockquote>

</details></p>

<hr>
<h1 id="16-schedule-future-tasks">16. Schedule Future Tasks<a hidden class="anchor" aria-hidden="true" href="#16-schedule-future-tasks">#</a></h1>
<h2 id="schedule-a-user-job">Schedule a User Job<a hidden class="anchor" aria-hidden="true" href="#schedule-a-user-job">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>To schedule a deferred user job, the <code>at</code> command and the <code>cron</code> system can be used. The <code>at</code> command is suitable for one-time deferred tasks, while the <code>cron</code> system is better for recurring tasks.</p>
</blockquote>
<blockquote>
<p>The <code>at</code> command schedules a one-time deferred task to run at a specific time in the future. To view pending jobs, use the <code>atq</code> command. When there is a need to cancel or remove a scheduled job, use the <code>atrm</code> command along with the job ID, which can be obtained from the <code>atq</code> command. Below is an example of using <code>at</code> command:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;date &gt;&gt; ~/myjob.txt&#34;</span> | at now +1 minute
</span></span></code></pre></div></blockquote>
<blockquote>
<p>For recurring tasks, use the <code>crontab</code> command. Below is an example of scheduling a job to run every day at 3 AM:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>crontab -e
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">3</span> * * * date &gt;&gt; ~/myjob.txt  <span style="color:#75715e"># Schedule at 3 AM every day</span>
</span></span></code></pre></div></blockquote>

</details></p>

<hr>
<h2 id="schedule-a-system-job">Schedule a System Job<a hidden class="anchor" aria-hidden="true" href="#schedule-a-system-job">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>To schedule a system job, it is necessary to edit the <code>/etc/crontab</code> file or create a custom cron job file inside the <code>/etc/cron.d/</code> directory. (Note that files in <code>/etc/cron.d/</code> are not executable by default; to make them executable, run <code>chmod +x file_name</code>.) The shell scripts executed by these job entries are typically located in directories such as <code>/etc/cron.hourly/</code>, <code>/etc/cron.daily/</code>, etc. Below are some common examples of scheduling system jobs:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 1. Create a script named hourly_job.sh in /etc/cron.hourly/</span>
</span></span><span style="display:flex;"><span>sudo vim /etc/cron.hourly/hourly_job.sh
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 2. Add the following content to the script</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#!/bin/bash</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;Hourly job executed at </span><span style="color:#66d9ef">$(</span>date<span style="color:#66d9ef">)</span><span style="color:#e6db74">&#34;</span> &gt;&gt; /var/log/hourly_job.log
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 3. Make the script executable</span>
</span></span><span style="display:flex;"><span>sudo chmod +x /etc/cron.hourly/hourly_job.sh
</span></span></code></pre></div></blockquote>
<blockquote>
<p><strong>Anacron</strong> is used for scheduling tasks that should run periodically but not necessarily at fixed times. It ensures that a missed job is executed as soon as possible after the system starts up. Below is an sample example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># period   delay   job-identifier   command</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 1        5       dailybackup      /usr/local/bin/backup.sh</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Run a daily backup at system start (5 minutes after boot)</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>   <span style="color:#ae81ff">5</span>   dailybackup   /usr/local/bin/backup.sh
</span></span></code></pre></div></blockquote>
<blockquote>
<p><strong>Systemd timers</strong> provide a more flexible way of scheduling tasks on Linux systems. They integrate with the systemd service manager, which makes them more powerful and capable of handling advanced scenarios. A systemd timer works by triggering a systemd service at specific intervals. It uses two components: <strong>Timer Unit</strong> and <strong>Service Unit</strong>.</p>
<ul>
<li><strong>Timer Unit</strong>: Defines when the task will be executed.</li>
<li><strong>Service Unit</strong>: Defines the actual task to be run.</li>
</ul>
</blockquote>
<blockquote>
<p>Below is an example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 1. Create a service file</span>
</span></span><span style="display:flex;"><span>sudo vim /etc/systemd/system/myjob.service
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 2. Add the following content to the file</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>Unit<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>Description<span style="color:#f92672">=</span>Run my scheduled task
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>Service<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>Type<span style="color:#f92672">=</span>oneshot  <span style="color:#75715e"># The service runs a one-time task</span>
</span></span><span style="display:flex;"><span>ExecStart<span style="color:#f92672">=</span>/usr/local/bin/myscript.sh  <span style="color:#75715e"># Specifies the command to execute</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 3. Create a timer unit</span>
</span></span><span style="display:flex;"><span>sudo vim /etc/systemd/system/myjob.timer
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 4. Add the following content to the file</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>Unit<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>Description<span style="color:#f92672">=</span>Run my job every day at <span style="color:#ae81ff">3</span> AM
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>Timer<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>OnCalendar<span style="color:#f92672">=</span>daily  <span style="color:#75715e"># Schedules the task to run once a day</span>
</span></span><span style="display:flex;"><span>Persistent<span style="color:#f92672">=</span>true  <span style="color:#75715e"># Ensures that if the system is off during the scheduled time, the task will run once the system boots up.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>Install<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>WantedBy<span style="color:#f92672">=</span>timers.target
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 5. Reload the systemd</span>
</span></span><span style="display:flex;"><span>sudo systemctl daemon-reload
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 6. Enable and start the timer</span>
</span></span><span style="display:flex;"><span>sudo systemctl enable myjob.timer
</span></span><span style="display:flex;"><span>sudo systemctl start myjob.timer
</span></span></code></pre></div></blockquote>

</details></p>

<hr>
<h2 id="manage-temporary-files">Manage Temporary Files<a hidden class="anchor" aria-hidden="true" href="#manage-temporary-files">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p><strong><code>systemd-tmpfiles</code></strong> is a utility provided by <code>systemd</code> that allows for automatic management of temporary files and directories on Linux systems. It is primarily used to clean up temporary files, manage file permissions, and enforce file creation rules. <code>systemd-tmpfiles</code> works based on configuration files located in <code>/etc/tmpfiles.d/</code>, <code>/usr/lib/tmpfiles.d/</code>, and <code>/run/tmpfiles.d/</code>. Below is an example of automatic clean up:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 1. Create a configuration file</span>
</span></span><span style="display:flex;"><span>sudo vim /etc/tmpfiles.d/temp_cleanup.conf
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 2. Add the following content to the file</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Type   Path           Mode  UID  GID  Age   Argument</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Remove any .log files in /tmp that are older than 7 days.</span>
</span></span><span style="display:flex;"><span>f       /tmp/*.log      <span style="color:#ae81ff">0644</span>  root root 7d    -
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Remove empty directories in /tmp older than 7 days.</span>
</span></span><span style="display:flex;"><span>d       /tmp/           <span style="color:#ae81ff">1777</span>  root root 7d    -
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 3. Create a system timer for automatic cleanup</span>
</span></span><span style="display:flex;"><span>sudo vim /etc/systemd/system/tmpfiles-cleanup.timer
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 4. Add the following content to the file</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>Unit<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>Description<span style="color:#f92672">=</span>Automatic cleanup of temporary files
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>Timer<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Run 1 hour after boot, then once every day</span>
</span></span><span style="display:flex;"><span>OnBootSec<span style="color:#f92672">=</span>1h
</span></span><span style="display:flex;"><span>OnUnitActiveSec<span style="color:#f92672">=</span>1d
</span></span><span style="display:flex;"><span>Unit<span style="color:#f92672">=</span>systemd-tmpfiles-clean.service
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>Install<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>WantedBy<span style="color:#f92672">=</span>timers.target
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 5. Create the service unit for systemd-tmpfiles cleanup</span>
</span></span><span style="display:flex;"><span>sudo vim /etc/systemd/system/systemd-tmpfiles-clean.service
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 6. Add the following content</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>Unit<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>Description<span style="color:#f92672">=</span>Cleanup temporary files using systemd-tmpfiles
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>Service<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>Type<span style="color:#f92672">=</span>oneshot
</span></span><span style="display:flex;"><span>ExecStart<span style="color:#f92672">=</span>/usr/bin/systemd-tmpfiles --clean
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 7. Reload the systemd</span>
</span></span><span style="display:flex;"><span>sudo systemctl daemon-reload
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 8. Enable and start the timer</span>
</span></span><span style="display:flex;"><span>sudo systemctl enable tmpfiles-cleanup.timer
</span></span><span style="display:flex;"><span>sudo systemctl start tmpfiles-cleanup.timer
</span></span></code></pre></div></blockquote>
</details></p>

<hr>
<h1 id="17-tune-system-performance">17. Tune System Performance<a hidden class="anchor" aria-hidden="true" href="#17-tune-system-performance">#</a></h1>
<h2 id="adjust-tuning-profiles">Adjust Tuning Profiles<a hidden class="anchor" aria-hidden="true" href="#adjust-tuning-profiles">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>The <strong><code>tuned</code></strong> utility is used to statically and dynamically adjust a system’s configuration and optimize its performance based on different use cases, such as improving I/O performance, network throughput, and power saving.</p>
<ul>
<li><strong>Static tuning</strong> configures predefined <strong>kernel</strong> parameters in a profile that the <strong>tuned</strong> daemon applies at runtime. These kernel parameters are set for overall performance expectations, but they do not change in response to system activity.</li>
<li><strong>Dynamic tuning</strong> allows the <strong>tuned</strong> daemon to monitor system activity and adjust settings based on runtime behavior changes. By default, dynamic tuning is disabled. To enable it, simply change the <code>dynamic_tuning</code> variable in the <code>/etc/tuned/tuned-main.conf</code> configuration file. When enabled, <strong>tuned</strong> periodically monitors the system and adjusts the tuning settings according to the observed behavior. The frequency of updates can be controlled by modifying the <code>update_interval</code> variable in the same configuration file (in seconds between updates).</li>
</ul>
</blockquote>
<blockquote>
<p>The <strong><code>tuned</code></strong> utility provides several predefined profiles and allows for the creation of custom profiles to optimize a system’s behavior for specific workloads, such as servers, laptops, or high-performance environments. Below are some common commands for managing profiles:</p>
<ul>
<li><code>tuned-adm active</code>: Show the currently active profile.</li>
<li><code>tuned-adm list</code>: List all available profiles.</li>
<li><code>tuned-adm profile_info</code>: Show information about the active profile.</li>
<li><code>tuned-adm profile_info &lt;profile_name&gt;</code>: Show information about a specific profile.</li>
<li><code>tuned-adm profile &lt;profile_name&gt;</code>: Apply a specific tuning profile.</li>
<li><code>tuned-adm recommend</code>: Recommend an optimal profile based on the system&rsquo;s current usage.</li>
<li><code>tuned-adm off</code>: Disable <strong>tuned</strong> and stop dynamic tuning.</li>
</ul>
</blockquote>

</details></p>

<hr>
<h2 id="influence-process-scheduling">Influence Process Scheduling<a hidden class="anchor" aria-hidden="true" href="#influence-process-scheduling">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>In Linux, <strong>process priorities</strong> determine the order in which processes are scheduled to run on the CPU. The <strong>scheduling policy</strong> and <strong>nice value</strong> are key factors in how the operating system manages process execution.</p>
</blockquote>
<blockquote>
<p>Common scheduling policies include <strong>SCHED_NORMAL/SCHED_OTHER</strong>, <strong>SCHED_FIFO</strong>, and <strong>SCHED_RR</strong>.</p>
<ul>
<li><strong>SCHED_NORMAL/SCHED_OTHER (TS)</strong>: This is the default policy used for most processes, where tasks are scheduled based on their priority and time-sharing behavior.</li>
<li><strong>SCHED_FIFO (FF)</strong>: A real-time policy where processes are executed in a first-in, first-out manner. It gives higher priority to processes with lower numerical values, without time slicing.</li>
<li><strong>SCHED_RR (RR)</strong>: Each process gets a fixed time slice before the next one is executed, providing better responsiveness.</li>
</ul>
</blockquote>
<blockquote>
<p>The <strong>nice value</strong> (default is <code>0</code>) is an integer that can range from <code>-20</code> (highest priority, maps to a <code>0</code> in the <code>top</code> command) to <code>+19</code> (lowest priority, maps to a <code>39</code> in the <code>top</code> command). It allows users to influence the priority of a process, where a lower nice value gives the process higher priority in CPU scheduling. A higher nice value lowers the priority. <img loading="lazy" src="/img/linux/23-priorities-and-nice-values.png" alt="Priorities and Nice Value"  />
</p>
</blockquote>
<blockquote>
<p>To view the nice value of a running process, use the <code>ps</code> or <code>top</code> command. In <code>top</code>, the nice value is displayed under the <code>NI</code> column. Below is an example of using <code>ps</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ps -eo pid,comm,ni,cls --sort<span style="color:#f92672">=</span>-ni
</span></span></code></pre></div></blockquote>
<blockquote>
<p>By default, when a process starts from the command line, it inherits its nice value from the shell process (default value is <code>0</code>). To start a new process with a specific nice value, use the <code>nice</code> command. Here are some examples:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>nice sleep <span style="color:#ae81ff">60</span> &amp;         <span style="color:#75715e"># Start a new process with the default nice value (0)</span>
</span></span><span style="display:flex;"><span>nice -n <span style="color:#ae81ff">15</span> sleep <span style="color:#ae81ff">60</span> &amp;   <span style="color:#75715e"># Start a new process with a nice value of 15</span>
</span></span></code></pre></div></blockquote>
<blockquote>
<p>To adjust the nice value of an existing process, use the <code>renice</code> command. The <code>renice</code> command allows users to change the nice value of a running process. Unprivileged users may only increase the nice value (lower the priority), up to a maximum of <code>19</code>. Privileged users can both increase and decrease the nice value, with a minimum of <code>-20</code>. It is available to modify the nice value of a process from the interactive interface of <code>top</code> by pressing <code>r</code>, entering the process ID, and then specifying the new nice value. Below is an example of using <code>renice</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>renice -n <span style="color:#ae81ff">18</span> <span style="color:#ae81ff">1997</span>  <span style="color:#75715e"># Change the nice value of the process with PID 1997 to 18</span>
</span></span></code></pre></div></blockquote>

</details></p>

<hr>
<h1 id="18-manage-selinux-security">18. Manage SELinux Security<a hidden class="anchor" aria-hidden="true" href="#18-manage-selinux-security">#</a></h1>
<h2 id="change-the-selinux-environment-mode">Change the SELinux Environment Mode<a hidden class="anchor" aria-hidden="true" href="#change-the-selinux-environment-mode">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p><strong>SELinux (Security-Enhanced Linux)</strong> is a security module for the Linux kernel that provides a mechanism for enforcing access control security policies. It ensures resource access is controlled at a granular level. Unlike traditional file permissions, which control file access for specific users or groups, <strong>SELinux prevents even authorized users with access to a file from using it for unintended purposes</strong>. SELinux operates based on application-specific policies, such as the <strong>targeted policy</strong>, which precisely defines the allowed actions and access for each binary executable, configuration file, and data file used by an application.</p>
</blockquote>
<blockquote>
<p><strong>SELinux policies</strong> are security rules that define how specific processes can access files, directories, and ports. Each resource entity—such as a file, process, directory, or port—has a label called an <strong>SELinux context</strong>, which can be viewed using <code>-Z</code> option in many commands. Each SELinux context consists of four fields: <strong>user</strong>, <strong>role</strong>, <strong>type</strong>, and <strong>security level</strong>.</p>
<ul>
<li><strong>User</strong>: Specifies the SELinux user associated with the resource.</li>
<li><strong>Role</strong>: Defines the role assigned to the resource, determining the permitted actions within the system.</li>
<li><strong>Type</strong>: Specifies the type or category of the resource, which is used for defining access controls.</li>
<li><strong>Security level</strong>: Indicates the security classification or sensitivity level of the resource.</li>
</ul>
<p><img loading="lazy" src="/img/linux/24-selinux-file-context.png" alt="SELinux File Context"  />

For example, a web server process runs with the <code>httpd_t</code> type context. By default, files and directories in the <code>/var/www/html/</code> directory have the <code>httpd_sys_content_t</code> type context A web server can access the <code>httpd_sys_content_t</code> labeled files, but has no rules to allow access to files for other services, such as <code>mysqld_db_t</code> labeled files.</p>
</blockquote>
<blockquote>
<p>SELinux supports three operational modes: <strong>enforcing</strong>, <strong>permissive</strong>, and <strong>disabled</strong>.</p>
<ul>
<li><strong>Enforcing</strong>: SELinux is actively enforcing security policies. blocking any unauthorized access based on the policy.</li>
<li><strong>Permissive</strong>: SELinux logs any policy violations but does not block the access. This mode is helpful for testing and troubleshooting applications and rules.</li>
<li><strong>Disabled</strong>: SELinux is completely turned off. (Note that starting in Red Hat Enterprise Linux 9, SELinux can be fully disabled only by using the <code>selinux=0</code> kernel parameter at boot.)</li>
</ul>
</blockquote>
<blockquote>
<p>To change the SELinux mode, the <code>setenforce</code> command can be used, or the <code>/etc/selinux/config</code> file can be edited. It is recommended to reboot the system after making changes. To enable or disable SELinux, pass <code>selinux=1</code> or <code>selinux=0</code> respectively during system boot. Below are some examples of how to change the SELinux mode using commands:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>getenforce             <span style="color:#75715e"># Displays the current SELinux mode</span>
</span></span><span style="display:flex;"><span>setenforce enforcing   <span style="color:#75715e"># Sets SELinux to enforcing mode</span>
</span></span><span style="display:flex;"><span>setenforce <span style="color:#ae81ff">1</span>           <span style="color:#75715e"># Equivalent to setenforce enforcing</span>
</span></span></code></pre></div></blockquote>

</details></p>

<hr>
<h2 id="control-selinux-file-contexts">Control SELinux File Contexts<a hidden class="anchor" aria-hidden="true" href="#control-selinux-file-contexts">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>By default, SELinux labels files based on policies defined in the <code>/etc/selinux/targeted/contexts/files/</code> directory. When creating a new file, it inherits the same label as its parent directory unless a specific label is applied. If a file is copied, its context will change, as copying a file creates a new inode. However, moving a file does not change its context, because moving a file only updates the inode&rsquo;s filename without altering the inode itself. To preserve the context while copying, the <code>-p</code> or <code>--preserved=context</code> option can be used. For moving files, the <code>-Z</code> option is used to explicitly change the SELinux context. Below is an example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ls /tmp
</span></span><span style="display:flex;"><span><span style="color:#75715e"># system_u:object_r:tmp_t:s0 /tmp</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>touch /tmp/file1 /tmp/file2 /tmp/file3
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ls -Z /tmp/file*
</span></span><span style="display:flex;"><span><span style="color:#75715e"># unconfined_u:object_r:user_tmp_t:s0 /tmp/file1 </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># unconfined_u:object_r:user_tmp_t:s0 /tmp/file2</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># unconfined_u:object_r:user_tmp_t:s0 /tmp/file3</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ls -Zd ~/
</span></span><span style="display:flex;"><span><span style="color:#75715e"># unconfined_u:object_r:user_home_dir_t:s0 /home/signalyu999/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cp /tmp/file1 ~/
</span></span><span style="display:flex;"><span>mv /tmp/file2 ~/
</span></span><span style="display:flex;"><span>mv -Z /tmp/file3 ~/
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ls -Z ~/file*
</span></span><span style="display:flex;"><span><span style="color:#75715e"># unconfined_u:object_r:user_home_t:s0 /home/signalyu999/file1</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># unconfined_u:object_r:user_tmp_t:s0 /home/signalyu999/file2</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># unconfined_u:object_r:user_home_t:s0 /home/signalyu999/file3</span>
</span></span></code></pre></div></blockquote>
<blockquote>
<p>To change the SELinux context, three commands—<code>semanage fcontext</code>, <code>restorecon</code>, and <code>chcon</code>—are commonly used:</p>
<ul>
<li><strong><code>semanage fcontext</code></strong>: This command defines custom SELinux context rules for files or directories. It is often used to assign a specific context to files when they are created or moved to a particular location.</li>
<li><strong><code>restorecon</code></strong>: This command applies the SELinux context based on the rules defined by <code>semanage fcontext</code>. It restores the SELinux context of the file or directory to the predefined context.</li>
<li><strong><code>chcon</code></strong>: This command changes the SELinux context of a file or directory temporarily. Unlike <code>semanage</code>, which alters permanent rules, <code>chcon</code> applies the context change on a temporary basis and can be overwritten by <code>restorecon</code>.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># Define a custom SELinux context for files in /home/signalyu999/test</span>
</span></span><span style="display:flex;"><span>sudo semanage fcontext -a -t tmp_t <span style="color:#e6db74">&#34;/home/signalyu999/test(/.*)?&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>mkdir ~/test
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Before applying</span>
</span></span><span style="display:flex;"><span>ls -Zd ~/test
</span></span><span style="display:flex;"><span><span style="color:#75715e"># unconfined_u:object_r:user_home_t:s0 /home/signalyu999/test</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cd test/
</span></span><span style="display:flex;"><span>touch file1.txt
</span></span><span style="display:flex;"><span>ls -Z file1.txt 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># unconfined_u:object_r:user_home_t:s0 file1.txt</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Apply the custom SELinux context rule using restorecon</span>
</span></span><span style="display:flex;"><span>restorecon -v ~/test
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># After applying</span>
</span></span><span style="display:flex;"><span>ls -Zd ~/test
</span></span><span style="display:flex;"><span><span style="color:#75715e"># unconfined_u:object_r:tmp_t:s0 /home/signalyu999/test</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ls -Zd file1.txt 
</span></span><span style="display:flex;"><span>unconfined_u:object_r:user_home_t:s0 file1.txt
</span></span><span style="display:flex;"><span>touch file2.txt
</span></span><span style="display:flex;"><span>ls -Z file2.txt
</span></span><span style="display:flex;"><span><span style="color:#75715e"># unconfined_u:object_r:user_tmp_t:s0 file2.txt</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Temporarily change the SELinux context using chcon</span>
</span></span><span style="display:flex;"><span>sudo chcon -t user_home_t ~/test
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ls -Zd ~/test
</span></span><span style="display:flex;"><span><span style="color:#75715e"># unconfined_u:object_r:user_home_t:s0 /home/signalyu999/test</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>touch file3.txt
</span></span><span style="display:flex;"><span>ls -Z file3.txt 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># unconfined_u:object_r:user_home_t:s0 file3.txt</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Restore the original SELinux context with restorecon</span>
</span></span><span style="display:flex;"><span>restorecon -v ~/test
</span></span><span style="display:flex;"><span>ls -Zd ~/test
</span></span><span style="display:flex;"><span><span style="color:#75715e"># unconfined_u:object_r:tmp_t:s0 /home/signalyu999/test</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ls -Z file*
</span></span><span style="display:flex;"><span><span style="color:#75715e"># unconfined_u:object_r:user_home_t:s0 file1.txt  </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># unconfined_u:object_r:user_home_t:s0 file3.txt</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># unconfined_u:object_r:user_tmp_t:s0 file2.txt</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sudo semanage fcontext -l | grep <span style="color:#e6db74">&#34;/home/signalyu999&#34;</span>
</span></span><span style="display:flex;"><span>/home/signalyu999/test<span style="color:#f92672">(</span>/.*<span style="color:#f92672">)</span>?                       all files          system_u:object_r:tmp_t:s0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>restorecon -Rv ~/test
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Relabeled /home/signalyu999/test/file1.txt from unconfined_u:object_r:user_home_t:s0 to unconfined_u:object_r:tmp_t:s0</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Relabeled /home/signalyu999/test/file2.txt from unconfined_u:object_r:user_tmp_t:s0 to unconfined_u:object_r:tmp_t:s0</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Relabeled /home/signalyu999/test/file3.txt from unconfined_u:object_r:user_home_t:s0 to unconfined_u:object_r:tmp_t:s0</span>
</span></span><span style="display:flex;"><span>ls -Z file*
</span></span><span style="display:flex;"><span><span style="color:#75715e"># unconfined_u:object_r:tmp_t:s0 file1.txt</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># unconfined_u:object_r:tmp_t:s0 file3.txt</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># unconfined_u:object_r:tmp_t:s0 file2.txt</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>rm -r ~/test 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Delete the custom context rule</span>
</span></span><span style="display:flex;"><span>sudo semanage fcontext -d <span style="color:#e6db74">&#34;/home/signalyu999/test(/.*)?&#34;</span>
</span></span></code></pre></div></blockquote>

</details></p>

<hr>
<h2 id="adjust-selinux-with-booleans">Adjust SELinux with Booleans<a hidden class="anchor" aria-hidden="true" href="#adjust-selinux-with-booleans">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p><strong>SELinux Booleans</strong> are runtime tunable parameters that control specific aspects of SELinux behavior. They <strong>allow administrators to enable or disable certain security features without altering the underlying SELinux policies</strong>. Some common SELinux booleans include:</p>
<ul>
<li><strong><code>httpd_can_network_connect</code></strong>: Enable it to allow Apache to access external resources over the network.</li>
<li><strong><code>httpd_enable_homedirs</code></strong>: Enable it to allow Apache to serve content from user home directories.</li>
<li><strong><code>allow_execmem</code></strong>: Enable it to allow executable memory mapping.</li>
<li><strong><code>selinuxuser_execheap</code></strong>: Enable it to allow SELinux users to execute files with low-security contexts.</li>
<li><strong><code>samba_enable_home_dirs</code></strong>: Enable it to allow Samba to share user home directories.</li>
</ul>
</blockquote>
<blockquote>
<p>To manage SELinux booleans, the following commands are commonly used: <code>getsebool</code>, <code>setsebool</code>, and <code>semanage boolean</code>. Below is an example of how to check and change SELinux boolean values:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># List all SELinux booleans related to &#34;httpd_enable_&#34;</span>
</span></span><span style="display:flex;"><span>getsebool -a | grep <span style="color:#e6db74">&#34;httpd_enable_&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># httpd_enable_cgi --&gt; on</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># httpd_enable_ftp_server --&gt; off</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># httpd_enable_homedirs --&gt; off</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Check the current state of a specific boolean</span>
</span></span><span style="display:flex;"><span>getsebool httpd_enable_homedirs
</span></span><span style="display:flex;"><span><span style="color:#75715e"># httpd_enable_homedirs --&gt; off</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Use semanage to view the details of a specific boolean</span>
</span></span><span style="display:flex;"><span>sudo semanage boolean -l | grep httpd_enable_homedirs
</span></span><span style="display:flex;"><span><span style="color:#75715e"># httpd_enable_homedirs          (off, off)  Allow httpd to enable homedirs</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Change the value of a boolean (without the -P flag, the changes will only persist until the system is rebooted)</span>
</span></span><span style="display:flex;"><span>sudo setsebool httpd_enable_homedirs on
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Use semanage again to confirm the change</span>
</span></span><span style="display:flex;"><span>sudo semanage boolean -l | grep httpd_enable_homedirs
</span></span><span style="display:flex;"><span><span style="color:#75715e"># httpd_enable_homedirs          (on, off)  Allow httpd to enable homedirs</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Make the change persistent across reboots</span>
</span></span><span style="display:flex;"><span>sudo setsebool -P httpd_enable_homedirs on
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Check the persistent state of all SELinux booleans</span>
</span></span><span style="display:flex;"><span>sudo semanage boolean -l -C
</span></span><span style="display:flex;"><span><span style="color:#75715e"># SELinux boolean                State  Default Description</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># httpd_enable_homedirs          (on, on)  Allow httpd to enable homedirs</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sudo setsebool -P httpd_enable_homedirs off
</span></span></code></pre></div></blockquote>

</details></p>

<hr>
<h2 id="investigate-and-resolve-selinux-issues">Investigate and Resolve SELinux Issues<a hidden class="anchor" aria-hidden="true" href="#investigate-and-resolve-selinux-issues">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>When SELinux denies an action, it logs an <strong>AVC (Access Vector Cache)</strong> message to the <code>/var/log/audit/audit.log</code> file. Additionally, a summary of the AVC event is sent to <code>/var/log/messages</code>. These logs provide valuable information to diagnose SELinux-related issues. Here are some common steps to troubleshoot SELinux issues:</p>
<ol>
<li><strong>View SELinux Logs</strong>: The first step in troubleshooting SELinux issues is to check the SELinux logs for AVC denials. This can be done using the following command:</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo grep AVC /var/log/audit/audit.log | audit2why
</span></span></code></pre></div><ol start="2">
<li><strong>Check and Set SELinux Booleans</strong>: The second step is to permit SELinux behavior by setting SELinux Booleans. To list the current SELinux booleans and search for a specific one (e.g., related to HTTPD), use the following command:</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>getsebool -a | grep httpd
</span></span></code></pre></div><p>If a boolean needs to be modified, for example, enabling Apache to read user content, use the <code>setsebool</code> command with the <code>-P</code> option to make the change persistent:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo setsebool -P httpd_read_user_content <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><ol start="3">
<li><strong>Check File and Directory Contexts</strong>: The third step is to check the context of a file or directory as incorrect or missing contexts can result in access denials. This can be done using the following command:</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ls -Z /path/to/file
</span></span></code></pre></div><p>If the context is incorrect, it can be fixed using the <code>semanage fcontext</code> command to define the correct context or <code>restorecon</code> to apply the default context based on the current policies:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo restorecon -v /path/to/file
</span></span></code></pre></div></blockquote>
<blockquote>
<p>Below is a simple example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl start httpd
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;&lt;h1&gt;HELLO&lt;/h1&gt;&#34;</span> &gt;&gt; ~/index.html
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sudo mv ~/index.html /var/www/html/
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>curl http://localhost/index.html
</span></span><span style="display:flex;"><span><span style="color:#75715e"># &lt;!DOCTYPE HTML PUBLIC &#34;-//IETF//DTD HTML 2.0//EN&#34;&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># &lt;html&gt;&lt;head&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># &lt;title&gt;404 Not Found&lt;/title&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># &lt;/head&gt;&lt;body&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># &lt;h1&gt;Not Found&lt;/h1&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># &lt;p&gt;The requested URL was not found on this server.&lt;/p&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># &lt;/body&gt;&lt;/html&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Check the SELinux audit logs for AVC denials related to the &#34;httpd&#34; process</span>
</span></span><span style="display:flex;"><span>sudo grep AVC /var/log/audit/audit.log | audit2why
</span></span><span style="display:flex;"><span><span style="color:#75715e"># type=AVC msg=audit(1746191992.345:5086): avc:  denied  { read } for  pid=84172 comm=&#34;httpd&#34; name=&#34;index.html&#34; dev=&#34;dm-0&#34; ino=34324608 scontext=system_u:system_r:httpd_t:s0 tcontext=unconfined_u:object_r:user_home_t:s0 tclass=file permissive=0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Was caused by:</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># The boolean httpd_read_user_content was set incorrectly. </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Description:</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Allow httpd to read user content</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Allow access by executing:</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># # setsebool -P httpd_read_user_content 1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sudo setsebool -P httpd_read_user_content <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>curl http://localhost/index.html
</span></span><span style="display:flex;"><span><span style="color:#75715e"># &lt;h1&gt;HELLO&lt;/h1&gt; </span>
</span></span></code></pre></div></blockquote>

</details></p>

<hr>
<h1 id="19-manage-basic-storage">19. Manage Basic Storage<a hidden class="anchor" aria-hidden="true" href="#19-manage-basic-storage">#</a></h1>
<h2 id="add-partitions-file-systems-and-persistent-mounts">Add Partitions, File Systems, and Persistent Mounts<a hidden class="anchor" aria-hidden="true" href="#add-partitions-file-systems-and-persistent-mounts">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p><strong>Disk partitioning</strong> is the process of dividing a computer&rsquo;s storage device into separate, independent sections called partitions. Each partition acts like an individual disk, allowing it to be formatted with a specific file system and used for various purposes, such as system files, user data, or backups. There are two main disk partitioning schemes: <strong>MBR (Master Boot Record)</strong> and <strong>GPT (GUID Partition Table)</strong>.</p>
<ul>
<li>
<p><strong>MBR (Master Boot Record)</strong>: MBR is an older partitioning scheme that is commonly used in BIOS-based systems. It stores partitioning information in the first sector of the disk, known as the master boot record. This sector contains both the bootloader (a small program that helps the system load the operating system) and the partition table, which holds the details about each partition. MBR supports a maximum of four primary partitions and is limited to disks up to 2 TB in size. <img loading="lazy" src="/img/linux/25-mbr-partition-scheme.png" alt="MBR Partition Scheme"  />
</p>
</li>
<li>
<p><strong>GPT (GUID Partition Table)</strong>: GPT is a newer partitioning scheme designed as part of the UEFI (Unified Extensible Firmware Interface) standard. GPT overcomes the limitations of MBR by using two partition tables: a primary GPT header located at the beginning of the disk and a backup GPT header stored at the end of the disk. This redundancy ensures protection in case the primary GPT header is damaged. GPT supports up to 128 partitions by default and can handle disks as large as 9.4 ZB. <img loading="lazy" src="/img/linux/26-gpt-partition-scheme.png" alt="GPT Partition Table"  />
</p>
</li>
</ul>
</blockquote>
<blockquote>
<p>Below is an real-world example of disk partitioning:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 1. Shutdown the VMware machine and add the new disk device.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 2. Use parted to manage the partitions on /dev/sdb (the new disk).</span>
</span></span><span style="display:flex;"><span>sudo parted /dev/sdb
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 3. Create a new partition table (GPT or MSDOS). GPT is recommended for modern systems.</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>parted<span style="color:#f92672">)</span> mklabel gpt  <span style="color:#75715e"># Or use &#34;msdos&#34; for older systems.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 4. Create a new primary partition</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>parted<span style="color:#f92672">)</span> mkpart 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># partition name: app-data</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># file system type: ext4</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># start: 0%</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># end: 50%</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 5. Print the partition information to verify the partition layout.</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>parted<span style="color:#f92672">)</span> print
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 6. Ensure the system create the associated device file in the /dev directory</span>
</span></span><span style="display:flex;"><span>udevadm settle
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 7. Format the partition</span>
</span></span><span style="display:flex;"><span>sudo mkfs.ext4 /dev/sdb1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 8. Create a mounting point and mount the newly created partition</span>
</span></span><span style="display:flex;"><span>sudo mkdir /mnt/mydata
</span></span><span style="display:flex;"><span>sudo mount /dev/sdb1 /mnt/mydata
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 9. Use blkid to get the UUID of the new partition.</span>
</span></span><span style="display:flex;"><span>sudo blkid /dev/sdb1
</span></span><span style="display:flex;"><span><span style="color:#75715e"># /dev/sdb1: UUID=&#34;98c3694b-5a44-4729-bc14-2987562754cd&#34; TYPE=&#34;ext4&#34; PARTLABEL=&#34;app-data&#34; PARTUUID=&#34;4c737002-504a-4206-adda-737270fc083e&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 10. Edit the /etc/fstab </span>
</span></span><span style="display:flex;"><span>sudo vim /etc/fstab
</span></span><span style="display:flex;"><span><span style="color:#75715e"># UUID=98c3694b-5a44-4729-bc14-2987562754cd /mnt/mydata ext4 defaults 0 2</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># UUID: Universally Unique Identifier</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># defaults: include auto mount option</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># /mnt/mydata: mounting point</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ext4: file system</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 0: dump (back up option), 0 = no backup (default), 1 = enable backup</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 0: fsck (file system checking), 0 = do not check, 1 = check first (usually for root), 2 = check after root (for other file systems)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 11. After editing /etc/fstab, mount all filesystems as specified in /etc/fstab.</span>
</span></span><span style="display:flex;"><span>sudo mount -a
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 12. Use the df command to check that the partition is correctly mounted.</span>
</span></span><span style="display:flex;"><span>df -h
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 13. Register new configuraation</span>
</span></span><span style="display:flex;"><span>sudo systemctl daemon-reload
</span></span></code></pre></div></blockquote>
<blockquote>
<p>Below is a real-world example of removing a partition:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 1. Ensure the partition is not mounted</span>
</span></span><span style="display:flex;"><span>sudo umount /dev/sdb1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 2. Check if it is mounted</span>
</span></span><span style="display:flex;"><span>df -h
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 3. Delete the partition in parted</span>
</span></span><span style="display:flex;"><span>parted /dev/sdb
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>parted<span style="color:#f92672">)</span> print
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>parted<span style="color:#f92672">)</span> rm <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 4. Edit the /etc/fstab file</span>
</span></span></code></pre></div></blockquote>

</details></p>

<hr>
<h2 id="manage-swap-space">Manage Swap Space<a hidden class="anchor" aria-hidden="true" href="#manage-swap-space">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p><strong>Swap space</strong> is a portion of the disk that is used as virtual memory when the system&rsquo;s physical RAM is full. It allows the operating system to move inactive pages from RAM to disk, free up memory for active processes.</p>
</blockquote>
<blockquote>
<p>When creating swap partitions, administrators should size the swap space based on the memory workload on the system. Below is a practical guide line:</p>
<table>
<thead>
<tr>
<th>RAM Size</th>
<th>Swap (No Hibernation)</th>
<th>Swap (With Hibernation)</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt; 2 GB</td>
<td>Twice the RAM</td>
<td>Three times the RAM</td>
</tr>
<tr>
<td>2–8 GB</td>
<td>Same as RAM</td>
<td>Twice the RAM</td>
</tr>
<tr>
<td>8–64 GB</td>
<td>At least 4 GB</td>
<td>1.5 times the RAM</td>
</tr>
<tr>
<td>&gt; 64 GB</td>
<td>At least 4 GB</td>
<td>Hibernation is not recommended</td>
</tr>
</tbody>
</table>
</blockquote>
<blockquote>
<p>Below is an real-world example of creating swap partition:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 1. Open parted to manage the new disk</span>
</span></span><span style="display:flex;"><span>parted /dev/sdc
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 2. Create a GPT partition table</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>parted<span style="color:#f92672">)</span> mklabel gpt
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 3. Create a new partition</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>parted<span style="color:#f92672">)</span> mkpart 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># partition name: swap1</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># file system type: linux-swap</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># start: 0%</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># end: 100%</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 4. Ensure the system create the associated device file in the /dev directory</span>
</span></span><span style="display:flex;"><span>udevadm settle
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 5. Format the new partition as swap space</span>
</span></span><span style="display:flex;"><span>mkswap /dev/sdc1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 6. Activate the swap space immediately</span>
</span></span><span style="display:flex;"><span>swapon /dev/sdc1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 7. Get the UUID of the swap partition</span>
</span></span><span style="display:flex;"><span>blkid /dev/sdc1
</span></span><span style="display:flex;"><span><span style="color:#75715e"># /dev/sdc1: UUID=&#34;e2d9fbc3-65dc-4427-8051-c07dcc043866&#34; TYPE=&#34;swap&#34; PARTLABEL=&#34;swap1&#34; PARTUUID=&#34;4f0f1298-cf05-4440-856f-534d69aeeccc&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 8. Edit fstab to enable swap at boot</span>
</span></span><span style="display:flex;"><span>sudo vim /etc/fstab
</span></span><span style="display:flex;"><span><span style="color:#75715e"># UUID=e2d9fbc3-65dc-4427-8051-c07dcc043866 none swap defaults 0 0</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Add the following line for default swap:</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># UUID=e2d9fbc3-65dc-4427-8051-c07dcc043866 none swap defaults 0 0</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Or set a custom priority:</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># UUID=e2d9fbc3-65dc-4427-8051-c07dcc043866 none swap pri=10 0 0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 9. Reload systemd config (optional if fstab changed)</span>
</span></span><span style="display:flex;"><span>sudo systemctl daemon-reload
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 10. Display swap space priorities</span>
</span></span><span style="display:flex;"><span>swapon --show
</span></span></code></pre></div></blockquote>
<blockquote>
<p>Below is a real-world example of removing a swap partition:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 1. Turn off swap</span>
</span></span><span style="display:flex;"><span>sudo swapoff /dev/sdc1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 2. Verify whether a swap is off</span>
</span></span><span style="display:flex;"><span>swapon --summary
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 3. Remove the partition in parted</span>
</span></span><span style="display:flex;"><span>parted /dev/sdc1
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>parted<span style="color:#f92672">)</span> print
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>parted<span style="color:#f92672">)</span> rm <span style="color:#f92672">[</span>number<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 4. Edit the /etc/fstab file</span>
</span></span></code></pre></div></blockquote>

</details></p>

<hr>
<h1 id="20-manage-storage-stack">20. Manage Storage Stack<a hidden class="anchor" aria-hidden="true" href="#20-manage-storage-stack">#</a></h1>
<h2 id="create-and-extend-logical-volumes">Create and Extend Logical Volumes<a hidden class="anchor" aria-hidden="true" href="#create-and-extend-logical-volumes">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p><strong>Logical Volume Manager (LVM)</strong> is a system for managing disk storage in Linux that adds a layer of abstraction between physical storage devices and file systems. It allows multiple physical volumes to be combined into a single volume group, enabling more flexible and efficient storage allocation. The key components of <strong>LVM</strong> include: <strong>Physical Devices (PD)</strong>, <strong>Physical Volumes (PV)</strong>, <strong>Volume Groups (VG)</strong>, and <strong>Logical Volumes (LV)</strong>.</p>
<ul>
<li>📦 <strong>Physical Devices</strong>: These are actual hardware devices or virtual disks (e.g., <code>/dev/sda</code>, <code>/dev/sdb</code>).</li>
<li>💽 <strong>Physical Volumes (PV)</strong>: Physical devices that have been initialized for LVM using <code>pvcreate</code>.</li>
<li>🧱 <strong>Volume Groups (VG)</strong>: Collections of one or more physical volumes, combined into a single logical storage pool. Created using <code>vgcreate</code>.</li>
<li>📂 <strong>Logical Volumes (LV)</strong>: Flexible storage units carved out from volume groups, created using <code>lvcreate</code>.
<img loading="lazy" src="/img/linux/27-logical-volume-manager-workflow.png" alt="Logical Volume Manager Workflow"  />
</li>
</ul>
</blockquote>
<blockquote>
<p>Creating a logical volume involves creating physical device partitions, physical volumes, and volume groups. Below is an example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 1. Prepare physical devices</span>
</span></span><span style="display:flex;"><span>parted /dev/sdb
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>parted<span style="color:#f92672">)</span> mklabel gpt
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>parted<span style="color:#f92672">)</span> mkpart primary 1MiB 50%
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>parted<span style="color:#f92672">)</span> set <span style="color:#ae81ff">1</span> lvm on
</span></span><span style="display:flex;"><span>parted /dev/sdc 
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>parted<span style="color:#f92672">)</span> mklabel gpt
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>parted<span style="color:#f92672">)</span> mkpart primary 50% 100%
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>parted<span style="color:#f92672">)</span> set <span style="color:#ae81ff">1</span> lvm on
</span></span><span style="display:flex;"><span>udevadm settle
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 2. Create Physical volumes</span>
</span></span><span style="display:flex;"><span>pvcreate /dev/sdb1 /dev/sdc1
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Physical volume &#34;/dev/sdb1&#34; successfully created.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Physical volume &#34;/dev/sdc1&#34; successfully created.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 3. Create volume groups</span>
</span></span><span style="display:flex;"><span>vgcreate vg01 /dev/sdb1 /dev/sdc1
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Volume group &#34;vg01&#34; successfully created</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 4. Create a logical volume</span>
</span></span><span style="display:flex;"><span>lvcreate -n lv01 -L 100G vg01
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Logical volume &#34;lv01&#34; created.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 5. Format the logical volume</span>
</span></span><span style="display:flex;"><span>mkfs.ext4 /dev/vg01/lv01
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 6. Mount the logical volume to /mnt/app-data</span>
</span></span><span style="display:flex;"><span>mount /dev/vg01/lv01 /mnt/app-data
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 7. Verify whether if the logical volume is mounted</span>
</span></span><span style="display:flex;"><span>df -h
</span></span></code></pre></div></blockquote>

</details></p>



  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://signalyu.github.io/tags/engineering--technology/">Engineering &amp; Technology</a></li>
      <li><a href="https://signalyu.github.io/tags/computer-science/">Computer Science</a></li>
      <li><a href="https://signalyu.github.io/tags/linux/">Linux</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/system-design/1-system-design/">
    <span class="title">« PREV</span>
    
    <br>
    <span>System Design</span>
  </a>
  <a class="next" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/devops/docker/1-docker/">
    <span class="title">NEXT »</span>
    
    <br>
    <span>Docker</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://signalyu.github.io/">Signal&#39;s Blog</a></span> · 
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>

</body>
</html>
