<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Red Hat Enterprise Linux | Signal&#39;s Blog</title>
<meta name="keywords" content="Engineering &amp; Technology, Computer Science, Linux">
<meta name="description" content="1. Introduction to Linux SHOW CONTENTS Open Source refers to software whose source code is freely available to the public for anyone to view, modify, and distribute. It encourages coolaboration, transparency, and community-driven improvements.
Open Source Licenses are legal agreements that define how software can be used, modified, and distributed. There are two main types of Copyleft and Permissive.
Copyleft licenses require that any modified versions of the software also be open source, under the same terms as the original.">
<meta name="author" content="Signal Yu">
<link rel="canonical" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/linux/1-red-hat-enterprise-linux/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5a0ace7f2dc73037e40ceea0eb0d119b5d798dba2da38d9129982a8cf9fa07a5.css" integrity="sha256-WgrOfy3HMDfkDO6g6w0Rm115jboto42RKZgqjPn6B6U=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://signalyu.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://signalyu.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://signalyu.github.io/favicon-32x32">
<link rel="apple-touch-icon" href="https://signalyu.github.io/apple-touch-icon">
<link rel="mask-icon" href="https://signalyu.github.io/favicon.io">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/linux/1-red-hat-enterprise-linux/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
  

<meta property="og:title" content="Red Hat Enterprise Linux" />
<meta property="og:description" content="1. Introduction to Linux SHOW CONTENTS Open Source refers to software whose source code is freely available to the public for anyone to view, modify, and distribute. It encourages coolaboration, transparency, and community-driven improvements.
Open Source Licenses are legal agreements that define how software can be used, modified, and distributed. There are two main types of Copyleft and Permissive.
Copyleft licenses require that any modified versions of the software also be open source, under the same terms as the original." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/linux/1-red-hat-enterprise-linux/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2025-04-15T11:03:32+08:00" />
<meta property="article:modified_time" content="2025-04-15T11:03:32+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Red Hat Enterprise Linux"/>
<meta name="twitter:description" content="1. Introduction to Linux SHOW CONTENTS Open Source refers to software whose source code is freely available to the public for anyone to view, modify, and distribute. It encourages coolaboration, transparency, and community-driven improvements.
Open Source Licenses are legal agreements that define how software can be used, modified, and distributed. There are two main types of Copyleft and Permissive.
Copyleft licenses require that any modified versions of the software also be open source, under the same terms as the original."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://signalyu.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Red Hat Enterprise Linux",
      "item": "https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/linux/1-red-hat-enterprise-linux/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Red Hat Enterprise Linux",
  "name": "Red Hat Enterprise Linux",
  "description": "1. Introduction to Linux SHOW CONTENTS Open Source refers to software whose source code is freely available to the public for anyone to view, modify, and distribute. It encourages coolaboration, transparency, and community-driven improvements.\nOpen Source Licenses are legal agreements that define how software can be used, modified, and distributed. There are two main types of Copyleft and Permissive.\nCopyleft licenses require that any modified versions of the software also be open source, under the same terms as the original.",
  "keywords": [
    "Engineering \u0026 Technology", "Computer Science", "Linux"
  ],
  "articleBody": "1. Introduction to Linux SHOW CONTENTS Open Source refers to software whose source code is freely available to the public for anyone to view, modify, and distribute. It encourages coolaboration, transparency, and community-driven improvements.\nOpen Source Licenses are legal agreements that define how software can be used, modified, and distributed. There are two main types of Copyleft and Permissive.\nCopyleft licenses require that any modified versions of the software also be open source, under the same terms as the original. Popular examples include the GPL (GNU General Public License) and AGPL (Affero GPL). Permissive licenses are more relaxed, allowing users to modify, distribute, and even close-source the software if desired. Well-known examples of permissive licenses include the MIT License, Apache License 2.0, and BSD License (Berkeley Software Distribution). The differences between Fedora, CentOS Stream, and Red Hat Enterprise Linux (RHEL) are primarily based on their release cycles, stability, and target audiences. Fedora is a cutting-edge distribution that always features the latest software and technologies, making it ideal for developers and enthusiasts who want to experience the newest features. CentOS Stream serves as a rolling preview of future RHEL versions, acting as a middle ground between Fedora and RHEL. Finally, RHEL is the most stable and secure option, designed for enterprise environments that require long-term support and paid services. RHEL is commonly used in production systems that demand reliability and robust commercial support. 2. Manage Files From the Command Line Linux File System Hierarchy SHOW CONTENTS The Linux File System Hierarchy defines the directory structure and directory contents in Linux-based operating systems. It stores all files which organized into a single incerted tree structure.\nHere’s an overview of the key directories in the Linux file system hierarchy:\nLocation Purpose /boot Files to start the boot process. /dev Special device files that the system uses to access hardware. /etc System-specific configuration files. /home Home directory, where regular users store their data and configuration files. /root Home directory for the administrative superuser, root. /run Runtime data for processes that started since the last boot. This data includes process ID files and lock files. The contents of this directory are re-created on reboot. This directory consolidates the /var/run and /var/lock directories from earlier versions of Red Hat Enterprise Linux. /tmp A world-writable space for temporary files. Files that are not accessed, changed, or modified for 10 days are deleted from this directory automatically. The /var/tmp directory is also a temporary directory, in which files that are not accessed, changed, or modified in more than 30 days are deleted automatically. /usr Installed software, shared libraries, including files, and read-only program data. Significant subdirectories include: /usr/bin: User commands; /usr/sbin: System administration commands; /usr/local: Locally customized software /var System-specific variable data that should persist between boots. Files that dynamically change, such as databases, cache directories, log files, printer-spooled documents, and website content, might be found under /var. static, dynamic(variable), persistent, runtime: Static content remains unchanged until explicitly edited or reconfigured; Dynamic (Variable) content might be modified or appended by active processes; Persistent content remains after a reboot, such as configuration settings; Runtime content from a process or from the system is deleted on reboot.\nCommon Directory and File Management Commands SHOW CONTENTS pwd: Prints the current working directory (path) to the terminal. cd: Changes the current working directory to the home directory of the current user. cd -: Changes the directory to the previous directory. cd ../..: Moves up two levels in the directory structure. cd ..: Moves up one level in the directory structure (to the parent directory). ls -l: Lists files and directories in the current directory in long format, showing details such as permissions, owner, group, size, and last modification time. ls -al: Lists all files (including hidden files) in the current directory in long format. ls -lR: Lists files and directories recursively in the current directory and all its subdirectories, in long format. ls -l file*.txt: Lists files that start with the word file and end with .txt. cp hello.py HELLO.py: Copies the file hello.py to HELLO.py. The original file remains unchanged. mv -v hello.py HELLO.py: Moves (or renames) the file hello.py to HELLO.py. The -v option prints verbose output showing the operation. rm HELLO.py: Removes (deletes) the file HELLO.py. Be careful, as this is a permanent deletion. mkdir HOME: Creates a new directory named HOME in the current directory. rmdir HOME: Removes an empty directory named HOME. If the directory contains any files, it cannot be removed with rmdir. Create Links Between Files SHOW CONTENTS In Linux, there are two types of links that can be created for files: hard links and soft links. A hard link is a direct reference to the data of a file. It creates another name for an existing file, pointing directly to the file’s inode (the underlying data structure that holds the file’s metadata and data.) A soft link, on the other hand, is a reference to the original file’s path, rather than directly pointing to the file’s inode.\nHard links that reference the same file share the same inode struct with the link count, access permissions, user and group ownership, time stamps, and file content. Therefore, when any of this information is changed for one hard link, the changes are reflected in all other hard links pointing to the same file.\nCommands for creating links between files are as follows:\nln file.txt file_link.txt # Create a hard link ls -i file.txt file_link.txt # Show the inode number for both files ln -s file.txt file_soft.txt # Create a soft link ls -l file_soft.txt # Check if the soft link work (file_soft.txt -\u003e file.txt) 3 Get Help Using man Command SHOW CONTENTS The man command in Linux is used to display the manual pages for various commands, programs, system calls, etc. The man pages are divided into 9 sections: executable programs or shell commands, system calls, library calls, special files, file formats and conventions, games, miscellaneous, system administration commands, and kernel routines (non standard).\nExecutable programs or shell commands: Commands executed by regular users (e.g., ls, cp). System calls: Functions that the kernel provides for programs to interact with the system (e.g., open, read). Library calls: Functions that can be used in programs written in C and other languages (e.g., printf). Special files: Usually found in /dev(e.g., /dev/sda). File formats and conventions: Descriptions of file formats (e.g., /etc/passwd). Games: Information about games available on the system. Miscellaneous: including macro packages and conventions (e.g. man(7), groff(7)). System administration commands: Commands for system administrators (e.g., useradd, systemctl). Kernel routines: Non standard The most common way to use man command including:\nman open or man open.3: Displays the manual page for the open command. (open exists in Section 2 (System Calls) and Section 3 (Library Functions), man open display the System Call documentation while man open.3 display the Library Function manual.) man -f ls: Displays a brief description of the ls command, equivalent to whatis ls. man -k ls: Searches the manual page database for the term ls, equivalent to apropos ls. Note that before running man -f ls or man -k ls, it is important to ensure that the mandb database has been built. This can be done by running sudo mandb.\n4. I/O Redirection \u0026 Pipelines I/O Redirection SHOW CONTENTS A process reads input and writes output. By default, it reads input from the keyboard and sends its output to the terminal window. Processes use numbered channels called file descriptors to manage input and output. Every process starts with at least three file descriptors:\nStandard Input (channel 0): Reads input from the keyboard. Standard Output (channel 1): Sends normal output to the terminal. Standard Error (channel 2): Sends error messages to the terminal. Number Channel Name Description Default Connection Usage 0 stdin Standard input Keyboard Read only 1 stdout Standard output Terminal Write only 2 stderr Standard error Terminal Write only 3+ filename Other files None Read/write or both By default, a process takes input from the keyboard and displays its output on the terminal. Redirection refers to changing the default input or output of a command. The following table summarizes the different types of redirection available:\nUsage Explanation Vitulization \u003e file Redirect stdout to overwrite a file \u003e\u003e file Redirect stdout ot append to a file 2\u003e file Redirect stderr to overwrite a file 2\u003e /dev/null Discard stderr error messages by redirecting them to /dev/null \u003e file 2\u003e\u00261 or \u0026\u003e file Redirect stdout and stderr to overwrite the same file \u003e\u003e file 2\u003e\u00261 or \u0026\u003e\u003e file Redirect stdout and stderr to append the same file sort \u003c file \u003e sorted_file Redirects the stdin to a file and redirect stdout to overwrite a different file It is important to note that the order of redirection operations is crucial. For example:\nThe command \u003e output.log 2\u003e\u00261 redirects both standard output and standard error messages to the same file, output.log. On the other hand, 2\u003e\u00261 \u003e output.log redirects standard error messages to the default standard output (the terminal), and then redirects only the standard output to output.log. Additionally, the command \u003e output.log 2\u003e\u00261 can be shortened to \u0026\u003e output.log. However, it is important to note that \u0026\u003e is not standardized and may not be implemented in all shells.\nPipelines SHOW CONTENTS A pipeline is a sequence of one or more commands that are connected by the vertical bar character (|). In a pipeline, the standard output of one command is passed directly as the standard input to the next command.\nThe main difference between pipelines and I/O redirection lies in how they handle data. I/O redirection refers to sending standard output to a file or receiving standard input from a file. In contrast, pipelines are used to send the standard output of one process directly to the standard input of another process.\nThe following are some commonly used pipeline examples:\ncat file.txt | grep \"pattern\": Searches for patterns within text. cat file.txt | sort: Sorts the lines of text in a specified order (alphabetically by default). cat file.txt | wc -l: Counts the number of lines in a file. cat file.txt | tee output.txt: Outputs the content of a file to both the terminal and a specified file. find / -name \"passwd\" 2\u003e\u00261 | less: find / -name \"passwd\": Searches for a file or directory named passwd starting from the root directory (/). 2\u003e\u00261: Redirects standard error (file descriptor 2) to standard output (file descriptor 1). This ensures that any error messages, such as permission denials, are also passed along with the normal output. | less: Pipes the combined output (standard output and error messages) into the less command. 5. Bash Environment Configuration SHOW CONTENTS When Bash starts, several initialization scripts are executed to configure the shell environment, with the specific scripts depending on whether the shell is interactive, non-interactive, login, or non-login. An interactive shell allows users to enter commands directly, while a non-interactive shell runs in the background. A login shell is invoked when a user logs in via terminal or SSH, while non-login shell is opened from an existing session, like when launching a terminal in a GUI.\nFor interactive login shells, the environment is configured by the /etc/profile and ~/.bash_profile files, which also source /etc/bashrc and ~/.bashrc respectively. For interactive non-login shells, only /etc/bashrc and ~/.bashrc are used. System-wide configurations are stored in /etc/profile and /etc/bashrc, while user-specific configurations are in ~/.bash_profile and ~/.bashrc.\n6. Manage Local Users and Groups User \u0026 Group Concepts SHOW CONTENTS A user is an individual account created on a Linux system that can own files, execute commands, and interact with the system. User details are typically stored in the /etc/passwd file, where each line represents a user account with specific information like username, UID, home directory, and default shell.\nIn Linux, there are three primary types of users:\nSuperuser: The superuser account is responsible for administering the system. Its name is root with a UID of 0. It has full system access. System User: These accounts are used by processes or daemons that provide system services (e.g., web servers, databases). System users are non-privileged and are created to isolate and secure the services they support. Regular User: The regular user is the typical user who do not have root priviledges and have limited access to the system. A group is a collection of users that can be assigned a common set of permissions. The group details are typically stored in etc/group, which contains information about group names, GIDs, and the list of users that belong to each group.\nIn Linux, there two main types of group: the primary group and the secondary group.\nPrimary Group: The primary group is the default group assigned to a user. It is used as the group ownership for files and directories the user creates. By default, a user’s primary group often shares the same name as the username. Secondary Groups: These are additional groups to which a user can belong. Secondary groups provide users with access to shared resources or enable them to perform tasks that require specific group-level permissions. Gain Superuser Access SHOW CONTENTS In RHEL 9, to switch from a regular user to a superuser (root), the su command is used. To switch back from the root account to a regular user, the command su - user_name can be used, or alternatively, typing exit will return to the previous user account.\nIf a regular user is not in the sudoers file, an error message such as \"user_name is not in the sudoers file. This incident will be reported.\" will appear when trying to run a command with sudo. To enable full sudo access for a specific user, switch to the root account and then add the line user_name ALL=(ALL) ALL to the /etc/sudoers file. Similarly, to provide users in a specific group full sudo access, the line %group_name ALL=(ALL) ALL should be added.\nIt’s important to use the visudo command to edit the /etc/sudoers file, as it performs syntax checks to avoid errors that could lock out users from using sudo.\nManage Local User Accounts SHOW CONTENTS To create a user, use the useradd command. When executing useradd user_name, it creates the user’s home directory, sets up the account information, and generates a private group for the user named user_name. The default configuration for creating a new user is defined in the /etc/login.defs file. Note that at this point, the user account does not have a valid password set, so the user cannot log in until a password is assigned. To set a password for the user, the passwd command should be used. To delete a user, the userdel command is used. The userdel user_name command removes the user_name from the /etc/passwd file but leaves the user’s home directory intact. If it is necessary to delete the home directory as well, the userdel -r user_name option should be used. It’s important to note that when deleting a user without the -r option, the files owned by the user will be left with an unassigned UID. If a new account is later assigned to the same UID, that account will inherit the old user’s files, which poses a security risk. For this reason, many organizations prefer to lock user accounts instead of deleting them, in accordance with security policies.\nManage Local Group Accounts SHOW CONTENTS The commands for managing local group accounts include groupadd, groupmod, and groupdel.\ngroupadd: This command is used to create a new group. By default, it assigns the next available GID from the range specified by the GID_MIN and GID_MAX variables in the /etc/login.defs file. groupmod: This command is used to modify an existing group, such as changing its group name or GID. groupdel: This command is used to delete an existing group. However, it’s important to note that the primary group of an existing user cannot be removed. Here are some commonly used commands for managing local group accounts:\ngroupadd -g group_id group_name: Creates a new group with a specified GID. groupmod -n old_group_name new_group_name: Renames an existing group from old_group_name to new_group_name. groupmod -g group_id group_name: Changes the GID of an existing group (group_name) to a specified group id. usermod -aG group_name user_name: Adds a user (user_name) to an additional group (group_name) without removing the user from their existing groups. The -aG option ensures the user is appended to the group list rather than replacing the existing group memberships. groupdel group_name: Deletes the specified group (group_name). Note that the primary group of any existing users cannot be deleted. Manage User Passwords SHOW CONTENTS In Linux, /etc/passwd and /etc/shadow are critical system files that store user account information and password data, repectively. The /etc/passwd file contains basic information about user accounts on the system, while the /etc/shadow file is used to store encrypted user password information, as well as other related data such as password expiration and account locking details.\nHere is the breakdown of the line from /etc/shadow:\nThe chage command is used to configure password aging parameters for user accounts, allowing administrators to manage password expiration, warning periods, and other related settings (as shown in the following image).\nMin Days (Minimum Days Between Password Changes): The minimum days (default is 0) parameter specifies the minimum number of days that must pass before a user can change their password after setting it for the first time or after a password change. For example, if min days is set to 7, then after changing their password, the user will not be able to change it again until 7 days have passed. Max Days (Maximum Days Between Password Changes): The maximum days (default is 99999) parameter defines the maximum number of days that a user is allowed to use the current password. After this period, the user will be required to change the password. For example, If max days is set to 30, the user must change their password every 30 days. After 30 days, they will be prompted to change it. Warn Days (Warning Period Before Password Expiration): The warn days (default is 7) parameter specifies how many days before the password expires the user will be warned to change their password. The warning is displayed when the user logs in. For example, If warn days is set to 7, the user will receive a warning 7 days before the password expiration. Expiration Date/Inactivity Days: The expiration date (default is None) specifies the date when the user’s account will be locked. If the inactivity days is set to 0, the account will be locked immediately after the expiration date. The inactivity days parameter (default is 7) defines the grace period after a password expires during which the user can still log in. During this period, the user is required to change the expired password using the passwd command before the account is locked. If the password is not changed within this grace period, the account will be locked. For example, if the expiration date is set to 2024-12-01 and the inactivity days is set to 7, the user can continue logging in until 2024-12-08. After 2024-12-08, the user’s account will be locked, and contact with an administrator will be necessary to reactivate the account. Below are some commonly used chage commands:\nchage -E $(date -d \"+30 days\" +%F) user_name: This command sets the expiration date of a user’s account to 30 days from the current date. chage -d 0 user_name: This command forces the user to change their password immediately. There are common scenarios where user access needs to be restricted, such as temporarily blocking a user or disabling access for a former employee. Below are some common methods for restricting user access.\nHere are the descriptions for the mentioned commands:\nusermod -L user_name: This command locks the user account by disabling the password. It works by placing an exclamation mark (!) in front of the password hash in the /etc/shadow file, preventing the user from logging in. usermod -L -e 2024-12-31 user_name: This command locks the user account and also sets an expiration date for the account. usermod -s /sbin/nologin user_name: This command changes the login shell for the user to /sbin/nologin, which prevents the user from logging in interactively. It’s important to note that this command does not prevent all types of access. Users may still be able to authenticate and upload or retrieve files through applications like file transfer programs or mail clients, as long as the user knows the password. 7. Control Access to Files File System Permissions Concepts SHOW CONTENTS In Linux, file system permissions control the access and actions that users can perform on files and directories. These permissions help manage security and determine who can read (r), write (w), or execute (x) a file. Permissions are typically displayed in a 10-character string, such as -rwxr-xr--. The 10 characters consist of a file type and three sets of permissions (User, Group, and Others):\nThe first character in the file permission string represents the file type. Common file types include - for regular files, d for directories, l for symbolic links, c for character device files, b for block device files, p for named pipe files, and s for local socket files.\nThe first set represents the user (owner) permissions. The second set represents the group permissions. The third set represents the others (everyone else) permissions. Each set of permissions is made up of three characters, corresponding to read (r), write (w), and execute (x). For example, rwx indicates full permissions (read, write, execute) and r-- stands for read-only permissions.\nManage File System Permissions SHOW CONTENTS The chmod command is used to modify file system permissions for files and directories. The standard syntax is chmod [options] mode file_or_directory_name. The mode can be specified in either symbolic mode (e.g., r, w, x) or numeric mode (e.g., 755, 644). In numeric mode, permissions are represented by a three-digit number, where each digit corresponds to a set of permissions for the user, group, and others. Each permission is assigned a value: 4 for read, 2 for write, and 1 for execute. The sum of these values determines the permissions for each set. Below are some commonly used commands for changing file system permissions:\nchmod 755 file: Grants read, write, and execute permissions to the user, and read and execute permissions to the group and others. chmod 644 file: Grants read and write permissions to the user, and read-only permissions to the group and others. chmod +x file: Adds execute permission for all user categories (user, group, and others). chmod -x file: Removes execute permission for all user categories. chmod u+x file: Adds execute permission for the user (owner) only. chmod g-w file: Removes write permission from the group. chmod o+r file: Grants read permission to others. To change the user or group ownership of a file or directory in Linux, the chown command is used. Only the root user can change the ownership of a file. However, both the file’s owner and the root user can modify the file’s group ownership. While the root user can assign file ownership to any group, regular users can change the group ownership of a file only if they are members of the target group. Below are some commonly used commands for changing the user or group ownership of a file or directory.\nchown user_name file_name: Changes the owner of a file or directory to the specified user_name. chown user_name:group_name file_name: Changes both the owner and the group of a file or directory. chown :group_name file_name: Changes only the group ownership of the file or directory. chown -R user_name directory_name: Recursively changes the ownership of files and directories within the specified directory. chgrp group_name file_name: Changes only the group ownership of a file or directory to the specified group_name. chgrp -R group_name directory_name: Recursively changes the group ownership of files and directories within the specified directory. Sepcial Permissions \u0026 Default Permissions SHOW CONTENTS In Linux, special file permissions provide advanced control over file and directory access. These permissions include setuid, setgid, and the sticky bit.\nsetuid: This permission is represented with s in the user permission set. When set on an executable file, it allows the program to be executed with the privileges of the file owner (usually root) rather than the privileges of the user running the file. For example, the file /usr/bin/passwd is owned by the root user, but it can be executed by a regular user without sudo because it has the setuid permission in the user permission set (-rwsr-xr-x. 1 root root 32648 Aug 10 2021 /usr/bin/passwd). setgid (Group ID): This permission is represented with s in the group permission set. When applied to a file, it causes the program to run with the group privileges of the file’s group. For directories, it ensures that files created within the directory will inherit the directory’s group rather than the user’s group. For example, the file /usr/bin/locate (-rwx--s--x. 1 root slocate 41032 Aug 10 2021 /usr/bin/locate) has the setgid permission in the group permission set, allowing it to run with the group privileges of the file’s group. Similarly, the directory /run/log/journal (drwxr-sr-x+ 3 root systemd-journal 60 Apr 15 09:44 /run/log/journal/) has the setgid permission in the group permission set. This ensures that files created within the directory will inherit the systemd-journal group. sticky bit: This permission is represented with t in the others’ permission set. When applied to a directory, it allows only the file owner to delete or modify their files, preventing other users from tampering with them. For example, the directory /tmp (drwxrwxrwt. 20 root root 4096 Apr 17 08:32 /tmp) has the sticky bit set in the others’ permission set. This ensures that a user can only modify or delete the files in the /tmp directory that they own. In Linux, when a file or directory is created, its default permission is determined by the combination of the initial permission and the umask (user file creation mask). By default, files are created with initial permissions of 0666 (-rw-rw-rw-), and directories with 0777 (drwxrwxrwx). The umask defines which permission bits should be removed from these initial values, Typically, the default umask is 0022. This value can be modified in /etc/bashrc. For example, if the umask is set to 0022, a newly created file will have permissions 0644 (-rw-r--r--) because 0666 - 0022 = 0644. Similarly, a newly created directory will have permissions 0755 (drwxr-xr-x) because 0777 - 0022 = 0755.\n8. Monitor \u0026 Manage Linux Processes Process Life Cycle \u0026 States SHOW CONTENTS A process is a running instance of an executable program. Once created, a process includes several key components: an address space for allocated memory, security properties such as ownership and privileges, one or more execution threads for running code, and a process state that reflects its current status.\nThe environment of a process contains important contextual information, including local and global variables, the current scheduling context, and system resources like file descriptors and network ports that are assigned to the process.\nA new process is typically created when an existing parent process duplicates its own address space through a mechanism called a process fork. The resulting child process is assigned a unique Process ID (PID) for identification and security purposes. The child process also records the Parent Process ID (PPID) as part of its environment. On systems like Red Hat, all processes ultimately descend from the first system process, systemd.\nThrough the fork operation, the child process inherits the parent’s security credentials, file descriptors, resource privileges, environment variables, and program code. Once forked, the child process can continue running the same code or replace it with its own program logic using an exec family function.\nTypically, after creating a child process, the parent process enters a waiting state, pausing its own execution until the child finishes. When the child process exits, it releases its resources, but its process table entry remains temporarily as a zombie process. Once the parent receives a termination signal from the child, it performs cleanup by removing the zombie entry from the process table, freeing the last of the child’s resources, and then resumes its own execution.\nIn Linux, every process moves through a series of well-defined states during its lifecycle. The following image and table describe Linux process states in detail.\nTASK_INTERRUPTIBLE: TASK_UNINTERRUPTIBLE: TASK_KILLABLE: TASK_REPORT_IDLE: Flags TASK_UNINTERRUPTIBLE and TASK_NOLOAD are set. Similar to TASK_KILLABLE, also a subset of state D. It accepts fatal signals.\nName Flag Kernel-defined state name and description Running R TASK_RUNNING: The process is either executing on a CPU or waiting to run. The process can be executing user routines or kernel routines (system calls), or be queued and ready when in the Running (or Runnable) state. Sleeping S TASK_INTERRUPTIBLE: The process is waiting for some condition: a hardware request, system resource access, or signal. When an event or signal satisfies the condition, the process returns to Running. D TASK_UNINTERRUPTIBLE: This process is also sleeping, but unlike S state, does not respond to signals. Used only when process interruption might cause an unpredictable device state. K TASK_KILLABLE: Identical to the uninterruptible D state, but modified to allow a waiting task to respond to the signal that it should be killed (exit completely). Utilities frequently display Killable processes as D state. I TASK_REPORT_IDLE: A subset of state D. The kernel does not count these processes when calculating load average. Used for kernel threads. Flags TASK_UNINTERRUPTIBLE and TASK_NOLOAD are set. Similar to TASK_KILLABLE, also a subset of state D. It accepts fatal signals. Stopped T TASK_STOPPED: The process is stopped (suspended), usually by being signaled by a user or another process. The process can be continued (resumed) by another signal to return to running. T TASK_TRACED: A process that is being debugged is also temporarily stopped and shares the same T state flag. Zombie Z EXIT_ZOMBIE: A child process signals to its parent as it exits. All resources except for the process identity (PID) are released. X EXIT_DEAD: When the parent cleans up (reaps) the remaining child process structure, the process is now released completely. This state cannot be observed in process-listing utilities. In Linux, the ps and top commands are commonly used to inspect processes. The ps command displays information about active processes and is typically used to capture a snapshot of the processes running at a specific moment. In contrast, the top command provides a real-time, dynamic view of system processes, continuously updating to show CPU usage, memory usage, uptime, load average, and resource consumption for each process.\nControl Jobs SHOW CONTENTS In Linux, a job refers to a command or a group of commands initiated from a terminal by a user. Jobs can run in two modes: as a foreground job or a background job. A foreground job occupies the terminal until it completes, while a background job runs independently, allowing the terminal to remain available for other tasks. For example, executing vim file.txt starts a foreground job, which holds the terminal until the editor is closed. Running sleep 300 \u0026 starts a background job, allowing the terminal to remain usable while the command runs for 300 seconds in th e background.\nA process is a running instance of a program. When a job is initiated, one or more processes are created to perform the assigned tasks. For example, typing ls -l creates a new process to handle the application.\nA pipeline is a sequence of commands connected by the | operator, where the output of one command is passed directly as input to the next. For example, the command ps aux | grep nginx | sort forms a pipeline involving three separate processes working in succession. In this case, a pipeline runs as one job, but each part is a separate process.\nA session is a collection of processes initiated from a single user login. The first process created in a session is known as the session leader. For example, when a user logs in to a server via ssh user_name@ip_address, the shell process (bash, zsh, etc.) acts as the session leader. All jobs and processes started from that terminal belong to the same session.\nIn Linux, job control allows management of multiple jobs (commands or processes) within a single terminal session. Job control makes it possible to pause, resume, move jobs between the foreground and background, or terminate them. Below are the common-use commands for job control:\nCtrl + Z: Suspends the current foreground job and puts it into the background in a stopped state. bg: Resumes a suspended job in the background. fg: Brings a background job back to the foreground. jobs: Lists all jobs associated with the current terminal session, showing each job’s ID and status (e.g., running, stopped). In the output, a + next to a job ID denotes the current default job, which is the target of any bg or fg command issued without a %jobID. A - marks the previous job, which will become the default once the current default job completes or is removed. For example: [1] Running sleep 100 \u0026 [2] Running sleep 100 \u0026 [3]- Running sleep 100 \u0026 [4]+ Running sleep 100 \u0026 kill %job_number: Sends a signal (default is SIGTERM) to terminate a job, identified by its job number. Ctrl + C: Terminates a foreground job. Kill Processes SHOW CONTENTS In Linux, processes can be terminated using signals. A signal is a software interrupt that is delivered to a process. The following table describes common signals.\nSignal Number Description SIGTERM 15 Graceful termination (default) SIGKILL 9 Forcefully kill (non-catchable) SIGINT 2 Interrupt from keyboard (Ctrl+C) SIGHUP 1 Hang up / restart daemon SIGSTOP 19 Stop (pause) a process SIGCONT 18 Resume a stopped process Note that while signal numbers may vary across different Linux hardware platforms, signal names and their meanings remain consistent. It is generally recommended to use signal names rather than numbers when sending signals. Additionally, Red Hat advises sending SIGTERM first to allow the process to terminate gracefully, followed by SIGINT if necessary. If both signals fail, SIGKILL should be used as a last resort. The SIGKILL signal cannot be caught or ignored, and it forcibly terminates the process without giving it an opportunity to perform any self-cleanup.\nHere are some commonly used commands related to terminating processes:\nkill PID: Sends the SIGTERM signal to the specified process, requesting it to terminate gracefully. kill -SIGKILL PID: Sends the SIGKILL signal to forcefully terminate the specified process immediately (cannot be caught or ignored). killall process_name: Sends SIGTERM to all processes matching the given name, attempting a graceful termination. killall -SIGKILL process_name: Sends SIGKILL to all processes matching the given name, forcing termination. pgrep process_name: Searches for processes matching the given name and returns their PIDs. pgrep -u user_name process_name: Searches for processes with the specified name owned by a specific user. pkill process_name: Sends SIGTERM to all processes matching the given name, similar to killall. pkill -SIGKILL process_name: Sends SIGKILL to all processes matching the given name, forcing termination. pkill -u user_name: Sends a signal to all processes owned by the specified user. pstree -p: Displays the process tree with PIDs included. pstree -u: Displays the process tree with associated user names. In real-world scenarios, system administrators can forcibly terminate a user’s session to log them out. The following example demonstrates this process:\nwho -u # Lists all active user sessions along with their associated PIDs. pkill -t pts/0 # Sends SIGTERM (default) to processes attached to terminal pts/0. pkill -SIGINT -t pts/0 # If necessary, sends SIGINT to the same terminal. pkill -SIGKILL -t pts/0 # As a last resort, sends SIGKILL to forcefully terminate the session. Monitor Process Activity SHOW CONTENTS In Linux, the load average indicates the system’s workload over a period of time, measuring how many processes are either actively running or waiting to be executed by the CPU. The load average is typically represented by three numbers, corresponding to the system load over the past 1, 5, and 15 minutes. A load average of 1.0 per CPU is considered fully utilized, meaning that each CPU is handling one process at a time. For example, if a system has 2 CPUs, a load average of 2.0 would mean that the system is fully utilized. To inspect the number of CPUs in the system, the lscpu command can be used.\nFor instance, if a system has 2 CPUs and the uptime command returns:\n20:41:31 up 5:29, 3 users, load average: 3.32, 1.90, 0.32 The load average for the last minute is 3.32, which means the total load on the system is 3.32. With 2 CPUs, the per-CPU load average for the last minute is 1.66 (3.32 ÷ 2). This suggests the system is overloaded since the per-CPU load exceeds 1.0. The load average for the last 5 minutes is 1.90, and the per-CPU load average for this period is 0.95 (1.90 ÷ 2), indicating that the system is closer to optimal usage during this time. The load average for the last 15 minutes is 0.30, and the per-CPU load average is 0.16 (0.32 ÷ 2), suggesting the system is underutilized. 9. Control Services \u0026 Daemons SHOW CONTENTS ",
  "wordCount" : "6190",
  "inLanguage": "en",
  "datePublished": "2025-04-15T11:03:32+08:00",
  "dateModified": "2025-04-15T11:03:32+08:00",
  "author":{
    "@type": "Person",
    "name": "Signal Yu"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/linux/1-red-hat-enterprise-linux/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Signal's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://signalyu.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://signalyu.github.io/" accesskey="h" title="Signal&#39;s Blog (Alt + H)">
                <img src="https://signalyu.github.io/apple-touch-icon.png" alt="" aria-label="logo"
                    height="40">Signal&#39;s Blog</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://signalyu.github.io/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://signalyu.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://signalyu.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://signalyu.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://signalyu.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Red Hat Enterprise Linux
    </h1>
    <div class="post-meta"><span title='2025-04-15 11:03:32 +0800 HKT'>Apr 15 2025</span>&nbsp;·&nbsp;Signal Yu

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#1-introduction-to-linux" aria-label="1. Introduction to Linux">1. Introduction to Linux</a></li>
                <li>
                    <a href="#2-manage-files-from-the-command-line" aria-label="2. Manage Files From the Command Line">2. Manage Files From the Command Line</a><ul>
                        
                <li>
                    <a href="#linux-file-system-hierarchy" aria-label="Linux File System Hierarchy">Linux File System Hierarchy</a></li>
                <li>
                    <a href="#common-directory-and-file-management-commands" aria-label="Common Directory and File Management Commands">Common Directory and File Management Commands</a></li>
                <li>
                    <a href="#create-links-between-files" aria-label="Create Links Between Files">Create Links Between Files</a></li></ul>
                </li>
                <li>
                    <a href="#3-get-help-using-man-command" aria-label="3 Get Help Using man Command">3 Get Help Using man Command</a></li>
                <li>
                    <a href="#4-io-redirection--pipelines" aria-label="4. I/O Redirection &amp; Pipelines">4. I/O Redirection &amp; Pipelines</a><ul>
                        
                <li>
                    <a href="#io-redirection" aria-label="I/O Redirection">I/O Redirection</a></li>
                <li>
                    <a href="#pipelines" aria-label="Pipelines">Pipelines</a></li></ul>
                </li>
                <li>
                    <a href="#5-bash-environment-configuration" aria-label="5. Bash Environment Configuration">5. Bash Environment Configuration</a></li>
                <li>
                    <a href="#6-manage-local-users-and-groups" aria-label="6. Manage Local Users and Groups">6. Manage Local Users and Groups</a><ul>
                        
                <li>
                    <a href="#user--group-concepts" aria-label="User &amp; Group Concepts">User &amp; Group Concepts</a></li>
                <li>
                    <a href="#gain-superuser-access" aria-label="Gain Superuser Access">Gain Superuser Access</a></li>
                <li>
                    <a href="#manage-local-user-accounts" aria-label="Manage Local User Accounts">Manage Local User Accounts</a></li>
                <li>
                    <a href="#manage-local-group-accounts" aria-label="Manage Local Group Accounts">Manage Local Group Accounts</a></li>
                <li>
                    <a href="#manage-user-passwords" aria-label="Manage User Passwords">Manage User Passwords</a></li></ul>
                </li>
                <li>
                    <a href="#7-control-access-to-files" aria-label="7. Control Access to Files">7. Control Access to Files</a><ul>
                        
                <li>
                    <a href="#file-system-permissions-concepts" aria-label="File System Permissions Concepts">File System Permissions Concepts</a></li>
                <li>
                    <a href="#manage-file-system-permissions" aria-label="Manage File System Permissions">Manage File System Permissions</a></li>
                <li>
                    <a href="#sepcial-permissions--default-permissions" aria-label="Sepcial Permissions &amp; Default Permissions">Sepcial Permissions &amp; Default Permissions</a></li></ul>
                </li>
                <li>
                    <a href="#8-monitor--manage-linux-processes" aria-label="8. Monitor &amp; Manage Linux Processes">8. Monitor &amp; Manage Linux Processes</a><ul>
                        
                <li>
                    <a href="#process-life-cycle--states" aria-label="Process Life Cycle &amp; States">Process Life Cycle &amp; States</a></li>
                <li>
                    <a href="#control-jobs" aria-label="Control Jobs">Control Jobs</a></li>
                <li>
                    <a href="#kill-processes" aria-label="Kill Processes">Kill Processes</a></li>
                <li>
                    <a href="#monitor-process-activity" aria-label="Monitor Process Activity">Monitor Process Activity</a></li></ul>
                </li>
                <li>
                    <a href="#9-control-services--daemons" aria-label="9. Control Services &amp; Daemons">9. Control Services &amp; Daemons</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="1-introduction-to-linux">1. Introduction to Linux<a hidden class="anchor" aria-hidden="true" href="#1-introduction-to-linux">#</a></h1>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p><strong>Open Source</strong> refers to software whose source code is freely available to the public for anyone to view, modify, and distribute. It encourages coolaboration, transparency, and community-driven improvements.</p>
</blockquote>
<blockquote>
<p><strong>Open Source Licenses</strong> are legal agreements that define how software can be used, modified, and distributed. There are two main types of <strong>Copyleft</strong> and <strong>Permissive</strong>.</p>
</blockquote>
<ol>
<li><strong>Copyleft</strong> licenses require that any modified versions of the software also be open source, under the same terms as the original. Popular examples include the GPL (GNU General Public License) and AGPL (Affero GPL).</li>
<li><strong>Permissive</strong> licenses are more relaxed, allowing users to modify, distribute, and even close-source the software if desired. Well-known examples of permissive licenses include the MIT License, Apache License 2.0, and BSD License (Berkeley Software Distribution).</li>
</ol>
<blockquote>
<p>The differences between <strong>Fedora</strong>, <strong>CentOS Stream</strong>, and <strong>Red Hat Enterprise Linux (RHEL)</strong> are primarily based on their release cycles, stability, and target audiences. <strong>Fedora</strong> is a cutting-edge distribution that always features the latest software and technologies, making it ideal for developers and enthusiasts who want to experience the newest features. <strong>CentOS Stream</strong> serves as a rolling preview of future RHEL versions, acting as a middle ground between Fedora and RHEL. Finally, <strong>RHEL</strong> is the most stable and secure option, designed for enterprise environments that require long-term support and paid services. RHEL is commonly used in production systems that demand reliability and robust commercial support. <img loading="lazy" src="/img/linux/1-fedora-centos-stream-rhel.png" alt="Fedora, Centos Stream, and REHL"  />
</p>
</blockquote>

</details></p>

<hr>
<h1 id="2-manage-files-from-the-command-line">2. Manage Files From the Command Line<a hidden class="anchor" aria-hidden="true" href="#2-manage-files-from-the-command-line">#</a></h1>
<h2 id="linux-file-system-hierarchy">Linux File System Hierarchy<a hidden class="anchor" aria-hidden="true" href="#linux-file-system-hierarchy">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>The <strong>Linux File System Hierarchy</strong> defines the directory structure and directory contents in Linux-based operating systems. It stores all files which organized into a single incerted tree structure.</p>
</blockquote>
<p><img loading="lazy" src="/img/linux/2-rhel-file-system-hierarchy.png" alt="RHEL File System Hierarchy"  />
</p>
<blockquote>
<p>Here’s an overview of the key directories in the Linux file system hierarchy:</p>
</blockquote>
<table>
<thead>
<tr>
<th><strong>Location</strong></th>
<th><strong>Purpose</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>/boot</code></strong></td>
<td>Files to start the boot process.</td>
</tr>
<tr>
<td><strong><code>/dev</code></strong></td>
<td>Special device files that the system uses to access hardware.</td>
</tr>
<tr>
<td><strong><code>/etc</code></strong></td>
<td>System-specific configuration files.</td>
</tr>
<tr>
<td><strong><code>/home</code></strong></td>
<td>Home directory, where regular users store their data and configuration files.</td>
</tr>
<tr>
<td><strong><code>/root</code></strong></td>
<td>Home directory for the administrative superuser, root.</td>
</tr>
<tr>
<td><strong><code>/run</code></strong></td>
<td>Runtime data for processes that started since the last boot. This data includes process ID files and lock files. The contents of this directory are re-created on reboot. This directory consolidates the <code>/var/run</code> and <code>/var/lock</code> directories from earlier versions of Red Hat Enterprise Linux.</td>
</tr>
<tr>
<td><strong><code>/tmp</code></strong></td>
<td>A world-writable space for temporary files. Files that are not accessed, changed, or modified for 10 days are deleted from this directory automatically. The <code>/var/tmp</code> directory is also a temporary directory, in which files that are not accessed, changed, or modified in more than 30 days are deleted automatically.</td>
</tr>
<tr>
<td><strong><code>/usr</code></strong></td>
<td>Installed software, shared libraries, including files, and read-only program data. Significant subdirectories include: <code>/usr/bin</code>: User commands; <code>/usr/sbin</code>: System administration commands; <code>/usr/local</code>: Locally customized software</td>
</tr>
<tr>
<td><strong><code>/var</code></strong></td>
<td>System-specific variable data that should persist between boots. Files that dynamically change, such as databases, cache directories, log files, printer-spooled documents, and website content, might be found under <code>/var</code>.</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>static, dynamic(variable), persistent, runtime</strong>: Static content remains unchanged until explicitly edited or reconfigured; <strong>Dynamic (Variable)</strong> content might be modified or appended by active processes; <strong>Persistent</strong> content remains after a reboot, such as configuration settings; <strong>Runtime</strong> content from a process or from the system is deleted on reboot.</p>
</blockquote>

</details></p>

<hr>
<h2 id="common-directory-and-file-management-commands">Common Directory and File Management Commands<a hidden class="anchor" aria-hidden="true" href="#common-directory-and-file-management-commands">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <ul>
<li><code>pwd</code>: Prints the <strong>current working directory</strong> (path) to the terminal.</li>
<li><code>cd</code>: Changes the <strong>current working directory</strong> to the <strong>home</strong> directory of the current user.</li>
<li><code>cd -</code>: Changes the directory to the <strong>previous directory</strong>.</li>
<li><code>cd ../..</code>: Moves <strong>up two levels</strong> in the directory structure.</li>
<li><code>cd ..</code>: Moves <strong>up one level</strong> in the directory structure (to the parent directory).</li>
<li><code>ls -l</code>: Lists files and directories in the <strong>current directory</strong> in <strong>long format</strong>, showing details such as permissions, owner, group, size, and last modification time.</li>
<li><code>ls -al</code>: Lists <strong>all files</strong> (including hidden files) in the <strong>current directory</strong> in <strong>long format</strong>.</li>
<li><code>ls -lR</code>: Lists files and directories <strong>recursively</strong> in the <strong>current directory</strong> and all its subdirectories, in <strong>long format</strong>.</li>
<li><code>ls -l file*.txt</code>: Lists files that start with the word <code>file</code> and end with <code>.txt</code>.</li>
<li><code>cp hello.py HELLO.py</code>: Copies the file <code>hello.py</code> to <code>HELLO.py</code>. The original file remains unchanged.</li>
<li><code>mv -v hello.py HELLO.py</code>: Moves (or renames) the file <code>hello.py</code> to <code>HELLO.py</code>. The <code>-v</code> option prints verbose output showing the operation.</li>
<li><code>rm HELLO.py</code>: Removes (deletes) the file <code>HELLO.py</code>. <strong>Be careful, as this is a <em><strong>permanent deletion</strong></em>.</strong></li>
<li><code>mkdir HOME</code>: Creates a new directory named <code>HOME</code> in the current directory.</li>
<li><code>rmdir HOME</code>: Removes an <strong>empty directory</strong> named <code>HOME</code>. If the directory contains any files, it cannot be removed with <code>rmdir</code>.</li>
</ul>

</details></p>

<hr>
<h2 id="create-links-between-files">Create Links Between Files<a hidden class="anchor" aria-hidden="true" href="#create-links-between-files">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>In Linux, there are two types of links that can be created for files: <strong>hard links</strong> and <strong>soft links</strong>. A <strong>hard link</strong> is a direct reference to the data of a file. It creates another name for an existing file, pointing directly to the file&rsquo;s inode (the underlying data structure that holds the file&rsquo;s metadata and data.) A <strong>soft link</strong>, on the other hand, is a reference to the original file&rsquo;s path, rather than directly pointing to the file&rsquo;s inode.</p>
</blockquote>
<p><img loading="lazy" src="/img/linux/3-hard-link-vs-soft-link.png" alt="Hard Link vs. Soft Link"  />
</p>
<blockquote>
<p>Hard links that reference the same file share the same inode struct with the link count, access permissions, user and group ownership, time stamps, and file content. Therefore, when any of this information is changed for one hard link, the changes are reflected in all other hard links pointing to the same file.</p>
</blockquote>
<blockquote>
<p>Commands for creating links between files are as follows:</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ln file.txt file_link.txt <span style="color:#75715e"># Create a hard link</span>
</span></span><span style="display:flex;"><span>ls -i file.txt file_link.txt <span style="color:#75715e"># Show the inode number for both files</span>
</span></span><span style="display:flex;"><span>ln -s file.txt file_soft.txt <span style="color:#75715e"># Create a soft link</span>
</span></span><span style="display:flex;"><span>ls -l file_soft.txt <span style="color:#75715e"># Check if the soft link work (file_soft.txt -&gt; file.txt)</span>
</span></span></code></pre></div>
</details></p>

<hr>
<h1 id="3-get-help-using-man-command">3 Get Help Using <code>man</code> Command<a hidden class="anchor" aria-hidden="true" href="#3-get-help-using-man-command">#</a></h1>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>The <code>man</code> command in Linux is used to display the <strong>manual pages</strong> for various commands, programs, system calls, etc. The <strong>man pages</strong> are divided into 9 sections: <strong>executable programs or shell commands</strong>, <strong>system calls</strong>, <strong>library calls</strong>, <strong>special files</strong>, <strong>file formats and conventions</strong>, <strong>games</strong>, <strong>miscellaneous</strong>, <strong>system administration commands</strong>, and <strong>kernel routines (non standard)</strong>.</p>
</blockquote>
<ol>
<li><code>Executable programs or shell commands</code>: Commands executed by regular users (e.g., <code>ls</code>, <code>cp</code>).</li>
<li><code>System calls</code>: Functions that the kernel provides for programs to interact with the system (e.g., <code>open</code>, <code>read</code>).</li>
<li><code>Library calls</code>: Functions that can be used in programs written in C and other languages (e.g., <code>printf</code>).</li>
<li><code>Special files</code>: Usually found in <code>/dev</code>(e.g., <code>/dev/sda</code>).</li>
<li><code>File formats and conventions</code>: Descriptions of file formats (e.g., <code>/etc/passwd</code>).</li>
<li><code>Games</code>: Information about games available on the system.</li>
<li><code>Miscellaneous</code>: including macro packages and conventions (e.g. <code>man(7)</code>, <code>groff(7)</code>).</li>
<li><code>System administration commands</code>: Commands for system administrators (e.g., <code>useradd</code>, <code>systemctl</code>).</li>
<li><code>Kernel routines</code>: Non standard</li>
</ol>
<blockquote>
<p>The most common way to use <code>man</code> command including:</p>
</blockquote>
<ul>
<li><code>man open</code> or <code>man open.3</code>: Displays the manual page for the <code>open</code> command. (<code>open</code> exists in <strong>Section 2 (System Calls)</strong> and <strong>Section 3 (Library Functions)</strong>, <code>man open</code> display the System Call documentation while <code>man open.3</code> display the Library Function manual.)</li>
<li><code>man -f ls</code>: Displays a brief description of the <code>ls</code> command, equivalent to <code>whatis ls</code>.</li>
<li><code>man -k ls</code>: Searches the manual page database for the term <code>ls</code>, equivalent to <code>apropos ls</code>.</li>
</ul>
<blockquote>
<p>Note that before running <code>man -f ls</code> or <code>man -k ls</code>, it is important to ensure that the <code>mandb</code> database has been built. This can be done by running <code>sudo mandb</code>.</p>
</blockquote>

</details></p>

<hr>
<h1 id="4-io-redirection--pipelines">4. I/O Redirection &amp; Pipelines<a hidden class="anchor" aria-hidden="true" href="#4-io-redirection--pipelines">#</a></h1>
<h2 id="io-redirection">I/O Redirection<a hidden class="anchor" aria-hidden="true" href="#io-redirection">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>A process reads input and writes output. By default, it reads input from the <strong>keyboard</strong> and sends its output to the <strong>terminal window</strong>. Processes use numbered channels called <strong>file descriptors</strong> to manage input and output. Every process starts with at least three file descriptors:</p>
</blockquote>
<ul>
<li><strong>Standard Input (channel 0)</strong>: Reads input from the keyboard.</li>
<li><strong>Standard Output (channel 1)</strong>: Sends normal output to the terminal.</li>
<li><strong>Standard Error (channel 2)</strong>: Sends error messages to the terminal.</li>
</ul>
<p><img loading="lazy" src="/img/linux/4-process-io-channels.png" alt="Process I/O channels (file descriptors)"  />
</p>
<table>
<thead>
<tr>
<th>Number</th>
<th>Channel Name</th>
<th>Description</th>
<th>Default Connection</th>
<th>Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>stdin</td>
<td>Standard input</td>
<td>Keyboard</td>
<td>Read only</td>
</tr>
<tr>
<td>1</td>
<td>stdout</td>
<td>Standard output</td>
<td>Terminal</td>
<td>Write only</td>
</tr>
<tr>
<td>2</td>
<td>stderr</td>
<td>Standard error</td>
<td>Terminal</td>
<td>Write only</td>
</tr>
<tr>
<td>3+</td>
<td>filename</td>
<td>Other files</td>
<td>None</td>
<td>Read/write or both</td>
</tr>
</tbody>
</table>
<blockquote>
<p>By default, a process takes input from the keyboard and displays its output on the terminal. <strong>Redirection</strong> refers to changing the default input or output of a command. The following table summarizes the different types of redirection available:</p>
</blockquote>
<table>
<thead>
<tr>
<th>Usage</th>
<th>Explanation</th>
<th>Vitulization</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&gt; file</code></td>
<td>Redirect <strong>stdout</strong> to overwrite a file</td>
<td><img loading="lazy" src="/img/linux/5-output-override.png" alt="override output"  />
</td>
</tr>
<tr>
<td><code>&gt;&gt; file</code></td>
<td>Redirect <strong>stdout</strong> ot append to a file</td>
<td><img loading="lazy" src="/img/linux/6-output-append.png" alt="append outout"  />
</td>
</tr>
<tr>
<td><code>2&gt; file</code></td>
<td>Redirect <strong>stderr</strong> to overwrite a file</td>
<td><img loading="lazy" src="/img/linux/7-error-override.png" alt="override error"  />
</td>
</tr>
<tr>
<td><code>2&gt; /dev/null</code></td>
<td>Discard <strong>stderr</strong> error messages by redirecting them to <code>/dev/null</code></td>
<td><img loading="lazy" src="/img/linux/8-error-discard.png" alt="discard error"  />
</td>
</tr>
<tr>
<td><code>&gt; file 2&gt;&amp;1</code> or <code>&amp;&gt; file</code></td>
<td>Redirect <strong>stdout</strong> and <strong>stderr</strong> to overwrite the same file</td>
<td><img loading="lazy" src="/img/linux/9-output-and-error-override.png" alt="override output and error"  />
</td>
</tr>
<tr>
<td><code>&gt;&gt; file 2&gt;&amp;1</code> or <code>&amp;&gt;&gt; file</code></td>
<td>Redirect <strong>stdout</strong> and <strong>stderr</strong> to append the same file</td>
<td><img loading="lazy" src="/img/linux/10-output-and-error-append.png" alt="append output and error"  />
</td>
</tr>
<tr>
<td><code>sort &lt; file &gt; sorted_file</code></td>
<td>Redirects the <strong>stdin</strong> to a file and redirect <strong>stdout</strong> to overwrite a different file</td>
<td><img loading="lazy" src="/img/linux/11-input-redirection.png" alt="input redirection"  />
</td>
</tr>
</tbody>
</table>
<blockquote>
<p>It is important to note that <strong>the order of redirection operations is crucial</strong>. For example:</p>
</blockquote>
<ul>
<li>The command <code>&gt; output.log 2&gt;&amp;1</code> redirects both standard output and standard error messages to the same file, <code>output.log</code>.</li>
<li>On the other hand, <code>2&gt;&amp;1 &gt; output.log</code> redirects standard error messages to the default standard output (the terminal), and then redirects only the standard output to <code>output.log</code>.</li>
</ul>
<blockquote>
<p>Additionally, the command <code>&gt; output.log 2&gt;&amp;1</code> can be shortened to <code>&amp;&gt; output.log</code>. However, it is important to note that <code>&amp;&gt;</code> is not standardized and may not be implemented in all shells.</p>
</blockquote>

</details></p>

<hr>
<h2 id="pipelines">Pipelines<a hidden class="anchor" aria-hidden="true" href="#pipelines">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>A <strong>pipeline</strong> is a sequence of one or more commands that are connected by the vertical bar character (<code>|</code>). In a pipeline, the standard output of one command is passed directly as the standard input to the next command.</p>
</blockquote>
<p><img loading="lazy" src="/img/linux/12-process-io-piping.png" alt="Process I/O Piping"  />
</p>
<blockquote>
<p>The main difference between <strong>pipelines</strong> and <strong>I/O redirection</strong> lies in how they handle data. <strong>I/O redirection</strong> refers to sending standard output to a file or receiving standard input from a file. In contrast, <strong>pipelines</strong> are used to send the standard output of one process directly to the standard input of another process.</p>
</blockquote>
<blockquote>
<p>The following are some commonly used pipeline examples:</p>
</blockquote>
<ul>
<li><code>cat file.txt | grep &quot;pattern&quot;</code>: Searches for patterns within text.</li>
<li><code>cat file.txt | sort</code>: Sorts the lines of text in a specified order (alphabetically by default).</li>
<li><code>cat file.txt | wc -l</code>: Counts the number of lines in a file.</li>
<li><code>cat file.txt | tee output.txt</code>: Outputs the content of a file to both the terminal and a specified file. <img loading="lazy" src="/img/linux/13-process-io-piping-with-tee.png" alt="Process I/O Piping With tee"  />
</li>
<li><code>find / -name &quot;passwd&quot; 2&gt;&amp;1 | less</code>:
<ul>
<li><code>find / -name &quot;passwd&quot;</code>: Searches for a file or directory named <code>passwd</code> starting from the root directory (<code>/</code>).</li>
<li><code>2&gt;&amp;1</code>: Redirects standard error (file descriptor 2) to standard output (file descriptor 1). This ensures that any error messages, such as permission denials, are also passed along with the normal output.</li>
<li><code>| less</code>: Pipes the combined output (standard output and error messages) into the <code>less</code> command.</li>
</ul>
</li>
</ul>

</details></p>

<hr>
<h1 id="5-bash-environment-configuration">5. Bash Environment Configuration<a hidden class="anchor" aria-hidden="true" href="#5-bash-environment-configuration">#</a></h1>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>When Bash starts, several initialization scripts are executed to configure the shell environment, with the specific scripts depending on whether the shell is <em>interactive</em>, <em>non-interactive</em>, <em>login</em>, or <em>non-login</em>. An interactive shell allows users to enter commands directly, while a non-interactive shell runs in the background. A login shell is invoked when a user logs in via terminal or SSH, while non-login shell is opened from an existing session, like when launching a terminal in a GUI.</p>
</blockquote>
<blockquote>
<p>For <strong>interactive login shells</strong>, the environment is configured by the <code>/etc/profile</code> and <code>~/.bash_profile</code> files, which also source <code>/etc/bashrc</code> and <code>~/.bashrc</code> respectively. For <strong>interactive non-login shells</strong>, only <code>/etc/bashrc</code> and <code>~/.bashrc</code> are used. System-wide configurations are stored in <code>/etc/profile</code> and <code>/etc/bashrc</code>, while user-specific configurations are in <code>~/.bash_profile</code> and <code>~/.bashrc</code>.</p>
</blockquote>

</details></p>

<hr>
<h1 id="6-manage-local-users-and-groups">6. Manage Local Users and Groups<a hidden class="anchor" aria-hidden="true" href="#6-manage-local-users-and-groups">#</a></h1>
<h2 id="user--group-concepts">User &amp; Group Concepts<a hidden class="anchor" aria-hidden="true" href="#user--group-concepts">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>A <strong>user</strong> is an individual account created on a Linux system that can own files, execute commands, and interact with the system. User details are typically stored in the <code>/etc/passwd</code> file, where each line represents a user account with specific information like username, UID, home directory, and default shell.</p>
</blockquote>
<p><img loading="lazy" src="/img/linux/14-user-details-etc-passwd.png" alt="User Details"  />
</p>
<blockquote>
<p>In Linux, there are three primary types of users:</p>
</blockquote>
<ul>
<li><strong>Superuser</strong>: The superuser account is responsible for administering the system.  Its name is <code>root</code> with a UID of <code>0</code>. It has full system access.</li>
<li><strong>System User</strong>: These accounts are used by processes or daemons that provide system services (e.g., web servers, databases). System users are non-privileged and are created to isolate and secure the services they support.</li>
<li><strong>Regular User</strong>: The <strong>regular user</strong> is the typical user who do not have root priviledges and have limited access to the system.</li>
</ul>
<blockquote>
<p>A <strong>group</strong> is a collection of users that can be assigned a common set of permissions. The group details are typically stored in <code>etc/group</code>, which contains information about group names, GIDs, and the list of users that belong to each group.</p>
</blockquote>
<p><img loading="lazy" src="/img/linux/15-group-details-etc-group.png" alt="Group Details"  />
</p>
<blockquote>
<p>In Linux, there two main types of group: the <strong>primary group</strong> and the <strong>secondary group</strong>.</p>
</blockquote>
<ul>
<li><strong>Primary Group</strong>: The primary group is the default group assigned to a user. It is used as the group ownership for files and directories the user creates. By default, a user’s primary group often shares the same name as the username.</li>
<li><strong>Secondary Groups</strong>: These are additional groups to which a user can belong. Secondary groups provide users with access to shared resources or enable them to perform tasks that require specific group-level permissions.</li>
</ul>

</details></p>

<hr>
<h2 id="gain-superuser-access">Gain Superuser Access<a hidden class="anchor" aria-hidden="true" href="#gain-superuser-access">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>In <strong>RHEL 9</strong>, to switch from a regular user to a superuser (root), the <code>su</code> command is used. To switch back from the root account to a regular user, the command <code>su - user_name</code> can be used, or alternatively, typing <code>exit</code> will return to the previous user account.</p>
</blockquote>
<blockquote>
<p>If a regular user is not in the <strong>sudoers</strong> file, an error message such as <em>&quot;<code>user_name</code> is not in the sudoers file. This incident will be reported.&quot;</em> will appear when trying to run a command with <code>sudo</code>. To enable full <code>sudo</code> access for a specific user, switch to the root account and then add the line <code>user_name ALL=(ALL) ALL</code> to the <code>/etc/sudoers</code> file. Similarly, to provide users in a specific group full <code>sudo</code> access, the line <code>%group_name ALL=(ALL) ALL</code> should be added.</p>
</blockquote>
<blockquote>
<p>It’s important to use the <code>visudo</code> command to edit the <code>/etc/sudoers</code> file, as it performs syntax checks to avoid errors that could lock out users from using <code>sudo</code>.</p>
</blockquote>

</details></p>

<hr>
<h2 id="manage-local-user-accounts">Manage Local User Accounts<a hidden class="anchor" aria-hidden="true" href="#manage-local-user-accounts">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>To create a user, use the <code>useradd</code> command. When executing <code>useradd user_name</code>, it creates the user&rsquo;s home directory, sets up the account information, and generates a private group for the user named <code>user_name</code>. The default configuration for creating a new user is defined in the <code>/etc/login.defs</code> file. Note that at this point, the user account does not have a valid password set, so the user cannot log in until a password is assigned. To set a password for the user, the <code>passwd</code> command should be used.
To delete a user, the <code>userdel</code> command is used. The <code>userdel user_name</code> command removes the <code>user_name</code> from the <code>/etc/passwd</code> file but leaves the user&rsquo;s home directory intact. If it is necessary to delete the home directory as well, the <code>userdel -r user_name</code> option should be used. It’s important to note that when deleting a user without the <code>-r</code> option, the files owned by the user will be left with an unassigned UID. If a new account is later assigned to the same UID, that account will inherit the old user&rsquo;s files, which poses a security risk. For this reason, many organizations prefer to lock user accounts instead of deleting them, in accordance with security policies.</p>
</blockquote>
</details></p>

<hr>
<h2 id="manage-local-group-accounts">Manage Local Group Accounts<a hidden class="anchor" aria-hidden="true" href="#manage-local-group-accounts">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>The commands for managing local group accounts include <code>groupadd</code>, <code>groupmod</code>, and <code>groupdel</code>.</p>
</blockquote>
<ul>
<li><strong>groupadd</strong>: This command is used to create a new group. By default, it assigns the next available GID from the range specified by the <code>GID_MIN</code> and <code>GID_MAX</code> variables in the <code>/etc/login.defs</code> file.</li>
<li><strong>groupmod</strong>: This command is used to modify an existing group, such as changing its group name or GID.</li>
<li><strong>groupdel</strong>: This command is used to delete an existing group. However, it&rsquo;s important to note that the primary group of an existing user cannot be removed.</li>
</ul>
<blockquote>
<p>Here are some commonly used commands for managing local group accounts:</p>
</blockquote>
<ul>
<li><strong><code>groupadd -g group_id group_name</code></strong>: Creates a new group with a specified GID.</li>
<li><strong><code>groupmod -n old_group_name new_group_name</code></strong>: Renames an existing group from <code>old_group_name</code> to <code>new_group_name</code>.</li>
<li><strong><code>groupmod -g group_id group_name</code></strong>: Changes the GID of an existing group (<code>group_name</code>) to a specified group id.</li>
<li><strong><code>usermod -aG group_name user_name</code></strong>: Adds a user (<code>user_name</code>) to an additional group (<code>group_name</code>) without removing the user from their existing groups. <strong>The <code>-aG</code> option ensures the user is appended to the group list rather than replacing the existing group memberships.</strong></li>
<li><strong><code>groupdel group_name</code></strong>: Deletes the specified group (<code>group_name</code>). Note that the primary group of any existing users cannot be deleted.</li>
</ul>

</details></p>

<hr>
<h2 id="manage-user-passwords">Manage User Passwords<a hidden class="anchor" aria-hidden="true" href="#manage-user-passwords">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>In Linux, <code>/etc/passwd</code> and <code>/etc/shadow</code> are critical system files that store user account information and password data, repectively. The <code>/etc/passwd</code> file contains basic information about user accounts on the system, while the <code>/etc/shadow</code> file is used to store encrypted user password information, as well as other related data such as password expiration and account locking details.</p>
</blockquote>
<blockquote>
<p>Here is the breakdown of the line from <code>/etc/shadow</code>:</p>
</blockquote>
<p><img loading="lazy" src="/img/linux/16-password-info-diagram-in-etc-shadow.png" alt="Password Info Diagram in /etc/shadow"  />
</p>
<blockquote>
<p>The <code>chage</code> command is used to configure <strong>password aging</strong> parameters for user accounts, allowing administrators to manage password expiration, warning periods, and other related settings (as shown in the following image).</p>
</blockquote>
<p><img loading="lazy" src="/img/linux/17-password-aging-parameters.png" alt="Password Aging Parameters"  />
</p>
<ul>
<li><strong>Min Days (Minimum Days Between Password Changes)</strong>: The <strong>minimum days</strong> (default is <code>0</code>) parameter specifies the minimum number of days that must pass before a user can change their password after setting it for the first time or after a password change. For example, if <code>min days</code> is set to 7, then after changing their password, the user will not be able to change it again until 7 days have passed.</li>
<li><strong>Max Days (Maximum Days Between Password Changes)</strong>: The <strong>maximum days</strong> (default is <code>99999</code>) parameter defines the maximum number of days that a user is allowed to use the current password. After this period, the user will be required to change the password. For example,  If <strong>max days</strong> is set to 30, the user must change their password every 30 days. After 30 days, they will be prompted to change it.</li>
<li><strong>Warn Days (Warning Period Before Password Expiration)</strong>: The <strong>warn days</strong> (default is <code>7</code>) parameter specifies how many days before the password expires the user will be warned to change their password. The warning is displayed when the user logs in. For example, If <code>warn days</code> is set to 7, the user will receive a warning 7 days before the password expiration.</li>
<li><strong>Expiration Date/Inactivity Days</strong>: The <strong>expiration date</strong> (default is <code>None</code>) specifies the date when the user’s account will be locked. If the <strong>inactivity days</strong> is set to <code>0</code>, the account will be locked immediately after the expiration date. The <strong>inactivity days</strong> parameter (default is <code>7</code>) defines the grace period after a password expires during which the user can still log in. During this period, the user is required to change the expired password using the <code>passwd</code> command before the account is locked. If the password is not changed within this grace period, the account will be locked. For example, if the <code>expiration date</code> is set to <code>2024-12-01</code> and the <code>inactivity days</code> is set to <code>7</code>, the user can continue logging in until <code>2024-12-08</code>. After <code>2024-12-08</code>, the user’s account will be locked, and contact with an administrator will be necessary to reactivate the account.</li>
</ul>
<blockquote>
<p>Below are some commonly used <code>chage</code> commands:</p>
</blockquote>
<ul>
<li><code>chage -E $(date -d &quot;+30 days&quot; +%F) user_name</code>: This command sets the <strong>expiration date</strong> of a user&rsquo;s account to 30 days from the current date.</li>
<li><code>chage -d 0 user_name</code>: This command forces the <strong>user to change their password</strong> immediately.</li>
</ul>
<blockquote>
<p>There are common scenarios where user access needs to be restricted, such as temporarily blocking a user or disabling access for a former employee. Below are some common methods for restricting user access.</p>
</blockquote>
<p>Here are the descriptions for the mentioned commands:</p>
<ul>
<li><strong><code>usermod -L user_name</code></strong>: This command locks the user account by disabling the password. It works by placing an exclamation mark (<code>!</code>) in front of the password hash in the <code>/etc/shadow</code> file, preventing the user from logging in.</li>
<li><strong><code>usermod -L -e 2024-12-31 user_name</code></strong>: This command locks the user account and also sets an expiration date for the account.</li>
<li><strong><code>usermod -s /sbin/nologin user_name</code></strong>: This command changes the login shell for the user to <code>/sbin/nologin</code>, which prevents the user from logging in interactively. <strong>It&rsquo;s important to note that this command does not prevent all types of access. Users may still be able to authenticate and upload or retrieve files through applications like file transfer programs or mail clients, as long as the user knows the password.</strong></li>
</ul>

</details></p>

<hr>
<h1 id="7-control-access-to-files">7. Control Access to Files<a hidden class="anchor" aria-hidden="true" href="#7-control-access-to-files">#</a></h1>
<h2 id="file-system-permissions-concepts">File System Permissions Concepts<a hidden class="anchor" aria-hidden="true" href="#file-system-permissions-concepts">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>In Linux, <strong>file system permissions</strong> control the access and actions that users can perform on files and directories. These permissions help manage security and determine who can read (<code>r</code>), write (<code>w</code>), or execute (<code>x</code>) a file. Permissions are typically displayed in a 10-character string, such as <code>-rwxr-xr--</code>. The 10 characters consist of a file type and three sets of permissions (<strong>User</strong>, <strong>Group</strong>, and <strong>Others</strong>):</p>
</blockquote>
<p><img loading="lazy" src="/img/linux/18-file-system-permissions.png" alt="File System Permissions"  />
</p>
<blockquote>
<p>The first character in the file permission string represents the <strong>file type</strong>. Common file types include <code>-</code> for regular files, <code>d</code> for directories, <code>l</code> for symbolic links, <code>c</code> for character device files, <code>b</code> for block device files, <code>p</code> for named pipe files, and <code>s</code> for local socket files.</p>
</blockquote>
<blockquote>
<p>The <strong>first set</strong> represents the <code>user</code> (owner) permissions. The <strong>second set</strong> represents the <code>group</code> permissions. The <strong>third set</strong> represents the <code>others</code> (everyone else) permissions. Each set of permissions is made up of three characters, corresponding to <strong>read</strong> (<code>r</code>), <strong>write</strong> (<code>w</code>), and <strong>execute</strong> (<code>x</code>). For example, <code>rwx</code> indicates full permissions (read, write, execute) and <code>r--</code> stands for read-only permissions.</p>
</blockquote>

</details></p>

<hr>
<h2 id="manage-file-system-permissions">Manage File System Permissions<a hidden class="anchor" aria-hidden="true" href="#manage-file-system-permissions">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>The <code>chmod</code> command is used to modify file system permissions for files and directories. The standard syntax is <code>chmod [options] mode file_or_directory_name</code>. The <strong>mode</strong> can be specified in either symbolic mode (e.g., <code>r</code>, <code>w</code>, <code>x</code>) or numeric mode (e.g., <code>755</code>, <code>644</code>). In numeric mode, permissions are represented by a three-digit number, where each digit corresponds to a set of permissions for the <strong>user</strong>, <strong>group</strong>, and <strong>others</strong>. Each permission is assigned a value: <code>4</code> for read, <code>2</code> for write, and <code>1</code> for execute. The sum of these values determines the permissions for each set. Below are some commonly used commands for changing file system permissions:</p>
</blockquote>
<ul>
<li><code>chmod 755 file</code>: Grants read, write, and execute permissions to the user, and read and execute permissions to the group and others.</li>
<li><code>chmod 644 file</code>: Grants read and write permissions to the user, and read-only permissions to the group and others.</li>
<li><code>chmod +x file</code>: Adds execute permission for all user categories (user, group, and others).</li>
<li><code>chmod -x file</code>: Removes execute permission for all user categories.</li>
<li><code>chmod u+x file</code>: Adds execute permission for the user (owner) only.</li>
<li><code>chmod g-w file</code>: Removes write permission from the group.</li>
<li><code>chmod o+r file</code>: Grants read permission to others.</li>
</ul>
<blockquote>
<p>To change the user or group ownership of a file or directory in Linux, the <code>chown</code> command is used. Only the root user can change the ownership of a file. However, both the file&rsquo;s owner and the root user can modify the file&rsquo;s group ownership. While the root user can assign file ownership to any group, regular users can change the group ownership of a file only if they are members of the target group.  Below are some commonly used commands for changing the user or group ownership of a file or directory.</p>
</blockquote>
<ul>
<li><code>chown user_name file_name</code>: Changes the owner of a file or directory to the specified <code>user_name</code>.</li>
<li><code>chown user_name:group_name file_name</code>: Changes both the owner and the group of a file or directory.</li>
<li><code>chown :group_name file_name</code>: Changes only the group ownership of the file or directory.</li>
<li><code>chown -R user_name directory_name</code>: Recursively changes the ownership of files and directories within the specified directory.</li>
<li><code>chgrp group_name file_name</code>: Changes only the group ownership of a file or directory to the specified <code>group_name</code>.</li>
<li><code>chgrp -R group_name directory_name</code>: Recursively changes the group ownership of files and directories within the specified directory.</li>
</ul>

</details></p>

<hr>
<h2 id="sepcial-permissions--default-permissions">Sepcial Permissions &amp; Default Permissions<a hidden class="anchor" aria-hidden="true" href="#sepcial-permissions--default-permissions">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>In Linux, special file permissions provide advanced control over file and directory access. These permissions include <strong>setuid</strong>, <strong>setgid</strong>, and the <strong>sticky bit</strong>.</p>
</blockquote>
<ul>
<li><strong>setuid</strong>: This permission is represented with <code>s</code> in the user permission set. When set on an executable file, it allows the program to be executed with the privileges of the file owner (usually <strong>root</strong>) rather than the privileges of the user running the file. For example, the file <code>/usr/bin/passwd</code> is owned by the root user, but it can be executed by a regular user without <code>sudo</code> because it has the <code>setuid</code> permission in the user permission set (<code>-rwsr-xr-x. 1 root root 32648 Aug 10  2021 /usr/bin/passwd</code>).</li>
<li><strong>setgid (Group ID)</strong>: This permission is represented with <code>s</code> in the group permission set. When applied to a file, it causes the program to run with the group privileges of the file&rsquo;s group. For directories, it ensures that files created within the directory will inherit the directory&rsquo;s group rather than the user&rsquo;s group. For example, the file <code>/usr/bin/locate (-rwx--s--x. 1 root slocate 41032 Aug 10  2021 /usr/bin/locate)</code> has the <code>setgid</code> permission in the group permission set, allowing it to run with the group privileges of the file&rsquo;s group. Similarly, the directory <code>/run/log/journal (drwxr-sr-x+ 3 root systemd-journal 60 Apr 15 09:44 /run/log/journal/)</code> has the <code>setgid</code> permission in the group permission set. This ensures that files created within the directory will inherit the <code>systemd-journal</code> group.</li>
<li><strong>sticky bit</strong>: This permission is represented with <code>t</code> in the others&rsquo; permission set. When applied to a directory, it allows only the file owner to delete or modify their files, preventing other users from tampering with them. For example, the directory <code>/tmp (drwxrwxrwt. 20 root root 4096 Apr 17 08:32 /tmp)</code> has the sticky bit set in the others&rsquo; permission set. This ensures that a user can only modify or delete the files in the <code>/tmp</code> directory that they own.</li>
</ul>
<hr>
<blockquote>
<p>In Linux, when a file or directory is created, its default permission is determined by the combination of the initial permission and the <strong>umask</strong> (user file creation mask). By default, files are created with initial permissions of <code>0666</code> (<code>-rw-rw-rw-</code>), and directories with <code>0777</code> (<code>drwxrwxrwx</code>). The <strong>umask</strong> defines which permission bits should be removed from these initial values, Typically, the default umask is 0022. This value can be modified in <code>/etc/bashrc</code>. For example, if the umask is set to <code>0022</code>, a newly created file will have permissions <code>0644</code> (<code>-rw-r--r--</code>) because <code>0666 - 0022 = 0644</code>. Similarly, a newly created directory will have permissions <code>0755</code> (<code>drwxr-xr-x</code>) because <code>0777 - 0022 = 0755</code>.</p>
</blockquote>

</details></p>

<hr>
<h1 id="8-monitor--manage-linux-processes">8. Monitor &amp; Manage Linux Processes<a hidden class="anchor" aria-hidden="true" href="#8-monitor--manage-linux-processes">#</a></h1>
<h2 id="process-life-cycle--states">Process Life Cycle &amp; States<a hidden class="anchor" aria-hidden="true" href="#process-life-cycle--states">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <p>A <strong>process</strong> is a running instance of an executable program. Once created, a process includes several key components: an address space for allocated memory, security properties such as ownership and privileges, one or more execution threads for running code, and a process state that reflects its current status.</p>
<p>The <strong>environment</strong> of a process contains important contextual information, including local and global variables, the current scheduling context, and system resources like file descriptors and network ports that are assigned to the process.</p>
<p><img loading="lazy" src="/img/linux/19-process-life-cycle.png" alt="Process Life Cycle"  />
</p>
<p>A new process is typically created when an existing <strong>parent process</strong> duplicates its own address space through a mechanism called a <strong>process fork</strong>. The resulting child process is assigned a unique Process ID (PID) for identification and security purposes. The child process also records the Parent Process ID (PPID) as part of its environment. On systems like Red Hat, all processes ultimately descend from the first system process, <code>systemd</code>.</p>
<p>Through the <strong>fork</strong> operation, the child process inherits the parent’s security credentials, file descriptors, resource privileges, environment variables, and program code. Once forked, the child process can continue running the same code or replace it with its own program logic using an <code>exec</code> family function.</p>
<p>Typically, after creating a child process, the <strong>parent process</strong> enters a waiting state, pausing its own execution until the child finishes. When the child process exits, it releases its resources, but its process table entry remains temporarily as a <strong>zombie process</strong>. Once the parent receives a termination signal from the child, it performs cleanup by removing the zombie entry from the process table, freeing the last of the child’s resources, and then resumes its own execution.</p>
<hr>
<blockquote>
<p>In Linux, every process moves through a series of well-defined <strong>states</strong> during its lifecycle. The following image and table describe Linux process states in detail.</p>
</blockquote>
<p><img loading="lazy" src="/img/linux/20-linux-process-states.png" alt="Linux Process States"  />
</p>
<p>TASK_INTERRUPTIBLE:
TASK_UNINTERRUPTIBLE:
TASK_KILLABLE:
TASK_REPORT_IDLE:
Flags TASK_UNINTERRUPTIBLE and TASK_NOLOAD are set. Similar to TASK_KILLABLE, also a subset of state D. It accepts fatal signals.</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Flag</th>
<th>Kernel-defined state name and description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Running</strong></td>
<td>R</td>
<td><code>TASK_RUNNING</code>: The process is either executing on a CPU or waiting to run. The process can be executing user routines or kernel routines (system calls), or be queued and ready when in the Running (or Runnable) state.</td>
</tr>
<tr>
<td><strong>Sleeping</strong></td>
<td>S</td>
<td><code>TASK_INTERRUPTIBLE</code>: The process is waiting for some condition: a hardware request, system resource access, or signal. When an event or signal satisfies the condition, the process returns to Running.</td>
</tr>
<tr>
<td></td>
<td>D</td>
<td><code>TASK_UNINTERRUPTIBLE</code>: This process is also sleeping, but unlike S state, does not respond to signals. Used only when process interruption might cause an unpredictable device state.</td>
</tr>
<tr>
<td></td>
<td>K</td>
<td><code>TASK_KILLABLE</code>: Identical to the uninterruptible D state, but modified to allow a waiting task to respond to the signal that it should be killed (exit completely). Utilities frequently display Killable processes as D state.</td>
</tr>
<tr>
<td></td>
<td>I</td>
<td><code>TASK_REPORT_IDLE</code>: A subset of state D. The kernel does not count these processes when calculating load average. Used for kernel threads. Flags TASK_UNINTERRUPTIBLE and TASK_NOLOAD are set. Similar to TASK_KILLABLE, also a subset of state D. It accepts fatal signals.</td>
</tr>
<tr>
<td><strong>Stopped</strong></td>
<td>T</td>
<td><code>TASK_STOPPED</code>: The process is stopped (suspended), usually by being signaled by a user or another process. The process can be continued (resumed) by another signal to return to running.</td>
</tr>
<tr>
<td></td>
<td>T</td>
<td><code>TASK_TRACED</code>: A process that is being debugged is also temporarily stopped and shares the same T state flag.</td>
</tr>
<tr>
<td><strong>Zombie</strong></td>
<td>Z</td>
<td><code>EXIT_ZOMBIE</code>: A child process signals to its parent as it exits. All resources except for the process identity (PID) are released.</td>
</tr>
<tr>
<td></td>
<td>X</td>
<td><code>EXIT_DEAD</code>: When the parent cleans up (reaps) the remaining child process structure, the process is now released completely. This state cannot be observed in process-listing utilities.</td>
</tr>
</tbody>
</table>
<blockquote>
<p>In Linux, the <code>ps</code> and <code>top</code> commands are commonly used to inspect processes. The <code>ps</code> command displays information about active processes and is typically used to capture a snapshot of the processes running at a specific moment. In contrast, the <code>top</code> command provides a real-time, dynamic view of system processes, continuously updating to show CPU usage, memory usage, uptime, load average, and resource consumption for each process.</p>
</blockquote>

</details></p>

<hr>
<h2 id="control-jobs">Control Jobs<a hidden class="anchor" aria-hidden="true" href="#control-jobs">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>In Linux, a <strong>job</strong> refers to a command or a group of commands initiated from a terminal by a user. Jobs can run in two modes: as a <strong>foreground job</strong> or a <strong>background job</strong>. A foreground job occupies the terminal until it completes, while a background job runs independently, allowing the terminal to remain available for other tasks. For example, executing <code>vim file.txt</code> starts a foreground job, which holds the terminal until the editor is closed. Running <code>sleep 300 &amp;</code> starts a background job, allowing the terminal to remain usable while the command runs for 300 seconds in th e background.</p>
</blockquote>
<blockquote>
<p>A <strong>process</strong> is a running instance of a program. When a job is initiated, one or more processes are created to perform the assigned tasks. For example, typing <code>ls -l</code> creates a new process to handle the application.</p>
</blockquote>
<blockquote>
<p>A <strong>pipeline</strong> is a sequence of commands connected by the <code>|</code> operator, where the output of one command is passed directly as input to the next. For example, the command <code>ps aux | grep nginx | sort</code> forms a pipeline involving three separate processes working in succession. In this case, a pipeline runs as one job, but each part is a separate process.</p>
</blockquote>
<blockquote>
<p>A <strong>session</strong> is a collection of processes initiated from a single user login. The first process created in a session is known as the <strong>session leader</strong>. For example, when a user logs in to a server via <code>ssh user_name@ip_address</code>, the shell process (<code>bash</code>, <code>zsh</code>, etc.) acts as the session leader. All jobs and processes started from that terminal belong to the same session.</p>
</blockquote>
<blockquote>
<p>In Linux, <strong>job control</strong> allows management of multiple jobs (commands or processes) within a single terminal session. Job control makes it possible to pause, resume, move jobs between the foreground and background, or terminate them. Below are the common-use commands for job control:</p>
</blockquote>
<ul>
<li><code>Ctrl + Z</code>: Suspends the current foreground job and puts it into the background in a <strong>stopped</strong> state.</li>
<li><code>bg</code>: Resumes a suspended job in the background.</li>
<li><code>fg</code>: Brings a background job back to the foreground.</li>
<li><code>jobs</code>: Lists all jobs associated with the current terminal session, showing each job’s ID and status (e.g., running, stopped). In the output, a <code>+</code> next to a job ID denotes the <strong>current default job</strong>, which is the target of any <code>bg</code> or <code>fg</code> command issued without a <code>%jobID</code>. A <code>-</code> marks the <strong>previous job</strong>, which will become the default once the current default job completes or is removed. For example:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">[</span>1<span style="color:#f92672">]</span>   Running                 sleep <span style="color:#ae81ff">100</span> &amp;
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>2<span style="color:#f92672">]</span>   Running                 sleep <span style="color:#ae81ff">100</span> &amp;
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>3<span style="color:#f92672">]</span>-  Running                 sleep <span style="color:#ae81ff">100</span> &amp;
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>4<span style="color:#f92672">]</span>+  Running                 sleep <span style="color:#ae81ff">100</span> &amp;
</span></span></code></pre></div></li>
<li><code>kill %job_number</code>: Sends a signal (default is <code>SIGTERM</code>) to terminate a job, identified by its job number.</li>
<li><code>Ctrl + C</code>: Terminates a foreground job.</li>
</ul>

</details></p>

<hr>
<h2 id="kill-processes">Kill Processes<a hidden class="anchor" aria-hidden="true" href="#kill-processes">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>In Linux, processes can be terminated using signals. A <strong>signal</strong> is a software interrupt that is delivered to a process. The following table describes common signals.</p>
</blockquote>
<table>
<thead>
<tr>
<th>Signal</th>
<th>Number</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SIGTERM</code></td>
<td>15</td>
<td>Graceful termination (default)</td>
</tr>
<tr>
<td><code>SIGKILL</code></td>
<td>9</td>
<td>Forcefully kill (non-catchable)</td>
</tr>
<tr>
<td><code>SIGINT</code></td>
<td>2</td>
<td>Interrupt from keyboard (<code>Ctrl+C</code>)</td>
</tr>
<tr>
<td><code>SIGHUP</code></td>
<td>1</td>
<td>Hang up / restart daemon</td>
</tr>
<tr>
<td><code>SIGSTOP</code></td>
<td>19</td>
<td>Stop (pause) a process</td>
</tr>
<tr>
<td><code>SIGCONT</code></td>
<td>18</td>
<td>Resume a stopped process</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Note that while signal numbers may vary across different Linux hardware platforms, signal names and their meanings remain consistent. It is generally recommended to use signal names rather than numbers when sending signals. Additionally, Red Hat advises sending <code>SIGTERM</code> first to allow the process to terminate gracefully, followed by <code>SIGINT</code> if necessary. If both signals fail, <code>SIGKILL</code> should be used as a last resort. The <code>SIGKILL</code> signal cannot be caught or ignored, and it forcibly terminates the process without giving it an opportunity to perform any self-cleanup.</p>
</blockquote>
<blockquote>
<p>Here are some commonly used commands related to terminating processes:</p>
</blockquote>
<ul>
<li><code>kill PID</code>: Sends the <code>SIGTERM</code> signal to the specified process, requesting it to terminate gracefully.</li>
<li><code>kill -SIGKILL PID</code>: Sends the <code>SIGKILL</code> signal to forcefully terminate the specified process immediately (cannot be caught or ignored).</li>
<li><code>killall process_name</code>: Sends <code>SIGTERM</code> to all processes matching the given name, attempting a graceful termination.</li>
<li><code>killall -SIGKILL process_name</code>: Sends <code>SIGKILL</code> to all processes matching the given name, forcing termination.</li>
<li><code>pgrep process_name</code>: Searches for processes matching the given name and returns their PIDs.</li>
<li><code>pgrep -u user_name process_name</code>: Searches for processes with the specified name owned by a specific user.</li>
<li><code>pkill process_name</code>: Sends <code>SIGTERM</code> to all processes matching the given name, similar to <code>killall</code>.</li>
<li><code>pkill -SIGKILL process_name</code>: Sends <code>SIGKILL</code> to all processes matching the given name, forcing termination.</li>
<li><code>pkill -u user_name</code>: Sends a signal to all processes owned by the specified user.</li>
<li><code>pstree -p</code>: Displays the process tree with PIDs included.</li>
<li><code>pstree -u</code>: Displays the process tree with associated user names.</li>
</ul>
<blockquote>
<p>In real-world scenarios, system administrators can forcibly terminate a user&rsquo;s session to log them out. The following example demonstrates this process:</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>who -u                  <span style="color:#75715e"># Lists all active user sessions along with their associated PIDs.</span>
</span></span><span style="display:flex;"><span>pkill -t pts/0          <span style="color:#75715e"># Sends SIGTERM (default) to processes attached to terminal pts/0.</span>
</span></span><span style="display:flex;"><span>pkill -SIGINT -t pts/0  <span style="color:#75715e"># If necessary, sends SIGINT to the same terminal.</span>
</span></span><span style="display:flex;"><span>pkill -SIGKILL -t pts/0 <span style="color:#75715e"># As a last resort, sends SIGKILL to forcefully terminate the session.</span>
</span></span></code></pre></div>
</details></p>

<hr>
<h2 id="monitor-process-activity">Monitor Process Activity<a hidden class="anchor" aria-hidden="true" href="#monitor-process-activity">#</a></h2>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  <blockquote>
<p>In Linux, the <strong>load average</strong> indicates the system&rsquo;s workload over a period of time, measuring how many processes are either actively running or waiting to be executed by the CPU. The load average is typically represented by three numbers, corresponding to the system load over the past 1, 5, and 15 minutes. A load average of <strong>1.0 per CPU</strong> is considered fully utilized, meaning that each CPU is handling one process at a time. For example, if a system has 2 CPUs, a load average of <strong>2.0</strong> would mean that the system is fully utilized. To inspect the number of CPUs in the system, the <code>lscpu</code> command can be used.</p>
</blockquote>
<blockquote>
<p>For instance, if a system has 2 CPUs and the <code>uptime</code> command returns:</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>20:41:31 up 5:29, <span style="color:#ae81ff">3</span> users, load average: 3.32, 1.90, 0.32
</span></span></code></pre></div><ul>
<li>The load average for the last minute is <strong>3.32</strong>, which means the total load on the system is 3.32. With 2 CPUs, the <strong>per-CPU load average</strong> for the last minute is <strong>1.66</strong> (3.32 ÷ 2). This suggests the system is overloaded since the per-CPU load exceeds 1.0.</li>
<li>The load average for the last 5 minutes is <strong>1.90</strong>, and the <strong>per-CPU load average</strong> for this period is <strong>0.95</strong> (1.90 ÷ 2), indicating that the system is closer to optimal usage during this time.</li>
<li>The load average for the last 15 minutes is <strong>0.30</strong>, and the <strong>per-CPU load average</strong> is <strong>0.16</strong> (0.32 ÷ 2), suggesting the system is underutilized.</li>
</ul>

</details></p>

<hr>
<h1 id="9-control-services--daemons">9. Control Services &amp; Daemons<a hidden class="anchor" aria-hidden="true" href="#9-control-services--daemons">#</a></h1>


<p><details >
  <summary markdown="span">SHOW CONTENTS</summary>
  
</details></p>

<hr>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://signalyu.github.io/tags/engineering--technology/">Engineering &amp; Technology</a></li>
      <li><a href="https://signalyu.github.io/tags/computer-science/">Computer Science</a></li>
      <li><a href="https://signalyu.github.io/tags/linux/">Linux</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/system-design/1-system-design/">
    <span class="title">« PREV</span>
    
    <br>
    <span>System Design</span>
  </a>
  <a class="next" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/devops/docker/1-docker/">
    <span class="title">NEXT »</span>
    
    <br>
    <span>Docker</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://signalyu.github.io/">Signal&#39;s Blog</a></span> · 
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>

</body>
</html>
