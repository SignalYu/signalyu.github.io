<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Database Design | Signal&#39;s Blog</title>
<meta name="keywords" content="Engineering &amp; Technology, Computer Science, Database">
<meta name="description" content="Introduction to Databases A database is a collection of data that is stored, managed, and accessed electronically. It typically contains one or more tables, which resemble Excel or Google sheets, with data organized into rows and columns. As the number of tables grows, managing the database can become complex, making it essential to design a scalable and maintainable strucutre.
Databases can be broadly categorized into two types: Relational database, primarily used for real-time data updates and transactions, and data warehouse, optimized for data analysis and reporting purposes.">
<meta name="author" content="Signal Yu">
<link rel="canonical" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/database/database-design/1-database-design/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5a0ace7f2dc73037e40ceea0eb0d119b5d798dba2da38d9129982a8cf9fa07a5.css" integrity="sha256-WgrOfy3HMDfkDO6g6w0Rm115jboto42RKZgqjPn6B6U=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://signalyu.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://signalyu.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://signalyu.github.io/favicon-32x32">
<link rel="apple-touch-icon" href="https://signalyu.github.io/apple-touch-icon">
<link rel="mask-icon" href="https://signalyu.github.io/favicon.io">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/database/database-design/1-database-design/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css"
    integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"
    integrity="sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd"
    crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js"
    integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk"
    crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: true }
            ],
            
            throwOnError: false,
            strict: false
        });
    });
</script>

  

<meta property="og:title" content="Database Design" />
<meta property="og:description" content="Introduction to Databases A database is a collection of data that is stored, managed, and accessed electronically. It typically contains one or more tables, which resemble Excel or Google sheets, with data organized into rows and columns. As the number of tables grows, managing the database can become complex, making it essential to design a scalable and maintainable strucutre.
Databases can be broadly categorized into two types: Relational database, primarily used for real-time data updates and transactions, and data warehouse, optimized for data analysis and reporting purposes." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/database/database-design/1-database-design/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-05-22T21:07:21+08:00" />
<meta property="article:modified_time" content="2024-05-22T21:07:21+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Database Design"/>
<meta name="twitter:description" content="Introduction to Databases A database is a collection of data that is stored, managed, and accessed electronically. It typically contains one or more tables, which resemble Excel or Google sheets, with data organized into rows and columns. As the number of tables grows, managing the database can become complex, making it essential to design a scalable and maintainable strucutre.
Databases can be broadly categorized into two types: Relational database, primarily used for real-time data updates and transactions, and data warehouse, optimized for data analysis and reporting purposes."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://signalyu.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Database Design",
      "item": "https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/database/database-design/1-database-design/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Database Design",
  "name": "Database Design",
  "description": "Introduction to Databases A database is a collection of data that is stored, managed, and accessed electronically. It typically contains one or more tables, which resemble Excel or Google sheets, with data organized into rows and columns. As the number of tables grows, managing the database can become complex, making it essential to design a scalable and maintainable strucutre.\nDatabases can be broadly categorized into two types: Relational database, primarily used for real-time data updates and transactions, and data warehouse, optimized for data analysis and reporting purposes.",
  "keywords": [
    "Engineering \u0026 Technology", "Computer Science", "Database"
  ],
  "articleBody": "Introduction to Databases A database is a collection of data that is stored, managed, and accessed electronically. It typically contains one or more tables, which resemble Excel or Google sheets, with data organized into rows and columns. As the number of tables grows, managing the database can become complex, making it essential to design a scalable and maintainable strucutre.\nDatabases can be broadly categorized into two types: Relational database, primarily used for real-time data updates and transactions, and data warehouse, optimized for data analysis and reporting purposes.\nData Modeling Data modeling is the process of creating a conceptual representation of data structures, relationships, and rule to meet business requirements. It serves as a blueprint for designing and managing a database.\nThere are three types of data models: conceptual, logical, and physical. The conceptual data model provides a high-level overview, specifying relationships between objects without technical details. The logical data model refine the conceptual data model by adding more detail, such as fields for each object. The physical data model describe the internal schema of the database, including table structures, storage details, and implementation specifics.\n--- title: Conceptual Data Model --- erDiagram Customer ||--o{ Order : places Order ||--|{ Product : contains --- title: Logical Data Model --- erDiagram Customer { int customerId string name string email } Order { int orderId date orderDate float totalAmount } Product { int productId string productName float price } Customer ||--o{ Order : places Order ||--|{ Product : contains --- title: Physical Data Model --- erDiagram Customer { int customerId PK varchar name varchar email } Order { int orderId PK date orderDate float totalAmount int customerId FK } Product { int productId PK varchar productName decimal price } OrderItem { int orderItemId PK int orderId FK int productId FK int quantity } Customer ||--o{ Order : places Order ||--|{ OrderItem : includes OrderItem ||--|{ Product : contains Example: University Enrollment Management System Entities In database design, an entity is a distinct object that typically represents real-world objects, events, or concepts. Entities are represented as tables in a relational database, and they are similar to classes in object-oriented design. Each row in the table represents an instance of the entity. Each entity has attributes that describe its characteristics. For example, a Student entity may have attributes like student_id, first_name, last_name, and date_of_birth, among others. Entities can be related to one another, and these relationships are often captured using foreign keys or relationship tables, which link entities together based on logical associations. For example, a Student might be linked to a Course through an enrollment relationship.\nIdentifying Entities Identifying entities in database design is a crucial step, as entities form the foundation of a database. A useful approach for identifying entities is to clarify the design objectives and look for nouns in the objective statement. For example, consider the University Enrollment Management System. The objective statement might be:\n“The University Enrollment Management System” is designed to help a university track enrolled students, the subjects they are taking, and the teachers assigned to those subjects\".\nIn this sentence, the nouns university, student, subject, and teacher are potential entities, as they represent key objects or concepts that the system needs to track.\n--- title: Identifying Entities --- erDiagram UNIVERSITY STUDENT erDiagram TEACHER SUBJECT Defining Attributes In database design, an attribute describes the characteristics of an entity. In a relational database, attributes are typically represented as columns in a table. Defining entity attributes is a crucial step in database design, as it ensures that the entity captures all the necessary details required by the system. When defining attributes, it’s important to consider what properties or characteristics the entity possesses.\nFor example, in a University Enrollment Management System, the Student entity might have attributes like first_name, last_name, date_of_birth, and address. After identifying the necessary attributes, the next step is to specify the approapriate data type for each attribute. For instance, attributes like first_name, last_name, and address would typically use the TEXT data type, while the date_of_birth attribute would be defined with the DATE data type.\n--- title: Defining Attributes --- erDiagram UNIVERSITY { string name string address } STUDENT { string first_name string last_name date date_of_birth string address } erDiagram SUBJECT { string subject_name string category string students_enrolled } TEACHER { string first_name string last_name date date_of_birth string address string subject_taught } Normalization Normalization in database design is the process of organizing the attributes of entities and their relationships to reduce data redundency, avoid operational anomalies, and improve data integrity. Normalization involves decomposing a large, complex database into smaller, simpler tables while preserving the relationships between entities. This decomposition follows a set of rules called normal forms. In real-world database design, the three most commonly used normal normal forms are First Normal Form (1NF), Second Normal Form (2NF), and Third Normal Form (3NF).\nFirst Normal Form First Normal Form (1NF) is a property of a relational database table that ensures the table is structured properly. It follows the following conditions:\nEach column must contain atomic values, meaning that the value in a field should be indivisible and not contain sets or lists of values. Each row must be unique, which can be achieved by using a primary key to uniquely identify each record. All values in single column should be of the same data type. A Primary Key is a column (or a set of columns) in a relational database table that uniquely identifies each row in that table. It satisfies the following conditions:\nThe value in the primary key must be unique for each row. The value in the primary key must not be null for any record. The value in the primary key should generally be immutable, meaning it should not change once assigned. When designing tables, assess if any combination of columns can be used to uniquely identify a record. If such a combination exists, those columns can form the primary key. If no suitable combination is found, create a new column to serve as the primary key.\nA primary key can be a set of columns when a single column is not sufficient to uniquely identify a row. For example, in the following table, neither the StudentID nor the CourseID alone can uniquely identify a row, because a student might enroll mutiple courses, and a course can have multiple students. However, the combination of both columns can uniquely identify each enrollment record.\nStudentID CourseID EnrollmentDate 1 CS101 2024-01-01 1 MATH101 2024-01-02 2 CS101 2024-01-03 1NF: Student In the following Student table, there is no single field that can uniquely identify a row. Therefore, it is necessary to add a new field. such as StudentID, to ensure each row has a unique identifier. Additionally, the Address field may contain multiple values, such as unit number, street number, street name, suburb, city, state, country, and postcode. To comply with the First Normal Form (1NF), the Address firld must be divided into multiple separate columns, ensuring that each column contains only atomic values.\n--- title: Violation of 1NF - Student --- erDiagram STUDENT { string first_name string last_name date date_of_birth string address } --- title: Comply with 1NF - Student --- erDiagram STUDENT { number student_id PK string first_name string last_name date date_of_birth number unit_number number street_number string street_name string suburb string city string state string country string postcode } 1NF: Subject --- title: Violation of 1NF - Subject --- erDiagram SUBJECT { string subject_name string category string students_enrolled } --- title: Comply with 1NF - Subject --- erDiagram SUBJECT { number subject_id PK string subject_name string category string students_enrolled } 1NF: Teacher --- title: Violation of 1NF - Teacher --- erDiagram TEACHER { string first_name string last_name date date_of_birth string address string subject_taught } --- title: Comply with 1NF - Teacher --- erDiagram TEACHER { number teacher_id PK string first_name string last_name date date_of_birth number unit_number number street_number string street_name string suburb string city string state string country string postcode string subject_taught } 1NF: University --- title: Violation of 1NF - University --- erDiagram UNIVERSITY { string name string address } --- title: Comply with 1NF - University --- erDiagram UNIVERSITY { number university_id PK string name number unit_number number street_number string street_name string suburb string city string state string country string postcode } Second Normal Form The Second Normal Form (2NF) in database design is a level of normalization that builds upon the First Normal Form (1NF). A table is in 2NF if every non-key attribute is fully functionally dependent on the entire primary key, not just part of it, particularly in tables with composite primary keys (a key made up of two or more columns).\nRelationships Relationship in database design refers to the association between different entities (tables) in a database. It defines how data in one table is related to data in another table, enabling efficient organization and retrival of data. Relationships are established through a foreign key, which is a column in one table that references the primary key of another table. There are four main types of relationships: One-to-One (1:1), One-to-Many (1:N), Many-to-Many (N:M), and Self-Reference.\nIn a One to One relationship, each record in one table is related to exactly one record in another table. For example, consider a Person table and a Passport table, where each person has one unique passport, and each passport is associated with only one person. This type of relationship is relatively rare in real-world database design.\nThe One to Many relationship is the most common type in real-world database design. In a 1:N relationship, one record in a table can be linked to multiple records in another table. For example, in a Department table and an Employee table, one department can have many employees, but each employee blongs to exactly one department. This is a typical relational model for most business applications.\nThe Many-to-Many relationship is common but often requires an intermediary table to properly represent the association. In an N:M relationship, multiple records in one table can be asoociated with multiple records in another table. For instance, in a Student table and a Course table, a student can enroll in many courses, and each course can have many students enrolled. This relationship is typically handled by a joining table, such as Student_Course.\nIn a Self-Referencing relationship, a table is related to itself. In other words, a record in the table is associated with another record in the same table. For example, in an Employee table, each employee has a Manager, and that manager may also have a manager. This type of relationship is useful for representing hierarchical structures, such as organizational charts.\nIn database design, a foreign key is a column that references the primary key of another table. It is used to establish a relationship between two tables, ensuring referential integrity and maintaining consistent data across the database.\n2NF: Subject \u0026 Category In the following Subject table, the subject_name is dependent on the primary key subject_id, but the category is not fully dependent on the primary key, which violates 2NF. To resolve this issue, a new Category table should be created with two fields: category_id as the primary key and subject_id as a foreign key. The two tables have a One-to-Many relationship, where each category can have many subjects, while each subject bleongs to exactly one category.\n--- title: Violation of 2NF - Subject --- erDiagram SUBJECT { number subject_id PK string subject_name string category } --- title: Comply with 2NF - Subject --- erDiagram SUBJECT { number subject_id PK string subject_name number category_id FK } CATEGORY { number category_id PK string category_name } CATEGORY ||--|{ SUBJECT : \"\" 2NF: Student \u0026 Subject In the following Subject table, the subject_id and students_enrolled create a Many-to-Many relationship. However, relational databases should not represent Many-to-Many relationships directly in s single table. This is because a single table cannot handle multiple instances of related data (such as multiple students enrolled in multiple subjects) within a single field. To resolve this issue, a junction table is introduced. It breaks down the Many-to-Many relationship into two One-to-Many relationships, ensuring data integrity and normalization.\n--- title: Violation of 2NF - Subject --- erDiagram SUBJECT { number subject_id PK string subject_name string students_enrolled } subject_id subject_name students_name 1 Math Alice, Bob, Charlie 2 History David, Emily, Frank, Grace 3 Science Helen, Ian In the above table, the students_enrolled field violates First Normal Form (1NF), which requires each column to contain only atomic values. Additionally, this design leads to data redundancy. For example, if the student Alice enrolls in multiple courses such as Math, History, and Science. her name will be repeated in each row, causing unnecessary duplication of data.\nFurthermore, this design makes data manipulation more complex. For instance, when a student drops a course or a new student enrolls in a course, the list of students in the students_enrolled column must be manually updated, which is error-prone and inefficient.\n--- title: Comply with 2NF - Subject --- erDiagram SUBJECT { number subject_id PK string subject_name } STUDENT { number student_id PK string students_enrolled } ENROLLMENT { number subject_id FK number student_id FK } SUBJECT ||--|{ ENROLLMENT : \"has\" STUDENT ||--|{ ENROLLMENT : \"enrolled in\" Comply with 2NF: Real-World Example 2NF: Teacher --- title: Violation of 2NF - Teacher (subject_taught) --- erDiagram TEACHER { number teacher_id string first_name string last_name date date_of_birth string subject_taught } --- title: Comply with 2NF - Teacher --- erDiagram TEACHER { number teacher_id string first_name string last_name date date_of_birth } SUBJECT { number subject_id PK string subject_name number category_id FK number teacher_id FK } TEACHER ||--|{ SUBJECT : \"teaches\" 2NF: University --- title: Comply with 2NF - UNIVERSITY --- erDiagram UNIVERSITY { number university_id PK string name } SUBJECT { number subject_id PK string subject_name number category_id FK number teacher_id FK number university_id FK } UNIVERSITY ||--|{ SUBJECT : \"\" Third Normal From Third Normal Form (3NF) is a level of normalization that satisfies Second Normal Form (2NF) and eliminates transitive dependencies. In simpler terms, a non-key attribute in a table should not depend on another non-key attrubute. For example, if A $\\rightarrow$ B and B $\\rightarrow$ C, then A $\\rightarrow$ C, which means C should be moved to a separate table to avoid redundency. This process helps reduce data redundency and improves the efficiency of relational databases.\n3NF: Student In the following Student table, the non-key attributes (unit_number, street_number, street_name, suburb, city, state, country, and postcode) are not directly dependent on the primary key student_id; instead, they depend on the student’s address. This results in a transitive dependency, which violates 3NF. Furthermore, since multiple students may share the same address, these address attributes will be repeated for each student, leading to data redundency.\n--- title: Violation of 3NF - Student --- erDiagram STUDENT { number student_id PK string first_name string last_name date date_of_birth number unit_number number street_number string street_name string suburb string city string state string country string postcode } --- title: Comply with 3NF - Student --- erDiagram STUDENT { number student_id PK string first_name string last_name date date_of_birth number address_id FK } ADDRESS { number address_id PK number unit_number number street_number string street_name string suburb string city string state string country string postcode } STUDENT ||--|{ ADDRESS : \"\" 3NF: Teacher --- title: Comply with 3NF - Teacher --- erDiagram TEACHER { number teacher_id PK string first_name string last_name date date_of_birth number address_id FK } ADDRESS { number address_id PK number unit_number number street_number string street_name string suburb string city string state string country string postcode } TEACHER ||--|{ ADDRESS : \"\" 3NF: University --- title: Comply with 3NF - University --- erDiagram UNIVERSITY { number university_id PK string name number address_id FK } ADDRESS { number address_id PK number unit_number number street_number string street_name string suburb string city string state string country string postcode } UNIVERSITY ||--|{ ADDRESS : \"\" Design Considerations Determine Data Types \u0026 Precision Determining data types and precision in database design is crucial for ensuring optimal storage, performance, and accuracy of data. There are typically three steps to determine the apprpriate data type and precision for a field:\nIdentifying the nature of the field: Determine the type of data the field will store—whether it’s numeric, string, or data/time. For example, the student_id field might be of type INT, while the first_time field might of type CHAR or VARCHAR. Choose the smallest sufficient data type: Select the samllest data type that can accommodate the required values. For example, if a field’s values range from -128 to 127, use TINYINT instead of INT to optimize performance and storage efficiency. Set precision and scale for numeric values: For numeric fields, it’s important to define the precision (total number of digits) and scale (number of digits after the decimal point). For example, a price field should be set to DECIMAL(10,2), which allows for 10 digits in total, with 2 digits after the decimal point. Integrity Constraints Integrity Constraints in database design are rules that ensure the accuracy, consistency, and validity of data. There are several types of integrity constraints, each serving a specific purpose:\nEntity Integrity Entity Integrity ensures that each record in a table is unique and identifiable. This is achieved by setting a column in a table as a primary key. For example, the student_id field must be unique for each record in the Student table.\nCREATE TABLE Student ( student_id INT PRIMARY KEY, first_name VARCHAR(100), last_name VARCHAR(100) ); Referencial Integrity Referencial Integrity ensures that relationships between tables are maintained consistently. Foreign keys enforce this constraint by ensuring that a value in one table corresbonds to a valid value in another table. For example, the student_id field in the Enrollment table serves as a foreign key referencing the primary key student_id in the Student table.\nCREATE TABLE Enrollment ( enrollment_id INT PRIMARY KEY, student_id INT, course_id INT, FOREIGN KEY (student_id) REFERENCES Students(student_id) ); Domain Integrity Domain Integrity ensures that the data entered in a column matches the defined data type, format, and range. This is enforced using data types. default values. and check constraints. For example, the price field should only store positive values.\nCREATE TABLE Product ( product_id INT PRIMARY KEY, product_name VARCHAR(100), price DECIMAL(10, 2) CHECK (price \u003e 0) ); User-Defined Integrity User-defined integrity enforces business rules specific to the application or domain. For instance, in the Enrollment table, the combination of student_id and course_id should be unique to prevent a student from enrolling in the same course more than once.\nCREATE TABLE Enrollment ( enrollment_id INT PRIMARY KEY, student_id INT, course_id INT, UNIQUE (student_id, course_id) ); Null Integrity Null integrity ensures that certain fields cannot store NULL values. This is enforced by defining the column with the NOT NULL constraint. For example, the student_id field in the Student table must not be NULL because it is used to identify each record.\nCREATE TABLE Student ( student_id INT PRIMARY KEY NOT NULL, first_name VARCHAR(100) NOT NULL, last_name VARCHAR(100) NOT NULL ); ",
  "wordCount" : "3154",
  "inLanguage": "en",
  "datePublished": "2024-05-22T21:07:21+08:00",
  "dateModified": "2024-05-22T21:07:21+08:00",
  "author":{
    "@type": "Person",
    "name": "Signal Yu"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/database/database-design/1-database-design/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Signal's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://signalyu.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://signalyu.github.io/" accesskey="h" title="Signal&#39;s Blog (Alt + H)">
                <img src="https://signalyu.github.io/apple-touch-icon.png" alt="" aria-label="logo"
                    height="40">Signal&#39;s Blog</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://signalyu.github.io/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://signalyu.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://signalyu.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://signalyu.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://signalyu.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Database Design
    </h1>
    <div class="post-meta"><span title='2024-05-22 21:07:21 +0800 HKT'>May 22 2024</span>&nbsp;·&nbsp;Signal Yu

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#introduction-to-databases" aria-label="Introduction to Databases">Introduction to Databases</a></li>
                <li>
                    <a href="#data-modeling" aria-label="Data Modeling">Data Modeling</a></li>
                <li>
                    <a href="#example-university-enrollment-management-system" aria-label="Example: University Enrollment Management System">Example: University Enrollment Management System</a><ul>
                        
                <li>
                    <a href="#entities" aria-label="Entities">Entities</a><ul>
                        
                <li>
                    <a href="#identifying-entities" aria-label="Identifying Entities">Identifying Entities</a></li>
                <li>
                    <a href="#defining-attributes" aria-label="Defining Attributes">Defining Attributes</a></li></ul>
                </li>
                <li>
                    <a href="#normalization" aria-label="Normalization">Normalization</a><ul>
                        
                <li>
                    <a href="#first-normal-form" aria-label="First Normal Form">First Normal Form</a><ul>
                        
                <li>
                    <a href="#1nf-student" aria-label="1NF: Student">1NF: Student</a></li>
                <li>
                    <a href="#1nf-subject" aria-label="1NF: Subject">1NF: Subject</a></li>
                <li>
                    <a href="#1nf-teacher" aria-label="1NF: Teacher">1NF: Teacher</a></li>
                <li>
                    <a href="#1nf-university" aria-label="1NF: University">1NF: University</a></li></ul>
                </li>
                <li>
                    <a href="#second-normal-form" aria-label="Second Normal Form">Second Normal Form</a><ul>
                        
                <li>
                    <a href="#relationships" aria-label="Relationships">Relationships</a></li>
                <li>
                    <a href="#2nf-subject--category" aria-label="2NF: Subject &amp; Category">2NF: Subject &amp; Category</a></li>
                <li>
                    <a href="#2nf-student--subject" aria-label="2NF: Student &amp; Subject">2NF: Student &amp; Subject</a></li>
                <li>
                    <a href="#2nf-teacher" aria-label="2NF: Teacher">2NF: Teacher</a></li>
                <li>
                    <a href="#2nf-university" aria-label="2NF: University">2NF: University</a></li></ul>
                </li>
                <li>
                    <a href="#third-normal-from" aria-label="Third Normal From">Third Normal From</a><ul>
                        
                <li>
                    <a href="#3nf-student" aria-label="3NF: Student">3NF: Student</a></li>
                <li>
                    <a href="#3nf-teacher" aria-label="3NF: Teacher">3NF: Teacher</a></li>
                <li>
                    <a href="#3nf-university" aria-label="3NF: University">3NF: University</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#design-considerations" aria-label="Design Considerations">Design Considerations</a><ul>
                        
                <li>
                    <a href="#determine-data-types--precision" aria-label="Determine Data Types &amp; Precision">Determine Data Types &amp; Precision</a></li>
                <li>
                    <a href="#integrity-constraints" aria-label="Integrity Constraints">Integrity Constraints</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="introduction-to-databases">Introduction to Databases<a hidden class="anchor" aria-hidden="true" href="#introduction-to-databases">#</a></h1>
<blockquote>
<p>A <strong>database</strong> is a collection of data that is stored, managed, and accessed electronically. It typically contains one or more tables, which resemble Excel or Google sheets, with data organized into rows and columns. As the number of tables grows, managing the database can become complex, making it essential to design a scalable and maintainable strucutre.</p>
</blockquote>
<blockquote>
<p>Databases can be broadly categorized into two types: <strong>Relational database</strong>, primarily used for real-time data updates and transactions, and <strong>data warehouse</strong>, optimized for data analysis and reporting purposes.</p>
</blockquote>
<hr>
<h1 id="data-modeling">Data Modeling<a hidden class="anchor" aria-hidden="true" href="#data-modeling">#</a></h1>
<blockquote>
<p><strong>Data modeling</strong> is the process of creating a conceptual representation of data structures, relationships, and rule to meet business requirements. It serves as a blueprint for designing and managing a database.</p>
</blockquote>
<blockquote>
<p>There are three types of data models: <strong>conceptual</strong>, <strong>logical</strong>, and <strong>physical</strong>. The <strong>conceptual data model</strong> provides a high-level overview, specifying relationships between objects without technical details. The <strong>logical data model</strong> refine the conceptual data model by adding more detail, such as fields for each object. The <strong>physical data model</strong> describe the internal schema of the database, including table structures, storage details, and implementation specifics.</p>
</blockquote>
<pre class="mermaid">---
title: Conceptual Data Model
---
erDiagram
    Customer ||--o{ Order : places
    Order ||--|{ Product : contains
</pre>
<pre class="mermaid">---
title: Logical Data Model
---
erDiagram
    Customer {
        int customerId
        string name
        string email
    }
    Order {
        int orderId
        date orderDate
        float totalAmount
    }
    Product {
        int productId
        string productName
        float price
    }
    Customer ||--o{ Order : places
    Order ||--|{ Product : contains
</pre>
<pre class="mermaid">---
title: Physical Data Model
---
erDiagram
    Customer {
        int customerId PK
        varchar name
        varchar email
    }
    Order {
        int orderId PK
        date orderDate
        float totalAmount
        int customerId FK
    }
    Product {
        int productId PK
        varchar productName
        decimal price
    }
    OrderItem {
        int orderItemId PK
        int orderId FK
        int productId FK
        int quantity
    }
    Customer ||--o{ Order : places
    Order ||--|{ OrderItem : includes
    OrderItem ||--|{ Product : contains
</pre>
<hr>
<h1 id="example-university-enrollment-management-system">Example: University Enrollment Management System<a hidden class="anchor" aria-hidden="true" href="#example-university-enrollment-management-system">#</a></h1>
<h2 id="entities">Entities<a hidden class="anchor" aria-hidden="true" href="#entities">#</a></h2>
<blockquote>
<p>In database design, an <strong>entity</strong> is a distinct object that typically represents real-world objects, events, or concepts. Entities are represented as tables in a relational database, and they are similar to classes in object-oriented design. Each row in the table represents an instance of the entity. Each entity has attributes that describe its characteristics. For example, a <code>Student</code> entity may have attributes like <code>student_id</code>, <code>first_name</code>, <code>last_name</code>, and <code>date_of_birth</code>, among others. Entities can be related to one another, and these relationships are often captured using foreign keys or relationship tables, which link entities together based on logical associations. For example, a <code>Student</code> might be linked to a <code>Course</code> through an enrollment relationship.</p>
</blockquote>
<hr>
<h3 id="identifying-entities">Identifying Entities<a hidden class="anchor" aria-hidden="true" href="#identifying-entities">#</a></h3>
<blockquote>
<p><strong>Identifying entities</strong> in database design is a crucial step, as entities form the foundation of a database. A useful approach for identifying entities is to <strong>clarify the design objectives and look for nouns</strong> in the objective statement. For example, consider the <strong>University Enrollment Management System</strong>. The objective statement might be:</p>
</blockquote>
<blockquote>
<p>&ldquo;The <strong>University Enrollment Management System</strong>&rdquo; is designed to help a <em><strong>university</strong></em> track enrolled <em><strong>students</strong></em>, the <em><strong>subjects</strong></em> they are taking, and the <em><strong>teachers</strong></em> assigned to those subjects&quot;.</p>
</blockquote>
<blockquote>
<p>In this sentence, the nouns <code>university</code>, <code>student</code>, <code>subject</code>, and <code>teacher</code> are potential entities, as they represent key objects or concepts that the system needs to track.</p>
</blockquote>
<pre class="mermaid">---
title: Identifying Entities
---
erDiagram
    UNIVERSITY 
    STUDENT
</pre>
<pre class="mermaid">erDiagram
    TEACHER
    SUBJECT
</pre>
<hr>
<h3 id="defining-attributes">Defining Attributes<a hidden class="anchor" aria-hidden="true" href="#defining-attributes">#</a></h3>
<blockquote>
<p>In database design, an attribute describes the characteristics of an entity. In a relational database, attributes are typically represented as columns in a table. Defining entity attributes is a crucial step in database design, as it ensures that the entity captures all the necessary details required by the system. When defining attributes, it&rsquo;s important to consider what properties or characteristics the entity possesses.</p>
</blockquote>
<blockquote>
<p>For example, in a <strong>University Enrollment Management System</strong>, the <strong>Student</strong> entity might have attributes like <code>first_name</code>, <code>last_name</code>, <code>date_of_birth</code>, and <code>address</code>. After identifying the necessary attributes, the next step is to specify the approapriate data type for each attribute. For instance, attributes like <code>first_name</code>, <code>last_name</code>, and <code>address</code> would typically use the <code>TEXT</code> data type, while the <code>date_of_birth</code> attribute would be defined with the <code>DATE</code> data type.</p>
</blockquote>
<pre class="mermaid">---
title: Defining Attributes
---
erDiagram
    UNIVERSITY {
        string name
        string address
    }
    STUDENT {
        string first_name
        string last_name
        date date_of_birth
        string address
    }
</pre>
<pre class="mermaid">erDiagram
    SUBJECT {
        string subject_name
        string category
        string students_enrolled
    }

    TEACHER {
        string first_name
        string last_name
        date date_of_birth
        string address
        string subject_taught
    }    
</pre>
<hr>
<h2 id="normalization">Normalization<a hidden class="anchor" aria-hidden="true" href="#normalization">#</a></h2>
<blockquote>
<p><strong>Normalization</strong> in database design is the process of organizing the attributes of entities and their relationships to reduce data redundency, avoid operational anomalies, and improve data integrity. Normalization involves decomposing a large, complex database into smaller, simpler tables while preserving the relationships between entities. This decomposition follows a set of rules called <strong>normal forms</strong>. In real-world database design, the three most commonly used normal normal forms are <strong>First Normal Form (1NF)</strong>, <strong>Second Normal Form (2NF)</strong>, and <strong>Third Normal Form (3NF)</strong>.</p>
</blockquote>
<h3 id="first-normal-form">First Normal Form<a hidden class="anchor" aria-hidden="true" href="#first-normal-form">#</a></h3>
<blockquote>
<p><strong>First Normal Form (1NF)</strong> is a property of a relational database table that ensures the table is structured properly. It follows the following conditions:</p>
</blockquote>
<ol>
<li><strong>Each column must contain atomic values</strong>, meaning that the value in a field should be indivisible and not contain sets or lists of values.</li>
<li><strong>Each row must be unique</strong>, which can be achieved by using a primary key to uniquely identify each record.</li>
<li><strong>All values in single column should be of the same data type.</strong></li>
</ol>
<hr>
<blockquote>
<p>A <strong>Primary Key</strong> is a column (or a set of columns) in a relational database table that uniquely identifies each row in that table. It satisfies the following conditions:</p>
</blockquote>
<ol>
<li>The value in the primary key must be unique for each row.</li>
<li>The value in the primary key must not be null for any record.</li>
<li>The value in the primary key should generally be immutable, meaning it should not change once assigned.</li>
</ol>
<blockquote>
<p>When designing tables, assess if any combination of columns can be used to uniquely identify a record. If such a combination exists, those columns can form the primary key. If no suitable combination is found, create a new column to serve as the primary key.</p>
</blockquote>
<hr>
<blockquote>
<p>A primary key can be a set of columns when a single column is not sufficient to uniquely identify a row. For example, in the following table, neither the <code>StudentID</code> nor the <code>CourseID</code> alone can uniquely identify a row, because a student might enroll mutiple courses, and a course can have multiple students. However, the combination of both columns can uniquely identify each enrollment record.</p>
</blockquote>
<table>
<thead>
<tr>
<th>StudentID</th>
<th>CourseID</th>
<th>EnrollmentDate</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>CS101</td>
<td>2024-01-01</td>
</tr>
<tr>
<td>1</td>
<td>MATH101</td>
<td>2024-01-02</td>
</tr>
<tr>
<td>2</td>
<td>CS101</td>
<td>2024-01-03</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="1nf-student">1NF: Student<a hidden class="anchor" aria-hidden="true" href="#1nf-student">#</a></h4>
<blockquote>
<p>In the following <code>Student</code> table, there is no single field that can uniquely identify a row. Therefore, it is necessary to add a new field. such as <code>StudentID</code>, to ensure each row has a unique identifier. Additionally, the <code>Address</code> field may contain multiple values, such as unit number, street number, street name, suburb, city, state, country, and postcode. To comply with the <strong>First Normal Form (1NF)</strong>, the <code>Address</code> firld must be divided into multiple separate columns, ensuring that each column contains only atomic values.</p>
</blockquote>
<pre class="mermaid">---
title: Violation of 1NF - Student
---
erDiagram
    STUDENT {
        string first_name
        string last_name
        date date_of_birth
        string address
    }    
</pre>
<pre class="mermaid">---
title: Comply with 1NF - Student
---
erDiagram
    STUDENT {
        number student_id PK
        string first_name
        string last_name
        date date_of_birth
        number unit_number
        number street_number
        string street_name
        string suburb
        string city
        string state
        string country
        string postcode
    }    
</pre>
<h4 id="1nf-subject">1NF: Subject<a hidden class="anchor" aria-hidden="true" href="#1nf-subject">#</a></h4>
<pre class="mermaid">---
title: Violation of 1NF - Subject
---
erDiagram
    SUBJECT {
        string subject_name
        string category
        string students_enrolled
    }
</pre>
<pre class="mermaid">---
title: Comply with 1NF - Subject
---
erDiagram
    SUBJECT {
        number subject_id PK
        string subject_name
        string category
        string students_enrolled
    }
</pre>
<h4 id="1nf-teacher">1NF: Teacher<a hidden class="anchor" aria-hidden="true" href="#1nf-teacher">#</a></h4>
<pre class="mermaid">---
title: Violation of 1NF - Teacher
---
erDiagram
    TEACHER {
        string first_name
        string last_name
        date date_of_birth
        string address
        string subject_taught
    }    
</pre>
<pre class="mermaid">---
title: Comply with 1NF - Teacher
---
erDiagram
    TEACHER {
        number teacher_id PK
        string first_name
        string last_name
        date date_of_birth
        number unit_number
        number street_number
        string street_name
        string suburb
        string city
        string state
        string country
        string postcode
        string subject_taught
    }    
</pre>
<h4 id="1nf-university">1NF: University<a hidden class="anchor" aria-hidden="true" href="#1nf-university">#</a></h4>
<pre class="mermaid">---
title: Violation of 1NF - University
---
erDiagram
    UNIVERSITY {
        string name
        string address
    }
</pre>
<pre class="mermaid">---
title: Comply with 1NF - University
---
erDiagram
    UNIVERSITY {
        number university_id PK
        string name
        number unit_number
        number street_number
        string street_name
        string suburb
        string city
        string state
        string country
        string postcode
    }    
</pre>
<h3 id="second-normal-form">Second Normal Form<a hidden class="anchor" aria-hidden="true" href="#second-normal-form">#</a></h3>
<blockquote>
<p>The <strong>Second Normal Form (2NF)</strong> in database design is a level of normalization that builds upon the <strong>First Normal Form (1NF)</strong>. A table is in 2NF if every non-key attribute is fully functionally dependent on the entire primary key, not just part of it, particularly in tables with composite primary keys (a key made up of two or more columns).</p>
</blockquote>
<h4 id="relationships">Relationships<a hidden class="anchor" aria-hidden="true" href="#relationships">#</a></h4>
<blockquote>
<p><strong>Relationship</strong> in database design refers to the association between different entities (tables) in a database. It defines how data in one table is related to data in another table, enabling efficient organization and retrival of data. Relationships are established through a <strong>foreign key</strong>, which is a column in one table that references the <strong>primary key</strong> of another table. There are four main types of relationships: <strong>One-to-One (1:1)</strong>, <strong>One-to-Many (1:N)</strong>, <strong>Many-to-Many (N:M)</strong>, and <strong>Self-Reference</strong>.</p>
</blockquote>
<blockquote>
<p>In a <strong>One to One</strong> relationship, each record in one table is related to exactly one record in another table. For example, consider a <code>Person</code> table and a <code>Passport</code> table, where each person has one unique passport, and each passport is associated with only one person. This type of relationship is relatively rare in real-world database design.</p>
</blockquote>
<blockquote>
<p>The <strong>One to Many</strong> relationship is the most common type in real-world database design. In a 1:N relationship, one record in a table can be linked to multiple records in another table. For example, in a <code>Department</code> table and an <code>Employee</code> table, one department can have many employees, but each employee blongs to exactly one department. This is a typical relational model for most business applications.</p>
</blockquote>
<blockquote>
<p>The <strong>Many-to-Many</strong> relationship is common but often requires an intermediary table to properly represent the association. In an N:M relationship, multiple records in one table can be asoociated with multiple records in another table. For instance, in a <code>Student</code> table and a <code>Course</code> table, a student can enroll in many courses, and each course can have many students enrolled. This relationship is typically handled by a joining table, such as <code>Student_Course</code>.</p>
</blockquote>
<blockquote>
<p>In a <strong>Self-Referencing</strong> relationship, a table is related to itself. In other words, a record in the table is associated with another record in the same table. For example, in an <code>Employee</code> table, each employee has a <code>Manager</code>, and that manager may also have a manager. This type of  relationship is useful for representing hierarchical structures, such as organizational charts.</p>
</blockquote>
<hr>
<blockquote>
<p>In database design, a <strong>foreign key</strong> is a column that references the primary key of another table. It is used to establish a relationship between two tables, ensuring referential integrity and maintaining consistent data across the database.</p>
</blockquote>
<hr>
<h4 id="2nf-subject--category">2NF: Subject &amp; Category<a hidden class="anchor" aria-hidden="true" href="#2nf-subject--category">#</a></h4>
<blockquote>
<p>In the following <code>Subject</code> table, the <code>subject_name</code> is dependent on the primary key <code>subject_id</code>, but the <code>category</code> is not fully dependent on the primary key, which violates 2NF. To resolve this issue, a new <code>Category</code> table should be created with two fields: <code>category_id</code> as the primary key and <code>subject_id</code> as a foreign key. The two tables have a <strong>One-to-Many</strong> relationship, where each category can have many subjects, while each subject bleongs to exactly one category.</p>
</blockquote>
<pre class="mermaid">---
title: Violation of 2NF - Subject
---
erDiagram
    SUBJECT {
        number subject_id PK
        string subject_name
        string category
    }
</pre>
<pre class="mermaid">---
title: Comply with 2NF - Subject
---
erDiagram
    SUBJECT {
        number subject_id PK
        string subject_name
        number category_id FK
    }
    CATEGORY {
        number category_id PK
        string category_name
    }

    CATEGORY ||--|{ SUBJECT : ""
</pre>
<h4 id="2nf-student--subject">2NF: Student &amp; Subject<a hidden class="anchor" aria-hidden="true" href="#2nf-student--subject">#</a></h4>
<blockquote>
<p>In the following <code>Subject</code> table, the <code>subject_id</code> and <code>students_enrolled</code> create a <strong>Many-to-Many</strong> relationship. However, relational databases should not represent <strong>Many-to-Many</strong> relationships directly in s single table. This is because a single table cannot handle multiple instances of related data (such as multiple students enrolled in multiple subjects) within a single field. To resolve this issue, a <strong>junction table</strong> is introduced. It breaks down the <strong>Many-to-Many</strong> relationship into two <strong>One-to-Many</strong> relationships, ensuring data integrity and normalization.</p>
</blockquote>
<pre class="mermaid">---
title: Violation of 2NF - Subject
---
erDiagram
    SUBJECT {
        number subject_id PK
        string subject_name
        string students_enrolled
    }
</pre>
<table>
<thead>
<tr>
<th>subject_id</th>
<th>subject_name</th>
<th>students_name</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Math</td>
<td>Alice, Bob, Charlie</td>
</tr>
<tr>
<td>2</td>
<td>History</td>
<td>David, Emily, Frank, Grace</td>
</tr>
<tr>
<td>3</td>
<td>Science</td>
<td>Helen, Ian</td>
</tr>
</tbody>
</table>
<blockquote>
<p>In the above table, the <code>students_enrolled</code> field violates <strong>First Normal Form (1NF)</strong>, which requires each column to contain only atomic values. Additionally, this design leads to <strong>data redundancy</strong>. For example, if the student <code>Alice</code> enrolls in multiple courses such as Math, History, and Science. her name will be repeated in each row, causing unnecessary duplication of data.</p>
</blockquote>
<blockquote>
<p>Furthermore, this design makes data manipulation more complex. For instance, when a student drops a course or a new student enrolls in a course, the list of students in the <code>students_enrolled</code> column must be manually updated, which is error-prone and inefficient.</p>
</blockquote>
<hr>
<pre class="mermaid">---
title: Comply with 2NF - Subject
---
erDiagram
    SUBJECT {
        number subject_id PK
        string subject_name
    }
    STUDENT {
        number student_id PK
        string students_enrolled
    }
    ENROLLMENT {
        number subject_id FK
        number student_id FK
    }

    SUBJECT ||--|{ ENROLLMENT : "has"
    STUDENT ||--|{ ENROLLMENT : "enrolled in"
</pre>
<h2 id="hahahugoshortcode45s0hbhb"><figure class="align-center ">
    <img loading="lazy" src="/img/database-design/1-comply-with-2nf.png#center" width="100%" height="100%"/> <figcaption>
            Comply with 2NF: Real-World Example
        </figcaption>
</figure>
</h2>
<h4 id="2nf-teacher">2NF: Teacher<a hidden class="anchor" aria-hidden="true" href="#2nf-teacher">#</a></h4>
<pre class="mermaid">---
title: Violation of 2NF - Teacher (subject_taught)
---
erDiagram
    TEACHER {
        number teacher_id
        string first_name
        string last_name
        date date_of_birth
        string subject_taught
    }    
</pre>
<pre class="mermaid">---
title: Comply with 2NF - Teacher
---
erDiagram
    TEACHER {
        number teacher_id
        string first_name
        string last_name
        date date_of_birth
    }    

    SUBJECT {
        number subject_id PK
        string subject_name
        number category_id FK        
        number teacher_id FK
    }

    TEACHER ||--|{ SUBJECT : "teaches"
</pre>
<h4 id="2nf-university">2NF: University<a hidden class="anchor" aria-hidden="true" href="#2nf-university">#</a></h4>
<pre class="mermaid">---
title: Comply with 2NF - UNIVERSITY
---
erDiagram
    UNIVERSITY {
        number university_id PK
        string name        
    }

    SUBJECT {
        number subject_id PK
        string subject_name
        number category_id FK        
        number teacher_id FK
        number university_id FK
    }

    UNIVERSITY ||--|{ SUBJECT : ""
</pre>
<h3 id="third-normal-from">Third Normal From<a hidden class="anchor" aria-hidden="true" href="#third-normal-from">#</a></h3>
<blockquote>
<p><strong>Third Normal Form (3NF)</strong> is a level of normalization that satisfies <strong>Second Normal Form (2NF)</strong> and eliminates <strong>transitive dependencies</strong>. In simpler terms, a non-key attribute in a table should not depend on another non-key attrubute. For example, if A $\rightarrow$ B and B $\rightarrow$ C, then A $\rightarrow$ C, which means C should be moved to a separate table to avoid redundency. This process helps reduce data redundency and improves the efficiency of relational databases.</p>
</blockquote>
<h4 id="3nf-student">3NF: Student<a hidden class="anchor" aria-hidden="true" href="#3nf-student">#</a></h4>
<blockquote>
<p>In the following <code>Student</code> table, the non-key attributes (<code>unit_number</code>, <code>street_number</code>, <code>street_name</code>, <code>suburb</code>, <code>city</code>, <code>state</code>, <code>country</code>, and <code>postcode</code>) are not directly dependent on the primary key <code>student_id</code>; instead, they depend on the student&rsquo;s address. This results in a <strong>transitive dependency</strong>, which violates 3NF. Furthermore, since multiple students may share the same address, these address attributes will be repeated for each student, leading to data redundency.</p>
</blockquote>
<pre class="mermaid">---
title: Violation of 3NF - Student
---
erDiagram
    STUDENT {
        number student_id PK
        string first_name
        string last_name
        date date_of_birth
        number unit_number
        number street_number
        string street_name
        string suburb
        string city
        string state
        string country
        string postcode
    }
</pre>
<pre class="mermaid">---
title: Comply with 3NF - Student
---
erDiagram
    STUDENT {
        number student_id PK
        string first_name
        string last_name
        date date_of_birth
        number address_id FK
    }

    ADDRESS {
        number address_id PK
        number unit_number
        number street_number
        string street_name
        string suburb
        string city
        string state
        string country
        string postcode
    }

    STUDENT ||--|{ ADDRESS : ""
</pre>
<h4 id="3nf-teacher">3NF: Teacher<a hidden class="anchor" aria-hidden="true" href="#3nf-teacher">#</a></h4>
<pre class="mermaid">---
title: Comply with 3NF - Teacher
---
erDiagram
    TEACHER {
        number teacher_id PK
        string first_name
        string last_name
        date date_of_birth
        number address_id FK
    }

    ADDRESS {
        number address_id PK
        number unit_number
        number street_number
        string street_name
        string suburb
        string city
        string state
        string country
        string postcode
    }

    TEACHER ||--|{ ADDRESS : ""
</pre>
<h4 id="3nf-university">3NF: University<a hidden class="anchor" aria-hidden="true" href="#3nf-university">#</a></h4>
<pre class="mermaid">---
title: Comply with 3NF - University
---
erDiagram
    UNIVERSITY {
        number university_id PK
        string name
        number address_id FK
    }

    ADDRESS {
        number address_id PK
        number unit_number
        number street_number
        string street_name
        string suburb
        string city
        string state
        string country
        string postcode
    }

    UNIVERSITY ||--|{ ADDRESS : ""
</pre>
<h2 id="design-considerations">Design Considerations<a hidden class="anchor" aria-hidden="true" href="#design-considerations">#</a></h2>
<h3 id="determine-data-types--precision">Determine Data Types &amp; Precision<a hidden class="anchor" aria-hidden="true" href="#determine-data-types--precision">#</a></h3>
<blockquote>
<p><strong>Determining data types and precision</strong> in database design is crucial for ensuring optimal storage, performance, and accuracy of data. There are typically three steps to determine the apprpriate data type and precision for a field:</p>
</blockquote>
<ol>
<li><strong>Identifying the nature of the field</strong>: Determine the type of data the field will store—whether it&rsquo;s numeric, string, or data/time. For example, the <code>student_id</code> field might be of type <code>INT</code>, while the <code>first_time</code> field might of type <code>CHAR</code> or <code>VARCHAR</code>.</li>
<li><strong>Choose the smallest sufficient data type</strong>: Select the samllest data type that can accommodate the required values. For example, if a field&rsquo;s values range from -128 to 127, use <code>TINYINT</code> instead of <code>INT</code> to optimize performance and storage efficiency.</li>
<li><strong>Set precision and scale for numeric values</strong>: For numeric fields, it&rsquo;s important to define the precision (total number of digits) and scale (number of digits after the decimal point). For example, a <code>price</code> field should be set to <code>DECIMAL(10,2)</code>, which allows for 10 digits in total, with 2 digits after the decimal point.</li>
</ol>
<hr>
<h3 id="integrity-constraints">Integrity Constraints<a hidden class="anchor" aria-hidden="true" href="#integrity-constraints">#</a></h3>
<blockquote>
<p><strong>Integrity Constraints</strong> in database design are rules that ensure the <strong>accuracy</strong>, <strong>consistency</strong>, and <strong>validity</strong> of data. There are several types of integrity constraints, each serving a specific purpose:</p>
</blockquote>
<ol>
<li><strong>Entity Integrity</strong></li>
</ol>
<blockquote>
<p><strong>Entity Integrity</strong> ensures that each record in a table is <strong>unique</strong> and <strong>identifiable</strong>. This is achieved by setting a column in a table as a <strong>primary key</strong>. For example, the <code>student_id</code> field must be unique for each record in the <code>Student</code> table.</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> Student (
</span></span><span style="display:flex;"><span>    student_id INT <span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span>,
</span></span><span style="display:flex;"><span>    first_name VARCHAR(<span style="color:#ae81ff">100</span>),
</span></span><span style="display:flex;"><span>    last_name VARCHAR(<span style="color:#ae81ff">100</span>)
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><ol start="2">
<li><strong>Referencial Integrity</strong></li>
</ol>
<blockquote>
<p><strong>Referencial Integrity</strong> ensures that relationships between tables are maintained consistently. <strong>Foreign keys</strong> enforce this constraint by ensuring that a value in one table corresbonds to a valid value in another table. For example, the <code>student_id</code> field in the <code>Enrollment</code> table serves as a foreign key referencing the primary key <code>student_id</code> in the <code>Student</code> table.</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> Enrollment (
</span></span><span style="display:flex;"><span>    enrollment_id INT <span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span>,
</span></span><span style="display:flex;"><span>    student_id INT,
</span></span><span style="display:flex;"><span>    course_id INT,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">FOREIGN</span> <span style="color:#66d9ef">KEY</span> (student_id) <span style="color:#66d9ef">REFERENCES</span> Students(student_id)
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><ol start="3">
<li><strong>Domain Integrity</strong></li>
</ol>
<blockquote>
<p><strong>Domain Integrity</strong> ensures that the data entered in a column matches the defined <strong>data type</strong>, <strong>format</strong>, and <strong>range</strong>. This is enforced using data types. default values. and <strong>check constraints</strong>. For example, the <code>price</code> field should only store positive values.</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> Product (
</span></span><span style="display:flex;"><span>    product_id INT <span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span>,
</span></span><span style="display:flex;"><span>    product_name VARCHAR(<span style="color:#ae81ff">100</span>),
</span></span><span style="display:flex;"><span>    price DECIMAL(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">CHECK</span> (price <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><ol start="4">
<li><strong>User-Defined Integrity</strong></li>
</ol>
<blockquote>
<p><strong>User-defined integrity</strong> enforces business rules specific to the application or domain. For instance, in the <code>Enrollment</code> table, the combination of <code>student_id</code> and <code>course_id</code> should be unique to prevent a student from enrolling in the same course more than once.</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> Enrollment (
</span></span><span style="display:flex;"><span>    enrollment_id INT <span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span>,
</span></span><span style="display:flex;"><span>    student_id INT,
</span></span><span style="display:flex;"><span>    course_id INT,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">UNIQUE</span> (student_id, course_id)
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><ol start="5">
<li><strong>Null Integrity</strong></li>
</ol>
<blockquote>
<p><strong>Null integrity</strong> ensures that certain fields cannot store <strong>NULL</strong> values. This is enforced by defining the column with the <strong>NOT NULL</strong> constraint. For example, the <code>student_id</code> field in the <code>Student</code> table must not be NULL because it is used to identify each record.</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> Student (
</span></span><span style="display:flex;"><span>    student_id INT <span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span> <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>    first_name VARCHAR(<span style="color:#ae81ff">100</span>) <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>    last_name VARCHAR(<span style="color:#ae81ff">100</span>) <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><hr>
<h3 id="heading"><a hidden class="anchor" aria-hidden="true" href="#heading">#</a></h3>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://signalyu.github.io/tags/engineering--technology/">Engineering &amp; Technology</a></li>
      <li><a href="https://signalyu.github.io/tags/computer-science/">Computer Science</a></li>
      <li><a href="https://signalyu.github.io/tags/database/">Database</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/patterns/1-coding-patterns-for-interview-questions/">
    <span class="title">« PREV</span>
    
    <br>
    <span>Coding Patterns for Interview Questions</span>
  </a>
  <a class="next" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/algorithms/1-data-structure-and-algorithms/">
    <span class="title">NEXT »</span>
    
    <br>
    <span>Data Structure &amp; Algorithms</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://signalyu.github.io/">Signal&#39;s Blog</a></span> · 
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>

    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
        mermaid.initialize({
            startOnLoad: true,
            "flowchart": { "htmlLabels": true },
            theme: 'dark',
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
        });
    </script>
    
</body>
</html>
