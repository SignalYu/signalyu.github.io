<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Coding Problem Set | Signal&#39;s Blog</title>
<meta name="keywords" content="Engineering &amp; Technology, Computer Science, Programming">
<meta name="description" content="String 华为OD机试：字符串分割【100分】 点击查看题目 一、题目描述
给定一个非空字符串 S，其中包含多个子串，这些子串由 - 符号分隔。我们还给定一个正整数 K，要求按以下规则转换字符串：
对于字符串中的每个子串，从第二个子串开始，将其分为每 K 个字符的片段。 对每个片段应用以下转换规则： 如果片段中小写字母数量多于大写字母，将该片段的所有大写字母转换为小写字母。 如果片段中大写字母数量多于小写字母，将该片段的所有小写字母转换为大写字母。 如果大写和小写字母数量相等，不做转换。 二、输入描述
输入包含两行：
第一行为整数 K。 第二行为字符串 S，由 - 分隔成多个子串。 三、输出描述
输出转换后的字符串。
四、测试用例
测试用例 1 输入
3 12abc-abcABC-4aB@ 输出
12abc-abc-ABC-4aB-@ 说明
子串为 12abc、abcABC、4aB@。第一个子串保留。 对 abcABC 按每 3 个字符分组为 abc 和 ABC： abc 中小写字母多，转换为 abc。 ABC 中大写字母多，转换为 ABC。 对 4aB@ 按每 3 个字符分组为 4aB 和 @： 4aB 中大小写字母数量相等，不做转换。 @ 中无字母，不做转换。 最终输出为 12abc-abc-ABC-4aB-@。 测试用例 2
输入
3 Test-aaBBcc-CCddEE 输出">
<meta name="author" content="Signal Yu">
<link rel="canonical" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/programming/coding-problems/1-coding-problem-set/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5a0ace7f2dc73037e40ceea0eb0d119b5d798dba2da38d9129982a8cf9fa07a5.css" integrity="sha256-WgrOfy3HMDfkDO6g6w0Rm115jboto42RKZgqjPn6B6U=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://signalyu.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://signalyu.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://signalyu.github.io/favicon-32x32">
<link rel="apple-touch-icon" href="https://signalyu.github.io/apple-touch-icon">
<link rel="mask-icon" href="https://signalyu.github.io/favicon.io">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/programming/coding-problems/1-coding-problem-set/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css"
    integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"
    integrity="sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd"
    crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js"
    integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk"
    crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: true }
            ],
            
            throwOnError: false,
            strict: false
        });
    });
</script>

  

<meta property="og:title" content="Coding Problem Set" />
<meta property="og:description" content="String 华为OD机试：字符串分割【100分】 点击查看题目 一、题目描述
给定一个非空字符串 S，其中包含多个子串，这些子串由 - 符号分隔。我们还给定一个正整数 K，要求按以下规则转换字符串：
对于字符串中的每个子串，从第二个子串开始，将其分为每 K 个字符的片段。 对每个片段应用以下转换规则： 如果片段中小写字母数量多于大写字母，将该片段的所有大写字母转换为小写字母。 如果片段中大写字母数量多于小写字母，将该片段的所有小写字母转换为大写字母。 如果大写和小写字母数量相等，不做转换。 二、输入描述
输入包含两行：
第一行为整数 K。 第二行为字符串 S，由 - 分隔成多个子串。 三、输出描述
输出转换后的字符串。
四、测试用例
测试用例 1 输入
3 12abc-abcABC-4aB@ 输出
12abc-abc-ABC-4aB-@ 说明
子串为 12abc、abcABC、4aB@。第一个子串保留。 对 abcABC 按每 3 个字符分组为 abc 和 ABC： abc 中小写字母多，转换为 abc。 ABC 中大写字母多，转换为 ABC。 对 4aB@ 按每 3 个字符分组为 4aB 和 @： 4aB 中大小写字母数量相等，不做转换。 @ 中无字母，不做转换。 最终输出为 12abc-abc-ABC-4aB-@。 测试用例 2
输入
3 Test-aaBBcc-CCddEE 输出" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/programming/coding-problems/1-coding-problem-set/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-12-02T15:15:55+08:00" />
<meta property="article:modified_time" content="2024-12-02T15:15:55+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Coding Problem Set"/>
<meta name="twitter:description" content="String 华为OD机试：字符串分割【100分】 点击查看题目 一、题目描述
给定一个非空字符串 S，其中包含多个子串，这些子串由 - 符号分隔。我们还给定一个正整数 K，要求按以下规则转换字符串：
对于字符串中的每个子串，从第二个子串开始，将其分为每 K 个字符的片段。 对每个片段应用以下转换规则： 如果片段中小写字母数量多于大写字母，将该片段的所有大写字母转换为小写字母。 如果片段中大写字母数量多于小写字母，将该片段的所有小写字母转换为大写字母。 如果大写和小写字母数量相等，不做转换。 二、输入描述
输入包含两行：
第一行为整数 K。 第二行为字符串 S，由 - 分隔成多个子串。 三、输出描述
输出转换后的字符串。
四、测试用例
测试用例 1 输入
3 12abc-abcABC-4aB@ 输出
12abc-abc-ABC-4aB-@ 说明
子串为 12abc、abcABC、4aB@。第一个子串保留。 对 abcABC 按每 3 个字符分组为 abc 和 ABC： abc 中小写字母多，转换为 abc。 ABC 中大写字母多，转换为 ABC。 对 4aB@ 按每 3 个字符分组为 4aB 和 @： 4aB 中大小写字母数量相等，不做转换。 @ 中无字母，不做转换。 最终输出为 12abc-abc-ABC-4aB-@。 测试用例 2
输入
3 Test-aaBBcc-CCddEE 输出"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://signalyu.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Coding Problem Set",
      "item": "https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/programming/coding-problems/1-coding-problem-set/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Coding Problem Set",
  "name": "Coding Problem Set",
  "description": "String 华为OD机试：字符串分割【100分】 点击查看题目 一、题目描述\n给定一个非空字符串 S，其中包含多个子串，这些子串由 - 符号分隔。我们还给定一个正整数 K，要求按以下规则转换字符串：\n对于字符串中的每个子串，从第二个子串开始，将其分为每 K 个字符的片段。 对每个片段应用以下转换规则： 如果片段中小写字母数量多于大写字母，将该片段的所有大写字母转换为小写字母。 如果片段中大写字母数量多于小写字母，将该片段的所有小写字母转换为大写字母。 如果大写和小写字母数量相等，不做转换。 二、输入描述\n输入包含两行：\n第一行为整数 K。 第二行为字符串 S，由 - 分隔成多个子串。 三、输出描述\n输出转换后的字符串。\n四、测试用例\n测试用例 1 输入\n3 12abc-abcABC-4aB@ 输出\n12abc-abc-ABC-4aB-@ 说明\n子串为 12abc、abcABC、4aB@。第一个子串保留。 对 abcABC 按每 3 个字符分组为 abc 和 ABC： abc 中小写字母多，转换为 abc。 ABC 中大写字母多，转换为 ABC。 对 4aB@ 按每 3 个字符分组为 4aB 和 @： 4aB 中大小写字母数量相等，不做转换。 @ 中无字母，不做转换。 最终输出为 12abc-abc-ABC-4aB-@。 测试用例 2\n输入\n3 Test-aaBBcc-CCddEE 输出",
  "keywords": [
    "Engineering \u0026 Technology", "Computer Science", "Programming"
  ],
  "articleBody": "String 华为OD机试：字符串分割【100分】 点击查看题目 一、题目描述\n给定一个非空字符串 S，其中包含多个子串，这些子串由 - 符号分隔。我们还给定一个正整数 K，要求按以下规则转换字符串：\n对于字符串中的每个子串，从第二个子串开始，将其分为每 K 个字符的片段。 对每个片段应用以下转换规则： 如果片段中小写字母数量多于大写字母，将该片段的所有大写字母转换为小写字母。 如果片段中大写字母数量多于小写字母，将该片段的所有小写字母转换为大写字母。 如果大写和小写字母数量相等，不做转换。 二、输入描述\n输入包含两行：\n第一行为整数 K。 第二行为字符串 S，由 - 分隔成多个子串。 三、输出描述\n输出转换后的字符串。\n四、测试用例\n测试用例 1 输入\n3 12abc-abcABC-4aB@ 输出\n12abc-abc-ABC-4aB-@ 说明\n子串为 12abc、abcABC、4aB@。第一个子串保留。 对 abcABC 按每 3 个字符分组为 abc 和 ABC： abc 中小写字母多，转换为 abc。 ABC 中大写字母多，转换为 ABC。 对 4aB@ 按每 3 个字符分组为 4aB 和 @： 4aB 中大小写字母数量相等，不做转换。 @ 中无字母，不做转换。 最终输出为 12abc-abc-ABC-4aB-@。 测试用例 2\n输入\n3 Test-aaBBcc-CCddEE 输出\nTest-aab-bcc-CCD-DEE 说明\n子串为 Test、aaBBcc、CCddEE。第一个子串保留。 对 aaBBcc 按每 3 个字符分组为 aab 和 bcc： aab 中小写字母多，转换为 aab。 bcc 中小写字母多，转换为 bcc。 对 CCddEE 按每 3 个字符分组为 CCD 和 DEE： CCD 中大写字母多，转换为 CCD。 DEE 中大写字母多，转换为 DEE。 最终输出为 Test-aab-bcc-CCD-DEE。 点击查看代码 Java import java.util.*; class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取正整数 k int k = Integer.parseInt(in.nextLine().trim()); // 读取字符串 String s = in.nextLine().trim(); // 字符串转换 String result = transformString(s, k); // 输出结果 System.out.println(result); } private static String transformString(String s, int k) { // 根据 \"-\" 分隔符获取子串数组 String[] substringList = s.split(\"-\"); // 构建结果容器 StringBuilder builder = new StringBuilder(); builder.append(substringList[0]); for (int i = 1; i \u003c substringList.length; i++) { builder.append(\"-\"); // 子字符串进一步转换 String transformed = transformSubstring(substringList[i], k); builder.append(transformed); } return builder.toString(); } private static String transformSubstring(String s, int k) { // 构建结果容器 StringBuilder builder = new StringBuilder(); for (int i = 0; i \u003c s.length(); i += k) { int end = Math.min(i + k, s.length()); String subString = s.substring(i, end); // 对子串进行大小写转换处理 String transformed = applyCaseTransformation(subString); builder.append(transformed).append(\"-\"); } // 去除最后一个 \"-\" builder.setLength(builder.length() - 1); return builder.toString(); } private static String applyCaseTransformation(String s) { int lowerCaseCount = 0; int upperCaseCount = 0; // 统计字符串中大小写字母的频率 for (char c : s.toCharArray()) { if (Character.isLowerCase(c)) { lowerCaseCount++; } else if (Character.isUpperCase(c)){ upperCaseCount++; } } if (lowerCaseCount \u003e upperCaseCount) { return s.toLowerCase(); } else if (lowerCaseCount \u003c upperCaseCount) { return s.toUpperCase(); } return s; } } 字符匹配【100分】 SHOW PROBLEM 一、题目描述 给定一个字符串数组（每个字符串均由小写字母组成）和一个字符规律（由小写字母、.和*组成），请识别数组中哪些字符串可以完全匹配该字符规律。\n. 匹配任意单个字符。 * 匹配零个或多个前面的字符（即“零个或多个”的概念）。 匹配是要涵盖整个字符串，而不仅仅是部分字符串。\n二、输入描述\n第一行是一个由空格分隔的字符串数组，其中每个字符串的长度满足 1 \u003c 单个字符串长度 \u003c 100。 第二行为字符规律，长度满足 1 \u003c 字符规律长度 \u003c 50。 三、输出描述\n输出符合字符规律的字符串在数组中的下标，多个匹配时，下标按升序排列，并用逗号分隔。 如果没有任何字符串匹配，输出 -1。 示例\n输入：\ngolang java kafka .*a 输出：\n1,2 说明：\n匹配规则 .*a 表示以 a 结尾的任意字符串。符合要求的字符串是 java 和 kafka，因此它们的下标是 1 和 2（从 0 开始索引）。 SHOW CODE Java import java.util.*; import java.util.regex.Pattern; public class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); String[] words = in.nextLine().trim().split(\" \"); String rule = in.nextLine().trim(); String result = getMatchingIndices(words, rule); System.out.println(result); } private static String getMatchingIndices(String[] words, String rule) { List indices = new ArrayList\u003c\u003e(); // // 构建正则表达式 Pattern pattern = Pattern.compile(\"^\" + rule + \"$\"); // 遍历字符串数组，查找匹配项 for (int i = 0; i \u003c words.length; i++) { if (pattern.matcher(words[i]).matches()) { indices.add(i); } } return indices.isEmpty() ? \"-1\" : indices.toString().replaceAll(\"[\\\\[\\\\]\\\\s]\", \"\"); } } Queue 银行插队 SHOW PROBLEM 一、题目描述\n某银行将客户分为了若干个优先级，1级最高，5级最低。当客户到达银行时，优先级高的人可以随时插队到优先级低的人的前面。\n现在给定一系列的客户到达和办理业务的时间序列，请你每次银行办理业务时输出客户的编号。\n如果有多个优先级相同且最高的客户，则按照到达顺序进行办理。\n二、输入描述\n第一行是一个正整数 n（1 ≤ n ≤ 500），表示输入序列中的事件数量。 接下来的 n 行每行第一个字符为 a 或 p： 当字符为 a 时，后面跟着两个正整数 num 和 x，表示到达的客户编号 num 和优先级 x。 当字符为 p 时，表示当前优先级最高的客户去办理业务。 三、输出描述\n对于每个 p 类型的事件，输出一行，仅包含一个正整数 num，表示办理业务的客户编号。\n四、测试用例\n测试用例 1\n输入:\n4 a 1 3 a 2 2 a 3 2 p 输出:\n2 说明:\n客户 1 到达，优先级为 3。 客户 2 和客户 3 到达，优先级为 2。 第一次 p 会办理客户 2，因为客户 2 和客户 3 优先级相同，但是客户 2 先到达。 测试用例 2\n输入:\n6 a 10 1 a 20 5 a 30 3 p p p 输出:\n10 30 20 说明:\n客户 10 到达，优先级为 1（最高优先级）。 客户 20 到达，优先级为 5。 客户 30 到达，优先级为 3。 第一次 p 处理客户 10（因为客户 10 优先级最高）。 第二次 p 处理客户 30（优先级 3 高于 5）。 第三次 p 处理客户 20。 SHOW CODE Java import java.util.PriorityQueue; import java.util.Scanner; class Solution { static class Customer { int id; int priority; public Customer(int id, int priority) { this.id = id; this.priority = priority; } } public static void main(String[] args) { Scanner in = new Scanner(System.in); int n = Integer.parseInt(in.nextLine().trim()); // Customers with higher priority come first, // if priorities are equal, order by ID PriorityQueue queue = new PriorityQueue\u003c\u003e(( c1, c2) -\u003e c1.priority == c2.priority ? Integer.compare(c1.id, c2.id) : Integer.compare(c1.priority, c2.priority) ); // Process each event for (int i = 0; i \u003c n; i++) { String[] parts = in.nextLine().trim().split(\" \"); processEvents(parts, queue); } } private static void processEvents(String[] parts, PriorityQueue queue) { char action = parts[0].charAt(0); // A customer arrives if the action equals to 'a' if (action == 'a') { int id = Integer.parseInt(parts[1]); int priority = Integer.parseInt(parts[2]); queue.add(new Customer(id, priority)); } else if (action == 'p' \u0026\u0026 !queue.isEmpty()) { // Poll the highest priority customer from the queue Customer customer = queue.poll(); System.out.println(customer.id); } } } SHOW NOTES When sorting involves multiple fields, it is a good practice to encapsulate these fields in an entity class. This approach simplifies specifying the sorting order based on specific conditions, enhancing both the maintainability and readability of the code.\nTwo Pointers 华为OD机试：最大花费金额【100分】 点击查看题目 一、题目描述\n小明希望在预算范围内尽可能花完资金。双十一期间，众多商品打折销售，他想从心仪的商品中挑选三件购买。请设计一个程序，帮助小明计算可以花费的最大金额。\n二、输入描述\n第一行：一维整型数组 M，表示商品的价格列表，数组长度小于 100，每个商品价格小于 1000。 第二行：整数 R，表示购买的总资金限制，R 小于 100000。 三、输出描述\n输出满足条件的最大花费金额。如果不存在符合条件的组合，输出 -1。\n示例\n输入：\n28 16 36 22 100 输出：\n86 说明\n在示例中，购买三件商品且总价不超过 100 的最大组合为 28 + 36 + 22 = 86。\n点击查看代码 Java import java.util.*; class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取字符串数组并转换为整数数组 int[] prices = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); // 读取购买资金额度 int budget = Integer.parseInt(in.nextLine().trim()); // 计算预算范围内可以花费的最大金额 int maxCost = getMaxCost(prices, budget); // 输出结果 System.out.println(maxCost); } private static int getMaxCost(int[] prices, int budget) { // 对价格进行排序 Arrays.sort(prices); int maxCost = 0; // 用于记录最大花费金额 for (int i = 0; i \u003c prices.length - 2; i++) { if (prices[i] \u003c budget) { int left = i + 1, right = prices.length - 1; while (left \u003c right) { int currentCost = prices[i] + prices[left] + prices[right]; // 当前花费金额 if (currentCost == budget) { return currentCost; } else if (currentCost \u003c budget) { maxCost = Math.max(maxCost, currentCost); left++; } else { right--; } } } else { break; } } return maxCost; } } 华为OD机试：字符串序列判定【100分】 点击查看题目 一、题目描述\n给定两个字符串 a 和 b，均由小写英文字母组成。a 的长度不超过 100，b 的长度不超过 500,000。要求判断 a 是否是 b 的一个有效子序列。\n判定规则：\na 中的每个字符都能在 b 中找到（字符可以不连续）。 a 在 b 中的字符顺序必须保持一致。 例如，当 a = \"qwt\" 时，a 是 b = \"qwerty\" 的一个有效子序列，因为 a 的字符 q、w 和 t 在 b 中按顺序出现。 二、输入描述\n输入包含两个字符串 a 和 b，均由小写英文字母组成：\n第一行输入字符串 a。 第二行输入字符串 b。 字符串 a 的长度 ≤ 100，字符串 b 的长度 ≤ 500,000。\n三、输出描述\n输出 a 在 b 中的最后一个有效字符的位置（索引从 0 开始）。如果 a 不是 b 的有效子序列，返回 -1。\n点击查看代码 Java import java.util.*; class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取输入 String a = in.nextLine().trim(); String b = in.nextLine().trim(); in.close(); // 判断 a 是否是 b 的有效子串 int result = substringCheck(a, b); // 输出结果 System.out.println(result); } private static int substringCheck(String a, String b) { if (a.length() \u003e b.length()) { return -1; } int i = 0, j = 0; int lastMatchPosition = -1; // 用于记录 a 的最后一个有效字符在 b 中的索引位置 while (i \u003c a.length() \u0026\u0026 j \u003c b.length()) { if (a.charAt(i) == b.charAt(j)) { lastMatchPosition = j; // 更新最后一个匹配位置 i++; } j++; } return lastMatchPosition; } } 华为OD机试：租车骑绿道【100分】 点击查看题目 一、题目描述\n部门组织团建活动，安排绿道骑行，需要租用双人自行车。每辆自行车最多可容纳两人，且载重上限为 m。给出部门中每个人的体重，求最少需要租用多少辆双人自行车。\n二、输入描述\n第一行包含两个整数 m 和 n，其中 m 表示每辆自行车的最大载重，n 表示部门的总人数。 第二行包含 n 个整数，表示每个人的体重（每个人的体重不超过自行车的载重限制 m）。 输入数据满足以下条件：\n0 \u003c m \u003c= 200 0 \u003c n \u003c= 1,000,000 三、输出描述\n输出最少需要的双人自行车数量。\n点击查看代码 Java import java.util.*; class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取自行车限重与人数 int[] parts = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); int m = parts[0]; // 读取体重数据 int[] weights = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); // 计算所需最少双人自行车数量 int result = computeMinimumBicycles(weights, m); // 输出结果 System.out.println(result); } private static int computeMinimumBicycles(int[] weights, int maxWeight) { // 对数组进行排序，便于使用双指针模式 Arrays.sort(weights); // 初始化双指针 int left = 0, right = weights.length - 1; int bicycleCount = 0; // while (left \u003c= right) { // // 最轻和最重的人可以共用一辆车 // if (weights[left] + weights[right] \u003c= maxWeight) { // left++; // 左指针右移 // right--; // bicycleCount++; // } else { // 不能公用自行车 // right--; // 右指针左移 // bicycleCount++; // } // } while (left \u003c= right) { // 最轻和最重的人可以共用一辆车 if (weights[left] + weights[right] \u003c= maxWeight) { left++; // 左指针右移 } right--; // 右指针左移 bicycleCount++; } return bicycleCount; } } 华为OD机试：求最多可以派出多少支团队【100分】 点击查看题目 题目描述\n有一个数组表示每个人的能力值。比赛活动要求参赛团队的能力总和至少为 N。每个团队可以由一人或两人组成，每个人只能参加一个团队。请计算最多可以组建多少个符合要求的团队。\n输入描述\n第一行：一个整数表示总人数，范围为 1 至 500,000。 第二行：一个整数数组表示每个人的能力值，数组大小为 1 至 500,000，数组元素取值范围为 1 至 500,000。 第三行：一个整数表示团队能力要求的最低值 N，范围为 1 至 500,000。 输出描述\n输出一个整数，表示最多可以组建的符合要求的团队数量。 说明\n输入 输出 说明 3\n1 1 9\n8 1 9自己一队，输出1 5\n3 1 5 7 9\n8 3 说明3、5组成为一队，1、7组成一队，9自己一队，输出3 7\n3 1 5 7 9 2 6\n8 4 说明3、5组成为一队，1、7组成一队，9自己一队，2、6组成一队，输出4 点击查看代码 Java import java.util.Arrays; import java.util.Scanner; class Main { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取输入数据 int n = Integer.parseInt(in.nextLine().trim()); int[] abilities = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); int minTeamAbility = Integer.parseInt(in.nextLine().trim()); in.close(); // 计算符合题目要求的团队数量 int result = computeMaxTeams(abilities, n, minTeamAbility); // 输出结果 System.out.println(result); } private static int computeMaxTeams(int[] abilities, int n, int minTeamAbility) { // 对数组进行排序，便于使用双指针模式 Arrays.sort(abilities); // 初始化双指针 int left = 0, right = n - 1; int teamCount = 0; while (left \u003c= right) { if (abilities[left] == abilities[right] \u0026\u0026 abilities[right] \u003e= minTeamAbility) { // 只剩下一个人 teamCount++; break; } else if (abilities[right] \u003e= minTeamAbility) { // 能力最强的人单人成队 teamCount++; right--; } else if (abilities[left] + abilities[right] \u003e= minTeamAbility) { teamCount++; left++; right--; } else { left++; } } return teamCount; } } 华为OD机试：寻找身高相近的小朋友【100分】 点击查看题目 一、题目描述\n小明今年升入小学一年级，来到新班级后发现其他小朋友的身高各不相同。他想根据每个小朋友与自己的身高差，对他们进行排序，帮助自己更好地认识新同学。\n二、输入描述\n第一行包含两个正整数 $h $和 $n $，其中：\n$h $表示小明的身高，范围为 $0 \u003c h \u003c 200 $。 $n $表示班级中其他小朋友的数量，范围为 $0 \u003c n \u003c 50 $。 第二行包含 $n $个正整数，分别表示其他小朋友的身高 $h_1, h_2, \\ldots, h_n $，每个身高的取值范围为 $0 \u003c h_i \u003c 200 $，且这些数互不相同。\n三、输出描述\n按照以下规则输出排序结果，各正整数之间用空格分隔：\n与小明身高差的绝对值越小的小朋友排在前面。 如果与小明身高差的绝对值相同，则身高较矮的小朋友排在前面。 点击查看代码 Java import java.util.*; class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取小明身高值和小明同学数 int[] part = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); int h = part[0]; // 小明身高值 int n = part[1]; // 小明同学个数 // 读取小明同学身高数据并解析为数组 int[] heightList = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); // 基于小明的身高对小明同学的身高进行排序 String result = sortHeight(heightList, h, n); // 输出结果 System.out.println(result); } private static String sortHeight(int[] heightList, int h, int n) { // 对数组进行排序，便于使用双指针模式 Arrays.sort(heightList); // 构建结果容器 StringBuilder builder = new StringBuilder(); // 初始化双指针 int left = 0, right = n - 1; while (left \u003c= right) { if (Math.abs(h - heightList[left]) \u003e Math.abs(h - heightList[right])) { builder.insert(0, heightList[left]); left++; } else if (Math.abs(h - heightList[left]) \u003c= Math.abs(h - heightList[right])) { builder.insert(0, heightList[right]); right--; } builder.insert(0, \" \"); } return builder.substring(1); } } 华为OD机试：太阳能板最大面积【100分】 点击查看题目 一、题目描述\n在航天器的一侧安装太阳能板（如图中红色斜线区域）时，需要先固定两根支柱（如图中黑色竖条）。太阳能板的安装面积取决于支柱之间的距离和较短支柱的高度。\n现给定一组整数数组，表示各个支柱的高度。假设每根支柱之间的距离相等且为 1 个单位长度，计算如何选择两根支柱以使太阳能板的安装面积最大化。\n注意：支柱的高度无序排列。\n二、输入描述\n输入一个表示支柱高度的整数数组，如：10,9,6,7,8,5,4,7,2,3\n三、输出描述\n输出最大太阳能板的安装面积。\n点击查看代码 Java import java.util.*; class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取支柱高度 int[] height = Arrays.stream(in.nextLine().trim().split(\",\")) .mapToInt(Integer::parseInt) .toArray(); in.close(); // 计算最大面积 int maxArea = computeMaxArea(height); // 输出结果 System.out.println(maxArea); } private static int computeMaxArea(int[] height) { // 初始化双指针 int left = 0, right = height.length - 1; int maxArea = 0; // 用于记录最大面积 while (left \u003c right) { int area = Math.min(height[left], height[right]) * (right - left); maxArea = Math.max(maxArea, area); // 更新最大面积 // 移动较短的支柱，尝试获取更大的面积 if (height[left] \u003c height[right]) { left++; } else { right--; } } return maxArea; } } Sliding Window 华为OD机试：寻找连续区间【100分】 点击查看题目 题目描述\n给定一个包含 $N $个正整数的数组，找出所有连续子数组（包括单个元素），其和大于等于给定的整数 $X $的组合数量。\n输入描述\n第一行包含两个整数 $N $和 $X $。（$0 \u003c N \\leq 100000 $, $0 \\leq X \\leq 10000000 $）\n第二行包含 $N $个正整数（每个正整数的值不超过 100）。\n输出描述\n输出一个整数，表示满足条件的连续子数组的数量。\n输入示例\n3 7 3 4 7 输出示例\n4 示例说明\n输入的第一个数 3 表示数组包含 3 个元素，7 是目标值，用于判断子数组和是否大于等于该值。\n满足条件的子数组包括：3+4, 3+4+7, 4+7, 7，总共 4 个。\n点击查看代码 Java import java.util.*; class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取正整数个数和目标值 int[] part = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); int n = part[0]; int x = part[1]; // 读取整数 int[] nums = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); // 计算子数组和大于或等于目标值的个数 int result = countSubArrays(nums, x); // 输出结果 System.out.println(result); } private static int countSubArrays(int[] nums, int target) { int windowStart = 0, count = 0; int windowSum = 0; for (int windowEnd = 0; windowEnd \u003c nums.length; windowEnd++) { windowSum += nums[windowEnd]; // 更新窗口和 // 当窗口和大于或等于目标值时，缩小窗口 while (windowSum \u003e= target) { // 符合要求子数组：左边界为 windowStart，右边界取值范围为 [windowEnd, nums.length - 1] count += nums.length - windowEnd; windowSum -= nums[windowStart]; windowStart++; // 缩小窗口 } } return count; } } 点击查看笔记 count += nums.length - windowEnd; nums = [1, 4, 5], target = 4 windowEnd 为 0 时，当前窗口和1小于目标值 windowEnd 为 1 时，当前窗口和5大于目标值，符合要求的子数组为：[1, 4]和[1, 4, 5]。也就是说，子数组的左边界为windowStart = 0，右边界的取值可为：1, 2。 while (windowSum \u003e= target) 而非 if (windowSum \u003e= target) 当找到符合要求的子数组时，应尽可能缩小窗口。例如，子数组[1, 4] 缩小后变为[4]，但此时[4]仍满足题意，此时windowEnd的取值1和2，即子数组可为[4]和[4,5]。 华为OD机试：阿里巴巴找黄金宝箱(V)【100分】 点击查看题目 一、题目描述\n樵夫阿里巴巴在砍柴途中发现了一个藏宝地，这里有编号从 $0$ 到$N-1$的宝箱，每个宝箱上贴有一个数字，表示其价值。阿里巴巴记住了一个“咒语数字”$k$（$k \u003c N$），他希望通过这个数字找到宝藏组合的最大价值。具体而言，阿里巴巴要找出连续$k$个宝箱中的数字和的最大值，并输出该最大值。\n二、输入描述\n第一行：一个包含整数的字符串，表示宝箱上的数字，数字之间用逗号分隔。例子：2,10,-3,-8,40,5\n条件： 1 ≤ 数字的个数 ≤ 100,000 -10,000 ≤ 每个数字 ≤ 10,000 第二行：一个正整数$k$，表示咒语数字，指定连续宝箱的数量。例子：4，其中$k \u003c$宝箱的个数。\n三、输出描述\n输出一个整数，表示连续$k$个宝箱的最大和。例如：39\n四、测试用例\n测试用例 1：\n输入 2,10,-3,-8,40,5 4 输出 39 说明\n初始窗口：2,10,-3,-8，和为 1。\n移动窗口：10,-3,-8,40，和为 39，更新最大和。\n接下来窗口为：-3,-8,40,5，和为 34，保持最大和为 39。 测试用例 2：\n输入 8 1 输出 8 说明\n只有一个数字，窗口大小为 1，直接输出该数字 8。 测试用例 3：\n输入\n-1,-2,-3,-4 2 输出\n-3 说明\n初始窗口为 -1,-2，和为 -3。后续窗口的和分别为 -5 和 -7，因此最大和保持为 -3。\n点击查看代码 Java import java.util.*; class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取宝箱数字并转换为数组 int[] nums = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); // // 读取连续宝箱的个数 int boxes = Integer.parseInt(in.nextLine().trim()); // 计算指定连续宝箱个数的最大和 int maxSum = computeMaxSum(nums, boxes); // 输出结果 System.out.println(maxSum); } private static int computeMaxSum(int[] nums, int k) { int windowStart = 0, windowSum = 0; int maxSum = Integer.MIN_VALUE; for (int windowEnd = 0; windowEnd \u003c nums.length; windowEnd++) { windowSum += nums[windowEnd]; // 更新窗口和 // 当窗口大小等于k时，缩小窗口 if (windowEnd - windowStart + 1 == k) { maxSum = Math.max(maxSum, windowSum); // 更新最大和 windowSum -= nums[windowStart]; windowStart++; // 缩小窗口 } } return maxSum; } } 华为OD机试：最多购买宝石数目【100分】 点击查看题目 一、题目描述\n在一个橱窗里，有一排编号为 0 到 n-1 的宝石，每个宝石的价格用数组 gems[i] 表示（其中 0 \u003c= i \u003c n，且 n = gems.length）。你可以选择购买一组宝石，但需要满足以下条件：\n选择的宝石必须是连续编号的，例如：gems[i], gems[i+1], ..., gems[i+m-1]。 可以选择购买的宝石总数不能超过一个最大值 m。 你拥有的总金额为 value。 请计算，在给定的金额 value 和最大宝石数量 m 的限制下，最多可以购买多少个宝石。如果无法购买任何宝石，则返回 0。\n二、输入描述\n第一行输入整数 n，表示橱窗中宝石的总数量。取值范围：0 \u003c= n \u003c= 10^6 接下来的 n 行，每行一个整数，表示宝石的价格。即，第 i 行输入的是 gems[i] 的价格。价格范围：0 \u003c gems[i] \u003c= 1000 最后一行输入整数 m，表示拥有的总金额。取值范围：0 \u003c= value \u003c= 10^9 三、输出描述\n输出一个整数，表示在给定金额和数量限制下，最多可以购买的宝石数量。\n四、测试用例\n测试用例 1\n输入\n7 8 4 6 3 1 6 7 10 输出\n3 说明 可以购买编号为 2, 3, 4 的宝石，其价格和为 6 + 3 + 1 = 10，总价不超过 value\n点击查看代码 Java import java.util.*; class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取宝石数量 int n = Integer.parseInt(in.nextLine().trim()); // 读取宝石价格 int[] prices = new int[n]; for (int i = 0; i \u003c n; i++) { prices[i] = Integer.parseInt(in.nextLine().trim()); } // 读取拥有钱 int money = Integer.parseInt(in.nextLine().trim()); // 计算能够购买最多的宝石数量 int maxGem = buyMaxGems(prices, money); // 输出结果 System.out.println(maxGem); } private static int buyMaxGems(int[] prices, int money) { int windowStart = 0; int maxGem = 0, currentPrice = 0; for (int windowEnd = 0; windowEnd \u003c prices.length; windowEnd++) { currentPrice += prices[windowEnd]; // 如果总价超过预算，缩小窗口 if (currentPrice \u003e money) { currentPrice -= prices[windowStart]; windowStart++; } // 更新最大可购买的宝石数量 maxGem = Math.max(maxGem, windowEnd - windowStart + 1); } return maxGem; } } 点击查看笔记 问题本质：求给定条件下的最大区间\n华为OD机试：找出通过车辆最多颜色【100分】 点击查看题目 一、题目描述\n在一个狭窄的路口，每秒钟只能通过一辆车，且车辆的颜色只有三种。请找出在给定的统计时间窗内，经过的车辆中数量最多的颜色的车辆数量。\n颜色共有三种，分别用编号 0、1、2 表示。\n二、输入描述\n第一行是一个数组，表示每秒钟通过的车辆颜色信息。例如，输入 [0, 1, 1, 2] 表示在 4 秒钟内，车辆颜色依次为 0、1、1、2。 第二行是一个整数，表示统计时间窗的长度 T（单位：秒）。 三、输出描述\n输出在指定的统计时间窗 T 内，经过的数量最多的颜色的车辆数量。\n示例\n输入\n[0, 1, 1, 2] 3 输出\n2 说明\n在时间窗为 3 秒的范围内，颜色 1 的车辆数量最多，有 2 辆。\n点击查看代码 Java import java.util.*; class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取车辆颜色数据并转换为数组 int[] colors = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); // 读取指定时间窗口长度 int k = Integer.parseInt(in.nextLine().trim()); // 计算指定时间窗口内经过的最多颜色的车辆数量 int num = maxPassedCars(colors, k); // 输出结果 System.out.println(num); } private static int maxPassedCars(int[] colors, int windowSize) { int windowStart = 0, maxCars = 0; Map frequencyMap = new HashMap\u003c\u003e(); for (int windowEnd = 0; windowEnd \u003c colors.length; windowEnd++) { int count = frequencyMap.getOrDefault(colors[windowEnd], 0) + 1; maxCars = Math.max(maxCars, count); frequencyMap.put(colors[windowEnd], count); // 当窗口大小等于指定时间窗口时，缩小窗口 if (windowEnd - windowStart + 1 == windowSize) { frequencyMap.put(colors[windowStart], frequencyMap.get(colors[windowStart]) - 1); windowStart++; // 缩小窗口 } } return maxCars; } } 点击查看笔记 问题本质：统计指定区间内数字的出现频率\n滑动窗口模式相关算法题 长度最小的子数组 【力扣传送门】 SHOW CODE Java class Solution { public int minSubArrayLen(int target, int[] nums) { int windowSum = 0, minLength = Integer.MAX_VALUE; int windowStart = 0; for (int windowEnd = 0; windowEnd \u003c nums.length; windowEnd++) { windowSum += nums[windowEnd]; // 当窗口和大于目标值时，尽可能缩小窗口 while (windowSum \u003e= target) { minLength = Math.min(minLength, windowEnd - windowStart + 1); windowSum -= nums[windowStart]; windowStart++; } } return minLength == Integer.MAX_VALUE ? 0 : minLength; } } 水果成篮 【力扣传送门】 SHOW CODE Java class Solution { public int totalFruit(int[] fruits) { int maxLength = Integer.MIN_VALUE; Map frequencyMap = new HashMap\u003c\u003e(); int windowStart = 0; for (int windowEnd = 0; windowEnd \u003c fruits.length; windowEnd++) { int endFruit = fruits[windowEnd]; frequencyMap.put(endFruit, frequencyMap.getOrDefault(endFruit, 0) + 1); // 当水果类型大于2时缩小窗口 while (frequencyMap.size() \u003e 2) { int startFruit = fruits[windowStart]; frequencyMap.put(startFruit, frequencyMap.get(startFruit) - 1); if (frequencyMap.get(startFruit) == 0) { frequencyMap.remove(startFruit); } windowStart++; } maxLength = Math.max(maxLength, windowEnd - windowStart + 1); } return maxLength; } } 华为OD机试：计算最接近的数【100分】 点击查看题目 一、题目描述\n给定一个数组 X 和一个正整数 K，请找出一个下标 i，使得表达式 $X[i] - X[i-1] - \\dots - X[i+K+1]$ 的结果最接近数组中位数的下标i。如果有多个满足条件的下标 i，请返回最大的 i。\n数组的中位数定义为：将长度为 N 的数组按元素值从小到大排序后，下标为 N/2 的元素的值。\n二、输入描述\n第一行输入一个数组 X（元素为整数，长度为 N）。 第二行输入正整数 K。 三、输出描述\n表达式 $X[i] - X[i-1] - \\dots - X[i+K+1]$ 的结果最接近数组中位数的起始下标i。如果存在多个下标满足条件，返回最大的 i。\n点击查看代码 Java import java.util.*; /** * @author Signal Yu * @since 2024-11-07 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取输入数组并去除方括号与空格 int[] nums = Arrays.stream(in.nextLine() .replaceAll(\"[\\\\[\\\\]\\\\s]\", \"\") .split(\",\")) .mapToInt(Integer::parseInt) .toArray(); // 读取整数k int k = Integer.parseInt(in.nextLine().trim()); // 计算最接近中位数的表达式下标 int index = getClosestIndex(nums, k); // 输出结果 System.out.println(index); } private static int getClosestIndex(int[] nums, int k) { // 创建数组副本并排序以找到中位数 int[] sortedNums = Arrays.copyOf(nums, nums.length); Arrays.sort(sortedNums); int median = sortedNums[sortedNums.length / 2]; // 计算中位数 int closestIndex = -1; // 最终输出的最接近中位数的起始下标 int minDistance = Integer.MAX_VALUE; // 初始化最小差值为最大整数 for (int start = 0; start \u003c nums.length; start++) { int current = nums[start]; for (int end = start + 1; end \u003c= Math.min(nums.length - 1, start + k + 1); end++) { current -= nums[end]; } // 计算当前子数组和与中位数的差值 int diff = Math.abs(current - median); // 更新最接近的下标与最小差值（若差值相同则选择更大的下标） if (diff \u003c= minDistance) { closestIndex = start; minDistance = diff; } } return closestIndex; } } 华为OD机试：用连续自然数之和来表达整数【100分】 点击查看题目 题目描述 给定一个整数，可以用连续的自然数之和表示。请计算该整数有多少种不同的连续自然数之和的表示方式，并输出每种表示。\n输入描述 一个目标整数 T，其中 1 \u003c= T \u003c= 1000。\n输出描述 输出该整数的所有连续自然数之和的表示方式以及表示方式的总数。\n输出顺序要求：优先输出自然数数量最少的表达方式。 每个表达式中自然数应按递增顺序排列，格式参考样例。 在所有表达式输出结束后，单独输出一行 \"Result:X\"，其中 X 为表达式的总个数。 输入示例\n9 输出示例\n9=9 9=4+5 9=2+3+4 Result:3 点击查看代码 Java import java.util.Scanner; /** * @author Signal Yu * @since 2024-11-07 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取整数 t int t = Integer.parseInt(in.nextLine().trim()); // 获取符合条件的表达式及总数 String result = getExpressionAndResult(t); // 输出结果 System.out.println(result); } private static String getExpressionAndResult(int n) { StringBuilder result = new StringBuilder(); int start = 1; // 记录窗口起始位置 int count = 0; // 记录符合条件的表达式个数 int windowSum = 0; // 记录窗口和 // 使用滑动窗口找到所有符合条件的表达式 for (int end = 1; end \u003c= n; end++) { windowSum += end; // 更新窗口和 // 窗口和大于目标 n时，缩小窗口 while (windowSum \u003e n) { windowSum -= start; start++; } // 窗口和等于目标 n，记录表达式 if (windowSum == n) { StringBuilder expression = new StringBuilder(); expression.append(n).append(\"=\"); for (int i = start; i \u003c= end; i++) { expression.append(i).append(\"+\"); } expression.setLength(expression.length() - 1); // 移除最后一个加号 expression.append(\"\\n\"); result.insert(0, expression); // 将表达式插入到结果的起始位置 count++; } } // 添加表达式总数 result.append(\"Result:\").append(count); return result.toString(); } } 华为OD机试：滑动窗口最大和【100分】 点击查看题目 题目描述\n给定一个包含 $N$ 个整数的数组和一个长度为 $M$ 的滑动窗口，从数组的第一个数开始，窗口逐步滑动直到无法再滑动。每次滑动窗口会生成一个窗口和（窗口中所有元素的总和），请找出所有窗口和中的最大值。\n输入描述\n第一行输入一个正整数 $N$，表示数组中的整数个数（$0 \u003c N \u003c 100000$）。 第二行输入 $N$ 个整数，范围为 $[-100, 100]$。 第三行输入一个正整数 $M$，表示窗口大小，满足 $1 \\le M \\le N$。 输出描述\n输出所有窗口和的最大值。\n示例\n输入\n6 10 20 30 15 23 12 3 输出\n68 说明\n窗口长度为 3，窗口滑动产生的窗口和为：\n10 + 20 + 30 = 60 20 + 30 + 15 = 65 30 + 15 + 23 = 68 15 + 23 + 12 = 50 因此，最大窗口和为 68。\n点击查看代码 Java import java.util.*; /** * @author Signal Yu * @since 2024-11-07 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取整数个数 int n = Integer.parseInt(in.nextLine().trim()); // 读取整数字符串并转换为数组 int[] nums = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); // 读取滑动窗口大小 int m = Integer.parseInt(in.nextLine().trim()); // 计算符合条件的最大和 int maxSum = getMaxSum(nums, n, m); // 输出结果 System.out.println(maxSum); } private static int getMaxSum(int[] nums, int n, int m) { int start = 0, windowSum = 0, maxSum = Integer.MIN_VALUE; for (int end = 0; end \u003c n; end++) { windowSum += nums[end]; // 更新窗口和 // 当窗口大小等于 m 时，缩小窗口 if (end - start + 1 == m) { maxSum = Math.max(maxSum, windowSum); // 更新最大和 windowSum -= nums[start]; start++; // 缩小窗口 } } return maxSum; } } 替换后的最长重复字符 【力扣传送门】 SHOW CODE Java class Solution { public int characterReplacement(String s, int k) { Map frequencyMap = new HashMap\u003c\u003e(); int maxLength = Integer.MIN_VALUE; int maxRepeatLetterCount = 0; int windowStart = 0; for (int windowEnd = 0; windowEnd \u003c s.length(); windowEnd++) { char endChar = s.charAt(windowEnd); frequencyMap.put(endChar, frequencyMap.getOrDefault(endChar, 0) + 1); maxRepeatLetterCount = Math.max(maxRepeatLetterCount, frequencyMap.get(endChar)); // 当窗口大小与最大重复字母数之差大于 k 时，需要缩小窗口 if (windowEnd - windowStart + 1 - maxRepeatLetterCount \u003e k) { char startChar = s.charAt(windowStart); frequencyMap.put(startChar, frequencyMap.get(startChar) - 1); windowStart++; } maxLength = Math.max(maxLength, windowEnd - windowStart + 1); } return maxLength; } } 华为OD机试：补种未成活胡杨【100分】 点击查看题目 题目描述\n近年来，我国在防沙治沙方面取得了显著成果。某沙漠中新种植了 N 棵胡杨树，排成一行。一段时间后，有 M 棵胡杨未能成活，现需选择其中的 K 棵进行补种（只能补种已枯死的胡杨，不能新增种植）。请问如何补种，能够使连续胡杨树的数量达到最大？\n输入描述\n第一行包含三个整数，分别为： N：种植的胡杨总数量（1 ≤ N ≤ 100,000） M：未成活的胡杨数量（1 ≤ M ≤ N） M 个空格分隔的整数，按编号从小到大排列 K：最多可以补种的胡杨数量（0 ≤ K ≤ M） 输出描述\n输出最多的连续胡杨树数量。\n示例\n输入\n5 2 2 4 1 输出\n3 说明\n在 5 棵胡杨中，编号为 2、4 的胡杨未成活。最多可以补种 1 棵，通过补种编号为 2 或 4，可以形成最多的连续胡杨树，即 3 棵。\n点击查看代码 Java import java.util.*; import java.util.stream.Collectors; /** * @author Signal Yu * @since 2024-11-08 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取种植的胡杨总数 int n = Integer.parseInt(in.nextLine().trim()); // 读取未成活的胡杨数量 int m = Integer.parseInt(in.nextLine().trim()); // 读取未成活的胡杨编号并转换为集合 Set deadPopulusSet = Arrays.stream(in.nextLine().trim().split(\" \")) .map(Integer::parseInt) .collect(Collectors.toSet()); // 读取可以补种的棵数 int k = Integer.parseInt(in.nextLine().trim()); // 计算补种后最多连续胡杨树数量 int maxSurvivals = getMaxAlive(n, deadPopulusSet, k); // 输出结果 System.out.println(maxSurvivals); } private static int getMaxAlive(int n, Set deadPopulusSet, int k) { int start = 1, maxSurvivals = 0, deathCount = 0; for (int end = 1; end \u003c= n; end++) { if (deadPopulusSet.contains(end)) { deathCount++; } // 当前窗口内未成活的胡杨树棵数超过 k 时，缩小窗口 while (deathCount \u003e k) { if (deadPopulusSet.contains(start)) { deathCount--; } start++; // 缩小窗口 } maxSurvivals = end - start + 1; // 更新最大连续成活数量 } return maxSurvivals; } } 最大连续1的个数 III 【力扣传送门】 SHOW CODE Java class Solution { public int longestOnes(int[] nums, int k) { int maxLength = 0; // 记录最长窗口长度 int maxOnesInWindow = 0; // 记录当前窗口内的1的个数 int windowStart = 0; for (int windowEnd = 0; windowEnd \u003c nums.length; windowEnd++) { if (nums[windowEnd] == 1) { maxOnesInWindow++; } // 如果当前窗口内0的个数超过k，缩小窗口 while (windowEnd - windowStart + 1 - maxOnesInWindow \u003e k) { if (nums[windowStart] == 1) { maxOnesInWindow--; } windowStart++; } // 更新最长窗口长度 maxLength = Math.max(maxLength, windowEnd - windowStart + 1); } return maxLength; } } 字符串的排列 【力扣传送门】 SHOW CODE Java class Solution { public boolean checkInclusion(String s1, String s2) { Map frequencyMap = new HashMap\u003c\u003e(); // 初始化s1中每个字符的频率 for (char c : s1.toCharArray()) { frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1); } int windowStart = 0; // 滑动窗口起始位置 int matched = 0; // 已匹配的字符种类数 // 移动窗口的结束位置 for (int windowEnd = 0; windowEnd \u003c s2.length(); windowEnd++) { char endChar = s2.charAt(windowEnd); // 当前窗口的结束字符 // 如果结束字符在频率表中，更新其频率 if (frequencyMap.containsKey(endChar)) { frequencyMap.put(endChar, frequencyMap.get(endChar) - 1); // 如果字符频率降为0，表示完全匹配一个字符 if (frequencyMap.get(endChar) == 0) { matched++; } } // 若所有字符都匹配，返回true if (matched == frequencyMap.size()) { return true; } // 当窗口大小等于s1的长度时，调整窗口 if (windowEnd - windowStart + 1 \u003e= s1.length()) { char startChar = s2.charAt(windowStart); // 当前窗口的起始字符 // 若起始字符在频率表中，恢复频率并更新匹配状态 if (frequencyMap.containsKey(startChar)) { if (frequencyMap.get(startChar) == 0) { matched--; } frequencyMap.put(startChar, frequencyMap.get(startChar) + 1); } // 移动窗口起始位置 windowStart++; } } // 若未找到匹配的子串，返回false return false; } } 华为OD机试：关联子串【100分】 点击查看题目 题目描述\n给定两个字符串 str1 和 str2，判断是否存在 str1 的某种排列是 str2 的子串。如果存在，返回该子串在 str2 中的起始位置；如果不存在，则返回 -1。\n输入描述\n第一行输入两个字符串，分别为 str1 和 str2，用空格分隔。\n输出描述\n返回 str1 的某排列在 str2 中的子串起始位置。如果不存在关联子串，则输出 -1。\n示例\n输入\nvae hsgseva 输出\n4 说明\n在 str2 中，str1 的某种排列 eva 出现于索引 4。\n点击查看代码 Java import java.util.*; /** * @author Signal Yu * @since 2024-11-07 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取字符串 str1 和 str2 String[] parts = in.nextLine().trim().split(\" \"); String str1 = parts[0]; String str2 = parts[1]; // 计算关联子串 str1 在 str2 中的起始位置，非关联子串返回 -1 int index = getInclusionIndex(str1, str2); // 输出结果 System.out.println(index); } private static int getInclusionIndex(String s1, String s2) { if (s1.length() \u003e s2.length()) { return -1; } // 统计字符串 s1 中的字母频率 Map frequencyMap = new HashMap\u003c\u003e(); for (char c : s1.toCharArray()) { frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1); } int start = 0; // 记录窗口起始位置 int matched = 0; // 记录已匹配的字符 for (int end = 0; end \u003c s2.length(); end++) { char endChar = s2.charAt(end); // 当前窗口结束字符 if (frequencyMap.containsKey(endChar)) { frequencyMap.put(endChar, frequencyMap.get(endChar) - 1); if (frequencyMap.get(endChar) == 0) { matched++; } } // 当所有字符匹配时，返回起始位置 if (matched == frequencyMap.size()) { return start; } // 当窗口大小等于字符串s1长度时，收缩窗口 if (end - start + 1 == s1.length()) { char startChar = s2.charAt(start); // 当前窗口起始字符 if (frequencyMap.containsKey(startChar)) { if (frequencyMap.get(startChar) == 0) { matched--; } frequencyMap.put(startChar, frequencyMap.get(startChar) + 1); } start++; // 收缩窗口 } } return -1; } } 找到字符串中所有字母异位词 【力扣传送门】 SHOW CODE Java class Solution { public List findAnagrams(String s, String p) { List result = new ArrayList\u003c\u003e(); Map frequencyMap = new HashMap\u003c\u003e(); for (char c : p.toCharArray()) { frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1); } int windowStart = 0, matched = 0; for (int windowEnd = 0; windowEnd \u003c s.length(); windowEnd++) { char endChar = s.charAt(windowEnd); // 当前窗口的结束字符 if (frequencyMap.containsKey(endChar)) { // 更新频率映射，记录匹配字符 frequencyMap.put(endChar, frequencyMap.get(endChar) - 1); if (frequencyMap.get(endChar) == 0) { matched++; } } // 如果所有字符都匹配，则记录起始索引 if (matched == frequencyMap.size()) { result.add(windowStart); } // 窗口大小与目标字符串长度相等时，开始收缩窗口 if (windowEnd - windowStart + 1 \u003e= p.length()) { char startChar = s.charAt(windowStart); // 当前窗口的起始字符 if (frequencyMap.containsKey(startChar)) { if (frequencyMap.get(startChar) == 0) { matched--; } frequencyMap.put(startChar, frequencyMap.get(startChar) + 1); } windowStart++; // 收缩窗口 } } return result; } } 最小覆盖子串 【力扣传送门】 SHOW CODE Java class Solution { public String minWindow(String s, String t) { // 如果 t 比 s 长，直接返回空字符串 if (t.length() \u003e s.length()) { return \"\"; } // 创建 t 的字符频率映射 Map frequencyMap = new HashMap\u003c\u003e(); for (char c : t.toCharArray()) { frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1); } int windowStart = 0; // 窗口的起始位置 int minLength = s.length() + 1; // 最小窗口长度，初始化为超过 s 长度 int matched = 0; // 记录匹配到的字符数 int subStrStart = 0; // 最小窗口的起始位置 // 扩展窗口 for (int windowEnd = 0; windowEnd \u003c s.length(); windowEnd++) { char endChar = s.charAt(windowEnd); // 如果结束字符在 t 中，则减少其频率 if (frequencyMap.containsKey(endChar)) { frequencyMap.put(endChar, frequencyMap.get(endChar) - 1); // 频率非负时，说明该字符计入有效匹配 if (frequencyMap.get(endChar) \u003e= 0) { matched++; } } // 当前窗口包含所有 t 中字符时，尝试收缩窗口 while (matched == t.length()) { // 更新最小窗口长度和起始位置 if (windowEnd - windowStart + 1 \u003c minLength) { minLength = windowEnd - windowStart + 1; subStrStart = windowStart; } // 收缩窗口，处理起始字符 char startChar = s.charAt(windowStart); if (frequencyMap.containsKey(startChar)) { // 如果起始字符频率为 0，说明缩小窗口会减少匹配数 if (frequencyMap.get(startChar) == 0) { matched--; } // 恢复起始字符的频率 frequencyMap.put(startChar, frequencyMap.get(startChar) + 1); } windowStart++; // 窗口起点右移 } } // 返回最小窗口子串或空字符串 return minLength \u003e s.length() ? \"\" : s.substring(subStrStart, subStrStart + minLength); } } 华为OD机试：最左侧冗余覆盖子串【100分】 点击查看题目 一、题目描述\n给定两个字符串 s1 和 s2 以及一个正整数 k，其中 s1 的长度为 n1，s2 的长度为 n2。要求在 s2 中找到一个长度为 n1 + k 的子串，满足以下条件：\n该子串的长度为 n1 + k； 该子串包含 s1 中的所有字母； 该子串中每个字母的出现次数不少于 s1 中对应的字母次数。 如果在 s2 中存在满足条件的子串，则称 s2 以长度 k 冗余覆盖 s1。要求返回满足条件的最左侧子串的起始下标；如果不存在，则返回 -1。\n二、输入描述\n输入为三行：\n第一行是字符串 s1。 第二行是字符串 s2。 第三行是整数 k。 注意：s1 和 s2 都只包含小写字母。\n三、输出描述\n输出满足条件的 s2 中子串的最左侧起始下标；若不存在，则返回 -1。\n点击查看代码 Java import java.util.*; /** * @author Signal Yu * @since 2024-11-06 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取字符串和正整数k String s1 = in.nextLine().trim(); String s2 = in.nextLine().trim(); int k = Integer.parseInt(in.nextLine().trim()); // 计算冗余覆盖子串的最左侧起始下标 int index = getIndex(s1, s2, k); // 输出结果 System.out.println(index); } private static int getIndex(String s1, String s2, int k) { int index = -1; int subStrLength = s1.length() + k; if (subStrLength \u003e s2.length()) { return -1; // s2 不足以包含指定长度的子串 } // 构建 s1 中字符的频率表 Map frequencyMap = new HashMap\u003c\u003e(); for (char c : s1.toCharArray()) { frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1); } int windowStart = 0; int matched = 0; // 记录已匹配字符 for (int windowEnd = 0; windowEnd \u003c s2.length(); windowEnd++) { char endChar = s2.charAt(windowEnd); // 当前窗口结束字符 if (frequencyMap.containsKey(endChar)) { frequencyMap.put(endChar, frequencyMap.get(endChar) - 1); if (frequencyMap.get(endChar) == 0) { // 已匹配当前字符 matched++; } } // 所有字符匹配完成，返回结果 if (matched == frequencyMap.size()) { return windowStart; } // 窗口大小等于目标子串长度时，缩小窗口 if (windowEnd - windowStart + 1 == subStrLength) { char startChar = s2.charAt(windowStart); // 当前窗口起始字符 if (frequencyMap.containsKey(startChar)) { if (frequencyMap.get(startChar) == 1) { // 收缩窗口后，该字符变为未匹配 matched--; } frequencyMap.put(startChar, frequencyMap.get(startChar) + 1); } windowStart++; // 窗口收缩 } } return index; } } 串联所有单词的子串 【力扣传送门】 SHOW CODE Java 包含所有三种字符的子字符串数目 【力扣传送门】 SHOW CODE Java class Solution { public int numberOfSubstrings(String s) { int[] charCount = new int[3]; // 用于存储 'a', 'b', 'c' 的出现次数 int start = 0, count = 0; for (int end = 0; end \u003c s.length(); end++) { // 更新当前窗口内字符的出现次数 charCount[s.charAt(end) - 'a']++; while (charCount[0] \u003e 0 \u0026\u0026 charCount[1] \u003e 0 \u0026\u0026 charCount[2] \u003e 0) { count += s.length() - end; // 子串数量加1 charCount[s.charAt(start) - 'a']--; // 移除窗口起始字符 start++; // 缩小窗口 } } return count; } } 华为OD机试：优雅子数组【100分】 点击查看题目 题目描述\n如果一个数组中某个元素的出现次数大于等于 $k$ 次，则称该数组为 k-优雅数组，其中 $k$ 被称为 优雅阈值。\n例如，数组 [2, 3, 1, 2, 3, 1, 2, 3, 1] 是一个 3-优雅数组，因为元素 1 的出现次数达到了 3 次或更多。相反，数组 [2, 3, 1, 2, 3, 1] 不是一个 3-优雅数组，因为其中出现次数最多的元素（1 和 2）都仅出现了 2 次。\n给定一个数组 A 和一个阈值 k，请计算 A 中有多少个子数组是 k-优雅子数组。\n子数组是数组中由一个或多个连续元素组成的子集。例如，数组 [1, 2, 3, 4] 包含 10 个子数组，分别为：\n[1]，[1, 2]，[1, 2, 3]，[1, 2, 3, 4] [2]，[2, 3]，[2, 3, 4] [3]，[3, 4] [4] 输入描述\n第一行输入两个整数，以空格隔开，分别表示数组 A 的长度和优雅阈值 k。 第二行输入数组 A 的元素，以空格隔开。 输出描述\n输出数组 A 中有多少个子数组是 k-优雅子数组。 测试用例\n测试用例 1\n输入：\n7 3 1 2 3 1 2 3 1 输出：\n1 说明： 只有整个数组 [1, 2, 3, 1, 2, 3, 1] 中，元素 1 的出现次数达到 3 次。\n测试用例 2\n输入：\n7 2 1 2 3 1 2 3 1 输出：\n10 说明： 有 10 个子数组中，至少有一个元素出现了 2 次或更多。\n点击查看代码 Java import java.util.*; /** * @author Signal Yu * @since 2024-11-09 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取数组长度和优雅阈值 int[] parts = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); int n = parts[0]; int k = parts[1]; // 读取数字字符串并转换为整数数组 int[] nums = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); // 计算优雅子数组的个数 int count = countElegantSubarrays(nums, n, k); // 输出结果 System.out.println(count); } private static int countElegantSubarrays(int[] nums, int n, int k) { Map frequencyMap = new HashMap\u003c\u003e(); int start = 0, count = 0; for (int end = 0; end \u003c n; end++) { // 统计窗口内数字的频率 frequencyMap.put(nums[end], frequencyMap.getOrDefault(nums[end], 0) + 1); // 检查当前窗口是否符合 k-优雅条件 while (isKElegant(frequencyMap, k)) { count += n - end; // 更新优雅子数组的个数 // 缩小窗口，并减少频率映射中对应元素的计数 frequencyMap.put(nums[start], frequencyMap.get(nums[start]) - 1); if (frequencyMap.get(nums[start]) == 0) { frequencyMap.remove(nums[start]); } start++; } } return count; } private static boolean isKElegant(Map frequencyMap, int k) { for (int count : frequencyMap.values()) { if (count \u003e= k) { return true; } } return false; } } 数学与逻辑分析模式相关算法题 华为OD机试：考勤信息【100分】 点击查看题目 一、题目描述\n公司使用一个字符串来表示员工的出勤情况，其中：\nabsent 表示缺勤 late 表示迟到 leaveearly 表示早退 present 表示正常出勤 需要根据员工的出勤记录，判断该员工是否可以获得出勤奖。出勤奖的获得条件如下：\n缺勤次数不超过一次； 没有连续的迟到或早退； 任意连续 7 次出勤记录中，缺勤、迟到或早退的次数不超过 3 次。 二、输入描述\n第一行输入一个正整数 $n $，表示考勤记录的条数。\n接下来的 $n $行，每行包含一个字符串，表示一条考勤记录。\n注意：\n记录条数 $n \\geq 1 $； 每个字符串长度小于 10000； 不存在非法输入。 三、输出描述\n根据每条考勤记录，如果该员工符合出勤奖条件，则输出 \"true\"；否则输出 \"false\"。\n对于输入示例的结果，输出每条考勤记录对应的判断结果，每个结果占一行。\n示例\n输入：\n2 present present absent late present present leaveearly present absent late late leaveearly absent present 输出：\ntrue false 点击查看代码 Java import java.util.*; /** * @author Signal Yu * @since 2024-11-04 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取考勤记录条数 int n = Integer.parseInt(in.nextLine().trim()); // 读取考勤记录并处理 for (int i = 0; i \u003c n; i++) { String attendanceRecord = in.nextLine().trim(); String result = isEligibleForAward(attendanceRecord) ? \"true\" : \"false\"; System.out.println(result); } in.close(); } private static boolean isEligibleForAward(String attendanceRecord) { String[] attendanceList = attendanceRecord.split(\" \"); int absentCount = 0; int continuousLateOrLeaveEarly = 0; for (int i = 0; i \u003c attendanceList.length; i++) { String record = attendanceList[i]; // 条件1：缺勤次数不超过1次 if (\"absent\".equals(record)) { absentCount++; if (absentCount \u003e 1) { return false; } } // 条件2：没有连续的迟到或早退 if (\"late\".equals(record) || \"leaveearly\".equals(record)) { continuousLateOrLeaveEarly++; if (continuousLateOrLeaveEarly \u003e 1) { return false; } } else { continuousLateOrLeaveEarly = 0; } // 条件3：任意连续7次出勤记录中，缺勤、迟到和早退的次数不超过3次 // 条件3等价于一周内present次数小于4 if (i \u003e= 6) { int presentCount = 0; for (int j = i - 6; j \u003c= i; j++) { if (\"present\".equals(attendanceList[j])) { presentCount++; } } if (presentCount \u003c 4) { return false; } } } return true; } } 质数减法运算 【力扣传送门】 SHOW CODE Java class Solution { public boolean primeSubOperation(int[] nums) { // 获取数组最大值 int maxNum = Arrays.stream(nums).max().orElseThrow(); // 生成素数数组 int[] primes = generatePrimes(maxNum); int prev = 0; // 初始化前一个数字为0以便第一次比较 for (int num : nums) { // 尝试用小于 num 的最大素数使其变为比 prev 大的值 boolean found = false; for (int prime : primes) { if (num - prime \u003e prev) { num -= prime; found = true; break; } } // 如果找不到合适的素数来调整num以满足严格递增，则返回false if (!found \u0026\u0026 num \u003c= prev) { return false; } prev = num; } return true; } // 生成小于 limit 且呈递减顺序的素数数组 private static int[] generatePrimes(int limit) { List primes = new ArrayList\u003c\u003e(); for (int i = limit - 1; i \u003e= 2; i--) { if (isPrime(i)) { primes.add(i); } } return primes.stream().mapToInt(Integer::intValue).toArray(); } // 判断自然数是否为素数 private static boolean isPrime(int n) { if (n \u003c= 1) { return false; } if (n \u003c= 3) { return true; } if (n % 2 == 0 || n % 3 == 0) { return false; } /** 所有大于 3 的质数都可以表示成 6𝑘±1 的形式 i 从 5 开始，表示第一个满足 6k - 1 的数。 i + 2 则是紧接的满足 6k + 1 的数。 */ for (int i = 5; i \u003c= Math.sqrt(n); i += 6) { if (n % i == 0 || n % (i+2) == 0) { return false; } } return true; } } 数列描述【100分】 SHOW PROBLEM 一、题目描述\n有一个数列 a[N]（N=60），其中 a[0] = \"1\"，每一项 a[n+1] 是对前一项 a[n] 的描述。具体规则如下：\na[0] = \"1\"。 a[1] = \"11\"，表示 a[0] 中有一个 “1”。 a[2] = \"21\"，表示 a[1] 中有两个 “1”。 a[3] = \"1211\"，表示 a[2] 中有一个 “2” 和一个 “1”。 a[4] = \"111221\"，表示 a[3] 中有一个 “1”、一个 “2” 和两个 “1”。 即每一项的生成规则是：从前一项的数字中按顺序描述出现次数和对应的数字。\n例如：\na[0] = \"1\"，描述为 “一个 1”，得到 a[1] = \"11\"。 a[1] = \"11\"，描述为 “两个 1”，得到 a[2] = \"21\"。 a[2] = \"21\"，描述为 “一个 2，一个 1”，得到 a[3] = \"1211\"。 a[3] = \"1211\"，描述为 “一个 1，一个 2，两个 1”，得到 a[4] = \"111221\"。 请输出数列中的第 n 项。\n二、输入描述\n输入一个整数 n，表示数列中第 n 项的位置（0 \u003c= n \u003c= 59）。\n三、输出描述\n输出数列中第 n 项的内容。\n四、输入输出示例\n输入：\n5 输出\n312211 五、说明\n通过输入 n=5，输出 a[5]。 根据规则，数列的前几项如下： a[0] = \"1\" a[1] = \"11\" a[2] = \"21\" a[3] = \"1211\" a[4] = \"111221\" a[5] = \"312211\" SHOW CODE Java import java.util.Scanner; /** * @author Signal Yu * @since 2024-11-30 */ public class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); int n = Integer.parseInt(in.nextLine().trim()); String result = getNthTerm(n); System.out.println(result); } private static String getNthTerm(int n) { String term = \"1\"; // 初始项 a[0] = \"1\" // 逐项生成数列的每一项，直到第 n 项 for (int i = 1; i \u003c= n; i++) { term = describeTerm(term); // 对当前项描述生成下一项 } return term; } private static String describeTerm(String term) { StringBuilder nextTerm = new StringBuilder(); int count = 1; // 计数器，初始时认为当前数字出现了 1 次 // 从第二个字符开始遍历当前项，统计连续相同字符的次数 for (int i = 1; i \u003c term.length(); i++) { if (term.charAt(i) == term.charAt(i - 1)) { count++; // 当前字符与前一个字符相同，计数器加 1 } else { nextTerm.append(count).append(term.charAt(i - 1)); // 描述上一组数字 count = 1; // 重置计数器 } } // 处理最后一组字符 nextTerm.append(count).append(term.charAt(term.length() - 1)); return nextTerm.toString(); // 返回描述后的下一项 } } 前缀和模式相关算法题 找到数组的中间位置 【力扣传送门】 SHOW CODE Java class Solution { public int findMiddleIndex(int[] nums) { int totalSum = Arrays.stream(nums).sum(); int leftSum = 0; for (int i = 0; i \u003c nums.length; i++) { int rightSum = totalSum - leftSum - nums[i]; if (leftSum == rightSum) { return i; } leftSum += nums[i]; } return -1; } } 华为OD机试：阿里巴巴找黄金宝箱(I) 点击查看题目 一、题目描述\n樵夫阿里巴巴在砍柴路上意外发现了强盗团伙的藏宝地。藏宝地有一排编号从0到N的箱子，每个箱子上贴有一个数字。传说中，这些箱子里藏有一个黄金宝箱。\n黄金宝箱的定义是：它满足以下条件——在它之前所有箱子上数字的总和，等于在它之后所有箱子上数字的总和。\n第一个箱子左边部分的数字总和定义为0，最后一个箱子右边部分的数字总和也定义为0。\n请帮助阿里巴巴找到第一个符合条件的黄金宝箱，并输出该黄金宝箱的编号。如果不存在这样的黄金宝箱，则返回-1。\n二、输入描述\n一个用逗号分隔的数字列表，表示每个箱子上贴的数字，例如：1,-1,0。\n箱子的数量至少为1个，最多为10,000个。 每个箱子上的数字范围在-1000到1000之间。 三、输出描述\n输出第一个符合条件的黄金宝箱的编号，如果没有符合条件的宝箱，则输出-1。\n点击查看代码 Java import java.util.*; /** * @author Signal Yu * @since 2024-11-04 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取箱子数字 int[] boxNumbers = Arrays.stream(in.nextLine().trim().split(\",\")) .mapToInt(Integer::parseInt) .toArray(); in.close(); // 寻找黄金宝箱编号 int result = findTreasureBox(boxNumbers); // 输出结果 System.out.println(result); } private static int findTreasureBox(int[] boxNumbers) { // 计算箱子数字总和 int totalSum = Arrays.stream(boxNumbers).sum(); int leftSum = 0; for (int i = 0; i \u003c boxNumbers.length; i++) { int rightSum = totalSum - leftSum - boxNumbers[i]; if (leftSum == rightSum) { return i; } leftSum += boxNumbers[i]; } return -1; } } 华为 OD 光伏场地建设规划【100分】 SHOW PROBLEM 一、题目描述\n祖国西北部有一片广阔的荒地，零星分布着一些湖泊、保护区和矿区。整体上，这片地区常年光照良好，但也存在一些光照较差的区域。某电力公司希望在这片荒地上建设多个光伏电站，生产清洁能源。为了评估不同区域的发电潜力，对每平方公里的土地进行了发电量评估，其中不能建设的区域的发电量为0千瓦，能够建设的区域根据光照、地形等因素给出了每平方公里的年发电量（单位：千瓦）。我们希望能够找到其中发电量集中且合适的矩形区域用于建设光伏电站，从而获得良好的收益。\n二、输入描述\n第一行输入为调研区域的长、宽，以及准备建设电站的边长。电站的边长是正方形，且要求每个电站的最小年发电量。 随后的每一行包含调研区域中每平方公里的年发电量。 输入格式：\n第一行包含四个整数 L、W、S、M，其中： L：调研区域的长度。 W：调研区域的宽度。 S：电站的边长（单位：公里，正方形电站）。 M：电站的最低年发电量要求（单位：千瓦）。 接下来的 L 行，每行包含 W 个整数，表示该位置每平方公里的年发电量。 输入示例：\n2 5 2 6 2 3 7 1 4 3 5 2 8 1 三、输出描述\n输出符合要求的矩形区域的数量。即，每个边长为 S 的正方形区域（电站区域）在该区域内的年发电量总和大于或等于 M 的数量。 输出示例：\n4 四、补充说明\n调研区域的长宽 L 和 W 均大于等于 1。 电站的边长 S 大于等于 1，且 S 小于等于 L 和 W 中较小的那个值。 任何区域的年发电量都大于或等于 0千瓦。 SHOW CODE Java import java.util.*; /** * @author Signal Yu * @since 2024-12-1 */ public class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); int[] parts = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); int rows = parts[0]; int cols = parts[1]; int side = parts[2]; int minPower = parts[3]; int[][] matrixPower = new int[rows][cols]; for (int i = 0; i \u003c rows; i++) { matrixPower[i] = Arrays.stream(in.nextLine().trim().split(\" \")) .mapToInt(Integer::parseInt) .toArray(); } int result = countAvailableArea(matrixPower, side, minPower); System.out.println(result); } private static int countAvailableArea(int[][] matrixPower, int side, int minPower) { int rows = matrixPower.length; int cols = matrixPower[0].length; // 计算前缀和矩阵 int[][] prefix = calculatePrefixSum(matrixPower); int count = 0; // 遍历所有可能的电站位置，检查每个 SxS 子矩阵的发电量 for (int i = 0; i \u003c= rows - side; i++) { for (int j = 0; j \u003c= cols - side; j++) { // 计算当前子矩阵的总发电量 int totalPower = prefix[i+side][j+side] - prefix[i+side][j] - prefix[i][j+side] + prefix[i][j]; // 如果总发电量大于等于最低要求，则该区域有效 if (totalPower \u003e= minPower) { count++; } } } return count; } private static int[][] calculatePrefixSum(int[][] matrix) { int rows = matrix.length; int cols = matrix[0].length; int[][] prefix = new int[rows + 1][cols + 1]; for (int i = 1; i \u003c= rows; i++) { for (int j = 1; j \u003c= cols; j++) { prefix[i][j] = matrix[i-1][j-1] + prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1]; } } return prefix; } } $\\text{prefix}[i][j] = \\text{matrix}[i-1][j-1] + \\text{prefix}[i-1][j] + \\text{prefix}[i][j-1] - \\text{prefix}[i-1][j-1]\\dots i,j \u003e 0（减去重叠部分）$，\n$\\text{Sub-Matrix Sum} = \\text{prefix}[i+k_1][j+k_2] - \\text{prefix}[i][j+k_2] - \\text{prefix}[i+k_1][j] + \\text{prefix}[i][j];$\n单调队列模式相关算法题 绝对差不超过限制的最长连续子数组 【力扣传送门】 SHOW CODE Java class Solution { public int longestSubarray(int[] nums, int limit) { // 使用双端队列来维护当前窗口的最大值和最小值的索引 Deque maxDeque = new LinkedList\u003c\u003e(); Deque minDeque = new LinkedList\u003c\u003e(); int windowStart = 0, maxLength = 0; // 定义窗口的起始位置和最长子数组长度 for (int windowEnd = 0; windowEnd \u003c nums.length; windowEnd++) { int current = nums[windowEnd]; // 更新最大值队列，保持降序（队首为最大值） while (!maxDeque.isEmpty() \u0026\u0026 nums[maxDeque.peekLast()] \u003c current) { maxDeque.pollLast(); } maxDeque.offerLast(windowEnd); // 更新最小值队列，保持升序（队首为最小值） while (!minDeque.isEmpty() \u0026\u0026 nums[minDeque.peekLast()] \u003e current) { minDeque.pollLast(); } minDeque.offerLast(windowEnd); // 当当前窗口的最大值和最小值之差超过给定的限制时，收缩窗口 while (nums[maxDeque.peekFirst()] - nums[minDeque.peekFirst()] \u003e limit) { windowStart++; // 移动窗口的起始位置 // 移除超出窗口范围的元素索引 if (maxDeque.peekFirst() \u003c windowStart) { maxDeque.pollFirst(); } if (minDeque.peekFirst() \u003c windowStart) { minDeque.pollFirst(); } } // 更新最长子数组长度 maxLength = Math.max(maxLength, windowEnd - windowStart + 1); } return maxLength; } } 购买水果需要的最少金币数 【力扣传送门】 SHOW CODE Java class Solution { public int minimumCoins(int[] prices) { int n = prices.length; Deque deque = new LinkedList\u003c\u003e(); // 扩展数组，在末尾添加一个0，表示到达数组末尾的最终成本为0 prices = Arrays.copyOf(prices, n + 1); prices[n] = 0; // 基础情况：到达数组末尾的成本为0 deque.offerLast(n); // 初始化双端队列，末尾为最小成本的虚拟索引n // 从倒数第二个元素开始遍历数组，向前遍历至数组开头 for (int i = n - 1; i \u003e= 0; i--) { int maxCoveredIndex = Math.min(n, 2 * i + 2); // 计算当前水果的最大覆盖索引范围 // 从双端队列头部移除超出当前水果覆盖范围的索引 while (!deque.isEmpty() \u0026\u0026 deque.peekFirst() \u003e maxCoveredIndex) { deque.pollFirst(); } // 更新当前水果的成本，加上该水果可达的最小成本 prices[i] += prices[deque.peekFirst()]; // 维持单调递增的双端队列，移除队列尾部比当前成本大的元素 while (!deque.isEmpty() \u0026\u0026 prices[deque.peekLast()] \u003e prices[i]) { deque.pollLast(); } // 将当前索引加入队列，以便后续计算中使用最小值 deque.offerLast(i); } return prices[0]; // 返回从第一个物品开始的最小硬币总成本 } } 不间断子数组 【力扣传送门】 SHOW CODE Java class Solution { Deque increasingQ; Deque decreasingQ; public long continuousSubarrays(int[] nums) { increasingQ = new LinkedList\u003c\u003e(); decreasingQ = new LinkedList\u003c\u003e(); int start = 0; long result = 0; // 扩展窗口的终止位置 for (int end = 0; end \u003c nums.length; end++) { // 更新递增队列，确保队列从小到大有序 while (!increasingQ.isEmpty() \u0026\u0026 increasingQ.peekLast() \u003e nums[end]) { increasingQ.pollLast(); } // 更新递减队列，确保队列从大到小有序 while (!decreasingQ.isEmpty() \u0026\u0026 decreasingQ.peekLast() \u003c nums[end]) { decreasingQ.pollLast(); } // 将当前元素加入递增和递减队列 increasingQ.offerLast(nums[end]); decreasingQ.offerLast(nums[end]); // 检查当前窗口是否满足最大值和最小值之差不超过2的条件 while (getMaxInSubArray() - getMinInSubArray() \u003e 2) { // 如果不满足条件，收缩窗口左边界 if (!increasingQ.isEmpty() \u0026\u0026 increasingQ.peekFirst() == nums[start]) { increasingQ.pollFirst(); // 移除递增队列的头部元素 } if (!decreasingQ.isEmpty() \u0026\u0026 decreasingQ.peekFirst() == nums[start]) { decreasingQ.pollFirst(); // 移除递减队列的头部元素 } start++; // 收缩窗口左边界 } // 增加当前窗口内满足条件的子数组数量 result += end - start + 1; } return result; } // 获取当前窗口中的最大值 private long getMaxInSubArray() { return decreasingQ.isEmpty() ? -1 : decreasingQ.peekFirst(); } // 获取当前窗口中的最小值 private long getMinInSubArray() { return increasingQ.isEmpty() ? -1 : increasingQ.peekFirst(); } } HashMap/List/Set 模式相关算法题 华为OD机试：环中最长子串【100分】 点击查看题目 题目描述\n给定一个字符串 s，假设该字符串首尾相连形成一个环形，请在环形字符串中找出包含 o 字符出现偶数次的最长子字符串，并输出该子字符串的长度。\n输入描述\n输入为一个仅由小写字母组成的字符串 s。\n输出描述\n输出一个整数，表示符合条件的最长子字符串的长度。\n示例\n输入：\nalolobo 输出：\n6 示例说明\n在输入字符串 alolobo 中，符合条件的最长子字符串之一是 alolob，它包含 2 个 o 字符，因此其长度为 6。\n点击查看代码 Java import java.util.*; /** * @author Signal Yu * @since 2024-11-06 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取字符串 String s = in.nextLine().trim(); // 计算最长出现了'o'字符的最长子串长度 int maxLength = computeMaxLength(s); // 输出结果 System.out.println(maxLength); } private static int computeMaxLength(String s) { Map frequencyMap = new HashMap\u003c\u003e(); // 统计字符串中各字符出现的频率 for (char c : s.toCharArray()) { frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1); } // 字母'o'的频率 int oCount = frequencyMap.getOrDefault('o', 0); if (oCount % 2 == 0) { // 字母'o'的长度为偶数，直接返回字符串的长度 return s.length(); } else { // 字母'o'的长度为奇数，返回字符串的长度减1 return s.length() - 1; } } } 字符串中的第一个唯一字符 【力扣传送门】 SHOW CODE Java class Solution { public int firstUniqChar(String s) { Map frequencyMap = new HashMap\u003c\u003e(); // 统计字符串中的字母频率 for (char c : s.toCharArray()) { frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1); } // 查找第一个只出现一次的字符，并返回其索引 for (int i = 0; i \u003c s.length(); i++) { if (frequencyMap.get(s.charAt(i)) == 1) { return i; } } // 若无唯一字符，返回 -1 return -1; } } “气球” 的最大数量 【力扣传送门】 SHOW CODE Java class Solution { public int maxNumberOfBalloons(String text) { // 定义 balloon 中字符所需的频率，其中 'l' 和 'o' 的需求为 2 Map requiredCharMap = Map.of( 'b', 1, 'a', 1, 'l', 2, 'o', 2, 'n', 1); // 统计 text 中与 balloon 相关字符的出现次数 Map availableCharMap = new HashMap\u003c\u003e(); for (char c : text.toCharArray()) { if (requiredCharMap.containsKey(c)) { availableCharMap.put(c, availableCharMap.getOrDefault(c, 0) + 1); } } // 计算可以拼成 \"balloon\" 的最大次数 int maxCount = Integer.MAX_VALUE; if (availableCharMap.size() == requiredCharMap.size()) { for (char c : availableCharMap.keySet()) { int requiredCount = requiredCharMap.get(c); int availableCount = availableCharMap.get(c); maxCount = Math.min(maxCount, availableCount / requiredCount); } } return (maxCount == Integer.MAX_VALUE) ? 0 : maxCount; } } 最长回文串 【力扣传送门】 SHOW CODE Java class Solution { public int longestPalindrome(String s) { // 统计每个字符的出现频率 Map frequencyMap = new HashMap\u003c\u003e(); for (char c : s.toCharArray()) { frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1); } int maxLength = 0; boolean oddFound = false; // 用于检测是否有频率为奇数的字符 // 计算最长的回文长度 for (int count : frequencyMap.values()) { if (count % 2 == 0) { maxLength += count; // 如果频率为偶数，直接加入到长度 } else { maxLength += count - 1; // 对于奇数频率，加入最大偶数部分 oddFound = true; // 标记存在奇数频率字符 } } // 如果存在奇数频率字符，可将其中一个放在回文中心 return oddFound ? maxLength + 1 : maxLength; } } 赎金信 【力扣传送门】 SHOW CODE Java class Solution { public boolean canConstruct(String ransomNote, String magazine) { // 若 ransomNote 比 magazine 长，则直接返回 false if (ransomNote.length() \u003e magazine.length()) { return false; } // 用数组统计 magazine 中每个字母的出现频率 int[] charCount = new int[26]; for (char c : magazine.toCharArray()) { charCount[c - 'a']++; } // 检查 ransomNote 中每个字母的需求是否可以在 magazine 中满足 for (char c : ransomNote.toCharArray()) { if (charCount[c - 'a'] == 0) { return false; } charCount[c - 'a']--; } return true; } } 华为OD机试：数组去重和排序【100分】 点击查看题目 一、题目描述\n给定一个乱序的数组，删除所有重复元素，使得每个元素只出现一次，并按照出现次数从高到低进行排序。对于出现次数相同的元素，按照它们第一次出现的顺序进行排序。\n二、输入描述\n输入为一个数组，元素之间用逗号分隔。\n三、输出描述\n输出去重并排序后的数组，元素之间用逗号分隔。\n输入示例\n1,3,3,3,2,4,4,4,5 输出示例\n3,4,1,2,5 备注\n数组大小不超过100。 数组元素的值不超过100。 点击查看代码 Java import java.util.*; /** * @author Signal Yu * @since 2024-10-28 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取输入数组 int[] nums = Arrays.stream(in.nextLine().split(\",\")) .map(String::trim) .mapToInt(Integer::parseInt) .toArray(); // 去重并排序 int[] result = removeDuplicatesAndSort(nums); // 输出结果 formatOutput(result); } private static void formatOutput(int[] nums) { StringBuilder sb = new StringBuilder(); for (int num : nums) { sb.append(num).append(\",\"); } sb.setLength(sb.length() - 1); System.out.println(sb); } private static int[] removeDuplicatesAndSort(int[] nums) { Map frequencyMap = new HashMap\u003c\u003e(); List orderList = new ArrayList\u003c\u003e(); // 统计数字出现次数 for (int num : nums) { if (!frequencyMap.containsKey(num)) { // 第一次出现，记录在顺序表中 orderList.add(num); } frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1); } // 根据出现次数进行排序处理 orderList.sort((a, b) -\u003e frequencyMap.get(b).compareTo(frequencyMap.get(a))); return orderList.stream().mapToInt(Integer::intValue).toArray(); } } 华为OD机试：垃圾信息拦截【100分】 点击查看题目 一、题目描述\n大众对垃圾短信深恶痛绝，希望能识别垃圾短信发送者。经过分析，发现正常用户的短信通常具备交互性，而垃圾短信往往是大量单向的短信。根据如下规则进行垃圾短信识别：\n发送者 A 如果符合以下任一条件，则认为 A 是垃圾短信发送者：\n① A 发送短信的接收者中，没有向 A 发送过短信的人数 $L \u003e 5$；\n② $A 发送的短信数 - A 接收的短信数 M \u003e 10$；\n③ 存在接收者 $X$，使得 $A 发送给 X 的短信数 - A 接收到 X 的短信数 N \u003e 5$。\n二、输入描述\n第一行为条目数目，接下来的几行是具体的条目。每个条目是一个发送者 ID 和一个接收者 ID，之间用空格隔开。所有 ID 为无符号整型，最大值为 100；同一条目中两个 ID 不会相同（即不会自己给自己发消息）。最后一行为指定的 ID。\n三、输出描述\n输出结果为字符串。\n首先输出该 ID 是否为垃圾短信发送者（是则输出 true，否则输出 false），并按序列输出 L 和 M 的值（N 值不需要输出）。\n示例\n输入 8 1 2 1 3 1 4 1 5 1 6 6 1 5 2 6 3 1 输出 false 4 1 说明 输出该 ID 是否为垃圾短信发送者（是则输出 true，否则输出 false），并按序列输出 L 和 M 的值； L 为没有向 A 发过短信的人数，M 为 A 接收的短信数。 在示例中，A 接收的短信数 M 为 1，而没有向 A 发过短信的人数 L 为 4。 点击查看代码 Java import java.util.*; /** * @author Signal Yu * @since 2024-11-11 */ class Solution { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 读取条目数 n int n = Integer.parseInt(in.nextLine().trim()); // 构建发送者到接收者的映射关系 Map",
  "wordCount" : "24813",
  "inLanguage": "en",
  "datePublished": "2024-12-02T15:15:55+08:00",
  "dateModified": "2024-12-02T15:15:55+08:00",
  "author":{
    "@type": "Person",
    "name": "Signal Yu"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/programming/coding-problems/1-coding-problem-set/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Signal's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://signalyu.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://signalyu.github.io/" accesskey="h" title="Signal&#39;s Blog (Alt + H)">
                <img src="https://signalyu.github.io/apple-touch-icon.png" alt="" aria-label="logo"
                    height="40">Signal&#39;s Blog</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://signalyu.github.io/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://signalyu.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://signalyu.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://signalyu.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://signalyu.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Coding Problem Set
    </h1>
    <div class="post-meta"><span title='2024-12-02 15:15:55 +0800 HKT'>Dec 2 2024</span>&nbsp;·&nbsp;Signal Yu

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#string" aria-label="String">String</a><ul>
                        
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%88%86%e5%89%b2100%e5%88%86" aria-label="华为OD机试：字符串分割【100分】">华为OD机试：字符串分割【100分】</a></li>
                <li>
                    <a href="#%e5%ad%97%e7%ac%a6%e5%8c%b9%e9%85%8d100%e5%88%86" aria-label="字符匹配【100分】">字符匹配【100分】</a></li></ul>
                </li>
                <li>
                    <a href="#queue" aria-label="Queue">Queue</a><ul>
                        
                <li>
                    <a href="#%e9%93%b6%e8%a1%8c%e6%8f%92%e9%98%9f" aria-label="银行插队">银行插队</a></li></ul>
                </li>
                <li>
                    <a href="#two-pointers" aria-label="Two Pointers">Two Pointers</a><ul>
                        
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e6%9c%80%e5%a4%a7%e8%8a%b1%e8%b4%b9%e9%87%91%e9%a2%9d100%e5%88%86" aria-label="华为OD机试：最大花费金额【100分】">华为OD机试：最大花费金额【100分】</a></li>
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%ba%8f%e5%88%97%e5%88%a4%e5%ae%9a100%e5%88%86" aria-label="华为OD机试：字符串序列判定【100分】">华为OD机试：字符串序列判定【100分】</a></li>
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e7%a7%9f%e8%bd%a6%e9%aa%91%e7%bb%bf%e9%81%93100%e5%88%86" aria-label="华为OD机试：租车骑绿道【100分】">华为OD机试：租车骑绿道【100分】</a></li>
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e6%b1%82%e6%9c%80%e5%a4%9a%e5%8f%af%e4%bb%a5%e6%b4%be%e5%87%ba%e5%a4%9a%e5%b0%91%e6%94%af%e5%9b%a2%e9%98%9f100%e5%88%86" aria-label="华为OD机试：求最多可以派出多少支团队【100分】">华为OD机试：求最多可以派出多少支团队【100分】</a></li>
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e5%af%bb%e6%89%be%e8%ba%ab%e9%ab%98%e7%9b%b8%e8%bf%91%e7%9a%84%e5%b0%8f%e6%9c%8b%e5%8f%8b100%e5%88%86" aria-label="华为OD机试：寻找身高相近的小朋友【100分】">华为OD机试：寻找身高相近的小朋友【100分】</a></li>
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e5%a4%aa%e9%98%b3%e8%83%bd%e6%9d%bf%e6%9c%80%e5%a4%a7%e9%9d%a2%e7%a7%af100%e5%88%86" aria-label="华为OD机试：太阳能板最大面积【100分】">华为OD机试：太阳能板最大面积【100分】</a></li></ul>
                </li>
                <li>
                    <a href="#sliding-window" aria-label="Sliding Window">Sliding Window</a><ul>
                        
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e5%af%bb%e6%89%be%e8%bf%9e%e7%bb%ad%e5%8c%ba%e9%97%b4100%e5%88%86" aria-label="华为OD机试：寻找连续区间【100分】">华为OD机试：寻找连续区间【100分】</a></li>
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e9%98%bf%e9%87%8c%e5%b7%b4%e5%b7%b4%e6%89%be%e9%bb%84%e9%87%91%e5%ae%9d%e7%ae%b1v100%e5%88%86" aria-label="华为OD机试：阿里巴巴找黄金宝箱(V)【100分】">华为OD机试：阿里巴巴找黄金宝箱(V)【100分】</a></li>
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e6%9c%80%e5%a4%9a%e8%b4%ad%e4%b9%b0%e5%ae%9d%e7%9f%b3%e6%95%b0%e7%9b%ae100%e5%88%86" aria-label="华为OD机试：最多购买宝石数目【100分】">华为OD机试：最多购买宝石数目【100分】</a></li>
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e6%89%be%e5%87%ba%e9%80%9a%e8%bf%87%e8%bd%a6%e8%be%86%e6%9c%80%e5%a4%9a%e9%a2%9c%e8%89%b2100%e5%88%86" aria-label="华为OD机试：找出通过车辆最多颜色【100分】">华为OD机试：找出通过车辆最多颜色【100分】</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3%e6%a8%a1%e5%bc%8f%e7%9b%b8%e5%85%b3%e7%ae%97%e6%b3%95%e9%a2%98" aria-label="滑动窗口模式相关算法题">滑动窗口模式相关算法题</a><ul>
                        
                <li>
                    <a href="#%e9%95%bf%e5%ba%a6%e6%9c%80%e5%b0%8f%e7%9a%84%e5%ad%90%e6%95%b0%e7%bb%84" aria-label="长度最小的子数组">长度最小的子数组</a></li>
                <li>
                    <a href="#%e6%b0%b4%e6%9e%9c%e6%88%90%e7%af%ae" aria-label="水果成篮">水果成篮</a></li>
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e8%ae%a1%e7%ae%97%e6%9c%80%e6%8e%a5%e8%bf%91%e7%9a%84%e6%95%b0100%e5%88%86" aria-label="华为OD机试：计算最接近的数【100分】">华为OD机试：计算最接近的数【100分】</a></li>
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e7%94%a8%e8%bf%9e%e7%bb%ad%e8%87%aa%e7%84%b6%e6%95%b0%e4%b9%8b%e5%92%8c%e6%9d%a5%e8%a1%a8%e8%be%be%e6%95%b4%e6%95%b0100%e5%88%86" aria-label="华为OD机试：用连续自然数之和来表达整数【100分】">华为OD机试：用连续自然数之和来表达整数【100分】</a></li>
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3%e6%9c%80%e5%a4%a7%e5%92%8c100%e5%88%86" aria-label="华为OD机试：滑动窗口最大和【100分】">华为OD机试：滑动窗口最大和【100分】</a></li>
                <li>
                    <a href="#%e6%9b%bf%e6%8d%a2%e5%90%8e%e7%9a%84%e6%9c%80%e9%95%bf%e9%87%8d%e5%a4%8d%e5%ad%97%e7%ac%a6" aria-label="替换后的最长重复字符">替换后的最长重复字符</a></li>
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e8%a1%a5%e7%a7%8d%e6%9c%aa%e6%88%90%e6%b4%bb%e8%83%a1%e6%9d%a8100%e5%88%86" aria-label="华为OD机试：补种未成活胡杨【100分】">华为OD机试：补种未成活胡杨【100分】</a></li>
                <li>
                    <a href="#%e6%9c%80%e5%a4%a7%e8%bf%9e%e7%bb%ad1%e7%9a%84%e4%b8%aa%e6%95%b0-iii" aria-label="最大连续1的个数 III">最大连续1的个数 III</a></li>
                <li>
                    <a href="#%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%9a%84%e6%8e%92%e5%88%97" aria-label="字符串的排列">字符串的排列</a></li>
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e5%85%b3%e8%81%94%e5%ad%90%e4%b8%b2100%e5%88%86" aria-label="华为OD机试：关联子串【100分】">华为OD机试：关联子串【100分】</a></li>
                <li>
                    <a href="#%e6%89%be%e5%88%b0%e5%ad%97%e7%ac%a6%e4%b8%b2%e4%b8%ad%e6%89%80%e6%9c%89%e5%ad%97%e6%af%8d%e5%bc%82%e4%bd%8d%e8%af%8d" aria-label="找到字符串中所有字母异位词">找到字符串中所有字母异位词</a></li>
                <li>
                    <a href="#%e6%9c%80%e5%b0%8f%e8%a6%86%e7%9b%96%e5%ad%90%e4%b8%b2" aria-label="最小覆盖子串">最小覆盖子串</a></li>
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e6%9c%80%e5%b7%a6%e4%be%a7%e5%86%97%e4%bd%99%e8%a6%86%e7%9b%96%e5%ad%90%e4%b8%b2100%e5%88%86" aria-label="华为OD机试：最左侧冗余覆盖子串【100分】">华为OD机试：最左侧冗余覆盖子串【100分】</a></li>
                <li>
                    <a href="#%e4%b8%b2%e8%81%94%e6%89%80%e6%9c%89%e5%8d%95%e8%af%8d%e7%9a%84%e5%ad%90%e4%b8%b2" aria-label="串联所有单词的子串">串联所有单词的子串</a></li>
                <li>
                    <a href="#%e5%8c%85%e5%90%ab%e6%89%80%e6%9c%89%e4%b8%89%e7%a7%8d%e5%ad%97%e7%ac%a6%e7%9a%84%e5%ad%90%e5%ad%97%e7%ac%a6%e4%b8%b2%e6%95%b0%e7%9b%ae" aria-label="包含所有三种字符的子字符串数目">包含所有三种字符的子字符串数目</a></li>
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e4%bc%98%e9%9b%85%e5%ad%90%e6%95%b0%e7%bb%84100%e5%88%86" aria-label="华为OD机试：优雅子数组【100分】">华为OD机试：优雅子数组【100分】</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%95%b0%e5%ad%a6%e4%b8%8e%e9%80%bb%e8%be%91%e5%88%86%e6%9e%90%e6%a8%a1%e5%bc%8f%e7%9b%b8%e5%85%b3%e7%ae%97%e6%b3%95%e9%a2%98" aria-label="数学与逻辑分析模式相关算法题">数学与逻辑分析模式相关算法题</a><ul>
                        
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e8%80%83%e5%8b%a4%e4%bf%a1%e6%81%af100%e5%88%86" aria-label="华为OD机试：考勤信息【100分】">华为OD机试：考勤信息【100分】</a></li>
                <li>
                    <a href="#%e8%b4%a8%e6%95%b0%e5%87%8f%e6%b3%95%e8%bf%90%e7%ae%97" aria-label="质数减法运算">质数减法运算</a></li>
                <li>
                    <a href="#%e6%95%b0%e5%88%97%e6%8f%8f%e8%bf%b0100%e5%88%86" aria-label="数列描述【100分】">数列描述【100分】</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%89%8d%e7%bc%80%e5%92%8c%e6%a8%a1%e5%bc%8f%e7%9b%b8%e5%85%b3%e7%ae%97%e6%b3%95%e9%a2%98" aria-label="前缀和模式相关算法题">前缀和模式相关算法题</a><ul>
                        
                <li>
                    <a href="#%e6%89%be%e5%88%b0%e6%95%b0%e7%bb%84%e7%9a%84%e4%b8%ad%e9%97%b4%e4%bd%8d%e7%bd%ae" aria-label="找到数组的中间位置">找到数组的中间位置</a></li>
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e9%98%bf%e9%87%8c%e5%b7%b4%e5%b7%b4%e6%89%be%e9%bb%84%e9%87%91%e5%ae%9d%e7%ae%b1i" aria-label="华为OD机试：阿里巴巴找黄金宝箱(I)">华为OD机试：阿里巴巴找黄金宝箱(I)</a></li>
                <li>
                    <a href="#%e5%8d%8e%e4%b8%ba-od" aria-label="华为 OD">华为 OD</a></li>
                <li>
                    <a href="#%e5%85%89%e4%bc%8f%e5%9c%ba%e5%9c%b0%e5%bb%ba%e8%ae%be%e8%a7%84%e5%88%92100%e5%88%86" aria-label="光伏场地建设规划【100分】">光伏场地建设规划【100分】</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97%e6%a8%a1%e5%bc%8f%e7%9b%b8%e5%85%b3%e7%ae%97%e6%b3%95%e9%a2%98" aria-label="单调队列模式相关算法题">单调队列模式相关算法题</a><ul>
                        
                <li>
                    <a href="#%e7%bb%9d%e5%af%b9%e5%b7%ae%e4%b8%8d%e8%b6%85%e8%bf%87%e9%99%90%e5%88%b6%e7%9a%84%e6%9c%80%e9%95%bf%e8%bf%9e%e7%bb%ad%e5%ad%90%e6%95%b0%e7%bb%84" aria-label="绝对差不超过限制的最长连续子数组">绝对差不超过限制的最长连续子数组</a></li>
                <li>
                    <a href="#%e8%b4%ad%e4%b9%b0%e6%b0%b4%e6%9e%9c%e9%9c%80%e8%a6%81%e7%9a%84%e6%9c%80%e5%b0%91%e9%87%91%e5%b8%81%e6%95%b0" aria-label="购买水果需要的最少金币数">购买水果需要的最少金币数</a></li>
                <li>
                    <a href="#%e4%b8%8d%e9%97%b4%e6%96%ad%e5%ad%90%e6%95%b0%e7%bb%84" aria-label="不间断子数组">不间断子数组</a></li></ul>
                </li>
                <li>
                    <a href="#hashmaplistset-%e6%a8%a1%e5%bc%8f%e7%9b%b8%e5%85%b3%e7%ae%97%e6%b3%95%e9%a2%98" aria-label="HashMap/List/Set 模式相关算法题">HashMap/List/Set 模式相关算法题</a><ul>
                        
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e7%8e%af%e4%b8%ad%e6%9c%80%e9%95%bf%e5%ad%90%e4%b8%b2100%e5%88%86" aria-label="华为OD机试：环中最长子串【100分】">华为OD机试：环中最长子串【100分】</a></li>
                <li>
                    <a href="#%e5%ad%97%e7%ac%a6%e4%b8%b2%e4%b8%ad%e7%9a%84%e7%ac%ac%e4%b8%80%e4%b8%aa%e5%94%af%e4%b8%80%e5%ad%97%e7%ac%a6" aria-label="字符串中的第一个唯一字符">字符串中的第一个唯一字符</a></li>
                <li>
                    <a href="#%e6%b0%94%e7%90%83-%e7%9a%84%e6%9c%80%e5%a4%a7%e6%95%b0%e9%87%8f" aria-label="“气球” 的最大数量">“气球” 的最大数量</a></li>
                <li>
                    <a href="#%e6%9c%80%e9%95%bf%e5%9b%9e%e6%96%87%e4%b8%b2" aria-label="最长回文串">最长回文串</a></li>
                <li>
                    <a href="#%e8%b5%8e%e9%87%91%e4%bf%a1" aria-label="赎金信">赎金信</a></li>
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d%e5%92%8c%e6%8e%92%e5%ba%8f100%e5%88%86" aria-label="华为OD机试：数组去重和排序【100分】">华为OD机试：数组去重和排序【100分】</a></li>
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e5%9e%83%e5%9c%be%e4%bf%a1%e6%81%af%e6%8b%a6%e6%88%aa100%e5%88%86" aria-label="华为OD机试：垃圾信息拦截【100分】">华为OD机试：垃圾信息拦截【100分】</a></li>
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e6%9c%80%e5%a4%a7n%e4%b8%aa%e6%95%b0%e4%b8%8e%e6%9c%80%e5%b0%8fn%e4%b8%aa%e6%95%b0%e7%9a%84%e5%92%8c100%e5%88%86" aria-label="华为OD机试：最大N个数与最小N个数的和【100分】">华为OD机试：最大N个数与最小N个数的和【100分】</a></li>
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e5%85%a8%e9%87%8f%e5%92%8c%e5%b7%b2%e5%8d%a0%e7%94%a8%e5%ad%97%e7%ac%a6%e9%9b%86100%e5%88%86" aria-label="华为OD机试：全量和已占用字符集【100分】">华为OD机试：全量和已占用字符集【100分】</a></li>
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e5%91%8a%e8%ad%a6%e6%8a%91%e5%88%b6100%e5%88%86" aria-label="华为OD机试：告警抑制【100分】">华为OD机试：告警抑制【100分】</a></li>
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e6%8a%a5%e6%96%87%e5%9b%9e%e8%b7%af100%e5%88%86" aria-label="华为OD机试：报文回路【100分】">华为OD机试：报文回路【100分】</a></li>
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e5%bc%82%e5%b8%b8%e7%9a%84%e6%89%93%e5%8d%a1%e8%ae%b0%e5%bd%95100%e5%88%86" aria-label="华为OD机试：异常的打卡记录【100分】">华为OD机试：异常的打卡记录【100分】</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95%e6%a8%a1%e5%bc%8f%e7%9b%b8%e5%85%b3%e7%ae%97%e6%b3%95%e9%a2%98" aria-label="贪心算法模式相关算法题">贪心算法模式相关算法题</a><ul>
                        
                <li>
                    <a href="#%e6%95%91%e7%94%9f%e8%89%87" aria-label="救生艇">救生艇</a></li>
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e7%a7%9f%e8%bd%a6%e9%aa%91%e7%bb%bf%e9%81%93100%e5%88%86-1" aria-label="华为OD机试：租车骑绿道【100分】">华为OD机试：租车骑绿道【100分】</a></li>
                <li>
                    <a href="#%e9%aa%8c%e8%af%81%e5%9b%9e%e6%96%87%e4%b8%b2-ii" aria-label="验证回文串 II">验证回文串 II</a></li>
                <li>
                    <a href="#%e6%9c%80%e9%95%bf%e6%95%b0%e5%af%b9%e9%93%be" aria-label="最长数对链">最长数对链</a></li>
                <li>
                    <a href="#%e4%bd%bf%e6%8b%ac%e5%8f%b7%e6%9c%89%e6%95%88%e7%9a%84%e6%9c%80%e5%b0%91%e6%b7%bb%e5%8a%a0" aria-label="使括号有效的最少添加">使括号有效的最少添加</a></li>
                <li>
                    <a href="#%e5%8e%bb%e9%99%a4%e9%87%8d%e5%a4%8d%e5%ad%97%e6%af%8d" aria-label="去除重复字母">去除重复字母</a></li>
                <li>
                    <a href="#%e6%9c%80%e5%a4%a7%e5%9b%9e%e6%96%87%e6%95%b0%e5%ad%97" aria-label="最大回文数字">最大回文数字</a></li>
                <li>
                    <a href="#%e4%bb%8e%e6%95%b0%e7%bb%84%e4%b8%ad%e7%a7%bb%e9%99%a4%e6%9c%80%e5%a4%a7%e5%80%bc%e5%92%8c%e6%9c%80%e5%b0%8f%e5%80%bc" aria-label="从数组中移除最大值和最小值">从数组中移除最大值和最小值</a></li>
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e6%a8%a1%e6%8b%9f%e5%95%86%e5%9c%ba%e4%bc%98%e6%83%a0%e6%89%93%e6%8a%98ii100%e5%88%86" aria-label="华为OD机试：模拟商场优惠打折II【100分】">华为OD机试：模拟商场优惠打折II【100分】</a></li>
                <li>
                    <a href="#%e6%89%a7%e8%a1%8c%e4%bb%bb%e5%8a%a1%e8%b5%9a%e7%a7%af%e5%88%86100%e5%88%86" aria-label="执行任务赚积分【100分】">执行任务赚积分【100分】</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%a0%88%e6%a8%a1%e5%bc%8f%e7%9b%b8%e5%85%b3%e7%ae%97%e6%b3%95%e9%a2%98" aria-label="栈模式相关算法题">栈模式相关算法题</a><ul>
                        
                <li>
                    <a href="#%e5%88%a0%e9%99%a4%e5%ad%97%e7%ac%a6%e4%b8%b2%e4%b8%ad%e7%9a%84%e6%89%80%e6%9c%89%e7%9b%b8%e9%82%bb%e9%87%8d%e5%a4%8d%e9%a1%b9" aria-label="删除字符串中的所有相邻重复项">删除字符串中的所有相邻重复项</a></li>
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e5%ad%97%e7%ac%a6%e4%b8%b2%e6%b6%88%e9%99%a4100%e5%88%86" aria-label="华为OD机试：字符串消除【100分】">华为OD机试：字符串消除【100分】</a></li>
                <li>
                    <a href="#%e6%9c%89%e6%95%88%e7%9a%84%e6%8b%ac%e5%8f%b7" aria-label="有效的括号">有效的括号</a></li>
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e6%9c%80%e5%a4%a7%e6%8b%ac%e5%8f%b7%e6%b7%b1%e5%ba%a6100%e5%88%86" aria-label="华为OD机试：最大括号深度【100分】">华为OD机试：最大括号深度【100分】</a></li>
                <li>
                    <a href="#%e5%88%a0%e9%99%a4%e5%ad%97%e7%ac%a6%e4%b8%b2%e4%b8%ad%e7%9a%84%e6%89%80%e6%9c%89%e7%9b%b8%e9%82%bb%e9%87%8d%e5%a4%8d%e9%a1%b9-ii" aria-label="删除字符串中的所有相邻重复项 II">删除字符串中的所有相邻重复项 II</a></li>
                <li>
                    <a href="#%e7%ae%80%e5%8c%96%e8%b7%af%e5%be%84" aria-label="简化路径">简化路径</a></li>
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e6%a8%a1%e6%8b%9f%e7%9b%ae%e5%bd%95%e7%ae%a1%e7%90%86100%e5%88%86" aria-label="华为OD机试：模拟目录管理【100分】">华为OD机试：模拟目录管理【100分】</a></li>
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e8%8d%92%e5%b2%9b%e6%b1%82%e7%94%9f100%e5%88%86" aria-label="华为OD机试：荒岛求生【100分】">华为OD机试：荒岛求生【100分】</a></li>
                <li>
                    <a href="#%e5%ad%97%e7%ac%a6%e4%b8%b2%e8%a7%a3%e7%a0%81" aria-label="字符串解码">字符串解码</a></li>
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e7%ae%80%e5%8d%95%e7%9a%84%e8%a7%a3%e5%8e%8b%e7%bc%a9%e7%ae%97%e6%b3%95100%e5%88%86" aria-label="华为OD机试：简单的解压缩算法【100分】">华为OD机试：简单的解压缩算法【100分】</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%8d%95%e8%b0%83%e6%a0%88%e6%a8%a1%e5%bc%8f%e7%9b%b8%e5%85%b3%e7%ae%97%e6%b3%95%e9%a2%98" aria-label="单调栈模式相关算法题">单调栈模式相关算法题</a><ul>
                        
                <li>
                    <a href="#%e4%b8%8b%e4%b8%80%e4%b8%aa%e6%9b%b4%e5%a4%a7%e5%85%83%e7%b4%a0-i" aria-label="下一个更大元素 I">下一个更大元素 I</a></li>
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e5%88%86%e5%a5%96%e9%87%91100%e5%88%86" aria-label="华为OD机试：分奖金【100分】">华为OD机试：分奖金【100分】</a></li>
                <li>
                    <a href="#%e6%af%8f%e6%97%a5%e6%b8%a9%e5%ba%a6" aria-label="每日温度">每日温度</a></li>
                <li>
                    <a href="#%e4%b8%8b%e4%b8%80%e4%b8%aa%e6%9b%b4%e5%a4%a7%e5%85%83%e7%b4%a0-ii" aria-label="下一个更大元素 II">下一个更大元素 II</a></li>
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e9%98%bf%e9%87%8c%e5%b7%b4%e5%b7%b4%e6%89%be%e9%bb%84%e9%87%91%e5%ae%9d%e7%ae%b1iv100%e5%88%86" aria-label="华为OD机试：阿里巴巴找黄金宝箱（IV）【100分】">华为OD机试：阿里巴巴找黄金宝箱（IV）【100分】</a></li>
                <li>
                    <a href="#%e4%bb%8e%e9%93%be%e8%a1%a8%e4%b8%ad%e7%a7%bb%e9%99%a4%e8%8a%82%e7%82%b9" aria-label="从链表中移除节点">从链表中移除节点</a></li>
                <li>
                    <a href="#%e7%a7%bb%e6%8e%89-k-%e4%bd%8d%e6%95%b0%e5%ad%97" aria-label="移掉 K 位数字">移掉 K 位数字</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ad%90%e9%9b%86%e6%a8%a1%e5%bc%8f%e7%9b%b8%e5%85%b3%e7%ae%97%e6%b3%95%e9%a2%98" aria-label="子集模式相关算法题">子集模式相关算法题</a><ul>
                        
                <li>
                    <a href="#%e5%ad%90%e9%9b%86" aria-label="子集">子集</a></li>
                <li>
                    <a href="#%e5%ad%90%e9%9b%86-ii" aria-label="子集 II">子集 II</a></li>
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e6%9f%a5%e6%89%be%e5%85%85%e7%94%b5%e8%ae%be%e5%a4%87100%e5%88%86" aria-label="华为OD机试：查找充电设备【100分】">华为OD机试：查找充电设备【100分】</a></li>
                <li>
                    <a href="#%e5%85%a8%e6%8e%92%e5%88%97" aria-label="全排列">全排列</a></li>
                <li>
                    <a href="#%e5%ad%97%e6%af%8d%e5%a4%a7%e5%b0%8f%e5%86%99%e5%85%a8%e6%8e%92%e5%88%97" aria-label="字母大小写全排列">字母大小写全排列</a></li>
                <li>
                    <a href="#%e6%8b%ac%e5%8f%b7%e7%94%9f%e6%88%90" aria-label="括号生成">括号生成</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%8c%ba%e9%97%b4%e5%90%88%e5%b9%b6%e6%a8%a1%e5%bc%8f%e7%9b%b8%e5%85%b3%e7%ae%97%e6%b3%95%e9%a2%98" aria-label="区间合并模式相关算法题">区间合并模式相关算法题</a><ul>
                        
                <li>
                    <a href="#%e5%90%88%e5%b9%b6%e5%8c%ba%e9%97%b4" aria-label="合并区间">合并区间</a></li>
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e4%bc%9a%e8%ae%ae%e5%ae%a4%e5%8d%a0%e7%94%a8%e6%97%b6%e9%97%b4%e6%ae%b5100%e5%88%86" aria-label="华为OD机试：会议室占用时间段【100分】">华为OD机试：会议室占用时间段【100分】</a></li>
                <li>
                    <a href="#%e5%8d%8e%e4%b8%baod%e6%9c%ba%e8%af%95%e8%b7%af%e7%81%af%e7%85%a7%e6%98%8e%e9%97%ae%e9%a2%98100%e5%88%86" aria-label="华为OD机试：路灯照明问题【100分】">华为OD机试：路灯照明问题【100分】</a></li>
                <li>
                    <a href="#%e6%8f%92%e5%85%a5%e5%8c%ba%e9%97%b4" aria-label="插入区间">插入区间</a></li>
                <li>
                    <a href="#%e5%8c%ba%e9%97%b4%e5%88%97%e8%a1%a8%e7%9a%84%e4%ba%a4%e9%9b%86" aria-label="区间列表的交集">区间列表的交集</a></li>
                <li>
                    <a href="#%e6%97%a0%e9%87%8d%e5%8f%a0%e5%8c%ba%e9%97%b4" aria-label="无重叠区间">无重叠区间</a></li>
                <li>
                    <a href="#%e5%88%a4%e6%96%ad%e4%b8%a4%e4%b8%aa%e4%ba%8b%e4%bb%b6%e6%98%af%e5%90%a6%e5%ad%98%e5%9c%a8%e5%86%b2%e7%aa%81" aria-label="判断两个事件是否存在冲突">判断两个事件是否存在冲突</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e6%a8%a1%e5%bc%8f%e7%9b%b8%e5%85%b3%e7%ae%97%e6%b3%95%e9%a2%98" aria-label="动态规划模式相关算法题">动态规划模式相关算法题</a><ul>
                        
                <li>
                    <a href="#%e6%96%90%e6%b3%a2%e9%82%a3%e5%a5%91%e6%95%b0%e5%88%97%e6%a8%a1%e5%bc%8f" aria-label="斐波那契数列模式">斐波那契数列模式</a></li>
                <li>
                    <a href="#%e6%96%90%e6%b3%a2%e9%82%a3%e5%a5%91%e6%95%b0" aria-label="斐波那契数">斐波那契数</a></li>
                <li>
                    <a href="#%e7%88%ac%e6%a5%bc%e6%a2%af" aria-label="爬楼梯">爬楼梯</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8%e6%9c%80%e5%b0%8f%e8%8a%b1%e8%b4%b9%e7%88%ac%e6%a5%bc%e6%a2%af" aria-label="使用最小花费爬楼梯">使用最小花费爬楼梯</a></li>
                <li>
                    <a href="#%e6%89%93%e5%ae%b6%e5%8a%ab%e8%88%8d" aria-label="打家劫舍">打家劫舍</a></li>
                <li>
                    <a href="#01-%e8%83%8c%e5%8c%85%e6%a8%a1%e5%bc%8f" aria-label="0/1 背包模式">0/1 背包模式</a></li>
                <li>
                    <a href="#01-%e8%83%8c%e5%8c%85%e9%97%ae%e9%a2%98" aria-label="0/1 背包问题">0/1 背包问题</a></li>
                <li>
                    <a href="#%e5%88%86%e5%89%b2%e7%ad%89%e5%92%8c%e5%ad%90%e9%9b%86" aria-label="分割等和子集">分割等和子集</a></li>
                <li>
                    <a href="#%e6%9c%80%e5%b0%8f%e5%ad%90%e9%9b%86%e5%92%8c%e5%b7%ae" aria-label="最小子集和差">最小子集和差</a></li>
                <li>
                    <a href="#%e7%9b%ae%e6%a0%87%e5%92%8c" aria-label="目标和">目标和</a></li>
                <li>
                    <a href="#%e5%ae%8c%e5%85%a8%e8%83%8c%e5%8c%85%e6%a8%a1%e5%bc%8f" aria-label="完全背包模式">完全背包模式</a></li>
                <li>
                    <a href="#%e9%9b%b6%e9%92%b1%e5%85%91%e6%8d%a2" aria-label="零钱兑换">零钱兑换</a></li>
                <li>
                    <a href="#%e6%9c%80%e9%95%bf%e5%85%ac%e5%85%b1%e5%ad%90%e4%b8%b2%e6%a8%a1%e5%bc%8f" aria-label="最长公共子串模式">最长公共子串模式</a></li>
                <li>
                    <a href="#%e6%9c%80%e9%95%bf%e5%85%ac%e5%85%b1%e5%ad%90%e4%b8%b2%e9%95%bf%e5%ba%a6" aria-label="最长公共子串长度">最长公共子串长度</a></li>
                <li>
                    <a href="#%e6%9c%80%e9%95%bf%e5%85%ac%e5%85%b1%e5%ad%90%e5%ba%8f%e5%88%97" aria-label="最长公共子序列">最长公共子序列</a></li>
                <li>
                    <a href="#%e4%b8%a4%e4%b8%aa%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%9a%84%e5%88%a0%e9%99%a4%e6%93%8d%e4%bd%9c" aria-label="两个字符串的删除操作">两个字符串的删除操作</a></li>
                <li>
                    <a href="#%e6%9c%80%e9%95%bf%e9%80%92%e5%a2%9e%e5%ad%90%e5%ba%8f%e5%88%97%e5%be%85%e5%ae%9a" aria-label="最长递增子序列（待定）">最长递增子序列（待定）</a></li>
                <li>
                    <a href="#%e6%97%a0%e7%9f%9b%e7%9b%be%e7%9a%84%e6%9c%80%e4%bd%b3%e7%90%83%e9%98%9f%e5%be%85%e5%ae%9a" aria-label="无矛盾的最佳球队（待定）">无矛盾的最佳球队（待定）</a></li>
                <li>
                    <a href="#%e5%9b%9e%e6%96%87%e5%ad%90%e5%ba%8f%e5%88%97%e6%a8%a1%e5%bc%8f" aria-label="回文子序列模式">回文子序列模式</a></li>
                <li>
                    <a href="#%e6%9c%80%e9%95%bf%e5%9b%9e%e6%96%87%e5%ad%90%e5%ba%8f%e5%88%97" aria-label="最长回文子序列">最长回文子序列</a></li>
                <li>
                    <a href="#%e6%9c%80%e9%95%bf%e5%9b%9e%e6%96%87%e5%ad%90%e4%b8%b2" aria-label="最长回文子串">最长回文子串</a></li>
                <li>
                    <a href="#%e5%9b%9e%e6%96%87%e5%ad%90%e4%b8%b2" aria-label="回文子串">回文子串</a></li>
                <li>
                    <a href="#huawei-od" aria-label="Huawei OD">Huawei OD</a></li>
                <li>
                    <a href="#%e7%8e%a9%e7%89%8c%e9%ab%98%e6%89%8b100%e5%88%86" aria-label="玩牌高手【100分】">玩牌高手【100分】</a></li>
                <li>
                    <a href="#%e8%b7%b3%e6%a0%bc%e5%ad%902100%e5%88%86---divide--conquer" aria-label="跳格子2【100分】&ndash; Divide &amp; Conquer">跳格子2【100分】&ndash; Divide &amp; Conquer</a></li>
                <li>
                    <a href="#%e7%8c%b4%e5%ad%90%e7%88%ac%e5%b1%b1100%e5%88%86" aria-label="猴子爬山【100分】">猴子爬山【100分】</a></li>
                <li>
                    <a href="#%e6%9f%a5%e6%89%be%e9%87%8d%e5%a4%8d%e4%bb%a3%e7%a0%81100%e5%88%86" aria-label="查找重复代码【100分】">查找重复代码【100分】</a></li>
                <li>
                    <a href="#%e6%9c%80%e5%a4%9a%e8%8e%b7%e5%be%97%e7%9a%84%e7%9f%ad%e4%bf%a1%e6%9d%a1%e6%95%b0100%e5%88%86--01%e8%83%8c%e5%8c%85%e9%97%ae%e9%a2%98" aria-label="最多获得的短信条数【100分】&ndash;0/1背包问题">最多获得的短信条数【100分】&ndash;0/1背包问题</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%b9%bf%e5%ba%a6%e4%bc%98%e5%85%88%e6%90%9c%e7%b4%a2" aria-label="广度优先搜索">广度优先搜索</a><ul>
                        
                <li>
                    <a href="#102-binary-tree-level-order-traversal" aria-label="102. Binary Tree Level Order Traversal">102. Binary Tree Level Order Traversal</a></li>
                <li>
                    <a href="#107-binary-tree-level-order-traversal-ii" aria-label="107. Binary Tree Level Order Traversal II">107. Binary Tree Level Order Traversal II</a></li>
                <li>
                    <a href="#103-binary-tree-zigzag-level-order-traversal" aria-label="103. Binary Tree Zigzag Level Order Traversal">103. Binary Tree Zigzag Level Order Traversal</a></li>
                <li>
                    <a href="#637-average-of-levels-in-binary-tree" aria-label="637. Average of Levels in Binary Tree">637. Average of Levels in Binary Tree</a></li>
                <li>
                    <a href="#111-minimum-depth-of-binary-tree" aria-label="111. Minimum Depth of Binary Tree">111. Minimum Depth of Binary Tree</a></li>
                <li>
                    <a href="#104-maximum-depth-of-binary-tree" aria-label="104. Maximum Depth of Binary Tree">104. Maximum Depth of Binary Tree</a></li>
                <li>
                    <a href="#116-populating-next-right-pointers-in-each-node" aria-label="116. Populating Next Right Pointers in Each Node">116. Populating Next Right Pointers in Each Node</a></li>
                <li>
                    <a href="#199-binary-tree-right-side-view" aria-label="199. Binary Tree Right Side View">199. Binary Tree Right Side View</a></li>
                <li>
                    <a href="#huawei-od-1" aria-label="Huawei OD">Huawei OD</a></li>
                <li>
                    <a href="#%e6%9c%80%e9%95%bf%e5%b9%bf%e6%92%ad%e6%95%88%e5%ba%94200%e5%88%86" aria-label="最长广播效应【200分】">最长广播效应【200分】</a></li>
                <li>
                    <a href="#%e6%b7%b1%e5%ba%a6%e4%bc%98%e5%85%88%e6%90%9c%e7%b4%a2" aria-label="深度优先搜索">深度优先搜索</a></li>
                <li>
                    <a href="#112-path-sum" aria-label="112. Path Sum">112. Path Sum</a></li>
                <li>
                    <a href="#257-binary-tree-paths" aria-label="257. Binary Tree Paths">257. Binary Tree Paths</a></li>
                <li>
                    <a href="#129-sum-root-to-leaf-numbers" aria-label="129. Sum Root to Leaf Numbers">129. Sum Root to Leaf Numbers</a></li>
                <li>
                    <a href="#1971-find-if-path-exists-in-graph" aria-label="1971. Find if Path Exists in Graph">1971. Find if Path Exists in Graph</a></li>
                <li>
                    <a href="#%e5%8d%8e%e4%b8%ba-od-1" aria-label="华为 OD">华为 OD</a></li>
                <li>
                    <a href="#%e6%96%87%e4%bb%b6%e7%9b%ae%e5%bd%95%e5%a4%a7%e5%b0%8f100%e5%88%86" aria-label="文件目录大小【100分】">文件目录大小【100分】</a></li>
                <li>
                    <a href="#%e6%82%84%e6%82%84%e8%af%9d100%e5%88%86" aria-label="悄悄话【100分】">悄悄话【100分】</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%9b%9e%e6%ba%af" aria-label="回溯">回溯</a><ul>
                        
                <li>
                    <a href="#113-path-sum-ii" aria-label="113. Path Sum II">113. Path Sum II</a></li>
                <li>
                    <a href="#437-path-sum-iii" aria-label="437. Path Sum III">437. Path Sum III</a></li>
                <li>
                    <a href="#39-combination-sum" aria-label="39. Combination Sum">39. Combination Sum</a></li>
                <li>
                    <a href="#%e9%a1%b9%e7%9b%ae%e8%a7%84%e5%88%92100%e5%88%86" aria-label="项目规划【100分】">项目规划【100分】</a></li>
                <li>
                    <a href="#%e8%b6%a3%e5%91%b3%e6%b8%b8%e6%88%8f100%e5%88%86" aria-label="趣味游戏【100分】">趣味游戏【100分】</a></li>
                <li>
                    <a href="#%e7%8c%9c%e8%b0%9c%e7%a0%81100%e5%88%86" aria-label="猜谜码【100分】">猜谜码【100分】</a></li>
                <li>
                    <a href="#%e8%bf%87%e6%bb%a4%e7%bb%84%e5%90%88%e5%ad%97%e7%ac%a6%e4%b8%b2100%e5%88%86" aria-label="过滤组合字符串【100分】">过滤组合字符串【100分】</a></li>
                <li>
                    <a href="#%e7%ad%89%e5%92%8c%e5%ad%90%e6%95%b0%e7%bb%84%e6%9c%80%e5%b0%8f%e5%92%8c100%e5%88%86" aria-label="等和子数组最小和【100分】">等和子数组最小和【100分】</a></li>
                <li>
                    <a href="#melon-%e7%9a%84%e9%9a%be%e9%a2%98100%e5%88%86" aria-label="MELON 的难题【100分】">MELON 的难题【100分】</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%9f%a9%e9%98%b5%e9%81%8d%e5%8e%86" aria-label="矩阵遍历">矩阵遍历</a><ul>
                        
                <li>
                    <a href="#200-number-of-islands" aria-label="200. Number of Islands">200. Number of Islands</a></li>
                <li>
                    <a href="#1926-nearest-exit-from-entrance-in-maze" aria-label="1926. Nearest Exit from Entrance in Maze">1926. Nearest Exit from Entrance in Maze</a></li>
                <li>
                    <a href="#934-shortest-bridge" aria-label="934. Shortest Bridge">934. Shortest Bridge</a></li>
                <li>
                    <a href="#%e6%88%98%e5%9c%ba%e7%b4%a2%e6%95%8c100%e5%88%86" aria-label="战场索敌【100分】">战场索敌【100分】</a></li>
                <li>
                    <a href="#%e6%9f%a5%e6%89%be%e5%8d%95%e5%85%a5%e5%8f%a3%e7%a9%ba%e9%97%b2%e5%8c%ba%e5%9f%9f100%e5%88%86" aria-label="查找单入口空闲区域【100分】">查找单入口空闲区域【100分】</a></li>
                <li>
                    <a href="#%e6%8c%89%e5%9b%be%e6%89%be%e6%9c%80%e8%bf%91%e7%9a%84%e8%b7%af100%e5%88%86" aria-label="按图找最近的路【100分】">按图找最近的路【100分】</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%ae%a1%e6%95%b0%e6%a8%a1%e5%bc%8f%e7%9b%b8%e5%85%b3%e7%ae%97%e6%b3%95%e9%a2%98" aria-label="计数模式相关算法题">计数模式相关算法题</a><ul>
                        
                <li>
                    <a href="#%e6%9c%80%e5%a4%a7%e9%a2%91%e7%8e%87%e5%85%83%e7%b4%a0%e8%ae%a1%e6%95%b0" aria-label="最大频率元素计数">最大频率元素计数</a></li>
                <li>
                    <a href="#%e4%ba%ba%e5%8f%a3%e6%9c%80%e5%a4%9a%e7%9a%84%e5%b9%b4%e4%bb%bd" aria-label="人口最多的年份">人口最多的年份</a></li>
                <li>
                    <a href="#%e4%bd%bf%e6%95%b0%e7%bb%84%e5%94%af%e4%b8%80%e7%9a%84%e6%9c%80%e5%b0%8f%e5%a2%9e%e9%87%8f" aria-label="使数组唯一的最小增量">使数组唯一的最小增量</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="string">String<a hidden class="anchor" aria-hidden="true" href="#string">#</a></h1>
<h2 id="华为od机试字符串分割100分">华为OD机试：字符串分割【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试字符串分割100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p><strong>一、题目描述</strong></p>
<p>给定一个非空字符串 <code>S</code>，其中包含多个子串，这些子串由 <code>-</code> 符号分隔。我们还给定一个正整数 <code>K</code>，要求按以下规则转换字符串：</p>
<ol>
<li>对于字符串中的每个子串，从第二个子串开始，将其分为每 <code>K</code> 个字符的片段。</li>
<li>对每个片段应用以下转换规则：
<ul>
<li>如果片段中小写字母数量多于大写字母，将该片段的所有大写字母转换为小写字母。</li>
<li>如果片段中大写字母数量多于小写字母，将该片段的所有小写字母转换为大写字母。</li>
<li>如果大写和小写字母数量相等，不做转换。</li>
</ul>
</li>
</ol>
<p><strong>二、输入描述</strong></p>
<p>输入包含两行：</p>
<ol>
<li>第一行为整数 <code>K</code>。</li>
<li>第二行为字符串 <code>S</code>，由 <code>-</code> 分隔成多个子串。</li>
</ol>
<p><strong>三、输出描述</strong></p>
<p>输出转换后的字符串。</p>
<p><strong>四、测试用例</strong></p>
<p>测试用例 1
<strong>输入</strong></p>
<pre tabindex="0"><code>3
12abc-abcABC-4aB@
</code></pre><p><strong>输出</strong></p>
<pre tabindex="0"><code>12abc-abc-ABC-4aB-@
</code></pre><p><strong>说明</strong></p>
<ul>
<li>子串为 <code>12abc</code>、<code>abcABC</code>、<code>4aB@</code>。第一个子串保留。</li>
<li>对 <code>abcABC</code> 按每 3 个字符分组为 <code>abc</code> 和 <code>ABC</code>：
<ul>
<li><code>abc</code> 中小写字母多，转换为 <code>abc</code>。</li>
<li><code>ABC</code> 中大写字母多，转换为 <code>ABC</code>。</li>
</ul>
</li>
<li>对 <code>4aB@</code> 按每 3 个字符分组为 <code>4aB</code> 和 <code>@</code>：
<ul>
<li><code>4aB</code> 中大小写字母数量相等，不做转换。</li>
<li><code>@</code> 中无字母，不做转换。</li>
</ul>
</li>
<li>最终输出为 <code>12abc-abc-ABC-4aB-@</code>。</li>
</ul>
<p>测试用例 2</p>
<p><strong>输入</strong></p>
<pre tabindex="0"><code>3
Test-aaBBcc-CCddEE
</code></pre><p><strong>输出</strong></p>
<pre tabindex="0"><code>Test-aab-bcc-CCD-DEE
</code></pre><p><strong>说明</strong></p>
<ul>
<li>子串为 <code>Test</code>、<code>aaBBcc</code>、<code>CCddEE</code>。第一个子串保留。</li>
<li>对 <code>aaBBcc</code> 按每 3 个字符分组为 <code>aab</code> 和 <code>bcc</code>：
<ul>
<li><code>aab</code> 中小写字母多，转换为 <code>aab</code>。</li>
<li><code>bcc</code> 中小写字母多，转换为 <code>bcc</code>。</li>
</ul>
</li>
<li>对 <code>CCddEE</code> 按每 3 个字符分组为 <code>CCD</code> 和 <code>DEE</code>：
<ul>
<li><code>CCD</code> 中大写字母多，转换为 <code>CCD</code>。</li>
<li><code>DEE</code> 中大写字母多，转换为 <code>DEE</code>。</li>
</ul>
</li>
<li>最终输出为 <code>Test-aab-bcc-CCD-DEE</code>。</li>
</ul>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取正整数 k
        int k = Integer.parseInt(in.nextLine().trim());
        // 读取字符串
        String s = in.nextLine().trim();

        // 字符串转换
        String result = transformString(s, k);

        // 输出结果
        System.out.println(result);
    }

    private static String transformString(String s, int k) {
        // 根据 "-" 分隔符获取子串数组
        String[] substringList = s.split("-");

        // 构建结果容器
        StringBuilder builder = new StringBuilder();
        builder.append(substringList[0]);

        for (int i = 1; i < substringList.length; i++) {
            builder.append("-");
            // 子字符串进一步转换
            String transformed = transformSubstring(substringList[i], k);
            builder.append(transformed);
        }

        return builder.toString();
    }

    private static String transformSubstring(String s, int k) {
        // 构建结果容器
        StringBuilder builder = new StringBuilder();

        for (int i = 0; i < s.length(); i += k) {
            int end = Math.min(i + k, s.length());
            String subString = s.substring(i, end);
            // 对子串进行大小写转换处理
            String transformed = applyCaseTransformation(subString);
            builder.append(transformed).append("-");
        }

        // 去除最后一个 "-"
        builder.setLength(builder.length() - 1);

        return builder.toString();
    }

    private static String applyCaseTransformation(String s) {
        int lowerCaseCount = 0;
        int upperCaseCount = 0;

        // 统计字符串中大小写字母的频率
        for (char c : s.toCharArray()) {
            if (Character.isLowerCase(c)) {
                lowerCaseCount++;
            } else if (Character.isUpperCase(c)){
                upperCaseCount++;
            }
        }

        if (lowerCaseCount > upperCaseCount) {
            return s.toLowerCase();
        } else if (lowerCaseCount < upperCaseCount) {
            return s.toUpperCase();
        }

        return s;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="字符匹配100分">字符匹配【100分】<a hidden class="anchor" aria-hidden="true" href="#字符匹配100分">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>一、题目描述</strong>
给定一个字符串数组（每个字符串均由小写字母组成）和一个字符规律（由小写字母、<code>.</code>和<code>*</code>组成），请识别数组中哪些字符串可以完全匹配该字符规律。</p>
<ul>
<li><code>.</code> 匹配任意单个字符。</li>
<li><code>*</code> 匹配零个或多个前面的字符（即“零个或多个”的概念）。</li>
</ul>
<p>匹配是要涵盖整个字符串，而不仅仅是部分字符串。</p>
<p><strong>二、输入描述</strong></p>
<ul>
<li>第一行是一个由空格分隔的字符串数组，其中每个字符串的长度满足 <code>1 &lt; 单个字符串长度 &lt; 100</code>。</li>
<li>第二行为字符规律，长度满足 <code>1 &lt; 字符规律长度 &lt; 50</code>。</li>
</ul>
<p><strong>三、输出描述</strong></p>
<ul>
<li>输出符合字符规律的字符串在数组中的下标，多个匹配时，下标按升序排列，并用逗号分隔。</li>
<li>如果没有任何字符串匹配，输出 <code>-1</code>。</li>
</ul>
<p><strong>示例</strong></p>
<p><strong>输入：</strong></p>
<pre tabindex="0"><code>golang java kafka
.*a
</code></pre><p><strong>输出：</strong></p>
<pre tabindex="0"><code>1,2
</code></pre><p><strong>说明：</strong></p>
<ul>
<li>匹配规则 <code>.*a</code> 表示以 <code>a</code> 结尾的任意字符串。符合要求的字符串是 <code>java</code> 和 <code>kafka</code>，因此它们的下标是 <code>1</code> 和 <code>2</code>（从 <code>0</code> 开始索引）。</li>
</ul>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;
import java.util.regex.Pattern;

public class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        String[] words = in.nextLine().trim().split(" ");
        String rule = in.nextLine().trim();

        String result = getMatchingIndices(words, rule);

        System.out.println(result);
    }

    private static String getMatchingIndices(String[] words, String rule) {
        List<Integer> indices = new ArrayList<>();

        // // 构建正则表达式
        Pattern pattern = Pattern.compile("^" + rule + "$");

        // 遍历字符串数组，查找匹配项
        for (int i = 0; i < words.length; i++) {
            if (pattern.matcher(words[i]).matches()) {
                indices.add(i);
            }
        }

        return indices.isEmpty() ? "-1" : indices.toString().replaceAll("[\\[\\]\\s]", "");
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h1 id="queue">Queue<a hidden class="anchor" aria-hidden="true" href="#queue">#</a></h1>
<h2 id="银行插队">银行插队<a hidden class="anchor" aria-hidden="true" href="#银行插队">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>一、题目描述</strong></p>
<p>某银行将客户分为了若干个优先级，1级最高，5级最低。当客户到达银行时，优先级高的人可以随时插队到优先级低的人的前面。</p>
<p>现在给定一系列的客户到达和办理业务的时间序列，请你每次银行办理业务时输出客户的编号。<br>
如果有多个优先级相同且最高的客户，则按照到达顺序进行办理。</p>
<hr>
<p><strong>二、输入描述</strong></p>
<ol>
<li>第一行是一个正整数 <code>n</code>（1 ≤ n ≤ 500），表示输入序列中的事件数量。</li>
<li>接下来的 <code>n</code> 行每行第一个字符为 <code>a</code> 或 <code>p</code>：
<ul>
<li>当字符为 <code>a</code> 时，后面跟着两个正整数 <code>num</code> 和 <code>x</code>，表示到达的客户编号 <code>num</code> 和优先级 <code>x</code>。</li>
<li>当字符为 <code>p</code> 时，表示当前优先级最高的客户去办理业务。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>三、输出描述</strong></p>
<p>对于每个 <code>p</code> 类型的事件，输出一行，仅包含一个正整数 <code>num</code>，表示办理业务的客户编号。</p>
<hr>
<p><strong>四、测试用例</strong></p>
<p><strong>测试用例 1</strong></p>
<p><strong>输入</strong>:</p>
<pre tabindex="0"><code>4
a 1 3
a 2 2
a 3 2
p
</code></pre><p><strong>输出</strong>:</p>
<pre tabindex="0"><code>2
</code></pre><p><strong>说明</strong>:</p>
<ul>
<li>客户 1 到达，优先级为 3。</li>
<li>客户 2 和客户 3 到达，优先级为 2。</li>
<li>第一次 <code>p</code> 会办理客户 2，因为客户 2 和客户 3 优先级相同，但是客户 2 先到达。</li>
</ul>
<hr>
<p><strong>测试用例 2</strong></p>
<p><strong>输入</strong>:</p>
<pre tabindex="0"><code>6
a 10 1
a 20 5
a 30 3
p
p
p
</code></pre><p><strong>输出</strong>:</p>
<pre tabindex="0"><code>10
30
20
</code></pre><p><strong>说明</strong>:</p>
<ul>
<li>客户 10 到达，优先级为 1（最高优先级）。</li>
<li>客户 20 到达，优先级为 5。</li>
<li>客户 30 到达，优先级为 3。</li>
<li>第一次 <code>p</code> 处理客户 10（因为客户 10 优先级最高）。</li>
<li>第二次 <code>p</code> 处理客户 30（优先级 3 高于 5）。</li>
<li>第三次 <code>p</code> 处理客户 20。</li>
</ul>
<hr>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.PriorityQueue;
import java.util.Scanner;

class Solution {

    static class Customer {
        int id;
        int priority;

        public Customer(int id, int priority) {
            this.id = id;
            this.priority = priority;
        }

    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        int n = Integer.parseInt(in.nextLine().trim());

        // Customers with higher priority come first,
        // if priorities are equal, order by ID
        PriorityQueue&lt;Customer&gt; queue = new PriorityQueue&lt;&gt;((
                c1, c2) -> c1.priority == c2.priority
                ? Integer.compare(c1.id, c2.id)
                : Integer.compare(c1.priority, c2.priority)
        );

        // Process each event
        for (int i = 0; i < n; i++) {
            String[] parts = in.nextLine().trim().split(" ");
            processEvents(parts, queue);
        }
    }

    private static void processEvents(String[] parts, PriorityQueue&lt;Customer&gt; queue) {
        char action = parts[0].charAt(0);

        // A customer arrives if the action equals to 'a'
        if (action == 'a') {
            int id = Integer.parseInt(parts[1]);
            int priority = Integer.parseInt(parts[2]);
            queue.add(new Customer(id, priority));
        } else if (action == 'p' && !queue.isEmpty()) {
            // Poll the highest priority customer from the queue
            Customer customer = queue.poll();
            System.out.println(customer.id);
        }
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW NOTES</summary>
  <blockquote>
<p>When sorting involves multiple fields, it is a good practice to encapsulate these fields in an entity class. This approach simplifies specifying the sorting order based on specific conditions, enhancing both the maintainability and readability of the code.</p>
</blockquote>
</details></p>

<hr>
<h1 id="two-pointers">Two Pointers<a hidden class="anchor" aria-hidden="true" href="#two-pointers">#</a></h1>
<h2 id="华为od机试最大花费金额100分">华为OD机试：最大花费金额【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试最大花费金额100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p><strong>一、题目描述</strong></p>
<p>小明希望在预算范围内尽可能花完资金。双十一期间，众多商品打折销售，他想从心仪的商品中挑选三件购买。请设计一个程序，帮助小明计算可以花费的最大金额。</p>
<p><strong>二、输入描述</strong></p>
<ul>
<li>第一行：一维整型数组 <code>M</code>，表示商品的价格列表，数组长度小于 100，每个商品价格小于 1000。</li>
<li>第二行：整数 <code>R</code>，表示购买的总资金限制，<code>R</code> 小于 100000。</li>
</ul>
<p><strong>三、输出描述</strong></p>
<p>输出满足条件的最大花费金额。如果不存在符合条件的组合，输出 <code>-1</code>。</p>
<p><strong>示例</strong></p>
<p>输入：</p>
<pre tabindex="0"><code>28 16 36 22
100
</code></pre><p>输出：</p>
<pre tabindex="0"><code>86
</code></pre><p>说明</p>
<p>在示例中，购买三件商品且总价不超过 100 的最大组合为 28 + 36 + 22 = 86。</p>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取字符串数组并转换为整数数组
        int[] prices = Arrays.stream(in.nextLine().trim().split(" "))
                .mapToInt(Integer::parseInt)
                .toArray();
                
        // 读取购买资金额度
        int budget = Integer.parseInt(in.nextLine().trim());

        // 计算预算范围内可以花费的最大金额
        int maxCost = getMaxCost(prices, budget);

        // 输出结果
        System.out.println(maxCost);
    }

    private static int getMaxCost(int[] prices, int budget) {
        // 对价格进行排序
        Arrays.sort(prices);

        int maxCost = 0; // 用于记录最大花费金额
        for (int i = 0; i < prices.length - 2; i++) {
            if (prices[i] < budget) {
                int left = i + 1, right = prices.length - 1;
                while (left < right) {
                    int currentCost = prices[i] + prices[left] + prices[right]; // 当前花费金额
                    if (currentCost == budget) {
                        return currentCost;
                    } else if (currentCost < budget) {
                        maxCost = Math.max(maxCost, currentCost);
                        left++;
                    } else {
                        right--;
                    }
                }
            } else {
                break;
            }
        }

        return maxCost;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="华为od机试字符串序列判定100分">华为OD机试：字符串序列判定【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试字符串序列判定100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p><strong>一、题目描述</strong></p>
<p>给定两个字符串 <code>a</code> 和 <code>b</code>，均由小写英文字母组成。<code>a</code> 的长度不超过 100，<code>b</code> 的长度不超过 500,000。要求判断 <code>a</code> 是否是 <code>b</code> 的一个有效子序列。</p>
<p>判定规则：</p>
<ul>
<li><code>a</code> 中的每个字符都能在 <code>b</code> 中找到（字符可以不连续）。</li>
<li><code>a</code> 在 <code>b</code> 中的字符顺序必须保持一致。</li>
<li>例如，当 <code>a = &quot;qwt&quot;</code> 时，<code>a</code> 是 <code>b = &quot;qwerty&quot;</code> 的一个有效子序列，因为 <code>a</code> 的字符 <code>q</code>、<code>w</code> 和 <code>t</code> 在 <code>b</code> 中按顺序出现。</li>
</ul>
<p><strong>二、输入描述</strong></p>
<p>输入包含两个字符串 <code>a</code> 和 <code>b</code>，均由小写英文字母组成：</p>
<ul>
<li>第一行输入字符串 <code>a</code>。</li>
<li>第二行输入字符串 <code>b</code>。</li>
</ul>
<p>字符串 <code>a</code> 的长度 ≤ 100，字符串 <code>b</code> 的长度 ≤ 500,000。</p>
<p><strong>三、输出描述</strong></p>
<p>输出 <code>a</code> 在 <code>b</code> 中的最后一个有效字符的位置（索引从 0 开始）。如果 <code>a</code> 不是 <code>b</code> 的有效子序列，返回 -1。</p>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取输入
        String a = in.nextLine().trim();
        String b = in.nextLine().trim();

        in.close();

        // 判断 a 是否是 b 的有效子串
        int result = substringCheck(a, b);

        // 输出结果
        System.out.println(result);
    }

    private static int substringCheck(String a, String b) {
        if (a.length() > b.length()) {
            return -1;
        }

        int i = 0, j = 0;
        int lastMatchPosition = -1; // 用于记录 a 的最后一个有效字符在 b 中的索引位置

        while (i < a.length() && j < b.length()) {
            if (a.charAt(i) == b.charAt(j)) {
                lastMatchPosition = j; // 更新最后一个匹配位置
                i++;
            }
            j++;
        }

        return lastMatchPosition;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="华为od机试租车骑绿道100分">华为OD机试：租车骑绿道【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试租车骑绿道100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p><strong>一、题目描述</strong></p>
<p>部门组织团建活动，安排绿道骑行，需要租用双人自行车。每辆自行车最多可容纳两人，且载重上限为 <code>m</code>。给出部门中每个人的体重，求最少需要租用多少辆双人自行车。</p>
<p><strong>二、输入描述</strong></p>
<ul>
<li>第一行包含两个整数 <code>m</code> 和 <code>n</code>，其中 <code>m</code> 表示每辆自行车的最大载重，<code>n</code> 表示部门的总人数。</li>
<li>第二行包含 <code>n</code> 个整数，表示每个人的体重（每个人的体重不超过自行车的载重限制 <code>m</code>）。</li>
</ul>
<p>输入数据满足以下条件：</p>
<ul>
<li><code>0 &lt; m &lt;= 200</code></li>
<li><code>0 &lt; n &lt;= 1,000,000</code></li>
</ul>
<p><strong>三、输出描述</strong></p>
<p>输出最少需要的双人自行车数量。</p>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取自行车限重与人数
        int[] parts = Arrays.stream(in.nextLine().trim().split(" "))
                .mapToInt(Integer::parseInt)
                .toArray();
        int m = parts[0];
        // 读取体重数据
        int[] weights = Arrays.stream(in.nextLine().trim().split(" "))
                .mapToInt(Integer::parseInt)
                .toArray();

        // 计算所需最少双人自行车数量
        int result = computeMinimumBicycles(weights, m);

        // 输出结果
        System.out.println(result);
    }

    private static int computeMinimumBicycles(int[] weights, int maxWeight) {
        // 对数组进行排序，便于使用双指针模式
        Arrays.sort(weights);

        // 初始化双指针
        int left = 0, right = weights.length - 1;
        int bicycleCount = 0;

//        while (left <= right) {
//            // 最轻和最重的人可以共用一辆车
//            if (weights[left] + weights[right] <= maxWeight) {
//                left++;  // 左指针右移
//                right--;
//                bicycleCount++;
//            } else { // 不能公用自行车
//                right--;  // 右指针左移
//                bicycleCount++;
//            }
//        }

        while (left <= right) {
            // 最轻和最重的人可以共用一辆车
            if (weights[left] + weights[right] <= maxWeight) {
                left++;  // 左指针右移
            }
            right--;  // 右指针左移
            bicycleCount++;
        }

        return bicycleCount;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="华为od机试求最多可以派出多少支团队100分">华为OD机试：求最多可以派出多少支团队【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试求最多可以派出多少支团队100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p><strong>题目描述</strong></p>
<p>有一个数组表示每个人的能力值。比赛活动要求参赛团队的能力总和至少为 N。每个团队可以由一人或两人组成，每个人只能参加一个团队。请计算最多可以组建多少个符合要求的团队。</p>
<p><strong>输入描述</strong></p>
<ul>
<li>第一行：一个整数表示总人数，范围为 1 至 500,000。</li>
<li>第二行：一个整数数组表示每个人的能力值，数组大小为 1 至 500,000，数组元素取值范围为 1 至 500,000。</li>
<li>第三行：一个整数表示团队能力要求的最低值 N，范围为 1 至 500,000。</li>
</ul>
<p><strong>输出描述</strong></p>
<ul>
<li>输出一个整数，表示最多可以组建的符合要求的团队数量。</li>
</ul>

</details></p>

<p><strong>说明</strong></p>
<style>
    table {
        width: 100%;
        font-size: 18px;
    }
    tr, th, td {
        border: 2px solid #dee4eb;  
        padding: 5px;  
    }
</style>



<table>
    
    
    <tr>
      <th>输入</th>
      <th>输出</th>
      <th>说明</th>
    </tr>
    <tr>
      <td>3<br>1 1 9<br>8</td>
      <td>1</td>
      <td>9自己一队，输出1</td>
    </tr>
    <tr>
      <td>5<br>3 1 5 7 9<br>8</td>
      <td>3</td>
      <td>说明3、5组成为一队，1、7组成一队，9自己一队，输出3</td>
    </tr>
    <tr>
      <td>7<br>3 1 5 7 9 2 6<br>8</td>
      <td>4</td>
      <td>说明3、5组成为一队，1、7组成一队，9自己一队，2、6组成一队，输出4</td>
    </tr>

</table>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.Arrays;
import java.util.Scanner;

class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取输入数据
        int n = Integer.parseInt(in.nextLine().trim());
        int[] abilities = Arrays.stream(in.nextLine().trim().split(" "))
                .mapToInt(Integer::parseInt)
                .toArray();
        int minTeamAbility = Integer.parseInt(in.nextLine().trim());

        in.close();

        // 计算符合题目要求的团队数量
        int result = computeMaxTeams(abilities, n, minTeamAbility);

        // 输出结果
        System.out.println(result);
    }

    private static int computeMaxTeams(int[] abilities, int n, int minTeamAbility) {
        // 对数组进行排序，便于使用双指针模式
        Arrays.sort(abilities);

        // 初始化双指针
        int left = 0, right = n - 1;
        int teamCount = 0;
        while (left <= right) {
            if (abilities[left] == abilities[right] && abilities[right] >= minTeamAbility) {
                // 只剩下一个人
                teamCount++;
                break;
            } else if (abilities[right] >= minTeamAbility) { // 能力最强的人单人成队
                teamCount++;
                right--;
            } else if (abilities[left] + abilities[right] >= minTeamAbility) {
                teamCount++;
                left++;
                right--;
            } else {
                left++;
            }
        }

        return teamCount;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="华为od机试寻找身高相近的小朋友100分">华为OD机试：寻找身高相近的小朋友【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试寻找身高相近的小朋友100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p><strong>一、题目描述</strong></p>
<p>小明今年升入小学一年级，来到新班级后发现其他小朋友的身高各不相同。他想根据每个小朋友与自己的身高差，对他们进行排序，帮助自己更好地认识新同学。</p>
<p><strong>二、输入描述</strong></p>
<p>第一行包含两个正整数 $h $和 $n $，其中：</p>
<ul>
<li>$h $表示小明的身高，范围为 $0 &lt; h &lt; 200 $。</li>
<li>$n $表示班级中其他小朋友的数量，范围为 $0 &lt; n &lt; 50 $。</li>
</ul>
<p>第二行包含 $n $个正整数，分别表示其他小朋友的身高 $h_1, h_2, \ldots, h_n $，每个身高的取值范围为 $0 &lt; h_i &lt; 200 $，且这些数互不相同。</p>
<p><strong>三、输出描述</strong></p>
<p>按照以下规则输出排序结果，各正整数之间用空格分隔：</p>
<ol>
<li>与小明身高差的绝对值越小的小朋友排在前面。</li>
<li>如果与小明身高差的绝对值相同，则身高较矮的小朋友排在前面。</li>
</ol>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取小明身高值和小明同学数
        int[] part = Arrays.stream(in.nextLine().trim().split(" "))
                .mapToInt(Integer::parseInt)
                .toArray();
        int h = part[0]; // 小明身高值
        int n = part[1]; // 小明同学个数
        // 读取小明同学身高数据并解析为数组
        int[] heightList = Arrays.stream(in.nextLine().trim().split(" "))
                .mapToInt(Integer::parseInt)
                .toArray();

        // 基于小明的身高对小明同学的身高进行排序
        String result = sortHeight(heightList, h, n);

        // 输出结果
        System.out.println(result);
    }

    private static String sortHeight(int[] heightList, int h, int n) {
        // 对数组进行排序，便于使用双指针模式
        Arrays.sort(heightList);

        // 构建结果容器
        StringBuilder builder = new StringBuilder();

        // 初始化双指针
        int left = 0, right = n - 1;
        while (left <= right) {
            if (Math.abs(h - heightList[left]) > Math.abs(h - heightList[right])) {
                builder.insert(0, heightList[left]);
                left++;
            } else if (Math.abs(h - heightList[left]) <= Math.abs(h - heightList[right])) {
                builder.insert(0, heightList[right]);
                right--;
            }
            builder.insert(0, " ");
        }

        return builder.substring(1);
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="华为od机试太阳能板最大面积100分">华为OD机试：太阳能板最大面积【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试太阳能板最大面积100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p><strong>一、题目描述</strong></p>
<p>在航天器的一侧安装太阳能板（如图中红色斜线区域）时，需要先固定两根支柱（如图中黑色竖条）。太阳能板的安装面积取决于支柱之间的距离和较短支柱的高度。</p>
<p>现给定一组整数数组，表示各个支柱的高度。假设每根支柱之间的距离相等且为 1 个单位长度，计算如何选择两根支柱以使太阳能板的安装面积最大化。</p>
<p>注意：支柱的高度无序排列。</p>
<p><img loading="lazy" src="/img/algorithms/huawei-od/2-spacecraft.png" alt="航天器不同位置支柱高度"  />
</p>
<p><strong>二、输入描述</strong></p>
<p>输入一个表示支柱高度的整数数组，如：<code>10,9,6,7,8,5,4,7,2,3</code></p>
<p><strong>三、输出描述</strong></p>
<p>输出最大太阳能板的安装面积。</p>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取支柱高度
        int[] height = Arrays.stream(in.nextLine().trim().split(","))
                .mapToInt(Integer::parseInt)
                .toArray();

        in.close();

        // 计算最大面积
        int maxArea = computeMaxArea(height);

        // 输出结果
        System.out.println(maxArea);
    }

    private static int computeMaxArea(int[] height) {
        // 初始化双指针
        int left = 0, right = height.length - 1;
        int maxArea = 0; // 用于记录最大面积

        while (left < right) {
            int area = Math.min(height[left], height[right]) * (right - left);
            maxArea = Math.max(maxArea, area); // 更新最大面积

            // 移动较短的支柱，尝试获取更大的面积
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }

        return maxArea;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h1 id="sliding-window">Sliding Window<a hidden class="anchor" aria-hidden="true" href="#sliding-window">#</a></h1>
<h2 id="华为od机试寻找连续区间100分">华为OD机试：寻找连续区间【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试寻找连续区间100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p><strong>题目描述</strong></p>
<p>给定一个包含 $N $个正整数的数组，找出所有连续子数组（包括单个元素），其和大于等于给定的整数 $X $的组合数量。</p>
<p><strong>输入描述</strong><br>
第一行包含两个整数 $N $和 $X $。（$0 &lt; N \leq 100000 $, $0 \leq X \leq 10000000 $）<br>
第二行包含 $N $个正整数（每个正整数的值不超过 100）。</p>
<p><strong>输出描述</strong></p>
<p>输出一个整数，表示满足条件的连续子数组的数量。</p>
<p><strong>输入示例</strong></p>
<pre tabindex="0"><code>3 7
3 4 7
</code></pre><p><strong>输出示例</strong></p>
<pre tabindex="0"><code>4
</code></pre><p><strong>示例说明</strong></p>
<p>输入的第一个数 3 表示数组包含 3 个元素，7 是目标值，用于判断子数组和是否大于等于该值。<br>
满足条件的子数组包括：3+4, 3+4+7, 4+7, 7，总共 4 个。</p>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" > import java.util.*;

class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取正整数个数和目标值
        int[] part = Arrays.stream(in.nextLine().trim().split(" "))
                .mapToInt(Integer::parseInt)
                .toArray();
        int n = part[0];
        int x = part[1];

        // 读取整数
        int[] nums = Arrays.stream(in.nextLine().trim().split(" "))
                .mapToInt(Integer::parseInt)
                .toArray();

        // 计算子数组和大于或等于目标值的个数
        int result = countSubArrays(nums, x);

        // 输出结果
        System.out.println(result);
    }

    private static int countSubArrays(int[] nums, int target) {
        int windowStart = 0, count = 0;
        int windowSum = 0;
        for (int windowEnd = 0; windowEnd < nums.length; windowEnd++) {
            windowSum += nums[windowEnd]; // 更新窗口和

            // 当窗口和大于或等于目标值时，缩小窗口
            while (windowSum >= target) {
                // 符合要求子数组：左边界为 windowStart，右边界取值范围为 [windowEnd, nums.length - 1]
                count += nums.length - windowEnd;
                windowSum -= nums[windowStart];
                windowStart++; // 缩小窗口
            }
        }

        return count;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">点击查看笔记</summary>
  <ul>
<li><code>count += nums.length - windowEnd;</code>
<ul>
<li><code>nums = [1, 4, 5], target = 4</code>
<ul>
<li><code>windowEnd</code> 为 0 时，当前窗口和<code>1</code>小于目标值</li>
<li><code>windowEnd</code> 为 1 时，当前窗口和<code>5</code>大于目标值，符合要求的子数组为：<code>[1, 4]</code>和<code>[1, 4, 5]</code>。也就是说，子数组的左边界为<code>windowStart = 0</code>，右边界的取值可为：1, 2。</li>
</ul>
</li>
</ul>
</li>
<li><code>while (windowSum &gt;= target)</code> 而非 <code>if (windowSum &gt;= target)</code>
<ul>
<li>当找到符合要求的子数组时，应尽可能缩小窗口。例如，子数组<code>[1, 4]</code> 缩小后变为<code>[4]</code>，但此时<code>[4]</code>仍满足题意，此时<code>windowEnd</code>的取值<code>1</code>和<code>2</code>，即子数组可为<code>[4]</code>和<code>[4,5]</code>。</li>
</ul>
</li>
</ul>

</details></p>

<hr>
<h2 id="华为od机试阿里巴巴找黄金宝箱v100分">华为OD机试：阿里巴巴找黄金宝箱(V)【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试阿里巴巴找黄金宝箱v100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p><strong>一、题目描述</strong></p>
<p>樵夫阿里巴巴在砍柴途中发现了一个藏宝地，这里有编号从 $0$ 到$N-1$的宝箱，每个宝箱上贴有一个数字，表示其价值。阿里巴巴记住了一个“咒语数字”$k$（$k &lt; N$），他希望通过这个数字找到宝藏组合的最大价值。具体而言，阿里巴巴要找出连续$k$个宝箱中的数字和的最大值，并输出该最大值。</p>
<p><strong>二、输入描述</strong></p>
<ol>
<li>
<p><strong>第一行</strong>：一个包含整数的字符串，表示宝箱上的数字，数字之间用逗号分隔。例子：<code>2,10,-3,-8,40,5</code></p>
<ul>
<li><strong>条件</strong>：
<ul>
<li>1 ≤ 数字的个数 ≤ 100,000</li>
<li>-10,000 ≤ 每个数字 ≤ 10,000</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>第二行</strong>：一个正整数$k$，表示咒语数字，指定连续宝箱的数量。例子：<code>4</code>，其中$k &lt;$宝箱的个数。</p>
</li>
</ol>
<p><strong>三、输出描述</strong></p>
<p>输出一个整数，表示连续$k$个宝箱的最大和。例如：<code>39</code></p>
<p><strong>四、测试用例</strong></p>
<p><strong>测试用例 1：</strong></p>
<ul>
<li><strong>输入</strong>
<pre tabindex="0"><code>2,10,-3,-8,40,5
4
</code></pre></li>
<li><strong>输出</strong>
<pre tabindex="0"><code>39
</code></pre></li>
<li><strong>说明</strong><br>
初始窗口：<code>2,10,-3,-8</code>，和为 <code>1</code>。<br>
移动窗口：<code>10,-3,-8,40</code>，和为 <code>39</code>，更新最大和。<br>
接下来窗口为：<code>-3,-8,40,5</code>，和为 <code>34</code>，保持最大和为 <code>39</code>。</li>
</ul>
<p><strong>测试用例 2：</strong></p>
<ul>
<li><strong>输入</strong>
<pre tabindex="0"><code>8
1
</code></pre></li>
<li><strong>输出</strong>
<pre tabindex="0"><code>8
</code></pre></li>
<li><strong>说明</strong><br>
只有一个数字，窗口大小为 <code>1</code>，直接输出该数字 <code>8</code>。</li>
</ul>
<p><strong>测试用例 3：</strong></p>
<ul>
<li>
<p><strong>输入</strong></p>
<pre tabindex="0"><code>-1,-2,-3,-4
2
</code></pre></li>
<li>
<p><strong>输出</strong></p>
<pre tabindex="0"><code>-3
</code></pre></li>
<li>
<p><strong>说明</strong></p>
<p>初始窗口为 <code>-1,-2</code>，和为 <code>-3</code>。后续窗口的和分别为 <code>-5</code> 和 <code>-7</code>，因此最大和保持为 <code>-3</code>。</p>
</li>
</ul>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取宝箱数字并转换为数组
        int[] nums = Arrays.stream(in.nextLine().trim().split(" "))
                .mapToInt(Integer::parseInt)
                .toArray();
        // // 读取连续宝箱的个数
        int boxes = Integer.parseInt(in.nextLine().trim());

        // 计算指定连续宝箱个数的最大和
        int maxSum = computeMaxSum(nums, boxes);

        // 输出结果
        System.out.println(maxSum);
    }

    private static int computeMaxSum(int[] nums, int k) {
        int windowStart = 0, windowSum = 0;
        int maxSum = Integer.MIN_VALUE;
        for (int windowEnd = 0; windowEnd < nums.length; windowEnd++) {
            windowSum += nums[windowEnd]; // 更新窗口和

            // 当窗口大小等于k时，缩小窗口
            if (windowEnd - windowStart + 1 == k) {
                maxSum = Math.max(maxSum, windowSum); // 更新最大和
                windowSum -= nums[windowStart];
                windowStart++; // 缩小窗口
            }
        }

        return maxSum;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="华为od机试最多购买宝石数目100分">华为OD机试：最多购买宝石数目【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试最多购买宝石数目100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p><strong>一、题目描述</strong></p>
<p>在一个橱窗里，有一排编号为 <code>0</code> 到 <code>n-1</code> 的宝石，每个宝石的价格用数组 <code>gems[i]</code> 表示（其中 <code>0 &lt;= i &lt; n</code>，且 <code>n = gems.length</code>）。你可以选择购买一组宝石，但需要满足以下条件：</p>
<ol>
<li>选择的宝石必须是连续编号的，例如：<code>gems[i], gems[i+1], ..., gems[i+m-1]</code>。</li>
<li>可以选择购买的宝石总数不能超过一个最大值 <code>m</code>。</li>
<li>你拥有的总金额为 <code>value</code>。</li>
</ol>
<p>请计算，在给定的金额 <code>value</code> 和最大宝石数量 <code>m</code> 的限制下，最多可以购买多少个宝石。如果无法购买任何宝石，则返回 <code>0</code>。</p>
<p><strong>二、输入描述</strong></p>
<ol>
<li>第一行输入整数 <code>n</code>，表示橱窗中宝石的总数量。<strong>取值范围</strong>：<code>0 &lt;= n &lt;= 10^6</code></li>
<li>接下来的 <code>n</code> 行，每行一个整数，表示宝石的价格。即，第 <code>i</code> 行输入的是 <code>gems[i]</code> 的价格。<strong>价格范围</strong>：<code>0 &lt; gems[i] &lt;= 1000</code></li>
<li>最后一行输入整数 <code>m</code>，表示拥有的总金额。<strong>取值范围</strong>：<code>0 &lt;= value &lt;= 10^9</code></li>
</ol>
<p><strong>三、输出描述</strong></p>
<p>输出一个整数，表示在给定金额和数量限制下，最多可以购买的宝石数量。</p>
<p><strong>四、测试用例</strong></p>
<p><strong>测试用例 1</strong></p>
<p><strong>输入</strong></p>
<pre tabindex="0"><code>7
8
4
6
3
1
6
7
10
</code></pre><p><strong>输出</strong></p>
<pre tabindex="0"><code>3
</code></pre><p><strong>说明</strong>
可以购买编号为 <code>2, 3, 4</code> 的宝石，其价格和为 <code>6 + 3 + 1 = 10</code>，总价不超过 <code>value</code></p>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取宝石数量
        int n = Integer.parseInt(in.nextLine().trim());
        // 读取宝石价格
        int[] prices = new int[n];
        for (int i = 0; i < n; i++) {
            prices[i] = Integer.parseInt(in.nextLine().trim());
        }
        // 读取拥有钱
        int money = Integer.parseInt(in.nextLine().trim());

        // 计算能够购买最多的宝石数量
        int maxGem = buyMaxGems(prices, money);

        // 输出结果
        System.out.println(maxGem);
    }

    private static int buyMaxGems(int[] prices, int money) {
        int windowStart = 0;
        int maxGem = 0, currentPrice = 0;
        for (int windowEnd = 0; windowEnd < prices.length; windowEnd++) {
            currentPrice += prices[windowEnd];

            // 如果总价超过预算，缩小窗口
            if (currentPrice > money) {
                currentPrice -= prices[windowStart];
                windowStart++;
            }

            // 更新最大可购买的宝石数量
            maxGem = Math.max(maxGem, windowEnd - windowStart + 1);
        }

        return maxGem;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">点击查看笔记</summary>
  <blockquote>
<p>问题本质：求给定条件下的最大区间</p>
</blockquote>
</details></p>

<hr>
<h2 id="华为od机试找出通过车辆最多颜色100分">华为OD机试：找出通过车辆最多颜色【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试找出通过车辆最多颜色100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p><strong>一、题目描述</strong></p>
<p>在一个狭窄的路口，每秒钟只能通过一辆车，且车辆的颜色只有三种。请找出在给定的统计时间窗内，经过的车辆中数量最多的颜色的车辆数量。</p>
<p>颜色共有三种，分别用编号 <code>0</code>、<code>1</code>、<code>2</code> 表示。</p>
<p><strong>二、输入描述</strong></p>
<ul>
<li>第一行是一个数组，表示每秒钟通过的车辆颜色信息。例如，输入 <code>[0, 1, 1, 2]</code> 表示在 4 秒钟内，车辆颜色依次为 <code>0</code>、<code>1</code>、<code>1</code>、<code>2</code>。</li>
<li>第二行是一个整数，表示统计时间窗的长度 <code>T</code>（单位：秒）。</li>
</ul>
<p><strong>三、输出描述</strong></p>
<p>输出在指定的统计时间窗 <code>T</code> 内，经过的数量最多的颜色的车辆数量。</p>
<p><strong>示例</strong></p>
<ul>
<li>
<p><strong>输入</strong></p>
<pre tabindex="0"><code>[0, 1, 1, 2]
3
</code></pre></li>
<li>
<p><strong>输出</strong></p>
<pre tabindex="0"><code>2
</code></pre></li>
<li>
<p><strong>说明</strong></p>
<p>在时间窗为 <code>3</code> 秒的范围内，颜色 <code>1</code> 的车辆数量最多，有 <code>2</code> 辆。</p>
</li>
</ul>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取车辆颜色数据并转换为数组
        int[] colors = Arrays.stream(in.nextLine().trim().split(" "))
                .mapToInt(Integer::parseInt)
                .toArray();
        // 读取指定时间窗口长度
        int k = Integer.parseInt(in.nextLine().trim());

        // 计算指定时间窗口内经过的最多颜色的车辆数量
        int num = maxPassedCars(colors, k);

        // 输出结果
        System.out.println(num);
    }

    private static int maxPassedCars(int[] colors, int windowSize) {
        int windowStart = 0, maxCars = 0;
        Map&lt;Integer, Integer&gt; frequencyMap = new HashMap&lt;&gt;();
        for (int windowEnd = 0; windowEnd < colors.length; windowEnd++) {
            int count = frequencyMap.getOrDefault(colors[windowEnd], 0) + 1;
            maxCars = Math.max(maxCars, count);
            frequencyMap.put(colors[windowEnd], count);

            // 当窗口大小等于指定时间窗口时，缩小窗口
            if (windowEnd - windowStart + 1 == windowSize) {
                frequencyMap.put(colors[windowStart], frequencyMap.get(colors[windowStart]) - 1);
                windowStart++; // 缩小窗口
            }
        }

        return maxCars;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">点击查看笔记</summary>
  <blockquote>
<p>问题本质：统计指定区间内数字的出现频率</p>
</blockquote>
</details></p>

<hr>
<hr>
<hr>
<hr>
<h1 id="滑动窗口模式相关算法题">滑动窗口模式相关算法题<a hidden class="anchor" aria-hidden="true" href="#滑动窗口模式相关算法题">#</a></h1>
<h2 id="长度最小的子数组">长度最小的子数组<a hidden class="anchor" aria-hidden="true" href="#长度最小的子数组">#</a></h2>

<a href="https://leetcode.cn/problems/minimum-size-subarray-sum" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int windowSum = 0, minLength = Integer.MAX_VALUE;
        int windowStart = 0;
        for (int windowEnd = 0; windowEnd < nums.length; windowEnd++) {
            windowSum += nums[windowEnd];

            // 当窗口和大于目标值时，尽可能缩小窗口
            while (windowSum >= target) {
                minLength = Math.min(minLength, windowEnd - windowStart + 1);
                windowSum -= nums[windowStart];
                windowStart++;
            }
        }

        return minLength == Integer.MAX_VALUE ? 0 : minLength;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="水果成篮">水果成篮<a hidden class="anchor" aria-hidden="true" href="#水果成篮">#</a></h2>

<a href="https://leetcode.cn/problems/fruit-into-baskets" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int totalFruit(int[] fruits) {
        int maxLength = Integer.MIN_VALUE;
        Map&lt;Integer, Integer&gt; frequencyMap = new HashMap&lt;&gt;();

        int windowStart = 0;
        for (int windowEnd = 0; windowEnd < fruits.length; windowEnd++) {
            int endFruit = fruits[windowEnd];
            frequencyMap.put(endFruit, frequencyMap.getOrDefault(endFruit, 0) + 1);

            // 当水果类型大于2时缩小窗口
            while (frequencyMap.size() > 2) {
                int startFruit = fruits[windowStart];
                frequencyMap.put(startFruit, frequencyMap.get(startFruit) - 1);
                if (frequencyMap.get(startFruit) == 0) {
                    frequencyMap.remove(startFruit);
                }
                windowStart++;
            }

            maxLength = Math.max(maxLength, windowEnd - windowStart + 1);
        }

        return maxLength;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="华为od机试计算最接近的数100分">华为OD机试：计算最接近的数【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试计算最接近的数100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p><strong>一、题目描述</strong><br>
给定一个数组 <code>X</code> 和一个正整数 <code>K</code>，请找出一个下标 <code>i</code>，使得表达式 $X[i] - X[i-1] - \dots - X[i+K+1]$ 的结果最接近数组中位数的下标<code>i</code>。如果有多个满足条件的下标 <code>i</code>，请返回最大的 <code>i</code>。</p>
<p>数组的<strong>中位数</strong>定义为：将长度为 <code>N</code> 的数组按元素值从小到大排序后，下标为 <code>N/2</code> 的元素的值。</p>
<p><strong>二、输入描述</strong></p>
<ul>
<li>第一行输入一个数组 <code>X</code>（元素为整数，长度为 <code>N</code>）。</li>
<li>第二行输入正整数 <code>K</code>。</li>
</ul>
<p><strong>三、输出描述</strong></p>
<p>表达式 $X[i] - X[i-1] - \dots - X[i+K+1]$ 的结果最接近数组中位数的起始下标<code>i</code>。如果存在多个下标满足条件，返回最大的 <code>i</code>。</p>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

/**
 * @author Signal Yu
 * @since 2024-11-07
 */
class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取输入数组并去除方括号与空格
        int[] nums = Arrays.stream(in.nextLine()
                        .replaceAll("[\\[\\]\\s]", "")
                        .split(","))
                .mapToInt(Integer::parseInt)
                .toArray();

        // 读取整数k
        int k = Integer.parseInt(in.nextLine().trim());

        // 计算最接近中位数的表达式下标
        int index = getClosestIndex(nums, k);

        // 输出结果
        System.out.println(index);
    }

    private static int getClosestIndex(int[] nums, int k) {
        // 创建数组副本并排序以找到中位数
        int[] sortedNums = Arrays.copyOf(nums, nums.length);
        Arrays.sort(sortedNums);
        int median = sortedNums[sortedNums.length / 2];  // 计算中位数

        int closestIndex = -1;  // 最终输出的最接近中位数的起始下标
        int minDistance = Integer.MAX_VALUE;  // 初始化最小差值为最大整数

        for (int start = 0; start < nums.length; start++) {
            int current = nums[start];
            for (int end = start + 1; end <= Math.min(nums.length - 1, start + k + 1); end++) {
                current -= nums[end];
            }

            // 计算当前子数组和与中位数的差值
            int diff = Math.abs(current - median);

            // 更新最接近的下标与最小差值（若差值相同则选择更大的下标）
            if (diff <= minDistance) {
                closestIndex = start;
                minDistance = diff;
            }
        }

        return closestIndex;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="华为od机试用连续自然数之和来表达整数100分">华为OD机试：用连续自然数之和来表达整数【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试用连续自然数之和来表达整数100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p><strong>题目描述</strong>
给定一个整数，可以用连续的自然数之和表示。请计算该整数有多少种不同的连续自然数之和的表示方式，并输出每种表示。</p>
<p><strong>输入描述</strong>
一个目标整数 <code>T</code>，其中 <code>1 &lt;= T &lt;= 1000</code>。</p>
<p><strong>输出描述</strong>
输出该整数的所有连续自然数之和的表示方式以及表示方式的总数。</p>
<ul>
<li>输出顺序要求：优先输出自然数数量最少的表达方式。</li>
<li>每个表达式中自然数应按递增顺序排列，格式参考样例。</li>
<li>在所有表达式输出结束后，单独输出一行 <code>&quot;Result:X&quot;</code>，其中 <code>X</code> 为表达式的总个数。</li>
</ul>
<p><strong>输入示例</strong></p>
<pre tabindex="0"><code>9
</code></pre><p><strong>输出示例</strong></p>
<pre tabindex="0"><code>9=9
9=4+5
9=2+3+4
Result:3
</code></pre>
</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.Scanner;

/**
 * @author Signal Yu
 * @since 2024-11-07
 */
class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取整数 t
        int t = Integer.parseInt(in.nextLine().trim());

        // 获取符合条件的表达式及总数
        String result = getExpressionAndResult(t);

        // 输出结果
        System.out.println(result);
    }

    private static String getExpressionAndResult(int n) {
        StringBuilder result = new StringBuilder();

        int start = 1; // 记录窗口起始位置
        int count = 0; // 记录符合条件的表达式个数
        int windowSum = 0; // 记录窗口和
        // 使用滑动窗口找到所有符合条件的表达式
        for (int end = 1; end <= n; end++) {
            windowSum += end; // 更新窗口和

            // 窗口和大于目标 n时，缩小窗口
            while (windowSum > n) {
                windowSum -= start;
                start++;
            }

            // 窗口和等于目标 n，记录表达式
            if (windowSum == n) {
                StringBuilder expression = new StringBuilder();
                expression.append(n).append("=");
                for (int i = start; i <= end; i++) {
                    expression.append(i).append("+");
                }
                expression.setLength(expression.length() - 1); // 移除最后一个加号
                expression.append("\n");
                result.insert(0, expression); // 将表达式插入到结果的起始位置
                count++;
            }
        }

        // 添加表达式总数
        result.append("Result:").append(count);

        return result.toString();
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="华为od机试滑动窗口最大和100分">华为OD机试：滑动窗口最大和【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试滑动窗口最大和100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p><strong>题目描述</strong></p>
<p>给定一个包含 $N$ 个整数的数组和一个长度为 $M$ 的滑动窗口，从数组的第一个数开始，窗口逐步滑动直到无法再滑动。每次滑动窗口会生成一个窗口和（窗口中所有元素的总和），请找出所有窗口和中的最大值。</p>
<p><strong>输入描述</strong></p>
<ol>
<li>第一行输入一个正整数 $N$，表示数组中的整数个数（$0 &lt; N &lt; 100000$）。</li>
<li>第二行输入 $N$ 个整数，范围为 $[-100, 100]$。</li>
<li>第三行输入一个正整数 $M$，表示窗口大小，满足 $1 \le M \le N$。</li>
</ol>
<p><strong>输出描述</strong></p>
<p>输出所有窗口和的最大值。</p>
<p><strong>示例</strong></p>
<p><strong>输入</strong></p>
<pre tabindex="0"><code>6
10 20 30 15 23 12
3
</code></pre><p><strong>输出</strong></p>
<pre tabindex="0"><code>68
</code></pre><p><strong>说明</strong></p>
<p>窗口长度为 3，窗口滑动产生的窗口和为：</p>
<ul>
<li>10 + 20 + 30 = 60</li>
<li>20 + 30 + 15 = 65</li>
<li>30 + 15 + 23 = 68</li>
<li>15 + 23 + 12 = 50</li>
</ul>
<p>因此，最大窗口和为 68。</p>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

/**
 * @author Signal Yu
 * @since 2024-11-07
 */
class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取整数个数
        int n = Integer.parseInt(in.nextLine().trim());
        // 读取整数字符串并转换为数组
        int[] nums = Arrays.stream(in.nextLine().trim().split(" "))
                .mapToInt(Integer::parseInt)
                .toArray();
        // 读取滑动窗口大小
        int m = Integer.parseInt(in.nextLine().trim());

        // 计算符合条件的最大和
        int maxSum = getMaxSum(nums, n, m);

        // 输出结果
        System.out.println(maxSum);
    }

    private static int getMaxSum(int[] nums, int n, int m) {
        int start = 0, windowSum = 0, maxSum = Integer.MIN_VALUE;
        for (int end = 0; end < n; end++) {
            windowSum += nums[end]; // 更新窗口和

            // 当窗口大小等于 m 时，缩小窗口
            if (end - start + 1 == m) {
                maxSum = Math.max(maxSum, windowSum); // 更新最大和
                windowSum -= nums[start];
                start++; // 缩小窗口
            }
        }

        return maxSum;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="替换后的最长重复字符">替换后的最长重复字符<a hidden class="anchor" aria-hidden="true" href="#替换后的最长重复字符">#</a></h2>

<a href="https://leetcode.cn/problems/longest-repeating-character-replacement" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int characterReplacement(String s, int k) {
        Map&lt;Character, Integer&gt; frequencyMap = new HashMap&lt;&gt;();
        int maxLength = Integer.MIN_VALUE;
        int maxRepeatLetterCount = 0;

        int windowStart = 0;
        for (int windowEnd = 0; windowEnd < s.length(); windowEnd++) {
            char endChar = s.charAt(windowEnd);
            frequencyMap.put(endChar, frequencyMap.getOrDefault(endChar, 0) + 1);

            maxRepeatLetterCount = Math.max(maxRepeatLetterCount, frequencyMap.get(endChar));

            // 当窗口大小与最大重复字母数之差大于 k 时，需要缩小窗口
            if (windowEnd - windowStart + 1 - maxRepeatLetterCount > k) {
                char startChar = s.charAt(windowStart);
                frequencyMap.put(startChar, frequencyMap.get(startChar) - 1);
                windowStart++;
            }

            maxLength = Math.max(maxLength, windowEnd - windowStart + 1);
        }

        return maxLength;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="华为od机试补种未成活胡杨100分">华为OD机试：补种未成活胡杨【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试补种未成活胡杨100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p><strong>题目描述</strong><br>
近年来，我国在防沙治沙方面取得了显著成果。某沙漠中新种植了 <code>N</code> 棵胡杨树，排成一行。一段时间后，有 <code>M</code> 棵胡杨未能成活，现需选择其中的 <code>K</code> 棵进行补种（只能补种已枯死的胡杨，不能新增种植）。请问如何补种，能够使连续胡杨树的数量达到最大？</p>
<p><strong>输入描述</strong></p>
<ul>
<li>第一行包含三个整数，分别为：
<ul>
<li><code>N</code>：种植的胡杨总数量（1 ≤ N ≤ 100,000）</li>
<li><code>M</code>：未成活的胡杨数量（1 ≤ M ≤ N）</li>
<li><code>M</code> 个空格分隔的整数，按编号从小到大排列</li>
<li><code>K</code>：最多可以补种的胡杨数量（0 ≤ K ≤ M）</li>
</ul>
</li>
</ul>
<p><strong>输出描述</strong></p>
<p>输出最多的连续胡杨树数量。</p>
<p><strong>示例</strong><br>
<strong>输入</strong></p>
<pre tabindex="0"><code>5
2
2 4
1
</code></pre><p><strong>输出</strong></p>
<pre tabindex="0"><code>3
</code></pre><p><strong>说明</strong><br>
在 5 棵胡杨中，编号为 2、4 的胡杨未成活。最多可以补种 1 棵，通过补种编号为 2 或 4，可以形成最多的连续胡杨树，即 3 棵。</p>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;
import java.util.stream.Collectors;

/**
 * @author Signal Yu
 * @since 2024-11-08
 */
class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取种植的胡杨总数
        int n = Integer.parseInt(in.nextLine().trim());
        // 读取未成活的胡杨数量
        int m = Integer.parseInt(in.nextLine().trim());
        // 读取未成活的胡杨编号并转换为集合
        Set&lt;Integer&gt; deadPopulusSet = Arrays.stream(in.nextLine().trim().split(" "))
                .map(Integer::parseInt)
                .collect(Collectors.toSet());
        // 读取可以补种的棵数
        int k = Integer.parseInt(in.nextLine().trim());

        // 计算补种后最多连续胡杨树数量
        int maxSurvivals = getMaxAlive(n, deadPopulusSet, k);

        // 输出结果
        System.out.println(maxSurvivals);
    }

    private static int getMaxAlive(int n, Set<Integer> deadPopulusSet, int k) {
        int start = 1, maxSurvivals = 0, deathCount = 0;
        for (int end = 1; end <= n; end++) {
            if (deadPopulusSet.contains(end)) {
                deathCount++;
            }

            // 当前窗口内未成活的胡杨树棵数超过 k 时，缩小窗口
            while (deathCount > k) {
                if (deadPopulusSet.contains(start)) {
                    deathCount--;
                }
                start++; // 缩小窗口
            }

            maxSurvivals = end - start + 1; // 更新最大连续成活数量
        }

        return maxSurvivals;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="最大连续1的个数-iii">最大连续1的个数 III<a hidden class="anchor" aria-hidden="true" href="#最大连续1的个数-iii">#</a></h2>

<a href="https://leetcode.cn/problems/max-consecutive-ones-iii" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int longestOnes(int[] nums, int k) {
        int maxLength = 0;       // 记录最长窗口长度
        int maxOnesInWindow = 0; // 记录当前窗口内的1的个数
        int windowStart = 0;

        for (int windowEnd = 0; windowEnd < nums.length; windowEnd++) {
            if (nums[windowEnd] == 1) {
                maxOnesInWindow++;
            }

            // 如果当前窗口内0的个数超过k，缩小窗口
            while (windowEnd - windowStart + 1 - maxOnesInWindow > k) {
                if (nums[windowStart] == 1) {
                    maxOnesInWindow--;
                }
                windowStart++;
            }

            // 更新最长窗口长度
            maxLength = Math.max(maxLength, windowEnd - windowStart + 1);
        }

        return maxLength;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="字符串的排列">字符串的排列<a hidden class="anchor" aria-hidden="true" href="#字符串的排列">#</a></h2>

<a href="https://leetcode.cn/problems/permutation-in-string" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public boolean checkInclusion(String s1, String s2) {
        Map&lt;Character, Integer&gt; frequencyMap = new HashMap&lt;&gt;();

        // 初始化s1中每个字符的频率
        for (char c : s1.toCharArray()) {
            frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1);
        }

        int windowStart = 0; // 滑动窗口起始位置
        int matched = 0; // 已匹配的字符种类数

        // 移动窗口的结束位置
        for (int windowEnd = 0; windowEnd < s2.length(); windowEnd++) {
            char endChar = s2.charAt(windowEnd); // 当前窗口的结束字符

            // 如果结束字符在频率表中，更新其频率
            if (frequencyMap.containsKey(endChar)) {
                frequencyMap.put(endChar, frequencyMap.get(endChar) - 1);

                // 如果字符频率降为0，表示完全匹配一个字符
                if (frequencyMap.get(endChar) == 0) {
                    matched++;
                }
            } 

            // 若所有字符都匹配，返回true
            if (matched == frequencyMap.size()) {
                return true;
            }

            // 当窗口大小等于s1的长度时，调整窗口
            if (windowEnd - windowStart + 1 >= s1.length()) {
                char startChar = s2.charAt(windowStart); // 当前窗口的起始字符

                // 若起始字符在频率表中，恢复频率并更新匹配状态
                if (frequencyMap.containsKey(startChar)) {
                    if (frequencyMap.get(startChar) == 0) {
                        matched--;
                    }
                    frequencyMap.put(startChar, frequencyMap.get(startChar) + 1);
                }

                // 移动窗口起始位置
                windowStart++;
            }
        }

        // 若未找到匹配的子串，返回false
        return false;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="华为od机试关联子串100分">华为OD机试：关联子串【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试关联子串100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p><strong>题目描述</strong></p>
<p>给定两个字符串 <code>str1</code> 和 <code>str2</code>，判断是否存在 <code>str1</code> 的某种排列是 <code>str2</code> 的子串。如果存在，返回该子串在 <code>str2</code> 中的起始位置；如果不存在，则返回 -1。</p>
<p><strong>输入描述</strong></p>
<p>第一行输入两个字符串，分别为 <code>str1</code> 和 <code>str2</code>，用空格分隔。</p>
<p><strong>输出描述</strong></p>
<p>返回 <code>str1</code> 的某排列在 <code>str2</code> 中的子串起始位置。如果不存在关联子串，则输出 -1。</p>
<p><strong>示例</strong></p>
<p><strong>输入</strong></p>
<pre tabindex="0"><code>vae hsgseva
</code></pre><p><strong>输出</strong></p>
<pre tabindex="0"><code>4
</code></pre><p><strong>说明</strong></p>
<p>在 <code>str2</code> 中，<code>str1</code> 的某种排列 <code>eva</code> 出现于索引 4。</p>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

/**
 * @author Signal Yu
 * @since 2024-11-07
 */
class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取字符串 str1 和 str2
        String[] parts = in.nextLine().trim().split(" ");
        String str1 = parts[0];
        String str2 = parts[1];

        // 计算关联子串 str1 在 str2 中的起始位置，非关联子串返回 -1
        int index = getInclusionIndex(str1, str2);

        // 输出结果
        System.out.println(index);
    }

    private static int getInclusionIndex(String s1, String s2) {
        if (s1.length() > s2.length()) {
            return -1;
        }

        // 统计字符串 s1 中的字母频率
        Map&lt;Character, Integer&gt; frequencyMap = new HashMap&lt;&gt;();
        for (char c : s1.toCharArray()) {
            frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1);
        }

        int start = 0; // 记录窗口起始位置
        int matched = 0; // 记录已匹配的字符
        for (int end = 0; end < s2.length(); end++) {
            char endChar = s2.charAt(end); // 当前窗口结束字符
            if (frequencyMap.containsKey(endChar)) {
                frequencyMap.put(endChar, frequencyMap.get(endChar) - 1);
                if (frequencyMap.get(endChar) == 0) {
                    matched++;
                }
            }

            // 当所有字符匹配时，返回起始位置
            if (matched == frequencyMap.size()) {
                return start;
            }

            // 当窗口大小等于字符串s1长度时，收缩窗口
            if (end - start + 1 == s1.length()) {
                char startChar = s2.charAt(start); // 当前窗口起始字符
                if (frequencyMap.containsKey(startChar)) {
                    if (frequencyMap.get(startChar) == 0) {
                        matched--;
                    }
                    frequencyMap.put(startChar, frequencyMap.get(startChar) + 1);
                }
                start++; // 收缩窗口
            }
        }

        return -1;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="找到字符串中所有字母异位词">找到字符串中所有字母异位词<a hidden class="anchor" aria-hidden="true" href="#找到字符串中所有字母异位词">#</a></h2>

<a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public List&lt;Integer&gt; findAnagrams(String s, String p) {
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();

        Map&lt;Character, Integer&gt; frequencyMap = new HashMap&lt;&gt;();
        for (char c : p.toCharArray()) {
            frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1);
        }
        
        int windowStart = 0, matched = 0;
        for (int windowEnd = 0; windowEnd < s.length(); windowEnd++) {
            char endChar = s.charAt(windowEnd); // 当前窗口的结束字符
            if (frequencyMap.containsKey(endChar)) {
                // 更新频率映射，记录匹配字符
                frequencyMap.put(endChar, frequencyMap.get(endChar) - 1);
                if (frequencyMap.get(endChar) == 0) {
                    matched++;
                }
            }

            // 如果所有字符都匹配，则记录起始索引
            if (matched == frequencyMap.size()) {
                result.add(windowStart);
            }

            // 窗口大小与目标字符串长度相等时，开始收缩窗口
            if (windowEnd - windowStart + 1 >= p.length()) {
                char startChar = s.charAt(windowStart); // 当前窗口的起始字符
                if (frequencyMap.containsKey(startChar)) {
                    if (frequencyMap.get(startChar) == 0) {
                        matched--;
                    }
                    frequencyMap.put(startChar, frequencyMap.get(startChar) + 1);
                }
                windowStart++; // 收缩窗口
            }
        }

        return result;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="最小覆盖子串">最小覆盖子串<a hidden class="anchor" aria-hidden="true" href="#最小覆盖子串">#</a></h2>

<a href="https://leetcode.cn/problems/minimum-window-substring" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public String minWindow(String s, String t) {
        // 如果 t 比 s 长，直接返回空字符串
        if (t.length() > s.length()) {
            return "";
        }

        // 创建 t 的字符频率映射
        Map&lt;Character, Integer&gt; frequencyMap = new HashMap&lt;&gt;();
        for (char c : t.toCharArray()) {
            frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1);
        }

        int windowStart = 0; // 窗口的起始位置
        int minLength = s.length() + 1; // 最小窗口长度，初始化为超过 s 长度
        int matched = 0; // 记录匹配到的字符数
        int subStrStart = 0; // 最小窗口的起始位置

        // 扩展窗口
        for (int windowEnd = 0; windowEnd < s.length(); windowEnd++) {
            char endChar = s.charAt(windowEnd);
            
            // 如果结束字符在 t 中，则减少其频率
            if (frequencyMap.containsKey(endChar)) {
                frequencyMap.put(endChar, frequencyMap.get(endChar) - 1);
                
                // 频率非负时，说明该字符计入有效匹配
                if (frequencyMap.get(endChar) >= 0) {
                    matched++;
                }
            }

            // 当前窗口包含所有 t 中字符时，尝试收缩窗口
            while (matched == t.length()) {
                // 更新最小窗口长度和起始位置
                if (windowEnd - windowStart + 1 < minLength) {
                    minLength = windowEnd - windowStart + 1;
                    subStrStart = windowStart;
                }

                // 收缩窗口，处理起始字符
                char startChar = s.charAt(windowStart);
                if (frequencyMap.containsKey(startChar)) {
                    // 如果起始字符频率为 0，说明缩小窗口会减少匹配数
                    if (frequencyMap.get(startChar) == 0) {
                        matched--;
                    }
                    // 恢复起始字符的频率
                    frequencyMap.put(startChar, frequencyMap.get(startChar) + 1);
                }
                windowStart++; // 窗口起点右移
            }
        }

        // 返回最小窗口子串或空字符串
        return minLength > s.length() ? "" : s.substring(subStrStart, subStrStart + minLength);
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="华为od机试最左侧冗余覆盖子串100分">华为OD机试：最左侧冗余覆盖子串【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试最左侧冗余覆盖子串100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p><strong>一、题目描述</strong></p>
<p>给定两个字符串 <code>s1</code> 和 <code>s2</code> 以及一个正整数 <code>k</code>，其中 <code>s1</code> 的长度为 <code>n1</code>，<code>s2</code> 的长度为 <code>n2</code>。要求在 <code>s2</code> 中找到一个长度为 <code>n1 + k</code> 的子串，满足以下条件：</p>
<ol>
<li>该子串的长度为 <code>n1 + k</code>；</li>
<li>该子串包含 <code>s1</code> 中的所有字母；</li>
<li>该子串中每个字母的出现次数不少于 <code>s1</code> 中对应的字母次数。</li>
</ol>
<p>如果在 <code>s2</code> 中存在满足条件的子串，则称 <code>s2</code> 以长度 <code>k</code> 冗余覆盖 <code>s1</code>。要求返回满足条件的最左侧子串的起始下标；如果不存在，则返回 <code>-1</code>。</p>
<p><strong>二、输入描述</strong></p>
<p>输入为三行：</p>
<ol>
<li>第一行是字符串 <code>s1</code>。</li>
<li>第二行是字符串 <code>s2</code>。</li>
<li>第三行是整数 <code>k</code>。</li>
</ol>
<p><em>注意：<code>s1</code> 和 <code>s2</code> 都只包含小写字母。</em></p>
<p><strong>三、输出描述</strong></p>
<p>输出满足条件的 <code>s2</code> 中子串的最左侧起始下标；若不存在，则返回 <code>-1</code>。</p>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

/**
 * @author Signal Yu
 * @since 2024-11-06
 */
class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取字符串和正整数k
        String s1 = in.nextLine().trim();
        String s2 = in.nextLine().trim();
        int k = Integer.parseInt(in.nextLine().trim());

        // 计算冗余覆盖子串的最左侧起始下标
        int index = getIndex(s1, s2, k);

        // 输出结果
        System.out.println(index);
    }

    private static int getIndex(String s1, String s2, int k) {
        int index = -1;
        int subStrLength = s1.length() + k;
        if (subStrLength > s2.length()) {
            return -1; // s2 不足以包含指定长度的子串
        }

        // 构建 s1 中字符的频率表
        Map&lt;Character, Integer&gt; frequencyMap = new HashMap&lt;&gt;();
        for (char c : s1.toCharArray()) {
            frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1);
        }

        int windowStart = 0;
        int matched = 0; // 记录已匹配字符
        for (int windowEnd = 0; windowEnd < s2.length(); windowEnd++) {
            char endChar = s2.charAt(windowEnd); // 当前窗口结束字符
            if (frequencyMap.containsKey(endChar)) {
                frequencyMap.put(endChar, frequencyMap.get(endChar) - 1);
                if (frequencyMap.get(endChar) == 0) { // 已匹配当前字符
                    matched++;
                }
            }

            // 所有字符匹配完成，返回结果
            if (matched == frequencyMap.size()) {
                return windowStart;
            }

            // 窗口大小等于目标子串长度时，缩小窗口
            if (windowEnd - windowStart + 1 == subStrLength) {
                char startChar = s2.charAt(windowStart); // 当前窗口起始字符
                if (frequencyMap.containsKey(startChar)) {
                    if (frequencyMap.get(startChar) == 1) { // 收缩窗口后，该字符变为未匹配
                        matched--;
                    }
                    frequencyMap.put(startChar, frequencyMap.get(startChar) + 1);
                }
                windowStart++; // 窗口收缩
            }
        }

        return index;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="串联所有单词的子串">串联所有单词的子串<a hidden class="anchor" aria-hidden="true" href="#串联所有单词的子串">#</a></h2>

<a href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="包含所有三种字符的子字符串数目">包含所有三种字符的子字符串数目<a hidden class="anchor" aria-hidden="true" href="#包含所有三种字符的子字符串数目">#</a></h2>

<a href="https://leetcode.cn/problems/number-of-substrings-containing-all-three-characters" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int numberOfSubstrings(String s) {
        int[] charCount = new int[3]; // 用于存储 'a', 'b', 'c' 的出现次数
        int start = 0, count = 0;
        for (int end = 0; end < s.length(); end++) {
            // 更新当前窗口内字符的出现次数
            charCount[s.charAt(end) - 'a']++;

            while (charCount[0] > 0 && charCount[1] > 0 && charCount[2] > 0) {
                count += s.length() - end; // 子串数量加1
                charCount[s.charAt(start) - 'a']--; // 移除窗口起始字符
                start++; // 缩小窗口
            }
        }

        return count;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="华为od机试优雅子数组100分">华为OD机试：优雅子数组【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试优雅子数组100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p><strong>题目描述</strong></p>
<p>如果一个数组中某个元素的出现次数大于等于 $k$ 次，则称该数组为 <strong>k-优雅数组</strong>，其中 $k$ 被称为 <strong>优雅阈值</strong>。</p>
<p>例如，数组 <code>[2, 3, 1, 2, 3, 1, 2, 3, 1]</code> 是一个 3-优雅数组，因为元素 <code>1</code> 的出现次数达到了 3 次或更多。相反，数组 <code>[2, 3, 1, 2, 3, 1]</code> 不是一个 3-优雅数组，因为其中出现次数最多的元素（<code>1</code> 和 <code>2</code>）都仅出现了 2 次。</p>
<p>给定一个数组 <code>A</code> 和一个阈值 <code>k</code>，请计算 <code>A</code> 中有多少个子数组是 <strong>k-优雅子数组</strong>。</p>
<p>子数组是数组中由一个或多个连续元素组成的子集。例如，数组 <code>[1, 2, 3, 4]</code> 包含 10 个子数组，分别为：</p>
<ul>
<li><code>[1]</code>，<code>[1, 2]</code>，<code>[1, 2, 3]</code>，<code>[1, 2, 3, 4]</code></li>
<li><code>[2]</code>，<code>[2, 3]</code>，<code>[2, 3, 4]</code></li>
<li><code>[3]</code>，<code>[3, 4]</code></li>
<li><code>[4]</code></li>
</ul>
<p><strong>输入描述</strong></p>
<ul>
<li>第一行输入两个整数，以空格隔开，分别表示数组 <code>A</code> 的长度和优雅阈值 <code>k</code>。</li>
<li>第二行输入数组 <code>A</code> 的元素，以空格隔开。</li>
</ul>
<p><strong>输出描述</strong></p>
<ul>
<li>输出数组 <code>A</code> 中有多少个子数组是 <strong>k-优雅子数组</strong>。</li>
</ul>
<p><strong>测试用例</strong></p>
<p><strong>测试用例 1</strong></p>
<p><strong>输入：</strong></p>
<pre tabindex="0"><code>7 3
1 2 3 1 2 3 1
</code></pre><p><strong>输出：</strong></p>
<pre tabindex="0"><code>1
</code></pre><p><strong>说明：</strong> 只有整个数组 <code>[1, 2, 3, 1, 2, 3, 1]</code> 中，元素 <code>1</code> 的出现次数达到 3 次。</p>
<p><strong>测试用例 2</strong></p>
<p><strong>输入：</strong></p>
<pre tabindex="0"><code>7 2
1 2 3 1 2 3 1
</code></pre><p><strong>输出：</strong></p>
<pre tabindex="0"><code>10
</code></pre><p><strong>说明：</strong> 有 10 个子数组中，至少有一个元素出现了 2 次或更多。</p>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

/**
 * @author Signal Yu
 * @since 2024-11-09
 */
class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取数组长度和优雅阈值
        int[] parts = Arrays.stream(in.nextLine().trim().split(" "))
                .mapToInt(Integer::parseInt)
                .toArray();
        int n = parts[0];
        int k = parts[1];
        // 读取数字字符串并转换为整数数组
        int[] nums = Arrays.stream(in.nextLine().trim().split(" "))
                .mapToInt(Integer::parseInt)
                .toArray();

        // 计算优雅子数组的个数
        int count = countElegantSubarrays(nums, n, k);

        // 输出结果
        System.out.println(count);
    }

    private static int countElegantSubarrays(int[] nums, int n, int k) {
        Map&lt;Integer, Integer&gt; frequencyMap = new HashMap&lt;&gt;();

        int start = 0, count = 0;
        for (int end = 0; end < n; end++) {
            // 统计窗口内数字的频率
            frequencyMap.put(nums[end], frequencyMap.getOrDefault(nums[end], 0) + 1);

            // 检查当前窗口是否符合 k-优雅条件
            while (isKElegant(frequencyMap, k)) {
                count += n - end; // 更新优雅子数组的个数

                // 缩小窗口，并减少频率映射中对应元素的计数
                frequencyMap.put(nums[start], frequencyMap.get(nums[start]) - 1);
                if (frequencyMap.get(nums[start]) == 0) {
                    frequencyMap.remove(nums[start]);
                }
                start++;
            }
        }

        return count;
    }

    private static boolean isKElegant(Map&lt;Integer, Integer&gt; frequencyMap, int k) {
        for (int count : frequencyMap.values()) {
            if (count >= k) {
                return true;
            }
        }

        return false;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h1 id="数学与逻辑分析模式相关算法题">数学与逻辑分析模式相关算法题<a hidden class="anchor" aria-hidden="true" href="#数学与逻辑分析模式相关算法题">#</a></h1>
<h2 id="华为od机试考勤信息100分">华为OD机试：考勤信息【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试考勤信息100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p><strong>一、题目描述</strong></p>
<p>公司使用一个字符串来表示员工的出勤情况，其中：</p>
<ul>
<li><code>absent</code> 表示缺勤</li>
<li><code>late</code> 表示迟到</li>
<li><code>leaveearly</code> 表示早退</li>
<li><code>present</code> 表示正常出勤</li>
</ul>
<p>需要根据员工的出勤记录，判断该员工是否可以获得出勤奖。出勤奖的获得条件如下：</p>
<ol>
<li>缺勤次数不超过一次；</li>
<li>没有连续的迟到或早退；</li>
<li>任意连续 7 次出勤记录中，缺勤、迟到或早退的次数不超过 3 次。</li>
</ol>
<p><strong>二、输入描述</strong></p>
<p>第一行输入一个正整数 $n $，表示考勤记录的条数。<br>
接下来的 $n $行，每行包含一个字符串，表示一条考勤记录。</p>
<p>注意：</p>
<ul>
<li>记录条数 $n \geq 1 $；</li>
<li>每个字符串长度小于 10000；</li>
<li>不存在非法输入。</li>
</ul>
<p><strong>三、输出描述</strong><br>
根据每条考勤记录，如果该员工符合出勤奖条件，则输出 <code>&quot;true&quot;</code>；否则输出 <code>&quot;false&quot;</code>。<br>
对于输入示例的结果，输出每条考勤记录对应的判断结果，每个结果占一行。</p>
<p><strong>示例</strong></p>
<p>输入：</p>
<pre tabindex="0"><code>2
present present absent late present present leaveearly present
absent late late leaveearly absent present
</code></pre><p>输出：</p>
<pre tabindex="0"><code>true
false
</code></pre>
</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

/**
 * @author Signal Yu
 * @since 2024-11-04
 */
class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取考勤记录条数
        int n = Integer.parseInt(in.nextLine().trim());
        // 读取考勤记录并处理
        for (int i = 0; i < n; i++) {
            String attendanceRecord = in.nextLine().trim();
            String result = isEligibleForAward(attendanceRecord) ? "true" : "false";
            System.out.println(result);
        }

        in.close();
    }

    private static boolean isEligibleForAward(String attendanceRecord) {
        String[] attendanceList = attendanceRecord.split(" ");

        int absentCount = 0;
        int continuousLateOrLeaveEarly = 0;
        for (int i = 0; i < attendanceList.length; i++) {
            String record = attendanceList[i];
            // 条件1：缺勤次数不超过1次
            if ("absent".equals(record)) {
                absentCount++;
                if (absentCount > 1) {
                    return false;
                }
            }

            // 条件2：没有连续的迟到或早退
            if ("late".equals(record) || "leaveearly".equals(record)) {
                continuousLateOrLeaveEarly++;
                if (continuousLateOrLeaveEarly > 1) {
                    return false;
                }
            } else {
                continuousLateOrLeaveEarly = 0;
            }

            // 条件3：任意连续7次出勤记录中，缺勤、迟到和早退的次数不超过3次
            // 条件3等价于一周内present次数小于4
            if (i >= 6) {
                int presentCount = 0;
                for (int j = i - 6; j <= i; j++) {
                    if ("present".equals(attendanceList[j])) {
                        presentCount++;
                    }
                }
                if (presentCount < 4) {
                    return false;
                }
            }
        }

        return true;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="质数减法运算">质数减法运算<a hidden class="anchor" aria-hidden="true" href="#质数减法运算">#</a></h2>

<a href="https://leetcode.cn/problems/prime-subtraction-operation" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public boolean primeSubOperation(int[] nums) {
        // 获取数组最大值
        int maxNum = Arrays.stream(nums).max().orElseThrow();

        // 生成素数数组
        int[] primes = generatePrimes(maxNum);

        int prev = 0; // 初始化前一个数字为0以便第一次比较
        for (int num : nums) {
            // 尝试用小于 num 的最大素数使其变为比 prev 大的值
            boolean found = false;
            for (int prime : primes) {
                if (num - prime > prev) {
                    num -= prime;
                    found = true;
                    break;
                }
            }

            // 如果找不到合适的素数来调整num以满足严格递增，则返回false
            if (!found && num <= prev) {
                return false;
            }

            prev = num;
        }

        return true;
    }

    // 生成小于 limit 且呈递减顺序的素数数组
    private static int[] generatePrimes(int limit) {
        List<Integer> primes = new ArrayList<>();

        for (int i = limit - 1; i >= 2; i--) {
            if (isPrime(i)) {
                primes.add(i);
            }
        }

        return primes.stream().mapToInt(Integer::intValue).toArray();
    }

    // 判断自然数是否为素数
    private static boolean isPrime(int n) {
        if (n <= 1) {
            return false;
        }

        if (n <= 3) {
            return true;
        }

        if (n % 2 == 0 || n % 3 == 0) {
            return false;
        }

        /**
         所有大于 3 的质数都可以表示成 6𝑘±1 的形式
         i 从 5 开始，表示第一个满足 6k - 1 的数。
         i + 2 则是紧接的满足 6k + 1 的数。
         */
        for (int i = 5; i <= Math.sqrt(n); i += 6) {
            if (n % i == 0 || n % (i+2) == 0) {
                return false;
            }
        }

        return true;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="数列描述100分">数列描述【100分】<a hidden class="anchor" aria-hidden="true" href="#数列描述100分">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>一、题目描述</strong></p>
<p>有一个数列 <code>a[N]</code>（<code>N=60</code>），其中 <code>a[0] = &quot;1&quot;</code>，每一项 <code>a[n+1]</code> 是对前一项 <code>a[n]</code> 的描述。具体规则如下：</p>
<ol>
<li><code>a[0] = &quot;1&quot;</code>。</li>
<li><code>a[1] = &quot;11&quot;</code>，表示 <code>a[0]</code> 中有一个 &ldquo;1&rdquo;。</li>
<li><code>a[2] = &quot;21&quot;</code>，表示 <code>a[1]</code> 中有两个 &ldquo;1&rdquo;。</li>
<li><code>a[3] = &quot;1211&quot;</code>，表示 <code>a[2]</code> 中有一个 &ldquo;2&rdquo; 和一个 &ldquo;1&rdquo;。</li>
<li><code>a[4] = &quot;111221&quot;</code>，表示 <code>a[3]</code> 中有一个 &ldquo;1&rdquo;、一个 &ldquo;2&rdquo; 和两个 &ldquo;1&rdquo;。</li>
</ol>
<p>即每一项的生成规则是：从前一项的数字中按顺序描述出现次数和对应的数字。</p>
<p>例如：</p>
<ul>
<li><code>a[0] = &quot;1&quot;</code>，描述为 &ldquo;一个 1&rdquo;，得到 <code>a[1] = &quot;11&quot;</code>。</li>
<li><code>a[1] = &quot;11&quot;</code>，描述为 &ldquo;两个 1&rdquo;，得到 <code>a[2] = &quot;21&quot;</code>。</li>
<li><code>a[2] = &quot;21&quot;</code>，描述为 &ldquo;一个 2，一个 1&rdquo;，得到 <code>a[3] = &quot;1211&quot;</code>。</li>
<li><code>a[3] = &quot;1211&quot;</code>，描述为 &ldquo;一个 1，一个 2，两个 1&rdquo;，得到 <code>a[4] = &quot;111221&quot;</code>。</li>
</ul>
<p>请输出数列中的第 <code>n</code> 项。</p>
<p><strong>二、输入描述</strong></p>
<p>输入一个整数 <code>n</code>，表示数列中第 <code>n</code> 项的位置（<code>0 &lt;= n &lt;= 59</code>）。</p>
<p><strong>三、输出描述</strong></p>
<p>输出数列中第 <code>n</code> 项的内容。</p>
<p><strong>四、输入输出示例</strong></p>
<p><strong>输入：</strong></p>
<pre tabindex="0"><code>5
</code></pre><p><strong>输出</strong></p>
<pre tabindex="0"><code>312211
</code></pre><p><strong>五、说明</strong></p>
<ul>
<li>通过输入 <code>n=5</code>，输出 <code>a[5]</code>。</li>
<li>根据规则，数列的前几项如下：
<ul>
<li><code>a[0] = &quot;1&quot;</code></li>
<li><code>a[1] = &quot;11&quot;</code></li>
<li><code>a[2] = &quot;21&quot;</code></li>
<li><code>a[3] = &quot;1211&quot;</code></li>
<li><code>a[4] = &quot;111221&quot;</code></li>
<li><code>a[5] = &quot;312211&quot;</code></li>
</ul>
</li>
</ul>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.Scanner;

/**
 * @author Signal Yu
 * @since 2024-11-30
 */
public class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        int n = Integer.parseInt(in.nextLine().trim());

        String result = getNthTerm(n);

        System.out.println(result);
    }

    private static String getNthTerm(int n) {
        String term = "1";  // 初始项 a[0] = "1"

        // 逐项生成数列的每一项，直到第 n 项
        for (int i = 1; i <= n; i++) {
            term = describeTerm(term);  // 对当前项描述生成下一项
        }

        return term;
    }

    private static String describeTerm(String term) {
        StringBuilder nextTerm = new StringBuilder();

        int count = 1;  // 计数器，初始时认为当前数字出现了 1 次
        // 从第二个字符开始遍历当前项，统计连续相同字符的次数
        for (int i = 1; i < term.length(); i++) {
            if (term.charAt(i) == term.charAt(i - 1)) {
                count++;  // 当前字符与前一个字符相同，计数器加 1
            } else {
                nextTerm.append(count).append(term.charAt(i - 1));  // 描述上一组数字
                count = 1;  // 重置计数器
            }
        }

        // 处理最后一组字符
        nextTerm.append(count).append(term.charAt(term.length() - 1));

        return nextTerm.toString();  // 返回描述后的下一项
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h1 id="前缀和模式相关算法题">前缀和模式相关算法题<a hidden class="anchor" aria-hidden="true" href="#前缀和模式相关算法题">#</a></h1>
<h2 id="找到数组的中间位置">找到数组的中间位置<a hidden class="anchor" aria-hidden="true" href="#找到数组的中间位置">#</a></h2>

<a href="https://leetcode.cn/problems/find-the-middle-index-in-array" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int findMiddleIndex(int[] nums) {
        int totalSum = Arrays.stream(nums).sum();

        int leftSum = 0;
        for (int i = 0; i < nums.length; i++) {
            int rightSum = totalSum - leftSum - nums[i];
            if (leftSum == rightSum) {
                return i;
            }
            leftSum += nums[i];
        }

        return -1;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="华为od机试阿里巴巴找黄金宝箱i">华为OD机试：阿里巴巴找黄金宝箱(I)<a hidden class="anchor" aria-hidden="true" href="#华为od机试阿里巴巴找黄金宝箱i">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p><strong>一、题目描述</strong></p>
<p>樵夫阿里巴巴在砍柴路上意外发现了强盗团伙的藏宝地。藏宝地有一排编号从0到N的箱子，每个箱子上贴有一个数字。传说中，这些箱子里藏有一个黄金宝箱。</p>
<p>黄金宝箱的定义是：它满足以下条件——在它之前所有箱子上数字的总和，等于在它之后所有箱子上数字的总和。<br>
<em>第一个箱子左边部分的数字总和定义为0，最后一个箱子右边部分的数字总和也定义为0。</em></p>
<p>请帮助阿里巴巴找到第一个符合条件的黄金宝箱，并输出该黄金宝箱的编号。如果不存在这样的黄金宝箱，则返回-1。</p>
<p><strong>二、输入描述</strong></p>
<p>一个用逗号分隔的数字列表，表示每个箱子上贴的数字，例如：1,-1,0。</p>
<ul>
<li>箱子的数量至少为1个，最多为10,000个。</li>
<li>每个箱子上的数字范围在-1000到1000之间。</li>
</ul>
<p><strong>三、输出描述</strong></p>
<p>输出第一个符合条件的黄金宝箱的编号，如果没有符合条件的宝箱，则输出-1。</p>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

/**
 * @author Signal Yu
 * @since 2024-11-04
 */
class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取箱子数字
        int[] boxNumbers = Arrays.stream(in.nextLine().trim().split(","))
                .mapToInt(Integer::parseInt)
                .toArray();

        in.close();

        // 寻找黄金宝箱编号
        int result = findTreasureBox(boxNumbers);

        // 输出结果
        System.out.println(result);
    }

    private static int findTreasureBox(int[] boxNumbers) {
        // 计算箱子数字总和
        int totalSum = Arrays.stream(boxNumbers).sum();

        int leftSum = 0;
        for (int i = 0; i < boxNumbers.length; i++) {
            int rightSum = totalSum - leftSum - boxNumbers[i];
            if (leftSum == rightSum) {
                return i;
            }
            leftSum += boxNumbers[i];
        }

        return -1;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="华为-od">华为 OD<a hidden class="anchor" aria-hidden="true" href="#华为-od">#</a></h2>
<h2 id="光伏场地建设规划100分">光伏场地建设规划【100分】<a hidden class="anchor" aria-hidden="true" href="#光伏场地建设规划100分">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>一、题目描述</strong></p>
<p>祖国西北部有一片广阔的荒地，零星分布着一些湖泊、保护区和矿区。整体上，这片地区常年光照良好，但也存在一些光照较差的区域。某电力公司希望在这片荒地上建设多个光伏电站，生产清洁能源。为了评估不同区域的发电潜力，对每平方公里的土地进行了发电量评估，其中不能建设的区域的发电量为0千瓦，能够建设的区域根据光照、地形等因素给出了每平方公里的年发电量（单位：千瓦）。我们希望能够找到其中发电量集中且合适的矩形区域用于建设光伏电站，从而获得良好的收益。</p>
<p><strong>二、输入描述</strong></p>
<ul>
<li>第一行输入为调研区域的长、宽，以及准备建设电站的边长。电站的边长是正方形，且要求每个电站的最小年发电量。</li>
<li>随后的每一行包含调研区域中每平方公里的年发电量。</li>
</ul>
<p><strong>输入格式：</strong></p>
<ul>
<li>第一行包含四个整数 <code>L</code>、<code>W</code>、<code>S</code>、<code>M</code>，其中：
<ul>
<li><code>L</code>：调研区域的长度。</li>
<li><code>W</code>：调研区域的宽度。</li>
<li><code>S</code>：电站的边长（单位：公里，正方形电站）。</li>
<li><code>M</code>：电站的最低年发电量要求（单位：千瓦）。</li>
</ul>
</li>
<li>接下来的 <code>L</code> 行，每行包含 <code>W</code> 个整数，表示该位置每平方公里的年发电量。</li>
</ul>
<p><strong>输入示例：</strong></p>
<pre tabindex="0"><code>2 5 2 6
2 3 7 1 4
3 5 2 8 1
</code></pre><p><strong>三、输出描述</strong></p>
<ul>
<li>输出符合要求的矩形区域的数量。即，每个边长为 <code>S</code> 的正方形区域（电站区域）在该区域内的年发电量总和大于或等于 <code>M</code> 的数量。</li>
</ul>
<p><strong>输出示例：</strong></p>
<pre tabindex="0"><code>4
</code></pre><p><strong>四、补充说明</strong></p>
<ul>
<li>调研区域的长宽 <code>L</code> 和 <code>W</code> 均大于等于 1。</li>
<li>电站的边长 <code>S</code> 大于等于 1，且 <code>S</code> 小于等于 <code>L</code> 和 <code>W</code> 中较小的那个值。</li>
<li>任何区域的年发电量都大于或等于 0千瓦。</li>
</ul>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

/**
 * @author Signal Yu
 * @since 2024-12-1
 */
public class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        int[] parts = Arrays.stream(in.nextLine().trim().split(" "))
                .mapToInt(Integer::parseInt)
                .toArray();
        int rows = parts[0];
        int cols = parts[1];
        int side = parts[2];
        int minPower = parts[3];

        int[][] matrixPower = new int[rows][cols];
        for (int i = 0; i < rows; i++) {
            matrixPower[i] = Arrays.stream(in.nextLine().trim().split(" "))
                    .mapToInt(Integer::parseInt)
                    .toArray();
        }

        int result = countAvailableArea(matrixPower, side, minPower);

        System.out.println(result);
    }

    private static int countAvailableArea(int[][] matrixPower, int side, int minPower) {
        int rows = matrixPower.length;
        int cols = matrixPower[0].length;

        // 计算前缀和矩阵
        int[][] prefix = calculatePrefixSum(matrixPower);

        int count = 0;
        // 遍历所有可能的电站位置，检查每个 SxS 子矩阵的发电量
        for (int i = 0; i <= rows - side; i++)  {
            for (int j = 0; j <= cols - side; j++) {
                // 计算当前子矩阵的总发电量
                int totalPower = prefix[i+side][j+side]
                        - prefix[i+side][j]
                        - prefix[i][j+side]
                        + prefix[i][j];

                // 如果总发电量大于等于最低要求，则该区域有效
                if (totalPower >= minPower) {
                    count++;
                }
            }
        }

        return count;
    }


    private static int[][] calculatePrefixSum(int[][] matrix) {
        int rows = matrix.length;
        int cols = matrix[0].length;
        int[][] prefix = new int[rows + 1][cols + 1];

        for (int i = 1; i <= rows; i++) {
            for (int j = 1; j <= cols; j++) {
                prefix[i][j] = matrix[i-1][j-1]
                        + prefix[i - 1][j]
                        + prefix[i][j - 1]
                        - prefix[i - 1][j - 1];
            }
        }

        return prefix;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<p>$\text{prefix}[i][j] = \text{matrix}[i-1][j-1] + \text{prefix}[i-1][j] + \text{prefix}[i][j-1] - \text{prefix}[i-1][j-1]\dots i,j &gt; 0（减去重叠部分）$，</p>
<p>$\text{Sub-Matrix Sum} = \text{prefix}[i+k_1][j+k_2] - \text{prefix}[i][j+k_2] - \text{prefix}[i+k_1][j] + \text{prefix}[i][j];$</p>
<hr>
<h1 id="单调队列模式相关算法题">单调队列模式相关算法题<a hidden class="anchor" aria-hidden="true" href="#单调队列模式相关算法题">#</a></h1>
<h2 id="绝对差不超过限制的最长连续子数组">绝对差不超过限制的最长连续子数组<a hidden class="anchor" aria-hidden="true" href="#绝对差不超过限制的最长连续子数组">#</a></h2>

<a href="https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int longestSubarray(int[] nums, int limit) {
        // 使用双端队列来维护当前窗口的最大值和最小值的索引
        Deque&lt;Integer&gt; maxDeque = new LinkedList&lt;&gt;();
        Deque&lt;Integer&gt; minDeque = new LinkedList&lt;&gt;();

        int windowStart = 0, maxLength = 0; // 定义窗口的起始位置和最长子数组长度

        for (int windowEnd = 0; windowEnd < nums.length; windowEnd++) {
            int current = nums[windowEnd];

            // 更新最大值队列，保持降序（队首为最大值）
            while (!maxDeque.isEmpty() && nums[maxDeque.peekLast()] < current) {
                maxDeque.pollLast();
            }
            maxDeque.offerLast(windowEnd);

            // 更新最小值队列，保持升序（队首为最小值）
            while (!minDeque.isEmpty() && nums[minDeque.peekLast()] > current) {
                minDeque.pollLast();
            }
            minDeque.offerLast(windowEnd);

            // 当当前窗口的最大值和最小值之差超过给定的限制时，收缩窗口
            while (nums[maxDeque.peekFirst()] - nums[minDeque.peekFirst()] > limit) {
                windowStart++; // 移动窗口的起始位置

                // 移除超出窗口范围的元素索引
                if (maxDeque.peekFirst() < windowStart) {
                    maxDeque.pollFirst();
                }
                if (minDeque.peekFirst() < windowStart) {
                    minDeque.pollFirst();
                }
            }

            // 更新最长子数组长度
            maxLength = Math.max(maxLength, windowEnd - windowStart + 1);
        }

        return maxLength;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="购买水果需要的最少金币数">购买水果需要的最少金币数<a hidden class="anchor" aria-hidden="true" href="#购买水果需要的最少金币数">#</a></h2>

<a href="https://leetcode.cn/problems/minimum-number-of-coins-for-fruits" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int minimumCoins(int[] prices) {
        int n = prices.length;
        Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();
        
        // 扩展数组，在末尾添加一个0，表示到达数组末尾的最终成本为0
        prices = Arrays.copyOf(prices, n + 1);
        prices[n] = 0;  // 基础情况：到达数组末尾的成本为0
        deque.offerLast(n); // 初始化双端队列，末尾为最小成本的虚拟索引n

        // 从倒数第二个元素开始遍历数组，向前遍历至数组开头
        for (int i = n - 1; i >= 0; i--) {
            int maxCoveredIndex = Math.min(n, 2 * i + 2); // 计算当前水果的最大覆盖索引范围
            
            // 从双端队列头部移除超出当前水果覆盖范围的索引
            while (!deque.isEmpty() && deque.peekFirst() > maxCoveredIndex) {
                deque.pollFirst();
            }

            // 更新当前水果的成本，加上该水果可达的最小成本
            prices[i] += prices[deque.peekFirst()];

            // 维持单调递增的双端队列，移除队列尾部比当前成本大的元素
            while (!deque.isEmpty() && prices[deque.peekLast()] > prices[i]) {
                deque.pollLast();
            }
            
            // 将当前索引加入队列，以便后续计算中使用最小值
            deque.offerLast(i);
        }

        return prices[0];  // 返回从第一个物品开始的最小硬币总成本
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="不间断子数组">不间断子数组<a hidden class="anchor" aria-hidden="true" href="#不间断子数组">#</a></h2>

<a href="https://leetcode.cn/problems/continuous-subarrays" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    Deque&lt;Integer&gt; increasingQ;
    Deque&lt;Integer&gt; decreasingQ;

    public long continuousSubarrays(int[] nums) {
        increasingQ = new LinkedList&lt;&gt;();
        decreasingQ = new LinkedList&lt;&gt;();

        int start = 0;
        long result = 0;
        // 扩展窗口的终止位置
        for (int end = 0; end < nums.length; end++) {
            // 更新递增队列，确保队列从小到大有序
            while (!increasingQ.isEmpty() && increasingQ.peekLast() > nums[end]) {
                increasingQ.pollLast();
            }
            // 更新递减队列，确保队列从大到小有序
            while (!decreasingQ.isEmpty() && decreasingQ.peekLast() < nums[end]) {
                decreasingQ.pollLast();
            }

            // 将当前元素加入递增和递减队列
            increasingQ.offerLast(nums[end]);
            decreasingQ.offerLast(nums[end]);

            // 检查当前窗口是否满足最大值和最小值之差不超过2的条件
            while (getMaxInSubArray() - getMinInSubArray() > 2) {
                // 如果不满足条件，收缩窗口左边界
                if (!increasingQ.isEmpty() && increasingQ.peekFirst() == nums[start]) {
                    increasingQ.pollFirst(); // 移除递增队列的头部元素
                }
                if (!decreasingQ.isEmpty() && decreasingQ.peekFirst() == nums[start]) {
                    decreasingQ.pollFirst(); // 移除递减队列的头部元素
                }
                start++; // 收缩窗口左边界
            }

            // 增加当前窗口内满足条件的子数组数量
            result += end - start + 1;
        }

        return result;
    }

    // 获取当前窗口中的最大值
    private long getMaxInSubArray() {
        return decreasingQ.isEmpty() ? -1 : decreasingQ.peekFirst();
    }

    // 获取当前窗口中的最小值
    private long getMinInSubArray() {
        return increasingQ.isEmpty() ? -1 : increasingQ.peekFirst();
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h1 id="hashmaplistset-模式相关算法题">HashMap/List/Set 模式相关算法题<a hidden class="anchor" aria-hidden="true" href="#hashmaplistset-模式相关算法题">#</a></h1>
<h2 id="华为od机试环中最长子串100分">华为OD机试：环中最长子串【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试环中最长子串100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p><strong>题目描述</strong><br>
给定一个字符串 <code>s</code>，假设该字符串首尾相连形成一个环形，请在环形字符串中找出包含 <code>o</code> 字符出现偶数次的最长子字符串，并输出该子字符串的长度。</p>
<p><strong>输入描述</strong></p>
<p>输入为一个仅由小写字母组成的字符串 <code>s</code>。</p>
<p><strong>输出描述</strong></p>
<p>输出一个整数，表示符合条件的最长子字符串的长度。</p>
<p><strong>示例</strong></p>
<p>输入：</p>
<pre tabindex="0"><code>alolobo
</code></pre><p>输出：</p>
<pre tabindex="0"><code>6
</code></pre><p><strong>示例说明</strong></p>
<p>在输入字符串 <code>alolobo</code> 中，符合条件的最长子字符串之一是 <code>alolob</code>，它包含 <code>2</code> 个 <code>o</code> 字符，因此其长度为 <code>6</code>。</p>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

/**
 * @author Signal Yu
 * @since 2024-11-06
 */
class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取字符串
        String s = in.nextLine().trim();

        // 计算最长出现了'o'字符的最长子串长度
        int maxLength = computeMaxLength(s);

        // 输出结果
        System.out.println(maxLength);
    }

    private static int computeMaxLength(String s) {
        Map<Character, Integer> frequencyMap = new HashMap&lt;&gt;();
        // 统计字符串中各字符出现的频率
        for (char c : s.toCharArray()) {
            frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1);
        }

        // 字母'o'的频率
        int oCount = frequencyMap.getOrDefault('o', 0);

        if (oCount % 2 == 0) { // 字母'o'的长度为偶数，直接返回字符串的长度
            return s.length();
        } else { // 字母'o'的长度为奇数，返回字符串的长度减1
            return s.length() - 1;
        }
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="字符串中的第一个唯一字符">字符串中的第一个唯一字符<a hidden class="anchor" aria-hidden="true" href="#字符串中的第一个唯一字符">#</a></h2>

<a href="https://leetcode.cn/problems/first-unique-character-in-a-string" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int firstUniqChar(String s) {
        Map&lt;Character, Integer&gt; frequencyMap = new HashMap&lt;&gt;();

        // 统计字符串中的字母频率
        for (char c : s.toCharArray()) {
            frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1);
        }

        // 查找第一个只出现一次的字符，并返回其索引
        for (int i = 0; i < s.length(); i++) {
            if (frequencyMap.get(s.charAt(i)) == 1) {
                return i;
            }
        }

        // 若无唯一字符，返回 -1
        return -1;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="气球-的最大数量">“气球” 的最大数量<a hidden class="anchor" aria-hidden="true" href="#气球-的最大数量">#</a></h2>

<a href="https://leetcode.cn/problems/maximum-number-of-balloons" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int maxNumberOfBalloons(String text) {
        // 定义 balloon 中字符所需的频率，其中 'l' 和 'o' 的需求为 2
        Map&lt;Character, Integer&gt; requiredCharMap = Map.of(
                'b', 1,
                'a', 1,
                'l', 2,
                'o', 2,
                'n', 1);
        // 统计 text 中与 balloon 相关字符的出现次数
        Map&lt;Character, Integer&gt; availableCharMap = new HashMap&lt;&gt;();
        for (char c : text.toCharArray()) {
            if (requiredCharMap.containsKey(c)) {
                availableCharMap.put(c, availableCharMap.getOrDefault(c, 0) + 1);
            }
        }
        
        // 计算可以拼成 "balloon" 的最大次数
        int maxCount = Integer.MAX_VALUE;
        if (availableCharMap.size() == requiredCharMap.size()) {
            for (char c : availableCharMap.keySet()) {
                int requiredCount = requiredCharMap.get(c);
                int availableCount = availableCharMap.get(c);
                maxCount = Math.min(maxCount, availableCount / requiredCount);
            }
        }

        return (maxCount == Integer.MAX_VALUE) ? 0 : maxCount;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="最长回文串">最长回文串<a hidden class="anchor" aria-hidden="true" href="#最长回文串">#</a></h2>

<a href="https://leetcode.cn/problems/longest-palindrome" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int longestPalindrome(String s) {
        // 统计每个字符的出现频率
        Map&lt;Character, Integer&gt; frequencyMap = new HashMap&lt;&gt;();
        for (char c : s.toCharArray()) {
            frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1);
        }

        int maxLength = 0;
        boolean oddFound = false; // 用于检测是否有频率为奇数的字符

        // 计算最长的回文长度
        for (int count : frequencyMap.values()) {
            if (count % 2 == 0) {
                maxLength += count; // 如果频率为偶数，直接加入到长度
            } else {
                maxLength += count - 1; // 对于奇数频率，加入最大偶数部分
                oddFound = true; // 标记存在奇数频率字符
            }
        }

        // 如果存在奇数频率字符，可将其中一个放在回文中心
        return oddFound ? maxLength + 1 : maxLength;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="赎金信">赎金信<a hidden class="anchor" aria-hidden="true" href="#赎金信">#</a></h2>

<a href="https://leetcode.cn/problems/ransom-note" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        // 若 ransomNote 比 magazine 长，则直接返回 false
        if (ransomNote.length() > magazine.length()) {
            return false;
        }

        // 用数组统计 magazine 中每个字母的出现频率
        int[] charCount = new int[26];
        for (char c : magazine.toCharArray()) {
            charCount[c - 'a']++;
        }

        // 检查 ransomNote 中每个字母的需求是否可以在 magazine 中满足
        for (char c : ransomNote.toCharArray()) {
            if (charCount[c - 'a'] == 0) {
                return false;
            }
            charCount[c - 'a']--;
        }

        return true;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="华为od机试数组去重和排序100分">华为OD机试：数组去重和排序【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试数组去重和排序100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p>一、题目描述<br>
给定一个乱序的数组，删除所有重复元素，使得每个元素只出现一次，并按照出现次数从高到低进行排序。对于出现次数相同的元素，按照它们第一次出现的顺序进行排序。</p>
<p>二、输入描述<br>
输入为一个数组，元素之间用逗号分隔。</p>
<p>三、输出描述<br>
输出去重并排序后的数组，元素之间用逗号分隔。</p>
<p><strong>输入示例</strong></p>
<pre tabindex="0"><code>1,3,3,3,2,4,4,4,5
</code></pre><p><strong>输出示例</strong></p>
<pre tabindex="0"><code>3,4,1,2,5
</code></pre><p><strong>备注</strong></p>
<ul>
<li>数组大小不超过100。</li>
<li>数组元素的值不超过100。</li>
</ul>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

/**
 * @author Signal Yu
 * @since 2024-10-28
 */
class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取输入数组
        int[] nums = Arrays.stream(in.nextLine().split(","))
                .map(String::trim)
                .mapToInt(Integer::parseInt)
                .toArray();

        // 去重并排序
        int[] result = removeDuplicatesAndSort(nums);

        // 输出结果
        formatOutput(result);
    }

    private static void formatOutput(int[] nums) {
        StringBuilder sb = new StringBuilder();
        for (int num : nums) {
            sb.append(num).append(",");
        }
        sb.setLength(sb.length() - 1);
        System.out.println(sb);
    }

    private static int[] removeDuplicatesAndSort(int[] nums) {
        Map&lt;Integer, Integer&gt; frequencyMap = new HashMap&lt;&gt;();
        List&lt;Integer&gt; orderList = new ArrayList&lt;&gt;();

        // 统计数字出现次数
        for (int num : nums) {
            if (!frequencyMap.containsKey(num)) {
                // 第一次出现，记录在顺序表中
                orderList.add(num);
            }
            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);
        }

        // 根据出现次数进行排序处理
        orderList.sort((a, b) -> frequencyMap.get(b).compareTo(frequencyMap.get(a)));

        return orderList.stream().mapToInt(Integer::intValue).toArray();
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="华为od机试垃圾信息拦截100分">华为OD机试：垃圾信息拦截【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试垃圾信息拦截100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p>一、题目描述<br>
大众对垃圾短信深恶痛绝，希望能识别垃圾短信发送者。经过分析，发现正常用户的短信通常具备交互性，而垃圾短信往往是大量单向的短信。根据如下规则进行垃圾短信识别：<br>
发送者 A 如果符合以下任一条件，则认为 A 是垃圾短信发送者：<br>
① A 发送短信的接收者中，没有向 A 发送过短信的人数 $L &gt; 5$；<br>
② $A 发送的短信数 - A 接收的短信数 M &gt; 10$；<br>
③ 存在接收者 $X$，使得 $A 发送给 X 的短信数 - A 接收到 X 的短信数 N &gt; 5$。</p>
<p>二、输入描述<br>
第一行为条目数目，接下来的几行是具体的条目。每个条目是一个发送者 ID 和一个接收者 ID，之间用空格隔开。所有 ID 为无符号整型，最大值为 100；同一条目中两个 ID 不会相同（即不会自己给自己发消息）。最后一行为指定的 ID。</p>
<p>三、输出描述<br>
输出结果为字符串。<br>
首先输出该 ID 是否为垃圾短信发送者（是则输出 true，否则输出 false），并按序列输出 L 和 M 的值（N 值不需要输出）。</p>
<p><strong>示例</strong></p>
<ol>
<li>输入</li>
</ol>
<pre tabindex="0"><code>8
1 2
1 3
1 4
1 5
1 6
6 1
5 2
6 3
1
</code></pre><ol start="2">
<li>输出</li>
</ol>
<pre tabindex="0"><code>false 4 1
</code></pre><ol start="3">
<li>说明</li>
</ol>
<ul>
<li>输出该 ID 是否为垃圾短信发送者（是则输出 true，否则输出 false），并按序列输出 L 和 M 的值；</li>
<li>L 为没有向 A 发过短信的人数，M 为 A 接收的短信数。</li>
<li>在示例中，A 接收的短信数 M 为 1，而没有向 A 发过短信的人数 L 为 4。</li>
</ul>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

/**
 * @author Signal Yu
 * @since 2024-11-11
 */
class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取条目数 n
        int n = Integer.parseInt(in.nextLine().trim());

        // 构建发送者到接收者的映射关系
        Map&lt;Integer, List&lt;Integer&gt;> senderToReceiverMap = new HashMap&lt;&gt;();
        for (int i = 0; i < n; i++) {
            String[] parts = in.nextLine().trim().split(" ");
            int sender = Integer.parseInt(parts[0]);
            int receiver = Integer.parseInt(parts[1]);

            // 添加接收者到对应发送者的列表中
            senderToReceiverMap.putIfAbsent(sender, new ArrayList&lt;&gt;());
            senderToReceiverMap.get(sender).add(receiver);
        }

        // 读取指定的用户 ID A
        int A = Integer.parseInt(in.nextLine().trim());
        in.close();

        // 判断指定用户是否为垃圾短信发送者并
        String result = isSpamSender(A, senderToReceiverMap);

        // 输出结果
        System.out.println(result);
    }

    /**
     * 判断指定用户是否为垃圾短信发送者，并返回结果字符串。
     *
     * @param A                  指定的用户 ID
     * @param senderToReceiverMap 发送者到接收者的映射关系
     * @return 返回 "true L M" 或 "false L M"，其中 L 和 M 为判定依据的参数值
     */
    public static String isSpamSender(int A, Map&lt;Integer, List&lt;Integer&gt;> senderToReceiverMap) {
        List&lt;Integer&gt; sendByAList = senderToReceiverMap.getOrDefault(A, Collections.emptyList());

        /*
            L: 没有回复 A 的接收者人数
            M: 给 A 发送过短信的接收者人数
            X: A 发送给用户 X 的短信数
            N: A 接受到用户 X 的短信数
         */
        int L = 0, M = 0;
        boolean flag = false; // 标记条件③是否满足

        for (int receiver : sendByAList) {
            List&lt;Integer&gt; sendToAList = senderToReceiverMap.getOrDefault(receiver, Collections.emptyList());

            if (!sendToAList.contains(A)) {
                L++; // 接收者未给 A 回复，增加 L
            } else {
                M++; // 接收者给 A 回复过，增加 M

                if (!flag) {
                    // 判断条件③：A 发给接收者的次数减去接收者回复 A 的次数 > 5
                    int X = Collections.frequency(sendByAList, receiver);
                    int N = Collections.frequency(sendToAList, A);
                    flag = X - N > 5;
                }
            }
        }

        // 根据条件判定是否为垃圾短信发送者
        boolean isSpam = L > 5 || (sendByAList.size() - M) > 10 || flag;
        return String.format("%s %d %d", isSpam, L, M);
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="华为od机试最大n个数与最小n个数的和100分">华为OD机试：最大N个数与最小N个数的和【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试最大n个数与最小n个数的和100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p><strong>题目描述</strong></p>
<p>给定一个整数数组，请编写一个函数来计算该数组中最大N个数与最小N个数的和，要求对数组中的数字进行去重处理。</p>
<ul>
<li>数组中的数字范围为 $[0, 1000]$。</li>
<li>最大 $N$ 个数与最小 $N$ 个数不能有重叠，如果存在重叠或输入不合法，返回 -1。</li>
</ul>
<p><strong>输入描述</strong></p>
<ul>
<li>第一行输入整数 M，表示数组的大小。</li>
<li>第二行输入 M 个整数，表示数组的内容，元素之间以空格分隔。</li>
<li>第三行输入整数 N，表示需要计算的最大和最小的 N 个数的数量。</li>
</ul>
<p><strong>输出描述</strong></p>
<p>输出最大N个数与最小N个数的和。如果输入不合法，输出 -1。</p>
<p><strong>测试用例</strong></p>
<p><strong>输入</strong>：</p>
<pre tabindex="0"><code>7
47 17 26 9 18 47 52
3
</code></pre><p><strong>期望输出</strong>：</p>
<pre tabindex="0"><code>169
</code></pre><p><strong>说明</strong>：去重后数组为 [9, 17, 18, 26, 47, 52]，最大 3 个数为 26 + 47 + 52 = 125，最小 3 个数为 9 + 17 + 18 = 44。</p>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

/**
 * @author Signal Yu
 * @since 2024-11-12
 */
class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取
        int m = Integer.parseInt(in.nextLine().trim());
        int[] nums = Arrays.stream(in.nextLine().trim().split(" "))
                .mapToInt(Integer::parseInt)
                .toArray();
        int n = Integer.parseInt(in.nextLine().trim());

        int result = getSum(nums, n);

        // 输出结果
        System.out.println(result);
    }

    /**
     * 计算最大N个数与最小N个数的和
     *
     * @param nums 输入的数组
     * @param n    最大、最小N个数
     * @return 最大N个数与最小N个数之和，若输入非法返回-1
     */
    private static int getSum(int[] nums, int n) {
        // 使用TreeSet去重并排序
        TreeSet&lt;Integer&gt; sortedSet = new TreeSet&lt;&gt;();
        for (int num : nums) {
            sortedSet.add(num);
        }

        // 检查是否有足够的元素来获取最大和最小的N个数
        if (sortedSet.size() < 2 * n) {
            return -1;
        }

        // 计算最小N个数的和
        int minSum = 0;
        Iterator<Integer> ascIterator = sortedSet.iterator();
        for (int i = 0; i < n; i++) {
            minSum += ascIterator.next();
        }

        // 计算最大N个数的和
        int maxSum = 0;
        Iterator<Integer> descIterator = sortedSet.descendingIterator();
        for (int i = 0; i < n; i++) {
            maxSum += descIterator.next();
        }

        return minSum + maxSum;

          // 计算最小N个数的和
//        int totalSum = 0;
//        for (int i = 0; i < n; i++) {
//            totalSum += sortedSet.pollFirst();
//            totalSum += sortedSet.pollLast();
//        }
//        return totalSum;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="华为od机试全量和已占用字符集100分">华为OD机试：全量和已占用字符集【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试全量和已占用字符集100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p>一、题目描述<br>
给定两个字符集，一个是全量字符集，一个是已占用字符集。已占用字符集中的字符不能再使用，要求输出剩余可用字符集。</p>
<p>二、输入描述</p>
<ol>
<li>输入一个字符串，必定包含<code>@</code>，<code>@</code>前为全量字符集，<code>@</code>后的为已占用字符集。</li>
<li>已占用字符集中的字符必定是全量字符集中的字符，字符集中的字符之间使用英文逗号隔开。</li>
<li>每个字符表示为字符加数字的形式，用英文冒号分隔，比如 <code>a:1</code> 表示1个<code>a</code>字符。</li>
<li>字符只考虑英文字母，区分大小写，数字只考虑正整数，不超过100。</li>
<li>如果没有字符被占用，<code>@</code>仍需存在，例如 <code>a:3,b:5,c:2@</code>。</li>
</ol>
<p>三、输出描述<br>
输出可用字符集，不同的字符集之间用回车换行。<br>
注意：输出的字符顺序要与输入一致，不能输出<code>b:3,a:2,c:2</code>。如果某个字符已全部占用，则不需再输出。</p>
<p>示例</p>
<ol>
<li>输入</li>
</ol>
<pre tabindex="0"><code>a:3,b:5,c:2@a:1,b:2
</code></pre><ol start="2">
<li>输出</li>
</ol>
<pre tabindex="0"><code>a:2,b:3,c:2
</code></pre><ol start="3">
<li>说明<br>
全量字符集为 <code>3a+5b+2c</code>，已占用字符集为 <code>1a+2b</code>。可用字符集 = 全部字符集 - 已占用字符集 = <code>2a+3b+2c</code>。</li>
</ol>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

/**
 * @author Signal Yu
 * @since 2024-11-12
 */
class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取输入字符串
        String input = in.nextLine().trim();

        // 分割全量字符串和已占用字符串
        String[] parts = input.split("@");
        String[] fullSet = parts[0].split(",");
        String[] usedSet = parts[1].isEmpty() ?  new String[0] : parts[1].split(",");

        // 解析全量字符串
        Map&lt;String, Integer&gt; fullCharMap = parseCharacterSet(fullSet);
        // 解析已占用字符串
        Map&lt;String, Integer&gt; usedCharMap = parseCharacterSet(usedSet);

        // 计算可用字符集
        Map&lt;String, Integer&gt; availableCharMap = calculateAvailableMap(fullCharMap, usedCharMap);


        // 格式化输出可用字符集
        String result = formatOutput(availableCharMap);

        // 输出结果
        System.out.println(result);
    }

    /**
     * 格式化输出字符集，格式为 "字符:数量" 形式，元素之间用逗号分隔
     */
    private static String formatOutput(Map&lt;String, Integer&gt; availableCharMap) {
        StringBuilder result = new StringBuilder();
        availableCharMap.forEach((key, value) ->
                result.append(key).append(":").append(value).append(","));
        // 去掉最后一个多余的逗号
        if (!result.isEmpty()) {
            result.setLength(result.length() - 1);
        }
        return result.toString();
    }

    /**
     * 计算可用字符集，即从全量字符集中扣除已占用字符数，返回剩余可用字符集
     */
    private static Map&lt;String, Integer&gt; calculateAvailableMap(Map&lt;String, Integer&gt; fullCharMap, Map&lt;String, Integer&gt; usedCharMap) {
        Map&lt;String, Integer&gt; availableCharMap = new LinkedHashMap&lt;&gt;();
        fullCharMap.forEach((charKey, fullCount) -> {
            int availableCount = fullCount - usedCharMap.getOrDefault(charKey, 0);
            if (availableCount > 0) {
                availableCharMap.put(charKey, availableCount);
            }
        });
        return availableCharMap;
    }

    /**
     * 解析字符集字符串数组（如 "A:5"）为 Map，每个字符及其对应数量
     */
    private static Map&lt;String, Integer&gt; parseCharacterSet(String[] charSet) {
        Map&lt;String, Integer&gt; charSetMap = new LinkedHashMap&lt;&gt;();

        for (String item : charSet) {
            String[] parts = item.split(":");
            if (parts.length == 2) {
                String charKey = parts[0];
                int charCount = Integer.parseInt(parts[1]);
                charSetMap.put(charKey, charCount);
            }
        }

        return charSetMap;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="华为od机试告警抑制100分">华为OD机试：告警抑制【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试告警抑制100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p><strong>一、题目描述</strong></p>
<p>在告警系统中，高优先级的告警可以抑制低优先级的告警。当一个高优先级告警发生后，与之有抑制关系的低优先级告警将不再触发。请根据给定的告警抑制关系和告警产生列表，计算出最终实际产生的告警列表。</p>
<ul>
<li><strong>抑制规则</strong>：当某告警A抑制告警B时，若A触发，B将被抑制，反之不然。</li>
<li><strong>不传递抑制</strong>：如果A抑制B且B抑制C，A不会直接抑制C。</li>
<li><strong>无循环抑制</strong>：保证抑制关系中不存在循环。</li>
</ul>
<p><strong>二、输入描述</strong></p>
<ul>
<li>第一行输入一个整数N，表示告警抑制关系的数量，0 &lt;= N &lt;= 120。</li>
<li>接下来N行，每行包含两个告警ID，由空格分隔，格式为 <code>id1 id2</code>，表示 <code>id1</code> 抑制 <code>id2</code>。告警ID由一个大写字母和可选的一个数字组成。</li>
<li>最后一行输入告警产生列表，表示实际发生的告警ID序列，长度为 1 ～ 100。</li>
</ul>
<p><strong>三、输出描述</strong></p>
<p>输出实际产生的告警列表，按照输入顺序去除被抑制的告警。</p>
<p><strong>四、示例</strong></p>
<p><strong>输入示例</strong></p>
<pre tabindex="0"><code>3
A C
B D
A B
A B C D E
</code></pre><p><strong>输出示例</strong></p>
<pre tabindex="0"><code>A E
</code></pre><p><strong>示例说明</strong></p>
<ul>
<li>A抑制C；</li>
<li>B抑制D；</li>
<li>A抑制B；
因此，最终的实际产生告警列表为 <code>A E</code>。</li>
</ul>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

/**
 * @author Signal Yu
 * @since 2024-11-12
 */
class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取告警抑制关系的数量
        int n = Integer.parseInt(in.nextLine().trim());

        // 读取抑制关系并构建映射表
        Map&lt;String, List&lt;String&gt;> suppressionMap = new HashMap&lt;&gt;();
        for (int i = 0; i < n; i++) {
            String[] parts = in.nextLine().trim().split(" ");
            String highPriority = parts[0];
            String lowPriority = parts[1];
            suppressionMap.putIfAbsent(highPriority, new ArrayList&lt;&gt;());
            suppressionMap.get(highPriority).add(lowPriority);
        }

        // 读取告警产生列表
        List&lt;String&gt; warningList = new ArrayList&lt;&gt;(Arrays.asList(in.nextLine().trim().split(" ")));

        in.close();

        // 获取实际产生的告警列表
        String result = getActualWarningList(suppressionMap, warningList);

        // 输出最终告警列表
        System.out.println(result);
    }

    /**
     * 根据告警抑制关系，计算最终的实际告警列表
     *
     * @param suppressionMap 抑制关系映射，key表示高优先级告警，value表示被其抑制的低优先级告警列表
     * @param warningList    初始告警产生列表
     * @return 实际产生的告警列表字符串
     */
    private static String getActualWarningList(Map&lt;String, List&lt;String&gt;> suppressionMap, List&lt;String&gt; warningList) {
        Set&lt;String&gt; suppressedWarnings = new HashSet&lt;&gt;();

        // 遍历告警抑制关系，标记被抑制的告警
        for (String highPriority : suppressionMap.keySet()) {
            suppressedWarnings.addAll(suppressionMap.get(highPriority));
        }

        // 过滤掉被抑制的告警，保留未被抑制的告警
        warningList.removeAll(suppressedWarnings);

        // 格式化输出最终告警列表
        return String.join(" ", warningList);
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="华为od机试报文回路100分">华为OD机试：报文回路【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试报文回路100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p><strong>一、题目描述</strong>
在 IGMP 协议中，响应报文和查询报文是维持组播通路的重要机制。在一条已建立的组播通路中，两个相邻的主机（host）和路由器（router）之间会通过这两类报文进行通信。路由器定期向主机发送查询报文，主机在接收到查询后，向路由器发送响应报文以维持连接关系。一旦这种关系断裂，组播通路就会出现异常。</p>
<p>现已通过抓包工具截获了所有 host 与 router 之间的查询和响应报文。请根据这些报文分析该组播通路是否正常。</p>
<p><strong>二、输入描述</strong></p>
<ul>
<li>第一行输入一个整数 <code>C</code>，表示抓到的报文数量（<code>C &lt;= 100</code>）。</li>
<li>接下来的 <code>C</code> 行，每行包含两个用空格隔开的整数 <code>D1</code> 和 <code>D2</code>，表示一个从设备节点 <code>D1</code> 到设备节点 <code>D2</code> 的单向报文。</li>
</ul>
<p><strong>三、输出描述</strong></p>
<p>输出组播通路的状态。若通路正常，输出 <code>true</code>；若异常，输出 <code>false</code>。</p>
<p><strong>示例</strong></p>
<ul>
<li><strong>输入</strong>：
<pre tabindex="0"><code>5
1 2
2 3
3 2
1 2
2 1
</code></pre></li>
<li><strong>输出</strong>：
<pre tabindex="0"><code>true
</code></pre></li>
</ul>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

/**
 * @author Signal Yu
 * @since 2024-11-13
 */
class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取抓到的报文数量
        int c = Integer.parseInt(in.nextLine().trim());

        // 构建报文发送关系映射：key为发送设备，value为接收设备的集合
        Map&lt;Integer, Set&lt;Integer&gt;&gt; communicationMap = new HashMap&lt;&gt;();
        for (int i = 0; i < c; i++) {
            String[] parts = in.nextLine().trim().split(" ");
            int sender = Integer.parseInt(parts[0]);
            int receiver = Integer.parseInt(parts[1]);

            communicationMap
                    .computeIfAbsent(sender, k -> new HashSet&lt;&gt;())
                    .add(receiver);
//            communicationMap.putIfAbsent(sender, new HashSet&lt;&gt;());
//            communicationMap.get(sender).add(receiver);
        }

        // 判断组播通路的状态
        boolean isPathNormal = checkBidirectionalConnections(communicationMap);

        // 输出结果
        System.out.println(isPathNormal);
    }

    /**
     * 检查所有报文对是否满足双向性要求。
     *
     * @param communicationMap 设备之间的报文传输关系映射
     * @return true如果所有报文对双向连接正常；否则返回false
     */
    private static boolean checkBidirectionalConnections(Map&lt;Integer, Set&lt;Integer&gt;&gt; communicationMap) {
        for (Map.Entry&lt;Integer, Set&lt;Integer&gt;&gt; entry : communicationMap.entrySet()) {
            Integer sender = entry.getKey();
            Set<Integer> receivers = entry.getValue();

            // 检查每个接收设备是否具有相应的反向报文
            for (Integer receiver : receivers) {
                if (!communicationMap.containsKey(receiver) || !communicationMap.get(receiver).contains(sender)) {
                    return false; // 发现单向连接，返回异常状态
                }
            }
        }
        return true; // 所有连接均双向，返回正常状态
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="华为od机试异常的打卡记录100分">华为OD机试：异常的打卡记录【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试异常的打卡记录100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p><strong>一、题目描述</strong>
考勤记录用于分析和考核员工的工作时间利用情况，也是计算工资的依据。为了确保考勤数据的准确性，公司决定对员工的打卡记录进行异常排查。</p>
<p>判断打卡异常的条件如下：</p>
<ol>
<li>实际设备号与员工的注册设备号不一致；</li>
<li>同一员工的两个打卡记录时间间隔小于60分钟，且打卡地点间距超过5公里。</li>
</ol>
<p>给定打卡记录的字符串数组 <code>clockRecord</code>，每条记录格式为：<code>工号,时间（分钟）,打卡距离（公里）,实际设备号,注册设备号</code>。请返回其中所有异常的打卡记录，按输入顺序输出。</p>
<p><strong>二、输入描述</strong></p>
<ul>
<li>第一行输入为整数 <code>N</code>，表示打卡记录的总数；</li>
<li>接下来的 <code>N</code> 行分别是每条打卡记录，每行包含如下信息：
<ul>
<li><code>工号</code>，<code>时间（分钟）</code>，<code>打卡距离（公里）</code>，<code>实际设备号</code>，<code>注册设备号</code></li>
</ul>
</li>
</ul>
<p><strong>三、输出描述</strong></p>
<ul>
<li>按输入顺序输出所有异常的打卡记录，每条记录之间用分号隔开。</li>
</ul>
<p><strong>示例</strong></p>
<p><strong>输入</strong></p>
<pre tabindex="0"><code>6
1,10,1,100,100
1,80,10,100,100
1,120,16,100,100
2,80,10,200,200
2,150,15,200,200
3,150,15,200,300
</code></pre><p><strong>输出</strong></p>
<pre tabindex="0"><code>1,80,10,100,100;1,120,16,100,100;3,150,15,200,300
</code></pre>
</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

/**
 * @author Signal Yu
 * @since 2024-11-13
 */
class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取打卡记录数量
        int n = Integer.parseInt(in.nextLine().trim());

        // 读取打卡记录并构建映射表
        Map&lt;String, List&lt;ClockRecord&gt;> recordMap = new HashMap&lt;&gt;();
        for (int i = 0; i < n; i++) {
            String recordStr = in.nextLine().trim();
            String[] parts = recordStr.split(",");
            String id = parts[0];
            int time = Integer.parseInt(parts[1]);
            double distance = Double.parseDouble(parts[2]);
            String actualDeviceNo = parts[3];
            String registeredDeviceNo = parts[4];

            ClockRecord record = new ClockRecord(id, time, distance, actualDeviceNo, registeredDeviceNo, recordStr);
            recordMap.computeIfAbsent(id, k -> new ArrayList&lt;&gt;())
                    .add(record);
        }

        // 检查异常记录
        String abnormalClockRecords = checkAbnormalRecords(recordMap);

        // 输出结果
        System.out.println(abnormalClockRecords);
    }

    /**
     * 检查所有打卡记录，识别异常记录
     * @param recordMap 每位员工的打卡记录映射表
     * @return 异常记录字符串，以分号隔开
     */
    private static String checkAbnormalRecords(Map&lt;String, List&lt;ClockRecord&gt;> recordMap) {
        Set&lt;String&gt; anomalies = new LinkedHashSet&lt;&gt;();

        // 遍历每个员工的打卡记录
        for (Map.Entry&lt;String, List&lt;ClockRecord&gt;> entry : recordMap.entrySet()) {
            List&lt;ClockRecord&gt; records = entry.getValue();

            // 对于同一员工的每一条打卡记录，检查设备号一致性和时间间隔与距离条件
            for (int i = 0; i < records.size(); i++) {
                ClockRecord record = records.get(i);

                // 条件1：检查设备号是否一致
                if (!record.actualDeviceNo.equals(record.registeredDeviceNo)) {
                    anomalies.add(record.originalRecord);
                    continue;
                }

                // 条件2：检查时间间隔和距离
                for (int j = i + 1; j < records.size(); j++) {
                    ClockRecord otherRecord = records.get(j);
                    int timeDiff = Math.abs(record.time - otherRecord.time);
                    double distanceDiff = Math.abs(record.distance - otherRecord.distance);

                    // 若满足条件2，记录异常打卡记录
                    if (timeDiff < 60 && distanceDiff > 5) {
                        anomalies.add(record.originalRecord);
                        anomalies.add(otherRecord.originalRecord);
                        break; // 已识别异常，跳过进一步的比较
                    }
                }
            }
        }

        // 返回按输入顺序排列的异常记录，用分号分隔
        return String.join(";", anomalies);
    }
}

/**
 * 员工打卡记录类
 */
class ClockRecord {
    String id;                  // 员工工号
    int time;                   // 打卡时间（分钟）
    double distance;            // 打卡距离（公里）
    String actualDeviceNo;      // 实际设备号
    String registeredDeviceNo;  // 注册设备号
    String originalRecord;      // 原始打卡记录字符串

    public ClockRecord(String id, int time, double distance, String actualDeviceNo, String registeredDeviceNo, String originalRecord) {
        this.id = id;
        this.time = time;
        this.distance = distance;
        this.actualDeviceNo = actualDeviceNo;
        this.registeredDeviceNo = registeredDeviceNo;
        this.originalRecord = originalRecord;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h1 id="贪心算法模式相关算法题">贪心算法模式相关算法题<a hidden class="anchor" aria-hidden="true" href="#贪心算法模式相关算法题">#</a></h1>
<h2 id="救生艇">救生艇<a hidden class="anchor" aria-hidden="true" href="#救生艇">#</a></h2>

<a href="https://leetcode.cn/problems/boats-to-save-people" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int numRescueBoats(int[] people, int limit) {
        // 对体重数组进行升序排序
        Arrays.sort(people);

        int left = 0, right = people.length - 1;
        int minBoatCount = 0; // 记录所需最小的船的数量
        while (left <= right) {            
            if (left == right) {
                minBoatCount++;
                break;
            }
            
            // if (people[left] + people[right] <= limit) {
            //     left++;
            //     right--;
            //     minBoatCount++;
            // } else {
            //     right--;
            //     minBoatCount++;    
            // }

            // 最轻和最重的两人可以共用一艘船
            if (people[left] + people[right] <= limit) {
                left++;
            } 
            right--; // 无论是否共用，右指针都左移，表示最重者已被安排
            minBoatCount++;
        }

        return minBoatCount;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="华为od机试租车骑绿道100分-1">华为OD机试：租车骑绿道【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试租车骑绿道100分-1">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p><strong>一、题目描述</strong></p>
<p>部门组织团建活动，安排绿道骑行，需要租用双人自行车。每辆自行车最多可容纳两人，且载重上限为 <code>m</code>。给出部门中每个人的体重，求最少需要租用多少辆双人自行车。</p>
<p><strong>二、输入描述</strong></p>
<ul>
<li>第一行包含两个整数 <code>m</code> 和 <code>n</code>，其中 <code>m</code> 表示每辆自行车的最大载重，<code>n</code> 表示部门的总人数。</li>
<li>第二行包含 <code>n</code> 个整数，表示每个人的体重（每个人的体重不超过自行车的载重限制 <code>m</code>）。</li>
</ul>
<p>输入数据满足以下条件：</p>
<ul>
<li><code>0 &lt; m &lt;= 200</code></li>
<li><code>0 &lt; n &lt;= 1,000,000</code></li>
</ul>
<p><strong>三、输出描述</strong></p>
<p>输出最少需要的双人自行车数量。</p>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

/**
 * @author Signal Yu
 * @since 2024-11-03
 */
class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取自行车限重与人数
        int[] parts = Arrays.stream(in.nextLine().trim().split(" "))
                .mapToInt(Integer::parseInt)
                .toArray();
        int m = parts[0];
        // 读取体重数据
        int[] weights = Arrays.stream(in.nextLine().trim().split(" "))
                .mapToInt(Integer::parseInt)
                .toArray();

        // 计算所需最少双人自行车数量
        int result = computeMinimumBicycles(weights, m);

        // 输出结果
        System.out.println(result);
    }

    private static int computeMinimumBicycles(int[] weights, int maxWeight) {
        // 对数组进行排序，便于使用双指针模式
        Arrays.sort(weights);

        // 初始化双指针
        int left = 0, right = weights.length - 1;
        int bicycleCount = 0;

//        while (left <= right) {
//            // 最轻和最重的人可以共用一辆车
//            if (weights[left] + weights[right] <= maxWeight) {
//                left++;  // 左指针右移
//                right--;
//                bicycleCount++;
//            } else { // 不能公用自行车
//                right--;  // 右指针左移
//                bicycleCount++;
//            }
//        }

        while (left <= right) {
            // 最轻和最重的人可以共用一辆车
            if (weights[left] + weights[right] <= maxWeight) {
                left++;  // 左指针右移
            }
            right--;  // 右指针左移
            bicycleCount++;
        }

        return bicycleCount;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="验证回文串-ii">验证回文串 II<a hidden class="anchor" aria-hidden="true" href="#验证回文串-ii">#</a></h2>

<a href="https://leetcode.cn/problems/valid-palindrome-ii" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public boolean validPalindrome(String s) {
        int left = 0, right = s.length() - 1;

        // 遍历字符串，左右指针逐步收缩
        while (left < right) {
            // 如果左右字符不相等，尝试跳过一次字符判断是否为回文
            if (s.charAt(left) != s.charAt(right)) {
                // 若去掉左边或右边的一个字符后形成回文，则返回true
                return isPalindrome(s, left + 1, right) || isPalindrome(s, left, right - 1);
            }
            left++;
            right--;
        }

        // 若没有出现不相等字符，原字符串已是回文
        return true;
    }

    // 辅助函数：判断子字符串是否为回文
    private static boolean isPalindrome(String s, int left, int right) {
        while (left < right) {
            if (s.charAt(left) != s.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }

        return true;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="最长数对链">最长数对链<a hidden class="anchor" aria-hidden="true" href="#最长数对链">#</a></h2>

<a href="https://leetcode.cn/problems/maximum-length-of-pair-chain" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int findLongestChain(int[][] pairs) {
         // 按照每个数对的第二个元素升序排序
        Arrays.sort(pairs, (a, b) -> a[1] - b[1]);

        int chainCount = 0; // 记录最长数对链的长度
        int currentEnd = Integer.MIN_VALUE; // 当前数对链的末尾数对的第二个元素
        for (int[] pair : pairs) {
            // 若当前数对的起始元素大于当前链的末尾元素，说明可以将该数对加入链中
            if (pair[0] > currentEnd) {
                currentEnd = pair[1]; // 更新链的末尾元素
                chainCount++; // 增加数对链的长度
            }
        }

        return chainCount; // 返回最长数对链
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="使括号有效的最少添加">使括号有效的最少添加<a hidden class="anchor" aria-hidden="true" href="#使括号有效的最少添加">#</a></h2>

<a href="https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int minAddToMakeValid(String s) {
        int openNeeded = 0;  // 记录需要补充的左括号数量
        int closeNeeded = 0; // 记录需要补充的右括号数量量

        for (char c : s.toCharArray()) {
            // 遇到左括号，所需右括号加 1；遇到右括号则减 1
            closeNeeded += c == '(' ? 1 : -1;
            // closeNeeded 为负值表明该右括号多余，需要一个左括号进行匹配
            if (closeNeeded == -1) {
                openNeeded++; // 左括号数量加 1
                closeNeeded++; // 增加左括号数量后，多余的右括号数量减 1
            }
        }

        return openNeeded + closeNeeded; // 返回至少需要的括号总数
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="去除重复字母">去除重复字母<a hidden class="anchor" aria-hidden="true" href="#去除重复字母">#</a></h2>

<a href="https://leetcode.cn/problems/remove-duplicate-letters" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public String removeDuplicateLetters(String s) {
        Map&lt;Character, Integer&gt; frequencyMap = new HashMap&lt;&gt;();
        // 统计每个字符的出现频率
        for (char c : s.toCharArray()) {
            frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1);
        }

        Stack&lt;Character&gt; charStack = new Stack&lt;&gt;(); // 维护结果字符的栈
        Set&lt;Character&gt; charSet = new HashSet&lt;&gt;(); // 记录栈中已包含的字符

        for (char c : s.toCharArray()) {
            if (!charSet.contains(c)) {
                // 移除栈中比当前字符字典序大的字符，确保字典序最小
                // 栈顶元素频率不为0表明还存在未被遍历相同元素
                while (!charStack.isEmpty() && frequencyMap.get(charStack.peek()) > 0 && charStack.peek() > c) {
                    charSet.remove(charStack.pop());
                }
                charStack.push(c); // 将当前字符加入栈中
                charSet.add(c); // 将当前字符标记为已加入栈
            }
            // 更新当前字符的剩余出现次数
            frequencyMap.put(c, frequencyMap.get(c) - 1); 
        }

        // 构建结果字符串
        StringBuilder builder = new StringBuilder();
        for (char c : charStack) {
            builder.append(c);
        }

        return builder.toString();
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="最大回文数字">最大回文数字<a hidden class="anchor" aria-hidden="true" href="#最大回文数字">#</a></h2>

<a href="https://leetcode.cn/problems/largest-palindromic-number" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public String largestPalindromic(String num) {
        // 存储回文的第一部分
        StringBuilder firstHalf = new StringBuilder();

        // 统计每个数字字符的出现频率
        int[] frequency = new int[10];
        for (char c : num.toCharArray()) {
            int i = (int) c - '0';
            frequency[i]++;
        }

        int middle = -1; // 存储回文中间的单个字符
        // 从高位到低位遍历，优先选择较大的数字构建回文
        for (int i = 9; i >= 0; i--) {
            // 确保避免前导零（添加0之前firstHalf不能为空）
            if (frequency[i] > 0 && (i != 0 || !firstHalf.isEmpty())) {
                int count = frequency[i];
                while (count > 1) {
                    firstHalf.append(i);
                    count -= 2;
                }
                // 如果当前数字剩余一个且未设置中间字符，选择该数字为中间字符
                if (count == 1 && middle == -1) {
                    middle = i;
                }
            }
        }

        StringBuilder secondHalf = new StringBuilder(firstHalf);
        if (middle != -1) { // 若存在中间字符，将其加入到回文中间
            firstHalf.append(middle);
        }
        firstHalf.append(secondHalf.reverse()); // 拼接第二部分构成完整回文
        
        return !firstHalf.isEmpty() ? firstHalf.toString() : "0";
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="从数组中移除最大值和最小值">从数组中移除最大值和最小值<a hidden class="anchor" aria-hidden="true" href="#从数组中移除最大值和最小值">#</a></h2>

<a href="https://leetcode.cn/problems/removing-minimum-and-maximum-from-array" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int minimumDeletions(int[] nums) {
        int n = nums.length;
        int minIndex = 0, maxIndex = 0;
        
        // 查找数组中的最大值和最小值对应的索引
        for (int i = 0; i < n; i++) {
            if (nums[i] < nums[minIndex]) {
                minIndex = i;
            }
            if (nums[i] > nums[maxIndex]) {
                maxIndex = i;
            }
        }

        // 计算从起点或终点删除最大值和最小值的最小距离
        int minFromStart = minIndex + 1;
        int minFromEnd = n - minIndex;
        int maxFromStart = maxIndex + 1;
        int maxFromEnd = n - maxIndex;
        
        // 考虑四种删除方式，并选择删除步数最小的方案：
        int[] deletionOptions = new int[]{
            // 同向移动存在重叠，取最大值
            Math.max(minFromStart, maxFromStart), // 同时从起点删除
            Math.max(minFromEnd, maxFromEnd), // 同时从重点删除
            minFromStart + maxFromEnd, // 分别从起点和终点删除
            maxFromStart + minFromEnd // 分别从起点和终点删除
        };

        // 返回删除步数的最小值
        return Arrays.stream(deletionOptions).min().orElseThrow();
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="华为od机试模拟商场优惠打折ii100分">华为OD机试：模拟商场优惠打折II【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试模拟商场优惠打折ii100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p><strong>一、题目描述</strong></p>
<p>某网上商城推出了三种类型的优惠券：满减、打折和无门槛优惠券，具体规则如下：</p>
<ol>
<li><strong>满减券</strong>：每满100元减10元，可叠加使用，无使用张数限制。例如，购物金额在100至199元之间可使用1张满减券减10元，200至299元可使用2张减20元，以此类推。</li>
<li><strong>打折券</strong>：92折，每次限用1张。例如，100元使用后为92元。</li>
<li><strong>无门槛优惠券</strong>：每张直接减5元，可叠加使用，无张数限制。</li>
</ol>
<p>每次购物最多允许使用2种优惠券，且优惠叠加时按优惠后的价格计算。以购物金额200元为例：</p>
<ul>
<li><strong>方案1</strong>：先使用92折券，优惠至184元，再使用1张满减券减10元，最终价格为174元。</li>
<li><strong>方案2</strong>：先使用2张满减券减20元至180元，再用92折券优惠到165元（结果向下取整）。</li>
</ul>
<p>不同的使用顺序会产生不同的优惠价格，应优先考虑优惠后的最低价格。如果多个方案优惠后的价格相同，则优先选择使用优惠券数量最少的方案。如果无需使用优惠券即可达到最低价格，也可选择不使用。</p>
<p>每位顾客在活动中仅可参与一次，且优惠券种类和数量一致。</p>
<p><strong>二、输入描述</strong></p>
<ul>
<li><strong>第一行</strong>：三个整数，表示每人拥有的满减券、打折券和无门槛优惠券的数量（每种数量的取值范围为 $[0,10]$）。</li>
<li><strong>第二行</strong>：一个整数n，表示购物的人数（$1 ≤ n ≤ 10,000$）。</li>
<li><strong>接下来的 n 行</strong>：每行一个整数，表示每位顾客优惠前的购物总价（购物总价范围为 $(0,1000]$，均为整数）。</li>
</ul>
<p><strong>三、输出描述</strong></p>
<ul>
<li>每行输出每位顾客优惠后的最低价格和使用的优惠券总数量，按输入顺序输出结果。</li>
</ul>
<p><strong>补充说明</strong></p>
<ol>
<li>优惠券数量均为整数，范围为 $[0,10]$。</li>
<li>购物人数为整数，范围为 $[1,10,000]$。</li>
<li>购物总价为整数，范围为 $(0,1000]$。</li>
<li>计算优惠后的价格若为小数，则向下取整。输出均为整数。</li>
</ol>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="执行任务赚积分100分">执行任务赚积分【100分】<a hidden class="anchor" aria-hidden="true" href="#执行任务赚积分100分">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>一、题目描述</strong></p>
<p>有 N 个任务需要处理，每个任务的处理时间为 1 单位时间。每个任务都有一个最晚处理时间限制和一个积分值，只有在最晚处理时间之前完成任务才能获得对应的积分。</p>
<p>假设有 T 单位时间可以用于处理任务，请问在这 T 单位时间内，可以获得的最大积分是多少？</p>
<p><strong>二、输入描述</strong></p>
<ul>
<li>第一行输入一个整数 N，表示任务的数量 (1 ≤ N ≤ 100)。</li>
<li>第二行输入一个整数 T，表示可用于处理任务的时间单位数 (1 ≤ T ≤ 100)。</li>
<li>接下来 N 行，每行两个整数 SLA 和 V，分别表示任务的最晚处理时间和该任务的积分值：
<ul>
<li>1 &lt; SLA ≤ 100</li>
<li>0 ≤ V ≤ 100000</li>
</ul>
</li>
</ul>
<p><strong>三、输出描述</strong></p>
<p>输出一个整数，表示在有限的时间内可以获得的最大积分。</p>
<p><strong>四、测试用例</strong></p>
<p><strong>测试用例 1</strong></p>
<ul>
<li>输入：
<pre tabindex="0"><code>4
3
1 2
1 3
1 4
3 5
</code></pre></li>
<li>输出：
<pre tabindex="0"><code>9
</code></pre></li>
<li>说明：
<ul>
<li>第 1 个时间单位内，处理任务 (1, 4)，获得 4 分。</li>
<li>第 2 个时间单位内，处理任务 (1, 5)，获得 5 分。</li>
<li>最终总积分为 4 +  5 = 9。</li>
</ul>
</li>
</ul>
<p><strong>测试用例 2</strong></p>
<ul>
<li>输入：
<pre tabindex="0"><code>4
3
1 2
1 3
1 4
1 5
</code></pre></li>
<li>输出：
<pre tabindex="0"><code>5
</code></pre></li>
<li>说明：
<ul>
<li>虽然有 3 个时间单位可以处理任务，但是所有任务在时间 1 之后都已经无效，因此只能在第 1 个时间单位处理任务 (1, 5)，获得 5 分。</li>
</ul>
</li>
</ul>
<p><strong>测试用例 3</strong></p>
<ul>
<li>输入：
<pre tabindex="0"><code>4
3
1 2
2 4
2 3
1 5
</code></pre></li>
<li>输出：
<pre tabindex="0"><code>9
</code></pre></li>
<li>说明：
<ul>
<li>按照积分从高到低排序后，任务顺序为：
<ul>
<li>(1, 5)，(2, 4)，(2, 3)，(1, 2)</li>
</ul>
</li>
<li>第 1 个时间单位，处理任务 (1, 5)，获得 5 分。</li>
<li>第 2 个时间单位，处理任务 (2, 4)，获得 4 分。</li>
<li>第 3 个时间单位，没有合适的任务可以处理。</li>
<li>最终总积分为 5 + 4 = 9。</li>
</ul>
</li>
</ul>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

/**
 * @author Signal Yu
 * @since 2024-11-29
 */
public class Solution {

    static class Task {
        int deadline;  // The latest time the task can be completed
        int value;     // The points awarded for completing the task

        public Task(int deadline, int value) {
            this.deadline = deadline;
            this.value = value;
        }
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // Read the number of tasks (n) and available time units (t)
        int n = Integer.parseInt(in.nextLine().trim());
        int t = Integer.parseInt(in.nextLine().trim());

        // Create a list to store tasks
        List&lt;Task&gt; taskList = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            int[] parts = Arrays.stream(in.nextLine().trim().split(" "))
                    .mapToInt(Integer::parseInt)
                    .toArray();
            // Read task's deadline and value
            taskList.add(new Task(parts[0], parts[1]));
        }

        // Calculate the maximum points we can earn
        int maxPoints = getMaxPoints(taskList, t);

        // Output the result
        System.out.println(maxPoints);
    }

    private static int getMaxPoints(List&lt;Task&gt; taskList, int t) {
        // Sort tasks by value in descending order to prioritize higher value tasks
        taskList.sort((a, b) -> Integer.compare(b.value, a.value));

        // Array to track used time slots
        boolean[] timeSlots = new boolean[t];

        int totalPoints = 0;
        for (Task task : taskList) {
            // Try to find the latest available time slot before or on the task's deadline
            for (int i = Math.min(task.sla - 1, t - 1); i >= 0; i--) {
                if (!timeSlots[i]) { // If the time slot is available
                    timeSlots[i] = true; // Mark the time slot as occupied
                    totalPoints += task.value; // Add task's points to the total
                    break; // Move to the next task after assigning this one
                }
            }
        }

        return totalPoints;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h1 id="栈模式相关算法题">栈模式相关算法题<a hidden class="anchor" aria-hidden="true" href="#栈模式相关算法题">#</a></h1>
<h2 id="删除字符串中的所有相邻重复项">删除字符串中的所有相邻重复项<a hidden class="anchor" aria-hidden="true" href="#删除字符串中的所有相邻重复项">#</a></h2>

<a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public String removeDuplicates(String s) {
        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();

        // 遍历字符串中的每个字符
        for (char c : s.toCharArray()) {
            // 若栈不为空且栈顶字符与当前字符相同，则弹出栈顶元素（移除重复字符）
            if (!stack.isEmpty() && stack.peek() == c) {
                stack.pop();
            } else { // 否则将当前字符压入栈中
                stack.push(c);
            }
        }

        // 构建结果字符串
        StringBuilder builder = new StringBuilder();
        for (char c : stack) {
            builder.append(c);
        }

        // 返回去重后的字符串
        return builder.toString();
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="华为od机试字符串消除100分">华为OD机试：字符串消除【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试字符串消除100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p><strong>一、题目描述</strong></p>
<p><strong>游戏规则 Q</strong>：给定一个只包含英文字母的字符串，若字符串中的两个相邻且相同的字母，则这两个字母可以消除。在字符串上反复执行消除的操作，直到无法再消除为止。游戏结束时，输出剩余字符串的长度。</p>
<p><strong>二、输入描述</strong></p>
<p>输入原始字符串 <code>str</code>，它只包含大小写英文字母，字母的大小写敏感，且 <code>str</code> 的长度不超过 100。</p>
<p><strong>三、输出描述</strong></p>
<p>输出游戏结束后，最终剩余字符串的长度。</p>
<p><strong>示例：</strong></p>
<p><strong>输入 1：</strong></p>
<pre tabindex="0"><code>gg
</code></pre><p><strong>输出 1：</strong></p>
<pre tabindex="0"><code>0
</code></pre><p><strong>说明 1：</strong>
<code>gg</code> 可以直接消除，得到空串，长度为 0。</p>
<p><strong>输入 2：</strong></p>
<pre tabindex="0"><code>aabccba
</code></pre><p><strong>输出 2：</strong></p>
<pre tabindex="0"><code>1
</code></pre><p><strong>说明 2：</strong>
首先消除 <code>aa</code>，然后消除 <code>cc</code>，再消除 <code>b</code>，<code>b</code>，最后剩余<code>a</code>，长度为 1。</p>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

/**
 * @author Signal Yu
 * @since 2024-11-15
 */
class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取输入字符串
        String str = in.nextLine().trim();

        // 移除重复字符
        String result = removeDuplicates(str);

        // 输出结果
        System.out.println(result);
    }

    private static String removeDuplicates(String s) {
        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();

        // 遍历字符串中的每个字符
        for (char c : s.toCharArray()) {
            // 若栈不为空且栈顶字符与当前字符相同，则弹出栈顶元素（移除重复字符）
            if (!stack.isEmpty() && stack.peek() == c) {
                stack.pop();
            } else { // 否则将当前字符压入栈中
                stack.push(c);
            }
        }

        // 构建结果字符串
        StringBuilder builder = new StringBuilder();
        for (char c : stack) {
            builder.append(c);
        }

        // 返回去重后的字符串
        return builder.toString();
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="有效的括号">有效的括号<a hidden class="anchor" aria-hidden="true" href="#有效的括号">#</a></h2>

<a href="https://leetcode.cn/problems/valid-parentheses" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public boolean isValid(String s) {
        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();

        for (char c : s.toCharArray()) {
            // 若字符为左括号，压入栈中
            if (c == '(' || c == '[' || c == '{') {
                stack.push(c);
            } else {
                // 若栈为空或栈顶元素不匹配当前右括号，则无效
                if (stack.isEmpty() || !isMatchingPair(stack.pop(), c)) {
                    return false;
                }
            }
        }

        // 最终栈应为空，表示所有括号匹配
        return stack.isEmpty();
    }

    private boolean isMatchingPair(char open, char close) {
        return (open == '(' && close == ')') ||
               (open == '[' && close == ']') ||
               (open == '{' && close == '}');
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="华为od机试最大括号深度100分">华为OD机试：最大括号深度【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试最大括号深度100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p><strong>一、题目描述</strong></p>
<p>给定一个字符串，由以下六种括号组成：<code>(</code>、<code>)</code>、<code>{</code>、<code>}</code>、<code>[</code>、<code>]</code>。判断该字符串是否为有效的括号匹配字符串。</p>
<p>一个字符串为<strong>无效</strong>，如果满足以下任意条件：</p>
<ol>
<li>任意一种括号的左右数量不匹配；</li>
<li>存在未按正确顺序的括号闭合，即右括号在左括号之前出现。</li>
</ol>
<p>若字符串有效，输出该字符串的<strong>最大嵌套深度</strong>；若字符串无效，输出 0。</p>
<p><code>0 &lt;= 字符串长度 &lt;= 100000</code>。</p>
<p><strong>二、输入描述</strong></p>
<p>一个只包含<code>(</code>、<code>)</code>、<code>{</code>、<code>}</code>、<code>[</code>、<code>]</code> 六种括号的字符串。</p>
<p><strong>三、输出描述</strong></p>
<p>输出一个整数，表示字符串中的最大括号嵌套深度。如果字符串无效，输出 <code>0</code>。</p>
<p><strong>示例：</strong></p>
<p><strong>输入 1：</strong></p>
<pre tabindex="0"><code>[]
</code></pre><p><strong>输出 1：</strong></p>
<pre tabindex="0"><code>1
</code></pre><p><strong>说明 1：</strong>
字符串 <code>[]</code> 是有效的，最大嵌套深度为 1。</p>
<p><strong>输入 2：</strong></p>
<pre tabindex="0"><code>[{[]}()]
</code></pre><p><strong>输出 2：</strong></p>
<pre tabindex="0"><code>3
</code></pre><p><strong>说明 2：</strong>
字符串 <code>[{[]}()]</code> 是有效的，最大嵌套深度为 3。</p>
<p><strong>输入 3：</strong></p>
<pre tabindex="0"><code>[{(])}
</code></pre><p><strong>输出 3：</strong></p>
<pre tabindex="0"><code>0
</code></pre><p><strong>说明 3：</strong>
字符串 <code>[{(])}</code> 是无效的，因为 <code>(</code> 和 <code>)</code> 不是正确配对的，输出 <code>0</code>。</p>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

/**
 * @author Signal Yu
 * @since 2024-11-15
 */
class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取包含括号的字符串
        String str = in.nextLine().trim();

        // 计算括号的最大嵌套深度
        int maxDepth = getMaxDepth(str);

        // 输出结果
        System.out.println(maxDepth);
    }

    private static int getMaxDepth(String s) {
        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();

        int maxDepth = 0; // 记录括号最大嵌套深度
        for (char c : s.toCharArray()) {
            if (isOpenParenthesis(c)) {
                stack.push(c);
            } else  {
                // 栈为空，没有与之匹配的左括号，字符串无效
                if (stack.isEmpty()) {
                    return 0;
                }

                // 判断栈顶元素与当前右括号是否匹配
                if (!isMatch(stack.peek(), c)) {
                    return 0;
                }

                // 更新最大深度
                maxDepth = Math.max(maxDepth, stack.size());

                // 匹配成功，弹出栈顶元素
                stack.pop();
            }
        }

        return maxDepth; // 返回最终计算的最大深度
    }

    private static boolean isOpenParenthesis(char c) {
        return c == '(' || c == '[' || c == '{';
    }

    private static boolean isMatch(char c1, char c2) {
        return (c1 ==  '(' && c2 == ')') ||
                (c1 ==  '[' && c2 == ']') ||
                (c1 ==  '{' && c2 == '}');
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="删除字符串中的所有相邻重复项-ii">删除字符串中的所有相邻重复项 II<a hidden class="anchor" aria-hidden="true" href="#删除字符串中的所有相邻重复项-ii">#</a></h2>

<a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string-ii" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public String removeDuplicates(String s, int k) {
        // 使用栈存储字符及其计数信息
        Stack&lt;int[]&gt; stack = new Stack&lt;&gt;();

        // 遍历字符串中的每个字符
        for (char c : s.toCharArray()) {
            // 若栈顶字符与当前字符相同，则增加计数
            if (!stack.isEmpty() && stack.peek()[0] == c) {
                stack.peek()[1]++;
            } else {
                // 若不同，则将当前字符及计数1入栈
                stack.push(new int[]{c, 1});
            }

            // 如果栈顶字符的计数达到k，弹出栈顶（删除k个相同字符）
            if (stack.peek()[1] == k) {
                stack.pop();
            }
        }

        // 构建结果字符串
        StringBuilder builder = new StringBuilder();
        for (int[] entry : stack) {
            builder.append(String.valueOf((char) entry[0]).repeat(entry[1]));
        }

        return builder.toString();
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="简化路径">简化路径<a hidden class="anchor" aria-hidden="true" href="#简化路径">#</a></h2>

<a href="https://leetcode.cn/problems/simplify-path" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public String simplifyPath(String path) {
        // 将路径按“/”分割
        String[] split = path.split("/");
        // 用栈来处理路径的规范化
        Stack&lt;String&gt; stack = new Stack&lt;&gt;();

        for (String s : split) {
            // 忽略空字符串和当前目录符号 "."
            if (!s.isEmpty() || !".".equals(s)) {
                stack.push(s);

            } else if ("..".equals(s)) {
                // 如果是父目录符号 ".."，且栈不为空，则弹出栈顶元素
                if (!stack.isEmpty()) {
                    stack.pop();
                }
            }
        }

        // 构建结果路径
        StringBuilder builder = new StringBuilder();
        for (String dir : stack) {
            builder.append("/").append(dir);
        }

        // 如果栈为空，返回根目录 "/"
        return builder.length() == 0 ? "/" : builder.toString();
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="华为od机试模拟目录管理100分">华为OD机试：模拟目录管理【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试模拟目录管理100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p>一、题目描述<br>
实现一个模拟目录管理功能的软件，支持以下命令序列，并输出最后一条命令的运行结果。</p>
<ol>
<li>
<p><strong>创建目录命令</strong>：<code>mkdir 目录名称</code>，如 <code>mkdir abc</code> 用于在当前目录创建名为 <code>abc</code> 的目录。如果已存在同名目录，则不执行任何操作。此命令无输出。</p>
</li>
<li>
<p><strong>进入目录命令</strong>：<code>cd 目录名称</code>，如 <code>cd abc</code> 用于进入 <code>abc</code> 目录。特殊地，<code>cd ..</code> 用于返回上级目录。如果目录不存在，则不执行任何操作。此命令无输出。</p>
</li>
<li>
<p><strong>查看当前所在路径命令</strong>：<code>pwd</code>，输出当前路径字符串。</p>
</li>
</ol>
<p><strong>约束</strong>：</p>
<ol>
<li>目录名称仅支持小写字母；<code>mkdir</code> 和 <code>cd</code> 命令的参数仅支持单个目录，如 <code>mkdir abc</code> 和 <code>cd abc</code>；不支持嵌套路径和绝对路径，如 <code>mkdir abc/efg</code>、<code>cd abc/efg</code> 等。</li>
<li>目录符号为 <code>/</code>，根目录 <code>/</code> 作为初始目录。</li>
<li>任何不符合上述定义的无效命令不做任何处理，并且无输出。</li>
</ol>
<p>二、输入描述<br>
输入 N 行字符串，每一行字符串是一条命令。</p>
<p>三、输出描述<br>
输出最后一条命令的运行结果字符串。</p>
<p><strong>补充说明</strong>：</p>
<ul>
<li>命令行数限制为 100 行以内，目录名称限制为 10 个字符以内。</li>
</ul>
<p>四、测试用例</p>
<ol>
<li><strong>输入</strong></li>
</ol>
<pre tabindex="0"><code>mkdir abc
cd abc
pwd
</code></pre><p><strong>输出</strong></p>
<pre tabindex="0"><code>/abc/
</code></pre><ol start="2">
<li><strong>输入</strong></li>
</ol>
<pre tabindex="0"><code>mkdir test
cd test
mkdir example
cd example
cd ..
pwd
</code></pre><p><strong>输出</strong></p>
<pre tabindex="0"><code>/test/
</code></pre><ol start="5">
<li><strong>说明</strong></li>
</ol>
<ul>
<li><code>mkdir test</code> 创建了目录 <code>test</code>。</li>
<li><code>cd test</code> 进入目录 <code>test</code>。</li>
<li><code>mkdir example</code> 在 <code>test</code> 目录下创建了目录 <code>example</code>（该命令实际不影响路径管理）。</li>
<li><code>cd ..</code> 返回上级目录 <code>/test/</code>。</li>
<li><code>pwd</code> 输出当前路径 <code>/test/</code>。</li>
</ul>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

/**
 * @author Signal Yu
 * @since 2024-11-14
 */
class Solution {
    private static final String ROOT = "/"; // 根目录标识
    private static final Stack&lt;String&gt; pathStack = new Stack&lt;&gt;(); // 存储当前路径的目录栈
    private static final Set&lt;String&gt; dirNames = new HashSet&lt;&gt;(); // 存储已创建的目录名称集合

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取命令条目
        while (in.hasNextLine()) {
            String command = in.nextLine().trim();

            if (command.startsWith("mkdir ")) {
                mkdir(command.substring(6)); // 创建目录
            } else if (command.startsWith("cd ")) {
                cd(command.substring(3)); // 切换目录
            } else if ("pwd".equals(command)) {
                System.out.println(pwd()); // 显示当前路径
            }
        }

        in.close();
    }

    private static boolean isValidName(String dirName) {
        return dirName.matches("[a-z]{1,10}");
    }

    private static String pwd() {
        StringBuilder builder = new StringBuilder(ROOT);
        for (String dirName : pathStack) {
            builder.append(dirName).append("/"); // 将每个目录名添加到路径中
        }
        return builder.toString();
    }

    private static void cd(String dirName) {
        if ("..".equals(dirName) && !pathStack.isEmpty()) {
            pathStack.pop(); // 返回上一级目录
        } else if (isValidName(dirName) && dirNames.contains(dirName)) {
            pathStack.push(dirName); // 切换到有效且已创建的目录
        }
    }

    private static void mkdir(String dirName) {
        if (isValidName(dirName)) {
            dirNames.add(dirName); // 添加到已创建目录集合
        }
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="华为od机试荒岛求生100分">华为OD机试：荒岛求生【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试荒岛求生100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p><strong>题目描述</strong></p>
<p>有一个荒岛，岛上有两个港口（左港口和右港口），它们通过一座桥连接。现在一群人需要从两个港口逃生，有的人往右逃生（正数表示），有的人往左逃生（负数表示）。当两个人相遇时，会发生PK，体力值较大的人胜出，体力值相同的人则同归于尽。胜者继续向前逃生，并相应减少体力值。</p>
<p><strong>输入描述</strong></p>
<p>一行非零整数，用空格隔开，正数代表向右逃生，负数代表向左逃生。</p>
<p><strong>输出描述</strong></p>
<p>最终能够成功逃生的人数。</p>
<p><strong>示例</strong></p>
<p><strong>输入：</strong></p>
<pre tabindex="0"><code>10 20 -20 -5 10
</code></pre><p><strong>输出：</strong></p>
<pre tabindex="0"><code>2
</code></pre><p><strong>说明</strong>：</p>
<ul>
<li>正数集合：10, 20, 10</li>
<li>负数集合：-20, -5</li>
<li>20 和 -20 同归于尽；</li>
<li>10 和 -5 对战，剩余 5 体力；</li>
<li>最终逃生人数为 2 人。</li>
</ul>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

/**
 * @author Signal Yu
 * @since 2024-11-15
 */
class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取输入数据
        int[] nums = Arrays.stream(in.nextLine().trim().split(" "))
                .mapToInt(Integer::parseInt)
                .toArray();

        // 计算最终成功逃生的人数
        int result = escape(nums);

        // 输出结果
        System.out.println(result);
    }

    private static int escape(int[] nums) {
        // 使用栈来模拟桥上的人，栈顶表示当前在桥上的人
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();

        for (int num : nums) {
            // 如果栈不为空且当前人和栈顶人的体力值符号相反（即发生碰撞）
            while (!stack.isEmpty() && stack.peek() * num < 0) {
                // 对战：将体力较小的人的体力值加到栈顶，并判断结果
                num += stack.pop();
            }
            // 如果当前人仍然有体力（体力不为零），则继续逃生，将其加入栈
            if (num != 0) {
                stack.push(num);
            }
        }

        // 返回栈中剩余人的数量，即最终成功逃生的人数
        return stack.size();
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="字符串解码">字符串解码<a hidden class="anchor" aria-hidden="true" href="#字符串解码">#</a></h2>

<a href="https://leetcode.com/problems/decode-string" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >public class Solution {
    public String decodeString(String s) {
        // 栈用于存储重复次数和之前的字符串
        Stack&lt;Integer&gt; countStack = new Stack&lt;&gt;();
        Stack&lt;StringBuilder&gt; stringStack = new Stack&lt;&gt;();
        // 当前正在构建的字符串
        StringBuilder currentString = new StringBuilder();
        // 当前的重复次数
        int currentCount = 0;

        // 遍历字符串中的每个字符
        for (char c : s.toCharArray()) {
            if (Character.isDigit(c)) {
                // 如果是数字，构建当前重复次数（可能是多位数）
                currentCount = currentCount * 10 + (c - '0');
            } else if (c == '[') {
                // 遇到 '['，将当前重复次数和字符串入栈，准备开始一个新的编码块
                countStack.push(currentCount); // 入栈重复次数
                stringStack.push(currentString); // 入栈当前字符串
                currentString = new StringBuilder(); // 重置当前字符串
                currentCount = 0; // 重置重复次数
            } else if (c == ']') { // 遇到 ']'，解码：将当前字符串重复 countStack 中的次数
                int repeatTimes = countStack.pop(); // 从栈中取出重复次数
                StringBuilder decodedSubstring = currentString; // 获取当前解码块
                currentString = stringStack.pop(); // 获取之前的字符串

                // 重复当前字符串并拼接到原来的字符串上
                for (int i = 0; i < repeatTimes; i++) {
                    currentString.append(decodedSubstring);
                }
            } else {
                // 如果是字母，直接加入当前字符串
                currentString.append(c);
            }
        }

        return currentString.toString();
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="华为od机试简单的解压缩算法100分">华为OD机试：简单的解压缩算法【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试简单的解压缩算法100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p><strong>一、题目描述</strong></p>
<p>现需要实现一种算法，将一组压缩字符串还原成原始字符串。压缩规则如下：</p>
<ol>
<li><strong>字符重复规则</strong>：如果字符后面加上一个数字 <code>N</code>，则表示该字符重复 <code>N</code> 次。例如：压缩内容为 <code>A3</code>，表示原始字符串为 <code>AAA</code>。</li>
<li><strong>花括号重复规则</strong>：花括号中的字符串后面加上一个数字 <code>N</code>，表示花括号中的字符串重复 <code>N</code> 次。例如：压缩内容为 <code>{AB}3</code>，表示原始字符串为 <code>ABABAB</code>。</li>
<li><strong>嵌套规则</strong>：字符重复和花括号内容的重复规则支持任意的嵌套结构，包括互相嵌套。例如：压缩内容可以是 <code>{A3B1{C}3}3</code>，表示原始字符串为 <code>AACCCBAACCCBAACCCB</code>。</li>
</ol>
<p>请实现一个算法，解压给定的压缩字符串，并还原成原始字符串。</p>
<p><strong>二、输入描述</strong></p>
<p>输入为一行压缩后的字符串。</p>
<p><strong>三、输出描述</strong></p>
<p>输出解压后的原始字符串。</p>
<p><strong>四、补充说明</strong></p>
<ol>
<li>输入保证，数字 <code>N</code> 不为 0，花括号中的内容不为空，且保证输入的字符串合法有效。</li>
<li>输入和输出的字符串区分大小写。</li>
<li>输入的字符串长度范围为 <code>[1, 10000]</code>。</li>
<li>输出的字符串长度范围为 <code>[1, 100000]</code>。</li>
<li>数字 <code>N</code> 的取值范围为 <code>[1, 10000]</code>。</li>
</ol>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

/**
 * @author Signal Yu
 * @since 2024-11-16
 */
class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取压缩字符串
        String str = in.nextLine().trim();

        // 解压字符串并还原成原始字符串
        String result = decodeString(str);

        // 输出结果
        System.out.println(result);
    }

    private static String decodeString(String s) {
        Stack&lt;String&gt; stack = new Stack&lt;&gt;();
        int n = s.length();
        int repeatTimes; // 重复次数

        int i = 0;
        while (i < n) {
            char c = s.charAt(i);

            // 如果是 '{' 或者字母，直接入栈
            if (c == '{' || Character.isLetter(c)) {
                stack.push(String.valueOf(c));
                i++;
            } else if (Character.isDigit(c)) { // 如果是数字，表示需要处理重复逻辑
                int j = i;
                // 获取数字部分（重复次数）
                while (j < n && Character.isDigit(s.charAt(j))) {
                    j++;
                }

                // 获取重复次数
                repeatTimes = Integer.parseInt(s.substring(i, j));
                String top = stack.pop();
                stack.push(top.repeat(repeatTimes));
                i = j; // 更新索引，跳过数字部分
            } else { // 如果是 '}'，处理嵌套部分
                StringBuilder builder = new StringBuilder();

                // 弹出栈顶元素直到遇到 '{'，构建当前部分的字符串
                while (!stack.isEmpty()) {
                    String top = stack.pop();
                    if ("{".equals(top)) {
                        break;
                    }
                    builder.insert(0, top); // 将当前元素添加到结果的开头
                }

                stack.push(builder.toString());
                i++;
            }
        }

        // 拼接栈中的子串以构建原始字符串
        StringBuilder result = new StringBuilder();
        for (String str : stack) {
            result.append(str);
        }

        return result.toString();
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h1 id="单调栈模式相关算法题">单调栈模式相关算法题<a hidden class="anchor" aria-hidden="true" href="#单调栈模式相关算法题">#</a></h1>
<h2 id="下一个更大元素-i">下一个更大元素 I<a hidden class="anchor" aria-hidden="true" href="#下一个更大元素-i">#</a></h2>

<a href="https://leetcode.cn/problems/next-greater-element-i" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        Map&lt;Integer, Integer&gt; nextGreaterMap = new HashMap&lt;&gt;();

        // 从右向左遍历 nums2，构建每个元素的下一个更大元素映射
        for (int i = nums2.length - 1; i >= 0; i--) {
            int num = nums2[i];

            // 移除栈顶小于等于当前元素的值
            while (!stack.isEmpty() && stack.peek() <= num) {
                stack.pop();
            }

            // 若栈不为空，栈顶即为下一个更大元素，否则为 -1
            nextGreaterMap.put(num, stack.isEmpty() ? -1 : stack.peek());

            // 将当前元素入栈，用于后续元素的比较
            stack.push(num);
        }

        // 构建结果数组，将 nums1 中的每个元素对应的下一个更大元素取出
        int[] result = new int[nums1.length];
        for (int i = 0; i < nums1.length; i++) {
            result[i] = nextGreaterMap.get(nums1[i]);
        }

        return result;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="华为od机试分奖金100分">华为OD机试：分奖金【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试分奖金100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p><strong>一、题目描述</strong>
公司老板做了一笔大生意，想要给每位员工分配一些奖金，决定通过游戏的方式来确定每个人分到多少奖金。每位员工根据工号顺序随机抽取一个数字。按照工号顺序，遇到第一个比自己数字大的员工，前面的员工可以获得“距离 * 数字差值”的奖金。如果没有员工的数字比自己大，则该员工获得与自己数字相同的奖金。具体规则如下：</p>
<ol>
<li>每位员工抽取一个数字，并按照工号顺序排列；</li>
<li>对于每一位员工，找到第一个数字比自己大的人，计算奖金为“距离 * 数字差值”；</li>
<li>如果没有找到比自己数字大的员工，则该员工获得自己数字的奖金。</li>
</ol>
<p>例如，假设员工的随机数字依次为：<code>2 10 3</code>，那么：</p>
<ul>
<li>第1个员工：数字2，遇到第2个员工数字10，比自己大，因此第1个员工可以获得奖金 <code>1 * (10 - 2) = 8</code>；</li>
<li>第2个员工：数字10，后面没有比10大的数字，所以他获得自己的奖金，金额为10；</li>
<li>第3个员工：数字3，后面没有比3大的数字，所以他获得自己的奖金，金额为3。</li>
</ul>
<p><strong>请编写程序，计算每位员工最终获得的奖金。</strong></p>
<p><strong>二、输入描述</strong></p>
<ol>
<li>第一行是一个整数 <code>n</code>，表示员工的数量（包含老板）。</li>
<li>第二行是一个包含 <code>n</code> 个数字的字符串，每个数字表示对应员工抽取的随机数字。</li>
</ol>
<p><strong>三、输出描述</strong></p>
<p>输出一行，包含每个员工最终分配的奖金数量，以空格分隔。</p>
<p><strong>四、测试用例</strong></p>
<p><strong>测试用例1：</strong>
<strong>输入：</strong></p>
<pre tabindex="0"><code>3
2 10 3
</code></pre><p><strong>输出：</strong></p>
<pre tabindex="0"><code>8 10 3
</code></pre><p><strong>测试用例2：</strong>
<strong>输入：</strong></p>
<pre tabindex="0"><code>4
5 7 8 6
</code></pre><p><strong>输出：</strong></p>
<pre tabindex="0"><code>2 1 8 6
</code></pre>
</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

/**
 * @author Signal Yu
 * @since 2024-11-15
 */
class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取员工数量
        int n = Integer.parseInt(in.nextLine().trim());
        // 读取员工抽取的随机数字
        int[] nums = Arrays.stream(in.nextLine().trim().split(" "))
                .mapToInt(Integer::parseInt)
                .toArray();

        // 计算每个员工最终获得的奖金数量
        int[] bonus = computeBonus(nums, n);

        // 格式化输出结果
        System.out.println(Arrays.toString(bonus).replaceAll("[\\[\\],]", "").trim());
    }

    private static int[] computeBonus(int[] nums, int n) {
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        int[] bonus = new int[n]; // 用来存储每个员工的奖金

        for (int i = n - 1; i >= 0; i--) {
            // 弹出栈中所有不大于当前员工数字的元素
            while (!stack.isEmpty() && nums[stack.peek()] <= nums[i]) {
                stack.pop();
            }

            // 如果栈非空，说明当前员工的奖金由栈顶的员工决定
            if (!stack.isEmpty()) {
                bonus[i] = (stack.peek() - i) * (nums[stack.peek()] - nums[i]);
            } else {
                // 如果栈为空，说明当前员工没有遇到比自己数字大的员工，奖金为自己的数字
                bonus[i] = nums[i];
            }

            // 将当前员工的索引推入栈中
            stack.push(i);
        }

        return bonus;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="每日温度">每日温度<a hidden class="anchor" aria-hidden="true" href="#每日温度">#</a></h2>

<a href="https://leetcode.cn/problems/daily-temperatures" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int n = temperatures.length;
        int[] result = new int[n];
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();  // 栈中存储温度索引

        // 从后向前遍历温度数组
        for (int i = n - 1; i >= 0; i--) {
            // 弹出栈顶不满足条件的元素，即栈顶温度不高于当前温度
            while (!stack.isEmpty() && temperatures[stack.peek()] <= temperatures[i]) {
                stack.pop();
            }

            // 如果栈为空，则结果为 0，否则为最近的更高温度索引差值
            result[i] = stack.isEmpty() ? 0 : stack.peek() - i;

            // 当前索引入栈，作为后续元素的比较参考
            stack.push(i);
        }

        return result;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="下一个更大元素-ii">下一个更大元素 II<a hidden class="anchor" aria-hidden="true" href="#下一个更大元素-ii">#</a></h2>

<a href="https://leetcode.cn/problems/next-greater-element-ii" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int[] nextGreaterElements(int[] nums) {
        int n = nums.length;
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        int[] result = new int[n];

        // 初始化结果数组为 -1，假设不存在下一个更大元素
        Arrays.fill(result, -1);

        // 双倍长度遍历数组模拟循环数组
        for (int i = 0; i < 2 * n; i++) {
            int num = nums[i % n];

            // 如果栈顶元素的下一个更大元素是当前元素，则更新结果数组
            while (!stack.isEmpty() && nums[stack.peek()] < num) {
                result[stack.pop()] = num;
            }

            // 仅当 i < n 时压栈，避免重复处理
            if (i < n) {
                stack.push(i);
            }
        }

        return result;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="华为od机试阿里巴巴找黄金宝箱iv100分">华为OD机试：阿里巴巴找黄金宝箱（IV）【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试阿里巴巴找黄金宝箱iv100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p><strong>一、题目描述</strong></p>
<p>一贫如洗的樵夫阿里巴巴，在去砍柴的路上，无意中发现了一个藏宝地，藏宝地有编号从0到N的箱子，每个箱子上面都有一个数字。这些箱子按照顺时针方向排列成一个环，编号最大的箱子的下一个是编号为0的箱子。</p>
<p>现在，请你帮助阿里巴巴计算每个箱子上数字后的下一个比它大的数字。如果某个箱子没有比它大的数字，则输出-1。</p>
<p><strong>二、输入描述</strong></p>
<p>输入一个由逗号分隔的数字子串，表示各个箱子上的数字。</p>
<ul>
<li>1 &lt;= 子串中数字的个数 &lt;= 10,000</li>
<li>-100,000 &lt;= 每个数字的值 &lt;= 100,000</li>
</ul>
<p><strong>三、输出描述</strong></p>
<p>输出一个逗号分隔的数字列表，表示每个箱子上数字后的下一个比它大的数字。如果没有，则输出-1。</p>
<p><strong>示例</strong></p>
<p><strong>输入</strong></p>
<pre tabindex="0"><code>1,2,3,1
</code></pre><p><strong>输出</strong></p>
<pre tabindex="0"><code>2,3,-1,2
</code></pre><p><strong>说明</strong></p>
<ul>
<li>第一个箱子的数字1，后面第一个比它大的数字是2。</li>
<li>第二个箱子的数字2，后面第一个比它大的数字是3。</li>
<li>第三个箱子的数字3，没有比它大的数字，输出 -1。</li>
<li>第四个箱子的数字1，后面第一个比它大的数字是 2。</li>
</ul>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

/**
 * @author Signal Yu
 * @since 2024-11-15
 */
class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取宝箱编号
        int[] nums = Arrays.stream(in.nextLine().trim().split(","))
                .mapToInt(Integer::parseInt)
                .toArray();

        // 查找每个箱子数字下一个比它大的数字
        String result = nextGreaterElement(nums);

        // 输出结果
        System.out.println(result);
    }

    private static String nextGreaterElement(int[] nums) {
        int n = nums.length;
        int[] result = new int[n];

        // 使用栈来保存数组的索引
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        // 初始化结果数组为 -1，假设所有元素都没有下一个更大的元素
        Arrays.fill(result, -1);

        // 遍历数组两遍，模拟环形数组
        for (int i = 0; i < 2 * n; i++) {
            int num = nums[i % n];  // 当前元素，利用i % n保证环形结构

            // 如果栈顶元素对应的数字小于当前数字，说明当前数字是下一个更大的元素
            while (!stack.isEmpty() && nums[stack.peek()] < num) {
                result[stack.pop()] = num;  // 更新结果数组
            }

            // 仅当i小于n时，将索引压栈，避免重复处理
            if (i < n) {
                stack.push(i);
            }
        }

        // 构建返回结果的字符串
        StringBuilder builder = new StringBuilder();
        for (int num : result) {
            builder.append(num).append(",");
        }

        // 删除最后一个多余的逗号
        builder.setLength(builder.length() - 1);

        return builder.toString();
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="从链表中移除节点">从链表中移除节点<a hidden class="anchor" aria-hidden="true" href="#从链表中移除节点">#</a></h2>

<a href="https://leetcode.cn/problems/remove-nodes-from-linked-list" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNodes(ListNode head) {
        // 使用栈来存储节点，确保每个节点的值不小于前面的节点
        Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;();

        ListNode current = head;
        // 遍历链表
        while (current != null) {
            // 如果当前节点值大于栈顶节点的值，则弹出栈顶节点，确保栈中节点值单调递减
            while (!stack.isEmpty() && stack.peek().val < current.val) {
                stack.pop();
            }

            // 如果栈不为空，连接栈顶节点与当前节点，确保链表的连续性
            if (!stack.isEmpty()) {
                stack.peek().next = current;
            }

            // 将当前节点压入栈中
            stack.push(current);

            // 移动到下一个节点
            current = current.next;
        }

        // 返回栈底的节点，即链表头节点
        return stack.isEmpty() ? null : stack.get(0);
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="移掉-k-位数字">移掉 K 位数字<a hidden class="anchor" aria-hidden="true" href="#移掉-k-位数字">#</a></h2>

<a href="https://leetcode.cn/problems/remove-k-digits" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public String removeKdigits(String num, int k) {
        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();

        // 遍历数字字符，使用单调递增栈保持最小的数字组合
        for (char digit : num.toCharArray()) {
            // 当前数字比栈顶小，且仍有移除次数时，弹出栈顶数字
            while (!stack.isEmpty() && stack.peek() > digit && k > 0) {
                stack.pop();
                k--;
            }
            stack.push(digit); // 将当前数字压入栈中
        }   

        // 若 k > 0，移除栈顶元素以达到所需移除的位数
        for (int i = 0; i < k; i++) {
            stack.pop();
        }

        // 将栈中数字构建为结果字符串
        StringBuilder builder = new StringBuilder();
        for (char c : stack){
            builder.append(c);
        }

        // 删除前导零
        while (!builder.isEmpty() && builder.charAt(0) == '0') {
            builder.deleteCharAt(0);
        }

        // 若结果为空，则返回 "0"
        return builder.isEmpty() ? "0" : builder.toString();
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h1 id="子集模式相关算法题">子集模式相关算法题<a hidden class="anchor" aria-hidden="true" href="#子集模式相关算法题">#</a></h1>
<h2 id="子集">子集<a hidden class="anchor" aria-hidden="true" href="#子集">#</a></h2>

<a href="https://leetcode.cn/problems/subsets" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {
        // 用于存储所有子集的列表
        List&lt;List&lt;Integer&gt;&gt; subsets = new ArrayList&lt;&gt;();

        // 添加空集
        subsets.add(new ArrayList&lt;&gt;());


        for (int num : nums) {
            int size = subsets.size();
            // 遍历已有子集，将当前数字添加到每个子集中生成新子集
            for (int i = 0; i < size; i++) {
                // 创建当前子集的副本并添加当前数字
                List<Integer> currentSet = new ArrayList(subsets.get(i));
                currentSet.add(num);
                // 将新子集添加到子集列表中
                subsets.add(currentSet);
            }
        }

        return subsets;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="子集-ii">子集 II<a hidden class="anchor" aria-hidden="true" href="#子集-ii">#</a></h2>

<a href="https://leetcode.cn/problems/subsets-ii" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) {
        // 对数组进行排序，以便在遍历时检测重复元素
        Arrays.sort(nums);

        List&lt;List&lt;Integer&gt;&gt; subsets = new ArrayList&lt;&gt;();
        // 添加空集作为初始子集
        subsets.add(new ArrayList&lt;&gt;());

        int start = 0, end = 0;
        // 遍历每个元素，构造包含该元素的子集
        for (int i = 0; i < nums.length; i++) {
            // 如果当前元素与上一个元素相同，则仅从上次新增的子集开始
            start = (i > 0 && nums[i] == nums[i - 1]) ? end + 1 : 0;
            // 记录当前子集的末尾位置，以便确定新子集的起始范围
            end = subsets.size() - 1;

            // 从 startIdx 到 endIdx 遍历，生成新的子集
            for (int j = start; j <= end; j++) {
                // 为当前子集创建副本并添加当前元素
                List<Integer> currentSet = new ArrayList&lt;&gt;(subsets.get(j));
                currentSet.add(nums[i]);
                subsets.add(currentSet);
            }
        }

        return subsets;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="华为od机试查找充电设备100分">华为OD机试：查找充电设备【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试查找充电设备100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p>一、<strong>题目描述</strong></p>
<p>某个充电站可以提供 $n$ 个充电设备，每个充电设备均有对应的输出功率。任意个充电设备组合的输出功率总和构成一个功率集合 $P$。功率集合 $P$ 的最优元素表示最接近充电站最大输出功率 $p_{max}$ 的元素。</p>
<p>二、<strong>输入描述</strong><br>
输入共 3 行：</p>
<ol>
<li>第 1 行为充电设备的个数 $n$；</li>
<li>第 2 行为每个充电设备的输出功率，以空格分隔；</li>
<li>第 3 行为充电站的最大输出功率 $p_{max}$。</li>
</ol>
<p>三、<strong>输出描述</strong><br>
输出功率集合$P$的最优元素。</p>
<p>四、<strong>补充说明</strong></p>
<ol>
<li>充电设备个数 $n &gt; 0$；</li>
<li>最优元素必须小于或等于充电站最大输出功率 $p_{max}$。</li>
</ol>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

/**
 * 计算功率的所有子集
 * 求解最优子集和
 *
 * @author Signal Yu
 * @since 2024-10-28
 */
class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 获取充电设备个数
        int n = in.nextInt();

        // 获取充电设备功率
        List&lt;Integer&gt; powerList = new ArrayList&lt;&gt;();
        for (int i = 0; i < n; i++) {
            powerList.add(in.nextInt());
        }

        // 获取充电站最大输出功率
        int maxPower = in.nextInt();

        in.close();

        // 求解最有功率组合
        int result = findOptimalPower(powerList, maxPower);

        // 输出结果
        System.out.println(result);
    }

    private static int findOptimalPower(List&lt;Integer&gt; powerList, int maxPower) {
        if (powerList.isEmpty()) {
            return 0;
        }
        int optimalPower = Integer.MIN_VALUE;

        List&lt;List&lt;Integer&gt;&gt; subsets = new ArrayList&lt;&gt;();
        subsets.add(new ArrayList&lt;&gt;());

        for (int power : powerList) {
            int subsetSize = subsets.size();

            for (int i = 0; i < subsetSize; i++) {
                // 在原子集基础上新建子集
                List&lt;Integer&gt; subset = new ArrayList&lt;&gt;(subsets.get(i));
                subset.add(power);
                int subsetSum = subset.stream().mapToInt(Integer::intValue).sum();
                if (subsetSum <= maxPower) {
                    optimalPower = Math.max(optimalPower, subsetSum);
                }
                subsets.add(subset);
            }
        }
        
        return (optimalPower == Integer.MIN_VALUE) ? 0 : optimalPower;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="全排列">全排列<a hidden class="anchor" aria-hidden="true" href="#全排列">#</a></h2>

<a href="https://leetcode.cn/problems/permutations" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {
        // 存储最终结果的全排列
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
        // 存储中间状态的排列
        Queue&lt;List&lt;Integer&gt;&gt; permutations = new LinkedList&lt;&gt;();
        // 初始添加空排列
        permutations.add(new ArrayList&lt;&gt;());

        // 遍历每个数字，将其插入到现有排列的每个位置
        for (int num : nums) {
            int n = permutations.size();
            for (int i = 0; i < n; i++) {
                List<Integer> oldPermutation = permutations.poll();
                // 将当前数字插入到排列中的每个可能位置，形成新的排列
                for (int j = 0; j <= oldPermutation.size(); j++) {
                    List<Integer> newPermutation = new ArrayList&lt;&gt;(oldPermutation);
                    // 在第 j 个位置插入当前数字
                    newPermutation.add(j, num);
                    // 如果新排列的长度与输入数组长度相等，则表示一个完整的排列
                    if (newPermutation.size() == nums.length) {
                        result.add(newPermutation);
                    } else { // 继续加入队列待处理
                        permutations.add(newPermutation);
                    }
                }
            }
        }

        return result;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="字母大小写全排列">字母大小写全排列<a hidden class="anchor" aria-hidden="true" href="#字母大小写全排列">#</a></h2>

<a href="https://leetcode.cn/problems/letter-case-permutation" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public List&lt;String&gt; letterCasePermutation(String s) {
        List&lt;String&gt; permutations = new ArrayList&lt;&gt;();
        permutations.add(s); // 初始化时将原始字符串添加到结果列表中

        // 遍历字符串的每个字符
        for (int i = 0; i < s.length(); i++) {
            // 如果字符是字母，则生成大小写的变换
            if (Character.isLetter(s.charAt(i))) {
                int size = permutations.size();
                // 对当前已有的每个排列进行修改，生成新排列
                for(int j = 0; j < size; j++) {
                    char[] charArray = permutations.get(j).toCharArray();
                    
                    // 切换当前字母的大小写
                    charArray[i] = Character.isUpperCase(charArray[i]) 
                        ? Character.toLowerCase(charArray[i]) 
                        : Character.toUpperCase(charArray[i]);

                    // 将新排列添加到列表
                    permutations.add(new String(charArray));
                }
            }

        }

        return permutations;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="括号生成">括号生成<a hidden class="anchor" aria-hidden="true" href="#括号生成">#</a></h2>

<a href="https://leetcode.cn/problems/generate-parentheses" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public List&lt;String&gt; generateParenthesis(int n) {
        List&lt;String&gt; result = new ArrayList&lt;&gt;(); // 存储所有有效的括号组合
        Queue&lt;ParenthesesString&gt; queue = new LinkedList&lt;&gt;();
        queue.add(new ParenthesesString("", 0, 0)); // 初始状态，字符串为空，左右括号数为0

        // 广度优先遍历，生成每种可能的括号组合
        while (!queue.isEmpty()) {
            ParenthesesString parentheses = queue.poll();

            // 如果当前字符串已包含 n 对括号，将其加入结果集
            if (parentheses.openCount == n && parentheses.closeCount == n) {
                result.add(parentheses.str);
            } else {
                // 如果左括号数小于 n，可以添加左括号
                if (parentheses.openCount < n) {
                    queue.add(new ParenthesesString(parentheses.str + "(",
                            parentheses.openCount + 1,
                            parentheses.closeCount));
                }

                // 如果右括号数小于左括号数，可以添加右括号
                if (parentheses.openCount > parentheses.closeCount) {
                    queue.add(new ParenthesesString(parentheses.str + ")",
                            parentheses.openCount,
                            parentheses.closeCount + 1));
                }
            }
        }

        return result;
    }
}

// 辅助类，用于存储生成过程中的字符串及其左右括号数量
class ParenthesesString {
    String str; // 当前生成的括号字符串
    int openCount; // 左括号数量
    int closeCount; // 右括号数量

    public ParenthesesString(String str, int openCount, int closeCount) {
        this.str = str;
        this.openCount = openCount;
        this.closeCount = closeCount;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h1 id="区间合并模式相关算法题">区间合并模式相关算法题<a hidden class="anchor" aria-hidden="true" href="#区间合并模式相关算法题">#</a></h1>
<h2 id="合并区间">合并区间<a hidden class="anchor" aria-hidden="true" href="#合并区间">#</a></h2>

<a href="https://leetcode.cn/problems/merge-intervals" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int[][] merge(int[][] intervals) {
        // 按每个区间的起始位置进行升序排序
        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);

        // 用于存放合并后的区间
        List&lt;int[]&gt; mergedIntervals = new ArrayList&lt;&gt;();

        // 初始化当前区间为第一个区间
        int[] currentInterval = intervals[0];
        mergedIntervals.add(currentInterval);

        // 遍历后续区间并进行合并
        for (int[] interval : intervals) {
            int currentEnd = currentInterval[1];
            int nextStart = interval[0];
            int nextEnd = interval[1];

            // 如果当前区间的结束点不小于下一个区间的起始点，则合并区间
            if (nextStart <= currentEnd) {
                currentInterval[1] = Math.max(currentEnd, nextEnd); // 更新当前区间的结束点
            } else {
                // 否则，当前区间结束，将下一个区间设为新的当前区间
                currentInterval = interval;
                mergedIntervals.add(currentInterval);
            }
        }

        // 将列表转换为二维数组返回
        return mergedIntervals.toArray(new int[mergedIntervals.size()][]);
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="华为od机试会议室占用时间段100分">华为OD机试：会议室占用时间段【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试会议室占用时间段100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p>一、题目描述</p>
<p>现有若干个会议，所有会议共享一个会议室。用数组表示各个会议的开始时间和结束时间，格式为：<code>[[会议1开始时间，会议1结束时间], [会议2开始时间，会议2结束时间]]</code>。请计算会议室的占用时间段。</p>
<p>二、输入描述</p>
<p><code>[[会议1开始时间，会议1结束时间], [会议2开始时间，会议2结束时间]]</code><br>
备注：</p>
<ul>
<li>会议个数范围：<code>[1, 100]</code></li>
<li>会议室时间段：<code>[1, 24]</code></li>
</ul>
<p>三、输出描述</p>
<p>输出格式与输入一致，具体请看用例。<br>
<code>[[会议开始时间，会议结束时间], [会议开始时间，会议结束时间]]</code></p>
<p>1、输入
<code>[[1, 4], [4, 5]]</code></p>
<p>2、输出
<code>[[1, 5]]</code></p>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Scanner;

/**
 * 区间合并问题：
 * 1. 根据区间起始时间排序
 * 2. 若区间发生重叠，则更新当前区间的结束时间
 * 3. 若区间没有发生重叠，则将其添加至结果集
 * 4. 重叠判定：下一个区间的起始时间是否小于或等于当前区间结束时间
 *
 * @author Signal Yu
 * @since 2024-10-28
 */
class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取输入
        String input = in.nextLine();

        in.close();

        // 处理输入
        List&lt;int[]&gt; intervals = parseInput(input);

        // 区间合并
        List&lt;int[]&gt; mergedIntervals = mergeIntervals(intervals);

        // 输出结果
        System.out.println(formatOutput(mergedIntervals));
    }

    private static String formatOutput(List&lt;int[]&gt; intervals) {
        StringBuilder sb = new StringBuilder();

        sb.append("[");
        for (int[] interval : intervals) {
            sb.append("[").append(interval[0]).append(",").append(interval[1]).append("],");
        }

        // 移除末尾的逗号
        if (!sb.isEmpty()) {
            sb.setLength(sb.length() - 1);
        }
        sb.append("]");

        return sb.toString();
    }

    private static List&lt;int[]&gt; mergeIntervals(List&lt;int[]&gt; intervals) {
        if (intervals.size() <= 1) {
            return intervals;
        }

        // 根据区间的起始时间进行排序
        intervals.sort(Comparator.comparingInt(a -> a[0]));

        List&lt;int[]&gt; mergedIntervals = new ArrayList&lt;&gt;();
        int[] currentInterval = intervals.get(0);
        mergedIntervals.add(currentInterval);
        for (int i = 1; i < intervals.size(); i++) {
            int[] nextInterval = intervals.get(i);
            int nextStart = nextInterval[0];
            int nextEnd = nextInterval[1];
            int currentEnd = currentInterval[1];

            if (nextStart <= currentEnd) { // 区间重叠
                // 更新当前区间的结束时间
                currentInterval[1] = Math.max(currentEnd, nextEnd);
            } else { // 区间无重叠
                mergedIntervals.add(nextInterval);
                currentInterval = nextInterval;
            }
        }

        return mergedIntervals;
    }

    private static List&lt;int[]&gt; parseInput(String input) {
        // 移除中括号和空格
        input = input.replaceAll("[\\[\\]\\s]", "");
        String[] pairs = input.split(",");

        List&lt;int[]&gt; intervals = new ArrayList&lt;&gt;();
        for (int i = 0; i < pairs.length; i += 2) {
            int start = Integer.parseInt(pairs[i]);
            int end = Integer.parseInt(pairs[i + 1]);
            intervals.add(new int[]{start, end});
        }

        return intervals;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="华为od机试路灯照明问题100分">华为OD机试：路灯照明问题【100分】<a hidden class="anchor" aria-hidden="true" href="#华为od机试路灯照明问题100分">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p><strong>题目描述</strong><br>
在一条笔直的公路上安装了 $N$ 个路灯，从位置 0 开始安装，路灯之间的间距固定为 100 米。每个路灯都有其照明半径，请计算从第一个路灯到最后一个路灯之间无法被任何路灯照亮的区间长度之和。</p>
<p><strong>输入描述</strong></p>
<ul>
<li>第一行包含一个整数 $N$，表示路灯的个数，$1 \leq N \leq 100000$。</li>
<li>第二行包含 $N$ 个正整数，以空格分隔，表示每个路灯的照明半径，$1 \leq \text{照明半径}$。</li>
</ul>
<p><strong>输出描述</strong></p>
<p>输出第一个路灯与最后一个路灯之间，所有无法照亮的区间长度之和。</p>
<p><strong>示例</strong></p>
<p>输入：</p>
<pre tabindex="0"><code>3
20 70 30
</code></pre><p>输出：</p>
<pre tabindex="0"><code>10
</code></pre><p><strong>说明</strong></p>
<p>第一个路灯覆盖 0 到 20 米，第二个路灯覆盖 30 到 170 米，第二个路灯覆盖 170 到 230 米，因此未被照明的区间为[20, 30]，所以输出为 $10（30 -20）$。</p>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

/**
 * @author Signal Yu
 * @since 2024-11-12
 */
class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 读取路灯个数
        int n = Integer.parseInt(in.nextLine().trim());
        // 读取照明半径字符串并转换为数组
        int[] lightRadius = Arrays.stream(in.nextLine().trim().split(" "))
                .mapToInt(Integer::parseInt)
                .toArray();

        // 计算无法照亮的的长度和
        int result = getNonLightDistance(lightRadius, n);

        // 输出结果
        System.out.println(result);
    }

    private static int getNonLightDistance(int[] lightRadius, int n) {
        // 根据照明半径生成照明区间
        List<int[]> lightIntervals = new ArrayList<>();

        // 生成每个路灯的照明区间：[起始位置 - 半径, 起始位置 + 半径]
        for (int i = 0; i < n; i++) {
            int r = lightRadius[i];
            lightIntervals.add(new int[]{i * 100 - r, i * 100 + r});
        }

        // 按照区间起点进行排序
        lightIntervals.sort(Comparator.comparingInt(a -> a[0]));

        int currentEnd = lightIntervals.get(0)[1];
        int totalNonLightDistance = 0;
        for (int i = 1; i < lightIntervals.size(); i++) {
            int[] interval = lightIntervals.get(i);
            int start = interval[0];
            int end = interval[1];

            if (currentEnd < start) {
                // 当前区间和下一个区间之间的未覆盖部分
                totalNonLightDistance += start - currentEnd;
            }

            currentEnd = Math.max(currentEnd, end); // 更新已覆盖的最远端
        }

        return totalNonLightDistance;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="插入区间">插入区间<a hidden class="anchor" aria-hidden="true" href="#插入区间">#</a></h2>

<a href="https://leetcode.cn/problems/insert-interval" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int[][] insert(int[][] intervals, int[] newInterval) {
        List&lt;int[]&gt; mergedIntervals = new ArrayList&lt;&gt;();

        int i = 0;
        // 将不重叠且位于 newInterval 左侧的区间直接加入结果集
        while (i < intervals.length && intervals[i][1] < newInterval[0]) {
            mergedIntervals.add(intervals[i]);
            i++;
        }

        // 合并与 newInterval 重叠的区间，更新 newInterval 的左右边界
        while (i < intervals.length && intervals[i][0] <= newInterval[1]) {
            newInterval[0] = Math.min(intervals[i][0], newInterval[0]);
            newInterval[1] = Math.max(intervals[i][1], newInterval[1]);
            i++;
        }

        // 将合并后的 newInterval 加入结果集
        mergedIntervals.add(newInterval);

        // 将剩余不重叠且位于 newInterval 右侧的区间加入结果集
        while (i < intervals.length) {
            mergedIntervals.add(intervals[i]);
            i++;
        }

        // 将结果集转换为二维数组返回
        return mergedIntervals.toArray(new int[mergedIntervals.size()][]);
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="区间列表的交集">区间列表的交集<a hidden class="anchor" aria-hidden="true" href="#区间列表的交集">#</a></h2>

<a href="https://leetcode.cn/problems/interval-list-intersections" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int[][] intervalIntersection(int[][] firstList, int[][] secondList) {
        List&lt;int[]&gt; intersections = new ArrayList&lt;&gt;();
        int i = 0, j = 0;
        
        // 使用双指针遍历两个列表，寻找所有重叠区间
        while (i < firstList.length && j < secondList.length) {
            int start = Math.max(firstList[i][0], secondList[j][0]);
            int end = Math.min(firstList[i][1], secondList[j][1]);

            // 如果两个区间有交集，加入结果列表
            if (start <= end) {
                intersections.add(new int[] { start, end });
            }

            // 移动指向区间结束较早的指针，以继续寻找可能的交集
            if (firstList[i][1] < secondList[j][1]) {
                i++;
            } else {
                j++;
            }
        }

        return intersections.toArray(new int[intersections.size()][]);
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="无重叠区间">无重叠区间<a hidden class="anchor" aria-hidden="true" href="#无重叠区间">#</a></h2>

<a href="https://leetcode.cn/problems/non-overlapping-intervals" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        // 按区间的结束时间升序排序，以便优先选择结束早的区间
        Arrays.sort(intervals, (a, b) -> Integer.compare(a[1], b[1]));

        int removeCount = 0; // 记录需要移除的重叠区间数
        int end = intervals[0][1]; // 初始化为第一个区间的结束时间

        // 从第二个区间开始遍历
        for (int i = 1; i < intervals.length; i++) {
            // 如果当前区间的起始时间不小于上一个区间的结束时间，则无重叠
            if (intervals[i][0] >= end) {
                end = intervals[i][1]; // 更新结束时间为当前区间的结束时间
            } else {
                removeCount++; // 重叠区间，计数增加
            }
        }

        return removeCount;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="判断两个事件是否存在冲突">判断两个事件是否存在冲突<a hidden class="anchor" aria-hidden="true" href="#判断两个事件是否存在冲突">#</a></h2>

<a href="https://leetcode.cn/problems/determine-if-two-events-have-conflict" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public boolean haveConflict(String[] event1, String[] event2) {
        /*
          时间格式为 "HH:MM" ，符合字典顺序，可以使用
          compareTo 方法来比较时间的先后顺序。

          str1.compareTo(str2):
            负数 --> str1 < str2
            0   --> str1 == str2
            正数 --> str1 > str2
        */
        
        /*
           不存在冲突情况
             (1)【事件1】
                      】 【事件2】
             (2)【事件2】 
                      】 【事件1】  
        */
        return !(event1[1].compareTo(event2[0]) < 0 ||
                event2[1].compareTo(event1[0]) < 0);
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h1 id="动态规划模式相关算法题">动态规划模式相关算法题<a hidden class="anchor" aria-hidden="true" href="#动态规划模式相关算法题">#</a></h1>
<h2 id="斐波那契数列模式">斐波那契数列模式<a hidden class="anchor" aria-hidden="true" href="#斐波那契数列模式">#</a></h2>
<h2 id="斐波那契数">斐波那契数<a hidden class="anchor" aria-hidden="true" href="#斐波那契数">#</a></h2>

<a href="https://leetcode.cn/problems/fibonacci-number" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码：暴力递归</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">暴力递归</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int fibRecursive(int n) {
        if (n < 2) {
            return n; // 基础情况：F(0) = 0，F(1) = 1
        }
        return fibRecursive(n - 1) + fibRecursive(n - 2); // 递归计算 F(n) = F(n-1) + F(n-2)
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码：记忆化递归</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">记忆化递归</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int fibMemoization(int n) {
        int[] cache = new int[n + 1]; // 用于缓存计算结果
        return fibRecursiveWithCache(n, cache);
    }

    private int fibRecursiveWithCache(int n, int[] cache) {
        if (n < 2) {
            return n; // 基础情况
        }
        if (cache[n] == 0) {
            // 缓存未命中时，计算并保存结果
            cache[n] = fibRecursiveWithCache(n - 1, cache) + fibRecursiveWithCache(n - 2, cache);
        }
        return cache[n]; // 返回缓存结果
    }

}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<p>递归树分析：</p>
<ul>
<li><code>斐波那契数列 = [0, 1, 1, 2, 3, 5]</code></li>
<li><code>n = 5</code></li>
</ul>
<pre class="mermaid">---
title: 递归树分析：斐波那契数
---
graph TD
    L0((5)) 
    L0 --> L1((4))
    L0 --> R1((3))

    L1 --> L2a((3))
    L1 --> L2b((2))
    
    L2a --> L3a((2))
    L2a --> L3b((1))

    L3a --> L4a((1))
    L3a --> L4b((0))

    style R1 fill:blue
    style L2a fill:blue
    style L2b fill:orange,color:black
    style L3a fill:orange,color:black
</pre>
<hr>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码：自下而上迭代</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">自下而上迭代</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int fibTabulation(int n) {
        if (n < 2) {
            return n; // 基础情况
        }

        int[] dp = new int[n + 1]; // 状态数组
        dp[0] = 0;
        dp[1] = 1;

        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2]; // F(i) = F(i-1) + F(i-2)
        }

        return dp[n]; // 返回最终结果
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<figure class="align-center ">
    <img loading="lazy" src="/img/algorithms/patterns/1-fib-iteration.png#center" width="100%" height="100%"/> <figcaption>
            自下而上迭代
        </figcaption>
</figure>

<hr>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码：空间优化</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">空间优化</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int fibSpaceOptimized(int n) {
        if (n < 2) {
            return n; // 基础情况
        }

        int prev1 = 0, prev2 = 1, current; // 初始化前两个状态

        for (int i = 2; i <= n; i++) {
            current = prev1 + prev2; // F(i) = F(i-1) + F(i-2)
            prev1 = prev2; // 更新状态
            prev2 = current;
        }

        return prev2; // 返回最终结果
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<blockquote>
<p>斐波那契数等式：$F(n) = F(n-1) + F(n-2)$</p>
</blockquote>
<hr>
<h2 id="爬楼梯">爬楼梯<a hidden class="anchor" aria-hidden="true" href="#爬楼梯">#</a></h2>

<a href="https://leetcode.cn/problems/climbing-stairs" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码：暴力递归</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">暴力递归</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int climbStairsRecursive(int n) {
        if (n < 3) {
            return n; // 基础情况：1级楼梯1种方法，2级楼梯2种方法
        }
        return climbStairsRecursive(n - 1) + climbStairsRecursive(n - 2); // F(n) = F(n-1) + F(n-2)
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码：记忆化递归</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">记忆化递归</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int climbStairsMemoization(int n) {
        int[] cache = new int[n + 1]; // 缓存数组
        return climbStairsWithCache(n, cache);
    }

    private int climbStairsWithCache(int n, int[] cache) {
        if (n < 3) {
            return n; // 基础情况
        }
        if (cache[n] == 0) {
            // 缓存未命中时，计算并保存结果
            cache[n] = climbStairsWithCache(n - 1, cache) + climbStairsWithCache(n - 2, cache);
        }
        return cache[n]; // 返回缓存结果
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码：自下而上迭代</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">自下而上迭代</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int climbStairsTabulation(int n) {
        if (n < 3) {
            return n; // 基础情况
        }

        int[] cache = new int[n + 1]; // 状态数组
        cache[1] = 1;
        cache[2] = 2;

        for (int i = 3; i <= n; i++) {
            cache[i] = cache[i - 1] + cache[i - 2]; // F(i) = F(i-1) + F(i-2)
        }

        return cache[n]; // 返回结果
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码：空间优化</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">空间优化</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int climbStairsSpaceOptimized(int n) {
        if (n < 3) {
            return n; // 基础情况
        }

        int prev1 = 1, prev2 = 2, current = 0; // 初始化前两个状态

        for (int i = 3; i <= n; i++) {
            current = prev1 + prev2; // F(i) = F(i-1) + F(i-2)
            prev1 = prev2; // 更新状态
            prev2 = current;
        }

        return prev2; // 返回最终结果
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<blockquote>
<p>斐波那契数等式：$F(n) = F(n - 1) + F(n - 2)$</p>
</blockquote>
<hr>
<h2 id="使用最小花费爬楼梯">使用最小花费爬楼梯<a hidden class="anchor" aria-hidden="true" href="#使用最小花费爬楼梯">#</a></h2>

<a href="https://leetcode.cn/problems/min-cost-climbing-stairs" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码：暴力递归</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">暴力递归</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {

    public int minCostClimbingStairs(int[] cost) {
        int n = cost.length;
        // 从倒数第一步或倒数第二步到达楼顶
        return Math.min(minCost(cost, n - 1), minCost(cost, n - 2));
    }

    private int minCost(int[] cost, int i) {
        // 基础情况：第 0 或第 1 级台阶
        if (i == 0 || i == 1) {
            return cost[i];
        }
        // 递归计算当前台阶的最小花费
        return cost[i] + Math.min(minCost(cost, i - 1), minCost(cost, i - 2));
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码：记忆化递归</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">记忆化递归</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {

    public int minCostClimbingStairs(int[] cost) {
        int n = cost.length;
        int[] cache = new int[n];
        Arrays.fill(cache, -1);
        
        // 从倒数第一步或倒数第二步到达楼顶
        return Math.min(minCost(cost, n - 1, cache), minCost(cost, n - 2, cache));
    }

    private int minCost(int[] cost, int i, int[] cache) {
        if (i < 2) {
            return cost[i];
        }
        // 递归计算并存储当前台阶的最小花费
        if (cache[i] == -1) {
            cache[i] = cost[i] + Math.min(minCost(cost, i - 1, cache), minCost(cost, i - 2, cache));
        }
        
        return cache[i];
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码：自下而上迭代</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {

    public int minCostClimbingStairs(int[] cost) {
        int n = cost.length;
        int[] cache = new int[n];
        // 初始化第 0 和第 1 级台阶的花费
        cache[0] = cost[0];
        cache[1] = cost[1];
        // 计算到达每一级台阶的最小花费
        for (int i = 2; i < n; i++) {
            cache[i] = cost[i] + Math.min(cache[i - 1], cache[i - 2]);
        }
        // 返回从倒数第一步或倒数第二步到达楼顶的最小花费
        return Math.min(cache[n - 1], cache[n - 2]);
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码：空间优化</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">空间优化</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {

    public int minCostClimbingStairs(int[] cost) {
        int n = cost.length;
        // 初始化前两个台阶的最小花费
        int prev1 = cost[0], prev2 = cost[1];
        // 逐步计算当前台阶的最小花费
        for (int i = 2; i < n; i++) {
            int current = cost[i] + Math.min(prev1, prev2);
            prev1 = prev2;
            prev2 = current;
        }
        // 返回从倒数第一步或倒数第二步到达楼顶的最小花费
        return Math.min(prev1, prev2);
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<blockquote>
<p>斐波那契数等式：$F(n) = \min\{\text{cache}[n], \text{cache}[n-1]\}$</p>
</blockquote>
<hr>
<h2 id="打家劫舍">打家劫舍<a hidden class="anchor" aria-hidden="true" href="#打家劫舍">#</a></h2>

<a href="https://leetcode.cn/problems/house-robber" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码：暴力解法</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">暴力解法</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        // 从最后一间房屋开始计算最大收益
        return robFrom(nums, n - 1);
    }

    private int robFrom(int[] nums, int i) {
        // 边界条件：如果索引小于 0，表示无房屋可抢，返回 0
        if (i < 0) {
            return 0;
        }
 
        // 选择抢当前房屋或跳过当前房屋
        int robCurrent = nums[i] + robFrom(nums, i - 2); // 抢当前房屋
        int robSkip = robFrom(nums, i - 1);             // 跳过当前房屋
 
        // 返回两种选择的最大值
        return Math.max(robCurrent, robSkip);
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<p>递归树分析：</p>
<ul>
<li><code>nums = [1, 2, 3, 1]</code></li>
<li>[index]</li>
</ul>
<pre class="mermaid">---
title: 打家劫舍：递归树分析
---
graph TD
    L0(("\[3\]")) -->|+1| L1(("\[1\]"))
    L0 -.->|skip| R1(("\[2\]"))
    L1 -->|+2| L2A(("\[-1\]"))
    L1 -.->|skip| R2A(("\[0\]"))
    R1 -->|+3| L2B(("\[0\]"))
    R1 -.->|skip| R2B(("\[1\]"))

    style L1 fill:blue
    style R2B fill:blue

    L2A --> r1((0))
    R2A --> r2((1))
    L2B --> r3((1))
    R2B --> r4((2))
</pre>
<hr>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码：记忆化递归</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">记忆化递归</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        // 初始化缓存数组，-1 表示尚未计算
        int[] cache = new int[n];
        Arrays.fill(cache, -1);
        // 从最后一间房屋开始计算最大收益
        return robRecursive(nums, n - 1, cache);
    }

    private static int robRecursive(int[] nums, int i, int[] cache) {
        if (i < 0) {
            return 0;
        }

        if (cache[i] == -1) {
            // 选择抢当前房屋或跳过当前房屋
            int robCurrent = nums[i] + robRecursive(nums, i - 2, cache);
            int robSkip = robRecursive(nums, i - 1, cache);
            // 缓存结果
            cache[i] = Math.max(robCurrent, robSkip);
        }

        return cache[i];
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码：自下而上迭代</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">自下而上迭代</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        // 边界条件：只有一间房屋时直接返回金额
        if (n == 1) {
            return nums[0];
        }
        // 初始化缓存数组
        int[] cache = new int[n];
        cache[0] = nums[0];                           // 仅抢第一间房屋
        cache[1] = Math.max(nums[0], nums[1]);        // 抢第一间或第二间房屋
        // 从第三间房屋开始，计算每间房屋的最大收益
        for (int i = 2; i < n; i++) {
            cache[i] = Math.max(nums[i] + cache[i - 2], cache[i - 1]);
        }
        // 返回最后一间房屋的最大收益
        return cache[n - 1];
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码：空间优化</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">空间优化</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        // 边界条件：只有一间房屋时直接返回金额
        if (n == 1) {
            return nums[0];
        }
        // 使用两个变量滚动存储状态
        int prev1 = nums[0];                         // 抢第一间房屋
        int prev2 = Math.max(nums[0], nums[1]);      // 抢第一间或第二间房屋
        for (int i = 2; i < n; i++) {
            int current = Math.max(nums[i] + prev1, prev2); // 当前最大收益
            prev1 = prev2;                                 // 更新状态
            prev2 = current;
        }
        // 返回最终的最大收益
        return prev2;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<blockquote>
<p>斐波那契数等式：$F(n) = \max\{\text{nums}[n] + F(n-2), F(n-1)\}$</p>
</blockquote>
<hr>
<h2 id="heading"><a hidden class="anchor" aria-hidden="true" href="#heading">#</a></h2>
<h2 id="01-背包模式">0/1 背包模式<a hidden class="anchor" aria-hidden="true" href="#01-背包模式">#</a></h2>
<h2 id="01-背包问题">0/1 背包问题<a hidden class="anchor" aria-hidden="true" href="#01-背包问题">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p>给定两个整数数组分别表示 <code>N</code> 个物品的重量和利润，要求找到一个物品的子集，使其总重量不超过给定的容量 <code>C</code>，同时获得最大利润。编写一个函数返回最大利润。每个物品只能被选择一次，也就是说，物品要么被放入背包，要么不放入。</p>
<p><code>weights：{ 1, 2, 3 }</code></p>
<p><code>profits：{ 6, 10, 16 }</code></p>
<p><code>capacity：4</code></p>
<p>最大利润为 <code>6 + 16 = 22</code></p>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码：暴力递归</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">暴力递归</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >public class Solution {
  public int solveKnapsack(int[] profits, int[] weights, int capacity) {
    return solveKnapsackRecursive(profits, weights, capacity, 0);
  }

  private int solveKnapsackRecursive(int[] profits, int[] weights, int capacity, int i) {
    // 基础情况：容量不足或所有物品已处理完
    if (capacity < 0 || i == weights.length) {
      return 0;
    }

    // 包含当前物品的选择
    int include = 0;
    if (weights[i] <= capacity) {
      include = profits[i] + solveKnapsackRecursive(profits, weights, capacity - weights[i], i + 1);
    }

    // 排除当前物品的选择
    int exclude = solveKnapsackRecursive(profits, weights, capacity, i + 1);

    // 返回两种选择中较大的利润
    return Math.max(include, exclude);
  }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<p>递归树分析</p>
<ul>
<li><code>weights = [1, 2, 3]</code></li>
<li><code>profits = [6, 10, 16]</code></li>
<li><code>capacity = 4</code></li>
<li><code>(current weight, [profits], remaining capacity)</code></li>
<li><code>current weight 的值为 null 表示已经遍历完毕</code></li>
</ul>
<pre class="mermaid">---
title: 背包问题：递归树分析
---
graph TD
    L0["(1,[],4)"] -->|+6| L1["(2,[6],3)"]
    L0 -.->|skip| R1["(2,[],4)"]

    L1 -->|+10| L2A["(3,[6,10],2)"]
    L1 -.->|skip| R2A["(3,[6],3)"]

    R1 -->|+10| L2B["(3,[10],2)"]
    R1 -.->|skip| R2B["(3,[],4)"]

    R2A -->|+16| L3B["(null,[6,16],0)"]
    R2A -.->|skip| R3B["(null,[6],3)"]

    R2B -->|+16| L3D["(null,[16],1)"]
    R2B -.->|skip| R3D["(null,[],4)"]

    L3B --> r1((6 \+ 16 = 22))

    style L3B fill:blue
</pre>
<hr>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码：记忆化递归</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">记忆化递归</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >public class Solution {
    public int solveKnapsack(int[] profits, int[] weights, int capacity) {
        // 初始化缓存数组，用于存储子问题的结果以避免重复计算
        Integer[][] cache = new Integer[weights.length][capacity + 1];
        return solveKnapsackRecursive(profits, weights, capacity, 0, cache);
    }

    private int solveKnapsackRecursive(int[] profits, int[] weights, int capacity, int currentIndex, Integer[][] cache) {
        // 基础情况：容量不足或所有物品已处理完
        if (capacity <= 0 || currentIndex >= weights.length) {
            return 0;
        }

        // 如果当前状态未计算过，则计算并缓存结果
        if (cache[currentIndex][capacity] == null) {
            // 选择当前物品的情况
            int include = 0;
            if (weights[currentIndex] <= capacity) {
                include = profits[currentIndex] 
                    + solveKnapsackRecursive(profits, weights, capacity - weights[currentIndex], currentIndex + 1, cache);
            }

            // 不选择当前物品的情况
            int exclude = solveKnapsackRecursive(profits, weights, capacity, currentIndex + 1, cache);

            // 取两种选择中的最大值并缓存结果
            cache[currentIndex][capacity] = Math.max(include, exclude);
        }

        return cache[currentIndex][capacity];
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码：自下而上迭代</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">自下而上迭代</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >public class Solution {
    public int solveKnapsack(int[] profits, int[] weights, int capacity) {
        if (capacity <= 0) {
            return 0;
        }

        int n = weights.length;

        // cache[i][c] 表示前 i 个物品在容量 c 下的最大利润
        int[][] cache = new int[n][capacity + 1];

        // 初始化第一列：容量为 0 时，利润始终为 0
        for (int i = 0; i < n; i++) {
            cache[i][0] = 0;
        }

        // 初始化第一行：只考虑第一个物品
        for (int c = 0; c <= capacity; c++) {
            if (weights[0] <= c) {
                cache[0][c] = profits[0];
            }
        }

        for (int i = 1; i < n; i++) {
            for (int c = 1; c <= capacity; c++) {
                // 包含当前物品
                int include = 0;
                if (weights[i] <= c) {
                    include = profits[i] + cache[i - 1][c - weights[i]];
                }

                // 不包含当前物品
                int exclude = cache[i - 1][c];

                cache[i][c] = Math.max(include, exclude);
            }
        }

        return cache[n - 1][capacity];
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<p>步骤演示：</p>
<ul>
<li><code>weights = [1, 2, 3]</code></li>
<li><code>profits = [6, 10, 16]</code></li>
<li><code>capacity = 4</code></li>
</ul>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看步骤演示</summary>
        <div>
            
<style>
    table {
        width: 100%;
        font-size: 18px;
    }
    tr, th, td {
        border: 2px solid #dee4eb;  
        padding: 5px;  
    }
</style>



<table>
    
        <caption>填充第一列</caption>
    
    
<tr style="text-align:center;">
    <td style="background-color:blue;"></td><td style="color:gold;background-color:red;">0</td><td style="color:gold;background-color:red;">1</td><td style="color:gold;background-color:red;">2</td><td style="color:gold;background-color:red;">3</td><td style="color:gold;background-color:red;">4</td>
</tr>
<tr style="text-align:center;">
    <td style="color:gold;background-color:red;">0</td><td>0</td><td></td><td></td><td></td><td></td>
</tr>
<tr style="text-align:center;">
    <td style="color:gold;background-color:red;">1</td><td>0</td><td></td><td></td><td></td><td></td>
</tr>
<tr style="text-align:center;">
    <td style="color:gold;background-color:red;">2</td><td>0</td><td></td><td></td><td></td><td></td>
</tr>    

</table>

<style>
    table {
        width: 100%;
        font-size: 18px;
    }
    tr, th, td {
        border: 2px solid #dee4eb;  
        padding: 5px;  
    }
</style>



<table>
    
        <caption>填充第一行</caption>
    
    
<tr style="text-align:center;">
    <td style="background-color:blue;"></td><td style="color:gold;background-color:red;">0</td><td style="color:gold;background-color:red;">1</td><td style="color:gold;background-color:red;">2</td><td style="color:gold;background-color:red;">3</td><td style="color:gold;background-color:red;">4</td>
</tr>
<tr style="text-align:center;">
    <td style="color:gold;background-color:red;">0</td><td>0</td><td>6</td><td>6</td><td>6</td><td>6</td>
</tr>
<tr style="text-align:center;">
    <td style="color:gold;background-color:red;">1</td><td>0</td><td></td><td></td><td></td><td></td>
</tr>
<tr style="text-align:center;">
    <td style="color:gold;background-color:red;">2</td><td>0</td><td></td><td></td><td></td><td></td>
</tr>    

</table>

<style>
    table {
        width: 100%;
        font-size: 18px;
    }
    tr, th, td {
        border: 2px solid #dee4eb;  
        padding: 5px;  
    }
</style>



<table>
    
        <caption>填充第二行</caption>
    
    
<tr style="text-align:center;">
    <td style="background-color:blue;"></td><td style="color:gold;background-color:red;">0</td><td style="color:gold;background-color:red;">1</td><td style="color:gold;background-color:red;">2</td><td style="color:gold;background-color:red;">3</td><td style="color:gold;background-color:red;">4</td>
</tr>
<tr style="text-align:center;">
    <td style="color:gold;background-color:red;">0</td><td>0</td><td>6</td><td>6</td><td>6</td><td>6</td>
</tr>
<tr style="text-align:center;">
    <td style="color:gold;background-color:red;">1</td><td>0</td><td>6</td><td>10</td><td>16</td><td>16</td>
</tr>
<tr style="text-align:center;">
    <td style="color:gold;background-color:red;">2</td><td>0</td><td></td><td></td><td></td><td></td>
</tr>    

</table>

<style>
    table {
        width: 100%;
        font-size: 18px;
    }
    tr, th, td {
        border: 2px solid #dee4eb;  
        padding: 5px;  
    }
</style>



<table>
    
        <caption>填充第三行</caption>
    
    
<tr style="text-align:center;">
    <td style="background-color:blue;"></td><td style="color:gold;background-color:red;">0</td><td style="color:gold;background-color:red;">1</td><td style="color:gold;background-color:red;">2</td><td style="color:gold;background-color:red;">3</td><td style="color:gold;background-color:red;">4</td>
</tr>
<tr style="text-align:center;">
    <td style="color:gold;background-color:red;">0</td><td>0</td><td>6</td><td>6</td><td>6</td><td>6</td>
</tr>
<tr style="text-align:center;">
    <td style="color:gold;background-color:red;">1</td><td>0</td><td>6</td><td>10</td><td>16</td><td>16</td>
</tr>
<tr style="text-align:center;">
    <td style="color:gold;background-color:red;">2</td><td>0</td><td>6</td><td>10</td><td>16</td><td style="background-color:grey;color:black">22</td>
</tr>    

</table>

<style>
    table {
        width: 100%;
        font-size: 18px;
    }
    tr, th, td {
        border: 2px solid #dee4eb;  
        padding: 5px;  
    }
</style>



<table>
    
        <caption>最大利润来源</caption>
    
    
<tr style="text-align:center;">
    <td style="background-color:blue;"></td><td style="color:gold;background-color:red;">0</td><td style="color:gold;background-color:red;">1</td><td style="color:gold;background-color:red;">2</td><td style="color:gold;background-color:red;">3</td><td style="color:gold;background-color:red;">4</td>
</tr>
<tr style="text-align:center;">
    <td style="color:gold;background-color:red;">0</td><td>0</td><td style="background-color:grey;color:black">6</td><td>6</td><td>6</td><td>6</td>
</tr>
<tr style="text-align:center;">
    <td style="color:gold;background-color:red;">1</td><td>0</td><td>6</td><td>10</td><td>16</td><td>16</td>
</tr>
<tr style="text-align:center;">
    <td style="color:gold;background-color:red;">2</td><td>0</td><td>6</td><td>10</td><td style="background-color:grey;color:black">16</td><td>22</td>
</tr>    

</table>

        </div>
    </details>
</div>
<hr>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码：空间优化 I</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">空间优化 I（二维滚动数组）</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >public class Solution {
    public int solveKnapsack(int[] profits, int[] weights, int capacity) {
        // 基本检查：容量小于等于 0 或数组为空或数组长度不一致
        if (capacity <= 0) {
            return 0;
        }

        int n = profits.length;
        // 滚动数组缓存，只需要两行交替存储
        int[][] cache = new int[2][capacity + 1];

        // 仅考虑第一个物品时的最大价值
        for (int c = 0; c <= capacity; c++) {
            if (weights[0] <= c) {
                cache[0][c] = profits[0];
            }
        }

        // 逐步计算子数组在每种容量下的最优解
        for (int i = 1; i < n; i++) {
            for (int c = 0; c <= capacity; c++) {
                int include = 0; // 包含当前物品
                int exclude = 0; // 不包含当前物品

                // 如果当前物品重量不超过容量，尝试包含当前物品
                if (weights[i] <= c) {
                    include = profits[i] + cache[(i - 1) % 2][c - weights[i]];
                }

                // 不包含当前物品的情况
                exclude = cache[(i - 1) % 2][c];

                // 当前容量下取最大值
                cache[i % 2][c] = Math.max(include, exclude);
            }
        }

        // 返回最后一个物品在最大容量下的最优解
        return cache[(n - 1) % 2][capacity];
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码：空间优化 II</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">空间优化 II（一维数组）</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >public class Solution {
    private static int solveKnapsack(int[] profits, int[] weights, int capacity) {
        // If the knapsack capacity is 0 or negative, no profit can be made
        if (capacity <= 0) {
            return 0;
        }

        // Initialize cache for the first item
        int n = profits.length;
        int[] cache = new int[capacity + 1];

        for (int c = 0; c <= capacity; c++) {
            if (c >= weights[0])
                cache[c] = profits[0];
        }

        // Fill the cache for all remaining items (1 to n-1)
        for (int i = 1; i < n; i++) {
            // Traverse the capacities in reverse to avoid reusing the same item
            for (int c = capacity; c >= weights[i]; c--) { 
                // Include the current item
                int include = profits[i] + cache[c - weights[i]];
                // Exclude the current item
                int exclude = cache[c];
                // Update cache with the maximum profit for the current capacity
                cache[c] = Math.max(include, exclude);
            }
        }

        // The last element in the cache will store the maximum profit that can be obtained with the given capacity
        return cache[capacity];
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="分割等和子集">分割等和子集<a hidden class="anchor" aria-hidden="true" href="#分割等和子集">#</a></h2>

<a href="https://leetcode.cn/problems/partition-equal-subset-sum" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码：暴力递归</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">暴力递归</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >public class Solution {
  public boolean canPartition(int[] nums) {
    int sum = Arrays.stream(nums).sum();

    if (sum % 2 == 1) {
      return false;
    }

    return canPartitionRecursive(nums, 0, sum / 2);    
  }

  private static boolean canPartitionRecursive(int[] nums, int currentIndex, int target) {
    // 如果目标和为 0，则找到一个子集
    if (target == 0) {
      return true;
    }

    // 如果遍历到数组末尾或目标值小于 0，则无法找到满足条件的子集
    if (currentIndex == nums.length || target < 0) {
      return false;
    }

    // 包含当前元素
    boolean include = canPartitionRecursive(nums, currentIndex + 1, target - nums[currentIndex]);
    // 不包含当前元素
    boolean exclude = canPartitionRecursive(nums, currentIndex + 1, target);

    // 如果包含或不包含当前元素的任一情况可以找到目标子集，则返回 true
    return include || exclude;
  }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<p>递归树分析：</p>
<ul>
<li>
<p><code>nums = [1, 2, 3, 4]</code></p>
</li>
<li>
<p><code>sum = 1 + 2 + 3 + 4 = 10</code></p>
</li>
<li>
<p><code>target = sum / 2 = 5</code></p>
</li>
<li>
<p><code>(index, target)</code></p>
</li>
</ul>
<pre class="mermaid">---
title: 分割等和子集：递归树分析
---
graph TD
    L0(("\(0,5\)")) --> L1(("\(1,4\)"))
    L0 -.-> R1(("\(1,5\)"))
    L1 --> L2_1(("\(2,2\)"))
    L1 -.-> R2_1(("\(2,4\)"))
    R1 --> L2_2(("\(2,3\)"))
    R1 -.-> R2_2(("\(2,5\)"))
    L2_1 --> L3_1(("\(3,-1\)"))
    L2_1 -.-> R3_1(("\(3,2\)"))
    R2_1 --> L3_2(("\(3,1\)"))
    R2_1 -.-> R3_2(("\(3,4\)"))
    R2_2 --> L3_4(("\(3,2\)"))
    R2_2 -.-> R3_4(("\(3,5\)"))
    R3_1 --> L4_2(("\(4,-2\)"))
    R3_1 -.-> R4_2(("\(4,2\)"))
    L3_2 --> L4_3(("\(4,-3\)"))
    L3_2 -.-> R4_3(("\(4,1\)"))
    L3_4 --> L4_7(("\(4,-2\)"))
    L3_4 -.-> R4_7(("\(4,2\)"))
    R3_4 --> L4_8(("\(4,1\)"))
    R3_4 -.-> R4_8(("\(4,5\)"))

    style L2_2 fill:lightblue,color:black
    style R3_2 fill:lightblue,color:black
    
    style L3_1 fill:red
    style L4_2 fill:red
    style R4_2 fill:red
    style R4_3 fill:red
    style L4_3 fill:red
    style R4_7 fill:red
    style L4_7 fill:red
    style R4_8 fill:red
    style L4_8 fill:red

    style L3_4 fill:purple,color:white
    style R3_1 fill:purple,color:white
</pre>
<hr>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码：记忆化递归</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">记忆化递归</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public boolean canPartition(int[] nums) {
        // 计算数组总和
        int sum = Arrays.stream(nums).sum();

        // 如果总和为奇数，不可能分割成两个和相等的子集
        if (sum % 2 == 1) {
            return false;
        }

        int target = sum / 2;
        // 使用缓存表记录子问题的解，避免重复计算
        Boolean[][] cache = new Boolean[nums.length][target + 1];
        return canPartitionRecursive(nums, 0, target, cache);
    }

    private static boolean canPartitionRecursive(int[] nums, int currentIndex, int target, Boolean[][] cache) {
        // 如果目标和为 0，说明找到一个子集
        if (target == 0) {
            return true;
        }

        // 如果遍历到数组末尾或目标值小于 0，无法找到满足条件的子集
        if (currentIndex == nums.length || target < 0) {
            return false;
        }

        if (cache[currentIndex][target] == null) {
            // 包含当前元素
            boolean include = canPartitionRecursive(nums, currentIndex + 1, target - nums[currentIndex], cache);
            // 不包含当前元素
            boolean exclude = canPartitionRecursive(nums, currentIndex + 1, target, cache);

            // 缓存当前子问题的结果
            cache[currentIndex][target] = include || exclude;
        }

        return cache[currentIndex][target];
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码：自下向上迭代</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">自下而上迭代</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public boolean canPartition(int[] nums) {
        // 计算数组总和
        int sum = Arrays.stream(nums).sum();

        // 如果总和为奇数，不可能分割成两个和相等的子集
        if (sum % 2 == 1) {
            return false;
        }

        int n = nums.length;
        int target = sum / 2;
        boolean[][] cache = new boolean[n][target + 1];

        // 目标和为 0 时，无需选择任何元素，因此为 true
        for (int i = 0; i < n; i++) {
            cache[i][0] = true;
        }

        // 只有第一个元素，且其值等于目标和，则为 true
        for (int t = 1; t <= target; t++) {
            if (nums[0] == t) {
                cache[0][t] = true;
            }
        }

        for (int i = 1; i < n; i++) {
            for (int t = 1; t <= target; t++) {
                boolean include = false;

                // 如果当前元素小于等于目标和 t，则尝试包含该元素
                if (nums[i] <= t) {
                    include = cache[i-1][t-nums[i]];
                } 

                // 不包含当前元素的情况
                boolean exclude = cache[i - 1][t];

                // 当前状态取包含或不包含两种情况的逻辑或
                cache[i][t] = include || exclude;
            }
        }

        return cache[n - 1][target];
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码：空间优化 I</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">空间优化 I（二维滚动数组）</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码：空间优化 II</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">空间优化 II（一维数组）</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {    
    public boolean canPartition(int[] nums) {
        // Calculate the total sum of the array
        int sum = Arrays.stream(nums).sum();

        // If the sum is odd, it cannot be partitioned into two equal subsets
        if (sum % 2 != 0) {
            return false;
        }

        // The target sum for one subset is half of the total sum
        int target = sum / 2;

        // DP array to track achievable sums up to the target value
        // cache[i] will be true if a subset with sum i is achievable
        boolean[] cache = new boolean[target + 1];
        cache[0] = true; // A sum of 0 is always achievable (by selecting no elements)

        // Iterate over each number in the array
        for (int num : nums) {
            // Update the DP table from right to left to avoid using the same number multiple times
            for (int i = target; i >= num; i--) {
                // If the current sum i - num was achievable, then sum i is also achievable by adding num
                cache[i] |= cache[i - num];
            }
        }

        // The answer is whether the target sum is achievable
        return cache[target];
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="最小子集和差">最小子集和差<a hidden class="anchor" aria-hidden="true" href="#最小子集和差">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p><strong>问题描述</strong></p>
<p>给定一组正整数，将该集合划分为两个子集，使它们的子集和之间的差最小。</p>
<p><strong>示例 1：</strong><br>
输入：</p>
<pre tabindex="0"><code>{1, 2, 3, 9}  
</code></pre><p>输出：</p>
<pre tabindex="0"><code>3  
</code></pre><p>解释：可以将给定集合划分为两个子集，使得它们的和之间的绝对差最小为 <code>3</code>。以下是两个子集：{1, 2, 3} 和 {9}。</p>
<p><strong>示例 2：</strong></p>
<p>输入：</p>
<pre tabindex="0"><code>{1, 2, 7, 1, 5}  
</code></pre><p>输出：</p>
<pre tabindex="0"><code>0  
</code></pre><p>解释：可以将给定集合划分为两个子集，使得它们的和之间的绝对差最小为 <code>0</code>。以下是两个子集：{1, 2, 5} 和 {7, 1}。</p>
<p><strong>示例 3：</strong></p>
<p>输入：</p>
<pre tabindex="0"><code>{1, 3, 100, 4}  
</code></pre><p>输出：</p>
<pre tabindex="0"><code>92  
</code></pre><p>解释：可以将给定集合划分为两个子集，使得它们的和之间的绝对差最小为 <code>92</code>。以下是两个子集：{1, 3, 4} 和 {100}。</p>
<p><strong>约束条件</strong></p>
<ul>
<li>$1 \leq n \leq 15$</li>
<li>$\text{nums.length} == 2 \times n$</li>
<li>$-10^7 \leq \text{nums[i]} \leq 10^7$</li>
</ul>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE：暴力递归</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">暴力解法</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int canPartition(int[] nums) {
        return canPartitionRecursive(nums, 0, 0, 0);
    }

    private static int canPartitionRecursive(int[] nums, int currentIndex, int sum1, int sum2) {
        // 基本条件：当所有元素都被分配完时，返回两个子集和的绝对差
        if (currentIndex == nums.length) {
            return Math.abs(sum1 - sum2);
        }

        // 选择将当前元素加入到子集1中
        int include = canPartitionRecursive(nums, currentIndex + 1, sum1 + nums[currentIndex], sum2);
        // 选择将当前元素加入到子集2中
        int exclude = canPartitionRecursive(nums, currentIndex + 1, sum1, sum2 + nums[currentIndex]);

        // 返回两种选择中差值的最小值
        return Math.min(include, exclude);
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<p>递归树分析：</p>
<ul>
<li><code>nums = [1, 2, 3]</code></li>
<li><code>(index, sum1, sum2)</code></li>
</ul>
<pre class="mermaid">---
title: 最小子集和差：递归树分析
---
graph TD
    L0["\(0,0,0\)"] --> L1["\(1,1,0\)"]
    L0 -.-> R1["\(1,0,1\)"]
    
    L1 --> L2["\(2,3,0\)"]
    L1 -.-> R2["\(2,1,2\)"]

    R1 --> L3["\(2,2,1\)"]
    R1 -.-> R3["\(2,0,3\)"]

    L2 --> L4["\(3,6,0\)"] --> r1((6))
    L2 -.-> R4["\(3,3,3\)"] --> r2((0))

    R2 --> L5["\(3,4,2\)"] --> r3((2))
    R2 -.-> R5["\(3,1,5\)"] --> r4((4))

    L3 --> L6["\(3,5,1\)"] --> r5((4))
    L3 -.-> R6["\(3,2,4\)"] --> r6((2))

    R3 --> L7["\(3,3,3\)"] --> r7((0))
    R3 -.-> R7["\(3,0,6\)"] --> r8((6))
</pre>
<hr>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码：记忆化递归</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

class Solution {
    public int canPartition(int[] nums) {
        int totalSum = Arrays.stream(nums).sum();
        Integer[][] cache = new Integer[nums.length][totalSum + 1];
        return this.canPartitionRecursive(nums, 0, 0, 0, cache);
    }
    
    private int canPartitionRecursive(int[] nums, int currentIndex, int sum1, int sum2, Integer[][] cache) {
        // 基础条件：如果已经处理完数组的所有元素，返回两个子集的绝对和差
        if (currentIndex == nums.length) {
            return Math.abs(sum1 - sum2);
        }

        // 如果缓存中不存在当前子问题的结果，则计算并存入缓存
        if (cache[currentIndex][sum1] == null) {
            // 选择将当前元素加入子集 1
            int include = canPartitionRecursive(nums, currentIndex + 1, sum1 + nums[currentIndex], sum2, cache);
            // 选择将当前元素加入子集 2
            int exclude = canPartitionRecursive(nums, currentIndex + 1, sum1, sum2 + nums[currentIndex], cache);

            // 取两种选择中子集和差的最小值，存入缓存
            cache[currentIndex][sum1] = Math.min(include, exclude);
        }

        // 返回缓存中的结果
        return cache[currentIndex][sum1];
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看代码：自下而上迭代</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">自下而上迭代</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

class Solution {
    public int canPartition(int[] nums) {
        int totalSum = Arrays.stream(nums).sum();

        int n = nums.length;

        // cache[i][j] 表示前 i 个数是否可以组成和为 j
        boolean[][] cache = new boolean[n][totalSum / 2 + 1];

        // 初始化：和为 0 时总能成立
        for (int i = 0; i < n; i++) {
            cache[i][0] = true;
        }

        // 初始化第一个数字的情况
        for (int i = 0; i <= totalSum / 2; i++) {
            if (nums[0] == i) {
                cache[0][i] = true;
            }
        }

        
        for (int i = 1; i < n; i++) {
            for (int j = 1; j <= totalSum / 2; j++) {
                // 选择当前数字（需确保当前数字不超过目标和）
                boolean include = nums[i] <= j && cache[i - 1][j - nums[i]];
                 // 不选择当前数字
                boolean exclude = cache[i - 1][j];
                
                cache[i][j] = include || exclude;
            }
        }


        int sum1 = 0;
        // 从最后一行逆序查找最大子集和
        for (int i = totalSum / 2; i >= 0; i--) {
            if (cache[n-1][i]) {
                sum1 = i;
                break;
            }
        }
        int sum2 = totalSum - sum1;

        return Math.abs(sum1 - sum2);
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="目标和">目标和<a hidden class="anchor" aria-hidden="true" href="#目标和">#</a></h2>

<a href="https://leetcode.cn/problems/target-sum" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">暴力解法</button>



<button class="tab_btn ">记忆化递归</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        return findTargetSumWaysRecursive(nums, target, 0, 0);
    }

    private static int findTargetSumWaysRecursive(int[] nums, int target, int sum, int i) {
        // 递归终止条件：如果已处理完所有数字，检查当前和是否等于目标值
        if (i == nums.length) {
            return sum == target ? 1 : 0;
        }

        // 考虑当前数字添加 '+' 符号
        int add = findTargetSumWaysRecursive(nums, target, sum + nums[i], i + 1);
        // 考虑当前数字添加 '-' 符号
        int subtract = findTargetSumWaysRecursive(nums, target, sum - nums[i], i + 1);

        // 返回两种可能的结果之和
        return add + subtract;
    }
}
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        Map&lt;String, Integer&gt; cache = new HashMap&lt;&gt;(); // 缓存，存储中间结果
        return findTargetSumWaysRecursive(nums, target, 0, 0, cache);
    }

    private static int findTargetSumWaysRecursive(int[] nums, int target, int sum, int i, Map&lt;String, Integer&gt; cache) {
        // 递归终止条件：如果已处理完所有数字，检查当前和是否等于目标值
        if (i == nums.length) {
            return sum == target ? 1 : 0;
        }

        // 使用当前索引和累加和作为缓存的键
        String key = i + "," + sum;

        // 如果缓存中不存在当前状态的结果，进行递归计算
        if (cache.get(key) == null) {
            // 当前数字添加 '+' 符号
            int add = findTargetSumWaysRecursive(nums, target, sum + nums[i], i + 1, cache);
            // 当前数字添加 '-' 符号
            int subtract = findTargetSumWaysRecursive(nums, target, sum - nums[i], i + 1, cache);
            // 将结果存入缓存
            cache.put(key, add + subtract);
        }

        // 返回缓存中存储的结果
        return cache.get(key);
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<p>递归树分析：</p>
<ul>
<li><code>nums = [1, 2, 2], target = 1</code></li>
<li><code>(index, sum)</code></li>
</ul>
<pre class="mermaid">---
title: 目标和：递归树分析
---
graph TD
    A(("\(0,0\)")) -->|\+| B(("\(1,1\)"))
    A -.->|−| C(("\(1,-1\)"))
    
    B -->|\+| D(("\(2,3\)"))
    B -.->|−| E(("\(2,-1\)"))
    C -->|\+| F(("\(2,1\)"))
    C -.->|−| G(("\(2,-3\)"))

    D -->|\+| H(("\(3,5\)"))
    D -.->|−| I(("\(3,1\)"))
    E -->|\+| J(("\(3,1\)"))
    E -.->|−| K(("\(3,-3\)"))
    F -->|\+| L(("\(3,3\)"))
    F -.->|−| M(("\(3,-1\)"))
    G -->|\+| N(("\(3,-1\)"))
    G -.->|−| O(("\(3,-5\)"))

    style I fill:lightblue,color:black
    style J fill:lightblue,color:black
</pre>
<hr>
<h2 id="heading-1"><a hidden class="anchor" aria-hidden="true" href="#heading-1">#</a></h2>
<h2 id="完全背包模式">完全背包模式<a hidden class="anchor" aria-hidden="true" href="#完全背包模式">#</a></h2>
<h2 id="零钱兑换">零钱兑换<a hidden class="anchor" aria-hidden="true" href="#零钱兑换">#</a></h2>

<a href="https://leetcode.cn/problems/coin-change" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">暴力解法</button>



<button class="tab_btn ">记忆化递归</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int coinChange(int[] coins, int amount) {
        // 调用递归函数计算最小硬币数
        int result = coinChangeRecursive(coins, amount, 0);
        // 如果结果是Integer.MAX_VALUE（表示无解），返回-1；否则返回结果
        return result == Integer.MAX_VALUE ? -1 : result;
    }

    private static int coinChangeRecursive(int[] coins, int amount, int i) {
        // 基本情况：如果金额为0，返回0表示不需要更多硬币
        if (amount == 0) {
            return 0;
        }

        // 基本情况：如果硬币用完或金额为负，返回一个较大值表示无解
        if (i == coins.length || amount < 0) {
            return Integer.MAX_VALUE;
        }

        // 尝试包含当前硬币
        int include = coinChangeRecursive(coins, amount - coins[i], i);
        // 如果包含当前硬币的结果有效（不是Integer.MAX_VALUE），加1表示使用了一个硬币
        if (include != Integer.MAX_VALUE) {
            include += 1;
        }

        // 尝试跳过当前硬币
        int exclude = coinChangeRecursive(coins, amount, i + 1);

        // 返回两种选择中较小的值
        return Math.min(include, exclude);
    }
}
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int coinChange(int[] coins, int amount) {
        // 创建缓存（哈希表）用于存储子问题的结果
        Map&lt;String, Integer&gt; cache = new HashMap&lt;&gt;();
        // 调用递归函数计算最小硬币数
        int result = coinChangeRecursive(coins, amount, 0, cache);
        // 如果结果是Integer.MAX_VALUE（表示无解），返回-1；否则返回结果
        return result == Integer.MAX_VALUE ? -1 : result;
    }

    private static int coinChangeRecursive(int[] coins, int amount, int i, Map&lt;String, Integer&gt; cache) {
        // 基本情况：如果金额为0，返回0表示不需要更多硬币
        if (amount == 0) {
            return 0;
        }

        // 基本情况：如果硬币用完或金额为负，返回一个较大值表示无解
        if (i == coins.length || amount < 0) {
            return Integer.MAX_VALUE;
        }

        // 生成当前子问题的键，用于标识缓存中的结果
        String key = i + "," + amount;

        // 如果当前子问题的结果不在缓存中，进行计算
        if (cache.get(key) == null) {
            // 尝试包含当前硬币
            int include = coinChangeRecursive(coins, amount - coins[i], i, cache);
            // 如果包含当前硬币的结果有效（不是Integer.MAX_VALUE），加1表示使用了一个硬币
            if (include != Integer.MAX_VALUE) {
                include += 1;
            }

            // 尝试跳过当前硬币
            int exclude = coinChangeRecursive(coins, amount, i + 1, cache);

            // 将两种选择的最小值存入缓存
            cache.put(key, Math.min(include, exclude));
        }

        // 返回缓存中存储的结果
        return cache.get(key);
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="heading-2"><a hidden class="anchor" aria-hidden="true" href="#heading-2">#</a></h2>
<h2 id="最长公共子串模式">最长公共子串模式<a hidden class="anchor" aria-hidden="true" href="#最长公共子串模式">#</a></h2>
<h2 id="最长公共子串长度">最长公共子串长度<a hidden class="anchor" aria-hidden="true" href="#最长公共子串长度">#</a></h2>


<p><details >
  <summary markdown="span">点击查看题目</summary>
  <p>给定两个字符串 <code>s1</code> 和 <code>s2</code>，找到它们之间最长公共子串的长度。</p>
<p><strong>示例 1：</strong></p>
<p>输入:<br>
<code>s1 = &quot;abdca&quot;</code><br>
<code>s2 = &quot;cbda&quot;</code><br>
输出:
<code>2</code><br>
解释: 最长的公共子串是 <code>&quot;bd&quot;</code>。</p>
<p><strong>示例 2：</strong></p>
<p>输入:<br>
<code>s1 = &quot;passport&quot;</code><br>
<code>s2 = &quot;ppsspt&quot;</code></p>
<p>输出:
<code>3</code><br>
解释: 最长的公共子串是 <code>&quot;ssp&quot;</code>。</p>
<p><strong>限制条件：</strong></p>
<ul>
<li><code>1 &lt;= s1.length, s2.length &lt;= 1000</code></li>
<li><code>s1</code> 和 <code>s2</code> 仅由小写英文字母组成。</li>
</ul>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">暴力解法</button>



<button class="tab_btn ">记忆化递归</button>



<button class="tab_btn ">自下而上</button>



<button class="tab_btn ">空间优化</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {

    /**
     * 查找两个字符串的最长公共子串长度。
     * 
     * @param s1 字符串1
     * @param s2 字符串2
     * @return 最长公共子串的长度
     */
    public int findLCSLength(String s1, String s2) {
        return findLCSLengthRecursive(s1, s2, 0, 0, 0);
    }

    /**
     * 使用递归查找最长公共子串长度。
     * 
     * @param s1    字符串1
     * @param s2    字符串2
     * @param i1     s1 当前字符的索引
     * @param i2     s2 当前字符的索引
     * @param count 当前匹配子串的长度
     * @return      最长公共子串的长度
     */
    private int findLCSLengthRecursive(String s1, String s2, int i1, int i2, int count) {
        // 基本结束条件：如果任一字符串达到末尾，返回当前匹配的长度
        if (i1 >= s1.length() || i2 >= s2.length()) {
            return count;
        }

        // 如果当前字符匹配，递归计算匹配长度并更新 count
        int newCount = count;
        if (s1.charAt(i1) == s2.charAt(i2)) {
            newCount = findLCSLengthRecursive(s1, s2, i1 + 1, i2 + 1, count + 1);
        }

        // 跳过当前字符分别从两个方向继续递归，重置 count
        int skipS1 = findLCSLengthRecursive(s1, s2, i1 + 1, i2, 0);
        int skipS2 = findLCSLengthRecursive(s1, s2, i1, i2 + 1, 0);

        // 返回三者中最大的值：继续匹配、新分支1、新分支2
        return Math.max(newCount, Math.max(skipS1, skipS2));
    }
}
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int findLCSLength(String s1, String s2) {
        Map&lt;String, Integer&gt; cache = new HashMap&lt;&gt;();
        return findLCSLengthRecursive(s1, s2, 0, 0, 0, cache);
    }

    private int findLCSLengthRecursive(String s1, String s2, int i1, int i2, int count, Map&lt;String, Integer&gt; cache) {
        // 递归结束条件：如果任一索引超出字符串长度，返回当前匹配长度
        if (i1 >= s1.length() || i2 >= s2.length()) {
            return count;
        }

        // 当前字符匹配时，递归计算匹配长度
        int newCount = count;
        if (s1.charAt(i1) == s2.charAt(i2)) {
            newCount = findLCSLengthRecursive(s1, s2, i1 + 1, i2 + 1, count + 1, cache);
        }

        String key = i1 + "," + i2 + "," + count;
        if (cache.get(key) == null) {
            // 分别跳过 s1 或 s2 当前字符的递归分支，重置匹配计数
            int skipS1 = findLCSLengthRecursive(s1, s2, i1 + 1, i2, 0, cache);
            int skipS2 = findLCSLengthRecursive(s1, s2, i1, i2 + 1, 0, cache);

            // 缓存结果：当前匹配长度与跳过分支的最大值
            cache.put(key, Math.max(newCount, Math.max(skipS1, skipS2)));
        }

        return cache.get(key);
    }
}
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int findLCSLength(String s1, String s2) {
        // dp[i][j]表示s1的前i个字符与s2的前j个字符的最长公共子串长度
        int[][] dp = new int[s1.length() + 1][s2.length() + 1];
        int maxLength = 0;
        for (int i = 1; i <= s1.length(); i++) {
            for (int j = 1; j <= s2.length(); j++) {
                // 如果当前字符相等，最长公共子串长度加1
                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                // else {
                //     // 如果不相等，当前公共子串长度为0（dp[i][j]默认就是0）
                //     dp[i][j] = 0;
                // }
                // 更新最长公共子串的长度
                maxLength = Math.max(maxLength, dp[i][j]);
            }
        }

        return maxLength;
    }
}
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int findLCSLength(String s1, String s2) {
        // dp[i][j]表示s1的前i个字符与s2的前j个字符的最长公共子串长度
        int[][] dp = new int[2][s2.length() + 1];
        int maxLength = 0;
        for (int i = 1; i <= s1.length(); i++) {
            for (int j = 1; j <= s2.length(); j++) {
                // 如果当前字符相等，最长公共子串长度加1
                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                    dp[i % 2][j] = dp[(i - 1) % 2][j - 1] + 1;
                } else {
                    dp[i % 2][j] = 0;
                }
                // 更新最长公共子串的长度
                maxLength = Math.max(maxLength, dp[i % 2][j]);
            }
        }

        return maxLength;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<p>递归树分析：</p>
<ul>
<li><code>s1 = &quot;ab&quot;, s2 = &quot;cba&quot;</code></li>
<li><code>(i1, i2, count)</code></li>
</ul>
<pre class="mermaid">---
title: 最长公共子串长度：递归树分析
---
graph TD
    L0["(0,0,0)"]
    L0 === L1["❌"]
    L0 --- M1["(1,0,0)"]
    L0 -.- R1["(0,1,0)"]

    M1 === M2L["❌"]
    M1 --- M2M["(2,0,0)"]
    M1 -.- M2R["(1,1,0)"]

    R1 === R2L["❌"]
    R1 --- R2M["(1,1,0)"]
    R1 -.- R2R["(0,2,0)"]

    M2R === R3L["(2,2,1)"]
    M2R --- R3M["(2,1,0)"]
    M2R -.- R3R["(1,2,0)"]

    R3L --- r2["1"]
    R3M --- r3["0"]
    R3R --- r4["0"]

    style R3L fill:blue
    style r2 fill:blue
    style M2R fill:green
    style R2M fill:green
</pre>
<hr>
<h2 id="最长公共子序列">最长公共子序列<a hidden class="anchor" aria-hidden="true" href="#最长公共子序列">#</a></h2>

<a href="https://leetcode.cn/problems/longest-common-subsequence" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">暴力解法</button>



<button class="tab_btn ">记忆化递归</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        return findLCSRecursive(text1, text2, 0, 0);
    }

    private static int findLCSRecursive(String s1, String s2, int i1, int i2) {
        // 如果任一字符串已遍历完，返回0
        if (i1 == s1.length() || i2 == s2.length()) {
            return 0;
        }

        // 如果当前字符匹配，跳过当前字符并累加1
        if (s1.charAt(i1) == s2.charAt(i2)) {
            return 1 + findLCSRecursive(s1, s2, i1 + 1, i2 + 1);
        }

        // 否则，分别跳过s1和s2的当前字符，取两种情况的最大值
        int skipS1 = findLCSRecursive(s1, s2, i1, i2 + 1);
        int skipS2 = findLCSRecursive(s1, s2, i1 + 1, i2);

        return Math.max(skipS1, skipS2);
    }
}
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        Map&lt;String, Integer&gt; cache = new HashMap&lt;&gt;();
        return findLCSRecursive(text1, text2, 0, 0, cache);
    }

    private static int findLCSRecursive(String s1, String s2, int i1, int i2, Map&lt;String, Integer&gt; cache) {
        // 如果任一字符串已遍历完，返回0
        if (i1 == s1.length() || i2 == s2.length()) {
            return 0;
        }

        String key = i1 + "|" + i2;
        if (cache.get(key) == null) {
            // 如果当前字符匹配，跳过当前字符并累加1
            if (s1.charAt(i1) == s2.charAt(i2)) {
                cache.put(key, 1 + findLCSRecursive(s1, s2, i1 + 1, i2 + 1, cache));
            } else {
                // 否则，分别跳过s1和s2的当前字符，取两种情况的最大值
                int skipS1 = findLCSRecursive(s1, s2, i1, i2 + 1, cache);
                int skipS2 = findLCSRecursive(s1, s2, i1 + 1, i2, cache);
                cache.put(key, Math.max(skipS1, skipS2));
            }
        }

        return cache.get(key);
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<p>递归树分析：</p>
<ul>
<li><code>s1 = &quot;aba&quot;, s2 = &quot;acb&quot;</code></li>
<li><code>(i1, i2)</code></li>
</ul>
<pre class="mermaid">---
title: 递归树分析：最长公共子序列
---
graph TD
    L0(("\(0,0\)"))
    L0 ---|"\+1"| L1(("\(1,1\)"))
    L0 --- R1["❌"]
    L1 --- L2L(("\(1,2\)"))
    L1 --- L2R(("\(2,1\)"))
    L2L ---|"\+1"| L3LL(("\(2,3\)"))
    L2L --- L3LR["❌"]
    L2R --- L3RL(("\(3,1\)"))
    L2R --- L3RR(("\(2,2\)"))
    L3RR --- L4L(("\(3, 2\)"))
    L3RR --- L4R(("\(2, 3\)"))

    L3LL --- r1[0]
    L3RL --- r2[0]
    L4L --- r3[0]
    L4R --- r4[0]

    style L3LL fill:blue
    style L4R fill:blue
</pre>
<hr>
<h2 id="两个字符串的删除操作">两个字符串的删除操作<a hidden class="anchor" aria-hidden="true" href="#两个字符串的删除操作">#</a></h2>

<a href="https://leetcode.cn/problems/delete-operation-for-two-strings" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">暴力解法</button>



<button class="tab_btn ">记忆化递归</button>


</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int minDistance(String word1, String word2) {
        // 找到 word1 和 word2 的最长公共子序列（LCS）长度
        int lengthOfLCS = findLCSLengthRecursive(word1, word2, 0, 0);
        // 删除操作次数 = word1 长度 - LCS 长度
        int minDeleted = word1.length() - lengthOfLCS;
        // 插入操作次数 = word2 长度 - LCS 长度
        int minInserted = word2.length() - lengthOfLCS;

        // 总操作次数为删除和插入次数之和
        return minDeleted + minInserted;
    }

    private static int findLCSLengthRecursive(String word1, String word2, int i1, int i2) {
        if (i1 == word1.length() || i2 == word2.length()) {
            return 0;
        }

        // 当前字符相等，LCS 长度加 1，继续递归
        if (word1.charAt(i1) == word2.charAt(i2)) {
            return 1 + findLCSLengthRecursive(word1, word2, i1 + 1, i2 + 1);
        }
        
        // 当前字符不相等，尝试跳过 word1 或 word2 的当前字符
        int skipWord1 = findLCSLengthRecursive(word1, word2, i1 + 1, i2);
        int skipWord2 = findLCSLengthRecursive(word1, word2, i1, i2 + 1);

        return Math.max(skipWord1, skipWord2);
    }
}
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int minDistance(String word1, String word2) {
        // 缓存用于记忆化递归，避免重复计算
        Map&lt;String, Integer&gt; cache = new HashMap&lt;&gt;();
        // 找到 word1 和 word2 的最长公共子序列（LCS）长度
        int lengthOfLCS = findLCSLengthRecursive(word1, word2, 0, 0, cache);
        // 删除操作次数 = word1 长度 - LCS 长度
        int minDeleted = word1.length() - lengthOfLCS;
        // 插入操作次数 = word2 长度 - LCS 长度
        int minInserted = word2.length() - lengthOfLCS;

        // 总操作次数为删除和插入次数之和
        return minDeleted + minInserted;
    }

    private static int findLCSLengthRecursive(String word1, String word2, int i1, int i2, Map&lt;String, Integer&gt; cache) {
        if (i1 == word1.length() || i2 == word2.length()) {
            return 0;
        }

        String key = i1 + "," + i2;
        // 如果缓存中没有当前子问题的结果，计算并存储
        if (cache.get(key) == null) {
            if (word1.charAt(i1) == word2.charAt(i2)) {
                // 当前字符相等，LCS 长度加 1，继续递归
                cache.put(key, 1 + findLCSLengthRecursive(word1, word2, i1 + 1, i2 + 1, cache));
            } else {
                // 当前字符不相等，尝试跳过 word1 或 word2 的当前字符
                int skipWord1 = findLCSLengthRecursive(word1, word2, i1 + 1, i2, cache);
                int skipWord2 = findLCSLengthRecursive(word1, word2, i1, i2 + 1, cache);
                // 取两种情况的最大值作为当前结果
                cache.put(key, Math.max(skipWord1, skipWord2));
            }
        }

        return cache.get(key);
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<hr>
<h2 id="最长递增子序列待定">最长递增子序列（待定）<a hidden class="anchor" aria-hidden="true" href="#最长递增子序列待定">#</a></h2>

<a href="https://leetcode.cn/problems/longest-increasing-subsequence" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">暴力解法</button>



<button class="tab_btn ">记忆化递归</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="无矛盾的最佳球队待定">无矛盾的最佳球队（待定）<a hidden class="anchor" aria-hidden="true" href="#无矛盾的最佳球队待定">#</a></h2>

<a href="https://leetcode.cn/problems/best-team-with-no-conflicts" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">暴力解法</button>



<button class="tab_btn ">记忆化递归</button>



<button class="tab_btn ">自下而上迭代</button>



<button class="tab_btn ">空间优化</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="回文子序列模式">回文子序列模式<a hidden class="anchor" aria-hidden="true" href="#回文子序列模式">#</a></h2>
<h2 id="最长回文子序列">最长回文子序列<a hidden class="anchor" aria-hidden="true" href="#最长回文子序列">#</a></h2>

<a href="https://leetcode.cn/problems/longest-palindromic-subsequence" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">暴力解法</button>



<button class="tab_btn ">记忆化递归</button>



<button class="tab_btn ">自下而上迭代</button>



<button class="tab_btn ">空间优化</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int longestPalindromeSubseq(String s) {
        return getLPSRecursive(s, 0, s.length() - 1);
    }

    private static int getLPSRecursive(String s, int start, int end) {
        // 如果起始索引超过结束索引，返回0（无有效子序列）
        if (start > end) {
            return 0;
        }

        // 如果起始索引等于结束索引，返回1（单个字符是回文）
        if (start == end) {
            return 1;
        }

        // 如果两端字符相等，继续递归处理中间部分，同时长度增加2
        if (s.charAt(start) == s.charAt(end)) {
            return 2 + getLPSRecursive(s, start + 1, end - 1);
        }

        // 计算跳过起始字符或结束字符的两种情况的最大值
        int skipStart = getLPSRecursive(s, start + 1, end);
        int skipEnd = getLPSRecursive(s, start, end - 1);

        return Math.max(skipStart, skipEnd);
    }
}
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="最长回文子串">最长回文子串<a hidden class="anchor" aria-hidden="true" href="#最长回文子串">#</a></h2>

<a href="https://leetcode.cn/problems/longest-palindromic-substring" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">暴力解法</button>



<button class="tab_btn ">记忆化递归</button>



<button class="tab_btn ">自下而上迭代</button>



<button class="tab_btn ">空间优化</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="回文子串">回文子串<a hidden class="anchor" aria-hidden="true" href="#回文子串">#</a></h2>

<a href="https://leetcode.cn/problems/palindromic-substrings" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">暴力解法</button>



<button class="tab_btn ">记忆化递归</button>



<button class="tab_btn ">自下而上迭代</button>



<button class="tab_btn ">空间优化</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="huawei-od">Huawei OD<a hidden class="anchor" aria-hidden="true" href="#huawei-od">#</a></h2>
<h2 id="玩牌高手100分">玩牌高手【100分】<a hidden class="anchor" aria-hidden="true" href="#玩牌高手100分">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>一、题目描述</strong></p>
<p>给定一个长度为 <code>n</code> 的整型数组，表示选手在 <code>n</code> 轮内可选择的牌面分数。选手需要基于以下规则选牌，请计算在所有轮结束后，选手可以获得的最高总分数。</p>
<p>选择规则如下：</p>
<ol>
<li>在每一轮，选手可以选择获取该轮牌面分数，则其总分数加上该轮的分数，更新为新的总分数；</li>
<li>选手也可以跳过当前轮牌面，直接进入下一轮。如果选择跳过，则当前总分数恢复为三轮前的总分数。如果当前轮次小于等于3（即在第1、2、3轮选择跳过），则总分数置为0；</li>
<li>选手的初始总分数为0，并且必须依次参加每一轮。</li>
</ol>
<p><strong>二、输入描述</strong></p>
<ul>
<li>第一行输入一个由逗号分隔的字符串，表示每轮的牌面分数。<code>1 &lt;= n &lt;= 20</code>。</li>
<li>每个分数为整数，范围是 <code>-100 &lt;= 分数值 &lt;= 100</code>。</li>
</ul>
<p><strong>三、输出描述</strong></p>
<p>输出选手在所有轮结束后获得的最高总分数。</p>
<p><strong>四、输入输出示例</strong></p>
<p><strong>输入：</strong></p>
<pre tabindex="0"><code>2,-3,-7,4,3,4,-2,-7
</code></pre><p><strong>输出：</strong></p>
<pre tabindex="0"><code>7
</code></pre><p><strong>说明</strong></p>
<ul>
<li>轮次 1：选手选择分数 2，总分 = 2。</li>
<li>轮次 2：选择分数 -3，当前总分为 2 + (-3) = -1；如果跳过当前轮，则总分数为 0（因为跳过前三轮总分归0）。</li>
<li>轮次 3：选择分数 -7，当前总分为 -1 + (-7) = -8；若跳过，则总分数为 0。</li>
<li>轮次 4：选择分数 4，总分为 0 + 4 = 4。</li>
<li>轮次 5：选择分数 3，总分为 4 + 3 = 7。</li>
<li>轮次 6：选择分数 4，总分为 7 + 4 = 11。</li>
<li>轮次 7：选择分数 -2，总分为 11 + (-2) = 9。如果选择跳过此轮，则恢复为三轮前的总分数 7，9 大于 7，因此不跳过。</li>
<li>轮次 8：选择分数 -7，总分为 9 + (-7) = 2。如果选择跳过，则恢复为三轮前的总分数 7，7 大于 2，因此跳过此轮。</li>
</ul>
<p>最终输出为 7。</p>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

/**
 * @author Signal Yu
 * @since 2024-11-30
 */
public class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 输入并转换为整数数组
        int[] scores = Arrays.stream(in.nextLine().trim().split(","))
                .mapToInt(Integer::parseInt)
                .toArray();

        // 获取结果并输出
        int result = getMaximumScore(scores);
        System.out.println(result);
    }

    private static int getMaximumScore(int[] scores) {
        int n = scores.length;

        // dp数组，用于存储每轮结束后的最大得分
        int[] dp = new int[n + 1];
        dp[0] = 0; // 初始化总分为0

        // 动态规划，遍历每一轮
        for (int i = 1; i <= n; i++) {
            // 选当前轮的牌面分数
            int current = dp[i - 1] + scores[i - 1];

            // 如果当前轮次小于等于3，跳过则总分归零
            if (i <= 3) {
                dp[i] = Math.max(current, 0);
            } else {
                // 如果轮次大于3，可以选择跳过该轮
                dp[i] = Math.max(current, dp[i - 3]);
            }
        }

        return dp[n]; // 返回最后的最大总分
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="跳格子2100分---divide--conquer">跳格子2【100分】&ndash; Divide &amp; Conquer<a hidden class="anchor" aria-hidden="true" href="#跳格子2100分---divide--conquer">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>一、题目描述</strong></p>
<p>小明和朋友玩跳格子游戏，游戏中有 <code>n</code> 个连续的格子组成一个圆圈，每个格子上有不同的得分。小朋友可以选择从任意格子开始跳跃，但必须遵循以下规则：</p>
<ul>
<li>不能跳到连续的格子；</li>
<li>不能回头跳；</li>
<li>不能跨越一圈。</li>
</ul>
<p>给定一个表示每个格子得分的非负整数数组，计算在遵循规则的前提下，能够获得的最高分数。</p>
<p><strong>二、输入描述</strong></p>
<p>输入一个非负整数数组，表示每个格子的得分，其中数组的第一个格子和最后一个格子首尾相连。</p>
<p>例如，输入：<code>[2, 3, 2]</code> 表示有 3 个格子，得分分别为 2、3 和 2。</p>
<p><strong>三、输出描述</strong></p>
<p>输出能够获得的最高得分。</p>
<p><strong>四、测试用例</strong></p>
<p><strong>输入1：</strong></p>
<pre tabindex="0"><code>[2, 3, 2]
</code></pre><p><strong>输出1：</strong></p>
<pre tabindex="0"><code>3
</code></pre><p><strong>解释：</strong></p>
<ul>
<li>不能从第一个格子跳到第三个格子，因为第一个格子和最后一个格子首尾相连，不满足题中要求的不能超过一圈。</li>
</ul>
<p><strong>输入2：</strong></p>
<pre tabindex="0"><code>[1, 2, 9, 4, 5]
</code></pre><p><strong>输出2：</strong></p>
<pre tabindex="0"><code>15
</code></pre><p><strong>解释：</strong></p>
<ul>
<li>小朋友可以选择从第 1 个格子（得分为 1）跳到第 3 个格子（得分为 9），然后跳到第 5 个格子（得分为 5），获得的总分为 <code>1 + 9 + 5 = 15</code>。</li>
</ul>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

/**
 * @author Signal Yu
 * @since 2024-11-30
 */
public class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        int[] scores = Arrays.stream(in.nextLine().trim().split(" "))
                .mapToInt(Integer::parseInt)
                .toArray();

        // Calculate maximum score
        int result = getMaxScore(scores);

        // Output the result
        System.out.println(result);
    }

    private static int getMaxScore(int[] scores) {
        int n = scores.length;

        // Case 1: Including the first cell but excluding the last cell
        int score1 = calculateScore(scores, 0, n - 2);
        // Case 2: Excluding the first cell but including the last cell
        int score2 = calculateScore(scores, 1, n - 1);

        // Return the maximum of the two cases
        return Math.max(score1, score2);
    }

    private static int calculateScore(int[] scores, int start, int end) {
        int n = end - start + 1;
        if (n == 1) {
            return scores[0];
        }

        int[] dp = new int[n];
        // Initialization: The first cell is the score of the start position
        dp[0] = scores[start];
        // The second cell is the maximum of the first and second grid cells
        dp[1] = Math.max(scores[start], scores[start + 1]);

        // For each subsequent cell, either take it or skip it
        for (int i = 2; i < n; i++) {
            // Include the current cell
            int include = scores[start + i] + dp[i - 2];
            // Exclude the current cell
            int exclude = dp[i - 1];

            dp[i] = Math.max(include, exclude);
        }

        // Return the maximum score that can be obtained up to the end index
        return dp[n - 1];
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="猴子爬山100分">猴子爬山【100分】<a hidden class="anchor" aria-hidden="true" href="#猴子爬山100分">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>一、题目描述</strong></p>
<p>一天，一只顽皮的猴子想从山脚爬到山顶，途中需要经过一个有N个台阶的阶梯。然而，这只猴子有一个习惯：每次跳跃时，它只能选择跳1步或3步。请你计算，猴子有多少种不同的方式能够跳上这个阶梯？</p>
<p><strong>二、输入描述</strong></p>
<p>输入一个整数N $(0 &lt; N \le 50)$，表示阶梯的台阶数。</p>
<p><strong>三、输出描述</strong></p>
<p>输出一个整数，表示猴子跳上这个阶梯的不同跳跃方式的数量。</p>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE: Brute Force</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Brute Force</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

public class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        int n = Integer.parseInt(in.nextLine().trim());

        int result = climbMountain(n);

        System.out.println(result);
    }

    private static int climbMountain(int n) {
        if (n < 0) {
            return 0;
        }

        if (n < 3) {
            return 1;
        }
        
        if (n == 3) {
            return 2;
        }

        return climbMountain(n - 1) + climbMountain(n - 3);
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE: Memoization</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Memoiztion</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

/**
 * @author Signal Yu
 * @since 2024-12-1
 */
public class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        int n = Integer.parseInt(in.nextLine().trim());

        int[] cache = new int[n + 1];

        int result = climbMountain(n, cache);

        System.out.println(result);
    }

    private static int climbMountain(int n, int[] cache) {
        if (n < 0) {
            return 0;
        }

        if (n < 3) {
            return 1;
        }

        if (n == 3) {
            return 2;
        }

        if (cache[n] == 0) {
            cache[n] = climbMountain(n - 1, cache) + climbMountain(n - 3, cache);
        }

        return cache[n];
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE: Bottom-Up</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Bottom Up</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" > Please optimize the following code:
import java.util.Scanner;

/**
 * @author Signal Yu
 * @since 2024-12-1
 */
public class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        int n = Integer.parseInt(in.nextLine().trim());

        int result = climbMountain(n);

        System.out.println(result);
    }

    private static int climbMountain(int n) {
        if (n <= 0) {
            return 0;
        }

        if (n < 3) {
            return 1;
        }

        int[] cache = new int[n];
        cache[0] = 1;
        cache[1] = 1;
        cache[2] = 2;

        for (int i = 3; i < n; i++) {
            cache[i] = cache[i - 1] + cache[i - 3];
        }

        return cache[n - 1];
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE: Space Optimization</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Space Optimization</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.Scanner;

/**
 * @author Signal Yu
 * @since 2024-12-1
 */
public class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        int n = Integer.parseInt(in.nextLine().trim());

        int result = climbMountain(n);

        System.out.println(result);
    }

    private static int climbMountain(int n) {
        if (n <= 0) {
            return 0;
        }

        if (n < 3) {
            return 1;
        }

        int prev1 = 1, prev2 = 1, prev3 = 2;

        for (int i = 3; i < n; i++) {
            int current = prev1 + prev3;
            prev1 = prev2;
            prev2 = prev3;
            prev3 = current;
        }

        return prev3;

    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="查找重复代码100分">查找重复代码【100分】<a hidden class="anchor" aria-hidden="true" href="#查找重复代码100分">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>一、题目描述</strong></p>
<p>小明负责维护项目中的代码，他需要查找并优化重复的代码。请你帮助小明找到两行代码中的最长公共子串。如果没有公共子串，返回空字符串。</p>
<p><strong>二、输入描述</strong></p>
<p>输入两行代码，每行以字符串形式给出。</p>
<p><strong>三、输出描述</strong></p>
<p>输出两行代码中的最长公共子串。如果没有公共子串，输出空字符串。</p>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>



<button class="tab_btn ">延伸：返回多个最大公共子串</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.Scanner;

/**
 * @author Signal Yu
 * @since 2024-12-2
 */
class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        String s1 = in.nextLine().trim();
        String s2 = in.nextLine().trim();

        String result = getLCS(s1, s2);

        System.out.println(result);
    }

    private static String getLCS(String s1, String s2) {
        // dp[i][j]表示s1的前i个字符和s2的前j个字符的最长公共子串长度
        int[][] dp = new int[2][s2.length() + 1];

        int maxLength = 0; // 最长公共子串的长度
        int endIndex = 0; // 记录最长公共子串的结束位置
        for (int i = 1; i <= s1.length(); i++) {
            for (int j = 1; j <= s2.length(); j++) {
                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                    dp[i % 2][j] = dp[(i - 1) % 2][j - 1] + 1;
                    if (dp[i % 2][j] > maxLength) {
                        maxLength = dp[i % 2][j];
                        endIndex = i; // 更新最长公共子串的结束位置
                    }
                } else {
                    // 不匹配则当前公共子串长度为0
                    dp[i % 2][j] = 0;
                }
            }
        }

        return maxLength == 0 ? "" : s1.substring(endIndex - maxLength, endIndex);
    }
}
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

/**
 * @author Signal Yu
 * @since 2024-12-2
 */
class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        String s1 = in.nextLine().trim();
        String s2 = in.nextLine().trim();

        List<String> result = getLCS(s1, s2);

        System.out.println(result);
    }

    private static List&lt;String&gt; getLCS(String s1, String s2) {
        // dp[i][j]表示s1的前i个字符和s2的前j个字符的最长公共子串长度
        int[][] dp = new int[2][s2.length() + 1];

        List&lt;String&gt; result = new ArrayList&lt;&gt;();
        int maxLength = 0; // 最长公共子串的长度
        for (int i = 1; i <= s1.length(); i++) {
            for (int j = 1; j <= s2.length(); j++) {
                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                    dp[i % 2][j] = dp[(i - 1) % 2][j - 1] + 1;
                    if (dp[i % 2][j] > maxLength) {
                        maxLength = dp[i % 2][j];
                        result.clear();
                        result.add(s1.substring(i - maxLength, i));
                    } else if (dp[i % 2][j] == maxLength) {
                        result.add(s1.substring(i - maxLength, i));
                    }
                } else {
                    // 不匹配则当前公共子串长度为0
                    dp[i % 2][j] = 0;
                }
            }
        }

        return result;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="最多获得的短信条数100分--01背包问题">最多获得的短信条数【100分】&ndash;0/1背包问题<a hidden class="anchor" aria-hidden="true" href="#最多获得的短信条数100分--01背包问题">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>一、题目描述</strong></p>
<p>某云短信厂商为庆祝国庆推出充值优惠活动。给定客户的预算和不同金额的充值优惠方案，求客户在预算范围内最多可获得的短信条数。</p>
<p><strong>二、输入描述</strong></p>
<ol>
<li>第一行：客户预算 $M$（$0 \leq M \leq 10^6$）。</li>
<li>第二行：售价表，包含 $n$ 个整数 $P_1, P_2, \dots, P_n$，表示每种充值金额对应的短信条数（$1 \leq n \leq 100$，$1 \leq P_i \leq 1000$）。</li>
</ol>
<p><strong>三、输出描述</strong></p>
<p>输出客户在预算范围内最多可获得的短信条数。</p>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

/**
 * @author Signal Yu
 * @since 2024-12-2
 */
class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        int budget = Integer.parseInt(in.nextLine().trim());
        int[] prices = Arrays.stream(in.nextLine().trim().split(","))
                .mapToInt(Integer::parseInt)
                .toArray();

        int result = getMaximumMessages(prices, budget, 0, 0);

        System.out.println(result);
    }

    private static int getMaximumMessages(int[] prices, int budget, int index, int count) {
        if (index == prices.length) {
            return count;
        }

        int include = count;
        if (budget >= index + 1) {
            include = getMaximumMessages(prices, budget - index - 1, index + 1, count + prices[index]);
        }
        int exclude = getMaximumMessages(prices, budget, index + 1, count);

        return Math.max(include, exclude);
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h1 id="广度优先搜索">广度优先搜索<a hidden class="anchor" aria-hidden="true" href="#广度优先搜索">#</a></h1>
<h2 id="102-binary-tree-level-order-traversal">102. Binary Tree Level Order Traversal<a hidden class="anchor" aria-hidden="true" href="#102-binary-tree-level-order-traversal">#</a></h2>

<a href="https://leetcode.com/problems/binary-tree-level-order-traversal" target="_blank">
Go to Leetcode 🔗
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();

        if (root == null) {
            return result;
        }

        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            List&lt;Integer&gt; currentLevel = new ArrayList&lt;&gt;(levelSize);

            // Process all nodes in the current level
            for (int i = 0; i < levelSize; i++) {
                TreeNode node = queue.poll();
                currentLevel.add(node.val);

                // Add children to the queue if they exist
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }

            result.add(currentLevel);
        }

        return result;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="107-binary-tree-level-order-traversal-ii">107. Binary Tree Level Order Traversal II<a hidden class="anchor" aria-hidden="true" href="#107-binary-tree-level-order-traversal-ii">#</a></h2>

<a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii" target="_blank">
Go to Leetcode 🔗
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) {
        List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;();

        if (root == null) {
            return result;
        }

        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.add(root);

        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            List&lt;Integer&gt; currentLevel = new ArrayList&lt;&gt;(levelSize); 

            // Process all nodes at the current level
            for (int i = 0; i < levelSize; i++) {
                TreeNode node = queue.poll();
                currentLevel.add(node.val);

                // Add children to the queue if they exist
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }

            // Add the current level at the begining
            result.add(0, currentLevel);
        }

        return result;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="103-binary-tree-zigzag-level-order-traversal">103. Binary Tree Zigzag Level Order Traversal<a hidden class="anchor" aria-hidden="true" href="#103-binary-tree-zigzag-level-order-traversal">#</a></h2>

<a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal" target="_blank">
Go to Leetcode 🔗
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();

        if (root == null) {
            return result;
        }

        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);

        int level = 0; // Tracks the current level number
        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            List&ltInteger&gt; currentLevel = new LinkedList&lt;&gt;();

            for (int i = 0; i < levelSize; i++) {
                TreeNode node = queue.poll();

                // Add the node reversely if at the odd level
                if (level % 2 == 1) {
                    currentLevel.add(0, node.val);
                } else {
                    currentLevel.add(node.val);
                }

                // Add children to the queue if they are exist
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }

            result.add(currentLevel);
            level++;
        }
        
        return result;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="637-average-of-levels-in-binary-tree">637. Average of Levels in Binary Tree<a hidden class="anchor" aria-hidden="true" href="#637-average-of-levels-in-binary-tree">#</a></h2>

<a href="https://leetcode.com/problems/average-of-levels-in-binary-tree" target="_blank">
Go to Leetcode 🔗
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class Solution {
    public List&lt;Double&gt; averageOfLevels(TreeNode root) {
        List&lt;Double&gt; result = new ArrayList&lt;&gt;();

        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);

        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            long levelSum = 0L;

            // Process all nodes at the current level
            for (int i = 0; i < levelSize; i++) {
                TreeNode node = queue.poll();
                levelSum += node.val;

                // Add children to the queue if they exist
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }

            // Add the current level's average to the result
            result.add((double) levelSum / levelSize);
        }

        return result;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="111-minimum-depth-of-binary-tree">111. Minimum Depth of Binary Tree<a hidden class="anchor" aria-hidden="true" href="#111-minimum-depth-of-binary-tree">#</a></h2>

<a href="https://leetcode.com/problems/minimum-depth-of-binary-tree" target="_blank">
Go to Leetcode 🔗
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int minDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }

        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);

        int minTreeDepth = 0;
        whileLoop:
        while (!queue.isEmpty()) {
            minTreeDepth++;
            int levelSize = queue.size();

            // Process all nodes at the current level
            for (int i = 0; i < levelSize; i++) {
                TreeNode node = queue.poll();

                // Found the minimum depth if both child are null
                if (node.left == null && node.right == null) {
                    break whileLoop;
                }

                // Add children to the queue if they exist
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
        }

        return minTreeDepth;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="104-maximum-depth-of-binary-tree">104. Maximum Depth of Binary Tree<a hidden class="anchor" aria-hidden="true" href="#104-maximum-depth-of-binary-tree">#</a></h2>

<a href="https://leetcode.com/problems/maximum-depth-of-binary-tree" target="_blank">
Go to Leetcode 🔗
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }

        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);

        int depth = 0;
        while (!queue.isEmpty()) {
            depth++;
            int levelSize = queue.size();

            // Process all nodes at the current level
            for (int i = 0; i < levelSize; i++) {
                TreeNode node = queue.poll();

                // Add children to the queue if they exist
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
        }

        return depth;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="116-populating-next-right-pointers-in-each-node">116. Populating Next Right Pointers in Each Node<a hidden class="anchor" aria-hidden="true" href="#116-populating-next-right-pointers-in-each-node">#</a></h2>

<a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node" target="_blank">
Go to Leetcode 🔗
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};
*/

class Solution {
    public Node connect(Node root) {
        if (root == null) {
            return root;
        }

        Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);

        while (!queue.isEmpty()) {
            int levelSize = queue.size();

            // Process all nodes at the current level
            for (int i = 0; i < levelSize; i++) {
                Node node = queue.poll();

                // The last node at the current level points to null
                if (i == levelSize - 1) {
                    node.next = null;
                } else {
                    node.next = queue.peek();
                }

                // Add children to the queue if they exist
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
        }

        return root;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="199-binary-tree-right-side-view">199. Binary Tree Right Side View<a hidden class="anchor" aria-hidden="true" href="#199-binary-tree-right-side-view">#</a></h2>

<a href="https://leetcode.com/problems/binary-tree-right-side-view" target="_blank">
Go to Leetcode 🔗
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class Solution {
    public List&ltInteger&gt; rightSideView(TreeNode root) {
        List&ltInteger&gt; result = new ArrayList&lt&gt;();

        if (root == null) {
            return result;
        }

        Queue&ltTreeNode&gt; queue = new LinkedList&lt&gt;();
        queue.offer(root);

        while (!queue.isEmpty()) {
            int levelSize = queue.size();

            // Process all nodes at the current level
            for (int i = 0; i < levelSize; i++) {
                TreeNode node = queue.poll();

                // Found the rightmost node at the current level
                if (i == levelSize - 1) {
                    result.add(node.val);
                }

                // Add children to the queue if they exist
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
        }

        return result;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="huawei-od-1">Huawei OD<a hidden class="anchor" aria-hidden="true" href="#huawei-od-1">#</a></h2>
<h2 id="最长广播效应200分">最长广播效应【200分】<a hidden class="anchor" aria-hidden="true" href="#最长广播效应200分">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>一、题目描述</strong></p>
<p>在某通信网络中，有N个网络结点，结点的编号为1到N。网络中的结点之间是互联互通的，且每条连接的时延为一个时间单位。现给定一个网络结点的连接关系<code>link = {u, v}</code>，其中u和v表示两个相连的网络结点。</p>
<p>当指定一个结点向其他结点进行广播时，所有被广播的结点在接收到消息后会在原路径上回复一条响应消息。请计算发送广播的结点，至少需要等待多少时间单位才能收到所有被广播结点的响应消息。</p>
<p><strong>注：</strong></p>
<ul>
<li>网络结点的数量N的取值范围为[1, 100]；</li>
<li>连接关系link的长度不超过3000，且1 &lt;= u, v &lt;= N；</li>
<li>网络中任意结点之间都是可达的。</li>
</ul>
<p><strong>二、输入描述</strong></p>
<ol>
<li>输入的第一行包含两个正整数，分别表示网络结点的个数N，以及时延列表的长度T。</li>
<li>接下来的T行输入，表示结点之间的连接关系。每行包含两个整数u和v，表示结点u与结点v之间存在一条连接。</li>
<li>最后一行输入一个正整数，表示指定的广播结点的编号。</li>
</ol>
<p><strong>三、输出描述</strong></p>
<p>输出一个整数，表示发送结点接收到所有响应消息至少需要等待的时长。即广播结点到其他所有结点的最短路径时延的最大值。</p>
<p><strong>四、测试用例</strong></p>
<p><strong>测试用例1：</strong></p>
<p><strong>输入：</strong></p>
<pre tabindex="0"><code>5 7
1 4
2 1
2 3
2 4
3 4
3 5
4 5
2
</code></pre><p><strong>输出：</strong></p>
<pre tabindex="0"><code>4
</code></pre><p><strong>说明：</strong></p>
<p>离节点 2 最远的点为 4 或 5，距离为 2，所需时间为 $2 \times 2 = 4s$。</p>
<p><strong>测试用例2：</strong></p>
<p><strong>输入：</strong></p>
<pre tabindex="0"><code>3 2
1 2
2 3
1
</code></pre><p><strong>输出：</strong></p>
<pre tabindex="0"><code>4
</code></pre><p><strong>说明：</strong></p>
<p>离节点 1 最远的点为 3，距离为 2，所需时间为 $2 \times 2 = 4s$。</p>
<p><strong>测试用例3：</strong></p>
<p><strong>输入：</strong></p>
<pre tabindex="0"><code>3 2
1 2
2 3
2
</code></pre><p><strong>输出：</strong></p>
<pre tabindex="0"><code>2
</code></pre><p><strong>说明：</strong></p>
<p>离节点 1 最远的点为 1 或 3，距离为 1，所需时间为 $2 \times 1 = 2s$。</p>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

/**
 * @author Signal Yu
 * @since 2024-11-27
 */
public class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        int[] parts = Arrays.stream(in.nextLine().trim().split(" "))
                .mapToInt(Integer::parseInt)
                .toArray();
        int n = parts[0];
        int edgeCount = parts[1];

        int[][] edges = new int[edgeCount][2];
        for (int i = 0; i < edgeCount; i++) {
            int[] edge = Arrays.stream(in.nextLine().trim().split(" "))
                    .mapToInt(Integer::parseInt)
                    .toArray();


            edges[i] = new int[]{edge[0] - 1, edge[1] - 1};
        }

        int start = Integer.parseInt(in.nextLine().trim()) - 1; // Convert to 0-based index

        // Construct the graph
        List&lt;List&lt;Integer&gt;&gt; graph = constructGraph(edges, n);

        // Calculate shortest time
        int result = findMaxBroadcastTime(graph, start);

        System.out.println(result);
    }

    private static int findMaxBroadcastTime(List&lt;List&lt;Integer&gt;&gt; graph, int start) {
        int[] distance = new int[graph.size()];
        Arrays.fill(distance, -1); // -1 indicates unvisited nodes

        Queue<Integer> queue = new LinkedList&lt;&gt;();

        distance[start] = 0; // Distance to itself is 0
        queue.offer(start);

        // Perform BFS to find the shortest path from the start node to all other nodes
        while (!queue.isEmpty()) {
            int node = queue.poll();
            List<Integer> neighbors = graph.get(node);
            for (int neighbor : neighbors) {
                if (distance[neighbor] == -1) { // If the neighbor hasn't been visited
                    distance[neighbor] = distance[node] + 1;
                    queue.offer(neighbor);
                }
            }
        }

        // Multiply by 2 for round-trip time
        return 2 * Arrays.stream(distance).max().orElse(0);
    }

    private static List&lt;List&lt;Integer&gt;&gt; constructGraph(int[][] edges, int n) {
        List&lt;List&lt;Integer&gt;&gt; graph = new ArrayList&lt;&gt;(n);

        for (int i = 0; i < n; i++) { // 0-based index
            graph.add(new ArrayList&lt;&gt;());
        }

        for (int[] edge : edges) {
            graph.get(edge[0]).add(edge[1]);
            graph.get(edge[1]).add(edge[0]);
        }

        return graph;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="深度优先搜索">深度优先搜索<a hidden class="anchor" aria-hidden="true" href="#深度优先搜索">#</a></h2>
<h2 id="112-path-sum">112. Path Sum<a hidden class="anchor" aria-hidden="true" href="#112-path-sum">#</a></h2>

<a href="https://leetcode.com/problems/path-sum" target="_blank">
Go to Leetcode 🔗
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        // Return false if the tree is empty
        if (root == null) {
            return false;
        }
        
        // Return true if current node is a leaf node and its value equals to remaining target sum 
        if (root.left == null && root.right == null) {
            return targetSum == root.val;
        }

        // Perform recursive calls for the left and right subtrees with updated target sum
        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="257-binary-tree-paths">257. Binary Tree Paths<a hidden class="anchor" aria-hidden="true" href="#257-binary-tree-paths">#</a></h2>

<a href="https://leetcode.com/problems/binary-tree-paths" target="_blank">
Go to Leetcode 🔗
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List&ltString&gt; binaryTreePaths(TreeNode root) {
        List&ltString&gt; allPaths = new ArrayList&lt;&gt;();

        findPathsRecursive(root, allPaths, "");

        return allPaths;
    }

    private static void findPathsRecursive(TreeNode node, List&ltString&gt; allPaths, String currentPath) {
        if (node == null) {
            return;
        }

        // Add the current node value to the path
        currentPath += node.val;

        // Check if the current node is a leaf node
        if (node.left == null && node.right == null) {
            allPaths.add(currentPath);
        } else {
            currentPath += "->";
            // Traverse the left and the right subtree
            findPathsRecursive(node.left, allPaths, currentPath);
            findPathsRecursive(node.right, allPaths, currentPath);
        }
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="129-sum-root-to-leaf-numbers">129. Sum Root to Leaf Numbers<a hidden class="anchor" aria-hidden="true" href="#129-sum-root-to-leaf-numbers">#</a></h2>

<a href="https://leetcode.com/problems/sum-root-to-leaf-numbers" target="_blank">
Go to Leetcode 🔗
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class Solution {
    public int sumNumbers(TreeNode root) {
        return calculateSum(root, 0);
    }

    private static int calculateSum(TreeNode node, int currentSum) {
        if (node == null) {
            return 0;
        }

        currentSum = currentSum * 10 + node.val;

        // Check if it's a leaf node
        if (node.left == null && node.right == null) {
            return currentSum;
        }

        // Traverse the left subtree
        int leftSum = calculateSum(node.left, currentSum);
        int rightSum = calculateSum(node.right, currentSum);

        return leftSum + rightSum;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="1971-find-if-path-exists-in-graph">1971. Find if Path Exists in Graph<a hidden class="anchor" aria-hidden="true" href="#1971-find-if-path-exists-in-graph">#</a></h2>

<a href="https://leetcode.com/problems/find-if-path-exists-in-graph" target="_blank">
Go to Leetcode 🔗
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public boolean validPath(int n, int[][] edges, int source, int destination) {
        // Initialize the adjacency list representation of the graph
        List&lt;List&lt;Integer&gt;&gt; graph = new ArrayList&lt;&gt;();
        for (int i = 0; i < n; i++) {
            graph.add(new ArrayList&lt;&gt;());
        }

        // Populate the adjacency list with the edges
        for (int[] edge : edges) {
            graph.get(edge[0]).add(edge[1]);
            graph.get(edge[1]).add(edge[0]);
        }

        // Array to track visited nodes
        boolean[] visited = new boolean[n];

        // Perform a DFS to check if a path exists
        return dfs(graph, visited, source, destination);
    }

    private static boolean dfs(List&lt;List&lt;Integer&gt;&gt; graph, boolean[] visited, int source, int destination) {
        // Base case: If the source and destination are the same, a path exists
        if (source == destination) {
            return true;
        }

        // Mark the current node as visited
        visited[source] = true;

        // Explore all unvisited nodes
        List<Integer> neighbors = graph.get(source);
        for (int neighbor : neighbors) {
            if (!visited[neighbor] && dfs(graph, visited, neighbor, destination)) {
                return true;
            }
        }

        // No path found from this node
        return false;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="华为-od-1">华为 OD<a hidden class="anchor" aria-hidden="true" href="#华为-od-1">#</a></h2>
<h2 id="文件目录大小100分">文件目录大小【100分】<a hidden class="anchor" aria-hidden="true" href="#文件目录大小100分">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>一、题目描述</strong></p>
<p>文件系统以如下格式表示目录数据：<br>
<strong>目录id 本目录中文件大小（子目录id列表）</strong></p>
<ul>
<li><strong>目录id</strong>：全局唯一，取值范围为 1-200；</li>
<li><strong>本目录中文件大小</strong>：取值范围为 1-1000；</li>
<li><strong>子目录id列表</strong>：包含 0-10 个子目录的 id，以逗号分隔。</li>
</ul>
<p>例如：<br>
<code>1 20 (2,3)</code> 表示目录 id 为 1，其中文件大小为 20，且包含两个子目录，id 分别为 2 和 3。</p>
<p>现给定文件系统中所有目录的信息以及待查询的目录 id，计算该目录及其所有子目录的文件大小之和。</p>
<p><strong>二、输入描述</strong></p>
<ul>
<li><strong>第一行</strong>：两个整数 M 和 N，分别表示目录的个数和待查询的目录 id：
<ul>
<li><code>1 &lt;= M &lt;= 100</code></li>
<li><code>1 &lt;= N &lt;= 200</code></li>
</ul>
</li>
<li><strong>接下来的 M 行</strong>：每行为一个目录的数据，格式为：
<ul>
<li><code>目录id 本目录中文件大小（子目录id列表）</code></li>
<li>子目录列表中的 id 以逗号分隔，若无子目录，则表示为空括号 <code>()</code>。</li>
</ul>
</li>
</ul>
<p><strong>三、输出描述</strong></p>
<p>输出待查询目录及其所有子目录的文件大小之和。</p>
<p><strong>四、输入输出示例</strong></p>
<p><strong>输入示例：</strong></p>
<pre tabindex="0"><code>3 1
1 10 (2)
2 20 (3)
3 30 ()
</code></pre><p><strong>输出示例：</strong></p>
<pre tabindex="0"><code>60
</code></pre><p><strong>示例说明：</strong></p>
<ol>
<li>系统包含 3 个目录：
<ul>
<li>目录 <code>1</code> 的文件大小为 <code>10</code>，其子目录 id 为 <code>2</code>；</li>
<li>目录 <code>2</code> 的文件大小为 <code>20</code>，其子目录 id 为 <code>3</code>；</li>
<li>目录 <code>3</code> 的文件大小为 <code>30</code>，无子目录。</li>
</ul>
</li>
<li>待查询的目录为 <code>1</code>：
<ul>
<li>目录 <code>1</code> 的文件大小为 <code>10</code>；</li>
<li>子目录 <code>2</code> 的文件大小为 <code>20</code>；</li>
<li>子目录 <code>3</code> 的文件大小为 <code>30</code>。</li>
</ul>
</li>
<li>大小之和为：<code>10 + 20 + 30 = 60</code>。</li>
</ol>
<p><strong>五、约束条件</strong></p>
<ol>
<li>输入保证是合法的，不会出现循环引用或无效目录。</li>
<li>目录列表中所有 id 保证唯一。</li>
</ol>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

/**
 * @author Signal Yu
 * @since 2024-11-26
 */
public class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // Parse input for number of directories and the target directory ID
        int[] nums = Arrays.stream(in.nextLine().trim().split(" "))
                .mapToInt(Integer::parseInt)
                .toArray();
        int m = nums[0];
        int n = nums[1];

        // Construct the directory map
        Map&lt;Integer, Directory&gt; directoryMap = new HashMap&lt;&gt;();
        for (int i = 0; i < m; i++) {
            String[] parts = in.nextLine().trim().split(" ");
            int id = Integer.parseInt(parts[0]);
            int size = Integer.parseInt(parts[1]);
            String subDirs = parts[2].replaceAll("[()]", "");

            List&lt;Integer&gt; subDirList = new ArrayList&lt;&gt;();
            if (!subDirs.isEmpty()) {
                for (String c : subDirs.split(",")) {
                    subDirList.add(Integer.parseInt(c));
                }
            }

            directoryMap.put(id, new Directory(id, size, subDirList));
        }

        // Compute and output the total size for the target directory
        int totalSize = calculateTotalSize(n, directoryMap);
        System.out.println(totalSize);
    }

    private static int calculateTotalSize(int id, Map&lt;Integer, Directory&gt; directoryMap) {
        Directory dir = directoryMap.get(id);

        if (dir == null) {
            return 0;
        }


        int totalSize = dir.size;

        // Sum the size of the current directory and its subdirectories
        for (int subId : dir.subDirList) {
            totalSize += calculateTotalSize(subId, directoryMap);
        }

        return totalSize;
    }
}

class Directory {
    int id;
    int size;
    List&lt;Integer&gt; subDirList;

    public Directory(int id, int size, List&lt;Integer&gt; subDirList) {
        this.id = id;
        this.size = size;
        this.subDirList = subDirList;
    }


}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="悄悄话100分">悄悄话【100分】<a hidden class="anchor" aria-hidden="true" href="#悄悄话100分">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>题目描述：</strong></p>
<p>给定一个二叉树，每个节点上站着一个人，节点的数字表示从父节点到该节点传递悄悄话所需的时间。初始时，根节点所在位置的人有一个悄悄话想要传递给其他所有节点的人，求传递完毕、所有节点上的人都接收到悄悄话所需的最大时间。</p>
<p><strong>输入描述：</strong></p>
<ul>
<li>输入包含二叉树的表示：
<ul>
<li>每个节点的值表示从父节点到该节点的传递时间；</li>
<li><code>-1</code>表示空节点。</li>
</ul>
</li>
</ul>
<p>例如，输入：<code>0 9 20 -1 -1 15 7 -1 -1 -1 -1 3 2 -1 -1</code></p>
<p><strong>输出描述：</strong></p>
<ul>
<li>输出为所有节点都收到悄悄话所花费的时间。
<strong>测试用例1：</strong></li>
</ul>
<p><strong>输入：</strong></p>
<pre tabindex="0"><code>0 1 2 -1 -1 3 4 -1 -1 -1 -1
</code></pre><p><strong>输出：</strong></p>
<pre tabindex="0"><code>6
</code></pre><p><strong>说明：</strong></p>
<p>根节点到叶节点最大和为 $0 + 2 + 4 = 6$</p>
<p><strong>测试用例2：</strong></p>
<p><strong>输入：</strong></p>
<pre tabindex="0"><code>0 1 2 3 4 5 6 -1 -1 -1 -1 -1 -1 -1 -1
</code></pre><p><strong>输出：</strong></p>
<pre tabindex="0"><code>8
</code></pre><p><strong>说明：</strong></p>
<p>根节点到叶节点最大和为 $0 + 2 + 6 = 8$</p>
<p><strong>示例3：</strong></p>
<p><strong>输入：</strong></p>
<pre tabindex="0"><code>0 9 20 -1 -1 15 7 -1 -1 -1 -1 3 2 -1 -1
</code></pre><p><strong>输出：</strong></p>
<pre tabindex="0"><code>38
</code></pre><p><strong>说明：</strong></p>
<p>根节点到叶节点最大和为 $0 + 20 + 15 + 3 = 38$</p>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.Arrays;
import java.util.Scanner;

/**
 * @author Signal Yu
 * @since 2024-11-27
 */
public class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        int[] nodes = Arrays.stream(in.nextLine().trim().split(" "))
                .mapToInt(Integer::parseInt)
                .toArray();

        int result = findMaxPathSumDFS(nodes, 0);

        System.out.println(result);
    }

    private static int findMaxPathSumDFS(int[] tree, int index) {
        // If the index is out of bounds or the node is null
        if (index >= tree.length || tree[index] == -1) {
            return 0;
        }

        // Time at the current node
        int currentTime = tree[index];

        // Recursively calculate the time for the left and right children
        int leftChildTime = findMaxPathSumDFS(tree, 2 * index + 1);
        int rightChildTime = findMaxPathSumDFS(tree, 2 * index + 2);

        // Return the maximum time between left and right child paths, adding the current node's time
        return currentTime + Math.max(leftChildTime, rightChildTime);
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h1 id="回溯">回溯<a hidden class="anchor" aria-hidden="true" href="#回溯">#</a></h1>
<h2 id="113-path-sum-ii">113. Path Sum II<a hidden class="anchor" aria-hidden="true" href="#113-path-sum-ii">#</a></h2>

<a href="https://leetcode.com/problems/path-sum-ii" target="_blank">
Go to Leetcode 🔗
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List&ltList&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) {
        List&ltList&lt;Integer&gt;&gt; requiredPaths = new ArrayList&lt&gt;();
        List&ltInteger&gt; currentPath = new ArrayList&lt&gt;();

        // Find required paths recursively
        findPathsRecursive(root, targetSum, requiredPaths, currentPath);
        
        return requiredPaths;
    }

    private static void findPathsRecursive(TreeNode node, int targetSum, List&ltList&lt;Integer&gt;&gt; requiredPaths, List&ltInteger&gt; currentPath) {
        if (node == null) {
            return;
        }

        // Add the current node value to the path
        currentPath.add(node.val);

        // Check if this is a leaf node and its value matches the remaining target sum
        if (node.left == null && node.right == null && node.val == targetSum) {
            requiredPaths.add(new ArrayList&lt&gt;(currentPath));
        } else {
            // Traverse the left subtree
            findPathsRecursive(node.left, targetSum - node.val, requiredPaths, currentPath);
            // Traverse the right subtree
            findPathsRecursive(node.right, targetSum - node.val, requiredPaths, currentPath);
        }

        // Backtrack to explore other paths
        currentPath.remove(currentPath.size() - 1);
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="437-path-sum-iii">437. Path Sum III<a hidden class="anchor" aria-hidden="true" href="#437-path-sum-iii">#</a></h2>

<a href="https://leetcode.com/problems/path-sum-iii" target="_blank">
Go to Leetcode 🔗
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >/**
 * Definition for a binary tree node.
 * public class TreeNode {
 * int val;
 * TreeNode left;
 * TreeNode right;
 * TreeNode() {}
 * TreeNode(int val) { this.val = val; }
 * TreeNode(int val, TreeNode left, TreeNode right) {
 * this.val = val;
 * this.left = left;
 * this.right = right;
 * }
 * }
 */
class Solution {
    public int pathSum(TreeNode root, int targetSum) {
        HashMap&lt;Long, Integer&gt; prefixSumMap = new HashMap&lt;&gt;();
        // Base case: a path with current sum matches target sum exitst at the root
        prefixSumMap.put(0L, 1);

        return pathSumRecursive(root, 0, targetSum, prefixSumMap);
    }

    private static int pathSumRecursive(TreeNode node, long currentSum, int targetSum, Map&lt;Long, Integer&gt; prefixSumMap) {
        if (node == null) {
            return 0;
        }

        // Update the current sum
        currentSum += node.val;

        // Calculate the number of valid paths ending at this node
        int pathCount = prefixSumMap.getOrDefault(currentSum - targetSum, 0);

        // Add the current sum to the map
        prefixSumMap.put(currentSum, prefixSumMap.getOrDefault(currentSum, 0) + 1);

        // Recur for left and right sub-trees
        pathCount += pathSumRecursive(node.left, currentSum, targetSum, prefixSumMap);
        pathCount += pathSumRecursive(node.right, currentSum, targetSum, prefixSumMap);

        // Remove the current path sum to backtrack
        prefixSumMap.put(currentSum, prefixSumMap.get(currentSum) - 1);

        return pathCount;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="39-combination-sum">39. Combination Sum<a hidden class="anchor" aria-hidden="true" href="#39-combination-sum">#</a></h2>

<a href="https://leetcode.com/problems/combination-sum" target="_blank">
Go to Leetcode 🔗
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >/**
 * This Program uses the backtracking technique to find all unique combinations
 * where the sum equals to the target.
 *
 * @author Signal Yu
 * @since 2024-11-25
 */
class Solution {
    /**
     * Finds combinations of numbers that sum to the target value.
     *
     * @param candidates Array of candidate numbers.
     * @param target Target sum to achieve.
     * @return A list of all unique combinations where the sum of numbers equals the target.
     */
    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) {
        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();

        backtrack(candidates, target, 0, new ArrayList&lt;&gt;(), result);

        return result;
    }

    /**
     * Helper method for backtracking to find valid combinations.
     *
     * @param candidates Array of candidate numbers.
     * @param target Remaining target sum to achieve.
     * @param start Starting index for exploration to avoid duplicates.
     * @param combination Current combination being explored.
     * @param result List to store all valid combinations.
     */
    private static void backtrack(int[] candidates, int target, int start, List&lt;Integer&gt; combination, List&lt;List&lt;Integer&gt;&gt; result) {
        // Found a combination if the remaining target matches 0
        if (target == 0) {
            result.add(combination);
            return;
        }

        // Iterate over the candidates array to find the combination
        for (int i = start; i < candidates.length; i++) {
            // Skip the candidate greater than the remaining target
            if (candidates[i] > target) {
                continue;
            }

            // Add the current element to the combination array
            combination.add(candidates[i]);

            // Recur with the updated combination array and the remaining target
            backtrack(candidates, target - candidates[i], i, combination, result);

            // Backtrack to explore other possibilities
            combination.remove(combination.size() - 1);
        }
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="项目规划100分">项目规划【100分】<a hidden class="anchor" aria-hidden="true" href="#项目规划100分">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>一、题目描述</strong></p>
<p>H公司正在进行项目规划，目前有3个团队（前端、后端、测试）需要共同完成M个项目。每个团队有固定的人力总和（单位：人月）。每个项目的特点如下：</p>
<ol>
<li>每个项目需要多个团队投入不同数量的人力。</li>
<li>每个项目具有一个预估价值（单位：万元）。</li>
</ol>
<p>你的任务是帮助公司进行项目规划，在团队人力允许的情况下，选择一组项目使其预估价值总和最大化。</p>
<p>如果无法承接任何项目，则返回0。</p>
<p><strong>二、输入描述</strong></p>
<ul>
<li><strong>项目数量</strong>：$M;(0 &lt; M \le 20)$。</li>
<li><strong>三个团队的人力总和</strong>：$S_1，S_2，S_3;(0 &lt; S_i \le 1000);$。</li>
<li><strong>每个项目的预估价值</strong>：$V_1, V_2, &hellip;, Vm（0 &lt; V_i \le 1,000,000);$。</li>
<li><strong>每个项目所需人力</strong>：$\{P_{11}, P_{12}, P_{13}\}, \{P_{21}, P_{22}, P_{23}\}, &hellip;, \{P_{m1}, P_{m2}, P_{m3}\}$。
<ul>
<li>其中，$P_{ij}$表示第$i$个项目对第$j$个团队的人力需求（$0 \le Pij \le Si$）。</li>
</ul>
</li>
</ul>
<p><strong>三、输出描述</strong></p>
<p>输出能够承接的最大预估价值总和。如果无法承接任何项目，输出0。</p>
<p><strong>四、输入输出示例</strong></p>
<p><strong>示例1</strong></p>
<p><strong>输入</strong></p>
<pre tabindex="0"><code>2  
100 100 100  
10000 8000  
60 60 60  
60 60 60  
</code></pre><p><strong>输出</strong></p>
<pre tabindex="0"><code>10000
</code></pre><p><strong>说明</strong></p>
<ul>
<li>有2个项目：
<ul>
<li>第1个项目价值为10000万元，需要每个团队分别投入60人月。</li>
<li>第2个项目价值为8000万元，也需要每个团队分别投入60人月。</li>
</ul>
</li>
<li>由于3个团队的人力总和分别为100人月，只有第1个项目可以完成，因此最大预估价值为10000。</li>
</ul>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

/**
 * This solution uses backtracking coding pattern for calculating maximum achievable project value.
 *
 * @author Signal Yu
 * @since 2024-11-25
 */
public class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // Project count
        int m = Integer.parseInt(in.nextLine().trim());

        // Team capacity
        int[] teamCapacity = Arrays.stream(in.nextLine().trim().split(" "))
                .mapToInt(Integer::parseInt)
                .toArray();

        // Project values
        int[] projectValues = Arrays.stream(in.nextLine().trim().split(" "))
                .mapToInt(Integer::parseInt)
                .toArray();

        // Project Requirements
        int[][] projectRequirements = new int[m][3];
        for (int i = 0; i < m; i++) {
            int[] parts = Arrays.stream(in.nextLine().trim().split(" "))
                    .mapToInt(Integer::parseInt)
                    .toArray();
            projectRequirements[i][0] = parts[0];
            projectRequirements[i][1] = parts[1];
            projectRequirements[i][2] = parts[2];
        }

        // Calculate the max value
        int maxValue = getMaxProjectValue(teamCapacity, projectValues, projectRequirements, 0, 0);

        // Print result
        System.out.println(maxValue);
    }

    /**
     * Calculate the maximum project value.
     *
     * @param teamCapacity Remaining capacity of each team.
     * @param projectValues Value of each project
     * @param projectRequirements Team Requirements for each project
     * @param index Current project index.
     * @param currentValue Current accumulated value
     * @return Maximum value achievable.
     */
    private static int getMaxProjectValue(int[] teamCapacity, int[] projectValues,
                                          int[][] projectRequirements, int index,
                                          int currentValue) {
        if (index == projectValues.length) {
            return currentValue;
        }

        // Skip the current project
        int maxValue = getMaxProjectValue(teamCapacity, projectValues, projectRequirements, index + 1, currentValue);

        // Check if the current project can be completed
        if (canCompleteProject(teamCapacity, projectRequirements[index])) {
            // Deduct team capacity for the current project
            adjustCapacity(teamCapacity, projectRequirements[index], -1);

            // Include the current project and calculate the new value
            maxValue = Math.max(maxValue,
                    getMaxProjectValue(teamCapacity, projectValues, projectRequirements,
                            index + 1, currentValue + projectValues[index]));

            // Backtrack: restore capacity
            adjustCapacity(teamCapacity, projectRequirements[index], 1);
        }

        return maxValue;
    }

    /**
     * Check if the project can be completed with the current capability
     *
     * @param teamCapacity Remaining capacity of each team.
     * @param projectRequirement Requirements for the current project.
     * @return true if the project can be completed, false otherwise.
     */
    private static boolean canCompleteProject(int[] teamCapacity, int[] projectRequirement) {
        for (int i = 0; i < teamCapacity.length; i++) {
            if (teamCapacity[i] < projectRequirement[i]) {
                return false;
            }
        }
        return true;
    }

    /**
     * Adjust the team capacity by adding or subtracting the project requirements
     *
     * @param teamCapacity Remaining capacity of each team.
     * @param projectRequirement Requirements to be adjusted.
     * @param multiplier Adjustment direction (1 for adding, -1 for subtracting)
     */
    private static void adjustCapacity(int[] teamCapacity, int[] projectRequirement, int multiplier) {
        for (int i = 0; i < teamCapacity.length; i++) {
            teamCapacity[i] += projectRequirement[i] * multiplier;
        }
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="趣味游戏100分">趣味游戏【100分】<a hidden class="anchor" aria-hidden="true" href="#趣味游戏100分">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>一、题目描述</strong></p>
<p>小明负责公司年会，设计了一个趣味游戏：</p>
<p>屏幕会给出4个1~9之间的不重复数字，要求大家以最快的速度计算出这几个数字可以拼接成的所有数字（从小到大排序后）的第N个数字。</p>
<p><strong>N的值为给出的4个数字中的最大值</strong>。如果排列的数字个数小于N，则输出最后一个数字。</p>
<p><strong>规则：</strong></p>
<ol>
<li>数字 <strong>2</strong> 和 <strong>5</strong> 可以互相替代使用，屏幕不会同时出现 <strong>2</strong> 和 <strong>5</strong>。</li>
<li>数字 <strong>6</strong> 和 <strong>9</strong> 可以互相替代使用，屏幕不会同时出现 <strong>6</strong> 和 <strong>9</strong>。</li>
</ol>
<p><strong>例如：</strong></p>
<ul>
<li>输入数字为 <code>1,4,8,7</code> 时，可以拼接的所有数字为：<br>
<code>1, 4, 7, 8, 14, 17, 18, 41, 47, 48, 71, 74, 78, 81, 84, 87, 147, 148, 178, 187...</code><br>
第 <strong>8</strong> 个数字为 <code>41</code>，因此输出 <code>41</code>。</li>
</ul>
<hr>
<p><strong>二、输入描述</strong></p>
<p>输入为以逗号分隔的4个1~9的数字组成的字符串。</p>
<p><strong>要求：</strong></p>
<ul>
<li>输入的数字范围必须在1~9之间。</li>
<li>输入的数字不能重复。</li>
</ul>
<p><strong>如果输入不满足要求，输出 <code>-1</code>。</strong></p>
<p><strong>三、输出描述</strong></p>
<p>输出这几个数字拼接的所有数字从小到大排序后，第 <strong>N</strong> 个数字。<br>
如果拼接出的数字个数少于 <strong>N</strong>，则输出最后一个数字。</p>
<p><strong>四、样例</strong></p>
<p><strong>输入样例 1：</strong></p>
<pre tabindex="0"><code>1,4,8,7
</code></pre><p><strong>输出样例 1：</strong></p>
<pre tabindex="0"><code>41
</code></pre><p><strong>样例说明：</strong>
可拼接的数字为：<br>
<code>1, 4, 7, 8, 14, 17, 18, 41, 47, 48, 71, 74, 78, 81, 84, 87, 147, 148, 178, 187...</code><br>
第8个数字为 <code>41</code>，因此输出 <code>41</code>。</p>
<p><strong>输入样例 2：</strong></p>
<pre tabindex="0"><code>2,4,6,8
</code></pre><p><strong>输出样例 2：</strong></p>
<pre tabindex="0"><code>42
</code></pre><p><strong>样例说明：</strong></p>
<p>可拼接的数字为：<br>
<code>2, 4, 6, 8, 24, 26, 28, 42, 46, 48, 62, 64, 68, 82, 84, 86, 246, 248, 268, 284...</code><br>
第8个数字为 <code>42</code>，因此输出 <code>42</code>。</p>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;
import java.util.stream.Collectors;

/**
 * @author Signal Yu
 * @since 2024-11-25
 */
public class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // Parse input into a list of integers
        List&lt;Integer&gt; nums = Arrays.stream(in.nextLine().trim().split(","))
                .map(Integer::parseInt)
                .collect(Collectors.toList());

        // Determine the maximum number in the list
        int maxNum = Collections.max(nums);

        // Validate the input and process if valid
        if (!isValidInput(nums)) {
            System.out.println("-1");
        } else {
            // Generate and sort all unique permutations
            List&lt;Integer&gt; sortedPermutations = generateSortedPermutations(nums);

            // Find the N-th smallest number or the last number if insufficient permutations
            int result = sortedPermutations.size() >= maxNum
                    ? sortedPermutations.get(maxNum - 1)
                    : sortedPermutations.get(sortedPermutations.size() - 1);
            System.out.println(result);
        }
    }

    private static List&lt;Integer&gt; generateSortedPermutations(List&lt;Integer&gt; nums) {
        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();

        backtrack(nums, new boolean[nums.size()], new StringBuilder(), result);

        return result.stream().sorted().collect(Collectors.toList());
    }

    private static void backtrack(List&lt;Integer&gt; nums, boolean[] used, StringBuilder current, List&lt;Integer&gt; result) {
        if (!current.isEmpty()) {
            result.add(Integer.parseInt(current.toString()));
        }

        for (int i = 0; i < nums.size(); i++) {
            if (used[i]) {
                continue;
            }

            // Add current number to the combination
            current.append(nums.get(i));
            used[i] = true;

            // Recurse with the updated state
            backtrack(nums, used, current, result);

            // Backtrack: remove the last number and reset state
            current.deleteCharAt(current.length() - 1);
            used[i] = false;
        }
    }

    private static boolean isValidInput(List&lt;Integer&gt; nums) {
        if (nums.size() != 4) {
            return false;
        }

        int digitTwoOrFive = 0;
        int digitSixOrNine = 0;
        for (int num : nums) {
            if (num < 1 || num > 9) {
                return false;
            } else if (num == 2 || num == 5) {
                digitTwoOrFive++;
            } else if (num == 6 || num == 9) {
                digitSixOrNine++;
            }
        }

        return digitTwoOrFive <= 1 && digitSixOrNine <= 1;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="猜谜码100分">猜谜码【100分】<a hidden class="anchor" aria-hidden="true" href="#猜谜码100分">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>一、题目描述</strong></p>
<p>小杨申请了一个保密柜，但忘记了密码。唯一记得的是密码的数字都来源于一个范围内，并且这些数字互不重复。请你帮助小杨根据以下规则，计算可能的密码组合：</p>
<ol>
<li>密码的数字来源于给定的数字范围，并且同一密码内数字不能重复；</li>
<li>密码的数字需按从小到大的顺序排列，组合之间按字典序排序；</li>
<li>密码的长度需大于等于给定的最小数字数量；</li>
<li>如果没有符合条件的组合，则输出“None”。</li>
</ol>
<p><strong>二、输入描述</strong></p>
<ul>
<li><strong>第一行</strong>：可能的密码数字范围（1~9 的整数），以半角逗号 <code>,</code> 分隔。</li>
<li><strong>第二行</strong>：密码的最小数字数量（正整数）。</li>
</ul>
<p><strong>三、输出描述</strong></p>
<ul>
<li>输出所有可能的密码组合，每种组合的数字以半角逗号 <code>,</code> 分隔，并按字典序排序。</li>
<li>每种组合占一行。</li>
</ul>
<p>如果没有符合条件的组合，输出 <code>None</code>。</p>
<p><strong>四、输入示例</strong></p>
<p><strong>输入：</strong></p>
<pre tabindex="0"><code>2,3,4
2
</code></pre><p><strong>输出：</strong></p>
<pre tabindex="0"><code>2,3
2,3,4
2,4
3,4
</code></pre><p><strong>五、输出示例</strong></p>
<p><strong>输入：</strong></p>
<pre tabindex="0"><code>1,2,3
4
</code></pre><p><strong>输出：</strong></p>
<pre tabindex="0"><code>None
</code></pre>
</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;
import java.util.stream.Collectors;

/**
 * @author Signal Yu
 * @since 2024-11-25
 */
public class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        List<Integer> nums = Arrays.stream(in.nextLine().trim().split(","))
                .map(Integer::parseInt)
                .sorted()
                .collect(Collectors.toList());
        int minLength = Integer.parseInt(in.nextLine().trim());

        // Generate combinations
        List<List<Integer>> combinations = new ArrayList<>();
        generateCombinations(nums, minLength, 0, new ArrayList<>(), combinations);
        
        if(combinations.isEmpty()) {
            System.out.println("None");
        } else {
            combinations.forEach(combination ->
                    System.out.println(combination.stream()
                            .map(String::valueOf)
                            .collect(Collectors.joining(",")))
            );
        }
    }

    private static void generateCombinations(List<Integer> nums, int minLength,
                                             int start, List<Integer> current,
                                             List<List<Integer>> combinations) {
        if (current.size() >= minLength) {
            combinations.add(new ArrayList<>(current));
        }

        // Explore further combinations
        for (int i = start;i < nums.size(); i++) {
            // Add current number to the current combination
            current.add(nums.get(i));

            // Recur for futher combinations
            generateCombinations(nums, minLength, i + 1, current, combinations);

            // Backtrack to explore other combinations
            current.remove(current.size() - 1);
        }

    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="过滤组合字符串100分">过滤组合字符串【100分】<a hidden class="anchor" aria-hidden="true" href="#过滤组合字符串100分">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p>**一、题目描述  **</p>
<p>每个数字与多个字母关联，关联关系如下：</p>
<ul>
<li>0 关联 &ldquo;a&rdquo;, &ldquo;b&rdquo;, &ldquo;c&rdquo;</li>
<li>1 关联 &ldquo;d&rdquo;, &ldquo;e&rdquo;, &ldquo;f&rdquo;</li>
<li>2 关联 &ldquo;g&rdquo;, &ldquo;h&rdquo;, &ldquo;i&rdquo;</li>
<li>3 关联 &ldquo;j&rdquo;, &ldquo;k&rdquo;, &ldquo;l&rdquo;</li>
<li>4 关联 &ldquo;m&rdquo;, &ldquo;n&rdquo;, &ldquo;o&rdquo;</li>
<li>5 关联 &ldquo;p&rdquo;, &ldquo;q&rdquo;, &ldquo;r&rdquo;</li>
<li>6 关联 &ldquo;s&rdquo;, &ldquo;t&rdquo;</li>
<li>7 关联 &ldquo;u&rdquo;, &ldquo;v&rdquo;</li>
<li>8 关联 &ldquo;w&rdquo;, &ldquo;x&rdquo;</li>
<li>9 关联 &ldquo;y&rdquo;, &ldquo;z&rdquo;</li>
</ul>
<ol>
<li>输入一串数字，根据数字与字母的对应关系生成所有可能的字母组合（按数字顺序组合）。</li>
<li>提供一个<strong>屏蔽字符串</strong>，屏蔽字符串中的所有字母不能同时出现在输出的组合中。例如，屏蔽字符串为 <code>abc</code>，则结果中不能同时包含 <code>a</code>、<code>b</code>、<code>c</code>，但允许出现 <code>a, b</code> 或 <code>b, c</code> 等部分字母。</li>
<li>给定数字字符串和屏蔽字符串，输出符合条件的所有字母组合。</li>
<li><strong>示例</strong>：输入数字字符串 <code>78</code> 和屏蔽字符串 <code>ux</code>，输出结果为 <code>uw, vw, vx</code>。</li>
</ol>
<p><strong>二、输入描述</strong></p>
<ul>
<li><strong>第一行</strong>：输入一个数字字符串，要求：
<ul>
<li>数字字符串中的数字不能重复；</li>
<li>字符串长度为 1 至 5（含 1 和 5）。</li>
</ul>
</li>
<li><strong>第二行</strong>：输入屏蔽字符串，要求：
<ul>
<li>屏蔽字符串长度小于数字字符串长度；</li>
<li>屏蔽字符串中的字符不重复。</li>
</ul>
</li>
</ul>
<p><strong>三、输出描述</strong></p>
<p>输出符合条件的字母组合，组合之间用逗号 <code>,</code> 分隔，<strong>最后一个组合后需要带逗号</strong>。</p>
<p><strong>四、输入输出示例</strong></p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong></p>
<pre tabindex="0"><code>89  
wy  
</code></pre><p><strong>输出：</strong></p>
<pre tabindex="0"><code>wz,xy,xz,
</code></pre><p><strong>说明：</strong></p>
<ul>
<li>数字 <code>8</code> 对应字母为 <code>w, x</code>，数字 <code>9</code> 对应字母为 <code>y, z</code>；</li>
<li>生成的组合有 <code>wy, wz, xy, xz</code>；</li>
<li>屏蔽 <code>wy</code> 后，删除只包含 <code>w</code> 和 <code>y</code> 的组合；</li>
<li>最终保留组合 <code>wz, xy, xz</code>。</li>
</ul>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;
import java.util.stream.Collectors;

/**
 * @author Signal Yu
 * @since 2024-11-26
 */
public class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // Read input for digits and blocking string
        String digits = in.nextLine().trim();
        String blockString = in.nextLine().trim();

        in.close();

        // Generate combinations and filter based on blocking constraints
        Map&lt;Character, String&gt; digitToLetters = getDigitToStringMap();
        List&lt;String&gt; combinations = generateCombinations(digits, digitToLetters);
        List&lt;String&gt; filteredCombinations = filterCombinations(combinations, blockString);

        // Format and output results
        printFormattedCombinations(filteredCombinations);

    }

    private static Map&lt;Character, String&gt; getDigitToStringMap() {
        return Map.of(
                '0', "abc", '1', "def", '2', "ghi", '3', "jkl",
                '4', "mno", '5', "pqr", '6', "st", '7', "uv",
                '8', "wx", '9', "yz"
        );
    }

    private static List&lt;String&gt; generateCombinations(String digits, Map&lt;Character, String&gt; digitToLetters) {
        List&lt;String&gt; combinations = new ArrayList&lt;&gt;();
        backtrack(digits, digitToLetters, 0, new StringBuilder(), combinations);
        return combinations;
    }

    private static void backtrack(String digits, Map&lt;Character, String&gt; digitToLetters,
                                  int index, StringBuilder current, List&lt;String&gt; combinations) {
        if (index == digits.length()) {
            combinations.add(current.toString());
            return;
        }

        String letters = digitToLetters.get(digits.charAt(index));
        for (char letter : letters.toCharArray()) {
            current.append(letter);
            backtrack(digits, digitToLetters, index + 1, current, combinations);
            current.deleteCharAt(current.length() - 1); // Backtrack to explore other options
        }
    }

    private static List&lt;String&gt; filterCombinations(List&lt;String&gt; combinations, String blockString) {
        Set<Character> blockCharSet = blockString.chars()
                .mapToObj(c -> (char) c).collect(Collectors.toSet());

        return combinations.stream()
                .filter(combination -> !blockCharSet.stream().allMatch(c -> combination.contains(c.toString())))
                .collect(Collectors.toList());
    }

    private static void printFormattedCombinations(List&lt;String&gt; combinations) {
        String result = combinations.stream().collect(Collectors.joining(",", "", ","));
        System.out.println(result);
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="等和子数组最小和100分">等和子数组最小和【100分】<a hidden class="anchor" aria-hidden="true" href="#等和子数组最小和100分">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>一、题目描述</strong>
给定一个整数数组 <code>nums</code>，要求将数组元素划分为若干组，使得每组的元素和相等。请计算所有满足条件的分组中，<strong>组内元素和的最小值</strong>。</p>
<p><strong>二、输入描述</strong></p>
<ul>
<li>第一行输入一个整数 <code>m</code>，表示数组的长度。</li>
<li>第二行输入 <code>m</code> 个整数，表示数组 <code>nums</code> 的元素值（用空格分隔）。</li>
</ul>
<p><strong>数据范围：</strong></p>
<ul>
<li>$1 \leq m \leq 50$</li>
<li>$1 \leq \text{nums}[j] \leq 50$</li>
</ul>
<p><strong>三、输出描述</strong></p>
<p>输出所有满足条件的分组中，组内元素和的最小值。</p>
<p><strong>输入示例 1</strong></p>
<p><strong>输入</strong></p>
<pre tabindex="0"><code>3
1 3 2
</code></pre><p><strong>输出：</strong></p>
<pre tabindex="0"><code>3
</code></pre><p><strong>说明</strong>：</p>
<p>数组和为 $1 + 3 + 2 = 6$。</p>
<ul>
<li>数组可以被分组为：$[1, 2]$, $[3]$。</li>
<li>每组和为 $3$，因此满足条件的最小组内和为 <strong>3</strong>。</li>
</ul>
<p><strong>输入示例 2</strong></p>
<p><strong>输入</strong></p>
<pre tabindex="0"><code>7  
4 3 2 3 5 2 1
</code></pre><p><strong>输出：</strong></p>
<pre tabindex="0"><code>5
</code></pre><p><strong>说明</strong>：</p>
<p>数组和为 $4 + 3 + 2 + 3 + 5 + 2 + 1 = 20$。</p>
<ul>
<li>数组可以被分组为：$[5]$, $[4, 1]$, $[3, 2]$, $[3, 2]$。</li>
<li>每组和为 $5$，因此满足条件的最小组内和为 <strong>5</strong>。</li>
</ul>
<p><strong>输入示例 3</strong></p>
<p><strong>输入</strong></p>
<pre tabindex="0"><code>10
4 6 5 5 8 2 3 3 3 1
</code></pre><p><strong>输出：</strong></p>
<pre tabindex="0"><code>8
</code></pre><p><strong>说明</strong>：</p>
<ul>
<li>数组可以被分组为：$[8]$, $[6, 2]$, $[3, 5]$, $[3, 5]$, $[1, 3, 4]$。</li>
<li>每组和为 $8$，因此满足条件的最小组内和为 <strong>8</strong>。</li>
</ul>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.Arrays;
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

/**
 * @author Signal Yu
 * @since 2024-11-27
 */
public class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        int n = Integer.parseInt(in.nextLine().trim());
        int[] nums = Arrays.stream(in.nextLine().trim().split(" "))
                .mapToInt(Integer::parseInt)
                .toArray();

        // FInd the minimum group sum
        int result = findMinimumGroupSum(nums);

        System.out.println(result);
    }

    private static int findMinimumGroupSum(int[] nums) {
        // Total sum of the array
        int totalSum = Arrays.stream(nums).sum();
        // Maximum value in the array
        int max = Arrays.stream(nums).max().orElse(0);

        // Iterate from maxNum to totalSum to find the smallest feasible group sum
        for (int targetSum = max; targetSum <= totalSum; targetSum++) {
            if (totalSum % targetSum == 0 && canPartition(nums, new HashSet&lt;&gt;(), targetSum, 0, 0)) {
                return targetSum;
            }
        }

        // If no partitioning is possible, return the total sum
        return totalSum;
    }

    private static boolean canPartition(int[] nums, Set&lt;Integer&gt; usedIndex, int targetSum, int currentSum, int index) {
        if (usedIndex.size() == nums.length && currentSum == 0) {
            return true;
        }

        for (int i = index; i < nums.length; i++) {
            // Skip already used elements
            if (usedIndex.contains(i)) {
                continue;
            }

            // Mark the current element as used
            usedIndex.add(i);

            if (currentSum + nums[i] <= targetSum) {
                // If the current group is completed (current sum equals targetSum), start a new group
                if (currentSum + nums[i] == targetSum) {
                    if (canPartition(nums, usedIndex, targetSum, 0, 0)) {
                        return true;
                    }
                } else { // Otherwise, continue adding elements to the current group
                    if (canPartition(nums, usedIndex, targetSum, currentSum + nums[i], i + 1)) {
                        return true;
                    }
                }

            }

            // Backtrack: Unmark the current element as used
            usedIndex.remove(i);
        }

        return false;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="melon-的难题100分">MELON 的难题【100分】<a hidden class="anchor" aria-hidden="true" href="#melon-的难题100分">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>一、题目描述</strong></p>
<p>MELON 有一堆精美的雨花石（共有 n 块，重量各异），准备送给 S 和 W。MELON 希望将这些雨花石的重量均匀地分配给两个人。请你设计一个程序，帮 MELON 确认是否可以将雨花石平分，并找出最少需要移除的雨花石数量，使得剩下的雨花石能够均匀分配。</p>
<p><strong>二、输入描述</strong></p>
<ul>
<li>第 1 行输入一个整数 n，表示雨花石的数量，满足 <code>0 &lt; n &lt; 31</code>。</li>
<li>第 2 行输入 n 个整数，表示各块雨花石的重量，重量值 m[i] 满足 <code>0 &lt; m[i] &lt; 1001</code>，每个重量之间用空格分隔。</li>
</ul>
<p><strong>三、输出描述</strong></p>
<ul>
<li>如果可以均分，输出从当前雨花石中最少需要移除的块数，使得两堆的重量相等。</li>
<li>如果无法均分，输出 -1。</li>
</ul>
<p><strong>四、测试用例</strong></p>
<p><strong>示例1：</strong></p>
<p><strong>输入：</strong></p>
<pre tabindex="0"><code>4
1 1 2 2
</code></pre><p><strong>输出：</strong></p>
<pre tabindex="0"><code>2
</code></pre><p><strong>说明：</strong></p>
<p>输入第一行代表共4颗雨花石，第二行代表4颗雨花石重量分别为1、1、2、2。均分时只能分别为1,2，需要拿出重星为1和2的两块雨花石，所以输出2。</p>
<p><strong>示例2：</strong></p>
<p><strong>输入：</strong></p>
<pre tabindex="0"><code>10
1 1 1 1 1 9 8 3 7 10
</code></pre><p><strong>输出：</strong></p>
<pre tabindex="0"><code>3
</code></pre><p><strong>说明：</strong></p>
<p>输入第一行代表共10颗雨花石，第二行代表4颗雨花石重量分别为 1、1、1、1、1、9、8、3、7、10。均分时可以 1,1,1,1,1,9,7 和 10,8,3，也可以 1,1,1,1,9,8 和10,7,3,1，或者其他均分方式，但第一种只需要拿出重量为10,8,3 的 3 块雨花石，第二种需要拿出 4 块,所以输出 3。</p>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

/**
 * @author Signal Yu
 * @since 2024-11-29
 */
public class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        int n = Integer.parseInt(in.nextLine().trim());
        int[] weights = Arrays.stream(in.nextLine().trim().split(" "))
                .mapToInt(Integer::parseInt)
                .toArray();

        // 计算最小雨花石数量
        int result = getMinimumStones(weights);

        System.out.println(result);
    }

    private static int getMinimumStones(int[] weights) {
        // 计算所有雨花石的总重量
        int totalWeights = Arrays.stream(weights).sum();

        // 如果总重量是奇数，则无法平分，直接返回 -1
        if (totalWeights % 2 == 1) {
            return -1;
        }

        // 计算每堆应该分配的目标重量（即一半的总重量）
        int target = totalWeights / 2;

        // 使用回溯法查找长度最短的的子集，若不存在有效子集则返回 Integer.MAX_VALUE
        int result = backtrack(weights, target, new ArrayList&lt;&gt;(),  0);

        return result == Integer.MAX_VALUE ? -1 : result;
    }

    private static int backtrack(int[] nums, int target, List&lt;Integer&gt; current, int index) {
        // 如果目标重量为 0，说明已经找到一个有效子集，返回当前子集的大小
        if (target == 0) {
            return current.size();
        }

        // 初始化一个变量用于保存找到的最小子集大小
        int count = Integer.MAX_VALUE;

        // 从当前索引位置开始遍历所有未选择的元素
        for (int i = index; i < nums.length; i++) {
            // 如果当前元素大于目标重量，跳过该元素
            if (nums[i] > target) {
                continue;
            }

            // 将当前元素加入子集
            current.add(nums[i]);

            // 更新最小子集大小
            count = Math.min(count, backtrack(nums, target - nums[i], current, i + 1));

            // 回溯，移除当前元素，尝试其他可能的子集
            current.remove(current.size() - 1);
        }

        return count; // 返回最小子集的大小，有效子集不存在则返回 Integer.MAX_VALUE
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h1 id="矩阵遍历">矩阵遍历<a hidden class="anchor" aria-hidden="true" href="#矩阵遍历">#</a></h1>
<h2 id="200-number-of-islands">200. Number of Islands<a hidden class="anchor" aria-hidden="true" href="#200-number-of-islands">#</a></h2>

<a href="https://leetcode.com/problems/number-of-islands" target="_blank">
Go to Leetcode 🔗
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    // Directions representing movement: up, down, left, right
    private static final int[][] DIRECTIONS = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

    public int numIslands(char[][] grid) {
        int rows = grid.length;
        int cols = grid[0].length;

        int totalIslands = 0;
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                // If a land cell ('1') is found, it represents a new island
                if (grid[i][j] == '1') {
                    totalIslands++;
                    // Use DFS to mark all cells in this island as visited
                    visitIslandDFS(grid, i, j);
                }
            }
        }

        return totalIslands;
    }

    private static void visitIslandDFS(char[][] grid, int x, int y) {
        // Check for out-of-bounds or water cell ('0')
        if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] == '0') {
            return;
        }

        // Mark the cell as visited by changing it to '0'
        grid[x][y] = '0';

        // Explore all four adjacent directions
        for (int[] DIRECTION : DIRECTIONS) {
            visitIslandDFS(grid, x + DIRECTIONS[i][0], y + DIRECTIONS[i][1]);
        }
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="1926-nearest-exit-from-entrance-in-maze">1926. Nearest Exit from Entrance in Maze<a hidden class="anchor" aria-hidden="true" href="#1926-nearest-exit-from-entrance-in-maze">#</a></h2>

<a href="https://leetcode.com/problems/nearest-exit-from-entrance-in-maze" target="_blank">
Go to Leetcode 🔗
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    // Direction vectors for up, down, left, right
    private static final int[][] DIRECTIONS = { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 } };

    public int nearestExit(char[][] maze, int[] entrance) {
        int rows = maze.length;
        int cols = maze[0].length;
        Queue&lt;int[]&gt; queue = new LinkedList<>();
        
        // Initialize the queue with entrance point and mark it as visited
        queue.offer(new int[] { entrance[0], entrance[1], 0 });
        maze[entrance[0]][entrance[1]] = '+';

        // Perform BFS to find the nearest exit
        while (!queue.isEmpty()) {
            int[] current = queue.poll();
            int x = current[0], y = current[1], steps = current[2];

            // Check all 4 possible directions
            for (int[] direction : DIRECTIONS) {
                int newX = x + direction[0], newY = y + direction[1];
                
                // Skip out-of-bound coordinates or visited cells
                if (newX < 0 || newX >= rows || newY < 0 || newY >= cols || maze[newX][newY] == '+') {
                    continue;
                }

                // Check if the current position is a boundary (exit)
                if (newX == 0 || newX == rows - 1 || newY == 0 || newY == cols - 1) {
                    return steps + 1; // Exit found, return the number of steps
                }

                // Otherwise, mark as visited and add to queue
                queue.offer(new int[] { newX, newY, steps + 1 });
                maze[newX][newY] = '+';
            }
        }

        // No exit found
        return -1;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="934-shortest-bridge">934. Shortest Bridge<a hidden class="anchor" aria-hidden="true" href="#934-shortest-bridge">#</a></h2>

<a href="https://leetcode.com/problems/shortest-bridge" target="_blank">
Go to Leetcode 🔗
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    private static final int[][] DIRECTIONS = { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 } };

    public int shortestBridge(int[][] grid) {
        int rows = grid.length, cols = grid[0].length;
        Queue&lt;int[]&gt; queue = new LinkedList<>();

        // Find the first island and mark it while adding its positions to the queue
        outerLoop:
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (grid[i][j] == 1) {
                    // Perform DFS to mark the first island
                    findFirstIslandDFS(grid, i, j, queue);
                    // Break as soon as the first island is found
                    break outerLoop; 
                }
            }
        }

        // BFS to expand from the first island to find the shortest bridge
        int steps = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                int[] current = queue.poll();
                for (int[] direction : DIRECTIONS) {
                    int x = current[0] + direction[0];
                    int y = current[1] + direction[1];

                    if (x >= 0 && x < rows && y >= 0 && y < cols) {
                        // Found the second island
                        if (grid[x][y] == 1) {
                            return steps;
                        } else if (grid[x][y] == 0) {
                            queue.offer(new int[] { x, y });
                            grid[x][y] = 2; // Mark as visited
                        }
                    }
                }
            }
            steps++; // Increment steps after processing one level of BFS
        }

        return steps;
    }

    private static void findFirstIslandDFS(int[][] grid, int x, int y, Queue&lt;int[]&gt; queue) {
        if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] != 1) {
            return;
        }

        // Mark the current cell as part of the first island (visited)
        queue.offer(new int[] { x, y });
        grid[x][y] = 2;

        // Explore all four directions
        for (int[] direction : DIRECTIONS) {
            findFirstIslandDFS(grid, x + direction[0], y + direction[1], queue);
        }
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="heading-3"><a hidden class="anchor" aria-hidden="true" href="#heading-3">#</a></h2>
<h2 id="战场索敌100分">战场索敌【100分】<a hidden class="anchor" aria-hidden="true" href="#战场索敌100分">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>题目描述</strong></p>
<p>在一个大小为 $N \times M$ 的战场地图上，地图由墙壁（<code>#</code>）分隔成若干个区域，每个区域由上下左右相邻的空地（<code>.</code>）组成。同一个区域内，只有空地上可能存在敌人（<code>E</code>）。请计算地图上敌人数小于 $K$ 的区域数量。</p>
<p><strong>输入描述</strong></p>
<p>第一行输入三个整数 $N$, $M$, $K$：</p>
<ul>
<li>$N$ 表示地图的行数（$1 \leq N \leq 100$）；</li>
<li>$M$ 表示地图的列数（$1 \leq M \leq 100$）；</li>
<li>$K$ 表示目标敌人数量。</li>
</ul>
<p>接下来的 $N$ 行输入为大小为 $N \times M$ 的字符数组：</p>
<ul>
<li>每个字符为以下之一：
<ul>
<li><code>#</code> 表示墙壁；</li>
<li><code>.</code> 表示空地；</li>
<li><code>E</code> 表示敌人。</li>
</ul>
</li>
</ul>
<p><strong>输出描述</strong></p>
<p>输出一个整数，表示敌人数小于 $K$ 的区域数量。</p>
<p><strong>输入示例 1</strong></p>
<pre tabindex="0"><code>4 6 3
...#EE
E.#E..
#E#.E.
#.#...
</code></pre><p><strong>输出示例 1</strong></p>
<pre tabindex="0"><code>1
</code></pre><p><strong>说明</strong></p>
<p>地图中有两个区域：</p>
<ul>
<li>左边区域由空地和敌人构成，敌人数为 2；</li>
<li>右边区域由空地和敌人构成，敌人数为 4。</li>
</ul>
<p>符合条件（敌人数小于 3）的区域数量为 1，因此输出 <code>1</code>。</p>
<p><strong>输入示例 2</strong></p>
<pre tabindex="0"><code>6 8 4
..#EE.#E
E.#E..#.
#E#.E.#.
#.#...#E
#.#.E.#E
#.#...#.
</code></pre><p><strong>输出示例 1</strong></p>
<pre tabindex="0"><code>1
</code></pre><p><strong>说明</strong></p>
<p>地图中有两个区域：</p>
<ul>
<li>左边区域由空地和敌人构成，敌人数为 2；</li>
<li>中间区域由空地和敌人构成，敌人数为 5；</li>
<li>右边区域由空地和敌人构成，敌人数为 3。</li>
</ul>
<p>符合条件（敌人数小于 4）的区域数量为 2，因此输出 <code>1</code>。</p>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.Arrays;
import java.util.Scanner;

/**
 * @author Signal Yu
 * @since 2024-11-26
 */
public class Solution {
    // Directions for movement: up, down, left, right
    private static final int[][] DIRECTIONS = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // Read input for the number of rows, columns, and enemies
        int[] parts = Arrays.stream(in.nextLine().trim().split(" "))
                .mapToInt(Integer::parseInt)
                .toArray();
        int rows = parts[0];
        int cols = parts[1];
        int k = parts[2];

        char[][] matrix = new char[rows][cols];
        for (int i = 0; i < rows; i++) {
            matrix[i] = in.nextLine().trim().toCharArray();
        }

        // Count enemies in an area less than k
        int result = countEnemies(matrix, k);

        // Print result
        System.out.println(result);
    }

    private static int countEnemies(char[][] matrix, int k) {
        int rows = matrix.length;
        int cols = matrix[0].length;

        boolean[][] visited = new boolean[rows][cols];
        int regions = 0;

        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (!visited[i][j] && (matrix[i][j] == '.' || matrix[i][j] == 'E')) {
                    // Perform DFS to calculate enemy count in the region
                    int enemyCount = visitCellDFS(matrix, visited, i, j);
                    if (enemyCount < k) {
                        regions++;
                    }
                }
            }
        }

        return regions;
    }

    private static int visitCellDFS(char[][] matrix, boolean[][] visited, int x, int y) {
        // Check if out-of-bounds or already visited or wall
        if (x < 0 || x >= matrix.length || y < 0 || y >= matrix[0].length || visited[x][y] || matrix[x][y] == '#') {
            return 0;
        }

        // Mark the current cell as visited
        visited[x][y] = true;

        int enemyCount = matrix[x][y] == 'E' ? 1 : 0;

        for (int[] DIRECTION : DIRECTIONS) {
            enemyCount += visitCellDFS(matrix, visited, x + DIRECTION[0], y + DIRECTION[1]);
        }

        return enemyCount;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>$\text{SHOW MATRIX}[4][6]$</summary>
        <div>
            
<style>
    table {
        width: 100%;
        font-size: 18px;
    }
    tr, th, td {
        border: 2px solid #dee4eb;  
        padding: 5px;  
    }
</style>



<table>
    
        <caption>Battlefield Matrix[4][6]</caption>
    
    
<tr>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: green;">.</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: green;">.</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: green;">.</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;">#</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: grey;">E</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: grey;">E</td>
</tr>
<tr>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: grey;">E</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: green;">.</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;">#</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: grey;">E</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: green;">.</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: green;">.</td>
</tr>
<tr>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;">#</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: grey;">E</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;">#</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: green;">.</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: grey;">E</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: green;">.</td>
</tr>
<tr>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;">#</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: green;">.</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;">#</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: green;">.</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: green;">.</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: green;">.</td>
</tr>

</table>

        </div>
    </details>
</div>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>$\text{SHOW MATRIX}[6][8]$</summary>
        <div>
            
<style>
    table {
        width: 100%;
        font-size: 18px;
    }
    tr, th, td {
        border: 2px solid #dee4eb;  
        padding: 5px;  
    }
</style>



<table>
    
        <caption>Battlefield Matrix[6][8]</caption>
    
    
<tr>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: green;">.</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: green;">.</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;">#</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: grey;">E</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: grey;">E</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: green;">.</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;">#</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: grey;">E</td>
</tr>
<tr>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: grey;">E</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: green;">.</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;">#</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: grey;">E</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: green;">.</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: green;">.</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;">#</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: green;">.</td>
</tr>
<tr>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;">#</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: grey;">E</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;">#</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: green;">.</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: grey;">E</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: green;">.</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;">#</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: green;">.</td>
</tr>
<tr>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;">#</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: green;">.</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;">#</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: green;">.</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: green;">.</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: green;">.</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;">#</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: grey;">E</td>
</tr>
<tr>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;">#</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: green;">.</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;">#</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: green;">.</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: grey;">E</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: green;">.</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;">#</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: grey;">E</td>
</tr>
<tr>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;">#</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: green;">.</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;">#</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: green;">.</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: green;">.</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: green;">.</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;">#</td>
    <td style="text-align: center;width: 30px;height: 30px;font-family: monospace;background-color: green;">.</td>
</tr>

</table>

        </div>
    </details>
</div>
<hr>
<h2 id="查找单入口空闲区域100分">查找单入口空闲区域【100分】<a hidden class="anchor" aria-hidden="true" href="#查找单入口空闲区域100分">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>一、题目描述</strong></p>
<p>给定一个大小为 $m \times n$ 的矩阵，其中包含字符 <code>'X'</code> 和 <code>'O'</code>。字符 <code>'X'</code> 表示已被占据的位置，字符 <code>'O'</code> 表示空闲位置。你的任务是找到<strong>最大的单入口空闲区域</strong>。</p>
<p><strong>定义：</strong></p>
<ol>
<li><strong>空闲区域</strong>：由相连的 <code>'O'</code> 构成的区域。</li>
<li><strong>单入口空闲区域</strong>：仅有一个位于矩阵边界的 <code>'O'</code> 作为入口，并由此入口延伸形成的连通 <code>'O'</code> 区域。</li>
<li><strong>连通</strong>：两个元素在水平方向或垂直方向相邻，则称它们是连通的。</li>
</ol>
<p><strong>二、输入描述</strong></p>
<ul>
<li>第1行包含两个整数 $m$ 和 $n$，分别表示矩阵的行数和列数（以空格分隔），满足 $1 \leq m, n \leq 200$。</li>
<li>接下来的 $m$ 行，每行包含 $n$ 个字符，字符为 <code>'X'</code> 或 <code>'O'</code>（以空格分隔）。</li>
</ul>
<p><strong>三、输出描述</strong></p>
<p>根据输入，输出如下结果之一：</p>
<ol>
<li>如果存在唯一符合条件的<strong>最大单入口空闲区域</strong>，输出三个整数：
<ul>
<li>第一个整数：入口的行坐标（从 $0$ 到 $m-1$）。</li>
<li>第二个整数：入口的列坐标（从 $0$ 到 $n-1$）。</li>
<li>第三个整数：该区域的大小。<br>
输出格式为：<code>row col size</code>。</li>
</ul>
</li>
<li>如果存在多个符合条件的<strong>最大单入口空闲区域</strong>：
<ul>
<li>输出区域大小最大的一个的三个整数，若存在多个区域大小相同的情况，则仅输出区域大小，格式为：<code>size</code>。</li>
</ul>
</li>
<li>如果没有任何符合条件的单入口空闲区域，输出：<code>NULL</code>。</li>
</ol>
<p><strong>示例输入1：</strong></p>
<pre tabindex="0"><code>5 4
X X X X 
X O O O  
X X X X  
X O O O  
X X X X  
</code></pre><p><strong>输出:</strong></p>
<pre tabindex="0"><code>3
</code></pre><p><strong>说明：</strong></p>
<p>存在两个大小为 3 的最大单入口区域，两个入口坐标分别为 $(1, 3)$、$(3,3)$，只需输出大小 3。</p>
<p><strong>示例输入2：</strong></p>
<pre tabindex="0"><code>4 4
X X X X 
O O O O  
X X X X  
X O O O  
</code></pre><p><strong>输出:</strong></p>
<pre tabindex="0"><code>NULL
</code></pre><p><strong>说明：</strong></p>
<p>不存在单入口区域</p>
<p><strong>示例输入3：</strong></p>
<pre tabindex="0"><code>6 6
X X X X O X
O O O O X X
X X X X O O
X O O O X X
X X X O X X
X X X O X O
</code></pre><p><strong>输出:</strong></p>
<pre tabindex="0"><code>5 3 5
</code></pre><p><strong>说明：</strong></p>
<p>存在最大单入口区域 (5, 4)，大小为 5</p>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.Arrays;
import java.util.Scanner;

/**
 * @author Signal Yu
 * @since 2024-11-27
 */
public class Solution {
    // Movement directions: up, down, left, right
    private static final int[][] DIRECTIONS = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // Parse matrix dimensions
        int[] dimensions = Arrays.stream(in.nextLine().trim().split(" "))
                .mapToInt(Integer::parseInt)
                .toArray();
        int rows = dimensions[0];
        int cols = dimensions[1];

        // Populate the matrix with input data
        char[][] matrix = new char[rows][cols];
        for (int i = 0; i < rows; i++) {
            char[] row = in.nextLine().trim().replace(" ", "").toCharArray();
            matrix[i] = row;
        }

        // Explore the matrix to find the largest single-entry free area
        Result result = findLargestSingleEntryArea(matrix);

        if (result.areaSize == 0) {
            System.out.println("NULL");
        } else if (result.hasMultipleMaxAreas) {
            System.out.println(result.areaSize);
        } else {
            System.out.printf("%d %d %d\n", result.entryRow, result.entryCol, result.areaSize);
        }
    }

    private static Result findLargestSingleEntryArea(char[][] matrix) {
        int rows = matrix.length;
        int cols = matrix[0].length;

        int maxAreaSize = 0;
        int maxEntryRow = -1;
        int maxEntryCol = -1;
        boolean hasMultipleMaxArea = false;
        boolean[][] visited = new boolean[rows][cols];

        // Traverse the matrix to identify single-entry free areas
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                // Perform DFS operation from boundary cells with 'O' that have not been visited
                if (isBoundary(matrix, i, j) && matrix[i][j] == 'O' && !visited[i][j]) {
                    Result result = new Result(0, 0, i, j, hasMultipleMaxArea);

                    visitCellDFS(matrix, visited, i, j, result);

                    // Check if the region is a single-entry free area
                    if (result.boundaryCount == 1) {
                        if (result.areaSize > maxAreaSize) {
                            maxAreaSize = result.areaSize;
                            maxEntryRow = result.entryRow;
                            maxEntryCol = result.entryCol;
                            hasMultipleMaxArea = false;
                        } else if (result.areaSize == maxAreaSize) {
                            hasMultipleMaxArea = true;
                        }
                    }


                }
            }
        }

        return new Result(maxAreaSize, 0, maxEntryRow, maxEntryCol, hasMultipleMaxArea);
    }

    private static void visitCellDFS(char[][] matrix, boolean[][] visited, int x, int y, Result result) {
        if (x < 0 || x >= matrix.length || y < 0 || y >= matrix[0].length || matrix[x][y] != 'O' || visited[x][y]) {
            return;
        }

        visited[x][y] = true;
        result.areaSize++;

        if (isBoundary(matrix, x, y)) {
            result.boundaryCount++;
        }

        for (int[] direction : DIRECTIONS) {
            visitCellDFS(matrix, visited, x + direction[0], y + direction[1], result);
        }
    }

    private static boolean isBoundary(char[][] matrix, int x, int y) {
        return x == 0 || x == matrix.length - 1 || y == 0 || y == matrix[0].length - 1;
    }

    private static class Result {
        int areaSize;           // Size of the region
        int boundaryCount;      // Number of boundary cells in the region
        int entryRow;           // Row index of the entry point
        int entryCol;           // Column index of the entry point
        boolean hasMultipleMaxAreas; // Flag indicating multiple regions with the same maximum size

        public Result(int areaSize, int boundaryCount, int entryRow, int entryCol, boolean hasMultipleMaxAreas) {
            this.areaSize = areaSize;
            this.boundaryCount = boundaryCount;
            this.entryRow = entryRow;
            this.entryCol = entryCol;
            this.hasMultipleMaxAreas = hasMultipleMaxAreas;
        }
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="按图找最近的路100分">按图找最近的路【100分】<a hidden class="anchor" aria-hidden="true" href="#按图找最近的路100分">#</a></h2>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>一、题目描述</strong></p>
<p>有一张 $m \times n$ 的地图，其中有起点和终点的位置，并且在两点之间存在高山湖泊，高山湖泊会挡住路径，需要绕道行走。请问从起点到终点的最短路径有几条，且最短路径的距离是多少？</p>
<p>请注意：</p>
<ul>
<li>走动的路线只能沿着上下左右四个方向，不能斜着走。</li>
<li>如果有多个最短路径，输出所有最短路径的条数和距离。</li>
</ul>
<p><strong>二、输入描述</strong></p>
<p>输入数据格式如下：</p>
<ul>
<li>地图的大小为 $m \times n$，其中 $m$ 和 $n$ 为正整数，表示地图的行数和列数。</li>
<li>起点坐标为一对整数 $(x_1, y_1)$，表示起点的位置。</li>
<li>终点坐标为一对整数 $(x_2, y_2)$，表示终点的位置。</li>
<li>高山湖泊的个数为正整数 $k$，并给出每个湖泊的坐标。</li>
</ul>
<p>假设输入数据为：</p>
<pre tabindex="0"><code>m n
x1 y1
x2 y2
k
x3 y3
x4 y4
...
</code></pre><ul>
<li><strong>m n</strong>：地图的大小，m 为行数，n 为列数。</li>
<li><strong>x1 y1</strong>：起点坐标。</li>
<li><strong>x2 y2</strong>：终点坐标。</li>
<li><strong>k</strong>：高山湖泊的数量。</li>
<li><strong>x3 y3, x4 y4, &hellip;</strong>：高山湖泊的位置。</li>
</ul>
<p><strong>三、输出描述</strong></p>
<p>输出一个整数表示最短路径的条数和最短路径的距离，格式为“路径条数 距离”。</p>
<p><strong>示例 1</strong></p>
<p><strong>输入</strong>：</p>
<pre tabindex="0"><code>5 5
0 1
3 3
1
2 2
</code></pre><p><strong>输出：</strong></p>
<pre tabindex="0"><code>4 5
</code></pre><p><strong>说明：</strong></p>
<ul>
<li>输入表示地图的大小是 5×5，起点在 (0,1)，终点在 (3,3)，有 1 个湖泊，湖泊的坐标为 (2,2)。</li>
<li>最短路径共有 4 条，且每条路径的距离为 5。</li>
</ul>
<p><strong>示例 2</strong></p>
<p><strong>输入</strong>：</p>
<pre tabindex="0"><code>5 5
0 1
3 3
2
1 2
2 2
</code></pre><p><strong>输出：</strong></p>
<pre tabindex="0"><code>2 5
</code></pre><p><strong>说明：</strong></p>
<ul>
<li>输入表示地图的大小是 5×5，起点在 (0,1)，终点在 (3,3)，有 2 个湖泊，湖泊的坐标为 (1,2) 和 (2,2)。</li>
<li>最短路径共有 2 条，且每条路径的距离为 5。</li>
</ul>
<p><strong>示例 3</strong></p>
<p><strong>输入</strong>：</p>
<pre tabindex="0"><code>5 5
0 1
3 3
3
0 2
1 2
2 2
</code></pre><p><strong>输出：</strong></p>
<pre tabindex="0"><code>1 5
</code></pre><p><strong>说明：</strong></p>
<ul>
<li>输入表示地图的大小是 5×5，起点在 (0,1)，终点在 (3,3)，有 3 个湖泊，湖泊的坐标为 (0,2)、(1,2) 和 (2,2)。</li>
<li>最短路径共有 2 条，且每条路径的距离为 5。</li>
</ul>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.*;

/**
 * @author Signal Yu
 * @since 2024-11-28
 */
public class Solution {
    private static final int[][] DIRECTIONS = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // Read matrix dimensions
        int[] parts = Arrays.stream(in.nextLine().trim().split(" "))
                .mapToInt(Integer::parseInt)
                .toArray();

        // Initialize the matrix
        char[][] matrix = new char[parts[0]][parts[1]];
        for (int i = 0; i < parts[0]; i++) {
            Arrays.fill(matrix[i], '.');
        }

        // Read start and end coordinates
        int[] start = Arrays.stream(in.nextLine().trim().split(" "))
                .mapToInt(Integer::parseInt)
                .toArray();
        matrix[start[0]][start[1]] = 'S';

        int[] end = Arrays.stream(in.nextLine().trim().split(" "))
                .mapToInt(Integer::parseInt)
                .toArray();
        matrix[end[0]][end[1]] = 'E';

        // Read number of obstacles and update the matrix
        int obstacleCount = Integer.parseInt(in.nextLine().trim());
        for (int i = 0; i < obstacleCount; i++) {
            int[] obstacle = Arrays.stream(in.nextLine().trim().split(" "))
                    .mapToInt(Integer::parseInt)
                    .toArray();
            matrix[obstacle[0]][obstacle[1]] = '#';
        }

        // Find the shortest paths and distance
        int[] result = findShortestPaths(matrix, start, end);

        // Output the result: number of paths and the shortest distance
        System.out.printf("%d %d\n", result[0], result[1]);
    }

    private static int[] findShortestPaths(char[][] matrix, int[] start, int[] end) {
        int rows = matrix.length, cols = matrix[0].length;

        Queue&lt;int[]&gt; queue = new LinkedList<>();
        queue.add(new int[]{start[0], start[1]});

        int[][] distance = new int[rows][cols];
        for (int i = 0; i < rows; i++) {
            Arrays.fill(distance[i], Integer.MAX_VALUE); // Initialize distances to infinity
        }
        distance[start[0]][start[1]] = 0;

        int[][] pathCount = new int[rows][cols];
        pathCount[start[0]][start[1]] = 1; // Start point has 1 way to reach itself

        while (!queue.isEmpty()) {
            int[] current = queue.poll();
            int x = current[0], y = current[1];

            // Explore the four directions
            for (int[] direction : DIRECTIONS) {
                int newX = x + direction[0];
                int newY = y + direction[1];

                // Check if the new position is within bounds and not an obstacle
                if (isValidPosition(matrix, newX, newY)) {
                    // If the new position is unvisited, update distance and add to queue
                    if (distance[newX][newY] == Integer.MAX_VALUE) {
                        distance[newX][newY] = distance[x][y] + 1;
                        queue.add(new int[]{newX, newY});
                        pathCount[newX][newY] = pathCount[x][y];
                    } else if (distance[newX][newY] == distance[x][y] + 1) {
                        // If the new position has the same distance, increment path count
                        pathCount[newX][newY] += pathCount[x][y];
                    }
                }
            }
        }

        // Return the number of paths and distance to the end point, or (0, 0) if unreachable
        return distance[end[0]][end[1]] == Integer.MAX_VALUE
                ? new int[]{0, 0}
                : new int[]{pathCount[end[0]][end[1]], distance[end[0]][end[1]]};
    }

    private static boolean isValidPosition(char[][] matrix, int x, int y) {
        return x >= 0 && x < matrix.length && y >= 0 && y < matrix[0].length && matrix[x][y] != '#';
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h1 id="计数模式相关算法题">计数模式相关算法题<a hidden class="anchor" aria-hidden="true" href="#计数模式相关算法题">#</a></h1>
<h2 id="最大频率元素计数">最大频率元素计数<a hidden class="anchor" aria-hidden="true" href="#最大频率元素计数">#</a></h2>

<a href="https://leetcode.cn/problems/count-elements-with-maximum-frequency" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int maxFrequencyElements(int[] nums) {
        Map<Integer, Integer> frequencyMap = new HashMap<>();
        int maxCount = 0; // 记录元素的最大出现频率
        int total = 0; // 记录具有最大频率的所有元素的出现次数总和

        // 遍历数组以构建频率映射
        for (int num : nums) {
            int count = frequencyMap.getOrDefault(num, 0) + 1;
            frequencyMap.put(num, count);

            // 如果当前元素的频率超过之前的最大频率，更新maxCount并重置total
            if (count > maxCount) {
                maxCount = count;
                total = count; // 重置total为新的最大频率的值
            } else if (count == maxCount) {
                // 如果当前元素的频率等于最大频率，将该频率值加到total中
                total += count;
            }
        }

        return total; 
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="人口最多的年份">人口最多的年份<a hidden class="anchor" aria-hidden="true" href="#人口最多的年份">#</a></h2>

<a href="https://leetcode.cn/problems/maximum-population-year" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int maximumPopulation(int[][] logs) {
        int[] population = new int[101];
        // 记录人口增减：出生年份 +1，死亡年份 -1
        for (int[] log : logs) {
            population[log[0] - 1950] += 1;
            population[log[1] - 1950] -= 1;
        }

        int currentPopulation = 0, maxPopulation = 0;
        int maxYear = 1950;
        // 计算每一年的累计人口数
        for (int i = 0; i < population.length; i++) {
            currentPopulation += population[i];
            if (currentPopulation > maxPopulation) { // 累计该年人口数
                // 更新最大人口数和年份
                maxPopulation = currentPopulation;
                maxYear = 1950 + i;
            }
        }

        return maxYear;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="使数组唯一的最小增量">使数组唯一的最小增量<a hidden class="anchor" aria-hidden="true" href="#使数组唯一的最小增量">#</a></h2>

<a href="https://leetcode.cn/problems/minimum-increment-to-make-array-unique" target="_blank">
【力扣传送门】
</a>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Solution {
    public int minIncrementForUnique(int[] nums) {
        int n = nums.length;
        int max = 0;
        // 遍历数组寻找最大元素
        for (int num : nums) {
            max = Math.max(max, num);
        }

        int[] frequencies = new int[n + max];
        // 遍历数组统计每个数字的出现次数
        for (int num : nums) {
            frequencies[num]++;
        }

        int minMoves = 0; // 记录最小移动次数
        for (int i = 0; i < frequencies.length; i++) {
            if (frequencies[i] <= 1) {
                continue;
            }
            int excess = frequencies[i] - 1; // 记录需要移动的元素
            frequencies[i + 1] += excess; // 将需要移动的元素自增1移动至下一位
            minMoves += excess; // 更新最小移动次数
        }

        return minMoves;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://signalyu.github.io/tags/engineering--technology/">Engineering &amp; Technology</a></li>
      <li><a href="https://signalyu.github.io/tags/computer-science/">Computer Science</a></li>
      <li><a href="https://signalyu.github.io/tags/programming/">Programming</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://signalyu.github.io/posts/3-humanities/languages/listening/english/2-learn-english-with-speeches/">
    <span class="title">« PREV</span>
    
    <br>
    <span>Learn English With Speeches</span>
  </a>
  <a class="next" href="https://signalyu.github.io/posts/3-humanities/languages/listening/english/1-learning-english-with-podcasts/">
    <span class="title">NEXT »</span>
    
    <br>
    <span>Learning English With Podcasts</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://signalyu.github.io/">Signal&#39;s Blog</a></span> · 
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>

    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
        mermaid.initialize({
            startOnLoad: true,
            "flowchart": { "htmlLabels": true },
            theme: 'dark',
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
        });
    </script>
    
</body>
</html>
