<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Multithreading &amp; Concurrency | Signal&#39;s Blog</title>
<meta name="keywords" content="Engineering &amp; Technology, Computer Science, Multithreading &amp; Concurrency">
<meta name="description" content="Introduction to Multithreading Program, Process, and Thread A program is a static set of instructions that stores on a disk. A process is an instance of a program that is currently being executed by the operating system. A thread is a small unit of process that can be scheduled and executed by the operating system. In simpler terms, a program is the code, a process is the excution of the code, a thread is a unit of execution within a process.">
<meta name="author" content="Signal Yu">
<link rel="canonical" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/multithreading-and-concurrency/1-multithreading-and-concurrency/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5a0ace7f2dc73037e40ceea0eb0d119b5d798dba2da38d9129982a8cf9fa07a5.css" integrity="sha256-WgrOfy3HMDfkDO6g6w0Rm115jboto42RKZgqjPn6B6U=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://signalyu.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://signalyu.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://signalyu.github.io/favicon-32x32">
<link rel="apple-touch-icon" href="https://signalyu.github.io/apple-touch-icon">
<link rel="mask-icon" href="https://signalyu.github.io/favicon.io">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/multithreading-and-concurrency/1-multithreading-and-concurrency/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css"
    integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"
    integrity="sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd"
    crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js"
    integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk"
    crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: true }
            ],
            
            throwOnError: false,
            strict: false
        });
    });
</script>

  

<meta property="og:title" content="Multithreading &amp; Concurrency" />
<meta property="og:description" content="Introduction to Multithreading Program, Process, and Thread A program is a static set of instructions that stores on a disk. A process is an instance of a program that is currently being executed by the operating system. A thread is a small unit of process that can be scheduled and executed by the operating system. In simpler terms, a program is the code, a process is the excution of the code, a thread is a unit of execution within a process." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/multithreading-and-concurrency/1-multithreading-and-concurrency/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-12-11T12:13:32+08:00" />
<meta property="article:modified_time" content="2024-12-11T12:13:32+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Multithreading &amp; Concurrency"/>
<meta name="twitter:description" content="Introduction to Multithreading Program, Process, and Thread A program is a static set of instructions that stores on a disk. A process is an instance of a program that is currently being executed by the operating system. A thread is a small unit of process that can be scheduled and executed by the operating system. In simpler terms, a program is the code, a process is the excution of the code, a thread is a unit of execution within a process."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://signalyu.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Multithreading \u0026 Concurrency",
      "item": "https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/multithreading-and-concurrency/1-multithreading-and-concurrency/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Multithreading \u0026 Concurrency",
  "name": "Multithreading \u0026 Concurrency",
  "description": "Introduction to Multithreading Program, Process, and Thread A program is a static set of instructions that stores on a disk. A process is an instance of a program that is currently being executed by the operating system. A thread is a small unit of process that can be scheduled and executed by the operating system. In simpler terms, a program is the code, a process is the excution of the code, a thread is a unit of execution within a process.",
  "keywords": [
    "Engineering \u0026 Technology", "Computer Science", "Multithreading \u0026 Concurrency"
  ],
  "articleBody": "Introduction to Multithreading Program, Process, and Thread A program is a static set of instructions that stores on a disk. A process is an instance of a program that is currently being executed by the operating system. A thread is a small unit of process that can be scheduled and executed by the operating system. In simpler terms, a program is the code, a process is the excution of the code, a thread is a unit of execution within a process. Their relationships are illustrated in the following image:\nProgram, Process, and Thread Thread Life Cycle Within Concurrency A thread goes through various states in its life cycle, from creation to its termination. The life cycle of a thread typically includes five states: New, Runnable, Running, Blocked/Waiting, and Terminated.\nNew: This refers to the state where a thread instance is created but has not yet started running. In Java, this is commonly achieved by using new Thread(). Runnable: This refers to the state where a thread instance is ready to run but is waiting for CPU time. In Java, this is commonly achieved by ivoking start() on the thread instance. Running: This is refers to the state where the thread instance is actively executing its task. Blocked/Waiting: This refers to the state where a thread instance is waiting for other threads to complete their tasks, or it is waiting for a particular condition to be met. Terminated: This refers to the state where the thread instance has completed its task and has exited. Thread Life Cycle Within Concurrency Fork/Join Model The Fork/Join Model is an effective strategy commonly used in scenarios where a task can be recursively divided into multiple smaller, independent subtasks. This strategy typically involves the following steps:\nThe process begins with a single master thread. When it encounters a task that can be broken down into smaller subtasks, the master thread forks (spawns) multiple subsidiary threads, each of which takes on a portion of the task.\nOnce the subsidiary threads have completed their respective tasks, they join back with the master thread. Joining involves terminating the subsidiary threads and consolidating their results into the master thread. Afterward, the master thread continues its execution.\nFork/Join Model SHOW CODE Java import java.util.Arrays; import java.util.concurrent.RecursiveTask; import java.util.concurrent.ForkJoinPool; public class Solution { // RecursiveTask to compute the sum of a part of an array static class SumTask extends RecursiveTask { private final int[] array; private final int start; private final int end; // Threshold for splitting the task into smaller subtasks private static final int THRESHOLD = 1000; public SumTask(int[] array, int start, int end) { this.array = array; this.start = start; this.end = end; } @Override protected Long compute() { // If the task is small enough, calculate the sum directly if (end - start \u003c= THRESHOLD) { long sum = 0; for (int i = start; i \u003c end; i++) { sum += array[i]; } return sum; } // Otherwise, split the task into two subtasks int middle = (start + end) / 2; SumTask leftTask = new SumTask(array, start, middle); SumTask rightTask = new SumTask(array, middle, end); // Fork the subtasks leftTask.fork(); rightTask.fork(); // Join the results of the subtasks long leftResult = leftTask.join(); long rightResult = rightTask.join(); // Combine the results and return return leftResult + rightResult; } } public static void main(String[] args) { int[] array = new int[10000]; // Initialize all elements to 1 Arrays.fill(array, 1); // Create a ForkJoinPool to execute the tasks ForkJoinPool pool = new ForkJoinPool(); // Submit the task to the ForkJoinPool SumTask task = new SumTask(array, 0, array.length); long result = pool.invoke(task); System.out.println(\"Sum: \" + result); // Output the result } } SHOW OUTPUT Output Sum: 10000 Critical Section \u0026 Race Condition Critical Section refers to a portion of a program where shared resources are accessed and modified. A Race Condition occurs when the program’s behavior depends on the non-deterministic execution order of threads. Since multiple threads can access a critical section concurrently, it is essential to synchronize their access to avoid data inconsistency.\nFor example, suppose there are four threads trying to read a value of 20 from memory. Each thread increments the value by 1 and writes it back to memory. Without synchronization mechanisms, after all threads complete their writes, the final value might be 21 instead of the expected 24. This leads to an unexpected outcome, as illustrated below.\nCritical Section \u0026 Race Condition To resolve this issue, access to the critical section must be exclusive. This is commonly achieved by using mutexes, read/write locks, semaphores, conditional variables or barriers to ensure that only one thread can modify the shared resource at a time.\nSynchronization Mechanisms Synchronization Mechanisms are rules used to coordinate the execution of threads in a program, ensuring safe access to shared resources. These mechanisms can be primarily classified into five types: Mutexes, Read/Write Locks, Semaphores, Conditional Variables, and Barriers.\nMutex Mechanism The mutex mechanism ensures that only one thread can access the critical section at a time. Other threads will be blocked until the mutex is released. The key logic behind the mutex mechanism is as follows:\nLock lock = new ReentrantLock(); lock.lock(); // Acquire the lock try { // Critical section code } finally { lock.unlock(); // Release the lock } Mutex Mechanism SHOW CODE Java public class Mutex { private static int counter = 0; private static final Object lock = new Object(); public static void runExperiment(String experimentName, Runnable task) { counter = 0; Thread t1 = new Thread(task); Thread t2 = new Thread(task); t1.start(); t2.start(); try { t1.join(); t2.join(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"Final counter value \" + experimentName + \": \" + counter + \"\"); } public static void incrementCounterWithMutex() { for (int i = 0; i \u003c 100; i++) { synchronized (lock) { int temp = counter; try { Thread.sleep(1); // Sleep for 1 millisecond } catch (InterruptedException e) { e.printStackTrace(); } counter = temp + 1; } } } public static void incrementCounterNoMutex() { for (int i = 0; i \u003c 100; i++) { int temp = counter; try { Thread.sleep(1); // Sleep for 1 millisecond } catch (InterruptedException e) { e.printStackTrace(); } counter = temp + 1; } } public static void main(String[] args) { runExperiment(\"With Mutex Experiment\", Mutex::incrementCounterWithMutex); runExperiment(\"No Mutex Experiment\", Mutex::incrementCounterNoMutex); } } SHOW OUTPUT Output Final counter value With Mutex Experiment: 200 Final counter value No Mutex Experiment: 100 Read/Write Lock Mechanism The Read/Write Lock Mechanism allows threads read the shared resources concurrently, but ensures exclusive access for write operations. This mechanism is useful in scenarios where there are many read operations and fewer write operations, such as caching systems or databases. The key logic behind the read/write lock mechanism is as follows:\nReadWriteLock rwLock = new ReentrantReadWriteLock(); rwLock.readLock().lock(); // Acquire read lock try { // Read operation } finally { rwLock.readLock().unlock(); // Release read lock } rwLock.writeLock().lock(); // Acquire write lock try { // Write operation } finally { rwLock.writeLock().unlock(); // Release write lock } Under the Read/Write Lock mechanism, multiple threads can access the critical section simultaneously without blocking each other. When a writer thread is accessing the critical section, other writer threads and reader threads are blocked. Similarly, when a reader thread is accessing the critical section, the writer thread is blocked.\nRead/Write Lock Mechanism SHOW CODE Java import java.util.ArrayList; import java.util.List; import java.util.concurrent.locks.ReentrantReadWriteLock; public class ReadWriteLock { private static volatile int counter = 0; private static final int TARGET_VALUE = 1000; private static final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(); public static int incrementValue() { lock.writeLock().lock(); try { Thread.sleep(1); if (counter \u003c TARGET_VALUE) { counter++; } } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.writeLock().unlock(); } return counter; } public static int readValue() { lock.readLock().lock(); try { Thread.sleep(1); return counter; } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.readLock().unlock(); } return 0; } public static void main(String[] args) { long start = System.currentTimeMillis(); List readers = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c 8; i++) { readers.add(new Thread(() -\u003e { while (readValue() \u003c TARGET_VALUE) { try { Thread.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } } })); } List writers = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c 2; i++) { writers.add(new Thread(() -\u003e { while (incrementValue() \u003c TARGET_VALUE) { try { Thread.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } } })); } readers.forEach(Thread::start); writers.forEach(Thread::start); readers.forEach(t -\u003e { try { t.join(); } catch (InterruptedException e) { e.printStackTrace(); } }); writers.forEach(t -\u003e { try { t.join(); } catch (InterruptedException e) { e.printStackTrace(); } }); long end = System.currentTimeMillis(); System.out.println(\"Time taken: \" + (end - start) / 1000.0 + \" seconds\"); } } SHOW OUTPUT Output Time taken: 1.787 seconds In the above code, the readValue method uses a read lock, allowing multiple reader threads to access the counter (critical section) simultaneously without blocking each other. If the method used a write lock instead of a read lock, the execution time would be higher. This is because when a writer thread is accessing the counter, all other threads would be blocked.\npublic static int readValue() { // lock.readLock().lock(); lock.writeLock().lock(); try { Thread.sleep(1); return counter; } catch (InterruptedException e) { e.printStackTrace(); } finally { // lock.readLock().unlock(); lock.writeLock().unlock(); } return 0; } Time taken: 6.793 seconds # Use write lock Semaphore Mechanism The Semaphore mechanism uses an integer to manage a set of permits, allowing multiple threads to access shared resources simultaneously, but only up to a predetermined limit. There are two types of semaphores: Binary Semaphore and Counting Semaphore.\nBinary Semaphore: Similar to a mutex, it operates with two states (0 and 1), ensuring mutual exclusion in critical sections. Counting Semaphore: Allows a count greater than 1, permitting multiple threads to access shared resources concurrently, as long as the permit limit is not exceeded. Semaphores are useful in controlling access to a pool of resources, such as limiting the number of threads that can access a database connection or a server. The key logic behind the semaphore mechanism is as follows:\nSemaphore semaphore = new Semaphore(3); // Allow 3 threads at once semaphore.acquire(); // Acquire a permit try { // Critical section code } finally { semaphore.release(); // Release a permit } Semaphore Mechanism SHOW CODE Java import java.util.concurrent.Semaphore; import java.util.concurrent.atomic.AtomicInteger; public class SemaphoreTest { // Global shared resource // AtomicInteger allows multiple threads to read/write value of counter without requiring synchronization private static final AtomicInteger counter = new AtomicInteger(0); // Semaphore with a count of 5 private static final Semaphore semaphore = new Semaphore(5); private static final int TARGET_VALUE = 5000; public static void main(String[] args) { long startTime = System.currentTimeMillis(); Thread[] workers = new Thread[10]; for (int i = 0; i \u003c workers.length; i++) { workers[i] = new Thread(SemaphoreTest::worker); workers[i].start(); } for (Thread worker : workers) { try { worker.join(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); System.out.println(\"Thread was interrupted\"); } } long endTime = System.currentTimeMillis(); System.out.println(\"Time taken: \" + (endTime - startTime) / 1000.0 + \" seconds\"); } private static void worker() { while (true) { try { semaphore.acquire(); // Acquire the semaphore if (counter.get() \u003e= TARGET_VALUE) { break; } counter.incrementAndGet(); // Atomically increments the counter Thread.sleep(1); // Simulate work } catch (InterruptedException e) { Thread.currentThread().interrupt(); System.out.println(\"Thread was interrupted\"); } finally { semaphore.release(); // Release the semaphore } } } } Conditional Variable Mechanism The Conditional Variable Mechanism allows a thread to suspend its execution until other threads signal that a certain condition has been met. It is often used in conjunction with mutexes to implement synchronization patterns, such as the producer-consumer pattern.\nIn this mechanism, a thread can wait on a condition variable until it is notified by other threads that the condition has been satisfied. When the condition is fulfilled, one or more threads can be signaled to wake up and proceed. Condition variables are commonly used in scenarios like the producer-consumer problem, where one thread produces data and another consumes it, with both threads needing to wait for each other under specific conditions.\nThe key logic behind the Conditional Variable Mechanism is as follows:\nsynchronized (lock) { while (!condition) { lock.wait(); // Wait until condition is true } // Proceed with critical section } synchronized (lock) { condition = true; lock.notify(); // Notify waiting threads } Conditional Variable Mechanism SHOW CODE Wait \u0026 Notify Busy Waiting public class ConditionalVariable { private static final Object mutex = new Object(); private static int sharedNumber; private static boolean ready = false; public static void producer() { synchronized (mutex) { sharedNumber = 9; // Producing a number ready = true; System.out.println(\"Producer has produced the number: \" + sharedNumber); mutex.notify(); // Notify the consumer } } public static void consumer() { synchronized (mutex) { while (!ready) { try { mutex.wait(); // Wait until the number is ready } catch (InterruptedException e) { Thread.currentThread().interrupt(); System.out.println(\"Consumer thread was interrupted.\"); } } System.out.println(\"Consumer has consumed the number: \" + sharedNumber); } } public static void main(String[] args) { Thread producerThread = new Thread(ConditionalVariable::producer); Thread consumerThread = new Thread(ConditionalVariable::consumer); producerThread.start(); consumerThread.start(); try { producerThread.join(); consumerThread.join(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); System.out.println(\"Main thread was interrupted.\"); } } } public class Solution { private static final Object mutex = new Object(); private static int sharedNumber; private static boolean ready = false; private static void producer() { synchronized (mutex) { sharedNumber = 9; // Producing a number ready = true; System.out.println(\"Producer has produced the number: \" + sharedNumber); } } private static void consumer() { // Busy waiting loop while (true) { synchronized (mutex) { if (ready) { System.out.println(\"Consumer has consumed the number: \" + sharedNumber); break; } } try { Thread.sleep(1); // Sleep for a short time } catch (InterruptedException e) { Thread.currentThread().interrupt(); System.out.println(\"Thread was interrupted\"); } } } public static void main(String[] args) { Thread producerThread = new Thread(Solution::producer); Thread consumerThread = new Thread(Solution::consumer); producerThread.start(); consumerThread.start(); try { producerThread.join(); consumerThread.join(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); System.out.println(\"Main thread was interrupted\"); } } } Barrier Mechanism The Barrier Mechanism allows threads to wait for each other at a specified point in their execution. It ensures that threads cannot proceed to the subsequent code until all threads have reached the barrier, as illustrated in the following image.\nBarrier Mechanism Barrier Mechanism are useful in parallel algorithms where multiple threads need to work in phases, and the next phase cannot begin until all threads complete the current one.\nThe key logic behind this mechanism is as follows:\nCyclicBarrier barrier = new CyclicBarrier(4, new Runnable() { public void run() { System.out.println(\"All threads reached the barrier!\"); } }); // Threads: barrier.await(); // Wait at the barrier SHOW CODE Java import java.util.concurrent.CyclicBarrier; class Barriers { private static final CyclicBarrier barrier = new CyclicBarrier(2, () -\u003e System.out.println(\"All threads have reached the barrier. Continue execution.\")); public static void main(String[] args) { Thread t1 = new Thread(Barriers::work); Thread t2 = new Thread(Barriers::work); // Start both threads. t1.start(); t2.start(); } private static void work() { System.out.println(\"Thread \" + Thread.currentThread().getName() + \" is waiting at the barrier\"); try { // Wait for the specified number of threads (2 in this case) to reach the barrier. barrier.await(); System.out.println(\"Thread \" + Thread.currentThread().getName() + \" is released\"); } catch (Exception e) { // Handle exceptions, if any. } } } SHOW OUTPUT Output Thread Thread-0 is waiting at the barrier Thread Thread-1 is waiting at the barrier All threads have reached the barrier. Continue execution. Thread Thread-1 is released Thread Thread-0 is released Thread Creation In Java Extending Thread Class SHOW CODE Java class MyThread extends Thread { @Override public void run() { System.out.println(this.getName() + \" is running.\"); } } public class Main { public static void main(String[] args) { MyThread myThread = new MyThread(); myThread.setName(\"MYTHREAD-0\"); myThread.start(); } } Implementing Runnable Interface SHOW CODE Java public class Main { public static void main(String[] args) { Thread thread = new Thread(() -\u003e System.out.println(Thread.currentThread().getName() + \" is running.\")); thread.start(); } } //class MyRunnable implements Runnable { // @Override // public void run() { // System.out.println(\"Thread is running\"); // } //} // //public class Main { // public static void main(String[] args) { // Thread thread = new Thread(new MyRunnable()); // thread.start(); // Starts a new thread // } //} Using the Callable Interface SHOW CODE Java import java.util.concurrent.*; public class Main { public static void main(String[] args) throws Exception { ExecutorService executor = Executors.newSingleThreadExecutor(); Future future = executor.submit(() -\u003e Thread.currentThread().getName() + \" is running.\"); System.out.println(future.get()); executor.shutdown(); } } class MyCallable implements Callable { // @Override // public String call() { // return \"Thread executed\"; // } //} // //public class Main { // public static void main(String[] args) throws Exception { // ExecutorService executor = Executors.newSingleThreadExecutor(); // Future future = executor.submit(new MyCallable()); // System.out.println(future.get()); // Retrieves the result // executor.shutdown(); // } //} Using Executors SHOW CODE Java import java.util.concurrent.*; public class Main { public static void main(String[] args) { ExecutorService executor = Executors.newFixedThreadPool(2); Runnable task1 = () -\u003e System.out.println(Thread.currentThread().getName() + \" executed\"); Runnable task2 = () -\u003e System.out.println(Thread.currentThread().getName() + \" executed\"); executor.execute(task1); executor.execute(task2); executor.shutdown(); } } Thread Termination In Java Using a flag SHOW CODE Java class Task implements Runnable { // Use volatile to ensure visibility between thread private volatile boolean running = true; @Override public void run() { while (running) { System.out.println(\"Thread is running.\"); try { Thread.sleep(1000); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } System.out.println(\"Thread is stopping.\"); } public void stop() { running = false; } } public class Main { public static void main(String[] args) throws InterruptedException { Task task = new Task(); Thread thread = new Thread(task); thread.start(); Thread.sleep(3000); // Allow thread to run for a while task.stop(); // Signal thread to stop } } Interrupting a Thread SHOW CODE Java public class Main { public static void main(String[] args) throws InterruptedException { Thread thread = new Thread(() -\u003e { try { while (!Thread.currentThread().isInterrupted()) { System.out.println(\"Thread is running\"); Thread.sleep(1000); } } catch (InterruptedException e) { System.out.println(\"Thread is interrupted\"); } }); thread.start(); Thread.sleep(3000); // Allow thread to run for a while thread.interrupt(); // Interrupt the thread } } Daemon Threads A daemon thread in Java is a low-priority thread that runs in the background, typically handling tasks such as garbage collection or other housekeeping operations. The JVM terminates when all non-daemon threads have completed execution, even if daemon threads are still active. To create a daemon thread, the setDaemon(true) method is used on a Thread object before it is started.\nSHOW CODE Java public class Main { public static void main(String[] args) { Thread daemonThread = new Thread(() -\u003e { while (true) { System.out.println(\"Daemon thread is running\"); try { Thread.sleep(1000); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } }); daemonThread.setDaemon(true); // Mark as daemon daemonThread.start(); System.out.println(\"Main thread is ending\"); } } SHOW OUTPUT Output Main thread is ending Daemon thread is running Performance Optimization When it comes to multithreading, performance optimization typically focuses on two key areas: latency reduction and throughput improvement.\nLatency reduction refers to minimizing the time it takes to complete a single task, measured in time units. This is often achieved by breaking a task into smaller subtasks that can be executed concurrently by multiple threads.\nThroughput, on the other hand, measures the number of tasks completed within a specific time frame, typically expressed as tasks / time unit. Throughput improvement is commonly achieved by utilizing thread pooling, which reduces the overhead of creating and destroying threads for each task.\nSHOW CODE: Latency Reduction Java import javax.imageio.ImageIO; import java.awt.image.BufferedImage; import java.io.File; import java.io.IOException; import java.util.ArrayList; import java.util.List; public class Main { private static final String SOURCE_FILE = \"src/main/resources/1-flower.jpg\"; private static final String DESTINATION_FILE = \"./out/1-flower.jpg\"; public static void main(String[] args) throws IOException { BufferedImage originalImage = ImageIO.read(new File(SOURCE_FILE)); BufferedImage resultImage = new BufferedImage(originalImage.getWidth(), originalImage.getHeight(), BufferedImage.TYPE_INT_RGB); long startTime = System.currentTimeMillis(); // recolorSingleThreaded(originalImage, resultImage); int numberOfThreads = 1; recolorMultithreaded(originalImage, resultImage, numberOfThreads); long endTime = System.currentTimeMillis(); long duration = endTime - startTime; File outputFile = new File(DESTINATION_FILE); File parentDir = outputFile.getParentFile(); if (parentDir != null \u0026\u0026 !parentDir.exists()) { parentDir.mkdirs(); // Create the directory if it doesn't exist } ImageIO.write(resultImage, \"jpeg\", outputFile); System.out.println(\"duration = \" + duration); } public static void recolorMultithreaded(BufferedImage originalImage, BufferedImage resultImage, int numberOfThreads) { List threads = new ArrayList\u003c\u003e(); int width = originalImage.getWidth(); int height = originalImage.getHeight() / numberOfThreads; for(int i = 0; i \u003c numberOfThreads ; i++) { final int threadMultiplier = i; Thread thread = new Thread(() -\u003e { int xOrigin = 0 ; int yOrigin = height * threadMultiplier; recolorImage(originalImage, resultImage, xOrigin, yOrigin, width, height); }); threads.add(thread); } for(Thread thread : threads) { thread.start(); } for(Thread thread : threads) { try { thread.join(); } catch (InterruptedException e) { } } } private static void recolorSingleThreaded(BufferedImage originalImage, BufferedImage resultImage) { recolorImage(originalImage, resultImage, 0, 0, originalImage.getWidth(), originalImage.getHeight()); } private static void recolorImage(BufferedImage originalImage, BufferedImage resultImage, int leftCorner, int topCorner, int width, int height) { for (int x = leftCorner; x \u003c leftCorner + width \u0026\u0026 x \u003c originalImage.getWidth(); x++) { for (int y = topCorner; y \u003c topCorner + height \u0026\u0026 y \u003c originalImage.getHeight(); y++) { recolorPixel(originalImage, resultImage, x, y); } } } private static void recolorPixel(BufferedImage originalImage, BufferedImage resultImage, int x, int y) { int rgb = originalImage.getRGB(x, y); int red = getRed(rgb); int green = getGreen(rgb); int blue = getBlue(rgb); int newRed; int newGreen; int newBlue; if (isShadeOfGray(red, green, blue)) { newRed = Math.min(255, red + 10); newGreen = Math.max(0, green - 80); newBlue = Math.max(0, blue - 20); } else { newRed = red; newGreen = green; newBlue = blue; } int newRGB = createRGBFromColors(newRed, newGreen, newBlue); setRGB(resultImage, x, y, newRGB); } public static void setRGB(BufferedImage image, int x, int y, int rgb) { image.getRaster().setDataElements(x, y, image.getColorModel().getDataElements(rgb, null)); } public static boolean isShadeOfGray(int red, int green, int blue) { return Math.abs(red - green) \u003c 30 \u0026\u0026 Math.abs(red - blue) \u003c 30 \u0026\u0026 Math.abs(green - blue) \u003c 30; } public static int createRGBFromColors(int red, int green, int blue) { int rgb = 0; rgb |= blue; rgb |= green \u003c\u003c 8; rgb |= red \u003c\u003c 16; rgb |= 0xFF000000; return rgb; } public static int getRed(int rgb) { return (rgb \u0026 0x00FF0000) \u003e\u003e 16; } public static int getGreen(int rgb) { return (rgb \u0026 0x0000FF00) \u003e\u003e 8; } public static int getBlue(int rgb) { return rgb \u0026 0x000000FF; } } SHOW IMAGE: BEFORE PROCESSING SHOW IMAGE: AFTER PROCESSING Single Threaded VS. Multithreaded SHOW CODE: Throughput vs. Threads Throughput vs. Threads import com.sun.net.httpserver.HttpExchange; import com.sun.net.httpserver.HttpHandler; import com.sun.net.httpserver.HttpServer; import java.io.IOException; import java.io.OutputStream; import java.net.InetSocketAddress; import java.nio.file.Files; import java.nio.file.Paths; import java.util.concurrent.Executor; import java.util.concurrent.Executors; public class ThroughputHttpServer { private static final String INPUT_FILE = \"./resources/war_and_peace.txt\"; private static final int NUMBER_OF_THREADS = 8; public static void main(String[] args) throws IOException { String text = new String(Files.readAllBytes(Paths.get(INPUT_FILE))); startServer(text); } public static void startServer(String text) throws IOException { HttpServer server = HttpServer.create(new InetSocketAddress(8000), 0); server.createContext(\"/search\", new WordCountHandler(text)); Executor executor = Executors.newFixedThreadPool(NUMBER_OF_THREADS); server.setExecutor(executor); server.start(); } private static class WordCountHandler implements HttpHandler { private String text; public WordCountHandler(String text) { this.text = text; } @Override public void handle(HttpExchange httpExchange) throws IOException { String query = httpExchange.getRequestURI().getQuery(); String[] keyValue = query.split(\"=\"); String action = keyValue[0]; String word = keyValue[1]; if (!action.equals(\"word\")) { httpExchange.sendResponseHeaders(400, 0); return; } long count = countWord(word); byte[] response = Long.toString(count).getBytes(); httpExchange.sendResponseHeaders(200, response.length); OutputStream outputStream = httpExchange.getResponseBody(); outputStream.write(response); outputStream.close(); } private long countWord(String word) { long count = 0; int index = 0; while (index \u003e= 0) { index = text.indexOf(word, index); if (index \u003e= 0) { count++; index++; } } return count; } } } SHOW IMAGE: Throughput VS. Threads Problems Linear Search with Finding One Occurrence SHOW PROBLEM Problem Statement:\nThe input consists of a large array (or list) of elements and a target value to search for. The goal is to utilize multiple threads to divide the search space and concurrently search for the target value, ultimately returning the index of the first occurrence of the target or -1 indicating that the target is not present.\nRequirements:\nMultithreading: Divide the array into multiple segments, with each thread searching a specific segment of the array. Each thread should operate independently and search its assigned segment. Return First Occurrence: Once the target value is found by any thread, it should return the index of the first occurrence, and other threads should stop searching. Constraints:\nThe array can be large (millions of elements). The number of threads used should be adjustable. The target value may appear multiple times in the array, but only the index of the first occurrence should be returned. SHOW CODE Java public class Solution { private static final int SIZE = 280000; private static final int NUM_THREADS = 4; private static final Object mtx = new Object(); // Mutex for controlling access to foundIndex private static volatile int foundIndex = -1; private static void linearSearch(int threadId, int[] arr, int key) { int chunkSize = arr.length / NUM_THREADS; int start = threadId * chunkSize; int end = (threadId == NUM_THREADS - 1) ? arr.length : start + chunkSize; for (int i = start; i \u003c end; ++i) { // Early exit if foundIndex is set by another thread synchronized (mtx) { if (foundIndex != -1) { break; } } if (arr[i] == key) { synchronized (mtx) { if (foundIndex == -1) { foundIndex = i; break; // Exit after setting foundIndex } } } } } public static void main(String[] args) { // Fill array with random numbers between 0-99 int[] arr = new int[SIZE]; for (int i = 0; i \u003c SIZE; ++i) { arr[i] = (int) (Math.random() * 100); } Thread[] threads = new Thread[NUM_THREADS]; int key = 9; for (int i = 0; i \u003c NUM_THREADS; ++i) { final int threadId = i; threads[i] = new Thread(() -\u003e linearSearch(threadId, arr, key)); threads[i].start(); } for (Thread thread : threads) { try { thread.join(); } catch (InterruptedException e) { e.printStackTrace(); } } if (foundIndex == -1) { System.out.println(\"Element not found in the array.\"); } else { System.out.println(\"Element found at index: \" + foundIndex); } } } Linear Search for All Occurrences SHOW PROBLEM Problem Statement:\nThe input consists of a large array (or list) of elements and a target value to search for. The goal is to utilize multiple threads to divide the search space and concurrently search for the target value, ultimately returning the index of all occurrences of the target or an empty list indicating that the target is not present.\nRequirements:\nMultithreading: Divide the array into multiple segments, with each thread searching a specific segment of the array. Each thread should operate independently and search its assigned segment. Return All Occurrences: Once the target value is found, the thread should store the index. All threads should continue searching, and their results (all indices of the target’s occurrences) should be combined and returned. Constraints:\nThe array can be large (millions of elements). The number of threads used should be adjustable. The target value may appear multiple times in the array, and all indices where the target is found should be returned. SHOW CODE Java import java.util.ArrayList; import java.util.List; import java.util.Random; public class Solution { private static final int SIZE = 4000; private static final int NUM_THREADS = 4; // Mutex for controlling access to foundPlaces private static final Object lockObj = new Object(); private static List foundPlaces = new ArrayList\u003c\u003e(); private static void linearSearch(int threadId, int[] arr, int key) { int chunkSize = arr.length / NUM_THREADS; int start = threadId * chunkSize; int end = (threadId == NUM_THREADS - 1) ? arr.length : start + chunkSize; for (int i = start; i \u003c end; ++i) { if (arr[i] == key) { synchronized (lockObj) { // Lock when modifying foundPlaces foundPlaces.add(i); // Append the index to foundPlaces } } } } public static void main(String[] args) { // Create an array and fill it with random numbers between 0 and 99 int[] arr = new int[SIZE]; Random random = new Random(); for (int i = 0; i \u003c SIZE; ++i) { arr[i] = random.nextInt(100); } Thread[] threads = new Thread[NUM_THREADS]; // List to hold the threads int key = 9; // Element to find // Start the threads for (int i = 0; i \u003c NUM_THREADS; ++i) { final int threadId = i; threads[i] = new Thread(() -\u003e linearSearch(threadId, arr, key)); threads[i].start(); } // Join the threads with the main thread for (Thread thread : threads) { try { thread.join(); } catch (InterruptedException e) { e.printStackTrace(); } } // Display the result if (foundPlaces.isEmpty()) { System.out.println(\"Element not found in the array.\"); } else { System.out.print(\"Element found at indices: \"); synchronized (lockObj) { // Lock when reading from foundPlaces for (int index : foundPlaces) { System.out.print(index + \" \"); } } System.out.println(); } } } SHOW NOTES The synchonization block can be removed when reading values from foundPlaces, as no threads modify the foundPlaces after the join() method is called.\n// Display the result if (foundPlaces.isEmpty()) { System.out.println(\"Element not found in the array.\"); } else { System.out.print(\"Element found at indices: \"); // No need for synchronization here, as no threads are modifying foundPlaces now // synchronized (lockObj) { // Lock when reading from foundPlaces for (int index : foundPlaces) { System.out.print(index + \" \"); } // } System.out.println(); } Linear Search with Indices and Occurrences SHOW PROBLEM Problem Statement:\nYou are given a large array (or list) of elements and a target value to search for. Your task is to implement a linear search that finds all occurrences of the target value in the array using multiple threads. Each thread should search a specific segment of the array, and the results (indices where the target is found) should be stored in a shared collection (e.g., a list). Additionally, a shared variable should keep track of the count of occurrences of the target value.\nRequirements:\nMultithreading: Divide the array into equal segments based on the number of threads. Each thread should independently search its assigned segment for the target value. The number of threads should be adjustable to optimize performance depending on the size of the array. Return: A list of integers representing the indices of all occurrences of the target value. An integer representing the total count of occurrences of the target value. Constraints:\nThe array can be very large, potentially containing millions of elements. The number of threads used should be adjustable, allowing the program to scale with the size of the array and the system’s available resources. The target value may appear multiple times, and all occurrences should be included in the final result. SHOW CODE Java import java.util.ArrayList; import java.util.List; import java.util.Random; public class Solution { private static final int SIZE = 4000; private static final int NUM_THREADS = 4; private static final List foundIndices = new ArrayList\u003c\u003e(); // Shared list to store the indices of all occurrences private static int occurrencesCount = 0; // Shared variable to store the count of occurrences private static final Object indicesLock = new Object(); // Lock for synchronizing access to foundIndices private static final Object countLock = new Object(); // Lock for synchronizing access to occurrencesCount // Function executed by each thread to search for indices and occurrences private static void searchIndicesOccurrences(int threadId, int[] arr, int key) { int chunkSize = arr.length / NUM_THREADS; int start = threadId * chunkSize; int end = (threadId == NUM_THREADS - 1) ? arr.length : start + chunkSize; List localIndices = new ArrayList\u003c\u003e(); int localCount = 0; for (int i = start; i \u003c end; ++i) { if (arr[i] == key) { localIndices.add(i); localCount++; } } if (!localIndices.isEmpty()) { synchronized (indicesLock) { foundIndices.addAll(localIndices); } } if (localCount \u003e 0) { synchronized (countLock) { occurrencesCount += localCount; } } } public static void main(String[] args) { // Create an array and fill it with random numbers between 0 and 99 int[] arr = new int[SIZE]; Random random = new Random(); for (int i = 0; i \u003c SIZE; ++i) { arr[i] = random.nextInt(100); } Thread[] threads = new Thread[NUM_THREADS]; // Array of threads int key = 9; // Element to find // Start the threads for (int i = 0; i \u003c NUM_THREADS; ++i) { int threadId = i; threads[i] = new Thread(() -\u003e searchIndicesOccurrences(threadId, arr, key)); threads[i].start(); } // Wait for all threads to complete for (Thread thread : threads) { try { thread.join(); } catch (InterruptedException e) { e.printStackTrace(); } } // Output the results if (foundIndices.isEmpty()) { System.out.println(\"Element not found in the array.\"); } else { System.out.print(\"Element found \" + occurrencesCount + \" times at indices: \"); for (int index : foundIndices) { System.out.print(index + \" \"); } System.out.println(); } } } Min/Max/Sum SHOW PROBLEM Problem Statement:\nThe input consists of a large array (or list) of elements. The goal is to efficiently calculate the minimum, maximum, and sum of elements in the array using multithreading. The array is divided into multiple segments, with each thread processing a specific segment. The threads will then return partial results (minimum, maximum, and sum for their respective segments), which will be combined to compute the final values for the entire array.\nRequirements:\nMultithreading: Divide the array into multiple segments, with each thread processing a specific portion of the array. Each thread should independently compute the minimum, maximum, and sum for its assigned segment.\nCombine Results: Once each thread has finished processing, their partial results (min, max, and sum for the segment) should be combined to compute the final minimum, maximum, and sum for the entire array.\nEfficiency: The program should use multithreading to optimize the processing time, especially when dealing with large arrays containing millions of elements. The number of threads should be adjustable for optimal performance.\nConstraints:\nThe array can be large (millions of elements).\nThe number of threads used should be adjustable based on the size of the array and the system’s capabilities.\nThe array can contain both positive and negative numbers, and the minimum, maximum, and sum should be computed accurately, including for arrays with all negative values.\nSHOW CODE Java import java.util.Random; public class Solution { private static final int DATA_SIZE = 100; private static final int NUMBER_OF_THREADS = 4; private static int[] data = new int[DATA_SIZE]; private static int[] threadResultsSum = new int[NUMBER_OF_THREADS]; private static int[] threadResultsMin = new int[NUMBER_OF_THREADS]; private static int[] threadResultsMax = new int[NUMBER_OF_THREADS]; public static void main(String[] args) throws InterruptedException { // Initialize data array Random random = new Random(); for (int i = 0; i \u003c DATA_SIZE; i++) { data[i] = random.nextInt(500); } Thread[] threads = new Thread[NUMBER_OF_THREADS * 3]; // Start threads for sum, min, and max calculations for (int i = 0; i \u003c NUMBER_OF_THREADS; i++) { final int threadId = i; final int start = threadId * (DATA_SIZE / NUMBER_OF_THREADS); final int end = (threadId + 1) * (DATA_SIZE / NUMBER_OF_THREADS); threads[threadId] = new Thread(() -\u003e threadedSum(threadId, start, end)); threads[threadId + NUMBER_OF_THREADS] = new Thread(() -\u003e threadedMin(threadId, start, end)); threads[threadId + NUMBER_OF_THREADS * 2] = new Thread(() -\u003e threadedMax(threadId, start, end)); threads[threadId].start(); threads[threadId + NUMBER_OF_THREADS].start(); threads[threadId + NUMBER_OF_THREADS * 2].start(); } // Wait for threads to finish for (Thread thread : threads) { thread.join(); } // Aggregate results from threads int totalSum = 0; for (int sum : threadResultsSum) { totalSum += sum; } int min = Integer.MAX_VALUE; for (int minResult : threadResultsMin) { min = Math.min(min, minResult); } int max = Integer.MIN_VALUE; for (int maxResult : threadResultsMax) { max = Math.max(max, maxResult); } System.out.println(\"Sum is \" + totalSum); System.out.println(\"Min is \" + min); System.out.println(\"Max is \" + max); } private static void threadedSum(int threadId, int start, int end) { int sum = 0; for (int i = start; i \u003c end; i++) { sum += data[i]; } threadResultsSum[threadId] = sum; } private static void threadedMin(int threadId, int start, int end) { int min = Integer.MAX_VALUE; for (int i = start; i \u003c end; i++) { min = Math.min(min, data[i]); } threadResultsMin[threadId] = min; } private static void threadedMax(int threadId, int start, int end) { int max = Integer.MIN_VALUE; for (int i = start; i \u003c end; i++) { max = Math.max(max, data[i]); } threadResultsMax[threadId] = max; } } Pi Calculation SHOW PROBLEM Problem Statement\nThe problem is to estimate the value of Pi using the Monte Carlo simulation method. In this method, we randomly generate points within a square and check how many of these points fall inside a circle inscribed within the square. The ratio of points inside the circle to the total points generated provides an approximation of Pi.\nRequirements:\nRandom Point Generation:\nGenerate a large number of random points within a square. The square should have side lengths of 2 (i.e., points with coordinates ranging from -1 to 1 on both the x and y axes). Each point has coordinates $(x, y)$, where $x$ and $y$ are randomly generated floating-point values between -1 and 1. Circle Inside the Square:\nA circle is inscribed within the square, with a radius of 1 and centered at the origin (0, 0). A point $(x, y)$ lies inside the circle if the following condition is true: $$ x^2 + y^2 \\leq 1 $$ Monte Carlo Estimation of Pi:\nCount how many of the generated points fall inside the circle. The ratio of the points inside the circle to the total number of points can be used to estimate Pi. Specifically, the approximation of Pi is given by: $$ \\pi \\approx 4 \\times \\frac{\\text{points inside the circle}}{\\text{total number of points}} $$ Multithreading:\nTo speed up the simulation, divide the task of generating points and checking whether they lie inside the circle into multiple threads. Each thread should be responsible for generating a subset of points and counting how many fall inside the circle. Once all threads finish their work, their results should be combined to compute the final approximation of Pi. Output:\nReturn the estimated value of Pi based on the simulation. Constraints:\nThe number of points to generate can be very large (millions of points). The number of threads used should be adjustable. The accuracy of the approximation improves with more points, but the simulation should be efficient enough to handle large numbers of points and multiple threads. SHOW CODE Java import java.util.Random; public class Solution { private static final int NUM_THREADS = 10; private static final int NUMBER_OF_TOSSES = 100000000; private static int[] results = new int[NUM_THREADS]; public static void main(String[] args) throws InterruptedException { Thread[] threads = new Thread[NUM_THREADS]; for (int i = 0; i \u003c NUM_THREADS; i++) { final int threadId = i; threads[i] = new Thread(() -\u003e { Random rand = new Random(); int start = threadId * NUMBER_OF_TOSSES / NUM_THREADS; int end = (threadId + 1) * NUMBER_OF_TOSSES / NUM_THREADS; int count_in_circle = 0; for (int j = start; j \u003c end; j++) { double x = rand.nextDouble() * 2 - 1; // Random x in range [-1, 1] double y = rand.nextDouble() * 2 - 1; // Random y in range [-1, 1] if (x * x + y * y \u003c= 1) { // If point is inside the circle count_in_circle++; } } results[threadId] = count_in_circle; }); threads[i].start(); } for (Thread thread : threads) { thread.join(); } // Compute final estimate of Pi int total_inside = 0; for (int result : results) { total_inside += result; } double pi_estimate = 4.0 * total_inside / NUMBER_OF_TOSSES; System.out.println(\"PI = \" + pi_estimate); } } SHOW NOTES Introduction to Monte Carlo Estimation of $\\pi$\nSuppose a square with a circle inscribed inside it, as shown in the image below. The circle has a radius of $r$, and the square has side length $2r$. The area of the circle is $A_{\\text{circle}} = \\pi r^2$, and the area of the square is $A_{\\text{square}} = (2r)^2 = 4r^2$\nThe ratio of the area of the circle to the area of the square is $$ \\frac{A_{\\text{circle}}}{A_{\\text{square}}} = \\frac{\\pi r^2}{4 r^2} = \\frac{\\pi}{4} $$\nTherefore, the value of $\\pi$ can be estimated by the formula:\n$$ \\pi \\approx 4 \\times \\frac{\\text{Number of points inside the circle}}{\\text{Total number of points inside the square}} $$\nVisulization:\nJUC CompletableFuture Future Interface The Future interface in Java defines several methods for managing asynchronous tasks, such as retriving the execution result, canceling a task, and checking if a task has been canceled or completed. It includes four commonly used methods: get(), isDone(), cancel(), and isCancelled().\nThe get() mthod retrives the result of computation. Note: If the computation is not yet complete, this method will block until the result is available. The isDone() method checks whether the computation has finished executing. The cancel() method attempts to cancel the task execution. The isCancelled() method checks if the task has been canceled before completion. The FutureTask class is a concrete implementation of the Future interface. It implements both the Runnable and Future interfaces, allowing it to be executed by a thread while also returning a result. Its constructor takes a Callable, enabling the task to return a value. The class diagram is shown below: The Future combined with a thread pool enhances execution performance efficiently. However, its drarback lies in the get() method, which is blocking, and the isDone() method, whose polling behavior consumes CPU resources.\nSHOW CODE FutureGetBlocking FutureIsDonePolling import java.util.concurrent.ExecutionException; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Future; class Main { public static void main(String[] args) throws ExecutionException, InterruptedException { ExecutorService executor = Executors.newSingleThreadExecutor(); Future future = executor.submit(() -\u003e { Thread.sleep(3000); // Simulate a long running task return \"Task Completed\"; }); System.out.println(\"Waiting for result...\"); // Block the main thread until the result is available String result = future.get(); System.out.println(\"Result: \" + result); executor.shutdown(); } } import java.util.concurrent.ExecutionException; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Future; class Main { public static void main(String[] args) throws ExecutionException, InterruptedException { ExecutorService executor = Executors.newSingleThreadExecutor(); Future future = executor.submit(() -\u003e { Thread.sleep(3000); // Simulate a long-running task return \"Task Completed\"; }); // Busy-waiting, consuming CPU cycles while (!future.isDone()) { System.out.println(\"Checking if task is done...\"); Thread.sleep(100); // Reducing CPU usage slightly, but still inefficient } System.out.println(\"Result: \" + future.get()); executor.shutdown(); } } CompletableFuture The CompletableFuture implements both the Future and CompletionStage interfaces. The CompletionStage represents a computation step that can be completed asynchronously. Unlike Future, CompletableFuture provides advanced mechanisms for handling asynchronous tasks, including non-blocking execution, method chaining, exception handling, combining futures, and thread pool customization.\nNon-blocking Execution: Unlike Future.get(), whcih blocks until the result is available, CompletableFuture enables asynchronous execution without blocking the main thread. Chaining Supports method chaining with thenApply, thenCompose, and thenRun to process results sequently. Exception Handling: Provides exceptionally and handle methods to gracefully handle errors. Combining Futures: Supports combining multiple futures using thenCombine, allOf, and anyOf for parallel execution. Thread Pool Customization: Allows executing tasks in a custom thread pool for better resource management. SHOW CODE Without Blocking Chaining Tasks ExceptionHandling CombiningFutures import java.util.concurrent.*; class Main { public static void main(String[] args) throws ExecutionException, InterruptedException { CompletableFuture future = CompletableFuture.runAsync(() -\u003e { try { Thread.sleep(2000); System.out.println(\"Task executed in a separate thread\"); } catch (InterruptedException e) { e.printStackTrace(); } }); System.out.println(\"Main thread is not blocked.\"); future.join(); } } import java.util.concurrent.*; class Main { public static void main(String[] args) throws ExecutionException, InterruptedException { CompletableFuture future = CompletableFuture.supplyAsync(() -\u003e \"Hello\") .thenApply(result -\u003e result + \", World!\") .thenApply(String::toUpperCase); System.out.println(future.join()); // Output: HELLO, WORLD! } } import java.util.concurrent.*; class Main { public static void main(String[] args) throws ExecutionException, InterruptedException { CompletableFuture future = CompletableFuture.supplyAsync(() -\u003e { if (true) { throw new RuntimeException(\"Something went wrong!\"); } return \"Success\"; }).exceptionally(ex -\u003e \"Recovered from: \" + ex.getMessage()); // Recovered from: java.lang.RuntimeException: Something went wrong! System.out.println(future.join()); } } import java.util.concurrent.*; class Main { public static void main(String[] args) throws ExecutionException, InterruptedException { CompletableFuture future1 = CompletableFuture.supplyAsync(() -\u003e \"Task 1\"); CompletableFuture future2 = CompletableFuture.supplyAsync(() -\u003e \"Task 2\"); CompletableFuture future3 = CompletableFuture.supplyAsync(() -\u003e \"Task 3\"); CompletableFuture allFutures = CompletableFuture.allOf(future1, future2, future3); // Retrieve results from individual futures String result1 = future1.get(); String result2 = future2.get(); String result3 = future3.get(); System.out.println(result1); System.out.println(result2); System.out.println(result3); allFutures.join(); // Wait for all tasks to complete System.out.println(\"All tasks completed!\"); } } The advantage of CompletableFuture is that when an asynchronous task completes, it automatically invokes the callback method. Once the main thread sets up the callback, it no longer needs to monitor the asynchronous task, and allows execution to proceed in sequence. Additionally, if the asynchronous task fails, it automatically triggers the corresponding error-handling method.\nBy default, CompletableFuture.supplyAsync() and runAsync() utilize the ForkJoinPool.commonPool(), a shared thread pool based on the ForkJoin framework. To use a custom thread pool, you need to provide a custom Executor when calling these methods.\nSHOW CODE ForkJoinPool.commonPool() Custom Thread Pool import java.util.concurrent.*; class Main { public static void main(String[] args) throws ExecutionException, InterruptedException { CompletableFuture.runAsync(() -\u003e { // Running in: ForkJoinPool.commonPool-worker-1 System.out.println(\"Running in: \" + Thread.currentThread().getName()); }); // Sleep to allow async task to execute try { Thread.sleep(100); } catch (InterruptedException e) { } } } import java.util.concurrent.*; class Main { public static void main(String[] args) throws ExecutionException, InterruptedException { ExecutorService executor = Executors.newFixedThreadPool(5); CompletableFuture.runAsync(() -\u003e // Custom pool: pool-1-thread-1 System.out.println(\"Custom pool: \" + Thread.currentThread().getName()), executor); } } The main difference between CompletableFuture.get() and CompletableFuture.join() is exception handling. get() throws checked exceptions (ExecutionException, InterruptedException), requiring explicit handling, while join() throws an unchecked CompletionException, eliminating the need for explicit exception handling.\nThe main differences between thenRun(), thenAccept(), and thenApply are\nthenRun() runs a task after previous stage completes, but does not take its result as input. thenAccept() runs a task after previous stage completes and consumes its result. thenApply() runs a task after previous stage completes and transform its result. CompletableFuture.supplyAsync(() -\u003e \"Task Completed\") .thenRun(() -\u003e System.out.println(\"Follow-up action executed!\")); CompletableFuture.supplyAsync(() -\u003e \"Hello, World!\") .thenAccept(result -\u003e System.out.println(\"Result: \" + result)); CompletableFuture\u003cString\u003e future = CompletableFuture.supplyAsync(() -\u003e \"Hello\") .thenApply(result -\u003e result + \", World!\"); System.out.println(future.join()); // Output: Hello, World! Method Takes Previous Result? Returns a Value? Use Case thenRun ❌ No ❌ No (Void) Just run a task after completion thenAccept ✅ Yes ❌ No (Void) Consume the result without returning a new one thenApply ✅ Yes ✅ Yes (R) Transform the result and return a new value Java Locks Optimistic Lock vs. Pessimistic Lock Optimistic Lock assumes minimal contention, allowing multiple threads to read and write data concurrently. Instead of using locks, it relies on versioning or CAS (Compare-And-Swap) to detect conflicts during updates. If a conflict is detected (i.e., another thread has modified the data), the operation is retried. It is particularly effective in high-read, low-write scenarios.\nSHOW CODE Use versioning in SQL Use CAS in Java # Use versioning in SQL UPDATE products SET stock = stock - 1, version = version + 1 WHERE id = 1 AND version = 5; import java.util.concurrent.*; import java.util.concurrent.atomic.AtomicInteger; class Main { public static void main(String[] args) throws ExecutionException, InterruptedException { AtomicInteger count = new AtomicInteger(0); int expectedValue, newValue; do { expectedValue = count.get(); newValue = expectedValue + 1; } while (!count.compareAndSet(expectedValue, newValue)); System.out.println(\"Updated Count: \" + count.get()); } } Pessimistic Lock assumes high contention and prevents concurrent modification by blocking the resource. Other threads must wait until the lock is released. It is suitable for high-write, low-read scenerios. In Java, the synchronized and ReentrantLock are implementations of pessimistic lock.\nSHOW CODE synchronized ReentrantLock class PessimisticLockExample { private int count = 0; public synchronized void increment() { count++; } } import java.util.concurrent.locks.ReentrantLock; public class PessimisticLockExample { private int count = 0; private final ReentrantLock lock = new ReentrantLock(); public void increment() { lock.lock(); try { count++; } finally { lock.unlock(); } } } synchronized Related Problems SHOW CODE Java class Phone { public synchronized void sendEmail() { System.out.println(\"send email\"); } public synchronized void sendSMS() { System.out.println(\"send SMS\"); } } class Main { public static void main(String[] args) { Phone phone = new Phone(); new Thread(() -\u003e { phone.sendEmail(); }, \"A\").start(); // Ensure thread A starts first try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -\u003e { phone.sendSMS(); }, \"B\").start(); } } The above code first outputs send email, followed by send SMS. This happens because both sendEmail() and sendSMS() are synchronized methods that lock the same object. As a result, the thread that acquires the lock first executes first, while other threads must wait until the lock is released.\nSHOW CODE Java class Phone { public synchronized void sendEmail() { try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"send email\"); } public synchronized void sendSMS() { System.out.println(\"send SMS\"); } } class Main { public static void main(String[] args) { Phone phone = new Phone(); new Thread(() -\u003e { phone.sendEmail(); }, \"A\").start(); // Ensure thread A starts first try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -\u003e { phone.sendSMS(); }, \"B\").start(); } } The above code first outputs send email, followed by send SMS. This happens because both sendEmail() and sendSMS() are synchronized methods that lock the same object and executes sleep() method doesn’t release a lock. Therefore, the thread that acquires the lock first executes first, while other threads must wait until the lock is released.\nSHOW CODE Java class Phone { public synchronized void sendEmail() { try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"send email\"); } public synchronized void sendSMS() { System.out.println(\"send SMS\"); } public void hello() { System.out.println(\"hello\"); } } class Main { public static void main(String[] args) { Phone phone = new Phone(); new Thread(phone::sendEmail, \"A\").start(); // Ensure thread A starts first try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -\u003e { phone.hello(); }, \"B\").start(); } } The above code outputs hello immediately, followed by send email. This is because the hello() method is not synchronized and does not require a lock, allowing it to execute without waiting.\nSHOW CODE Java import java.util.concurrent.TimeUnit; class Phone { public synchronized void sendEmail() { try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"send email\"); } public synchronized void sendSMS() { System.out.println(\"send SMS\"); } } class Main { public static void main(String[] args) { Phone phone1 = new Phone(); Phone phone2 = new Phone(); new Thread(() -\u003e { phone1.sendEmail(); }, \"A\").start(); // Ensure thread A starts first try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -\u003e { phone2.sendSMS(); }, \"B\").start(); } } The above code outputs send SMS first, followed by send email. This happens because the synchronized keyword locks the object instances (phone1 and phone2), not the class itself. Since phone1 and phone2 are different objects, their locks do not interfere with each other.\nIn this case, Thread A starts first and acquires the lock on phone1, but sleep for 3 seconds inside the sendEmail() method. Meanwhile, Thread B starts shortly after and acquires the lock on phone2. Since Thread B does not need to wait for Thread A to release its lock (as they operate on different objects), it executes sendSMS() immediately. As a result, Thread B outputs send SMS first, while Thread A outputs send email after its sleep period ends.\nSHOW CODE Java import java.util.concurrent.TimeUnit; class Phone { public static synchronized void sendEmail() { try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"send email\"); } public static synchronized void sendSMS() { System.out.println(\"send SMS\"); } } class Main { public static void main(String[] args) { Phone phone = new Phone(); new Thread(() -\u003e { phone.sendEmail(); }, \"A\").start(); // Ensure thread A starts first try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -\u003e { phone.sendSMS(); }, \"B\").start(); } } The above code outputs send email first, followed by send SMS. This happens because the static synchronized keyword locks the Phone.class object, not individual instances of the class. Since both methods (sendEmail and send SMS) are static synchronized, they share the same lock on the Phone.class object. As a result, their execution is sequential.\nSHOW CODE Java import java.util.concurrent.TimeUnit; class Phone { public static synchronized void sendEmail() { try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"send email\"); } public static synchronized void sendSMS() { System.out.println(\"send SMS\"); } } class Main { public static void main(String[] args) { Phone phone1 = new Phone(); Phone phone2 = new Phone(); new Thread(() -\u003e { phone1.sendEmail(); }, \"A\").start(); // Ensure thread A starts first try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -\u003e { phone2.sendSMS(); }, \"B\").start(); } } The above code outputs send email first, followed by send SMS. Even though there are two different objects (phone1 and phone2), the static synchronized keyword locks the Phone.class object, not the individual instances. This means that both sendEmail() and sendSMS() share the same lock at the class level, ensuring sequential execution.\nSHOW CODE Java import java.util.concurrent.TimeUnit; class Phone { public static synchronized void sendEmail() { try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"send email\"); } public synchronized void sendSMS() { System.out.println(\"send SMS\"); } } class Main { public static void main(String[] args) { Phone phone = new Phone(); new Thread(() -\u003e { phone.sendEmail(); }, \"A\").start(); // Ensure thread A starts first try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -\u003e { phone.sendSMS(); }, \"B\").start(); } } The above code outputs send SMS first, followed by send email. This happens because the synchronized keyword locks individual object instance, while static synchronized locks the class-level object. In this case, sendSMS() locks the phone object, and sendEmail() locks the Phone.class object. Since these locks are independent, Thread B does not need to wait for Thread A to release its lock. As a result, send SMS is printed first, while send email is printed after the 3-second sleep.\nSHOW CODE Java import java.util.concurrent.TimeUnit; class Phone { public static synchronized void sendEmail() { try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"send email\"); } public static synchronized void sendSMS() { System.out.println(\"send SMS\"); } public void hello() { System.out.println(\"hello\"); } } class Main { public static void main(String[] args) { Phone phone1 = new Phone(); Phone phone2 = new Phone(); new Thread(() -\u003e { phone1.sendEmail(); }, \"A\").start(); // Ensure thread A starts first try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -\u003e { phone2.hello(); phone2.sendSMS(); }, \"B\").start(); } } The above code outputs hello first, followed by send email and send SMS. This is because sendEmail() and sendSMS() are both static synchronized, meaning they lock the Phone.class object, enforcing sequential execution. In contrast, the hello() method is a regular method that does not require a lock, allowing it to execute immediately.\nsynchronized Byte Code Analysis SHOW CODE Source Code Source Code class Main { private final Object mtx = new Object(); public void f() { synchronized (mtx) { System.out.println(\"hello...\"); } } } public void f(); Code: 0: aload_0 1: getfield #7 // Field mtx:Ljava/lang/Object; 4: dup 5: astore_1 🌟 6: monitorenter 7: getstatic #13 // Field java/lang/System.out:Ljava/io/PrintStream; 10: ldc #19 // String hello... 12: invokevirtual #21 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 15: aload_1 🌟 16: monitorexit 17: goto 25 20: astore_2 21: aload_1 🌟 22: monitorexit 23: aload_2 24: athrow 25: return From the above bytecode, the synchronized block translates into monitorenter and monitorexit instructions. The lock is acquired before entering the block and released before exiting. The second monitorexit ensures that the lock is properly released if an exception occurs, as shown in the following code:\nSHOW CODE Source Code Byte Code class Main { private final Object mtx = new Object(); public void f() { synchronized (mtx) { System.out.println(\"hello...\"); throw new RuntimeException(\"Exception occurred\"); } } } public void f(); Code: 0: aload_0 1: getfield #7 // Field mtx:Ljava/lang/Object; 4: dup 5: astore_1 🌟 6: monitorenter 7: getstatic #13 // Field java/lang/System.out:Ljava/io/PrintStream; 10: ldc #19 // String hello... 12: invokevirtual #21 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 15: new #27 // class java/lang/RuntimeException 18: dup 19: ldc #29 // String Exception occurred 21: invokespecial #31 // Method java/lang/RuntimeException.\"\":(Ljava/lang/String;)V 24: athrow 25: astore_2 26: aload_1 🌟 27: monitorexit 28: aload_2 29: athrow SHOW CODE Source Code Byte Code class Main { public synchronized void f() { System.out.println(\"hello...\"); } public static synchronized void m() { System.out.println(\"HELLO...\"); } } public synchronized void f(); descriptor: ()V flags: (0x0021) ACC_PUBLIC, 🌟ACC_SYNCHRONIZED🌟 Code: stack=2, locals=1, args_size=1 0: getstatic #7 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #13 // String hello... 5: invokevirtual #15 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LineNumberTable: line 3: 0 line 4: 8 public static synchronized void m(); descriptor: ()V flags: (0x0029) ACC_PUBLIC, 🌟ACC_STATIC, ACC_SYNCHRONIZED🌟 Code: stack=2, locals=0, args_size=0 0: getstatic #7 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #21 // String HELLO... 5: invokevirtual #15 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LineNumberTable: line 7: 0 line 8: 8 From the above bytecode, the JVM checks if the ACC_SYNCHRONIZED flag is set. If the flag is present, the thread acquires the appropriate monitor lock before executing the method. For instance methods, the lock is acquired on the object instance (this), while for static methods, the lock is acquired on the class object (e.g., Main.class). After the method completes execution, the thread releases the lock. The ACC_STATIC flag is used to determine whether the method is static, which in turn determines whether the lock is applied at the class level or the instance level.\nWhy any object in Java can be a lock?\nAny object in Java can be a lock because every object has an intrinsic monitor lock managed by the JVM. The ObjectMonitor structure is part of the JVM’s implementation of this mechanism, tracking details like the lock owner, EntryList, etc. For example, when a thread calls synchronized(obj), the JVM checks the ObjectMonitor associated with obj. If the lock is available, the thread acquires it and sets itself as the owner. If the lock is held by another thread, the current thread waits in the EntryList. When the lock is released, the JVM wakes up a waiting thread (if any) to acquire the lock.\nObjectMonitor() { _header = NULL; _count = 0; _waiters = 0; _recursions = 0; _object = NULL; _owner = NULL; _MailSet = NULL; _MailSetLock = 0; _Responsible = NULL; _succ = NULL; _cxq = NULL; FreeNext = NULL; _EntryList = NULL; _SpinFreq = 0; _SpinClock = 0; OwnerIsThread = 0; _previous_owner_tid = 0; } Fair Lock vs. Unfair Lock In Java, locks can be calssified into fair locks and unfair locks based on their approach to thread scheduling. A fair lock ensures that threads acquire the lock in the exact order they requested it, following a first-come, first-served priciple. While this prevents thread starvation, it incurs additional overhead to maintain the order of threads. On the other hand, an unfair lock does not guarantee any specific order for thread access. A thread can acquire the lock even if it arrived later than others. This eliminates the need to maintain a strict order, improving efficiency, but it may result in thread starvation, where some threads could wait indefinitely for access.\nSHOW CODE Java import java.util.concurrent.locks.ReentrantLock; public class Main { private static final ReentrantLock unfairLock = new ReentrantLock(); // Unfair lock private static final ReentrantLock fairLock = new ReentrantLock(true); // Fair lock public static void main(String[] args) { System.out.print(\"Testing Unfair Lock: \"); testLock(unfairLock); System.out.print(\"Testing Fair Lock: \"); testLock(fairLock); } private static void testLock(ReentrantLock lock) { long startTime = System.currentTimeMillis(); Runnable task = () -\u003e { for (int i = 0; i \u003c 10000; i++) { lock.lock(); try { // Simulate work } finally { lock.unlock(); } } }; Thread[] threads = new Thread[10]; for (int i = 0; i \u003c threads.length; i++) { threads[i] = new Thread(task); threads[i].start(); } for (Thread thread : threads) { try { thread.join(); } catch (InterruptedException e) { e.printStackTrace(); } } long endTime = System.currentTimeMillis(); System.out.println(\"Time taken: \" + (endTime - startTime) + \" ms\"); } } SHOW OUTPUT Output Testing Unfair Lock: Time taken: 11 ms Testing Fair Lock: Time taken: 560 ms Recursive Lock A recursive lock in Java allows a thread to acquire the same lock multiple times without causing a deadlock. It is particularly useful in scenarios where a thread holding a lock calls another method or enters a synchronized block that requires the same lock. By default, the synchronized keyword and ReentrantLock class support recursive locking mechanism.\nThe recursive lock maintains a hold count, which tracks how many times a thread has acquired the lock. Each time the thread acquires the lock, the hold count is incremented, and it is decremented when the lock is released. The lock is fully released only when the hold count reaches zero.\nUnder the hood, when the monitorenter command is executed, the JVM checks the MonitorObject’s _count field. If _count is zero, it means the lock is not held by any other thread. In this case, the JVM sets the _owner field to the current thread and increments the _count. If _count is not zero and the _owner is the current thread, the JVM increments the _count (indicating reentrancy). Otherwise, if the lock is held by another thread, the current thread must wait until the lock is released (i.e., _count reaches zero).\nWhen the monitorexit command is executed, the JVM decrements the _count. Once _count reaches zero, the lock is considered fully released, and the _owner field is cleared, allowing other threads to acquire the lock.\nSHOW CODE Java import java.util.concurrent.locks.ReentrantLock; public class Main { private static final ReentrantLock lock = new ReentrantLock(); public static void main(String[] args) { recursiveMethod(3); } public static void recursiveMethod(int count) { lock.lock(); // Acquire the lock try { System.out.println(Thread.currentThread().getName() + \" acquired the lock. Hold count: \" + lock.getHoldCount()); if (count \u003e 0) { recursiveMethod(count - 1); // Recursive call } } finally { lock.unlock(); // Release the lock System.out.println(Thread.currentThread().getName() + \" released the lock. Hold count: \" + lock.getHoldCount()); } } } SHOW OUTPUT Output main acquired the lock. Hold count: 1 main acquired the lock. Hold count: 2 main acquired the lock. Hold count: 3 main acquired the lock. Hold count: 4 main released the lock. Hold count: 3 main released the lock. Hold count: 2 main released the lock. Hold count: 1 main released the lock. Hold count: 0 Deadlock A deadlock is a situation where two or more threads are permanently blcoked, each waiting for a resource held by another, preventing further progress. For a deadlock to occur, four conditions must be met simultaneously: mutual exclusion, hold and wait, no preemption, and circular wait.\nMutual Exclusion: A resource must be non-sharable, meaning only one thread can use it at a time. Hold and Wait: A thread holding at least one resource must be waiting to acquire additional resources held by other threads. No Preemption: Resources cannot be forcibly taken from a thread; they must be released voluntarily. Circular Wait: A circular chain of two or more threads must exist, where each thread is waiting for a resource held by the next in the chain. To detect a deadlock in Java, use the jps command to get the process ID, then run jstack process_id to analyze thread states and identify deadlocks.\nSHOW CODE Deadlock Detecting a Deadlock public class Main { private static final Object lock1 = new Object(); private static final Object lock2 = new Object(); public static void main(String[] args) { Thread thread1 = new Thread(() -\u003e { synchronized (lock1) { System.out.println(\"Thread 1: Holding lock 1...\"); try { Thread.sleep(100); // Simulate work } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"Thread 1: Waiting for lock 2...\"); synchronized (lock2) { System.out.println(\"Thread 1: Acquired lock 2!\"); } } }); Thread thread2 = new Thread(() -\u003e { synchronized (lock2) { System.out.println(\"Thread 2: Holding lock 2...\"); try { Thread.sleep(100); // Simulate work } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"Thread 2: Waiting for lock 1...\"); synchronized (lock1) { System.out.println(\"Thread 2: Acquired lock 1!\"); } } }); thread1.start(); thread2.start(); } } $ jps 76995 Launcher 76996 Main 77127 Jps 2327 Main -------------- $ jstack 76996 \"Thread-0\": at dev.signalyu.warmup.Main.lambda$main$0(Main.java:18) 🌟 - waiting to lock \u003c0x000000070ffce280\u003e (a java.lang.Object) 🌟 - locked \u003c0x000000070ffce270\u003e (a java.lang.Object) at dev.signalyu.warmup.Main$$Lambda$14/0x000000012d001208.run(Unknown Source) at java.lang.Thread.run(java.base@17.0.9/Thread.java:842) \"Thread-1\": at dev.signalyu.warmup.Main.lambda$main$1(Main.java:33) 🌟 - waiting to lock \u003c0x000000070ffce270\u003e (a java.lang.Object) 🌟 - locked \u003c0x000000070ffce280\u003e (a java.lang.Object) at dev.signalyu.warmup.Main$$Lambda$15/0x000000012d001428.run(Unknown Source) at java.lang.Thread.run(java.base@17.0.9/Thread.java:842) Found 1 deadlock. 🌟 Thread Interruption In Java, thread interruption is a mechanism that allows one thread to signal another to stop its execution. The three common approaches to interrupt a thread are using a volatile flag, an AtomicBoolean, or the interrupt() method.\nSHOW CODE volatile AtomicBoolean interrupt() import java.util.concurrent.TimeUnit; public class Main { private static volatile boolean isStop = false; public static void main(String[] args) { new Thread(() -\u003e { while (!isStop) { try { TimeUnit.MILLISECONDS.sleep(500); System.out.println(\"isStop: \" + isStop); } catch (InterruptedException e) { throw new RuntimeException(e); } } System.out.println(\"isStop --\u003e \" + isStop); }, \"t1\").start(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } // Signal threads to stop new Thread(() -\u003e { isStop = true; }, \"t2\").start(); } } import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicBoolean; public class Main { private static final AtomicBoolean atomicBoolean = new AtomicBoolean(false); public static void main(String[] args) { new Thread(() -\u003e { while (!atomicBoolean.get()) { try { TimeUnit.MILLISECONDS.sleep(500); } catch (InterruptedException e) { throw new RuntimeException(e); } System.out.println(\"Atomic Boolean: \" + atomicBoolean); } System.out.println(\"Atomic Boolean --\u003e \" + atomicBoolean); }, \"t1\").start(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } // Signal threads to stop new Thread(() -\u003e { atomicBoolean.set(true); }, \"t2\").start(); } } public class Main { private static volatile boolean isStop = false; public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { while (!Thread.currentThread().isInterrupted()) { System.out.println(\"Is interrupted: \" + Thread.currentThread().isInterrupted()); } System.out.println(\"Is interrupted --\u003e \" + Thread.currentThread().isInterrupted()); }, \"t1\"); t1.start(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } // Signal threads to stop new Thread(() -\u003e { t1.interrupt(); }, \"t2\").start(); } } SHOW OUTPUT volatile AtomicBoolean interrupt() isStop: false isStop: true isStop --\u003e true Atomic Boolean: false Atomic Boolean: true Atomic Boolean --\u003e true ...... Is interrupted: false Is interrupted: false Is interrupted: false Is interrupted --\u003e true The common methods for managing thread interruption in Java include interrupt(), interrupted(), and isInterrupted():\ninterrupt(): An instance method that sets the thread’s interrupted status to true. It does not forcibly stop the thread. If the thread is blocked (e.g., in sleep(), wait(), or join()), it throws an InterruptedException. interrupted(): A static method that checks if the current thread has been interrupted. If it has, the method resets the interrupted status to false. isInterrupted(): An instance method that checks if the thread has been interrupted without resetting its interrupted status. What’s the following code output?\nSHOW CODE (Wrong Interruption) Java import java.util.concurrent.TimeUnit; public class Main { public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { while (true) { if (Thread.currentThread().isInterrupted()) { System.out.println(\"isInterrupted --\u003e true\"); break; } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"INTERRUPTED...\"); } }, \"t1\"); t1.start(); try { TimeUnit.SECONDS.sleep(3); // Sleep 3 seconds } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -\u003e { t1.interrupt(); // Set interrupted status of thread 't1' to true }, \"t2\").start(); } } SHOW OUTPUT (Wrong Interruption) Output INTERRUPTED... INTERRUPTED... java.lang.InterruptedException: sleep interrupted at java.base/java.lang.Thread.sleep(Native Method) at dev.signalyu.warmup.Main.lambda$main$0(Main.java:14) at java.base/java.lang.Thread.run(Thread.java:842) INTERRUPTED... INTERRUPTED... ...... When a thread is interrupted while blocked, the blocking method throws an InterruptedException and clears the interrupted status.\nSHOW CODE (Correct Interruption) Java import java.util.concurrent.TimeUnit; public class Main { public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { while (true) { if (Thread.currentThread().isInterrupted()) { System.out.println(\"isInterrupted --\u003e true\"); break; } try { Thread.sleep(1000); } catch (InterruptedException e) { Thread.currentThread().interrupt(); // 🌟🌟🌟 Restore its interrupted status 🌟🌟🌟 e.printStackTrace(); } System.out.println(\"INTERRUPTED...\"); } }, \"t1\"); t1.start(); try { TimeUnit.SECONDS.sleep(3); // Sleep 3 seconds } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -\u003e { t1.interrupt(); // Set interrupted status of thread 't1' to true }, \"t2\").start(); } } SHOW OUTPUT (Correct Interruption) Output INTERRUPTED... INTERRUPTED... java.lang.InterruptedException: sleep interrupted at java.base/java.lang.Thread.sleep(Native Method) at dev.signalyu.warmup.Main.lambda$main$0(Main.java:14) at java.base/java.lang.Thread.run(Thread.java:842) INTERRUPTED... isInterrupted --\u003e true After restoring the thread’s interrupted status by adding Thread.currentThread().interrupt();, it exits the while loop gracefully.\nLockSupport wait()/nofity() related problems There are two common issues when using wait() and notify() in Java:\nSynchronization Requirement: Both wait() and notify() must be called within a synchronized block or method. This is because these methods rely on the object’s intrinsic lock (monitor). If they are called outside a synchronized context, the program will throw an IllegalMonitorStateException. Missed Notifications: If notify() is called before wait(), the notification will be missed, and the thread calling wait() may block indefinitely. This happens because notify() does not have any effect if no thread is currently waiting on the object’s monitor. SHOW CODE Synchronization Requirement Missed Notifications public class Main { private static final Object lock = new Object(); public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { // synchronized (lock) { try { System.out.println(\"Thread 1 is waiting...\"); lock.wait(); // Thread 1 waits } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"Thread 1 is resumed.\"); // } }); Thread t2 = new Thread(() -\u003e { // synchronized (lock) { System.out.println(\"Thread 2 is notifying...\"); lock.notify(); // Thread 2 notifies // } }); t1.start(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } t2.start(); } } public class Main { private static final Object lock = new Object(); public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } // Acquire the lock after 1 second, notify() executes first synchronized (lock) { try { System.out.println(\"Thread 1 is waiting...\"); lock.wait(); // Thread 1 waits } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"Thread 1 is resumed.\"); } }); Thread t2 = new Thread(() -\u003e { synchronized (lock) { System.out.println(\"Thread 2 is notifying...\"); lock.notify(); // Thread 2 notifies } }); t1.start(); t2.start(); } } SHOW OUTPUT Synchronization Requirement Missed Notifications Thread 1 is waiting... Exception in thread \"Thread-0\" java.lang.IllegalMonitorStateException: current thread is not owner at java.base/java.lang.Object.wait(Native Method) at java.base/java.lang.Object.wait(Object.java:338) at dev.signalyu.warmup.Main.lambda$main$0(Main.java:11) at java.base/java.lang.Thread.run(Thread.java:842) Thread 2 is notifying... Exception in thread \"Thread-1\" java.lang.IllegalMonitorStateException: current thread is not owner at java.base/java.lang.Object.notify(Native Method) at dev.signalyu.warmup.Main.lambda$main$1(Main.java:22) at java.base/java.lang.Thread.run(Thread.java:842) Thread 2 is notifying... Thread 1 is waiting... // WAIT INDEFINITELY await()/signal() related problems Similar to wait()/notify(), when using await()/signal() from the Condition interface, the thread must hold the associated lock. If the lock is not held, the program will throw an IllegalMonitorStateException. Additionally, if signal() is called before await(), the notification will be missed, and the thread calling await() may wait indefinitely. To avoid this, always use a loop to recheck the condition after waking up from await(). This ensures that thread only proceeds when the condition is truly met, even if a spurious wakeup occurs or notification is missed.\nSHOW CODE Synchronization Requirement Missed Notifications import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.ReentrantLock; public class Main { private static final ReentrantLock lock = new ReentrantLock(); private static final Condition condition = lock.newCondition(); public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { // lock.lock(); try { System.out.println(\"Thread 1 is waiting...\"); condition.await(); // Thread 1 waits System.out.println(\"Thread 1 is resumed.\"); } catch (InterruptedException e) { e.printStackTrace(); } finally { // lock.unlock(); } }); Thread t2 = new Thread(() -\u003e { // lock.lock(); try { System.out.println(\"Thread 2 is signaling...\"); condition.signal(); // Thread 2 signals } finally { // lock.unlock(); } }); t1.start(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } t2.start(); } } import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.ReentrantLock; public class Main { private static final ReentrantLock lock = new ReentrantLock(); private static final Condition condition = lock.newCondition(); public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } // Acquire the lock after 1 second, signal() executes first lock.lock(); try { System.out.println(\"Thread 1 is waiting...\"); condition.await(); // Thread 1 waits System.out.println(\"Thread 1 is resumed.\"); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } }); Thread t2 = new Thread(() -\u003e { lock.lock(); try { System.out.println(\"Thread 2 is signaling...\"); condition.signal(); // Thread 2 signals } finally { lock.unlock(); } }); t1.start(); t2.start(); } } SHOW OUTPUT Synchronization Requirement Missed Notifications Thread 1 is waiting... Exception in thread \"Thread-0\" java.lang.IllegalMonitorStateException at java.base/java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.enableWait(AbstractQueuedSynchronizer.java:1516) at java.base/java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1611) at dev.signalyu.warmup.Main.lambda$main$0(Main.java:15) at java.base/java.lang.Thread.run(Thread.java:842) Thread 2 is signaling... Exception in thread \"Thread-1\" java.lang.IllegalMonitorStateException at java.base/java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.signal(AbstractQueuedSynchronizer.java:1473) at dev.signalyu.warmup.Main.lambda$main$1(Main.java:28) at java.base/java.lang.Thread.run(Thread.java:842) Thread 2 is signaling... Thread 1 is waiting... // WAIT INDEFINITELY LockSupport: park()/unpark(Thread) LockSupport is a utility class in Java that provides a low-level mechanism for thread synchronization. Unlike synchronized blocks or explicit Lock objects, LockSupport does not require explicit locking and unblocking. Instead, it operates using a permit mechanism, which makes it more flexible and lightweight. The most commonly used methods in LockSupport are park() and unpark(Thread). The park() method blocks the current thread if the permit is unavailable, while the unpark(Thread) method makes the permit available for a specific thread, unblocking if it was parked.\nThe key points about LockSupport include:\nThe permit is a binary semaphore, meaning it can either be available or unavailable. If a permit is available when park() is called, the thread continues execution without blocking. If no permit is available, the thread blocks until one is made available via unpark(). Unlike synchronized and Lock, LockSupport does not suffer from spurious wakeups. This means that a thread will only unblock when explicitly unparked, providing more predictable behavior compared to wait()/notify() or await()/signal(). The unpark(Thread) method targets a specific thread, making it more precise than notify() or signal(), which wake up any waiting thread. SHOW CODE park()/unpark(Thread) wait()/notify() await()/signal() import java.util.concurrent.locks.LockSupport; public class Main { public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { System.out.println(\"Thread 1 is parking...\"); LockSupport.park(); // Thread 1 parks System.out.println(\"Thread 1 is unparked.\"); }); Thread t2 = new Thread(() -\u003e { System.out.println(\"Thread 2 is unparking Thread 1...\"); LockSupport.unpark(t1); // Thread 2 unparks Thread 1 }); t1.start(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } t2.start(); } } public class Main { private static final Object lock = new Object(); public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { synchronized (lock) { try { System.out.println(\"Thread 1 is waiting...\"); lock.wait(); // Thread 1 waits } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"Thread 1 is resumed.\"); } }); Thread t2 = new Thread(() -\u003e { synchronized (lock) { System.out.println(\"Thread 2 is notifying...\"); lock.notify(); // Thread 2 notifies } }); t1.start(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } t2.start(); } } import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.ReentrantLock; public class Main { private static final ReentrantLock lock = new ReentrantLock(); private static final Condition condition = lock.newCondition(); public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { lock.lock(); try { System.out.println(\"Thread 1 is waiting...\"); condition.await(); // Thread 1 waits System.out.println(\"Thread 1 is resumed.\"); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } }); Thread t2 = new Thread(() -\u003e { lock.lock(); try { System.out.println(\"Thread 2 is signaling...\"); condition.signal(); // Thread 2 signals } finally { lock.unlock(); } }); t1.start(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } t2.start(); } } SHOW OUTPUT park()/unpark(Thread) wait()/notify() await()/signal() Thread 1 is parking... Thread 2 is unparking Thread 1... Thread 1 is unparked. Thread 1 is waiting... Thread 2 is notifying... Thread 1 is resumed. Thread 1 is waiting... Thread 2 is signaling... Thread 1 is resumed. Java Memory Model The Java Memory Model (JMM) is a specification that governs how threads interact with memory in a multi-threaded environment. It establishes rules that determine how and when change made by one thread to shared variables become visible to other threads, ensuring consistency and predictability in concurrent execution.\nJMM classifies memory into two types: Main Memory and Working Memory. Main Memory is the central storage where all variables, including instance fields, static fields, and array elements, reside. Working Memory, on the other hand, is a thread’s local memory that holds copies of variables it accesses. Threads do not interact with main memory directly; instead, they load variables into their working memory and write back updates when necessary. A fundamental concept in JMM is the happens-before relationship, which defines the order of operations between threads to maintain memory consistency. If one action happens-before another, the effects of the first action are guaranteed to be visible to the second. Examples include:\nA write to a volatile variable happens-before every subsequent read of that variable. Unlocking a monitor happens-before the next lock on the same monitor. The key characteristics of JMM include Atomicity, Visibility, and Ordering.\nAtomicity: Certain operations, such as reads and writes to volatile variables, are atomic, meaning they execute as indivisible units. Visibility: Changes made by one thread to shared variables are guaranteed to be seen by other threads under proper synchronization mechanisms. Ordering: JMM defines strict rules for instruction ordering, but without synchronization, the JVM may reorder instructions for optimization, potentially causing unpredictable behavior in a multi-threaded environment. happens-before The happens-before relationship in the Java Memory Model (JMM) establishes rules that dictate the ordering and visibility of actions in multithreaded programs. It ensures that certain operations performed in one thread become predictably visible to another, preventing issues like instruction reordering and inconsistent data access. Below are the eight key priciples of the happens-before relationship:\nProgram Order Rule: Within a single thread, actions occur in program order. For example, earlier statements happen-before later ones. int a = 10; // Happens-before int b = a + 5; // This sees the updated value of `a` Monitor Lock Rule: An unlock (unlock()) on a monitor lock happens-before any subsequent lock (lock()) on the same monitor. synchronized (lock) { sharedVar = 10; // Happens-before the next lock } synchronized (lock) { System.out.println(sharedVar); // Guaranteed to see updated value } Volatile Variable Rule: A write to a volatile variable happens-before any subsequent read of that same variable. private volatile boolean flag = false; flag = true; // Happens-before the next read System.out.println(flag); // Guaranteed to see true Thread Start Rule: A call to Thread.start() on a new thread happens-before any actions in that thread. Thread t = new Thread(() -\u003e System.out.println(\"Running\")); t.start(); // Happens-before the thread executes the print statement Thread Termination Rule: All actions in a thread happen-before other threads detecting its termination. In other words, after a thread terminates, all its actions are visible to the thread that joins it. Thread t = new Thread(() -\u003e counter = 100); t.start(); t.join(); // Ensures all writes in t happen-before main thread continues System.out.println(counter); // Guaranteed to see 100 A call to Thread.interrupt() happens-before the interrupted thread detects the interruption via isInterrupted() or InterruptedException. Thread t = new Thread(() -\u003e { while (!Thread.currentThread().isInterrupted()) { // Looping until interrupted } }); t.start(); t.interrupt(); // Happens-before the thread detects the interruption Final Field Rule: Writes to final fields in a constructor happen-before the object is seen by any other thread. class Example { final int x; Example() { x = 42; // Happens-before any other thread sees this object } } If action A happens-before action B, and action B happens-before action C, then action A happens-before action C. volatile int a = 0; a = 1; // A happens-before B (write to volatile) int b = a; // B happens-before C (read from volatile) volatile ",
  "wordCount" : "13101",
  "inLanguage": "en",
  "datePublished": "2024-12-11T12:13:32+08:00",
  "dateModified": "2024-12-11T12:13:32+08:00",
  "author":{
    "@type": "Person",
    "name": "Signal Yu"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/multithreading-and-concurrency/1-multithreading-and-concurrency/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Signal's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://signalyu.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://signalyu.github.io/" accesskey="h" title="Signal&#39;s Blog (Alt + H)">
                <img src="https://signalyu.github.io/apple-touch-icon.png" alt="" aria-label="logo"
                    height="40">Signal&#39;s Blog</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://signalyu.github.io/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://signalyu.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://signalyu.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://signalyu.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://signalyu.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Multithreading &amp; Concurrency
    </h1>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#introduction-to-multithreading" aria-label="Introduction to Multithreading">Introduction to Multithreading</a><ul>
                        
                <li>
                    <a href="#program-process-and-thread" aria-label="Program, Process, and Thread">Program, Process, and Thread</a></li>
                <li>
                    <a href="#thread-life-cycle-within-concurrency" aria-label="Thread Life Cycle Within Concurrency">Thread Life Cycle Within Concurrency</a></li>
                <li>
                    <a href="#forkjoin-model" aria-label="Fork/Join Model">Fork/Join Model</a></li>
                <li>
                    <a href="#critical-section--race-condition" aria-label="Critical Section &amp; Race Condition">Critical Section &amp; Race Condition</a></li>
                <li>
                    <a href="#synchronization-mechanisms" aria-label="Synchronization Mechanisms">Synchronization Mechanisms</a><ul>
                        
                <li>
                    <a href="#mutex-mechanism" aria-label="Mutex Mechanism">Mutex Mechanism</a></li>
                <li>
                    <a href="#readwrite-lock-mechanism" aria-label="Read/Write Lock Mechanism">Read/Write Lock Mechanism</a></li>
                <li>
                    <a href="#semaphore-mechanism" aria-label="Semaphore Mechanism">Semaphore Mechanism</a></li>
                <li>
                    <a href="#conditional-variable-mechanism" aria-label="Conditional Variable Mechanism">Conditional Variable Mechanism</a></li>
                <li>
                    <a href="#barrier-mechanism" aria-label="Barrier Mechanism">Barrier Mechanism</a></li></ul>
                </li>
                <li>
                    <a href="#thread-creation-in-java" aria-label="Thread Creation In Java">Thread Creation In Java</a><ul>
                        
                <li>
                    <a href="#extending-thread-class" aria-label="Extending Thread Class">Extending Thread Class</a></li>
                <li>
                    <a href="#implementing-runnable-interface" aria-label="Implementing Runnable Interface">Implementing Runnable Interface</a></li>
                <li>
                    <a href="#using-the-callable-interface" aria-label="Using the Callable Interface">Using the Callable Interface</a></li>
                <li>
                    <a href="#using-executors" aria-label="Using Executors">Using Executors</a></li></ul>
                </li>
                <li>
                    <a href="#thread-termination-in-java" aria-label="Thread Termination In Java">Thread Termination In Java</a><ul>
                        
                <li>
                    <a href="#using-a-flag" aria-label="Using a flag">Using a flag</a></li>
                <li>
                    <a href="#interrupting-a-thread" aria-label="Interrupting a Thread">Interrupting a Thread</a></li></ul>
                </li>
                <li>
                    <a href="#daemon-threads" aria-label="Daemon Threads">Daemon Threads</a></li>
                <li>
                    <a href="#performance-optimization" aria-label="Performance Optimization">Performance Optimization</a></li>
                <li>
                    <a href="#problems" aria-label="Problems">Problems</a><ul>
                        
                <li>
                    <a href="#linear-search-with-finding-one-occurrence" aria-label="Linear Search with Finding One Occurrence">Linear Search with Finding One Occurrence</a></li>
                <li>
                    <a href="#linear-search-for-all-occurrences" aria-label="Linear Search for All Occurrences">Linear Search for All Occurrences</a></li>
                <li>
                    <a href="#linear-search-with-indices-and-occurrences" aria-label="Linear Search with Indices and Occurrences">Linear Search with Indices and Occurrences</a></li>
                <li>
                    <a href="#minmaxsum" aria-label="Min/Max/Sum">Min/Max/Sum</a></li>
                <li>
                    <a href="#pi-calculation" aria-label="Pi Calculation">Pi Calculation</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#juc" aria-label="JUC">JUC</a><ul>
                        
                <li>
                    <a href="#completablefuture" aria-label="CompletableFuture">CompletableFuture</a><ul>
                        
                <li>
                    <a href="#future-interface" aria-label="Future Interface">Future Interface</a></li>
                <li>
                    <a href="#completablefuture-1" aria-label="CompletableFuture">CompletableFuture</a></li></ul>
                </li>
                <li>
                    <a href="#java-locks" aria-label="Java Locks">Java Locks</a><ul>
                        
                <li>
                    <a href="#optimistic-lock-vs-pessimistic-lock" aria-label="Optimistic Lock vs. Pessimistic Lock">Optimistic Lock vs. Pessimistic Lock</a></li>
                <li>
                    <a href="#synchronized-related-problems" aria-label="synchronized Related Problems">synchronized Related Problems</a></li>
                <li>
                    <a href="#synchronized-byte-code-analysis" aria-label="synchronized Byte Code Analysis">synchronized Byte Code Analysis</a></li>
                <li>
                    <a href="#fair-lock-vs-unfair-lock" aria-label="Fair Lock vs. Unfair Lock">Fair Lock vs. Unfair Lock</a></li>
                <li>
                    <a href="#recursive-lock" aria-label="Recursive Lock">Recursive Lock</a></li>
                <li>
                    <a href="#deadlock" aria-label="Deadlock">Deadlock</a></li></ul>
                </li>
                <li>
                    <a href="#thread-interruption" aria-label="Thread Interruption">Thread Interruption</a></li>
                <li>
                    <a href="#locksupport" aria-label="LockSupport">LockSupport</a><ul>
                        
                <li>
                    <a href="#waitnofity-related-problems" aria-label="wait()/nofity() related problems">wait()/nofity() related problems</a></li>
                <li>
                    <a href="#awaitsignal-related-problems" aria-label="await()/signal() related problems">await()/signal() related problems</a></li>
                <li>
                    <a href="#locksupport-parkunparkthread" aria-label="LockSupport: park()/unpark(Thread)">LockSupport: park()/unpark(Thread)</a></li></ul>
                </li>
                <li>
                    <a href="#java-memory-model" aria-label="Java Memory Model">Java Memory Model</a><ul>
                        
                <li>
                    <a href="#happens-before" aria-label="happens-before">happens-before</a></li></ul>
                </li>
                <li>
                    <a href="#volatile" aria-label="volatile">volatile</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="introduction-to-multithreading">Introduction to Multithreading<a hidden class="anchor" aria-hidden="true" href="#introduction-to-multithreading">#</a></h1>
<h2 id="program-process-and-thread">Program, Process, and Thread<a hidden class="anchor" aria-hidden="true" href="#program-process-and-thread">#</a></h2>
<blockquote>
<p>A <strong>program</strong> is a static set of instructions that stores on a disk. A <strong>process</strong> is an instance of a program that is currently being executed by the operating system. A <strong>thread</strong> is a small unit of process that can be scheduled and executed by the operating system. In simpler terms, a <strong>program</strong> is the code, a <strong>process</strong> is the excution of the code, a <strong>thread</strong> is a unit of execution within a process. Their relationships are illustrated in the following image:</p>
</blockquote>
<figure class="align-center ">
    <img loading="lazy" src="/img/multithreading-and-concurrency/1-program-process-thread.gif#center" width="100%" height="100%"/> <figcaption>
            Program, Process, and Thread
        </figcaption>
</figure>

<hr>
<h2 id="thread-life-cycle-within-concurrency">Thread Life Cycle Within Concurrency<a hidden class="anchor" aria-hidden="true" href="#thread-life-cycle-within-concurrency">#</a></h2>
<blockquote>
<p>A <strong>thread</strong> goes through various states in its life cycle, from creation to its termination. The life cycle of a thread typically includes five states: <code>New</code>, <code>Runnable</code>, <code>Running</code>, <code>Blocked/Waiting</code>, and <code>Terminated</code>.</p>
</blockquote>
<ol>
<li><code>New</code>: This refers to the state where a thread instance is created but has not yet started running. In Java, this is commonly achieved by using <code>new Thread()</code>.</li>
<li><code>Runnable</code>: This refers to the state where a thread instance is ready to run but is waiting for CPU time. In Java, this is commonly achieved by ivoking <code>start()</code> on the thread instance.</li>
<li><code>Running</code>: This is refers to the state where the thread instance is actively executing its task.</li>
<li><code>Blocked/Waiting</code>: This refers to the state where a thread instance is waiting for other threads to complete their tasks, or it is waiting for a particular condition to be met.</li>
<li><code>Terminated</code>: This refers to the state where the thread instance has completed its task and has exited.</li>
</ol>
<figure class="align-center ">
    <img loading="lazy" src="/img/multithreading-and-concurrency/2-thread-life-cycle-within-concurrency.gif#center" width="100%" height="100%"/> <figcaption>
            Thread Life Cycle Within Concurrency
        </figcaption>
</figure>

<hr>
<h2 id="forkjoin-model">Fork/Join Model<a hidden class="anchor" aria-hidden="true" href="#forkjoin-model">#</a></h2>
<blockquote>
<p>The <strong>Fork/Join Model</strong> is an effective strategy commonly used in scenarios where a task can be recursively divided into multiple smaller, independent subtasks. This strategy typically involves the following steps:</p>
</blockquote>
<ol>
<li>
<p>The process begins with a single master thread. When it encounters a task that can be broken down into smaller subtasks, the master thread forks (spawns) multiple subsidiary threads, each of which takes on a portion of the task.</p>
</li>
<li>
<p>Once the subsidiary threads have completed their respective tasks, they join back with the master thread. Joining involves terminating the subsidiary threads and consolidating their results into the master thread. Afterward, the master thread continues its execution.</p>
</li>
</ol>
<figure class="align-center ">
    <img loading="lazy" src="/img/multithreading-and-concurrency/3-fork-join.gif#center" width="100%" height="100%"/> <figcaption>
            Fork/Join Model
        </figcaption>
</figure>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.Arrays;
import java.util.concurrent.RecursiveTask;
import java.util.concurrent.ForkJoinPool;

public class Solution {

    // RecursiveTask to compute the sum of a part of an array
    static class SumTask extends RecursiveTask<Long> {
        private final int[] array;
        private final int start;
        private final int end;

        // Threshold for splitting the task into smaller subtasks
        private static final int THRESHOLD = 1000;

        public SumTask(int[] array, int start, int end) {
            this.array = array;
            this.start = start;
            this.end = end;
        }

        @Override
        protected Long compute() {
            // If the task is small enough, calculate the sum directly
            if (end - start <= THRESHOLD) {
                long sum = 0;
                for (int i = start; i < end; i++) {
                    sum += array[i];
                }
                return sum;
            }
            // Otherwise, split the task into two subtasks
            int middle = (start + end) / 2;
            SumTask leftTask = new SumTask(array, start, middle);
            SumTask rightTask = new SumTask(array, middle, end);

            // Fork the subtasks
            leftTask.fork();
            rightTask.fork();

            // Join the results of the subtasks
            long leftResult = leftTask.join();
            long rightResult = rightTask.join();

            // Combine the results and return
            return leftResult + rightResult;
        }
    }

    public static void main(String[] args) {
        int[] array = new int[10000];
        // Initialize all elements to 1
        Arrays.fill(array, 1);

        // Create a ForkJoinPool to execute the tasks
        ForkJoinPool pool = new ForkJoinPool();

        // Submit the task to the ForkJoinPool
        SumTask task = new SumTask(array, 0, array.length);
        long result = pool.invoke(task);

        System.out.println("Sum: " + result);  // Output the result
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW OUTPUT</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Output</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-bash" data-lang="bash" >Sum: 10000
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="critical-section--race-condition">Critical Section &amp; Race Condition<a hidden class="anchor" aria-hidden="true" href="#critical-section--race-condition">#</a></h2>
<blockquote>
<p><strong>Critical Section</strong> refers to a portion of a program where shared resources are accessed and modified. A <strong>Race Condition</strong> occurs when the program&rsquo;s behavior depends on the non-deterministic execution order of threads. Since multiple threads can access a critical section concurrently, it is essential to synchronize their access to avoid data inconsistency.</p>
</blockquote>
<p>For example, suppose there are four threads trying to read a value of 20 from memory. Each thread increments the value by 1 and writes it back to memory. Without synchronization mechanisms, after all threads complete their writes, the final value might be 21 instead of the expected 24. This leads to an unexpected outcome, as illustrated below.</p>
<figure class="align-center ">
    <img loading="lazy" src="/img/multithreading-and-concurrency/4-critical-section-and-race-condition.gif#center" width="100%" height="100%"/> <figcaption>
            Critical Section &amp; Race Condition
        </figcaption>
</figure>

<blockquote>
<p>To resolve this issue, <em>access to the critical section must be exclusive</em>. This is commonly achieved by using <strong>mutexes</strong>, <strong>read/write locks</strong>, <strong>semaphores</strong>, <strong>conditional variables</strong> or <strong>barriers</strong> to ensure that only one thread can modify the shared resource at a time.</p>
</blockquote>
<hr>
<h2 id="synchronization-mechanisms">Synchronization Mechanisms<a hidden class="anchor" aria-hidden="true" href="#synchronization-mechanisms">#</a></h2>
<blockquote>
<p><strong>Synchronization Mechanisms</strong> are rules used to coordinate the execution of threads in a program, ensuring safe access to shared resources. These mechanisms can be primarily classified into five types: <strong>Mutexes</strong>, <strong>Read/Write Locks</strong>, <strong>Semaphores</strong>, <strong>Conditional Variables</strong>, and Barriers.</p>
</blockquote>
<hr>
<h3 id="mutex-mechanism">Mutex Mechanism<a hidden class="anchor" aria-hidden="true" href="#mutex-mechanism">#</a></h3>
<blockquote>
<p>The <strong>mutex mechanism</strong> ensures that only one thread can access the critical section at a time. Other threads will be blocked until the mutex is released. The key logic behind the mutex mechanism is as follows:</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Lock lock <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ReentrantLock();
</span></span><span style="display:flex;"><span>lock.<span style="color:#a6e22e">lock</span>();  <span style="color:#75715e">// Acquire the lock</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Critical section code</span>
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>    lock.<span style="color:#a6e22e">unlock</span>(); <span style="color:#75715e">// Release the lock</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><figure class="align-center ">
    <img loading="lazy" src="/img/multithreading-and-concurrency/5-mutex.gif#center" width="100%" height="100%"/> <figcaption>
            Mutex Mechanism
        </figcaption>
</figure>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >public class Mutex {
    private static int counter = 0;
    private static final Object lock = new Object();

    public static void runExperiment(String experimentName, Runnable task) {
        counter = 0;

        Thread t1 = new Thread(task);
        Thread t2 = new Thread(task);

        t1.start();
        t2.start();

        try {
            t1.join();
            t2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Final counter value " + experimentName + ": " + counter + "");
    }

    public static void incrementCounterWithMutex() {
        for (int i = 0; i < 100; i++) {
            synchronized (lock) {
                int temp = counter;
                try {
                    Thread.sleep(1); // Sleep for 1 millisecond
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                counter = temp + 1;
            }
        }
    }

    public static void incrementCounterNoMutex() {
        for (int i = 0; i < 100; i++) {
            int temp = counter;
            try {
                Thread.sleep(1); // Sleep for 1 millisecond
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            counter = temp + 1;
        }
    }

    public static void main(String[] args) {
        runExperiment("With Mutex Experiment", Mutex::incrementCounterWithMutex);
        runExperiment("No Mutex Experiment", Mutex::incrementCounterNoMutex);
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW OUTPUT</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Output</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-bash" data-lang="bash" >Final counter value With Mutex Experiment: 200
Final counter value No Mutex Experiment: 100
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h3 id="readwrite-lock-mechanism">Read/Write Lock Mechanism<a hidden class="anchor" aria-hidden="true" href="#readwrite-lock-mechanism">#</a></h3>
<blockquote>
<p>The <strong>Read/Write Lock Mechanism</strong> allows threads read the shared resources concurrently, but ensures exclusive access for write operations. This mechanism is useful in scenarios where there are many read operations and fewer write operations, such as caching systems or databases. The key logic behind the <strong>read/write lock mechanism</strong> is as follows:</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ReadWriteLock rwLock <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ReentrantReadWriteLock();
</span></span><span style="display:flex;"><span>rwLock.<span style="color:#a6e22e">readLock</span>().<span style="color:#a6e22e">lock</span>();   <span style="color:#75715e">// Acquire read lock</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Read operation</span>
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>    rwLock.<span style="color:#a6e22e">readLock</span>().<span style="color:#a6e22e">unlock</span>(); <span style="color:#75715e">// Release read lock</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>rwLock.<span style="color:#a6e22e">writeLock</span>().<span style="color:#a6e22e">lock</span>();   <span style="color:#75715e">// Acquire write lock</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Write operation</span>
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>    rwLock.<span style="color:#a6e22e">writeLock</span>().<span style="color:#a6e22e">unlock</span>(); <span style="color:#75715e">// Release write lock</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>Under the Read/Write Lock mechanism, multiple threads can access the critical section simultaneously without blocking each other. When a writer thread is accessing the critical section, other writer threads and reader threads are blocked. Similarly, when a reader thread is accessing the critical section, the writer thread is blocked.</p>
</blockquote>
<figure class="align-center ">
    <img loading="lazy" src="/img/multithreading-and-concurrency/6-read-write-lock.webp#center" width="100%" height="100%"/> <figcaption>
            Read/Write Lock Mechanism
        </figcaption>
</figure>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class ReadWriteLock {
    private static volatile int counter = 0;
    private static final int TARGET_VALUE = 1000;
    private static final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();

    public static int incrementValue() {
        lock.writeLock().lock();
        try {
            Thread.sleep(1);
            if (counter < TARGET_VALUE) {
                counter++;
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.writeLock().unlock();
        }
        return counter;
    }

    public static int readValue() {
        lock.readLock().lock();
        try {
            Thread.sleep(1);
            return counter;
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.readLock().unlock();
        }
        return 0;
    }

    public static void main(String[] args) {
        long start = System.currentTimeMillis();

        List<Thread> readers = new ArrayList&lt;&gt;();
        for (int i = 0; i < 8; i++) {
            readers.add(new Thread(() -> {
                while (readValue() < TARGET_VALUE) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }));
        }

        List<Thread> writers = new ArrayList&lt;&gt;();
        for (int i = 0; i < 2; i++) {
            writers.add(new Thread(() -> {
                while (incrementValue() < TARGET_VALUE) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }));
        }

        readers.forEach(Thread::start);
        writers.forEach(Thread::start);

        readers.forEach(t -> {
            try {
                t.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        writers.forEach(t -> {
            try {
                t.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        long end = System.currentTimeMillis();
        System.out.println("Time taken: " + (end - start) / 1000.0 + " seconds");
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW OUTPUT</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Output</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-bash" data-lang="bash" >Time taken: 1.787 seconds
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<blockquote>
<p>In the above code, the <code>readValue</code> method uses a read lock, allowing multiple reader threads to access the counter (critical section) simultaneously without blocking each other. If the method used a write lock instead of a read lock, the execution time would be higher. This is because when a writer thread is accessing the counter, all other threads would be blocked.</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">readValue</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// lock.readLock().lock();</span>
</span></span><span style="display:flex;"><span>    lock.<span style="color:#a6e22e">writeLock</span>().<span style="color:#a6e22e">lock</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>        Thread.<span style="color:#a6e22e">sleep</span>(1);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> counter;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">catch</span> (InterruptedException e) {
</span></span><span style="display:flex;"><span>        e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// lock.readLock().unlock();</span>
</span></span><span style="display:flex;"><span>        lock.<span style="color:#a6e22e">writeLock</span>().<span style="color:#a6e22e">unlock</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> 0;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code>Time taken: 6.793 seconds # Use write lock
</code></pre><hr>
<h3 id="semaphore-mechanism">Semaphore Mechanism<a hidden class="anchor" aria-hidden="true" href="#semaphore-mechanism">#</a></h3>
<blockquote>
<p>The <strong>Semaphore mechanism</strong> uses an integer to manage a set of permits, allowing multiple threads to access shared resources simultaneously, but only up to a predetermined limit. There are two types of semaphores: <strong>Binary Semaphore</strong> and <strong>Counting Semaphore</strong>.</p>
</blockquote>
<ul>
<li><strong>Binary Semaphore</strong>: Similar to a mutex, it operates with two states (<code>0</code> and <code>1</code>), ensuring mutual exclusion in critical sections.</li>
<li><strong>Counting Semaphore</strong>: Allows a count greater than 1, permitting multiple threads to access shared resources concurrently, as long as the permit limit is not exceeded.</li>
</ul>
<blockquote>
<p>Semaphores are useful in controlling access to a pool of resources, such as limiting the number of threads that can access a database connection or a server. The key logic behind the semaphore mechanism is as follows:</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Semaphore semaphore <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Semaphore(3); <span style="color:#75715e">// Allow 3 threads at once</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>semaphore.<span style="color:#a6e22e">acquire</span>();   <span style="color:#75715e">// Acquire a permit</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Critical section code</span>
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>    semaphore.<span style="color:#a6e22e">release</span>();  <span style="color:#75715e">// Release a permit</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><figure class="align-center ">
    <img loading="lazy" src="/img/multithreading-and-concurrency/7-semaphore.gif#center" width="100%" height="100%"/> <figcaption>
            Semaphore Mechanism
        </figcaption>
</figure>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.concurrent.Semaphore;
import java.util.concurrent.atomic.AtomicInteger;

public class SemaphoreTest {
    // Global shared resource
    // AtomicInteger allows multiple threads to read/write value of counter without requiring synchronization
    private static final AtomicInteger counter = new AtomicInteger(0);

    // Semaphore with a count of 5
    private static final Semaphore semaphore = new Semaphore(5);

    private static final int TARGET_VALUE = 5000;

    public static void main(String[] args) {
        long startTime = System.currentTimeMillis();

        Thread[] workers = new Thread[10];
        for (int i = 0; i < workers.length; i++) {
            workers[i] = new Thread(SemaphoreTest::worker);
            workers[i].start();
        }

        for (Thread worker : workers) {
            try {
                worker.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                System.out.println("Thread was interrupted");
            }
        }

        long endTime = System.currentTimeMillis();
        System.out.println("Time taken: " + (endTime - startTime) / 1000.0 + " seconds");
    }

    private static void worker() {
        while (true) {
            try {
                semaphore.acquire(); // Acquire the semaphore
                if (counter.get() >= TARGET_VALUE) {
                    break;
                }
                counter.incrementAndGet(); // Atomically increments the counter
                Thread.sleep(1); // Simulate work
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                System.out.println("Thread was interrupted");
            } finally {
                semaphore.release(); // Release the semaphore
            }
        }
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h3 id="conditional-variable-mechanism">Conditional Variable Mechanism<a hidden class="anchor" aria-hidden="true" href="#conditional-variable-mechanism">#</a></h3>
<blockquote>
<p>The <strong>Conditional Variable Mechanism</strong> allows a thread to suspend its execution until other threads signal that a certain condition has been met. It is often used in conjunction with mutexes to implement synchronization patterns, such as the <em>producer-consumer pattern</em>.</p>
</blockquote>
<blockquote>
<p>In this mechanism, a thread can wait on a condition variable until it is notified by other threads that the condition has been satisfied. When the condition is fulfilled, one or more threads can be signaled to wake up and proceed. Condition variables are commonly used in scenarios like the producer-consumer problem, where one thread produces data and another consumes it, with both threads needing to wait for each other under specific conditions.</p>
</blockquote>
<blockquote>
<p>The key logic behind the <strong>Conditional Variable Mechanism</strong> is as follows:</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">synchronized</span> (lock) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>condition) {
</span></span><span style="display:flex;"><span>        lock.<span style="color:#a6e22e">wait</span>();  <span style="color:#75715e">// Wait until condition is true</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Proceed with critical section</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">synchronized</span> (lock) {
</span></span><span style="display:flex;"><span>    condition <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>    lock.<span style="color:#a6e22e">notify</span>();  <span style="color:#75715e">// Notify waiting threads</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><figure class="align-center ">
    <img loading="lazy" src="/img/multithreading-and-concurrency/8-conditional-variables.png#center" width="100%" height="100%"/> <figcaption>
            Conditional Variable Mechanism
        </figcaption>
</figure>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Wait &amp; Notify</button>



<button class="tab_btn ">Busy Waiting</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >public class ConditionalVariable {
    private static final Object mutex = new Object();
    private static int sharedNumber;
    private static boolean ready = false;

    public static void producer() {
        synchronized (mutex) {
            sharedNumber = 9; // Producing a number
            ready = true;
            System.out.println("Producer has produced the number: " + sharedNumber);
            mutex.notify(); // Notify the consumer
        }
    }

    public static void consumer() {
        synchronized (mutex) {
            while (!ready) {
                try {
                    mutex.wait(); // Wait until the number is ready
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    System.out.println("Consumer thread was interrupted.");
                }
            }
            System.out.println("Consumer has consumed the number: " + sharedNumber);
        }
    }

    public static void main(String[] args) {
        Thread producerThread = new Thread(ConditionalVariable::producer);
        Thread consumerThread = new Thread(ConditionalVariable::consumer);

        producerThread.start();
        consumerThread.start();

        try {
            producerThread.join();
            consumerThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            System.out.println("Main thread was interrupted.");
        }
    }
}
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >public class Solution {
    private static final Object mutex = new Object();
    private static int sharedNumber;
    private static boolean ready = false;

    private static void producer() {
        synchronized (mutex) {
            sharedNumber = 9; // Producing a number
            ready = true;
            System.out.println("Producer has produced the number: " + sharedNumber);
        }
    }

    private static void consumer() {
        // Busy waiting loop
        while (true) {
            synchronized (mutex) {
                if (ready) {
                    System.out.println("Consumer has consumed the number: " + sharedNumber);
                    break;
                }
            }
            try {
                Thread.sleep(1); // Sleep for a short time
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                System.out.println("Thread was interrupted");
            }
        }
    }

    public static void main(String[] args) {
        Thread producerThread = new Thread(Solution::producer);
        Thread consumerThread = new Thread(Solution::consumer);

        producerThread.start();
        consumerThread.start();

        try {
            producerThread.join();
            consumerThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            System.out.println("Main thread was interrupted");
        }
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h3 id="barrier-mechanism">Barrier Mechanism<a hidden class="anchor" aria-hidden="true" href="#barrier-mechanism">#</a></h3>
<blockquote>
<p>The <strong>Barrier Mechanism</strong> allows threads to wait for each other at a specified point in their execution. It ensures that threads cannot proceed to the subsequent code until all threads have reached the barrier, as illustrated in the following image.</p>
</blockquote>
<figure class="align-center ">
    <img loading="lazy" src="/img/multithreading-and-concurrency/9-barrier.gif#center" width="100%" height="100%"/> <figcaption>
            Barrier Mechanism
        </figcaption>
</figure>

<blockquote>
<p>Barrier Mechanism are useful in parallel algorithms where multiple threads need to work in phases, and the next phase cannot begin until all threads complete the current one.</p>
</blockquote>
<blockquote>
<p>The key logic behind this mechanism is as follows:</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>CyclicBarrier barrier <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CyclicBarrier(4, <span style="color:#66d9ef">new</span> Runnable() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>() {
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;All threads reached the barrier!&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Threads:</span>
</span></span><span style="display:flex;"><span>barrier.<span style="color:#a6e22e">await</span>();  <span style="color:#75715e">// Wait at the barrier</span>
</span></span></code></pre></div><head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.concurrent.CyclicBarrier;

class Barriers {
    private static final CyclicBarrier barrier = new CyclicBarrier(2, () ->
            System.out.println("All threads have reached the barrier. Continue execution."));

    public static void main(String[] args) {
        Thread t1 = new Thread(Barriers::work);
        Thread t2 = new Thread(Barriers::work);

        // Start both threads.
        t1.start();
        t2.start();
    }

    private static void work() {
        System.out.println("Thread " + Thread.currentThread().getName()
                + " is waiting at the barrier");

        try {
            // Wait for the specified number of threads (2 in this case) to reach the barrier.
            barrier.await(); 
            System.out.println("Thread " + Thread.currentThread().getName() + " is released");
        } catch (Exception e) {
            // Handle exceptions, if any.
        }
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW OUTPUT</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Output</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-bash" data-lang="bash" >Thread Thread-0 is waiting at the barrier
Thread Thread-1 is waiting at the barrier
All threads have reached the barrier. Continue execution.
Thread Thread-1 is released
Thread Thread-0 is released
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="thread-creation-in-java">Thread Creation In Java<a hidden class="anchor" aria-hidden="true" href="#thread-creation-in-java">#</a></h2>
<h3 id="extending-thread-class">Extending Thread Class<a hidden class="anchor" aria-hidden="true" href="#extending-thread-class">#</a></h3>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println(this.getName() + " is running.");
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.setName("MYTHREAD-0");
        myThread.start();
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h3 id="implementing-runnable-interface">Implementing Runnable Interface<a hidden class="anchor" aria-hidden="true" href="#implementing-runnable-interface">#</a></h3>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >public class Main {
    public static void main(String[] args) {
        Thread thread = new Thread(() ->
                System.out.println(Thread.currentThread().getName() + " is running."));
        thread.start();
    }
}

//class MyRunnable implements Runnable {
//    @Override
//    public void run() {
//        System.out.println("Thread is running");
//    }
//}
//
//public class Main {
//    public static void main(String[] args) {
//        Thread thread = new Thread(new MyRunnable());
//        thread.start(); // Starts a new thread
//    }
//}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h3 id="using-the-callable-interface">Using the Callable Interface<a hidden class="anchor" aria-hidden="true" href="#using-the-callable-interface">#</a></h3>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.concurrent.*;

public class Main {
    public static void main(String[] args) throws Exception {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        Future&lt;String&gt; future = executor.submit(() ->
                Thread.currentThread().getName() + " is running.");
        System.out.println(future.get());
        executor.shutdown();
    }
}

class MyCallable implements Callable&lt;String&gt; {
//    @Override
//    public String call() {
//        return "Thread executed";
//    }
//}
//
//public class Main {
//    public static void main(String[] args) throws Exception {
//        ExecutorService executor = Executors.newSingleThreadExecutor();
//        Future&lt;String&gt; future = executor.submit(new MyCallable());
//        System.out.println(future.get()); // Retrieves the result
//        executor.shutdown();
//    }
//}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h3 id="using-executors">Using Executors<a hidden class="anchor" aria-hidden="true" href="#using-executors">#</a></h3>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.concurrent.*;

public class Main {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2);

        Runnable task1 = () -> System.out.println(Thread.currentThread().getName() + " executed");
        Runnable task2 = () -> System.out.println(Thread.currentThread().getName() + " executed");

        executor.execute(task1);
        executor.execute(task2);

        executor.shutdown();
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="thread-termination-in-java">Thread Termination In Java<a hidden class="anchor" aria-hidden="true" href="#thread-termination-in-java">#</a></h2>
<h3 id="using-a-flag">Using a flag<a hidden class="anchor" aria-hidden="true" href="#using-a-flag">#</a></h3>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Task implements Runnable {
    // Use volatile to ensure visibility between thread
    private volatile boolean running = true;


    @Override
    public void run() {
        while (running) {
            System.out.println("Thread is running.");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        System.out.println("Thread is stopping.");
    }

    public void stop() {
        running = false;
    }
}

public class Main {
    public static void main(String[] args) throws InterruptedException {
        Task task = new Task();
        Thread thread = new Thread(task);
        thread.start();

        Thread.sleep(3000); // Allow thread to run for a while
        task.stop(); // Signal thread to stop
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h3 id="interrupting-a-thread">Interrupting a Thread<a hidden class="anchor" aria-hidden="true" href="#interrupting-a-thread">#</a></h3>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >public class Main {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
            try {
                while (!Thread.currentThread().isInterrupted()) {
                    System.out.println("Thread is running");
                    Thread.sleep(1000);
                }
            } catch (InterruptedException e) {
                System.out.println("Thread is interrupted");
            }
        });

        thread.start();
        Thread.sleep(3000); // Allow thread to run for a while
        thread.interrupt(); // Interrupt the thread
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="daemon-threads">Daemon Threads<a hidden class="anchor" aria-hidden="true" href="#daemon-threads">#</a></h2>
<blockquote>
<p>A <strong>daemon thread</strong> in Java is a low-priority thread that runs in the background, typically handling tasks such as garbage collection or other housekeeping operations. The JVM terminates when all non-daemon threads have completed execution, even if daemon threads are still active. To create a daemon thread, the <code>setDaemon(true)</code> method is used on a <code>Thread</code> object before it is started.</p>
</blockquote>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >public class Main {
    public static void main(String[] args) {
        Thread daemonThread = new Thread(() -> {
            while (true) {
                System.out.println("Daemon thread is running");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });

        daemonThread.setDaemon(true); // Mark as daemon
        daemonThread.start();

        System.out.println("Main thread is ending");
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW OUTPUT</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Output</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-bash" data-lang="bash" >Main thread is ending
Daemon thread is running
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="performance-optimization">Performance Optimization<a hidden class="anchor" aria-hidden="true" href="#performance-optimization">#</a></h2>
<blockquote>
<p>When it comes to multithreading, performance optimization typically focuses on two key areas: <strong>latency reduction</strong> and <strong>throughput improvement</strong>.</p>
</blockquote>
<blockquote>
<p><strong>Latency reduction</strong> refers to minimizing the time it takes to complete a single task, measured in <code>time units</code>. This is often achieved by breaking a task into smaller subtasks that can be executed concurrently by multiple threads.</p>
</blockquote>
<blockquote>
<p><strong>Throughput</strong>, on the other hand, measures the number of tasks completed within a specific time frame, typically expressed as <code>tasks / time unit</code>. <strong>Throughput improvement</strong> is commonly achieved by utilizing <code>thread pooling</code>, which reduces the overhead of creating and destroying threads for each task.</p>
</blockquote>
<hr>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE: Latency Reduction</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public class Main {
    private static final String SOURCE_FILE = "src/main/resources/1-flower.jpg";
    private static final String DESTINATION_FILE = "./out/1-flower.jpg";

    public static void main(String[] args) throws IOException {
        BufferedImage originalImage = ImageIO.read(new File(SOURCE_FILE));
        BufferedImage resultImage = new BufferedImage(originalImage.getWidth(), originalImage.getHeight(), BufferedImage.TYPE_INT_RGB);

        long startTime = System.currentTimeMillis();
//        recolorSingleThreaded(originalImage, resultImage);
        int numberOfThreads = 1;
        recolorMultithreaded(originalImage, resultImage, numberOfThreads);
        long endTime = System.currentTimeMillis();

        long duration = endTime - startTime;

        File outputFile = new File(DESTINATION_FILE);
        File parentDir = outputFile.getParentFile();
        if (parentDir != null && !parentDir.exists()) {
            parentDir.mkdirs(); // Create the directory if it doesn't exist
        }
        ImageIO.write(resultImage, "jpeg", outputFile);

        System.out.println("duration = " + duration);
    }

    public static void recolorMultithreaded(BufferedImage originalImage, BufferedImage resultImage, int numberOfThreads) {
        List&lt;Thread&gt; threads = new ArrayList&lt;&gt;();
        int width = originalImage.getWidth();
        int height = originalImage.getHeight() / numberOfThreads;

        for(int i = 0; i < numberOfThreads ; i++) {
            final int threadMultiplier = i;

            Thread thread = new Thread(() -> {
                int xOrigin = 0 ;
                int yOrigin = height * threadMultiplier;

                recolorImage(originalImage, resultImage, xOrigin, yOrigin, width, height);
            });

            threads.add(thread);
        }

        for(Thread thread : threads) {
            thread.start();
        }

        for(Thread thread : threads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
            }
        }
    }

    private static void recolorSingleThreaded(BufferedImage originalImage, BufferedImage resultImage) {
        recolorImage(originalImage, resultImage, 0, 0, originalImage.getWidth(), originalImage.getHeight());
    }

    private static void recolorImage(BufferedImage originalImage, BufferedImage resultImage, int leftCorner, int topCorner, int width, int height) {
        for (int x = leftCorner; x < leftCorner + width && x < originalImage.getWidth(); x++) {
            for (int y = topCorner; y < topCorner + height && y < originalImage.getHeight(); y++) {
                recolorPixel(originalImage, resultImage, x, y);
            }
        }
    }

    private static void recolorPixel(BufferedImage originalImage, BufferedImage resultImage, int x, int y) {
        int rgb = originalImage.getRGB(x, y);

        int red = getRed(rgb);
        int green = getGreen(rgb);
        int blue = getBlue(rgb);

        int newRed;
        int newGreen;
        int newBlue;

        if (isShadeOfGray(red, green, blue)) {
            newRed = Math.min(255, red + 10);
            newGreen = Math.max(0, green - 80);
            newBlue = Math.max(0, blue - 20);
        } else {
            newRed = red;
            newGreen = green;
            newBlue = blue;
        }
        int newRGB = createRGBFromColors(newRed, newGreen, newBlue);
        setRGB(resultImage, x, y, newRGB);
    }

    public static void setRGB(BufferedImage image, int x, int y, int rgb) {
        image.getRaster().setDataElements(x, y, image.getColorModel().getDataElements(rgb, null));
    }

    public static boolean isShadeOfGray(int red, int green, int blue) {
        return Math.abs(red - green) < 30 && Math.abs(red - blue) < 30 && Math.abs(green - blue) < 30;
    }

    public static int createRGBFromColors(int red, int green, int blue) {
        int rgb = 0;

        rgb |= blue;
        rgb |= green << 8;
        rgb |= red << 16;

        rgb |= 0xFF000000;

        return rgb;
    }

    public static int getRed(int rgb) {
        return (rgb & 0x00FF0000) >> 16;
    }

    public static int getGreen(int rgb) {
        return (rgb & 0x0000FF00) >> 8;
    }

    public static int getBlue(int rgb) {
        return rgb & 0x000000FF;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW IMAGE: BEFORE PROCESSING</summary>
  <img loading="lazy" src="/img/multithreading/1-flower.jpg" alt="Flower: Before Processing"  />
</details></p>



<p><details >
  <summary markdown="span">SHOW IMAGE: AFTER PROCESSING</summary>
  <img loading="lazy" src="/img/multithreading/2-flower.jpg" alt="Flower: Before Processing"  />
</details></p>



<p><details >
  <summary markdown="span">Single Threaded VS. Multithreaded</summary>
  <img loading="lazy" src="/img/multithreading/3-latency-optimization.png" alt="Single Threaded VS. Multithreaded"  />
</details></p>

<hr>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE: Throughput vs. Threads</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Throughput vs. Threads</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import com.sun.net.httpserver.HttpExchange;
import com.sun.net.httpserver.HttpHandler;
import com.sun.net.httpserver.HttpServer;

import java.io.IOException;
import java.io.OutputStream;
import java.net.InetSocketAddress;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;

public class ThroughputHttpServer {
    private static final String INPUT_FILE = "./resources/war_and_peace.txt";
    private static final int NUMBER_OF_THREADS = 8;

    public static void main(String[] args) throws IOException {
        String text = new String(Files.readAllBytes(Paths.get(INPUT_FILE)));
        startServer(text);
    }

    public static void startServer(String text) throws IOException {
        HttpServer server = HttpServer.create(new InetSocketAddress(8000), 0);
        server.createContext("/search", new WordCountHandler(text));
        Executor executor = Executors.newFixedThreadPool(NUMBER_OF_THREADS);
        server.setExecutor(executor);
        server.start();
    }

    private static class WordCountHandler implements HttpHandler {
        private String text;

        public WordCountHandler(String text) {
            this.text = text;
        }

        @Override
        public void handle(HttpExchange httpExchange) throws IOException {
            String query = httpExchange.getRequestURI().getQuery();
            String[] keyValue = query.split("=");
            String action = keyValue[0];
            String word = keyValue[1];
            if (!action.equals("word")) {
                httpExchange.sendResponseHeaders(400, 0);
                return;
            }

            long count = countWord(word);

            byte[] response = Long.toString(count).getBytes();
            httpExchange.sendResponseHeaders(200, response.length);
            OutputStream outputStream = httpExchange.getResponseBody();
            outputStream.write(response);
            outputStream.close();
        }

        private long countWord(String word) {
            long count = 0;
            int index = 0;
            while (index >= 0) {
                index = text.indexOf(word, index);

                if (index >= 0) {
                    count++;
                    index++;
                }
            }
            return count;
        }
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW IMAGE: Throughput VS. Threads</summary>
  <img loading="lazy" src="/img/multithreading/4-throughput-improvement.png" alt="Throughput VS. Threads"  />
</details></p>

<hr>
<h2 id="problems">Problems<a hidden class="anchor" aria-hidden="true" href="#problems">#</a></h2>
<h3 id="linear-search-with-finding-one-occurrence">Linear Search with Finding One Occurrence<a hidden class="anchor" aria-hidden="true" href="#linear-search-with-finding-one-occurrence">#</a></h3>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement:</strong></p>
<p>The input consists of a large array (or list) of elements and a target value to search for. The goal is to utilize multiple threads to divide the search space and concurrently search for the target value, ultimately <strong>returning the index of the first occurrence of the target or <code>-1</code></strong> indicating that the target is not present.</p>
<p><strong>Requirements:</strong></p>
<ol>
<li><strong>Multithreading</strong>: Divide the array into multiple segments, with each thread searching a specific segment of the array. Each thread should operate independently and search its assigned segment.</li>
<li><strong>Return First Occurrence</strong>: Once the target value is found by any thread, it should return the index of the first occurrence, and other threads should stop searching.</li>
</ol>
<p><strong>Constraints:</strong></p>
<ul>
<li>The array can be large (millions of elements).</li>
<li>The number of threads used should be adjustable.</li>
<li>The target value may appear multiple times in the array, but only the index of the <strong>first occurrence</strong> should be returned.</li>
</ul>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >public class Solution {

    private static final int SIZE = 280000;
    private static final int NUM_THREADS = 4;

    private static final Object mtx = new Object(); // Mutex for controlling access to foundIndex
    private static volatile int foundIndex = -1;

    private static void linearSearch(int threadId, int[] arr, int key) {
        int chunkSize = arr.length / NUM_THREADS;
        int start = threadId * chunkSize;
        int end = (threadId == NUM_THREADS - 1) ? arr.length : start + chunkSize;

        for (int i = start; i < end; ++i) {
            // Early exit if foundIndex is set by another thread
            synchronized (mtx) {
                if (foundIndex != -1) {
                    break;
                }
            }

            if (arr[i] == key) {
                synchronized (mtx) {
                    if (foundIndex == -1) {
                        foundIndex = i;
                        break; // Exit after setting foundIndex
                    }
                }
            }
        }
    }

    public static void main(String[] args) {
        // Fill array with random numbers between 0-99
        int[] arr = new int[SIZE];
        for (int i = 0; i < SIZE; ++i) {
            arr[i] = (int) (Math.random() * 100);
        }

        Thread[] threads = new Thread[NUM_THREADS];

        int key = 9;
        for (int i = 0; i < NUM_THREADS; ++i) {
            final int threadId = i;
            threads[i] = new Thread(() -> linearSearch(threadId, arr, key));
            threads[i].start();
        }

        for (Thread thread : threads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        if (foundIndex == -1) {
            System.out.println("Element not found in the array.");
        } else {
            System.out.println("Element found at index: " + foundIndex);
        }
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h3 id="linear-search-for-all-occurrences">Linear Search for All Occurrences<a hidden class="anchor" aria-hidden="true" href="#linear-search-for-all-occurrences">#</a></h3>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement:</strong></p>
<p>The input consists of a large array (or list) of elements and a target value to search for. The goal is to utilize multiple threads to divide the search space and concurrently search for the target value, ultimately returning the index of <strong>all occurrences</strong> of the target or an empty list indicating that the target is not present.</p>
<p><strong>Requirements:</strong></p>
<ul>
<li><strong>Multithreading</strong>: Divide the array into multiple segments, with each thread searching a specific segment of the array. Each thread should operate independently and search its assigned segment.</li>
<li><strong>Return All Occurrences</strong>: Once the target value is found, the thread should store the index. All threads should continue searching, and their results (all indices of the target’s occurrences) should be combined and returned.</li>
</ul>
<p><strong>Constraints:</strong></p>
<ul>
<li>The array can be large (millions of elements).</li>
<li>The number of threads used should be adjustable.</li>
<li>The target value may appear multiple times in the array, and all indices where the target is found should be returned.</li>
</ul>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.ArrayList;
import java.util.List;
import java.util.Random;

public class Solution {

    private static final int SIZE = 4000;
    private static final int NUM_THREADS = 4;

    // Mutex for controlling access to foundPlaces
    private static final Object lockObj = new Object();
    private static List&lt;Integer&gt; foundPlaces = new ArrayList&lt;&gt;();

    private static void linearSearch(int threadId, int[] arr, int key) {
        int chunkSize = arr.length / NUM_THREADS;
        int start = threadId * chunkSize;
        int end = (threadId == NUM_THREADS - 1) ? arr.length : start + chunkSize;

        for (int i = start; i < end; ++i) {
            if (arr[i] == key) {
                synchronized (lockObj) { // Lock when modifying foundPlaces
                    foundPlaces.add(i); // Append the index to foundPlaces
                }
            }
        }
    }

    public static void main(String[] args) {
        // Create an array and fill it with random numbers between 0 and 99
        int[] arr = new int[SIZE];
        Random random = new Random();
        for (int i = 0; i < SIZE; ++i) {
            arr[i] = random.nextInt(100);
        }

        Thread[] threads = new Thread[NUM_THREADS]; // List to hold the threads
        int key = 9; // Element to find

        // Start the threads
        for (int i = 0; i < NUM_THREADS; ++i) {
            final int threadId = i;
            threads[i] = new Thread(() -> linearSearch(threadId, arr, key));
            threads[i].start();
        }

        // Join the threads with the main thread
        for (Thread thread : threads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        // Display the result
        if (foundPlaces.isEmpty()) {
            System.out.println("Element not found in the array.");
        } else {
            System.out.print("Element found at indices: ");
            synchronized (lockObj) { // Lock when reading from foundPlaces
                for (int index : foundPlaces) {
                    System.out.print(index + " ");
                }
            }
            System.out.println();
        }
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW NOTES</summary>
  <blockquote>
<p>The synchonization block can be removed when reading values from <code>foundPlaces</code>, as no threads modify the <code>foundPlaces</code> after the <code>join()</code> method is called.</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// Display the result</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (foundPlaces.<span style="color:#a6e22e">isEmpty</span>()) {
</span></span><span style="display:flex;"><span>    System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Element not found in the array.&#34;</span>);
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">print</span>(<span style="color:#e6db74">&#34;Element found at indices: &#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// No need for synchronization here, as no threads are modifying foundPlaces now</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// synchronized (lockObj) { // Lock when reading from foundPlaces</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> index : foundPlaces) {
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">print</span>(index <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; &#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// }</span>
</span></span><span style="display:flex;"><span>    System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
</details></p>

<hr>
<h3 id="linear-search-with-indices-and-occurrences">Linear Search with Indices and Occurrences<a hidden class="anchor" aria-hidden="true" href="#linear-search-with-indices-and-occurrences">#</a></h3>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement:</strong></p>
<p>You are given a large array (or list) of elements and a target value to search for. Your task is to implement a linear search that finds all occurrences of the target value in the array using multiple threads. Each thread should search a specific segment of the array, and the results (indices where the target is found) should be stored in a shared collection (e.g., a list). Additionally, a shared variable should keep track of the count of occurrences of the target value.</p>
<p><strong>Requirements:</strong></p>
<ul>
<li><strong>Multithreading:</strong>
<ol>
<li>Divide the array into equal segments based on the number of threads.</li>
<li>Each thread should independently search its assigned segment for the target value.</li>
<li>The number of threads should be adjustable to optimize performance depending on the size of the array.</li>
</ol>
</li>
<li><strong>Return:</strong>
<ol>
<li>A list of integers representing the indices of all occurrences of the target value.</li>
<li>An integer representing the total count of occurrences of the target value.</li>
</ol>
</li>
</ul>
<p><strong>Constraints:</strong></p>
<ul>
<li>The array can be very large, potentially containing millions of elements.</li>
<li>The number of threads used should be adjustable, allowing the program to scale with the size of the array and the system&rsquo;s available resources.</li>
<li>The target value may appear multiple times, and all occurrences should be included in the final result.</li>
</ul>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.ArrayList;
import java.util.List;
import java.util.Random;

public class Solution {

    private static final int SIZE = 4000;
    private static final int NUM_THREADS = 4;

    private static final List&lt;Integer&gt; foundIndices = new ArrayList&lt;&gt;(); // Shared list to store the indices of all occurrences
    private static int occurrencesCount = 0;                            // Shared variable to store the count of occurrences

    private static final Object indicesLock = new Object(); // Lock for synchronizing access to foundIndices
    private static final Object countLock = new Object();   // Lock for synchronizing access to occurrencesCount

    // Function executed by each thread to search for indices and occurrences
    private static void searchIndicesOccurrences(int threadId, int[] arr, int key) {
        int chunkSize = arr.length / NUM_THREADS;
        int start = threadId * chunkSize;
        int end = (threadId == NUM_THREADS - 1) ? arr.length : start + chunkSize;

        List&lt;Integer&gt; localIndices = new ArrayList&lt;&gt;();
        int localCount = 0;

        for (int i = start; i < end; ++i) {
            if (arr[i] == key) {
                localIndices.add(i);
                localCount++;
            }
        }

        if (!localIndices.isEmpty()) {
            synchronized (indicesLock) {
                foundIndices.addAll(localIndices);
            }
        }

        if (localCount > 0) {
            synchronized (countLock) {
                occurrencesCount += localCount;
            }
        }
    }

    public static void main(String[] args) {
        // Create an array and fill it with random numbers between 0 and 99
        int[] arr = new int[SIZE];
        Random random = new Random();
        for (int i = 0; i < SIZE; ++i) {
            arr[i] = random.nextInt(100);
        }

        Thread[] threads = new Thread[NUM_THREADS]; // Array of threads
        int key = 9; // Element to find

        // Start the threads
        for (int i = 0; i < NUM_THREADS; ++i) {
            int threadId = i;
            threads[i] = new Thread(() -> searchIndicesOccurrences(threadId, arr, key));
            threads[i].start();
        }

        // Wait for all threads to complete
        for (Thread thread : threads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        // Output the results
        if (foundIndices.isEmpty()) {
            System.out.println("Element not found in the array.");
        } else {
            System.out.print("Element found " + occurrencesCount + " times at indices: ");
            for (int index : foundIndices) {
                System.out.print(index + " ");
            }
            System.out.println();
        }
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h3 id="minmaxsum">Min/Max/Sum<a hidden class="anchor" aria-hidden="true" href="#minmaxsum">#</a></h3>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement:</strong></p>
<p>The input consists of a large array (or list) of elements. The goal is to efficiently calculate the minimum, maximum, and sum of elements in the array using multithreading. The array is divided into multiple segments, with each thread processing a specific segment. The threads will then return partial results (minimum, maximum, and sum for their respective segments), which will be combined to compute the final values for the entire array.</p>
<hr>
<p><strong>Requirements:</strong></p>
<ul>
<li>
<p><strong>Multithreading:</strong> Divide the array into multiple segments, with each thread processing a specific portion of the array. Each thread should independently compute the minimum, maximum, and sum for its assigned segment.</p>
</li>
<li>
<p><strong>Combine Results:</strong> Once each thread has finished processing, their partial results (min, max, and sum for the segment) should be combined to compute the final minimum, maximum, and sum for the entire array.</p>
</li>
<li>
<p><strong>Efficiency:</strong> The program should use multithreading to optimize the processing time, especially when dealing with large arrays containing millions of elements. The number of threads should be adjustable for optimal performance.</p>
</li>
</ul>
<hr>
<p><strong>Constraints:</strong></p>
<ul>
<li>
<p>The array can be large (millions of elements).</p>
</li>
<li>
<p>The number of threads used should be adjustable based on the size of the array and the system’s capabilities.</p>
</li>
<li>
<p>The array can contain both positive and negative numbers, and the minimum, maximum, and sum should be computed accurately, including for arrays with all negative values.</p>
</li>
</ul>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.Random;

public class Solution {

    private static final int DATA_SIZE = 100;
    private static final int NUMBER_OF_THREADS = 4;

    private static int[] data = new int[DATA_SIZE];
    private static int[] threadResultsSum = new int[NUMBER_OF_THREADS];
    private static int[] threadResultsMin = new int[NUMBER_OF_THREADS];
    private static int[] threadResultsMax = new int[NUMBER_OF_THREADS];

    public static void main(String[] args) throws InterruptedException {
        // Initialize data array
        Random random = new Random();
        for (int i = 0; i < DATA_SIZE; i++) {
            data[i] = random.nextInt(500);
        }

        Thread[] threads = new Thread[NUMBER_OF_THREADS * 3];

        // Start threads for sum, min, and max calculations
        for (int i = 0; i < NUMBER_OF_THREADS; i++) {
            final int threadId = i;
            final int start = threadId * (DATA_SIZE / NUMBER_OF_THREADS);
            final int end = (threadId + 1) * (DATA_SIZE / NUMBER_OF_THREADS);

            threads[threadId] = new Thread(() -> threadedSum(threadId, start, end));
            threads[threadId + NUMBER_OF_THREADS] = new Thread(() -> threadedMin(threadId, start, end));
            threads[threadId + NUMBER_OF_THREADS * 2] = new Thread(() -> threadedMax(threadId, start, end));

            threads[threadId].start();
            threads[threadId + NUMBER_OF_THREADS].start();
            threads[threadId + NUMBER_OF_THREADS * 2].start();
        }

        // Wait for threads to finish
        for (Thread thread : threads) {
            thread.join();
        }

        // Aggregate results from threads
        int totalSum = 0;
        for (int sum : threadResultsSum) {
            totalSum += sum;
        }

        int min = Integer.MAX_VALUE;
        for (int minResult : threadResultsMin) {
            min = Math.min(min, minResult);
        }

        int max = Integer.MIN_VALUE;
        for (int maxResult : threadResultsMax) {
            max = Math.max(max, maxResult);
        }

        System.out.println("Sum is " + totalSum);
        System.out.println("Min is " + min);
        System.out.println("Max is " + max);
    }

    private static void threadedSum(int threadId, int start, int end) {
        int sum = 0;
        for (int i = start; i < end; i++) {
            sum += data[i];
        }
        threadResultsSum[threadId] = sum;
    }

    private static void threadedMin(int threadId, int start, int end) {
        int min = Integer.MAX_VALUE;
        for (int i = start; i < end; i++) {
            min = Math.min(min, data[i]);
        }
        threadResultsMin[threadId] = min;
    }

    private static void threadedMax(int threadId, int start, int end) {
        int max = Integer.MIN_VALUE;
        for (int i = start; i < end; i++) {
            max = Math.max(max, data[i]);
        }
        threadResultsMax[threadId] = max;
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h3 id="pi-calculation">Pi Calculation<a hidden class="anchor" aria-hidden="true" href="#pi-calculation">#</a></h3>


<p><details >
  <summary markdown="span">SHOW PROBLEM</summary>
  <p><strong>Problem Statement</strong></p>
<p>The problem is to estimate the value of <strong>Pi</strong> using the <strong>Monte Carlo simulation</strong> method. In this method, we randomly generate points within a square and check how many of these points fall inside a circle inscribed within the square. The ratio of points inside the circle to the total points generated provides an approximation of Pi.</p>
<p><strong>Requirements:</strong></p>
<ol>
<li>
<p><strong>Random Point Generation:</strong></p>
<ul>
<li>Generate a large number of random points within a square. The square should have side lengths of 2 (i.e., points with coordinates ranging from -1 to 1 on both the x and y axes).</li>
<li>Each point has coordinates $(x, y)$, where $x$ and $y$ are randomly generated floating-point values between -1 and 1.</li>
</ul>
</li>
<li>
<p><strong>Circle Inside the Square:</strong></p>
<ul>
<li>A circle is inscribed within the square, with a radius of 1 and centered at the origin (0, 0).</li>
<li>A point $(x, y)$ lies inside the circle if the following condition is true:
$$
x^2 + y^2 \leq 1
$$</li>
</ul>
</li>
<li>
<p><strong>Monte Carlo Estimation of Pi:</strong></p>
<ul>
<li>Count how many of the generated points fall inside the circle.</li>
<li>The ratio of the points inside the circle to the total number of points can be used to estimate Pi. Specifically, the approximation of Pi is given by:
$$
\pi \approx 4 \times \frac{\text{points inside the circle}}{\text{total number of points}}
$$</li>
</ul>
</li>
<li>
<p><strong>Multithreading:</strong></p>
<ul>
<li>To speed up the simulation, divide the task of generating points and checking whether they lie inside the circle into multiple threads.</li>
<li>Each thread should be responsible for generating a subset of points and counting how many fall inside the circle.</li>
<li>Once all threads finish their work, their results should be combined to compute the final approximation of Pi.</li>
</ul>
</li>
<li>
<p><strong>Output:</strong></p>
<ul>
<li>Return the estimated value of Pi based on the simulation.</li>
</ul>
</li>
</ol>
<p><strong>Constraints:</strong></p>
<ul>
<li>The number of points to generate can be very large (millions of points).</li>
<li>The number of threads used should be adjustable.</li>
<li>The accuracy of the approximation improves with more points, but the simulation should be efficient enough to handle large numbers of points and multiple threads.</li>
</ul>

</details></p>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.Random;

public class Solution {
    private static final int NUM_THREADS = 10;
    private static final int NUMBER_OF_TOSSES = 100000000;
    private static int[] results = new int[NUM_THREADS];

    public static void main(String[] args) throws InterruptedException {
        Thread[] threads = new Thread[NUM_THREADS];

        for (int i = 0; i < NUM_THREADS; i++) {
            final int threadId = i;
            threads[i] = new Thread(() -> {
                Random rand = new Random();
                int start = threadId * NUMBER_OF_TOSSES / NUM_THREADS;
                int end = (threadId + 1) * NUMBER_OF_TOSSES / NUM_THREADS;
                int count_in_circle = 0;

                for (int j = start; j < end; j++) {
                    double x = rand.nextDouble() * 2 - 1;  // Random x in range [-1, 1]
                    double y = rand.nextDouble() * 2 - 1;  // Random y in range [-1, 1]
                    if (x * x + y * y <= 1) {  // If point is inside the circle
                        count_in_circle++;
                    }
                }
                results[threadId] = count_in_circle;
            });
            threads[i].start();
        }

        for (Thread thread : threads) {
            thread.join();
        }

        // Compute final estimate of Pi
        int total_inside = 0;
        for (int result : results) {
            total_inside += result;
        }
        double pi_estimate = 4.0 * total_inside / NUMBER_OF_TOSSES;
        System.out.println("PI = " + pi_estimate);
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW NOTES</summary>
  <p><strong>Introduction to Monte Carlo Estimation of $\pi$</strong></p>
<p>Suppose a square with a circle inscribed inside it, as shown in the image below. <img loading="lazy" src="/img/multithreading-and-concurrency/10-circle-inscribed-in-a-square.gif" alt="Circle inscribed inside a square"  />
 The circle has a radius of $r$, and the square has side length $2r$. The area of the circle is $A_{\text{circle}} = \pi r^2$, and the area of the square is $A_{\text{square}} = (2r)^2 = 4r^2$</p>
<p>The ratio of the area of the circle to the area of the square is
$$
\frac{A_{\text{circle}}}{A_{\text{square}}} = \frac{\pi r^2}{4 r^2} = \frac{\pi}{4}
$$</p>
<p>Therefore, the value of $\pi$ can be estimated by the formula:</p>
<p>$$
\pi \approx 4 \times \frac{\text{Number of points inside the circle}}{\text{Total number of points inside the square}}
$$</p>
<hr>
<p><strong>Visulization:</strong></p>
<p><img loading="lazy" src="/img/multithreading-and-concurrency/11-monte-carlo-estimation-of-pi.gif" alt="Monte Carlo Estimation of PI"  />
</p>

</details></p>

<hr>
<h1 id="juc">JUC<a hidden class="anchor" aria-hidden="true" href="#juc">#</a></h1>
<h2 id="completablefuture">CompletableFuture<a hidden class="anchor" aria-hidden="true" href="#completablefuture">#</a></h2>
<h3 id="future-interface">Future Interface<a hidden class="anchor" aria-hidden="true" href="#future-interface">#</a></h3>
<blockquote>
<p>The <strong>Future</strong> interface in Java defines several methods for managing asynchronous tasks, such as retriving the execution result, canceling a task, and checking if a task has been canceled or completed. It includes four commonly used methods: <code>get()</code>, <code>isDone()</code>, <code>cancel()</code>, and <code>isCancelled()</code>.</p>
</blockquote>
<ul>
<li>The <code>get()</code> mthod retrives the result of computation. <strong>Note: If the computation is not yet complete, this method will block until the result is available</strong>.</li>
<li>The <code>isDone()</code> method checks whether the computation has finished executing.</li>
<li>The <code>cancel()</code> method attempts to cancel the task execution.</li>
<li>The <code>isCancelled()</code> method checks if the task has been canceled before completion.</li>
</ul>
<hr>
<blockquote>
<p>The <strong>FutureTask</strong> class is a concrete implementation of the <strong>Future</strong> interface. It implements both the <strong>Runnable</strong> and <strong>Future</strong> interfaces, allowing it to be executed by a thread while also returning a result. Its constructor takes a <code>Callable&lt;V&gt;</code>, enabling the task to return a value. The class diagram is shown below: <img loading="lazy" src="" alt="FutureTask Class Diagram"  />
</p>
</blockquote>
<hr>
<blockquote>
<p>The <strong>Future</strong> combined with a thread pool enhances execution performance efficiently. However, its drarback lies in the <code>get()</code> method, which is blocking, and the <code>isDone()</code> method, whose polling behavior consumes CPU resources.</p>
</blockquote>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">FutureGetBlocking</button>



<button class="tab_btn ">FutureIsDonePolling</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

class Main {
    public static void main(String[] args) throws ExecutionException, InterruptedException {

        ExecutorService executor = Executors.newSingleThreadExecutor();

        Future&lt;String&gt; future = executor.submit(() -> {
            Thread.sleep(3000); // Simulate a long running task
            return "Task Completed";
        });

        System.out.println("Waiting for result...");

        // Block the main thread until the result is available
        String result = future.get();

        System.out.println("Result: " + result);

        executor.shutdown();
    }
}
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

class Main {
    public static void main(String[] args) throws ExecutionException, InterruptedException {

        ExecutorService executor = Executors.newSingleThreadExecutor();

        Future&lt;String&gt; future = executor.submit(() -> {
            Thread.sleep(3000); // Simulate a long-running task
            return "Task Completed";
        });

        // Busy-waiting, consuming CPU cycles
        while (!future.isDone()) {
            System.out.println("Checking if task is done...");
            Thread.sleep(100); // Reducing CPU usage slightly, but still inefficient
        }

        System.out.println("Result: " + future.get());

        executor.shutdown();
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h3 id="completablefuture-1">CompletableFuture<a hidden class="anchor" aria-hidden="true" href="#completablefuture-1">#</a></h3>
<blockquote>
<p>The <strong>CompletableFuture</strong> implements both the <strong>Future</strong> and <strong>CompletionStage</strong> interfaces. The <strong>CompletionStage</strong> represents a <strong>computation step</strong> that can be completed asynchronously. Unlike <strong>Future</strong>, <strong>CompletableFuture</strong> provides advanced mechanisms for handling asynchronous tasks, including <strong>non-blocking execution</strong>, <strong>method chaining</strong>, <strong>exception handling</strong>, <strong>combining futures</strong>, and <strong>thread pool customization</strong>.</p>
</blockquote>
<ul>
<li><strong>Non-blocking Execution</strong>: Unlike <code>Future.get()</code>, whcih blocks until the result is available, <strong>CompletableFuture</strong> enables asynchronous execution without blocking the main thread.</li>
<li><strong>Chaining</strong> Supports method chaining with <code>thenApply</code>, <code>thenCompose</code>, and <code>thenRun</code> to process results sequently.</li>
<li><strong>Exception Handling</strong>: Provides <code>exceptionally</code> and <code>handle</code> methods to gracefully handle errors.</li>
<li><strong>Combining Futures</strong>: Supports combining multiple futures using <code>thenCombine</code>, <code>allOf</code>, and <code>anyOf</code> for parallel execution.</li>
<li><strong>Thread Pool Customization</strong>: Allows executing tasks in a custom thread pool for better resource management.</li>
</ul>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Without Blocking</button>



<button class="tab_btn ">Chaining Tasks</button>



<button class="tab_btn ">ExceptionHandling</button>



<button class="tab_btn ">CombiningFutures</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.concurrent.*;

class Main {
    public static void main(String[] args) throws ExecutionException, InterruptedException {

        CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -> {
            try {
                Thread.sleep(2000);
                System.out.println("Task executed in a separate thread");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        System.out.println("Main thread is not blocked.");

        future.join();
    }
}
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >import java.util.concurrent.*;

class Main {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -> "Hello")
                .thenApply(result -> result + ", World!")
                .thenApply(String::toUpperCase);

        System.out.println(future.join()); // Output: HELLO, WORLD!
    }
}
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >import java.util.concurrent.*;

class Main {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -> {
            if (true) {
                throw new RuntimeException("Something went wrong!");
            }
            return "Success";
        }).exceptionally(ex -> "Recovered from: " + ex.getMessage());

        // Recovered from: java.lang.RuntimeException: Something went wrong!
        System.out.println(future.join());
    }
}
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >import java.util.concurrent.*;

class Main {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -> "Task 1");
        CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -> "Task 2");
        CompletableFuture&lt;String&gt; future3 = CompletableFuture.supplyAsync(() -> "Task 3");

        CompletableFuture<Void> allFutures = CompletableFuture.allOf(future1, future2, future3);

        // Retrieve results from individual futures
        String result1 = future1.get();
        String result2 = future2.get();
        String result3 = future3.get();

        System.out.println(result1);
        System.out.println(result2);
        System.out.println(result3);

        allFutures.join(); // Wait for all tasks to complete

        System.out.println("All tasks completed!");
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<blockquote>
<p>The advantage of <code>CompletableFuture</code> is that when an asynchronous task completes, it automatically invokes the callback method. Once the main thread sets up the callback, it no longer needs to monitor the asynchronous task, and allows execution to proceed in sequence. Additionally, if the asynchronous task fails, it automatically triggers the corresponding error-handling method.</p>
</blockquote>
<hr>
<blockquote>
<p>By default, <code>CompletableFuture.supplyAsync()</code> and <code>runAsync()</code> utilize the <code>ForkJoinPool.commonPool()</code>, a shared thread pool based on the ForkJoin framework. To use a custom thread pool, you need to provide a custom <code>Executor</code> when calling these methods.</p>
</blockquote>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">ForkJoinPool.commonPool()</button>



<button class="tab_btn ">Custom Thread Pool</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.concurrent.*;

class Main {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture.runAsync(() -> {
            // Running in: ForkJoinPool.commonPool-worker-1
            System.out.println("Running in: " + Thread.currentThread().getName());
        });

        // Sleep to allow async task to execute
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
        }
    }
}
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >import java.util.concurrent.*;

class Main {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService executor = Executors.newFixedThreadPool(5);
        CompletableFuture.runAsync(() ->
                // Custom pool: pool-1-thread-1
                System.out.println("Custom pool: "
                        + Thread.currentThread().getName()), executor);
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<blockquote>
<p>The main difference between <code>CompletableFuture.get()</code> and <code>CompletableFuture.join()</code> is <strong>exception handling</strong>. <code>get()</code> throws checked exceptions (<code>ExecutionException</code>, <code>InterruptedException</code>), requiring explicit handling, while <code>join()</code> throws an unchecked <code>CompletionException</code>, eliminating the need for explicit exception handling.</p>
</blockquote>
<hr>
<blockquote>
<p>The main differences between <code>thenRun()</code>, <code>thenAccept()</code>, and <code>thenApply</code> are</p>
</blockquote>
<ul>
<li><code>thenRun()</code> runs a task after previous stage completes, but <strong>does not</strong> take its result as input.</li>
<li><code>thenAccept()</code> runs a task after previous stage completes and <strong>consumes</strong> its result.</li>
<li><code>thenApply()</code> runs a task after previous stage completes and <strong>transform</strong> its result.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>CompletableFuture.<span style="color:#a6e22e">supplyAsync</span>(() <span style="color:#f92672">-&gt;</span> <span style="color:#e6db74">&#34;Task Completed&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">thenRun</span>(() <span style="color:#f92672">-&gt;</span> System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Follow-up action executed!&#34;</span>));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>CompletableFuture.<span style="color:#a6e22e">supplyAsync</span>(() <span style="color:#f92672">-&gt;</span> <span style="color:#e6db74">&#34;Hello, World!&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">thenAccept</span>(result <span style="color:#f92672">-&gt;</span> System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Result: &#34;</span> <span style="color:#f92672">+</span> result));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>CompletableFuture<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> future <span style="color:#f92672">=</span> CompletableFuture.<span style="color:#a6e22e">supplyAsync</span>(() <span style="color:#f92672">-&gt;</span> <span style="color:#e6db74">&#34;Hello&#34;</span>)
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">thenApply</span>(result <span style="color:#f92672">-&gt;</span> result <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;, World!&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(future.<span style="color:#a6e22e">join</span>()); <span style="color:#75715e">// Output: Hello, World!</span>
</span></span></code></pre></div><table>
<thead>
<tr>
<th>Method</th>
<th>Takes Previous Result?</th>
<th>Returns a Value?</th>
<th>Use Case</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>thenRun</code></td>
<td>❌ No</td>
<td>❌ No (<code>Void</code>)</td>
<td>Just run a task after completion</td>
</tr>
<tr>
<td><code>thenAccept</code></td>
<td>✅ Yes</td>
<td>❌ No (<code>Void</code>)</td>
<td>Consume the result without returning a new one</td>
</tr>
<tr>
<td><code>thenApply</code></td>
<td>✅ Yes</td>
<td>✅ Yes (<code>R</code>)</td>
<td>Transform the result and return a new value</td>
</tr>
</tbody>
</table>
<blockquote>
</blockquote>
<h2 id="java-locks">Java Locks<a hidden class="anchor" aria-hidden="true" href="#java-locks">#</a></h2>
<h3 id="optimistic-lock-vs-pessimistic-lock">Optimistic Lock vs. Pessimistic Lock<a hidden class="anchor" aria-hidden="true" href="#optimistic-lock-vs-pessimistic-lock">#</a></h3>
<blockquote>
<p><strong>Optimistic Lock</strong> assumes minimal contention, allowing multiple threads to read and write data concurrently. Instead of using locks, it relies on <strong>versioning</strong> or <strong>CAS (Compare-And-Swap)</strong> to detect conflicts during updates. If a conflict is detected (i.e., another thread has modified the data), the operation is retried. It is particularly effective in <strong>high-read, low-write</strong> scenarios.</p>
</blockquote>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Use versioning in SQL</button>



<button class="tab_btn ">Use CAS in Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-sql" data-lang="sql" ># Use versioning in SQL
UPDATE products 
SET stock = stock - 1, version = version + 1 
WHERE id = 1 AND version = 5;
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

class Main {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        AtomicInteger count = new AtomicInteger(0);
        int expectedValue, newValue;
        do {
            expectedValue = count.get();
            newValue = expectedValue + 1;
        } while (!count.compareAndSet(expectedValue, newValue));

        System.out.println("Updated Count: " + count.get());
    }
}
</code></pre>
    </div>
</div>


</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<blockquote>
<p><strong>Pessimistic Lock</strong> assumes high contention and prevents concurrent modification by blocking the resource. Other threads must wait until the lock is released. It is suitable for high-write, <strong>low-read</strong> scenerios. In Java, the <code>synchronized</code> and <code>ReentrantLock</code> are implementations of pessimistic lock.</p>
</blockquote>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">synchronized</button>



<button class="tab_btn ">ReentrantLock</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class PessimisticLockExample {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }
}
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >import java.util.concurrent.locks.ReentrantLock;

public class PessimisticLockExample {
    private int count = 0;
    private final ReentrantLock lock = new ReentrantLock();

    public void increment() {
        lock.lock();
        try {
            count++;
        } finally {
            lock.unlock();
        }
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h3 id="synchronized-related-problems"><code>synchronized</code> Related Problems<a hidden class="anchor" aria-hidden="true" href="#synchronized-related-problems">#</a></h3>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Phone {
    public synchronized void sendEmail() {
        System.out.println("send email");
    }

    public synchronized void sendSMS() {
        System.out.println("send SMS");
    }
}

class Main {
    public static void main(String[] args) {
        Phone phone = new Phone();

        new Thread(() -> {
            phone.sendEmail();
        }, "A").start();

        // Ensure thread A starts first
        try {
            TimeUnit.MILLISECONDS.sleep(300);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(() -> {
            phone.sendSMS();
        }, "B").start();
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<blockquote>
<p>The above code first outputs <code>send email</code>, followed by <code>send SMS</code>. This happens because both <code>sendEmail()</code> and <code>sendSMS()</code> are synchronized methods that lock the same object. As a result, the thread that acquires the lock first executes first, while other threads must wait until the lock is released.</p>
</blockquote>
<hr>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Phone {
    public synchronized void sendEmail() {
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("send email");
    }

    public synchronized void sendSMS() {
        System.out.println("send SMS");
    }
}

class Main {
    public static void main(String[] args) {
        Phone phone = new Phone();

        new Thread(() -> {
            phone.sendEmail();
        }, "A").start();

        // Ensure thread A starts first
        try {
            TimeUnit.MILLISECONDS.sleep(300);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(() -> {
            phone.sendSMS();
        }, "B").start();
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<blockquote>
<p>The above code first outputs <code>send email</code>, followed by <code>send SMS</code>. This happens because both <code>sendEmail()</code> and <code>sendSMS()</code> are synchronized methods that lock the same object and executes <code>sleep()</code> method doesn&rsquo;t release a lock. Therefore, the thread that acquires the lock first executes first, while other threads must wait until the lock is released.</p>
</blockquote>
<hr>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Phone {
    public synchronized void sendEmail() {
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("send email");
    }

    public synchronized void sendSMS() {
        System.out.println("send SMS");
    }

    public void hello() {
        System.out.println("hello");
    }
}

class Main {
    public static void main(String[] args) {
        Phone phone = new Phone();

        new Thread(phone::sendEmail, "A").start();

        // Ensure thread A starts first
        try {
            TimeUnit.MILLISECONDS.sleep(300);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(() -> {
            phone.hello();
        }, "B").start();
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<blockquote>
<p>The above code outputs <code>hello</code> immediately, followed by <code>send email</code>. This is because the <code>hello()</code> method is not synchronized and does not require a lock, allowing it to execute without waiting.</p>
</blockquote>
<hr>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.concurrent.TimeUnit;

class Phone {
    public synchronized void sendEmail() {
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("send email");
    }

    public synchronized void sendSMS() {
        System.out.println("send SMS");
    }
}

class Main {
    public static void main(String[] args) {
        Phone phone1 = new Phone();
        Phone phone2 = new Phone();


        new Thread(() -> {
            phone1.sendEmail();
        }, "A").start();

        // Ensure thread A starts first
        try {
            TimeUnit.MILLISECONDS.sleep(300);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(() -> {
            phone2.sendSMS();
        }, "B").start();
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<blockquote>
<p>The above code outputs <code>send SMS</code> first, followed by <code>send email</code>. This happens because the <code>synchronized</code> keyword locks the object instances (<code>phone1</code> and <code>phone2</code>), not the class itself. Since <code>phone1</code> and <code>phone2</code> are different objects, their locks do not interfere with each other.</p>
</blockquote>
<blockquote>
<p>In this case, <code>Thread A</code> starts first and acquires the lock on <code>phone1</code>, but sleep for 3 seconds inside the <code>sendEmail()</code> method. Meanwhile, <code>Thread B</code> starts shortly after and acquires the lock on <code>phone2</code>. Since <code>Thread B</code> does not need to wait for <code>Thread A</code> to release its lock (as they operate on different objects), it executes <code>sendSMS()</code> immediately. As a result, <code>Thread B</code> outputs <code>send SMS</code> first, while <code>Thread A</code> outputs <code>send email</code> after its sleep period ends.</p>
</blockquote>
<hr>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.concurrent.TimeUnit;

class Phone {
    public static synchronized void sendEmail() {
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("send email");
    }

    public static synchronized void sendSMS() {
        System.out.println("send SMS");
    }
}

class Main {
    public static void main(String[] args) {
        Phone phone = new Phone();


        new Thread(() -> {
            phone.sendEmail();
        }, "A").start();

        // Ensure thread A starts first
        try {
            TimeUnit.MILLISECONDS.sleep(300);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(() -> {
            phone.sendSMS();
        }, "B").start();
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<blockquote>
<p>The above code outputs <code>send email</code> first, followed by <code>send SMS</code>. This happens because the <code>static synchronized</code> keyword locks the <code>Phone.class</code> object, not individual instances of the class. Since both methods (<code>sendEmail</code> and <code>send SMS</code>) are <code>static synchronized</code>, they share the same lock on the <code>Phone.class</code> object. As a result, their execution is sequential.</p>
</blockquote>
<hr>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.concurrent.TimeUnit;

class Phone {
    public static synchronized void sendEmail() {
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("send email");
    }

    public static synchronized void sendSMS() {
        System.out.println("send SMS");
    }
}

class Main {
    public static void main(String[] args) {
        Phone phone1 = new Phone();
        Phone phone2 = new Phone();


        new Thread(() -> {
            phone1.sendEmail();
        }, "A").start();

        // Ensure thread A starts first
        try {
            TimeUnit.MILLISECONDS.sleep(300);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(() -> {
            phone2.sendSMS();
        }, "B").start();
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<blockquote>
<p>The above code outputs <code>send email</code> first, followed by <code>send SMS</code>. Even though there are two different objects (<code>phone1</code> and <code>phone2</code>), the <code>static synchronized</code> keyword locks the <code>Phone.class</code> object, not the individual instances. This means that both <code>sendEmail()</code> and <code>sendSMS()</code> share the same lock at the class level, ensuring sequential execution.</p>
</blockquote>
<hr>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.concurrent.TimeUnit;

class Phone {
    public static synchronized void sendEmail() {
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("send email");
    }

    public synchronized void sendSMS() {
        System.out.println("send SMS");
    }
}

class Main {
    public static void main(String[] args) {
        Phone phone = new Phone();


        new Thread(() -> {
            phone.sendEmail();
        }, "A").start();

        // Ensure thread A starts first
        try {
            TimeUnit.MILLISECONDS.sleep(300);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(() -> {
            phone.sendSMS();
        }, "B").start();
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<blockquote>
<p>The above code outputs <code>send SMS</code> first, followed by <code>send email</code>. This happens because the <code>synchronized</code> keyword locks individual object instance, while <code>static synchronized</code> locks the class-level object. In this case, <code>sendSMS()</code> locks the <code>phone</code> object, and <code>sendEmail()</code> locks the <code>Phone.class</code> object. Since these locks are independent, <code>Thread B</code> does not need to wait for <code>Thread A</code> to release its lock. As a result, <code>send SMS</code> is printed first, while <code>send email</code> is printed after the 3-second sleep.</p>
</blockquote>
<hr>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.concurrent.TimeUnit;

class Phone {
    public static synchronized void sendEmail() {
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("send email");
    }

    public static synchronized void sendSMS() {
        System.out.println("send SMS");
    }

    public void hello() {
        System.out.println("hello");
    }

}

class Main {
    public static void main(String[] args) {
        Phone phone1 = new Phone();
        Phone phone2 = new Phone();


        new Thread(() -> {
            phone1.sendEmail();
        }, "A").start();

        // Ensure thread A starts first
        try {
            TimeUnit.MILLISECONDS.sleep(300);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(() -> {
            phone2.hello();
            phone2.sendSMS();
        }, "B").start();
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<blockquote>
<p>The above code outputs <code>hello</code> first, followed by <code>send email</code> and <code>send SMS</code>. This is because <code>sendEmail()</code> and <code>sendSMS()</code> are both <code>static synchronized</code>, meaning they lock the <code>Phone.class</code> object, enforcing sequential execution. In contrast, the <code>hello()</code> method is a regular method that does not require a lock, allowing it to execute immediately.</p>
</blockquote>
<hr>
<h3 id="synchronized-byte-code-analysis"><code>synchronized</code> Byte Code Analysis<a hidden class="anchor" aria-hidden="true" href="#synchronized-byte-code-analysis">#</a></h3>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Source Code</button>



<button class="tab_btn ">Source Code</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Main {
    private final Object mtx = new Object();

    public void f() {
        synchronized (mtx) {
            System.out.println("hello...");
        }
    }
}
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >public void f();
    Code:
       0: aload_0
       1: getfield      #7                  // Field mtx:Ljava/lang/Object;
       4: dup
       5: astore_1
  🌟   6: monitorenter
       7: getstatic     #13                 // Field java/lang/System.out:Ljava/io/PrintStream;
      10: ldc           #19                 // String hello...
      12: invokevirtual #21                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      15: aload_1
  🌟  16: monitorexit
      17: goto          25
      20: astore_2
      21: aload_1
  🌟  22: monitorexit
      23: aload_2
      24: athrow
      25: return
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<blockquote>
<p>From the above bytecode, the <code>synchronized</code> block translates into <code>monitorenter</code> and <code>monitorexit</code> instructions. The lock is acquired before entering the block and released before exiting. The second <code>monitorexit</code> ensures that the lock is properly released if an exception occurs, as shown in the following code:</p>
</blockquote>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Source Code</button>



<button class="tab_btn ">Byte Code</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Main {
    private final Object mtx = new Object();

    public void f() {
        synchronized (mtx) {
            System.out.println("hello...");
            throw new RuntimeException("Exception occurred");
        }
    }
}
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >  public void f();
    Code:
       0: aload_0
       1: getfield      #7                  // Field mtx:Ljava/lang/Object;
       4: dup
       5: astore_1
   🌟  6: monitorenter
       7: getstatic     #13                 // Field java/lang/System.out:Ljava/io/PrintStream;
      10: ldc           #19                 // String hello...
      12: invokevirtual #21                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      15: new           #27                 // class java/lang/RuntimeException
      18: dup
      19: ldc           #29                 // String Exception occurred
      21: invokespecial #31                 // Method java/lang/RuntimeException."&lt;init&gt;":(Ljava/lang/String;)V
      24: athrow
      25: astore_2
      26: aload_1
   🌟 27: monitorexit
      28: aload_2
      29: athrow
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Source Code</button>



<button class="tab_btn ">Byte Code</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Main {
    public synchronized void f() {
        System.out.println("hello...");
    }

    public static synchronized void m() {
        System.out.println("HELLO...");
    }
}
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >public synchronized void f();
    descriptor: ()V
    flags: (0x0021) ACC_PUBLIC, 🌟ACC_SYNCHRONIZED🌟
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #13                 // String hello...
         5: invokevirtual #15                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: return
      LineNumberTable:
        line 3: 0
        line 4: 8

public static synchronized void m();
    descriptor: ()V
    flags: (0x0029) ACC_PUBLIC, 🌟ACC_STATIC, ACC_SYNCHRONIZED🌟
    Code:
      stack=2, locals=0, args_size=0
         0: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #21                 // String HELLO...
         5: invokevirtual #15                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: return
      LineNumberTable:
        line 7: 0
        line 8: 8
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<blockquote>
<p>From the above bytecode, the JVM checks if the <code>ACC_SYNCHRONIZED</code> flag is set. If the flag is present, the thread acquires the appropriate monitor lock before executing the method. For instance methods, the lock is acquired on the object instance (<code>this</code>), while for static methods, the lock is acquired on the class object (e.g., <code>Main.class</code>). After the method completes execution, the thread releases the lock. The <code>ACC_STATIC</code> flag is used to determine whether the method is static, which in turn determines whether the lock is applied at the class level or the instance level.</p>
</blockquote>
<hr>
<blockquote>
<p>Why any object in Java can be a lock?</p>
</blockquote>
<blockquote>
<p>Any object in Java can be a lock because every object has an intrinsic monitor lock managed by the JVM. The <code>ObjectMonitor</code> structure is part of the JVM&rsquo;s implementation of this mechanism, tracking details like the lock owner, EntryList, etc. For example, when a thread calls <code>synchronized(obj)</code>, the JVM checks the <code>ObjectMonitor</code> associated with <code>obj</code>. If the lock is available, the thread acquires it and sets itself as the <code>owner</code>. If the lock is held by another thread, the current thread waits in the <code>EntryList</code>. When the lock is released, the JVM wakes up a waiting thread (if any) to acquire the lock.</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>ObjectMonitor() {
</span></span><span style="display:flex;"><span>    _header <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    _count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    _waiters <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    _recursions <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    _object <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    _owner <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    _MailSet <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    _MailSetLock <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    _Responsible <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    _succ <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    _cxq <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    FreeNext <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    _EntryList <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>    _SpinFreq <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    _SpinClock <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    OwnerIsThread <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    _previous_owner_tid <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="fair-lock-vs-unfair-lock">Fair Lock vs. Unfair Lock<a hidden class="anchor" aria-hidden="true" href="#fair-lock-vs-unfair-lock">#</a></h3>
<blockquote>
<p>In Java, locks can be calssified into <strong>fair locks</strong> and <strong>unfair locks</strong> based on their approach to thread scheduling. A <strong>fair lock</strong> ensures that threads acquire the lock in the exact order they requested it, following a first-come, first-served priciple. While this prevents <em>thread starvation</em>, it incurs additional overhead to maintain the order of threads. On the other hand, an <strong>unfair lock</strong> does not guarantee any specific order for thread access. A thread can acquire the lock even if it arrived later than others. This eliminates the need to maintain a strict order, improving efficiency, but it may result in thread starvation, where some threads could wait indefinitely for access.</p>
</blockquote>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.concurrent.locks.ReentrantLock;

public class Main {
    private static final ReentrantLock unfairLock = new ReentrantLock(); // Unfair lock
    private static final ReentrantLock fairLock = new ReentrantLock(true); // Fair lock

    public static void main(String[] args) {
        System.out.print("Testing Unfair Lock: ");
        testLock(unfairLock);

        System.out.print("Testing Fair Lock: ");
        testLock(fairLock);
    }

    private static void testLock(ReentrantLock lock) {
        long startTime = System.currentTimeMillis();
        Runnable task = () -> {
            for (int i = 0; i < 10000; i++) {
                lock.lock();
                try {
                    // Simulate work
                } finally {
                    lock.unlock();
                }
            }
        };

        Thread[] threads = new Thread[10];
        for (int i = 0; i < threads.length; i++) {
            threads[i] = new Thread(task);
            threads[i].start();
        }

        for (Thread thread : threads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        long endTime = System.currentTimeMillis();
        System.out.println("Time taken: " + (endTime - startTime) + " ms");
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW OUTPUT</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Output</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-bash" data-lang="bash" >Testing Unfair Lock: Time taken: 11 ms
Testing Fair Lock: Time taken: 560 ms
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h3 id="recursive-lock">Recursive Lock<a hidden class="anchor" aria-hidden="true" href="#recursive-lock">#</a></h3>
<blockquote>
<p>A <strong>recursive lock</strong> in Java allows a thread to acquire the same lock multiple times without causing a deadlock. It is particularly useful in scenarios where a thread holding a lock calls another method or enters a synchronized block that requires the same lock. By default, the <code>synchronized</code> keyword and <code>ReentrantLock</code> class support recursive locking mechanism.</p>
</blockquote>
<blockquote>
<p>The recursive lock maintains a <strong>hold count</strong>, which tracks how many times a thread has acquired the lock. Each time the thread acquires the lock, the hold count is incremented, and it is decremented when the lock is released. The lock is fully released only when the <strong>hold count</strong> reaches zero.</p>
</blockquote>
<blockquote>
<p>Under the hood, when the <code>monitorenter</code> command is executed, the JVM checks the <code>MonitorObject</code>&rsquo;s <code>_count</code> field. If <code>_count</code> is zero, it means the lock is not held by any other thread. In this case, the JVM sets the <code>_owner</code> field to the current thread and increments the <code>_count</code>. If <code>_count</code> is not zero and the <code>_owner</code> is the current thread, the JVM increments the <code>_count</code> (indicating reentrancy). Otherwise, if the lock is held by another thread, the current thread must wait until the lock is released (i.e., <code>_count</code> reaches zero).</p>
</blockquote>
<blockquote>
<p>When the <code>monitorexit</code> command is executed, the JVM decrements the <code>_count</code>. Once <code>_count</code> reaches zero, the lock is considered fully released, and the <code>_owner</code> field is cleared, allowing other threads to acquire the lock.</p>
</blockquote>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.concurrent.locks.ReentrantLock;

public class Main {
    private static final ReentrantLock lock = new ReentrantLock();

    public static void main(String[] args) {
        recursiveMethod(3);
    }

    public static void recursiveMethod(int count) {
        lock.lock(); // Acquire the lock
        try {
            System.out.println(Thread.currentThread().getName() + " acquired the lock. Hold count: " + lock.getHoldCount());
            if (count > 0) {
                recursiveMethod(count - 1); // Recursive call
            }
        } finally {
            lock.unlock(); // Release the lock
            System.out.println(Thread.currentThread().getName() + " released the lock. Hold count: " + lock.getHoldCount());
        }
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW OUTPUT</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Output</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-bash" data-lang="bash" >main acquired the lock. Hold count: 1
main acquired the lock. Hold count: 2
main acquired the lock. Hold count: 3
main acquired the lock. Hold count: 4
main released the lock. Hold count: 3
main released the lock. Hold count: 2
main released the lock. Hold count: 1
main released the lock. Hold count: 0
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h3 id="deadlock">Deadlock<a hidden class="anchor" aria-hidden="true" href="#deadlock">#</a></h3>
<blockquote>
<p>A <strong>deadlock</strong> is a situation where two or more threads are permanently blcoked, each waiting for a resource held by another, preventing further progress. For a deadlock to occur, four conditions must be met simultaneously: <strong>mutual exclusion</strong>, <strong>hold and wait</strong>, <strong>no preemption</strong>, and <strong>circular wait</strong>.</p>
</blockquote>
<ul>
<li><strong>Mutual Exclusion</strong>: A resource must be non-sharable, meaning only one thread can use it at a time.</li>
<li><strong>Hold and Wait</strong>: A thread holding at least one resource must be waiting to acquire additional resources held by other threads.</li>
<li><strong>No Preemption</strong>: Resources cannot be forcibly taken from a thread; they must be released voluntarily.</li>
<li><strong>Circular Wait</strong>: A circular chain of two or more threads must exist, where each thread is waiting for a resource held by the next in the chain.</li>
</ul>
<blockquote>
<p>To detect a deadlock in Java, use the <code>jps</code> command to get the process ID, then run <code>jstack process_id</code> to analyze thread states and identify deadlocks.</p>
</blockquote>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Deadlock</button>



<button class="tab_btn ">Detecting a Deadlock</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >public class Main {
    private static final Object lock1 = new Object();
    private static final Object lock2 = new Object();

    public static void main(String[] args) {
        Thread thread1 = new Thread(() -> {
            synchronized (lock1) {
                System.out.println("Thread 1: Holding lock 1...");
                try {
                    Thread.sleep(100); // Simulate work
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("Thread 1: Waiting for lock 2...");
                synchronized (lock2) {
                    System.out.println("Thread 1: Acquired lock 2!");
                }
            }
        });

        Thread thread2 = new Thread(() -> {
            synchronized (lock2) {
                System.out.println("Thread 2: Holding lock 2...");
                try {
                    Thread.sleep(100); // Simulate work
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("Thread 2: Waiting for lock 1...");
                synchronized (lock1) {
                    System.out.println("Thread 2: Acquired lock 1!");
                }
            }
        });

        thread1.start();
        thread2.start();
    }
}
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-bash" data-lang="bash" >$ jps
76995 Launcher
76996 Main
77127 Jps
2327 Main

--------------

$ jstack 76996
"Thread-0":
        at dev.signalyu.warmup.Main.lambda$main$0(Main.java:18)
    🌟  - waiting to lock <0x000000070ffce280> (a java.lang.Object)
    🌟  - locked <0x000000070ffce270> (a java.lang.Object)
        at dev.signalyu.warmup.Main$$Lambda$14/0x000000012d001208.run(Unknown Source)
        at java.lang.Thread.run(java.base@17.0.9/Thread.java:842)
"Thread-1":
        at dev.signalyu.warmup.Main.lambda$main$1(Main.java:33)
    🌟   - waiting to lock <0x000000070ffce270> (a java.lang.Object)
    🌟   - locked <0x000000070ffce280> (a java.lang.Object)
        at dev.signalyu.warmup.Main$$Lambda$15/0x000000012d001428.run(Unknown Source)
        at java.lang.Thread.run(java.base@17.0.9/Thread.java:842)

Found 1 deadlock.  🌟
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="thread-interruption">Thread Interruption<a hidden class="anchor" aria-hidden="true" href="#thread-interruption">#</a></h2>
<blockquote>
<p>In Java, thread interruption is a mechanism that allows one thread to signal another to stop its execution. The three common approaches to interrupt a thread are using a <code>volatile</code> flag, an <code>AtomicBoolean</code>, or the <code>interrupt()</code> method.</p>
</blockquote>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">volatile</button>



<button class="tab_btn ">AtomicBoolean</button>



<button class="tab_btn ">interrupt()</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.concurrent.TimeUnit;

public class Main {
    private static volatile boolean isStop = false;

    public static void main(String[] args) {
        new Thread(() -> {
            while (!isStop) {
                try {
                    TimeUnit.MILLISECONDS.sleep(500);
                    System.out.println("isStop: " + isStop);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
            System.out.println("isStop --> " + isStop);
        }, "t1").start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // Signal threads to stop
        new Thread(() -> {
            isStop = true;
        }, "t2").start();
    }
}
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

public class Main {
    private static final AtomicBoolean atomicBoolean = new AtomicBoolean(false);

    public static void main(String[] args) {
        new Thread(() -> {
            while (!atomicBoolean.get()) {
                try {
                    TimeUnit.MILLISECONDS.sleep(500);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                System.out.println("Atomic Boolean: " + atomicBoolean);
            }
            System.out.println("Atomic Boolean --> " + atomicBoolean);
        }, "t1").start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // Signal threads to stop
        new Thread(() -> {
            atomicBoolean.set(true);
        }, "t2").start();
    }
}
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >public class Main {
    private static volatile boolean isStop = false;

    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            while (!Thread.currentThread().isInterrupted()) {
                System.out.println("Is interrupted: " + Thread.currentThread().isInterrupted());
            }
            System.out.println("Is interrupted --> " + Thread.currentThread().isInterrupted());
        }, "t1");
        t1.start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // Signal threads to stop
        new Thread(() -> {
            t1.interrupt();
        }, "t2").start();
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW OUTPUT</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">volatile</button>



<button class="tab_btn ">AtomicBoolean</button>



<button class="tab_btn ">interrupt()</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-bash" data-lang="bash" >isStop: false
isStop: true
isStop --> true
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-bash" data-lang="bash" >Atomic Boolean: false
Atomic Boolean: true
Atomic Boolean --> true
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-bash" data-lang="bash" >......
Is interrupted: false
Is interrupted: false
Is interrupted: false
Is interrupted --> true
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<blockquote>
<p>The common methods for managing thread interruption in Java include <code>interrupt()</code>, <code>interrupted()</code>, and <code>isInterrupted()</code>:</p>
</blockquote>
<ul>
<li><strong><code>interrupt()</code></strong>: An instance method that sets the thread&rsquo;s interrupted status to <code>true</code>. <strong>It does not forcibly stop the thread.</strong> If the thread is blocked (e.g., in <code>sleep()</code>, <code>wait()</code>, or <code>join()</code>), it throws an <code>InterruptedException</code>.</li>
<li><strong><code>interrupted()</code></strong>: A static method that checks if the current thread has been interrupted. If it has, the method <strong>resets</strong> the interrupted status to <code>false</code>.</li>
<li><strong><code>isInterrupted()</code></strong>: An instance method that checks if the thread has been interrupted <strong>without resetting</strong> its interrupted status.</li>
</ul>
<hr>
<blockquote>
<p><strong>What&rsquo;s the following code output?</strong></p>
</blockquote>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE (Wrong Interruption)</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.concurrent.TimeUnit;

public class Main {
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            while (true) {
                if (Thread.currentThread().isInterrupted()) {
                    System.out.println("isInterrupted --> true");
                    break;
                }
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("INTERRUPTED...");
            }
        }, "t1");
        t1.start();

        try {
            TimeUnit.SECONDS.sleep(3); // Sleep 3 seconds
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(() -> {
            t1.interrupt(); // Set interrupted status of thread 't1' to true
        }, "t2").start();
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW OUTPUT (Wrong Interruption)</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Output</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-bash" data-lang="bash" >INTERRUPTED...
INTERRUPTED...
java.lang.InterruptedException: sleep interrupted
	at java.base/java.lang.Thread.sleep(Native Method)
	at dev.signalyu.warmup.Main.lambda$main$0(Main.java:14)
	at java.base/java.lang.Thread.run(Thread.java:842)
INTERRUPTED...
INTERRUPTED...
......
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<blockquote>
<p><em><strong>When a thread is interrupted while blocked, the blocking method throws an <code>InterruptedException</code> and clears the interrupted status.</strong></em></p>
</blockquote>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE (Correct Interruption)</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.concurrent.TimeUnit;

public class Main {
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            while (true) {
                if (Thread.currentThread().isInterrupted()) {
                    System.out.println("isInterrupted --> true");
                    break;
                }
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt(); // 🌟🌟🌟 Restore its interrupted status 🌟🌟🌟
                    e.printStackTrace();
                }
                System.out.println("INTERRUPTED...");
            }
        }, "t1");
        t1.start();

        try {
            TimeUnit.SECONDS.sleep(3); // Sleep 3 seconds
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(() -> {
            t1.interrupt(); // Set interrupted status of thread 't1' to true
        }, "t2").start();
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW OUTPUT (Correct Interruption)</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Output</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-bash" data-lang="bash" >INTERRUPTED...
INTERRUPTED...
java.lang.InterruptedException: sleep interrupted
	at java.base/java.lang.Thread.sleep(Native Method)
	at dev.signalyu.warmup.Main.lambda$main$0(Main.java:14)
	at java.base/java.lang.Thread.run(Thread.java:842)
INTERRUPTED...
isInterrupted --> true
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<blockquote>
<p>After restoring the thread&rsquo;s interrupted status by adding <code>Thread.currentThread().interrupt();</code>, it exits the while loop gracefully.</p>
</blockquote>
<hr>
<h2 id="locksupport">LockSupport<a hidden class="anchor" aria-hidden="true" href="#locksupport">#</a></h2>
<h3 id="waitnofity-related-problems">wait()/nofity() related problems<a hidden class="anchor" aria-hidden="true" href="#waitnofity-related-problems">#</a></h3>
<blockquote>
<p>There are two common issues when using <code>wait()</code> and <code>notify()</code> in Java:</p>
</blockquote>
<ul>
<li><strong>Synchronization Requirement</strong>: <strong>Both <code>wait()</code> and <code>notify()</code> must be called within a synchronized block or method.</strong> This is because these methods rely on the object&rsquo;s intrinsic lock (monitor). If they are called outside a synchronized context, the program will throw an <code>IllegalMonitorStateException</code>.</li>
<li><strong>Missed Notifications</strong>: If <code>notify()</code> is called before <code>wait()</code>, the notification will be missed, and the thread calling <code>wait()</code> may block indefinitely. This happens because <code>notify()</code> does not have any effect if no thread is currently waiting on the object&rsquo;s monitor.</li>
</ul>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Synchronization Requirement</button>



<button class="tab_btn ">Missed Notifications</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >public class Main {
    private static final Object lock = new Object();

    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
//            synchronized (lock) {
                try {
                    System.out.println("Thread 1 is waiting...");
                    lock.wait(); // Thread 1 waits
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("Thread 1 is resumed.");
//            }
        });

        Thread t2 = new Thread(() -> {
//            synchronized (lock) {
                System.out.println("Thread 2 is notifying...");
                lock.notify(); // Thread 2 notifies
//            }
        });

        t1.start();
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        t2.start();
    }
}
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >public class Main {
    private static final Object lock = new Object();

    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            // Acquire the lock after 1 second, notify() executes first
            synchronized (lock) {
                try {
                    System.out.println("Thread 1 is waiting...");
                    lock.wait(); // Thread 1 waits
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("Thread 1 is resumed.");
            }
        });

        Thread t2 = new Thread(() -> {
            synchronized (lock) {
                System.out.println("Thread 2 is notifying...");
                lock.notify(); // Thread 2 notifies
            }
        });

        t1.start();
        t2.start();
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW OUTPUT</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Synchronization Requirement</button>



<button class="tab_btn ">Missed Notifications</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-bash" data-lang="bash" >Thread 1 is waiting...
Exception in thread "Thread-0" java.lang.IllegalMonitorStateException: current thread is not owner
	at java.base/java.lang.Object.wait(Native Method)
	at java.base/java.lang.Object.wait(Object.java:338)
	at dev.signalyu.warmup.Main.lambda$main$0(Main.java:11)
	at java.base/java.lang.Thread.run(Thread.java:842)
Thread 2 is notifying...
Exception in thread "Thread-1" java.lang.IllegalMonitorStateException: current thread is not owner
	at java.base/java.lang.Object.notify(Native Method)
	at dev.signalyu.warmup.Main.lambda$main$1(Main.java:22)
	at java.base/java.lang.Thread.run(Thread.java:842)
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-bash" data-lang="bash" >Thread 2 is notifying...
Thread 1 is waiting...
// WAIT INDEFINITELY
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h3 id="awaitsignal-related-problems">await()/signal() related problems<a hidden class="anchor" aria-hidden="true" href="#awaitsignal-related-problems">#</a></h3>
<blockquote>
<p>Similar to <code>wait()/notify()</code>, when using <code>await()/signal()</code> from the <code>Condition</code> interface, the thread <strong>must hold the associated lock</strong>. If the lock is not held, the program will throw an <code>IllegalMonitorStateException</code>. Additionally, if <code>signal()</code> is called before <code>await()</code>, the notification will be missed, and the thread calling <code>await()</code> may wait indefinitely. To avoid this, always use a loop to recheck the condition after waking up from <code>await()</code>. This ensures that thread only proceeds when the condition is truly met, even if a spurious wakeup occurs or notification is missed.</p>
</blockquote>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Synchronization Requirement</button>



<button class="tab_btn ">Missed Notifications</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class Main {
    private static final ReentrantLock lock = new ReentrantLock();
    private static final Condition condition = lock.newCondition();

    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
//            lock.lock();
            try {
                System.out.println("Thread 1 is waiting...");
                condition.await(); // Thread 1 waits
                System.out.println("Thread 1 is resumed.");
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
//                lock.unlock();
            }
        });

        Thread t2 = new Thread(() -> {
//            lock.lock();
            try {
                System.out.println("Thread 2 is signaling...");
                condition.signal(); // Thread 2 signals
            } finally {
//                lock.unlock();
            }
        });

        t1.start();
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        t2.start();
    }
}
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class Main {
    private static final ReentrantLock lock = new ReentrantLock();
    private static final Condition condition = lock.newCondition();

    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            // Acquire the lock after 1 second, signal() executes first
            lock.lock();
            try {
                System.out.println("Thread 1 is waiting...");
                condition.await(); // Thread 1 waits
                System.out.println("Thread 1 is resumed.");
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        });

        Thread t2 = new Thread(() -> {
            lock.lock();
            try {
                System.out.println("Thread 2 is signaling...");
                condition.signal(); // Thread 2 signals
            } finally {
                lock.unlock();
            }
        });

        t1.start();
        t2.start();
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW OUTPUT</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Synchronization Requirement</button>



<button class="tab_btn ">Missed Notifications</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-bash" data-lang="bash" >Thread 1 is waiting...
Exception in thread "Thread-0" java.lang.IllegalMonitorStateException
	at java.base/java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.enableWait(AbstractQueuedSynchronizer.java:1516)
	at java.base/java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1611)
	at dev.signalyu.warmup.Main.lambda$main$0(Main.java:15)
	at java.base/java.lang.Thread.run(Thread.java:842)
Thread 2 is signaling...
Exception in thread "Thread-1" java.lang.IllegalMonitorStateException
	at java.base/java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.signal(AbstractQueuedSynchronizer.java:1473)
	at dev.signalyu.warmup.Main.lambda$main$1(Main.java:28)
	at java.base/java.lang.Thread.run(Thread.java:842)
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-bash" data-lang="bash" >Thread 2 is signaling...
Thread 1 is waiting...
// WAIT INDEFINITELY
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h3 id="locksupport-parkunparkthread">LockSupport: park()/unpark(Thread)<a hidden class="anchor" aria-hidden="true" href="#locksupport-parkunparkthread">#</a></h3>
<blockquote>
<p><strong>LockSupport</strong> is a utility class in Java that provides a low-level mechanism for thread synchronization. Unlike <code>synchronized</code> blocks or explicit <code>Lock</code> objects, <code>LockSupport</code> does not require explicit locking and unblocking. Instead, it operates using a <strong>permit mechanism</strong>, which makes it more flexible and lightweight. The most commonly used methods in <code>LockSupport</code> are <code>park()</code> and <code>unpark(Thread)</code>. The <code>park()</code> method blocks the current thread if the permit is unavailable, while the <code>unpark(Thread)</code> method makes the permit available for a specific thread, unblocking if it was parked.</p>
</blockquote>
<blockquote>
<p>The key points about <code>LockSupport</code> include:</p>
</blockquote>
<ol>
<li>The <strong>permit</strong> is a binary semaphore, meaning it can either be available or unavailable. If a permit is available when <code>park()</code> is called, the thread continues execution without blocking. If no permit is available, the thread blocks until one is made available via <code>unpark()</code>.</li>
<li>Unlike <code>synchronized</code> and <code>Lock</code>, <code>LockSupport</code> does not suffer from <strong>spurious wakeups</strong>. This means that a thread will only unblock when explicitly unparked, providing more predictable behavior compared to <code>wait()/notify()</code> or <code>await()/signal()</code>.</li>
<li>The <code>unpark(Thread)</code> method targets a specific thread, making it more precise than <code>notify()</code> or <code>signal()</code>, which wake up any waiting thread.</li>
</ol>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">park()/unpark(Thread)</button>



<button class="tab_btn ">wait()/notify()</button>



<button class="tab_btn ">await()/signal()</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.concurrent.locks.LockSupport;

public class Main {
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            System.out.println("Thread 1 is parking...");
            LockSupport.park(); // Thread 1 parks
            System.out.println("Thread 1 is unparked.");
        });

        Thread t2 = new Thread(() -> {
            System.out.println("Thread 2 is unparking Thread 1...");
            LockSupport.unpark(t1); // Thread 2 unparks Thread 1
        });

        t1.start();
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        t2.start();
    }
}
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >public class Main {
    private static final Object lock = new Object();

    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            synchronized (lock) {
                try {
                    System.out.println("Thread 1 is waiting...");
                    lock.wait(); // Thread 1 waits
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("Thread 1 is resumed.");
            }
        });

        Thread t2 = new Thread(() -> {
            synchronized (lock) {
                System.out.println("Thread 2 is notifying...");
                lock.notify(); // Thread 2 notifies
            }
        });

        t1.start();
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        t2.start();
    }
}
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

public class Main {
    private static final ReentrantLock lock = new ReentrantLock();
    private static final Condition condition = lock.newCondition();

    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            lock.lock();
            try {
                System.out.println("Thread 1 is waiting...");
                condition.await(); // Thread 1 waits
                System.out.println("Thread 1 is resumed.");
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        });

        Thread t2 = new Thread(() -> {
            lock.lock();
            try {
                System.out.println("Thread 2 is signaling...");
                condition.signal(); // Thread 2 signals
            } finally {
                lock.unlock();
            }
        });

        t1.start();
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        t2.start();
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW OUTPUT</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">park()/unpark(Thread)</button>



<button class="tab_btn ">wait()/notify()</button>



<button class="tab_btn ">await()/signal()</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-bash" data-lang="bash" >Thread 1 is parking...
Thread 2 is unparking Thread 1...
Thread 1 is unparked.
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-bash" data-lang="bash" >Thread 1 is waiting...
Thread 2 is notifying...
Thread 1 is resumed.
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-bash" data-lang="bash" >Thread 1 is waiting...
Thread 2 is signaling...
Thread 1 is resumed.
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="java-memory-model">Java Memory Model<a hidden class="anchor" aria-hidden="true" href="#java-memory-model">#</a></h2>
<blockquote>
<p>The <strong>Java Memory Model (JMM)</strong> is a specification that governs how threads interact with memory in a <strong>multi-threaded environment</strong>. It establishes rules that determine how and when change made by one thread to shared variables become visible to other threads, ensuring consistency and predictability in concurrent execution.</p>
</blockquote>
<blockquote>
<p>JMM classifies memory into two types: <strong>Main Memory</strong> and <strong>Working Memory</strong>. <strong>Main Memory</strong> is the central storage where all variables, including instance fields, static fields, and array elements, reside. <strong>Working Memory</strong>, on the other hand, is a thread&rsquo;s local memory that holds copies of variables it accesses. Threads do not interact with main memory directly; instead, they load variables into their working memory and write back updates when necessary. <img loading="lazy" src="/img/multithreading-and-concurrency/12-java-memory-model.png" alt="Java Memory Model"  />
</p>
</blockquote>
<blockquote>
<p>A fundamental concept in JMM is the <strong>happens-before</strong> relationship, which defines the order of operations between threads to maintain memory consistency. If one action <strong>happens-before</strong> another, the effects of the first action are guaranteed to be visible to the second. Examples include:</p>
</blockquote>
<ul>
<li>A write to a <code>volatile</code> variable happens-before every subsequent read of that variable.</li>
<li>Unlocking a monitor happens-before the next lock on the same monitor.</li>
</ul>
<blockquote>
<p>The <strong>key characteristics</strong> of JMM include <strong>Atomicity</strong>, <strong>Visibility</strong>, and <strong>Ordering</strong>.</p>
</blockquote>
<ul>
<li><strong>Atomicity</strong>: Certain operations, such as reads and writes to <code>volatile</code> variables, are <strong>atomic</strong>, meaning they execute as indivisible units.</li>
<li><strong>Visibility</strong>: Changes made by one thread to shared variables are guaranteed to be seen by other threads under proper synchronization mechanisms.</li>
<li><strong>Ordering</strong>: JMM defines strict rules for instruction <strong>ordering</strong>, but without synchronization, the JVM may reorder instructions for optimization, potentially causing unpredictable behavior in a multi-threaded environment.</li>
</ul>
<hr>
<h3 id="happens-before">happens-before<a hidden class="anchor" aria-hidden="true" href="#happens-before">#</a></h3>
<blockquote>
<p>The <strong>happens-before</strong> relationship in the <strong>Java Memory Model (JMM)</strong> establishes rules that dictate the <strong>ordering</strong> and <strong>visibility</strong> of actions in multithreaded programs. It ensures that certain operations performed in one thread become <strong>predictably visible</strong> to another, preventing issues like instruction reordering and inconsistent data access. Below are the eight key priciples of the happens-before relationship:</p>
</blockquote>
<ol>
<li><strong>Program Order Rule</strong>: Within a <strong>single thread</strong>, actions occur in <strong>program order</strong>. For example, earlier statements happen-before later ones.</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> 10;  <span style="color:#75715e">// Happens-before</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> a <span style="color:#f92672">+</span> 5; <span style="color:#75715e">// This sees the updated value of `a`</span>
</span></span></code></pre></div><ol start="2">
<li><strong>Monitor Lock Rule</strong>: An unlock (<code>unlock()</code>) on a monitor lock happens-before any subsequent lock (<code>lock()</code>) on the same monitor.</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">synchronized</span> (lock) {
</span></span><span style="display:flex;"><span>    sharedVar <span style="color:#f92672">=</span> 10; <span style="color:#75715e">// Happens-before the next lock</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">synchronized</span> (lock) {
</span></span><span style="display:flex;"><span>    System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(sharedVar); <span style="color:#75715e">// Guaranteed to see updated value</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="3">
<li><strong>Volatile Variable Rule</strong>: A write to a <code>volatile</code> variable happens-before any subsequent read of that same variable.</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">boolean</span> flag <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>flag <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;  <span style="color:#75715e">// Happens-before the next read</span>
</span></span><span style="display:flex;"><span>System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(flag);  <span style="color:#75715e">// Guaranteed to see true</span>
</span></span></code></pre></div><ol start="4">
<li><strong>Thread Start Rule</strong>: A call to <code>Thread.start()</code> on a new thread happens-before any actions in that thread.</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Thread t <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread(() <span style="color:#f92672">-&gt;</span> System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Running&#34;</span>));
</span></span><span style="display:flex;"><span>t.<span style="color:#a6e22e">start</span>(); <span style="color:#75715e">// Happens-before the thread executes the print statement</span>
</span></span></code></pre></div><ol start="5">
<li><strong>Thread Termination Rule</strong>: All actions in a thread happen-before other threads detecting its termination. In other words, after a thread terminates, all its actions are visible to the thread that joins it.</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Thread t <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread(() <span style="color:#f92672">-&gt;</span> counter <span style="color:#f92672">=</span> 100);
</span></span><span style="display:flex;"><span>t.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>t.<span style="color:#a6e22e">join</span>(); <span style="color:#75715e">// Ensures all writes in t happen-before main thread continues</span>
</span></span><span style="display:flex;"><span>System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(counter); <span style="color:#75715e">// Guaranteed to see 100</span>
</span></span></code></pre></div><ol start="6">
<li>A call to <code>Thread.interrupt()</code> happens-before the interrupted thread detects the interruption via <code>isInterrupted()</code> or <code>InterruptedException</code>.</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Thread t <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread(() <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>Thread.<span style="color:#a6e22e">currentThread</span>().<span style="color:#a6e22e">isInterrupted</span>()) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Looping until interrupted</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>t.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>t.<span style="color:#a6e22e">interrupt</span>(); <span style="color:#75715e">// Happens-before the thread detects the interruption</span>
</span></span></code></pre></div><ol start="7">
<li><strong>Final Field Rule</strong>: Writes to <code>final</code> fields in a constructor happen-before the object is seen by any other thread.</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Example</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> x;
</span></span><span style="display:flex;"><span>    Example() {
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">=</span> 42; <span style="color:#75715e">// Happens-before any other thread sees this object</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol start="8">
<li>If action A happens-before action B, and action B happens-before action C, then action A happens-before action C.</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>a <span style="color:#f92672">=</span> 1;  <span style="color:#75715e">// A happens-before B (write to volatile)</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> a;  <span style="color:#75715e">// B happens-before C (read from volatile)</span>
</span></span></code></pre></div><h2 id="volatile">volatile<a hidden class="anchor" aria-hidden="true" href="#volatile">#</a></h2>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://signalyu.github.io/tags/engineering--technology/">Engineering &amp; Technology</a></li>
      <li><a href="https://signalyu.github.io/tags/computer-science/">Computer Science</a></li>
      <li><a href="https://signalyu.github.io/tags/multithreading--concurrency/">Multithreading &amp; Concurrency</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/database/2-database-management-system/">
    <span class="title">« PREV</span>
    
    <br>
    <span>Database Management Systems</span>
  </a>
  <a class="next" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/system-design/1-system-design/">
    <span class="title">NEXT »</span>
    
    <br>
    <span>System Design</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://signalyu.github.io/">Signal&#39;s Blog</a></span> · 
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>

</body>
</html>
