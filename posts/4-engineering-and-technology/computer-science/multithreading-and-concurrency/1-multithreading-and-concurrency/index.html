<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Multithreading &amp; Concurrency | Signal&#39;s Blog</title>
<meta name="keywords" content="Engineering &amp; Technology, Computer Science, Multithreading &amp; Concurrency">
<meta name="description" content="Introduction to Multithreading Program, Process, and Thread A program is a static set of instructions that stores on a disk. A process is an instance of a program that is currently being executed by the operating system. A thread is a small unit of process that can be scheduled and executed by the operating system. In simpler terms, a program is the code, a process is the excution of the code, a thread is a unit of execution within a process.">
<meta name="author" content="Signal Yu">
<link rel="canonical" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/multithreading-and-concurrency/1-multithreading-and-concurrency/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5a0ace7f2dc73037e40ceea0eb0d119b5d798dba2da38d9129982a8cf9fa07a5.css" integrity="sha256-WgrOfy3HMDfkDO6g6w0Rm115jboto42RKZgqjPn6B6U=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://signalyu.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://signalyu.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://signalyu.github.io/favicon-32x32">
<link rel="apple-touch-icon" href="https://signalyu.github.io/apple-touch-icon">
<link rel="mask-icon" href="https://signalyu.github.io/favicon.io">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/multithreading-and-concurrency/1-multithreading-and-concurrency/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css"
    integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"
    integrity="sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd"
    crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js"
    integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk"
    crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: true }
            ],
            
            throwOnError: false,
            strict: false
        });
    });
</script>

  

<meta property="og:title" content="Multithreading &amp; Concurrency" />
<meta property="og:description" content="Introduction to Multithreading Program, Process, and Thread A program is a static set of instructions that stores on a disk. A process is an instance of a program that is currently being executed by the operating system. A thread is a small unit of process that can be scheduled and executed by the operating system. In simpler terms, a program is the code, a process is the excution of the code, a thread is a unit of execution within a process." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/multithreading-and-concurrency/1-multithreading-and-concurrency/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-12-11T12:13:32+08:00" />
<meta property="article:modified_time" content="2024-12-11T12:13:32+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Multithreading &amp; Concurrency"/>
<meta name="twitter:description" content="Introduction to Multithreading Program, Process, and Thread A program is a static set of instructions that stores on a disk. A process is an instance of a program that is currently being executed by the operating system. A thread is a small unit of process that can be scheduled and executed by the operating system. In simpler terms, a program is the code, a process is the excution of the code, a thread is a unit of execution within a process."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://signalyu.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Multithreading \u0026 Concurrency",
      "item": "https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/multithreading-and-concurrency/1-multithreading-and-concurrency/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Multithreading \u0026 Concurrency",
  "name": "Multithreading \u0026 Concurrency",
  "description": "Introduction to Multithreading Program, Process, and Thread A program is a static set of instructions that stores on a disk. A process is an instance of a program that is currently being executed by the operating system. A thread is a small unit of process that can be scheduled and executed by the operating system. In simpler terms, a program is the code, a process is the excution of the code, a thread is a unit of execution within a process.",
  "keywords": [
    "Engineering \u0026 Technology", "Computer Science", "Multithreading \u0026 Concurrency"
  ],
  "articleBody": "Introduction to Multithreading Program, Process, and Thread A program is a static set of instructions that stores on a disk. A process is an instance of a program that is currently being executed by the operating system. A thread is a small unit of process that can be scheduled and executed by the operating system. In simpler terms, a program is the code, a process is the excution of the code, a thread is a unit of execution within a process. Their relationships are illustrated in the following image:\nProgram, Process, and Thread Thread Life Cycle Within Concurrency A thread goes through various states in its life cycle, from creation to its termination. The life cycle of a thread typically includes five states: New, Runnable, Running, Blocked/Waiting, and Terminated.\nNew: This refers to the state where a thread instance is created but has not yet started running. In Java, this is commonly achieved by using new Thread(). Runnable: This refers to the state where a thread instance is ready to run but is waiting for CPU time. In Java, this is commonly achieved by ivoking start() on the thread instance. Running: This is refers to the state where the thread instance is actively executing its task. Blocked/Waiting: This refers to the state where a thread instance is waiting for other threads to complete their tasks, or it is waiting for a particular condition to be met. Terminated: This refers to the state where the thread instance has completed its task and has exited. Thread Life Cycle Within Concurrency Fork/Join Model The Fork/Join Model is an effective strategy commonly used in scenarios where a task can be recursively divided into multiple smaller, independent subtasks. This strategy typically involves the following steps:\nThe process begins with a single master thread. When it encounters a task that can be broken down into smaller subtasks, the master thread forks (spawns) multiple subsidiary threads, each of which takes on a portion of the task.\nOnce the subsidiary threads have completed their respective tasks, they join back with the master thread. Joining involves terminating the subsidiary threads and consolidating their results into the master thread. Afterward, the master thread continues its execution.\nFork/Join Model SHOW CODE Java import java.util.Arrays; import java.util.concurrent.RecursiveTask; import java.util.concurrent.ForkJoinPool; public class Solution { // RecursiveTask to compute the sum of a part of an array static class SumTask extends RecursiveTask { private final int[] array; private final int start; private final int end; // Threshold for splitting the task into smaller subtasks private static final int THRESHOLD = 1000; public SumTask(int[] array, int start, int end) { this.array = array; this.start = start; this.end = end; } @Override protected Long compute() { // If the task is small enough, calculate the sum directly if (end - start \u003c= THRESHOLD) { long sum = 0; for (int i = start; i \u003c end; i++) { sum += array[i]; } return sum; } // Otherwise, split the task into two subtasks int middle = (start + end) / 2; SumTask leftTask = new SumTask(array, start, middle); SumTask rightTask = new SumTask(array, middle, end); // Fork the subtasks leftTask.fork(); rightTask.fork(); // Join the results of the subtasks long leftResult = leftTask.join(); long rightResult = rightTask.join(); // Combine the results and return return leftResult + rightResult; } } public static void main(String[] args) { int[] array = new int[10000]; // Initialize all elements to 1 Arrays.fill(array, 1); // Create a ForkJoinPool to execute the tasks ForkJoinPool pool = new ForkJoinPool(); // Submit the task to the ForkJoinPool SumTask task = new SumTask(array, 0, array.length); long result = pool.invoke(task); System.out.println(\"Sum: \" + result); // Output the result } } SHOW OUTPUT Output Sum: 10000 Critical Section \u0026 Race Condition Critical Section refers to a portion of a program where shared resources are accessed and modified. A Race Condition occurs when the program’s behavior depends on the non-deterministic execution order of threads. Since multiple threads can access a critical section concurrently, it is essential to synchronize their access to avoid data inconsistency.\nFor example, suppose there are four threads trying to read a value of 20 from memory. Each thread increments the value by 1 and writes it back to memory. Without synchronization mechanisms, after all threads complete their writes, the final value might be 21 instead of the expected 24. This leads to an unexpected outcome, as illustrated below.\nCritical Section \u0026 Race Condition To resolve this issue, access to the critical section must be exclusive. This is commonly achieved by using mutexes, read/write locks, semaphores, conditional variables or barriers to ensure that only one thread can modify the shared resource at a time.\nSynchronization Mechanisms Synchronization Mechanisms are rules used to coordinate the execution of threads in a program, ensuring safe access to shared resources. These mechanisms can be primarily classified into five types: Mutexes, Read/Write Locks, Semaphores, Conditional Variables, and Barriers.\nMutex Mechanism The mutex mechanism ensures that only one thread can access the critical section at a time. Other threads will be blocked until the mutex is released. The key logic behind the mutex mechanism is as follows:\nLock lock = new ReentrantLock(); lock.lock(); // Acquire the lock try { // Critical section code } finally { lock.unlock(); // Release the lock } Mutex Mechanism SHOW CODE Java public class Mutex { private static int counter = 0; private static final Object lock = new Object(); public static void runExperiment(String experimentName, Runnable task) { counter = 0; Thread t1 = new Thread(task); Thread t2 = new Thread(task); t1.start(); t2.start(); try { t1.join(); t2.join(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"Final counter value \" + experimentName + \": \" + counter + \"\"); } public static void incrementCounterWithMutex() { for (int i = 0; i \u003c 100; i++) { synchronized (lock) { int temp = counter; try { Thread.sleep(1); // Sleep for 1 millisecond } catch (InterruptedException e) { e.printStackTrace(); } counter = temp + 1; } } } public static void incrementCounterNoMutex() { for (int i = 0; i \u003c 100; i++) { int temp = counter; try { Thread.sleep(1); // Sleep for 1 millisecond } catch (InterruptedException e) { e.printStackTrace(); } counter = temp + 1; } } public static void main(String[] args) { runExperiment(\"With Mutex Experiment\", Mutex::incrementCounterWithMutex); runExperiment(\"No Mutex Experiment\", Mutex::incrementCounterNoMutex); } } SHOW OUTPUT Output Final counter value With Mutex Experiment: 200 Final counter value No Mutex Experiment: 100 Read/Write Lock Mechanism The Read/Write Lock Mechanism allows threads read the shared resources concurrently, but ensures exclusive access for write operations. This mechanism is useful in scenarios where there are many read operations and fewer write operations, such as caching systems or databases. The key logic behind the read/write lock mechanism is as follows:\nReadWriteLock rwLock = new ReentrantReadWriteLock(); rwLock.readLock().lock(); // Acquire read lock try { // Read operation } finally { rwLock.readLock().unlock(); // Release read lock } rwLock.writeLock().lock(); // Acquire write lock try { // Write operation } finally { rwLock.writeLock().unlock(); // Release write lock } Under the Read/Write Lock mechanism, multiple threads can access the critical section simultaneously without blocking each other. When a writer thread is accessing the critical section, other writer threads and reader threads are blocked. Similarly, when a reader thread is accessing the critical section, the writer thread is blocked.\nRead/Write Lock Mechanism SHOW CODE Java import java.util.ArrayList; import java.util.List; import java.util.concurrent.locks.ReentrantReadWriteLock; public class ReadWriteLock { private static volatile int counter = 0; private static final int TARGET_VALUE = 1000; private static final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(); public static int incrementValue() { lock.writeLock().lock(); try { Thread.sleep(1); if (counter \u003c TARGET_VALUE) { counter++; } } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.writeLock().unlock(); } return counter; } public static int readValue() { lock.readLock().lock(); try { Thread.sleep(1); return counter; } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.readLock().unlock(); } return 0; } public static void main(String[] args) { long start = System.currentTimeMillis(); List readers = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c 8; i++) { readers.add(new Thread(() -\u003e { while (readValue() \u003c TARGET_VALUE) { try { Thread.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } } })); } List writers = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c 2; i++) { writers.add(new Thread(() -\u003e { while (incrementValue() \u003c TARGET_VALUE) { try { Thread.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } } })); } readers.forEach(Thread::start); writers.forEach(Thread::start); readers.forEach(t -\u003e { try { t.join(); } catch (InterruptedException e) { e.printStackTrace(); } }); writers.forEach(t -\u003e { try { t.join(); } catch (InterruptedException e) { e.printStackTrace(); } }); long end = System.currentTimeMillis(); System.out.println(\"Time taken: \" + (end - start) / 1000.0 + \" seconds\"); } } SHOW OUTPUT Output Time taken: 1.787 seconds In the above code, the readValue method uses a read lock, allowing multiple reader threads to access the counter (critical section) simultaneously without blocking each other. If the method used a write lock instead of a read lock, the execution time would be higher. This is because when a writer thread is accessing the counter, all other threads would be blocked.\npublic static int readValue() { // lock.readLock().lock(); lock.writeLock().lock(); try { Thread.sleep(1); return counter; } catch (InterruptedException e) { e.printStackTrace(); } finally { // lock.readLock().unlock(); lock.writeLock().unlock(); } return 0; } Time taken: 6.793 seconds # Use write lock Semaphore Mechanism The Semaphore mechanism uses an integer to manage a set of permits, allowing multiple threads to access shared resources simultaneously, but only up to a predetermined limit. There are two types of semaphores: Binary Semaphore and Counting Semaphore.\nBinary Semaphore: Similar to a mutex, it operates with two states (0 and 1), ensuring mutual exclusion in critical sections. Counting Semaphore: Allows a count greater than 1, permitting multiple threads to access shared resources concurrently, as long as the permit limit is not exceeded. Semaphores are useful in controlling access to a pool of resources, such as limiting the number of threads that can access a database connection or a server. The key logic behind the semaphore mechanism is as follows:\nSemaphore semaphore = new Semaphore(3); // Allow 3 threads at once semaphore.acquire(); // Acquire a permit try { // Critical section code } finally { semaphore.release(); // Release a permit } Semaphore Mechanism SHOW CODE Java import java.util.concurrent.Semaphore; import java.util.concurrent.atomic.AtomicInteger; public class SemaphoreTest { // Global shared resource // AtomicInteger allows multiple threads to read/write value of counter without requiring synchronization private static final AtomicInteger counter = new AtomicInteger(0); // Semaphore with a count of 5 private static final Semaphore semaphore = new Semaphore(5); private static final int TARGET_VALUE = 5000; public static void main(String[] args) { long startTime = System.currentTimeMillis(); Thread[] workers = new Thread[10]; for (int i = 0; i \u003c workers.length; i++) { workers[i] = new Thread(SemaphoreTest::worker); workers[i].start(); } for (Thread worker : workers) { try { worker.join(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); System.out.println(\"Thread was interrupted\"); } } long endTime = System.currentTimeMillis(); System.out.println(\"Time taken: \" + (endTime - startTime) / 1000.0 + \" seconds\"); } private static void worker() { while (true) { try { semaphore.acquire(); // Acquire the semaphore if (counter.get() \u003e= TARGET_VALUE) { break; } counter.incrementAndGet(); // Atomically increments the counter Thread.sleep(1); // Simulate work } catch (InterruptedException e) { Thread.currentThread().interrupt(); System.out.println(\"Thread was interrupted\"); } finally { semaphore.release(); // Release the semaphore } } } } Conditional Variable Mechanism The Conditional Variable Mechanism allows a thread to suspend its execution until other threads signal that a certain condition has been met. It is often used in conjunction with mutexes to implement synchronization patterns, such as the producer-consumer pattern.\nIn this mechanism, a thread can wait on a condition variable until it is notified by other threads that the condition has been satisfied. When the condition is fulfilled, one or more threads can be signaled to wake up and proceed. Condition variables are commonly used in scenarios like the producer-consumer problem, where one thread produces data and another consumes it, with both threads needing to wait for each other under specific conditions.\nThe key logic behind the Conditional Variable Mechanism is as follows:\nsynchronized (lock) { while (!condition) { lock.wait(); // Wait until condition is true } // Proceed with critical section } synchronized (lock) { condition = true; lock.notify(); // Notify waiting threads } Conditional Variable Mechanism SHOW CODE Wait \u0026 Notify Busy Waiting public class ConditionalVariable { private static final Object mutex = new Object(); private static int sharedNumber; private static boolean ready = false; public static void producer() { synchronized (mutex) { sharedNumber = 9; // Producing a number ready = true; System.out.println(\"Producer has produced the number: \" + sharedNumber); mutex.notify(); // Notify the consumer } } public static void consumer() { synchronized (mutex) { while (!ready) { try { mutex.wait(); // Wait until the number is ready } catch (InterruptedException e) { Thread.currentThread().interrupt(); System.out.println(\"Consumer thread was interrupted.\"); } } System.out.println(\"Consumer has consumed the number: \" + sharedNumber); } } public static void main(String[] args) { Thread producerThread = new Thread(ConditionalVariable::producer); Thread consumerThread = new Thread(ConditionalVariable::consumer); producerThread.start(); consumerThread.start(); try { producerThread.join(); consumerThread.join(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); System.out.println(\"Main thread was interrupted.\"); } } } public class Solution { private static final Object mutex = new Object(); private static int sharedNumber; private static boolean ready = false; private static void producer() { synchronized (mutex) { sharedNumber = 9; // Producing a number ready = true; System.out.println(\"Producer has produced the number: \" + sharedNumber); } } private static void consumer() { // Busy waiting loop while (true) { synchronized (mutex) { if (ready) { System.out.println(\"Consumer has consumed the number: \" + sharedNumber); break; } } try { Thread.sleep(1); // Sleep for a short time } catch (InterruptedException e) { Thread.currentThread().interrupt(); System.out.println(\"Thread was interrupted\"); } } } public static void main(String[] args) { Thread producerThread = new Thread(Solution::producer); Thread consumerThread = new Thread(Solution::consumer); producerThread.start(); consumerThread.start(); try { producerThread.join(); consumerThread.join(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); System.out.println(\"Main thread was interrupted\"); } } } Barrier Mechanism The Barrier Mechanism allows threads to wait for each other at a specified point in their execution. It ensures that threads cannot proceed to the subsequent code until all threads have reached the barrier, as illustrated in the following image.\nBarrier Mechanism Barrier Mechanism are useful in parallel algorithms where multiple threads need to work in phases, and the next phase cannot begin until all threads complete the current one.\nThe key logic behind this mechanism is as follows:\nCyclicBarrier barrier = new CyclicBarrier(4, new Runnable() { public void run() { System.out.println(\"All threads reached the barrier!\"); } }); // Threads: barrier.await(); // Wait at the barrier SHOW CODE Java import java.util.concurrent.CyclicBarrier; class Barriers { private static final CyclicBarrier barrier = new CyclicBarrier(2, () -\u003e System.out.println(\"All threads have reached the barrier. Continue execution.\")); public static void main(String[] args) { Thread t1 = new Thread(Barriers::work); Thread t2 = new Thread(Barriers::work); // Start both threads. t1.start(); t2.start(); } private static void work() { System.out.println(\"Thread \" + Thread.currentThread().getName() + \" is waiting at the barrier\"); try { // Wait for the specified number of threads (2 in this case) to reach the barrier. barrier.await(); System.out.println(\"Thread \" + Thread.currentThread().getName() + \" is released\"); } catch (Exception e) { // Handle exceptions, if any. } } } SHOW OUTPUT Output Thread Thread-0 is waiting at the barrier Thread Thread-1 is waiting at the barrier All threads have reached the barrier. Continue execution. Thread Thread-1 is released Thread Thread-0 is released Thread Creation In Java Extending Thread Class SHOW CODE Java class MyThread extends Thread { @Override public void run() { System.out.println(this.getName() + \" is running.\"); } } public class Main { public static void main(String[] args) { MyThread myThread = new MyThread(); myThread.setName(\"MYTHREAD-0\"); myThread.start(); } } Implementing Runnable Interface SHOW CODE Java public class Main { public static void main(String[] args) { Thread thread = new Thread(() -\u003e System.out.println(Thread.currentThread().getName() + \" is running.\")); thread.start(); } } //class MyRunnable implements Runnable { // @Override // public void run() { // System.out.println(\"Thread is running\"); // } //} // //public class Main { // public static void main(String[] args) { // Thread thread = new Thread(new MyRunnable()); // thread.start(); // Starts a new thread // } //} Using the Callable Interface SHOW CODE Java import java.util.concurrent.*; public class Main { public static void main(String[] args) throws Exception { ExecutorService executor = Executors.newSingleThreadExecutor(); Future future = executor.submit(() -\u003e Thread.currentThread().getName() + \" is running.\"); System.out.println(future.get()); executor.shutdown(); } } class MyCallable implements Callable { // @Override // public String call() { // return \"Thread executed\"; // } //} // //public class Main { // public static void main(String[] args) throws Exception { // ExecutorService executor = Executors.newSingleThreadExecutor(); // Future future = executor.submit(new MyCallable()); // System.out.println(future.get()); // Retrieves the result // executor.shutdown(); // } //} Using Executors SHOW CODE Java import java.util.concurrent.*; public class Main { public static void main(String[] args) { ExecutorService executor = Executors.newFixedThreadPool(2); Runnable task1 = () -\u003e System.out.println(Thread.currentThread().getName() + \" executed\"); Runnable task2 = () -\u003e System.out.println(Thread.currentThread().getName() + \" executed\"); executor.execute(task1); executor.execute(task2); executor.shutdown(); } } Thread Termination In Java Using a flag SHOW CODE Java class Task implements Runnable { // Use volatile to ensure visibility between thread private volatile boolean running = true; @Override public void run() { while (running) { System.out.println(\"Thread is running.\"); try { Thread.sleep(1000); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } System.out.println(\"Thread is stopping.\"); } public void stop() { running = false; } } public class Main { public static void main(String[] args) throws InterruptedException { Task task = new Task(); Thread thread = new Thread(task); thread.start(); Thread.sleep(3000); // Allow thread to run for a while task.stop(); // Signal thread to stop } } Interrupting a Thread SHOW CODE Java public class Main { public static void main(String[] args) throws InterruptedException { Thread thread = new Thread(() -\u003e { try { while (!Thread.currentThread().isInterrupted()) { System.out.println(\"Thread is running\"); Thread.sleep(1000); } } catch (InterruptedException e) { System.out.println(\"Thread is interrupted\"); } }); thread.start(); Thread.sleep(3000); // Allow thread to run for a while thread.interrupt(); // Interrupt the thread } } Daemon Threads A daemon thread in Java is a low-priority thread that runs in the background, typically handling tasks such as garbage collection or other housekeeping operations. The JVM terminates when all non-daemon threads have completed execution, even if daemon threads are still active. To create a daemon thread, the setDaemon(true) method is used on a Thread object before it is started.\nSHOW CODE Java public class Main { public static void main(String[] args) { Thread daemonThread = new Thread(() -\u003e { while (true) { System.out.println(\"Daemon thread is running\"); try { Thread.sleep(1000); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } }); daemonThread.setDaemon(true); // Mark as daemon daemonThread.start(); System.out.println(\"Main thread is ending\"); } } SHOW OUTPUT Output Main thread is ending Daemon thread is running Performance Optimization When it comes to multithreading, performance optimization typically focuses on two key areas: latency reduction and throughput improvement.\nLatency reduction refers to minimizing the time it takes to complete a single task, measured in time units. This is often achieved by breaking a task into smaller subtasks that can be executed concurrently by multiple threads.\nThroughput, on the other hand, measures the number of tasks completed within a specific time frame, typically expressed as tasks / time unit. Throughput improvement is commonly achieved by utilizing thread pooling, which reduces the overhead of creating and destroying threads for each task.\nSHOW CODE: Latency Reduction Java import javax.imageio.ImageIO; import java.awt.image.BufferedImage; import java.io.File; import java.io.IOException; import java.util.ArrayList; import java.util.List; public class Main { private static final String SOURCE_FILE = \"src/main/resources/1-flower.jpg\"; private static final String DESTINATION_FILE = \"./out/1-flower.jpg\"; public static void main(String[] args) throws IOException { BufferedImage originalImage = ImageIO.read(new File(SOURCE_FILE)); BufferedImage resultImage = new BufferedImage(originalImage.getWidth(), originalImage.getHeight(), BufferedImage.TYPE_INT_RGB); long startTime = System.currentTimeMillis(); // recolorSingleThreaded(originalImage, resultImage); int numberOfThreads = 1; recolorMultithreaded(originalImage, resultImage, numberOfThreads); long endTime = System.currentTimeMillis(); long duration = endTime - startTime; File outputFile = new File(DESTINATION_FILE); File parentDir = outputFile.getParentFile(); if (parentDir != null \u0026\u0026 !parentDir.exists()) { parentDir.mkdirs(); // Create the directory if it doesn't exist } ImageIO.write(resultImage, \"jpeg\", outputFile); System.out.println(\"duration = \" + duration); } public static void recolorMultithreaded(BufferedImage originalImage, BufferedImage resultImage, int numberOfThreads) { List threads = new ArrayList\u003c\u003e(); int width = originalImage.getWidth(); int height = originalImage.getHeight() / numberOfThreads; for(int i = 0; i \u003c numberOfThreads ; i++) { final int threadMultiplier = i; Thread thread = new Thread(() -\u003e { int xOrigin = 0 ; int yOrigin = height * threadMultiplier; recolorImage(originalImage, resultImage, xOrigin, yOrigin, width, height); }); threads.add(thread); } for(Thread thread : threads) { thread.start(); } for(Thread thread : threads) { try { thread.join(); } catch (InterruptedException e) { } } } private static void recolorSingleThreaded(BufferedImage originalImage, BufferedImage resultImage) { recolorImage(originalImage, resultImage, 0, 0, originalImage.getWidth(), originalImage.getHeight()); } private static void recolorImage(BufferedImage originalImage, BufferedImage resultImage, int leftCorner, int topCorner, int width, int height) { for (int x = leftCorner; x \u003c leftCorner + width \u0026\u0026 x \u003c originalImage.getWidth(); x++) { for (int y = topCorner; y \u003c topCorner + height \u0026\u0026 y \u003c originalImage.getHeight(); y++) { recolorPixel(originalImage, resultImage, x, y); } } } private static void recolorPixel(BufferedImage originalImage, BufferedImage resultImage, int x, int y) { int rgb = originalImage.getRGB(x, y); int red = getRed(rgb); int green = getGreen(rgb); int blue = getBlue(rgb); int newRed; int newGreen; int newBlue; if (isShadeOfGray(red, green, blue)) { newRed = Math.min(255, red + 10); newGreen = Math.max(0, green - 80); newBlue = Math.max(0, blue - 20); } else { newRed = red; newGreen = green; newBlue = blue; } int newRGB = createRGBFromColors(newRed, newGreen, newBlue); setRGB(resultImage, x, y, newRGB); } public static void setRGB(BufferedImage image, int x, int y, int rgb) { image.getRaster().setDataElements(x, y, image.getColorModel().getDataElements(rgb, null)); } public static boolean isShadeOfGray(int red, int green, int blue) { return Math.abs(red - green) \u003c 30 \u0026\u0026 Math.abs(red - blue) \u003c 30 \u0026\u0026 Math.abs(green - blue) \u003c 30; } public static int createRGBFromColors(int red, int green, int blue) { int rgb = 0; rgb |= blue; rgb |= green \u003c\u003c 8; rgb |= red \u003c\u003c 16; rgb |= 0xFF000000; return rgb; } public static int getRed(int rgb) { return (rgb \u0026 0x00FF0000) \u003e\u003e 16; } public static int getGreen(int rgb) { return (rgb \u0026 0x0000FF00) \u003e\u003e 8; } public static int getBlue(int rgb) { return rgb \u0026 0x000000FF; } } SHOW IMAGE: BEFORE PROCESSING SHOW IMAGE: AFTER PROCESSING Single Threaded VS. Multithreaded SHOW CODE: Throughput vs. Threads Throughput vs. Threads import com.sun.net.httpserver.HttpExchange; import com.sun.net.httpserver.HttpHandler; import com.sun.net.httpserver.HttpServer; import java.io.IOException; import java.io.OutputStream; import java.net.InetSocketAddress; import java.nio.file.Files; import java.nio.file.Paths; import java.util.concurrent.Executor; import java.util.concurrent.Executors; public class ThroughputHttpServer { private static final String INPUT_FILE = \"./resources/war_and_peace.txt\"; private static final int NUMBER_OF_THREADS = 8; public static void main(String[] args) throws IOException { String text = new String(Files.readAllBytes(Paths.get(INPUT_FILE))); startServer(text); } public static void startServer(String text) throws IOException { HttpServer server = HttpServer.create(new InetSocketAddress(8000), 0); server.createContext(\"/search\", new WordCountHandler(text)); Executor executor = Executors.newFixedThreadPool(NUMBER_OF_THREADS); server.setExecutor(executor); server.start(); } private static class WordCountHandler implements HttpHandler { private String text; public WordCountHandler(String text) { this.text = text; } @Override public void handle(HttpExchange httpExchange) throws IOException { String query = httpExchange.getRequestURI().getQuery(); String[] keyValue = query.split(\"=\"); String action = keyValue[0]; String word = keyValue[1]; if (!action.equals(\"word\")) { httpExchange.sendResponseHeaders(400, 0); return; } long count = countWord(word); byte[] response = Long.toString(count).getBytes(); httpExchange.sendResponseHeaders(200, response.length); OutputStream outputStream = httpExchange.getResponseBody(); outputStream.write(response); outputStream.close(); } private long countWord(String word) { long count = 0; int index = 0; while (index \u003e= 0) { index = text.indexOf(word, index); if (index \u003e= 0) { count++; index++; } } return count; } } } SHOW IMAGE: Throughput VS. Threads ",
  "wordCount" : "3891",
  "inLanguage": "en",
  "datePublished": "2024-12-11T12:13:32+08:00",
  "dateModified": "2024-12-11T12:13:32+08:00",
  "author":{
    "@type": "Person",
    "name": "Signal Yu"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/multithreading-and-concurrency/1-multithreading-and-concurrency/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Signal's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://signalyu.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://signalyu.github.io/" accesskey="h" title="Signal&#39;s Blog (Alt + H)">
                <img src="https://signalyu.github.io/apple-touch-icon.png" alt="" aria-label="logo"
                    height="40">Signal&#39;s Blog</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://signalyu.github.io/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://signalyu.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://signalyu.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://signalyu.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://signalyu.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Multithreading &amp; Concurrency
    </h1>
    <div class="post-meta"><span title='2024-12-11 12:13:32 +0800 HKT'>Dec 11 2024</span>&nbsp;·&nbsp;Signal Yu

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#introduction-to-multithreading" aria-label="Introduction to Multithreading">Introduction to Multithreading</a><ul>
                        
                <li>
                    <a href="#program-process-and-thread" aria-label="Program, Process, and Thread">Program, Process, and Thread</a></li>
                <li>
                    <a href="#thread-life-cycle-within-concurrency" aria-label="Thread Life Cycle Within Concurrency">Thread Life Cycle Within Concurrency</a></li>
                <li>
                    <a href="#forkjoin-model" aria-label="Fork/Join Model">Fork/Join Model</a></li>
                <li>
                    <a href="#critical-section--race-condition" aria-label="Critical Section &amp; Race Condition">Critical Section &amp; Race Condition</a></li>
                <li>
                    <a href="#synchronization-mechanisms" aria-label="Synchronization Mechanisms">Synchronization Mechanisms</a><ul>
                        
                <li>
                    <a href="#mutex-mechanism" aria-label="Mutex Mechanism">Mutex Mechanism</a></li>
                <li>
                    <a href="#readwrite-lock-mechanism" aria-label="Read/Write Lock Mechanism">Read/Write Lock Mechanism</a></li>
                <li>
                    <a href="#semaphore-mechanism" aria-label="Semaphore Mechanism">Semaphore Mechanism</a></li>
                <li>
                    <a href="#conditional-variable-mechanism" aria-label="Conditional Variable Mechanism">Conditional Variable Mechanism</a></li>
                <li>
                    <a href="#barrier-mechanism" aria-label="Barrier Mechanism">Barrier Mechanism</a></li></ul>
                </li>
                <li>
                    <a href="#thread-creation-in-java" aria-label="Thread Creation In Java">Thread Creation In Java</a><ul>
                        
                <li>
                    <a href="#extending-thread-class" aria-label="Extending Thread Class">Extending Thread Class</a></li>
                <li>
                    <a href="#implementing-runnable-interface" aria-label="Implementing Runnable Interface">Implementing Runnable Interface</a></li>
                <li>
                    <a href="#using-the-callable-interface" aria-label="Using the Callable Interface">Using the Callable Interface</a></li>
                <li>
                    <a href="#using-executors" aria-label="Using Executors">Using Executors</a></li></ul>
                </li>
                <li>
                    <a href="#thread-termination-in-java" aria-label="Thread Termination In Java">Thread Termination In Java</a><ul>
                        
                <li>
                    <a href="#using-a-flag" aria-label="Using a flag">Using a flag</a></li>
                <li>
                    <a href="#interrupting-a-thread" aria-label="Interrupting a Thread">Interrupting a Thread</a></li></ul>
                </li>
                <li>
                    <a href="#daemon-threads" aria-label="Daemon Threads">Daemon Threads</a></li>
                <li>
                    <a href="#performance-optimization" aria-label="Performance Optimization">Performance Optimization</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="introduction-to-multithreading">Introduction to Multithreading<a hidden class="anchor" aria-hidden="true" href="#introduction-to-multithreading">#</a></h1>
<h2 id="program-process-and-thread">Program, Process, and Thread<a hidden class="anchor" aria-hidden="true" href="#program-process-and-thread">#</a></h2>
<blockquote>
<p>A <strong>program</strong> is a static set of instructions that stores on a disk. A <strong>process</strong> is an instance of a program that is currently being executed by the operating system. A <strong>thread</strong> is a small unit of process that can be scheduled and executed by the operating system. In simpler terms, a <strong>program</strong> is the code, a <strong>process</strong> is the excution of the code, a <strong>thread</strong> is a unit of execution within a process. Their relationships are illustrated in the following image:</p>
</blockquote>
<figure class="align-center ">
    <img loading="lazy" src="/img/multithreading-and-concurrency/1-program-process-thread.gif#center" width="100%" height="100%"/> <figcaption>
            Program, Process, and Thread
        </figcaption>
</figure>

<hr>
<h2 id="thread-life-cycle-within-concurrency">Thread Life Cycle Within Concurrency<a hidden class="anchor" aria-hidden="true" href="#thread-life-cycle-within-concurrency">#</a></h2>
<blockquote>
<p>A <strong>thread</strong> goes through various states in its life cycle, from creation to its termination. The life cycle of a thread typically includes five states: <code>New</code>, <code>Runnable</code>, <code>Running</code>, <code>Blocked/Waiting</code>, and <code>Terminated</code>.</p>
</blockquote>
<ol>
<li><code>New</code>: This refers to the state where a thread instance is created but has not yet started running. In Java, this is commonly achieved by using <code>new Thread()</code>.</li>
<li><code>Runnable</code>: This refers to the state where a thread instance is ready to run but is waiting for CPU time. In Java, this is commonly achieved by ivoking <code>start()</code> on the thread instance.</li>
<li><code>Running</code>: This is refers to the state where the thread instance is actively executing its task.</li>
<li><code>Blocked/Waiting</code>: This refers to the state where a thread instance is waiting for other threads to complete their tasks, or it is waiting for a particular condition to be met.</li>
<li><code>Terminated</code>: This refers to the state where the thread instance has completed its task and has exited.</li>
</ol>
<figure class="align-center ">
    <img loading="lazy" src="/img/multithreading-and-concurrency/2-thread-life-cycle-within-concurrency.gif#center" width="100%" height="100%"/> <figcaption>
            Thread Life Cycle Within Concurrency
        </figcaption>
</figure>

<hr>
<h2 id="forkjoin-model">Fork/Join Model<a hidden class="anchor" aria-hidden="true" href="#forkjoin-model">#</a></h2>
<blockquote>
<p>The <strong>Fork/Join Model</strong> is an effective strategy commonly used in scenarios where a task can be recursively divided into multiple smaller, independent subtasks. This strategy typically involves the following steps:</p>
</blockquote>
<ol>
<li>
<p>The process begins with a single master thread. When it encounters a task that can be broken down into smaller subtasks, the master thread forks (spawns) multiple subsidiary threads, each of which takes on a portion of the task.</p>
</li>
<li>
<p>Once the subsidiary threads have completed their respective tasks, they join back with the master thread. Joining involves terminating the subsidiary threads and consolidating their results into the master thread. Afterward, the master thread continues its execution.</p>
</li>
</ol>
<figure class="align-center ">
    <img loading="lazy" src="/img/multithreading-and-concurrency/3-fork-join.gif#center" width="100%" height="100%"/> <figcaption>
            Fork/Join Model
        </figcaption>
</figure>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.Arrays;
import java.util.concurrent.RecursiveTask;
import java.util.concurrent.ForkJoinPool;

public class Solution {

    // RecursiveTask to compute the sum of a part of an array
    static class SumTask extends RecursiveTask<Long> {
        private final int[] array;
        private final int start;
        private final int end;

        // Threshold for splitting the task into smaller subtasks
        private static final int THRESHOLD = 1000;

        public SumTask(int[] array, int start, int end) {
            this.array = array;
            this.start = start;
            this.end = end;
        }

        @Override
        protected Long compute() {
            // If the task is small enough, calculate the sum directly
            if (end - start <= THRESHOLD) {
                long sum = 0;
                for (int i = start; i < end; i++) {
                    sum += array[i];
                }
                return sum;
            }
            // Otherwise, split the task into two subtasks
            int middle = (start + end) / 2;
            SumTask leftTask = new SumTask(array, start, middle);
            SumTask rightTask = new SumTask(array, middle, end);

            // Fork the subtasks
            leftTask.fork();
            rightTask.fork();

            // Join the results of the subtasks
            long leftResult = leftTask.join();
            long rightResult = rightTask.join();

            // Combine the results and return
            return leftResult + rightResult;
        }
    }

    public static void main(String[] args) {
        int[] array = new int[10000];
        // Initialize all elements to 1
        Arrays.fill(array, 1);

        // Create a ForkJoinPool to execute the tasks
        ForkJoinPool pool = new ForkJoinPool();

        // Submit the task to the ForkJoinPool
        SumTask task = new SumTask(array, 0, array.length);
        long result = pool.invoke(task);

        System.out.println("Sum: " + result);  // Output the result
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW OUTPUT</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Output</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-bash" data-lang="bash" >Sum: 10000
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="critical-section--race-condition">Critical Section &amp; Race Condition<a hidden class="anchor" aria-hidden="true" href="#critical-section--race-condition">#</a></h2>
<blockquote>
<p><strong>Critical Section</strong> refers to a portion of a program where shared resources are accessed and modified. A <strong>Race Condition</strong> occurs when the program&rsquo;s behavior depends on the non-deterministic execution order of threads. Since multiple threads can access a critical section concurrently, it is essential to synchronize their access to avoid data inconsistency.</p>
</blockquote>
<p>For example, suppose there are four threads trying to read a value of 20 from memory. Each thread increments the value by 1 and writes it back to memory. Without synchronization mechanisms, after all threads complete their writes, the final value might be 21 instead of the expected 24. This leads to an unexpected outcome, as illustrated below.</p>
<figure class="align-center ">
    <img loading="lazy" src="/img/multithreading-and-concurrency/4-critical-section-and-race-condition.gif#center" width="100%" height="100%"/> <figcaption>
            Critical Section &amp; Race Condition
        </figcaption>
</figure>

<blockquote>
<p>To resolve this issue, <em>access to the critical section must be exclusive</em>. This is commonly achieved by using <strong>mutexes</strong>, <strong>read/write locks</strong>, <strong>semaphores</strong>, <strong>conditional variables</strong> or <strong>barriers</strong> to ensure that only one thread can modify the shared resource at a time.</p>
</blockquote>
<hr>
<h2 id="synchronization-mechanisms">Synchronization Mechanisms<a hidden class="anchor" aria-hidden="true" href="#synchronization-mechanisms">#</a></h2>
<blockquote>
<p><strong>Synchronization Mechanisms</strong> are rules used to coordinate the execution of threads in a program, ensuring safe access to shared resources. These mechanisms can be primarily classified into five types: <strong>Mutexes</strong>, <strong>Read/Write Locks</strong>, <strong>Semaphores</strong>, <strong>Conditional Variables</strong>, and Barriers.</p>
</blockquote>
<hr>
<h3 id="mutex-mechanism">Mutex Mechanism<a hidden class="anchor" aria-hidden="true" href="#mutex-mechanism">#</a></h3>
<blockquote>
<p>The <strong>mutex mechanism</strong> ensures that only one thread can access the critical section at a time. Other threads will be blocked until the mutex is released. The key logic behind the mutex mechanism is as follows:</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Lock lock <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ReentrantLock();
</span></span><span style="display:flex;"><span>lock.<span style="color:#a6e22e">lock</span>();  <span style="color:#75715e">// Acquire the lock</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Critical section code</span>
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>    lock.<span style="color:#a6e22e">unlock</span>(); <span style="color:#75715e">// Release the lock</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><figure class="align-center ">
    <img loading="lazy" src="/img/multithreading-and-concurrency/5-mutex.gif#center" width="100%" height="100%"/> <figcaption>
            Mutex Mechanism
        </figcaption>
</figure>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >public class Mutex {
    private static int counter = 0;
    private static final Object lock = new Object();

    public static void runExperiment(String experimentName, Runnable task) {
        counter = 0;

        Thread t1 = new Thread(task);
        Thread t2 = new Thread(task);

        t1.start();
        t2.start();

        try {
            t1.join();
            t2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Final counter value " + experimentName + ": " + counter + "");
    }

    public static void incrementCounterWithMutex() {
        for (int i = 0; i < 100; i++) {
            synchronized (lock) {
                int temp = counter;
                try {
                    Thread.sleep(1); // Sleep for 1 millisecond
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                counter = temp + 1;
            }
        }
    }

    public static void incrementCounterNoMutex() {
        for (int i = 0; i < 100; i++) {
            int temp = counter;
            try {
                Thread.sleep(1); // Sleep for 1 millisecond
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            counter = temp + 1;
        }
    }

    public static void main(String[] args) {
        runExperiment("With Mutex Experiment", Mutex::incrementCounterWithMutex);
        runExperiment("No Mutex Experiment", Mutex::incrementCounterNoMutex);
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW OUTPUT</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Output</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-bash" data-lang="bash" >Final counter value With Mutex Experiment: 200
Final counter value No Mutex Experiment: 100
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h3 id="readwrite-lock-mechanism">Read/Write Lock Mechanism<a hidden class="anchor" aria-hidden="true" href="#readwrite-lock-mechanism">#</a></h3>
<blockquote>
<p>The <strong>Read/Write Lock Mechanism</strong> allows threads read the shared resources concurrently, but ensures exclusive access for write operations. This mechanism is useful in scenarios where there are many read operations and fewer write operations, such as caching systems or databases. The key logic behind the <strong>read/write lock mechanism</strong> is as follows:</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ReadWriteLock rwLock <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ReentrantReadWriteLock();
</span></span><span style="display:flex;"><span>rwLock.<span style="color:#a6e22e">readLock</span>().<span style="color:#a6e22e">lock</span>();   <span style="color:#75715e">// Acquire read lock</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Read operation</span>
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>    rwLock.<span style="color:#a6e22e">readLock</span>().<span style="color:#a6e22e">unlock</span>(); <span style="color:#75715e">// Release read lock</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>rwLock.<span style="color:#a6e22e">writeLock</span>().<span style="color:#a6e22e">lock</span>();   <span style="color:#75715e">// Acquire write lock</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Write operation</span>
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>    rwLock.<span style="color:#a6e22e">writeLock</span>().<span style="color:#a6e22e">unlock</span>(); <span style="color:#75715e">// Release write lock</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>Under the Read/Write Lock mechanism, multiple threads can access the critical section simultaneously without blocking each other. When a writer thread is accessing the critical section, other writer threads and reader threads are blocked. Similarly, when a reader thread is accessing the critical section, the writer thread is blocked.</p>
</blockquote>
<figure class="align-center ">
    <img loading="lazy" src="/img/multithreading-and-concurrency/6-read-write-lock.webp#center" width="100%" height="100%"/> <figcaption>
            Read/Write Lock Mechanism
        </figcaption>
</figure>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class ReadWriteLock {
    private static volatile int counter = 0;
    private static final int TARGET_VALUE = 1000;
    private static final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();

    public static int incrementValue() {
        lock.writeLock().lock();
        try {
            Thread.sleep(1);
            if (counter < TARGET_VALUE) {
                counter++;
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.writeLock().unlock();
        }
        return counter;
    }

    public static int readValue() {
        lock.readLock().lock();
        try {
            Thread.sleep(1);
            return counter;
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.readLock().unlock();
        }
        return 0;
    }

    public static void main(String[] args) {
        long start = System.currentTimeMillis();

        List<Thread> readers = new ArrayList<>();
        for (int i = 0; i < 8; i++) {
            readers.add(new Thread(() -> {
                while (readValue() < TARGET_VALUE) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }));
        }

        List<Thread> writers = new ArrayList<>();
        for (int i = 0; i < 2; i++) {
            writers.add(new Thread(() -> {
                while (incrementValue() < TARGET_VALUE) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }));
        }

        readers.forEach(Thread::start);
        writers.forEach(Thread::start);

        readers.forEach(t -> {
            try {
                t.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        writers.forEach(t -> {
            try {
                t.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        long end = System.currentTimeMillis();
        System.out.println("Time taken: " + (end - start) / 1000.0 + " seconds");
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW OUTPUT</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Output</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-bash" data-lang="bash" >Time taken: 1.787 seconds
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<blockquote>
<p>In the above code, the <code>readValue</code> method uses a read lock, allowing multiple reader threads to access the counter (critical section) simultaneously without blocking each other. If the method used a write lock instead of a read lock, the execution time would be higher. This is because when a writer thread is accessing the counter, all other threads would be blocked.</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">readValue</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// lock.readLock().lock();</span>
</span></span><span style="display:flex;"><span>    lock.<span style="color:#a6e22e">writeLock</span>().<span style="color:#a6e22e">lock</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>        Thread.<span style="color:#a6e22e">sleep</span>(1);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> counter;
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">catch</span> (InterruptedException e) {
</span></span><span style="display:flex;"><span>        e.<span style="color:#a6e22e">printStackTrace</span>();
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// lock.readLock().unlock();</span>
</span></span><span style="display:flex;"><span>        lock.<span style="color:#a6e22e">writeLock</span>().<span style="color:#a6e22e">unlock</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> 0;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code>Time taken: 6.793 seconds # Use write lock
</code></pre><hr>
<h3 id="semaphore-mechanism">Semaphore Mechanism<a hidden class="anchor" aria-hidden="true" href="#semaphore-mechanism">#</a></h3>
<blockquote>
<p>The <strong>Semaphore mechanism</strong> uses an integer to manage a set of permits, allowing multiple threads to access shared resources simultaneously, but only up to a predetermined limit. There are two types of semaphores: <strong>Binary Semaphore</strong> and <strong>Counting Semaphore</strong>.</p>
</blockquote>
<ul>
<li><strong>Binary Semaphore</strong>: Similar to a mutex, it operates with two states (<code>0</code> and <code>1</code>), ensuring mutual exclusion in critical sections.</li>
<li><strong>Counting Semaphore</strong>: Allows a count greater than 1, permitting multiple threads to access shared resources concurrently, as long as the permit limit is not exceeded.</li>
</ul>
<blockquote>
<p>Semaphores are useful in controlling access to a pool of resources, such as limiting the number of threads that can access a database connection or a server. The key logic behind the semaphore mechanism is as follows:</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Semaphore semaphore <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Semaphore(3); <span style="color:#75715e">// Allow 3 threads at once</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>semaphore.<span style="color:#a6e22e">acquire</span>();   <span style="color:#75715e">// Acquire a permit</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Critical section code</span>
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>    semaphore.<span style="color:#a6e22e">release</span>();  <span style="color:#75715e">// Release a permit</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><figure class="align-center ">
    <img loading="lazy" src="/img/multithreading-and-concurrency/7-semaphore.gif#center" width="100%" height="100%"/> <figcaption>
            Semaphore Mechanism
        </figcaption>
</figure>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.concurrent.Semaphore;
import java.util.concurrent.atomic.AtomicInteger;

public class SemaphoreTest {
    // Global shared resource
    // AtomicInteger allows multiple threads to read/write value of counter without requiring synchronization
    private static final AtomicInteger counter = new AtomicInteger(0);

    // Semaphore with a count of 5
    private static final Semaphore semaphore = new Semaphore(5);

    private static final int TARGET_VALUE = 5000;

    public static void main(String[] args) {
        long startTime = System.currentTimeMillis();

        Thread[] workers = new Thread[10];
        for (int i = 0; i < workers.length; i++) {
            workers[i] = new Thread(SemaphoreTest::worker);
            workers[i].start();
        }

        for (Thread worker : workers) {
            try {
                worker.join();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                System.out.println("Thread was interrupted");
            }
        }

        long endTime = System.currentTimeMillis();
        System.out.println("Time taken: " + (endTime - startTime) / 1000.0 + " seconds");
    }

    private static void worker() {
        while (true) {
            try {
                semaphore.acquire(); // Acquire the semaphore
                if (counter.get() >= TARGET_VALUE) {
                    break;
                }
                counter.incrementAndGet(); // Atomically increments the counter
                Thread.sleep(1); // Simulate work
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                System.out.println("Thread was interrupted");
            } finally {
                semaphore.release(); // Release the semaphore
            }
        }
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h3 id="conditional-variable-mechanism">Conditional Variable Mechanism<a hidden class="anchor" aria-hidden="true" href="#conditional-variable-mechanism">#</a></h3>
<blockquote>
<p>The <strong>Conditional Variable Mechanism</strong> allows a thread to suspend its execution until other threads signal that a certain condition has been met. It is often used in conjunction with mutexes to implement synchronization patterns, such as the <em>producer-consumer pattern</em>.</p>
</blockquote>
<blockquote>
<p>In this mechanism, a thread can wait on a condition variable until it is notified by other threads that the condition has been satisfied. When the condition is fulfilled, one or more threads can be signaled to wake up and proceed. Condition variables are commonly used in scenarios like the producer-consumer problem, where one thread produces data and another consumes it, with both threads needing to wait for each other under specific conditions.</p>
</blockquote>
<blockquote>
<p>The key logic behind the <strong>Conditional Variable Mechanism</strong> is as follows:</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">synchronized</span> (lock) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>condition) {
</span></span><span style="display:flex;"><span>        lock.<span style="color:#a6e22e">wait</span>();  <span style="color:#75715e">// Wait until condition is true</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Proceed with critical section</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">synchronized</span> (lock) {
</span></span><span style="display:flex;"><span>    condition <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>    lock.<span style="color:#a6e22e">notify</span>();  <span style="color:#75715e">// Notify waiting threads</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><figure class="align-center ">
    <img loading="lazy" src="/img/multithreading-and-concurrency/8-conditional-variables.png#center" width="100%" height="100%"/> <figcaption>
            Conditional Variable Mechanism
        </figcaption>
</figure>

<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Wait &amp; Notify</button>



<button class="tab_btn ">Busy Waiting</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >public class ConditionalVariable {
    private static final Object mutex = new Object();
    private static int sharedNumber;
    private static boolean ready = false;

    public static void producer() {
        synchronized (mutex) {
            sharedNumber = 9; // Producing a number
            ready = true;
            System.out.println("Producer has produced the number: " + sharedNumber);
            mutex.notify(); // Notify the consumer
        }
    }

    public static void consumer() {
        synchronized (mutex) {
            while (!ready) {
                try {
                    mutex.wait(); // Wait until the number is ready
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    System.out.println("Consumer thread was interrupted.");
                }
            }
            System.out.println("Consumer has consumed the number: " + sharedNumber);
        }
    }

    public static void main(String[] args) {
        Thread producerThread = new Thread(ConditionalVariable::producer);
        Thread consumerThread = new Thread(ConditionalVariable::consumer);

        producerThread.start();
        consumerThread.start();

        try {
            producerThread.join();
            consumerThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            System.out.println("Main thread was interrupted.");
        }
    }
}
</code></pre>
    </div>
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-java" data-lang="java" >public class Solution {
    private static final Object mutex = new Object();
    private static int sharedNumber;
    private static boolean ready = false;

    private static void producer() {
        synchronized (mutex) {
            sharedNumber = 9; // Producing a number
            ready = true;
            System.out.println("Producer has produced the number: " + sharedNumber);
        }
    }

    private static void consumer() {
        // Busy waiting loop
        while (true) {
            synchronized (mutex) {
                if (ready) {
                    System.out.println("Consumer has consumed the number: " + sharedNumber);
                    break;
                }
            }
            try {
                Thread.sleep(1); // Sleep for a short time
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                System.out.println("Thread was interrupted");
            }
        }
    }

    public static void main(String[] args) {
        Thread producerThread = new Thread(Solution::producer);
        Thread consumerThread = new Thread(Solution::consumer);

        producerThread.start();
        consumerThread.start();

        try {
            producerThread.join();
            consumerThread.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            System.out.println("Main thread was interrupted");
        }
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h3 id="barrier-mechanism">Barrier Mechanism<a hidden class="anchor" aria-hidden="true" href="#barrier-mechanism">#</a></h3>
<blockquote>
<p>The <strong>Barrier Mechanism</strong> allows threads to wait for each other at a specified point in their execution. It ensures that threads cannot proceed to the subsequent code until all threads have reached the barrier, as illustrated in the following image.</p>
</blockquote>
<figure class="align-center ">
    <img loading="lazy" src="/img/multithreading-and-concurrency/9-barrier.gif#center" width="100%" height="100%"/> <figcaption>
            Barrier Mechanism
        </figcaption>
</figure>

<blockquote>
<p>Barrier Mechanism are useful in parallel algorithms where multiple threads need to work in phases, and the next phase cannot begin until all threads complete the current one.</p>
</blockquote>
<blockquote>
<p>The key logic behind this mechanism is as follows:</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>CyclicBarrier barrier <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CyclicBarrier(4, <span style="color:#66d9ef">new</span> Runnable() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>() {
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;All threads reached the barrier!&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Threads:</span>
</span></span><span style="display:flex;"><span>barrier.<span style="color:#a6e22e">await</span>();  <span style="color:#75715e">// Wait at the barrier</span>
</span></span></code></pre></div><head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.concurrent.CyclicBarrier;

class Barriers {
    private static final CyclicBarrier barrier = new CyclicBarrier(2, () ->
            System.out.println("All threads have reached the barrier. Continue execution."));

    public static void main(String[] args) {
        Thread t1 = new Thread(Barriers::work);
        Thread t2 = new Thread(Barriers::work);

        // Start both threads.
        t1.start();
        t2.start();
    }

    private static void work() {
        System.out.println("Thread " + Thread.currentThread().getName()
                + " is waiting at the barrier");

        try {
            // Wait for the specified number of threads (2 in this case) to reach the barrier.
            barrier.await(); 
            System.out.println("Thread " + Thread.currentThread().getName() + " is released");
        } catch (Exception e) {
            // Handle exceptions, if any.
        }
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW OUTPUT</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Output</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-bash" data-lang="bash" >Thread Thread-0 is waiting at the barrier
Thread Thread-1 is waiting at the barrier
All threads have reached the barrier. Continue execution.
Thread Thread-1 is released
Thread Thread-0 is released
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="thread-creation-in-java">Thread Creation In Java<a hidden class="anchor" aria-hidden="true" href="#thread-creation-in-java">#</a></h2>
<h3 id="extending-thread-class">Extending Thread Class<a hidden class="anchor" aria-hidden="true" href="#extending-thread-class">#</a></h3>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println(this.getName() + " is running.");
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.setName("MYTHREAD-0");
        myThread.start();
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h3 id="implementing-runnable-interface">Implementing Runnable Interface<a hidden class="anchor" aria-hidden="true" href="#implementing-runnable-interface">#</a></h3>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >public class Main {
    public static void main(String[] args) {
        Thread thread = new Thread(() ->
                System.out.println(Thread.currentThread().getName() + " is running."));
        thread.start();
    }
}

//class MyRunnable implements Runnable {
//    @Override
//    public void run() {
//        System.out.println("Thread is running");
//    }
//}
//
//public class Main {
//    public static void main(String[] args) {
//        Thread thread = new Thread(new MyRunnable());
//        thread.start(); // Starts a new thread
//    }
//}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h3 id="using-the-callable-interface">Using the Callable Interface<a hidden class="anchor" aria-hidden="true" href="#using-the-callable-interface">#</a></h3>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.concurrent.*;

public class Main {
    public static void main(String[] args) throws Exception {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        Future&lt;String&gt; future = executor.submit(() ->
                Thread.currentThread().getName() + " is running.");
        System.out.println(future.get());
        executor.shutdown();
    }
}

class MyCallable implements Callable&lt;String&gt; {
//    @Override
//    public String call() {
//        return "Thread executed";
//    }
//}
//
//public class Main {
//    public static void main(String[] args) throws Exception {
//        ExecutorService executor = Executors.newSingleThreadExecutor();
//        Future&lt;String&gt; future = executor.submit(new MyCallable());
//        System.out.println(future.get()); // Retrieves the result
//        executor.shutdown();
//    }
//}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h3 id="using-executors">Using Executors<a hidden class="anchor" aria-hidden="true" href="#using-executors">#</a></h3>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import java.util.concurrent.*;

public class Main {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(2);

        Runnable task1 = () -> System.out.println(Thread.currentThread().getName() + " executed");
        Runnable task2 = () -> System.out.println(Thread.currentThread().getName() + " executed");

        executor.execute(task1);
        executor.execute(task2);

        executor.shutdown();
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="thread-termination-in-java">Thread Termination In Java<a hidden class="anchor" aria-hidden="true" href="#thread-termination-in-java">#</a></h2>
<h3 id="using-a-flag">Using a flag<a hidden class="anchor" aria-hidden="true" href="#using-a-flag">#</a></h3>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Task implements Runnable {
    // Use volatile to ensure visibility between thread
    private volatile boolean running = true;


    @Override
    public void run() {
        while (running) {
            System.out.println("Thread is running.");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        System.out.println("Thread is stopping.");
    }

    public void stop() {
        running = false;
    }
}

public class Main {
    public static void main(String[] args) throws InterruptedException {
        Task task = new Task();
        Thread thread = new Thread(task);
        thread.start();

        Thread.sleep(3000); // Allow thread to run for a while
        task.stop(); // Signal thread to stop
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h3 id="interrupting-a-thread">Interrupting a Thread<a hidden class="anchor" aria-hidden="true" href="#interrupting-a-thread">#</a></h3>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >public class Main {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -> {
            try {
                while (!Thread.currentThread().isInterrupted()) {
                    System.out.println("Thread is running");
                    Thread.sleep(1000);
                }
            } catch (InterruptedException e) {
                System.out.println("Thread is interrupted");
            }
        });

        thread.start();
        Thread.sleep(3000); // Allow thread to run for a while
        thread.interrupt(); // Interrupt the thread
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="daemon-threads">Daemon Threads<a hidden class="anchor" aria-hidden="true" href="#daemon-threads">#</a></h2>
<blockquote>
<p>A <strong>daemon thread</strong> in Java is a low-priority thread that runs in the background, typically handling tasks such as garbage collection or other housekeeping operations. The JVM terminates when all non-daemon threads have completed execution, even if daemon threads are still active. To create a daemon thread, the <code>setDaemon(true)</code> method is used on a <code>Thread</code> object before it is started.</p>
</blockquote>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >public class Main {
    public static void main(String[] args) {
        Thread daemonThread = new Thread(() -> {
            while (true) {
                System.out.println("Daemon thread is running");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });

        daemonThread.setDaemon(true); // Mark as daemon
        daemonThread.start();

        System.out.println("Main thread is ending");
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW OUTPUT</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Output</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-bash" data-lang="bash" >Main thread is ending
Daemon thread is running
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>
<hr>
<h2 id="performance-optimization">Performance Optimization<a hidden class="anchor" aria-hidden="true" href="#performance-optimization">#</a></h2>
<blockquote>
<p>When it comes to multithreading, performance optimization typically focuses on two key areas: <strong>latency reduction</strong> and <strong>throughput improvement</strong>.</p>
</blockquote>
<blockquote>
<p><strong>Latency reduction</strong> refers to minimizing the time it takes to complete a single task, measured in <code>time units</code>. This is often achieved by breaking a task into smaller subtasks that can be executed concurrently by multiple threads.</p>
</blockquote>
<blockquote>
<p><strong>Throughput</strong>, on the other hand, measures the number of tasks completed within a specific time frame, typically expressed as <code>tasks / time unit</code>. <strong>Throughput improvement</strong> is commonly achieved by utilizing <code>thread pooling</code>, which reduces the overhead of creating and destroying threads for each task.</p>
</blockquote>
<hr>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE: Latency Reduction</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Java</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public class Main {
    private static final String SOURCE_FILE = "src/main/resources/1-flower.jpg";
    private static final String DESTINATION_FILE = "./out/1-flower.jpg";

    public static void main(String[] args) throws IOException {
        BufferedImage originalImage = ImageIO.read(new File(SOURCE_FILE));
        BufferedImage resultImage = new BufferedImage(originalImage.getWidth(), originalImage.getHeight(), BufferedImage.TYPE_INT_RGB);

        long startTime = System.currentTimeMillis();
//        recolorSingleThreaded(originalImage, resultImage);
        int numberOfThreads = 1;
        recolorMultithreaded(originalImage, resultImage, numberOfThreads);
        long endTime = System.currentTimeMillis();

        long duration = endTime - startTime;

        File outputFile = new File(DESTINATION_FILE);
        File parentDir = outputFile.getParentFile();
        if (parentDir != null && !parentDir.exists()) {
            parentDir.mkdirs(); // Create the directory if it doesn't exist
        }
        ImageIO.write(resultImage, "jpeg", outputFile);

        System.out.println("duration = " + duration);
    }

    public static void recolorMultithreaded(BufferedImage originalImage, BufferedImage resultImage, int numberOfThreads) {
        List&lt;Thread&gt; threads = new ArrayList&lt;&gt;();
        int width = originalImage.getWidth();
        int height = originalImage.getHeight() / numberOfThreads;

        for(int i = 0; i < numberOfThreads ; i++) {
            final int threadMultiplier = i;

            Thread thread = new Thread(() -> {
                int xOrigin = 0 ;
                int yOrigin = height * threadMultiplier;

                recolorImage(originalImage, resultImage, xOrigin, yOrigin, width, height);
            });

            threads.add(thread);
        }

        for(Thread thread : threads) {
            thread.start();
        }

        for(Thread thread : threads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
            }
        }
    }

    private static void recolorSingleThreaded(BufferedImage originalImage, BufferedImage resultImage) {
        recolorImage(originalImage, resultImage, 0, 0, originalImage.getWidth(), originalImage.getHeight());
    }

    private static void recolorImage(BufferedImage originalImage, BufferedImage resultImage, int leftCorner, int topCorner, int width, int height) {
        for (int x = leftCorner; x < leftCorner + width && x < originalImage.getWidth(); x++) {
            for (int y = topCorner; y < topCorner + height && y < originalImage.getHeight(); y++) {
                recolorPixel(originalImage, resultImage, x, y);
            }
        }
    }

    private static void recolorPixel(BufferedImage originalImage, BufferedImage resultImage, int x, int y) {
        int rgb = originalImage.getRGB(x, y);

        int red = getRed(rgb);
        int green = getGreen(rgb);
        int blue = getBlue(rgb);

        int newRed;
        int newGreen;
        int newBlue;

        if (isShadeOfGray(red, green, blue)) {
            newRed = Math.min(255, red + 10);
            newGreen = Math.max(0, green - 80);
            newBlue = Math.max(0, blue - 20);
        } else {
            newRed = red;
            newGreen = green;
            newBlue = blue;
        }
        int newRGB = createRGBFromColors(newRed, newGreen, newBlue);
        setRGB(resultImage, x, y, newRGB);
    }

    public static void setRGB(BufferedImage image, int x, int y, int rgb) {
        image.getRaster().setDataElements(x, y, image.getColorModel().getDataElements(rgb, null));
    }

    public static boolean isShadeOfGray(int red, int green, int blue) {
        return Math.abs(red - green) < 30 && Math.abs(red - blue) < 30 && Math.abs(green - blue) < 30;
    }

    public static int createRGBFromColors(int red, int green, int blue) {
        int rgb = 0;

        rgb |= blue;
        rgb |= green << 8;
        rgb |= red << 16;

        rgb |= 0xFF000000;

        return rgb;
    }

    public static int getRed(int rgb) {
        return (rgb & 0x00FF0000) >> 16;
    }

    public static int getGreen(int rgb) {
        return (rgb & 0x0000FF00) >> 8;
    }

    public static int getBlue(int rgb) {
        return rgb & 0x000000FF;
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW IMAGE: BEFORE PROCESSING</summary>
  <img loading="lazy" src="/img/multithreading/1-flower.jpg" alt="Flower: Before Processing"  />
</details></p>



<p><details >
  <summary markdown="span">SHOW IMAGE: AFTER PROCESSING</summary>
  <img loading="lazy" src="/img/multithreading/2-flower.jpg" alt="Flower: Before Processing"  />
</details></p>



<p><details >
  <summary markdown="span">Single Threaded VS. Multithreaded</summary>
  <img loading="lazy" src="/img/multithreading/3-latency-optimization.png" alt="Single Threaded VS. Multithreaded"  />
</details></p>

<hr>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>SHOW CODE: Throughput vs. Threads</summary>
        <div>
            
<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">Throughput vs. Threads</button>

</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import com.sun.net.httpserver.HttpExchange;
import com.sun.net.httpserver.HttpHandler;
import com.sun.net.httpserver.HttpServer;

import java.io.IOException;
import java.io.OutputStream;
import java.net.InetSocketAddress;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;

public class ThroughputHttpServer {
    private static final String INPUT_FILE = "./resources/war_and_peace.txt";
    private static final int NUMBER_OF_THREADS = 8;

    public static void main(String[] args) throws IOException {
        String text = new String(Files.readAllBytes(Paths.get(INPUT_FILE)));
        startServer(text);
    }

    public static void startServer(String text) throws IOException {
        HttpServer server = HttpServer.create(new InetSocketAddress(8000), 0);
        server.createContext("/search", new WordCountHandler(text));
        Executor executor = Executors.newFixedThreadPool(NUMBER_OF_THREADS);
        server.setExecutor(executor);
        server.start();
    }

    private static class WordCountHandler implements HttpHandler {
        private String text;

        public WordCountHandler(String text) {
            this.text = text;
        }

        @Override
        public void handle(HttpExchange httpExchange) throws IOException {
            String query = httpExchange.getRequestURI().getQuery();
            String[] keyValue = query.split("=");
            String action = keyValue[0];
            String word = keyValue[1];
            if (!action.equals("word")) {
                httpExchange.sendResponseHeaders(400, 0);
                return;
            }

            long count = countWord(word);

            byte[] response = Long.toString(count).getBytes();
            httpExchange.sendResponseHeaders(200, response.length);
            OutputStream outputStream = httpExchange.getResponseBody();
            outputStream.write(response);
            outputStream.close();
        }

        private long countWord(String word) {
            long count = 0;
            int index = 0;
            while (index >= 0) {
                index = text.indexOf(word, index);

                if (index >= 0) {
                    count++;
                    index++;
                }
            }
            return count;
        }
    }
}
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script>

        </div>
    </details>
</div>


<p><details >
  <summary markdown="span">SHOW IMAGE: Throughput VS. Threads</summary>
  <img loading="lazy" src="/img/multithreading/4-throughput-improvement.png" alt="Throughput VS. Threads"  />
</details></p>

<hr>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://signalyu.github.io/tags/engineering--technology/">Engineering &amp; Technology</a></li>
      <li><a href="https://signalyu.github.io/tags/computer-science/">Computer Science</a></li>
      <li><a href="https://signalyu.github.io/tags/multithreading--concurrency/">Multithreading &amp; Concurrency</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://signalyu.github.io/posts/3-humanities/languages/speaking/english/2-english-speaking-ielts-1-100/">
    <span class="title">« PREV</span>
    
    <br>
    <span>English Speaking: IELTS (1-100)</span>
  </a>
  <a class="next" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/asynchronous-messaging/1-asynchronous-messaging/">
    <span class="title">NEXT »</span>
    
    <br>
    <span>Asynchronous Messaging</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://signalyu.github.io/">Signal&#39;s Blog</a></span> · 
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>

</body>
</html>
