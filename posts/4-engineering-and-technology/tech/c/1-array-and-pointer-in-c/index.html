<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>C 语言中的数组与指针 | Signal&#39;s Blog</title>
<meta name="keywords" content="工程与技术, Tech, C">
<meta name="description" content="数组 数组基本概念 在 C 语言中，越界访问数组编译器并不会报错； 一维数组的长度计算：int length = sizeof(arr) / sizeof(arr[0]); sizeof 返回值的数据类型是 size_t ，所以 sizeof(a) / sizeof(a[0]) 的数据类型也是 size_t。在 printf() 里面的占位符，要用 %zd 或 %zu 。 一维数组的内存分析： 一维数组的内存分析 C 语言规定，数组变量一旦声明，数组名指向的地址就不可更改。因此，使用大括号赋值时，必须在数组声明时赋值，否则编译时会报错。 int nums[5]; nums = {1, 2, 3, 4, 5}; // 报错 int nums[5] = {1, 2, 3, 4, 5}; // 正确写法 数组的复制 使用循环复制数组： void copyArray(int src[], int dest[], int size) { for (int i = 0; i &lt; size; i&#43;&#43;) { dest[i] = src[i]; } } 使用 memcopy() 函数复制数组： #include &lt;string.">
<meta name="author" content="Signal Yu">
<link rel="canonical" href="https://signalyu.github.io/posts/4-engineering-and-technology/tech/c/1-array-and-pointer-in-c/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.9ddf6c021b47a5a861a7c6af241af938775e0fc65a762930d3a2426fc59e9a5c.css" integrity="sha256-nd9sAhtHpahhp8avJBr5OHdeD8Zadikw06JCb8Wemlw=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://signalyu.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://signalyu.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://signalyu.github.io/favicon-32x32">
<link rel="apple-touch-icon" href="https://signalyu.github.io/apple-touch-icon">
<link rel="mask-icon" href="https://signalyu.github.io/favicon.io">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://signalyu.github.io/posts/4-engineering-and-technology/tech/c/1-array-and-pointer-in-c/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
  

<meta property="og:title" content="C 语言中的数组与指针" />
<meta property="og:description" content="数组 数组基本概念 在 C 语言中，越界访问数组编译器并不会报错； 一维数组的长度计算：int length = sizeof(arr) / sizeof(arr[0]); sizeof 返回值的数据类型是 size_t ，所以 sizeof(a) / sizeof(a[0]) 的数据类型也是 size_t。在 printf() 里面的占位符，要用 %zd 或 %zu 。 一维数组的内存分析： 一维数组的内存分析 C 语言规定，数组变量一旦声明，数组名指向的地址就不可更改。因此，使用大括号赋值时，必须在数组声明时赋值，否则编译时会报错。 int nums[5]; nums = {1, 2, 3, 4, 5}; // 报错 int nums[5] = {1, 2, 3, 4, 5}; // 正确写法 数组的复制 使用循环复制数组： void copyArray(int src[], int dest[], int size) { for (int i = 0; i &lt; size; i&#43;&#43;) { dest[i] = src[i]; } } 使用 memcopy() 函数复制数组： #include &lt;string." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://signalyu.github.io/posts/4-engineering-and-technology/tech/c/1-array-and-pointer-in-c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-06-04T16:17:31+08:00" />
<meta property="article:modified_time" content="2024-06-04T16:17:31+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="C 语言中的数组与指针"/>
<meta name="twitter:description" content="数组 数组基本概念 在 C 语言中，越界访问数组编译器并不会报错； 一维数组的长度计算：int length = sizeof(arr) / sizeof(arr[0]); sizeof 返回值的数据类型是 size_t ，所以 sizeof(a) / sizeof(a[0]) 的数据类型也是 size_t。在 printf() 里面的占位符，要用 %zd 或 %zu 。 一维数组的内存分析： 一维数组的内存分析 C 语言规定，数组变量一旦声明，数组名指向的地址就不可更改。因此，使用大括号赋值时，必须在数组声明时赋值，否则编译时会报错。 int nums[5]; nums = {1, 2, 3, 4, 5}; // 报错 int nums[5] = {1, 2, 3, 4, 5}; // 正确写法 数组的复制 使用循环复制数组： void copyArray(int src[], int dest[], int size) { for (int i = 0; i &lt; size; i&#43;&#43;) { dest[i] = src[i]; } } 使用 memcopy() 函数复制数组： #include &lt;string."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://signalyu.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "C 语言中的数组与指针",
      "item": "https://signalyu.github.io/posts/4-engineering-and-technology/tech/c/1-array-and-pointer-in-c/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "C 语言中的数组与指针",
  "name": "C 语言中的数组与指针",
  "description": "数组 数组基本概念 在 C 语言中，越界访问数组编译器并不会报错； 一维数组的长度计算：int length = sizeof(arr) / sizeof(arr[0]); sizeof 返回值的数据类型是 size_t ，所以 sizeof(a) / sizeof(a[0]) 的数据类型也是 size_t。在 printf() 里面的占位符，要用 %zd 或 %zu 。 一维数组的内存分析： 一维数组的内存分析 C 语言规定，数组变量一旦声明，数组名指向的地址就不可更改。因此，使用大括号赋值时，必须在数组声明时赋值，否则编译时会报错。 int nums[5]; nums = {1, 2, 3, 4, 5}; // 报错 int nums[5] = {1, 2, 3, 4, 5}; // 正确写法 数组的复制 使用循环复制数组： void copyArray(int src[], int dest[], int size) { for (int i = 0; i \u003c size; i++) { dest[i] = src[i]; } } 使用 memcopy() 函数复制数组： #include \u0026lt;string.",
  "keywords": [
    "工程与技术", "Tech", "C"
  ],
  "articleBody": "数组 数组基本概念 在 C 语言中，越界访问数组编译器并不会报错； 一维数组的长度计算：int length = sizeof(arr) / sizeof(arr[0]); sizeof 返回值的数据类型是 size_t ，所以 sizeof(a) / sizeof(a[0]) 的数据类型也是 size_t。在 printf() 里面的占位符，要用 %zd 或 %zu 。 一维数组的内存分析： 一维数组的内存分析 C 语言规定，数组变量一旦声明，数组名指向的地址就不可更改。因此，使用大括号赋值时，必须在数组声明时赋值，否则编译时会报错。 int nums[5]; nums = {1, 2, 3, 4, 5}; // 报错 int nums[5] = {1, 2, 3, 4, 5}; // 正确写法 数组的复制 使用循环复制数组： void copyArray(int src[], int dest[], int size) { for (int i = 0; i \u003c size; i++) { dest[i] = src[i]; } } 使用 memcopy() 函数复制数组： #include int main() { // ... memcpy(dest, src, sizeof(src)); return 0; } 使用指针对数组进行赋值和遍历 使用指针变量对数组进行赋值和遍历的效率比下标法高。\n#include #define N 5 int main() { int a[N]; int *p = a; printf(\"请输入%d个整数：\\n\", N); for (int i = 0; i \u003c N; i++) { scanf(\"%d\", p + i); } for (int i = 0; i \u003c N; i++) { printf(\"%d \", *(p + i)); } printf(\"\\n\"); return 0; } 点击查看题目 下列 C 语言代码是否正确？ #include #define N 5 int main() { int a[N]; int *p = a; printf(\"请输入%d个整数：\\n\", N); for (int i = 0; i \u003c N; i++) { scanf(\"%d\", \u0026a[i]); } for (p = a; a \u003c (p + N); a++) { printf(\"%d\", *a); } printf(\"\\n\"); return 0; } 点击查看答案 下列代码不正确： for (p = a; a \u003c (p + N); a++) { printf(\"%d\", *a); } 数组名 a 代表数组的首地址（或数组首元素的地址），它是一个指针型常量 ，它的值在程序运行期间是固定不变的。所以 a++ 是无法实现的。必须将 a 的地址赋值给指针变量 p ，然后对 p 进行自增。正确写法为： for (p = a; p \u003c (a + N); p++) { printf(\"%d \", *p); } 指针 指针的基本概念 变量：命名的内存空间，用于存放各种类型的数据； 变量名：为标记某块内存空间而采用的便于记忆的名字； 变量值：在变量单元中存放的数据值； 指针：指针是指变量所使用的内存空间的地址； 变量名 内存地址 内容 i 0x00000001 1 0x00000002 0x00000003 0x00000004 j 0x00000005 2 0x00000006 0x00000007 0x00000008 指针变量：指针变量是一个专门用来存放另一变量在内存中数据的地址的变量。通过访问指针变量，可以访问内存中另一个变量数据。 指针变量 指针的本质及其运算 指针本质上是一个代表内存地址的无符号整数。因此它可以进行整数加减，自增自减、同类指针相减等操作，但运算规则并不是整数运算规则。 指针与整数值的加减运算：表示指针所指向内存地址的移动。指针移动的单位，与指针指向的数据类型有关。数据类型占据多少个字节，每单位就移动多少个字节。 注意：只有指向连续的同类型数据区域，指针加、减整数才有实际意义。 指针的自增与自减：指针的增加或减少是指内存地址的向前或向后移动。 int arr[] = {1, 2, 3}; int *p = \u0026arr; printf(\"arr[0] = %d\\n\", *p); // arr[0] = 1 printf(\"arr[1] = %d\\n\", *(++p)); // arr[1] = 2 同类指针相减运算：相同类型的指针允许进行减法运算，返回它们之间的距离，即相隔多少个数据单位（非字节数）。返回的值属于头文件 stddef.h 里面的 ptrdiff_t 类型，这是一个带符号的整数类型别名，具体类型根据系统不同而不同。 #include #include int main() { short *ps1; short *ps2; ps1 = (short *) 0x1234; ps2 = (short *) 0x1236; ptrdiff_t dist = ps2 - ps1; printf(\"%d\\n\", dist); // 1（相差2个字节正好存放1个short类型的值） int *pi1; int *pi2; pi1 = (int *) 0x1234; pi2 = (int *) 0x1244; ptrdiff_t dist1 = pi2 - pi1; printf(\"%d\\n\",dist1); // 4（相差16个字节正好存放4个int类型的值） return 0; } 指针间的比较运算：比较各自的内存地址的大小，返回值是整数 1（true）或 0（false）。 取址运算符（\u0026）：取之运算符用于取出指定变量在内存中的地址。 int num = 10; int *p; // p 为整型指针变量，建议写成 int *p = NULL; p = \u0026num; // 必须为整型指针 printf(\"\u0026num = %p\", \u0026num); // 格式输出符为 %p 取值运算符（*）：取值运算符用于获取给定内存地址的数据值，它与取址运算符（\u0026）互为逆运算。 int num = 10; int *p; // p 为整型指针变量，建议写成 int *p = NULL; p = \u0026num; // 必须为整型指针 printf(\"\u0026num = %p\\n\", \u0026num); // 格式输出符为 %p printf(\"num = %d\", *p); // 取出指针 p 的值 野指针 野指针：野指针指的是指向未知知内存的一类指针； 野指针的成因主要有如下三种： 指针使用前未初始化：指针变量在定义时如果未初始化，其值是随机的，此时操作指针就是去访问一个不确定的地址，所以结果是不可知的。此时 p 为野指针。 int *p; // 建议写成 int *p = NULL; printf(\"%d\\n\", *p); // 输出的值每次都不一样 指针越界访问： int arr[10] = {0}; int *p = arr; for (int i = 0; i \u003c= 10; i++, p++) { *p = i; // i = 10 时越界 } 指针指向已释放的空间： test.c 输出结果 #include #include int *test() { int a = 10; return \u0026a; } int main() { int *p = test(); printf(\"*p = %d\", *p); printf(\"\\n暂停两秒...\\n\"); sleep(2); // 暂停两秒 printf(\"*p = %d\\n\", *p); return 0; } $ gcc -Wall -o test test.c test.c:6:13: warning: address of stack memory associated with local variable 'a' returned [-Wreturn-stack-address] return \u0026a; ^ 1 warning generated. $ ./test *p = 10 暂停两秒... *p = 1 调用 test 函数将返回值赋给 p，test 函数的返回值是局部变量 a 的地址。由于 a 只在 test 函数内有效，出了 test 函数其内存空间就被释放，也就意味着 a 的地址编号不存在，若将其赋值给 p，导致 p 获取到的地址是无效的。如果短时间内再次利用这块地址，它的值还未被改变，此时 p 的值为 a 的地址值，*p 返回 10。如果在打印之前有其他函数调用了这块地址，这块地址的名称就会发生变化，*p 不再返回 10。 野指针的避免： 定义指针时，如果没有确切的地址赋值，应该为指针变量赋一个NULL值。即： int *p = NULL; 赋为NULL值的指针被称为空指针，NULL指针是一个定义在标准库中的值为零的常量#define NULL 0。 访问数组元素时，避免越界(0 ≤ i \u003c arr.length)访问。 避免将函数返回的局部变量的地址值赋值给指针。 指针指向的空间被释放时，应该及时将指针置为NULL。 int *ptr = (int *) malloc(sizeof(int)); free(ptr); // 释放内存 ptr = NULL; // 将指针设置为 NULL 指针使用之前应进行有效性检查： if (ptr != NULL) { // ... } 二级指针 二级指针是指一个指针变量的值是另一个指针变量的地址。 int a = 20; int *pa = \u0026a; // pa是一级指针 int **ppa = \u0026pa; // ppa是二级指针，类型为int ** 二级指针 数组指针与指针数组 数组指针是指存放数组首地址的指针变量；指针数组是指存放指针的数组。 ###添加案例 数组指针与指针数组 字符数组和字符指针变量 字符数组由若干个元素组成，每个元素存放一个字符。 char str[] = \"signal\"; // 使用字符数组 字符数组 字符指针变量中存放的是地址（字符串或字符数组的首地址）。 char *pStr = \"signal\"; // 使用字符指针 字符指针 对已声明好的字符数组，只能一一对各个元素赋值，而不能对整个字符数组赋值： char str[14]; str[0] = 'i'; // 正确 str = \"signal\"; // 错误，不能对整个字符数组赋值 对已声明好的字符指针变量，可以采用如下方式赋值： char *pStr = \"\"; pStr = \"signal\"; // 正确 字符指针重新赋值 一个字符数组，因为它有确定的内存地址，所以字符数组名是一个常量 。而定义一个字符指针变量时，它在指向某个确定的字符串数据的情况下，可以多次重新赋值 。 字符串字面量存储在只读内存区域，是不可变的，不能修改其值。 char arr[] = \"hello\"; arr[1] = \"m\"; // 运行时错误 char *pStr = \"hello\"; pStr = \"hello tom\"; // 正确 pStr[1] = 'm'; // 运行时错误 ",
  "wordCount" : "697",
  "inLanguage": "en",
  "datePublished": "2024-06-04T16:17:31+08:00",
  "dateModified": "2024-06-04T16:17:31+08:00",
  "author":{
    "@type": "Person",
    "name": "Signal Yu"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://signalyu.github.io/posts/4-engineering-and-technology/tech/c/1-array-and-pointer-in-c/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Signal's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://signalyu.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://signalyu.github.io/" accesskey="h" title="Signal&#39;s Blog (Alt + H)">
                <img src="https://signalyu.github.io/apple-touch-icon.png" alt="" aria-label="logo"
                    height="40">Signal&#39;s Blog</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://signalyu.github.io/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://signalyu.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://signalyu.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://signalyu.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://signalyu.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      C 语言中的数组与指针
    </h1>
    <div class="post-meta"><span title='2024-06-04 16:17:31 +0800 HKT'>Jun 4 2024</span>&nbsp;·&nbsp;Signal Yu

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e6%95%b0%e7%bb%84" aria-label="数组">数组</a><ul>
                        
                <li>
                    <a href="#%e6%95%b0%e7%bb%84%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5" aria-label="数组基本概念">数组基本概念</a></li>
                <li>
                    <a href="#%e6%95%b0%e7%bb%84%e7%9a%84%e5%a4%8d%e5%88%b6" aria-label="数组的复制">数组的复制</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8%e6%8c%87%e9%92%88%e5%af%b9%e6%95%b0%e7%bb%84%e8%bf%9b%e8%a1%8c%e8%b5%8b%e5%80%bc%e5%92%8c%e9%81%8d%e5%8e%86" aria-label="使用指针对数组进行赋值和遍历">使用指针对数组进行赋值和遍历</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%8c%87%e9%92%88" aria-label="指针">指针</a><ul>
                        
                <li>
                    <a href="#%e6%8c%87%e9%92%88%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5" aria-label="指针的基本概念">指针的基本概念</a></li>
                <li>
                    <a href="#%e6%8c%87%e9%92%88%e7%9a%84%e6%9c%ac%e8%b4%a8%e5%8f%8a%e5%85%b6%e8%bf%90%e7%ae%97" aria-label="指针的本质及其运算">指针的本质及其运算</a></li>
                <li>
                    <a href="#%e9%87%8e%e6%8c%87%e9%92%88" aria-label="野指针">野指针</a></li>
                <li>
                    <a href="#%e4%ba%8c%e7%ba%a7%e6%8c%87%e9%92%88" aria-label="二级指针">二级指针</a></li>
                <li>
                    <a href="#%e6%95%b0%e7%bb%84%e6%8c%87%e9%92%88%e4%b8%8e%e6%8c%87%e9%92%88%e6%95%b0%e7%bb%84" aria-label="数组指针与指针数组">数组指针与指针数组</a></li>
                <li>
                    <a href="#%e5%ad%97%e7%ac%a6%e6%95%b0%e7%bb%84%e5%92%8c%e5%ad%97%e7%ac%a6%e6%8c%87%e9%92%88%e5%8f%98%e9%87%8f" aria-label="字符数组和字符指针变量">字符数组和字符指针变量</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="数组">数组<a hidden class="anchor" aria-hidden="true" href="#数组">#</a></h1>
<h2 id="数组基本概念">数组基本概念<a hidden class="anchor" aria-hidden="true" href="#数组基本概念">#</a></h2>
<ol>
<li>在 <code>C</code> 语言中，越界访问数组编译器并不会报错；</li>
<li>一维数组的长度计算：<code>int length = sizeof(arr) / sizeof(arr[0])</code>; <code>sizeof</code> 返回值的数据类型是 <code>size_t</code> ，所以 <code>sizeof(a) / sizeof(a[0])</code> 的数据类型也是 <code>size_t</code>。在 <code>printf()</code> 里面的占位符，要用 %zd 或 %zu 。</li>
<li>一维数组的内存分析：<figure class="align-center ">
    <img loading="lazy" src="/img/tech/c/1-c.png#center" width="100%" height="100%"/> <figcaption>
            一维数组的内存分析
        </figcaption>
</figure>
</li>
<li>C 语言规定，数组变量一旦声明，数组名指向的地址就不可更改。因此，使用大括号赋值时，必须在数组声明时赋值，否则编译时会报错。<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-c" data-lang="c" >int nums[5];
nums = {1, 2, 3, 4, 5};  // 报错

int nums[5] = {1, 2, 3, 4, 5}; // 正确写法
</code></pre>
    </div>
</div></li>
</ol>
<h2 id="数组的复制">数组的复制<a hidden class="anchor" aria-hidden="true" href="#数组的复制">#</a></h2>
<ol>
<li>使用循环复制数组：<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-c" data-lang="c" >void copyArray(int src[], int dest[], int size) {
    for (int i = 0; i < size; i++) {
        dest[i] = src[i];
    }
}
</code></pre>
    </div>
</div></li>
<li>使用 <code>memcopy()</code> 函数复制数组：<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-c" data-lang="c" >#include &lt;string.h&gt;

int main() {
    // ...
    memcpy(dest, src, sizeof(src));
    
    return 0;
}
</code></pre>
    </div>
</div></li>
</ol>
<h2 id="使用指针对数组进行赋值和遍历">使用指针对数组进行赋值和遍历<a hidden class="anchor" aria-hidden="true" href="#使用指针对数组进行赋值和遍历">#</a></h2>
<p><strong>使用指针变量对数组进行赋值和遍历的效率比下标法高。</strong></p>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-c" data-lang="c" >#include &lt;stdio.h&gt;

#define N 5

int main() {
    int a[N];
    int *p = a;
    
    printf("请输入%d个整数：\n", N);
    for (int i = 0; i < N; i++) {
        scanf("%d", p + i);
    }

    for (int i = 0; i < N; i++) {
        printf("%d ", *(p + i));
    }
    printf("\n");
    return 0;
}
</code></pre>
    </div>
</div>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看题目</summary>
        <div>
            
<link rel="stylesheet" href="/css/notice.css">


<div class="notice info">
    下列 C 语言代码是否正确？
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-c" data-lang="c" >#include &lt;stdio.h&gt;

#define N 5

int main() {
    int a[N];
    int *p = a;

    printf("请输入%d个整数：\n", N);
    for (int i = 0; i < N; i++) {
        scanf("%d", &a[i]); 
    }
    for (p = a; a < (p + N); a++) {
        printf("%d", *a);
    }
    printf("\n");
    
    return 0;
}
</code></pre>
    </div>
</div>

        </div>
    </details>
</div>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details>
        <summary>点击查看答案</summary>
        <div>
            
<link rel="stylesheet" href="/css/notice.css">


<div class="notice info">
    下列代码不正确：
</div>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-c" data-lang="c" >for (p = a; a < (p + N); a++) {
    printf("%d", *a);
}
</code></pre>
    </div>
</div>
<link rel="stylesheet" href="/css/notice.css">


<div class="notice info">
    数组名 a 代表数组的首地址（或数组首元素的地址），它是一个指针型常量 ，它的值在程序运行期间是固定不变的。所以 a++ 是无法实现的。必须将 a 的地址赋值给指针变量 p ，然后对 p 进行自增。正确写法为：
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-c" data-lang="c" >for (p = a; p < (a + N); p++) {
    printf("%d ", *p);
}
</code></pre>
    </div>
</div>

        </div>
    </details>
</div>
<h1 id="指针">指针<a hidden class="anchor" aria-hidden="true" href="#指针">#</a></h1>
<h2 id="指针的基本概念">指针的基本概念<a hidden class="anchor" aria-hidden="true" href="#指针的基本概念">#</a></h2>
<ol>
<li><strong>变量</strong>：命名的内存空间，用于存放各种类型的数据；</li>
<li><strong>变量名</strong>：为标记某块内存空间而采用的便于记忆的名字；</li>
<li><strong>变量值</strong>：在变量单元中存放的数据值；</li>
<li><strong>指针</strong>：指针是指变量所使用的内存空间的地址；<style>
    table {
        width: 100%;
        font-size: 18px;
    }
    tr, th, td {
        border: 2px solid #dee4eb;  
        padding: 5px;  
    }
</style>



<table>
    
    
<tr>
  <th>变量名</th>
  <th>内存地址</th>
  <th>内容</th>
</tr>
<tr>
  <td rowspan="4">i</td>
  <td>0x00000001</td>
  <td rowspan="4">1</td>
</tr>
<tr>
  <td>0x00000002</td>
</tr>
<tr>
  <td>0x00000003</td>
</tr>
<tr>
  <td>0x00000004</td>
</tr>
<tr>
  <td rowspan="4">j</td>
  <td>0x00000005</td>
  <td rowspan="4">2</td>
</tr>
<tr>
  <td>0x00000006</td>
</tr>
<tr>
  <td>0x00000007</td>
</tr>
<tr>
  <td>0x00000008</td>
</tr>

</table></li>
<li><strong>指针变量</strong>：指针变量是一个专门用来存放另一变量在内存中数据的地址的变量。通过访问指针变量，可以访问内存中另一个变量数据。<figure class="align-center ">
    <img loading="lazy" src="/img/#center" width="100%" height="100%"/> <figcaption>
            指针变量
        </figcaption>
</figure>
</li>
</ol>
<h2 id="指针的本质及其运算">指针的本质及其运算<a hidden class="anchor" aria-hidden="true" href="#指针的本质及其运算">#</a></h2>
<ol>
<li><strong>指针本质上是一个代表内存地址的无符号整数</strong>。因此它可以进行整数加减，自增自减、同类指针相减等操作，但运算规则并不是整数运算规则。</li>
<li><strong>指针与整数值的加减运算</strong>：表示指针所指向内存地址的移动。指针移动的单位，与指针指向的数据类型有关。数据类型占据多少个字节，每单位就移动多少个字节。<link rel="stylesheet" href="/css/notice.css">


<div class="notice info">
    注意：只有指向连续的同类型数据区域，指针加、减整数才有实际意义。
</div></li>
<li><strong>指针的自增与自减</strong>：指针的增加或减少是指内存地址的向前或向后移动。<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-c" data-lang="c" >int arr[] = {1, 2, 3};
int *p = &amp;arr;
printf("arr[0] = %d\n", *p);  // arr[0] = 1
printf("arr[1] = %d\n", *(++p));  // arr[1] = 2
</code></pre>
    </div>
</div></li>
<li><strong>同类指针相减运算</strong>：相同类型的指针允许进行减法运算，返回它们之间的距离，即相隔多少个数据单位（非字节数）。返回的值属于头文件 stddef.h 里面的 ptrdiff_t 类型，这是一个带符号的整数类型别名，具体类型根据系统不同而不同。<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-c" data-lang="c" >#include &lt;stdio.h&gt;
#include &lt;stddef.h&gt;
int main() {
    short *ps1;
    short *ps2;
    ps1 = (short *) 0x1234;
    ps2 = (short *) 0x1236;
    ptrdiff_t dist = ps2 - ps1;
    printf("%d\n", dist); // 1（相差2个字节正好存放1个short类型的值）
    int *pi1;
    int *pi2;
    pi1 = (int *) 0x1234;
    pi2 = (int *) 0x1244;
    ptrdiff_t dist1 = pi2 - pi1;
    printf("%d\n",dist1);  // 4（相差16个字节正好存放4个int类型的值）
    return 0;
}
</code></pre>
    </div>
</div></li>
<li><strong>指针间的比较运算</strong>：比较各自的内存地址的大小，返回值是整数 1（true）或 0（false）。</li>
<li><strong>取址运算符（&amp;）</strong>：取之运算符用于取出指定变量在内存中的地址。<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-c" data-lang="c" >int num = 10;
int *p; // p 为整型指针变量，建议写成 int *p = NULL;
p = &amp;num; // 必须为整型指针
printf("&num = %p", &num); // 格式输出符为 %p
</code></pre>
    </div>
</div></li>
<li><strong>取值运算符（*）</strong>：取值运算符用于获取给定内存地址的数据值，它与取址运算符（&amp;）互为逆运算。<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-c" data-lang="c" >int num = 10;
int *p; // p 为整型指针变量，建议写成 int *p = NULL;
p = &amp;num; // 必须为整型指针
printf("&num = %p\n", &num); // 格式输出符为 %p
printf("num = %d", *p); // 取出指针 p 的值
</code></pre>
    </div>
</div></li>
</ol>
<h2 id="野指针">野指针<a hidden class="anchor" aria-hidden="true" href="#野指针">#</a></h2>
<ol>
<li><strong>野指针</strong>：野指针指的是指向未知知内存的一类指针；</li>
<li><strong>野指针的成因</strong>主要有如下三种：
<ol>
<li><strong>指针使用前未初始化</strong>：指针变量在定义时如果未初始化，其值是随机的，此时操作指针就是去访问一个不确定的地址，所以结果是不可知的。此时 p 为野指针。<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-c" data-lang="c" >int *p; // 建议写成 int *p = NULL;
printf("%d\n", *p); // 输出的值每次都不一样
</code></pre>
    </div>
</div></li>
<li>指针越界访问：<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-c" data-lang="c" >int arr[10] = {0};
int *p = arr;
for (int i = 0; i <= 10; i++, p++) {
    *p = i;  // i = 10 时越界
}
</code></pre>
    </div>
</div></li>
<li>指针指向已释放的空间：<link rel="stylesheet" href="/css/tabbed_code.css">


<div class="code_block_container">
    
<div class="tabs">
    



<button class="tab_btn active">test.c</button>



<button class="tab_btn ">输出结果</button>

</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-c" data-lang="c" >#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int *test() {
    int a = 10;
    return &amp;a;  
}

int main() {
    int *p = test();
    printf("*p = %d", *p);
    printf("\n暂停两秒...\n");
    sleep(2); // 暂停两秒
    printf("*p = %d\n", *p);
    return 0;
}
</code></pre>
    </div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block ">
        <pre><code class="language-bash" data-lang="bash" >$ gcc -Wall -o test test.c 
test.c:6:13: warning: address of stack memory associated with local variable 'a' returned [-Wreturn-stack-address]
    return &amp;a;  
            ^
1 warning generated.

$ ./test

*p = 10
暂停两秒...
*p = 1
</code></pre>
    </div>
</div>

</div>

<script src="/js/tabbed_code.js"></script><link rel="stylesheet" href="/css/notice.css">


<div class="notice info">
    调用 test 函数将返回值赋给 p，test 函数的返回值是局部变量 a 的地址。由于 a 只在 test 函数内有效，出了 test 函数其内存空间就被释放，也就意味着 a 的地址编号不存在，若将其赋值给 p，导致 p 获取到的地址是无效的。如果短时间内再次利用这块地址，它的值还未被改变，此时 p 的值为 a 的地址值，*p 返回 10。如果在打印之前有其他函数调用了这块地址，这块地址的名称就会发生变化，*p 不再返回 10。
</div></li>
</ol>
</li>
<li>野指针的避免：
<ol>
<li>定义指针时，如果没有确切的地址赋值，应该为指针变量赋一个<code>NULL</code>值。即：<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-c" data-lang="c" >int *p = NULL;
</code></pre>
    </div>
</div>赋为<code>NULL</code>值的指针被称为空指针，<code>NULL</code>指针是一个定义在标准库中的值为零的常量<code>#define NULL 0</code>。</li>
<li>访问数组元素时，避免越界<code>(0 ≤ i &lt; arr.length)</code>访问。</li>
<li>避免将函数返回的局部变量的地址值赋值给指针。</li>
<li>指针指向的空间被释放时，应该及时将指针置为<code>NULL</code>。<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-c" data-lang="c" >int *ptr = (int *) malloc(sizeof(int));
free(ptr);  // 释放内存
ptr = NULL;  // 将指针设置为 NULL
</code></pre>
    </div>
</div></li>
<li>指针使用之前应进行有效性检查：<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-c" data-lang="c" >if (ptr != NULL) {
    // ...
}
</code></pre>
    </div>
</div></li>
</ol>
</li>
</ol>
<h2 id="二级指针">二级指针<a hidden class="anchor" aria-hidden="true" href="#二级指针">#</a></h2>
<p><strong>二级指针</strong>是指一个指针变量的值是另一个指针变量的地址。<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-c" data-lang="c" >int a = 20;
int *pa = &a;  // pa是一级指针
int **ppa = &pa; // ppa是二级指针，类型为int **
</code></pre>
    </div>
</div><figure class="align-center ">
    <img loading="lazy" src="/img/#center" width="100%" height="100%"/> <figcaption>
            二级指针
        </figcaption>
</figure>
</p>
<h2 id="数组指针与指针数组">数组指针与指针数组<a hidden class="anchor" aria-hidden="true" href="#数组指针与指针数组">#</a></h2>
<p><strong>数组指针</strong>是指存放数组首地址的指针变量；<strong>指针数组</strong>是指存放指针的数组。
###添加案例
<figure class="align-center ">
    <img loading="lazy" src="/img/#center" width="100%" height="100%"/> <figcaption>
            数组指针与指针数组
        </figcaption>
</figure>
</p>
<h2 id="字符数组和字符指针变量">字符数组和字符指针变量<a hidden class="anchor" aria-hidden="true" href="#字符数组和字符指针变量">#</a></h2>
<ol>
<li><strong>字符数组</strong>由若干个元素组成，每个元素存放一个字符。<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-c" data-lang="c" >char str[] = "signal";  // 使用字符数组
</code></pre>
    </div>
</div><figure class="align-center ">
    <img loading="lazy" src="/img/#center" width="100%" height="100%"/> <figcaption>
            字符数组
        </figcaption>
</figure>
</li>
<li><strong>字符指针</strong>变量中存放的是地址（字符串或字符数组的首地址）。<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-c" data-lang="c" >char *pStr = "signal";  // 使用字符指针
</code></pre>
    </div>
</div><figure class="align-center ">
    <img loading="lazy" src="/img/#center" width="100%" height="100%"/> <figcaption>
            字符指针
        </figcaption>
</figure>
</li>
<li>对已声明好的字符数组，只能一一对各个元素赋值，而不能对整个字符数组赋值：<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-c" data-lang="c" >char str[14];
str[0] = 'i'; // 正确
str = "signal"; // 错误，不能对整个字符数组赋值
</code></pre>
    </div>
</div></li>
<li>对已声明好的字符指针变量，可以采用如下方式赋值：<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-c" data-lang="c" >char *pStr = "";
pStr = "signal"; // 正确
</code></pre>
    </div>
</div><figure class="align-center ">
    <img loading="lazy" src="/img/#center" width="100%" height="100%"/> <figcaption>
            字符指针重新赋值
        </figcaption>
</figure>
<link rel="stylesheet" href="/css/notice.css">


<div class="notice info">
    <strong>一个字符数组，因为它有确定的内存地址，所以字符数组名是一个常量 。而定义一个字符指针变量时，它在指向某个确定的字符串数据的情况下，可以多次重新赋值 。</strong>
</div></li>
<li><strong>字符串字面量</strong>存储在只读内存区域，是不可变的，不能修改其值。<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-c" data-lang="c" >char arr[] = "hello";
arr[1] = "m";  // 运行时错误
char *pStr = "hello";
pStr = "hello tom"; // 正确
pStr[1] = 'm';  // 运行时错误
</code></pre>
    </div>
</div></li>
</ol>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://signalyu.github.io/tags/%E5%B7%A5%E7%A8%8B%E4%B8%8E%E6%8A%80%E6%9C%AF/">工程与技术</a></li>
      <li><a href="https://signalyu.github.io/tags/tech/">Tech</a></li>
      <li><a href="https://signalyu.github.io/tags/c/">C</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://signalyu.github.io/posts/1-natural-science/math/calculus/4-derivative-and-differential/">
    <span class="title">« PREV</span>
    
    <br>
    <span>导数与微分</span>
  </a>
  <a class="next" href="https://signalyu.github.io/posts/4-engineering-and-technology/computer-science/data-structures-and-algorithms/algorithms/1-boyer-moore-voting-algorithm/">
    <span class="title">NEXT »</span>
    
    <br>
    <span>数据结构与算法：投票算法</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://signalyu.github.io/">Signal&#39;s Blog</a></span> · 
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>

</body>
</html>
