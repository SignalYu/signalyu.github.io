<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Java 私有成员继承 | 信一的博客</title>
<meta name="keywords" content="工程与技术, Tech, Java">
<meta name="description" content="子类对象拥有父类的私有成员，但子类不继承父类的私有属性。 子类对象包含父类私有属性 首先验证子类对象包含父类的私有属性，代码如下：
点击查看代码 class Parent { private int privateField; public Parent() { System.out.println(&#34;this in Parent() =&gt; &#34; &#43; this); this.privateField = 666; } public Parent(int privateField) { System.out.println(&#34;this in Parent(int) =&gt; &#34; &#43; this); this.privateField = privateField; } private void printPrivateField() { System.out.println(this.privateField); } public void accessPrivateMembers() { System.out.println(&#34;this in accessPrivateMembers() =&gt; &#34; &#43; this); System.out.print(&#34;调用 this.printPrivateField() 方法 =&gt; &#34;); this.printPrivateField(); } } class Child extends Parent { public Child() { System.">
<meta name="author" content="Signal Yu">
<link rel="canonical" href="https://signalyu.github.io/posts/4-engineering-and-technology/tech/java/1-java-private-inheritance/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.9ddf6c021b47a5a861a7c6af241af938775e0fc65a762930d3a2426fc59e9a5c.css" integrity="sha256-nd9sAhtHpahhp8avJBr5OHdeD8Zadikw06JCb8Wemlw=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://signalyu.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://signalyu.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://signalyu.github.io/favicon-32x32">
<link rel="apple-touch-icon" href="https://signalyu.github.io/apple-touch-icon">
<link rel="mask-icon" href="https://signalyu.github.io/favicon.io">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://signalyu.github.io/posts/4-engineering-and-technology/tech/java/1-java-private-inheritance/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css"
    integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"
    integrity="sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd"
    crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js"
    integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk"
    crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: true }
            ],
            
            throwOnError: false,
            strict: false
        });
    });
</script>

  

<meta property="og:title" content="Java 私有成员继承" />
<meta property="og:description" content="子类对象拥有父类的私有成员，但子类不继承父类的私有属性。 子类对象包含父类私有属性 首先验证子类对象包含父类的私有属性，代码如下：
点击查看代码 class Parent { private int privateField; public Parent() { System.out.println(&#34;this in Parent() =&gt; &#34; &#43; this); this.privateField = 666; } public Parent(int privateField) { System.out.println(&#34;this in Parent(int) =&gt; &#34; &#43; this); this.privateField = privateField; } private void printPrivateField() { System.out.println(this.privateField); } public void accessPrivateMembers() { System.out.println(&#34;this in accessPrivateMembers() =&gt; &#34; &#43; this); System.out.print(&#34;调用 this.printPrivateField() 方法 =&gt; &#34;); this.printPrivateField(); } } class Child extends Parent { public Child() { System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://signalyu.github.io/posts/4-engineering-and-technology/tech/java/1-java-private-inheritance/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-04-23T15:31:50+08:00" />
<meta property="article:modified_time" content="2024-04-23T15:31:50+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Java 私有成员继承"/>
<meta name="twitter:description" content="子类对象拥有父类的私有成员，但子类不继承父类的私有属性。 子类对象包含父类私有属性 首先验证子类对象包含父类的私有属性，代码如下：
点击查看代码 class Parent { private int privateField; public Parent() { System.out.println(&#34;this in Parent() =&gt; &#34; &#43; this); this.privateField = 666; } public Parent(int privateField) { System.out.println(&#34;this in Parent(int) =&gt; &#34; &#43; this); this.privateField = privateField; } private void printPrivateField() { System.out.println(this.privateField); } public void accessPrivateMembers() { System.out.println(&#34;this in accessPrivateMembers() =&gt; &#34; &#43; this); System.out.print(&#34;调用 this.printPrivateField() 方法 =&gt; &#34;); this.printPrivateField(); } } class Child extends Parent { public Child() { System."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://signalyu.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Java 私有成员继承",
      "item": "https://signalyu.github.io/posts/4-engineering-and-technology/tech/java/1-java-private-inheritance/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java 私有成员继承",
  "name": "Java 私有成员继承",
  "description": "子类对象拥有父类的私有成员，但子类不继承父类的私有属性。 子类对象包含父类私有属性 首先验证子类对象包含父类的私有属性，代码如下： 点击查看代码 class Parent { private int privateField; public Parent() { System.out.println(\"this in Parent() =\u003e \" + this); this.privateField = 666; } public Parent(int privateField) { System.out.println(\"this in Parent(int) =\u003e \" + this); this.privateField = privateField; } private void printPrivateField() { System.out.println(this.privateField); } public void accessPrivateMembers() { System.out.println(\"this in accessPrivateMembers() =\u003e \" + this); System.out.print(\"调用 this.printPrivateField() 方法 =\u003e \"); this.printPrivateField(); } } class Child extends Parent { public Child() { System.",
  "keywords": [
    "工程与技术", "Tech", "Java"
  ],
  "articleBody": " 子类对象拥有父类的私有成员，但子类不继承父类的私有属性。 子类对象包含父类私有属性 首先验证子类对象包含父类的私有属性，代码如下：\n点击查看代码 class Parent { private int privateField; public Parent() { System.out.println(\"this in Parent() =\u003e \" + this); this.privateField = 666; } public Parent(int privateField) { System.out.println(\"this in Parent(int) =\u003e \" + this); this.privateField = privateField; } private void printPrivateField() { System.out.println(this.privateField); } public void accessPrivateMembers() { System.out.println(\"this in accessPrivateMembers() =\u003e \" + this); System.out.print(\"调用 this.printPrivateField() 方法 =\u003e \"); this.printPrivateField(); } } class Child extends Parent { public Child() { System.out.println(\"this in Child() =\u003e \" + this); } } public class Main { public static void main(String[] args) { Child child = new Child(); child.accessPrivateMembers(); } } 上述代码输出结果为：\nthis in Parent() =\u003e Child@372f7a8d this in Child() =\u003e Child@372f7a8d this in accessPrivateMembers() =\u003e Child@372f7a8d 调用 this.printPrivateField() 方法 =\u003e 666 上述代码的输出结果表明，执行 new Child() 后，会调用子类 Child 的无参构造器，而在子类构造器中默认会调用父类的无参构造器。而从输出结果可知，父类无参构造中的 this 指向子类 Child。并且 this.privateField = 666; 也成功执行。同样地，在调用公有（public）方法 accessPrivateMembers() 时，此时的 this 为 Child，并且通过 this 也可以访问父类的私有方法 printPrivateFields()。显然，this 中包含父类的私有属性 privateField 和私有方法 printPrivateField()。事实上，可以通过 org.openjdk.jol 工具中的 ClassLayout 来查看 child 对象在内存中的布局。代码如下：\n点击查看代码 import org.openjdk.jol.info.ClassLayout; class Parent { private int privateField; public Parent() { System.out.println(\"this in Parent() =\u003e \" + this); this.privateField = 666; } public Parent(int privateField) { System.out.println(\"this in Parent(int) =\u003e \" + this); this.privateField = privateField; } private void printPrivateField() { System.out.println(this.privateField); } public void accessPrivateMembers() { System.out.println(\"this in accessPrivateMembers() =\u003e \" + this); System.out.print(\"调用 this.printPrivateField() 方法 =\u003e \"); this.printPrivateField(); } } class Child extends Parent { public Child() { System.out.println(\"this in Child() =\u003e \" + this); } } public static void main(String[] args) { Child child = new Child(); String childLayout = ClassLayout.parseInstance(child).toPrintable(); System.out.println(childLayout); } 上述代码输出结果为：\nChild object internals: OFF SZ TYPE DESCRIPTION VALUE 0 8 (object header: mark) 0x000000372f7a8d01 (hash: 0x372f7a8d; age: 0) 8 4 (object header: class) 0x01001418 12 4 int Parent.privateField 666 Instance size: 16 bytes Space losses: 0 bytes internal + 0 bytes external = 0 bytes total 根据上述输出结果可以看出，child 对象中确实包含父类的私有属性。\nJava 语言规范中关于类成员的规定 Java 类成员 Java 语言规范中关于类成的部分陈述如下：\n类的成员包括以下所有成员（The members of a class type are all of the following）：\n从除 Object 类之外的直接父类继承的成员（Members inherited from its direct superclass, except in class Object, which has no direct superclass） 从任何直接父接口继承的成员（Members inherited from any direct superinterfaces） 类中声明的成员（Members declared in the body of the class） 类中声明为私有的成员不会被该类的子类继承。（Members of a class that are declared private are not inherited by subclasses of that class.）\n只有声明为受保护（protected）或公共（public）的类成员才会被本包外的子类继承。（Only members of a class that are declared protected or public are inherited by subclasses declared in a package other than the one in which the class is declared.）\n构造器（constructors）、静态初始化器（static initializers）和实例初始化器（instance initializers）不是类成员，因此不会被继承。（Constructors, static initializers, and instance initializers are not members and therefore are not inherited.）\n超类的私有成员 Oracle 官方 Java 教程中关于超类的私有成员的说明：\n子类不继承父类的私有成员。不过，如果超类有访问其私有字段的公共或保护方法，子类也可以使用这些方法（间接访问父类的私有属性）。（A subclass does not inherit the private members of its parent class. However, if the superclass has public or protected methods for accessing its private fields, these can also be used by the subclass.）\n官方已明确说明子类不继承父类的私有成员，那为什么子类对象可以访问父类的私有成员呢？博主认为，继承是发生在类之间行为，而非对象之间的行为。子类 Child 不继承父类 Parent 的私有成员，并不代表子类对象 child 不可以拥有父类的私有成员。 参考资料 知乎：java中子类有没有继承父类的私有变量？ Java Language Specification : 8.2. Class Members Oracle Java Tutorial: Private Members in a Superclass Do subclasses inherit private fields? ",
  "wordCount" : "474",
  "inLanguage": "en",
  "datePublished": "2024-04-23T15:31:50+08:00",
  "dateModified": "2024-04-23T15:31:50+08:00",
  "author":{
    "@type": "Person",
    "name": "Signal Yu"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://signalyu.github.io/posts/4-engineering-and-technology/tech/java/1-java-private-inheritance/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "信一的博客",
    "logo": {
      "@type": "ImageObject",
      "url": "https://signalyu.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://signalyu.github.io/" accesskey="h" title="信一的博客 (Alt + H)">
                <img src="https://signalyu.github.io/apple-touch-icon.png" alt="" aria-label="logo"
                    height="40">信一的博客</a>
            <div class="logo-switches">
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://signalyu.github.io/archives/" title="档案">
                    <span>档案</span>
                </a>
            </li>
            <li>
                <a href="https://signalyu.github.io/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="https://signalyu.github.io/search/" title="搜索 (Alt &#43; /)" accesskey=/>
                    <span>搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://signalyu.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://signalyu.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Java 私有成员继承
    </h1>
    <div class="post-meta"><span title='2024-04-23 15:31:50 +0800 HKT'>2024年4月23日</span>&nbsp;·&nbsp;Signal Yu

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
            
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%ad%90%e7%b1%bb%e5%af%b9%e8%b1%a1%e5%8c%85%e5%90%ab%e7%88%b6%e7%b1%bb%e7%a7%81%e6%9c%89%e5%b1%9e%e6%80%a7" aria-label="子类对象包含父类私有属性">子类对象包含父类私有属性</a></li>
                <li>
                    <a href="#java-%e8%af%ad%e8%a8%80%e8%a7%84%e8%8c%83%e4%b8%ad%e5%85%b3%e4%ba%8e%e7%b1%bb%e6%88%90%e5%91%98%e7%9a%84%e8%a7%84%e5%ae%9a" aria-label="Java 语言规范中关于类成员的规定">Java 语言规范中关于类成员的规定</a><ul>
                        
                <li>
                    <a href="#java-%e7%b1%bb%e6%88%90%e5%91%98" aria-label="Java 类成员">Java 类成员</a></li>
                <li>
                    <a href="#%e8%b6%85%e7%b1%bb%e7%9a%84%e7%a7%81%e6%9c%89%e6%88%90%e5%91%98" aria-label="超类的私有成员">超类的私有成员</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99" aria-label="参考资料">参考资料</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><link rel="stylesheet" href="/css/notice.css">


<div class="notice info">
    子类对象拥有父类的私有成员，但子类不继承父类的私有属性。
</div>
<h1 id="子类对象包含父类私有属性">子类对象包含父类私有属性<a hidden class="anchor" aria-hidden="true" href="#子类对象包含父类私有属性">#</a></h1>
<p>首先验证子类对象包含父类的私有属性，代码如下：</p>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details open>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >class Parent {
    private int privateField;

    public Parent() {
        System.out.println("this in Parent() => " + this);
        this.privateField = 666;
    }

    public Parent(int privateField) {
        System.out.println("this in Parent(int) => " + this);
        this.privateField = privateField;
    }

    private void printPrivateField() {
        System.out.println(this.privateField);
    }

    public void accessPrivateMembers() {
        System.out.println("this in accessPrivateMembers() => " + this);
        System.out.print("调用 this.printPrivateField() 方法 => ");
        this.printPrivateField();
    }
}

class Child extends Parent {
    public Child() {
        System.out.println("this in Child() => " + this);
    }
}

public class Main {
    public static void main(String[] args) {
        Child child = new Child();
        child.accessPrivateMembers();
    }
}
</code></pre>
    </div>
</div>

        </div>
    </details>
</div>
<p>上述代码输出结果为：</p>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-bash" data-lang="bash" >this in Parent() => Child@372f7a8d
this in Child() => Child@372f7a8d
this in accessPrivateMembers() => Child@372f7a8d
调用 this.printPrivateField() 方法 => 666
</code></pre>
    </div>
</div>
<p>上述代码的输出结果表明，执行 <code>new Child()</code> 后，会调用子类 <code>Child</code> 的无参构造器，而在子类构造器中默认会调用父类的无参构造器。而从输出结果可知，父类无参构造中的 <code>this</code> 指向子类 <code>Child</code>。并且 <code>this.privateField = 666;</code> 也成功执行。同样地，在调用公有（<code>public</code>）方法 <code>accessPrivateMembers()</code> 时，此时的 <code>this</code> 为 <code>Child</code>，并且通过 <code>this</code> 也可以访问父类的私有方法 <code>printPrivateFields()</code>。显然，<code>this</code> 中包含父类的私有属性 <code>privateField</code> 和私有方法 <code>printPrivateField()</code>。事实上，可以通过 <code>org.openjdk.jol</code> 工具中的 <code>ClassLayout</code> 来查看 <code>child</code> 对象在内存中的布局。代码如下：</p>
<head>
    <style>
         
        .collapsibleContainer {
            margin: 20px 0;
        }

        details summary {
            cursor: pointer;
        }

         
        details summary::-webkit-details-marker {
            display: none;
        }
    </style>
</head>

<div class="collapsibleContainer">
    <details open>
        <summary>点击查看代码</summary>
        <div>
            
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >import org.openjdk.jol.info.ClassLayout;

class Parent {
    private int privateField;

    public Parent() {
        System.out.println("this in Parent() => " + this);
        this.privateField = 666;
    }

    public Parent(int privateField) {
        System.out.println("this in Parent(int) => " + this);
        this.privateField = privateField;
    }

    private void printPrivateField() {
        System.out.println(this.privateField);
    }

    public void accessPrivateMembers() {
        System.out.println("this in accessPrivateMembers() => " + this);
        System.out.print("调用 this.printPrivateField() 方法 => ");
        this.printPrivateField();
    }
}

class Child extends Parent {
    public Child() {
        System.out.println("this in Child() => " + this);
    }
}

public static void main(String[] args) {
    Child child = new Child();
    String childLayout = ClassLayout.parseInstance(child).toPrintable();
    System.out.println(childLayout);
}
</code></pre>
    </div>
</div>

        </div>
    </details>
</div>
<p>上述代码输出结果为：</p>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/a11y-dark.min.css"
    integrity="sha512-Vj6gPCk8EZlqnoveEyuGyYaWZ1+jyjMPg8g4shwyyNlRQl6d3L9At02ZHQr5K6s5duZl/+YKMnM3/8pDhoUphg=="
    crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/java.min.js"></script>
<script>hljs.highlightAll();</script>





<div class="code_blocks">
    <div class="code_block active">
        <pre><code class="language-java" data-lang="java" >Child object internals:
OFF  SZ   TYPE DESCRIPTION               VALUE
  0   8        (object header: mark)     0x000000372f7a8d01 (hash: 0x372f7a8d; age: 0)
  8   4        (object header: class)    0x01001418
 12   4    int Parent.privateField       666
Instance size: 16 bytes
Space losses: 0 bytes internal + 0 bytes external = 0 bytes total
</code></pre>
    </div>
</div>
<p>根据上述输出结果可以看出，<code>child</code> 对象中确实包含父类的私有属性。</p>
<h1 id="java-语言规范中关于类成员的规定">Java 语言规范中关于类成员的规定<a hidden class="anchor" aria-hidden="true" href="#java-语言规范中关于类成员的规定">#</a></h1>
<h2 id="java-类成员">Java 类成员<a hidden class="anchor" aria-hidden="true" href="#java-类成员">#</a></h2>
<p>Java 语言规范中关于类成的部分陈述如下：</p>
<blockquote>
<p>类的成员包括以下所有成员（The members of a class type are all of the following）：</p>
<ul>
<li>从除 Object 类之外的直接父类继承的成员（Members inherited from its direct superclass, except in class Object, which has no direct superclass）</li>
<li>从任何直接父接口继承的成员（Members inherited from any direct superinterfaces）</li>
<li>类中声明的成员（Members declared in the body of the class）</li>
</ul>
</blockquote>
<blockquote>
<p><strong>类中声明为私有的成员不会被该类的子类继承。</strong>（Members of a class that are declared private are not inherited by subclasses of that class.）</p>
</blockquote>
<blockquote>
<p>只有声明为受保护（protected）或公共（public）的类成员才会被本包外的子类继承。（Only members of a class that are declared protected or public are inherited by subclasses declared in a package other than the one in which the class is declared.）</p>
</blockquote>
<blockquote>
<p>构造器（constructors）、静态初始化器（static initializers）和实例初始化器（instance initializers）不是类成员，因此不会被继承。（Constructors, static initializers, and instance initializers are not members and therefore are not inherited.）</p>
</blockquote>
<h2 id="超类的私有成员">超类的私有成员<a hidden class="anchor" aria-hidden="true" href="#超类的私有成员">#</a></h2>
<p>Oracle 官方 Java 教程中关于超类的私有成员的说明：</p>
<blockquote>
<p><strong>子类不继承父类的私有成员。不过，如果超类有访问其私有字段的公共或保护方法，子类也可以使用这些方法（间接访问父类的私有属性）。</strong>（A subclass does not inherit the private members of its parent class. However, if the superclass has public or protected methods for accessing its private fields, these can also be used by the subclass.）</p>
</blockquote>
<link rel="stylesheet" href="/css/notice.css">


<div class="notice info">
    官方已明确说明子类不继承父类的私有成员，那为什么子类对象可以访问父类的私有成员呢？博主认为，<!-- raw HTML omitted -->继承是发生在类之间行为，而非对象之间的行为。<!-- raw HTML omitted -->子类 Child 不继承父类 Parent 的私有成员，并不代表子类对象 child 不可以拥有父类的私有成员。
</div>
<h1 id="参考资料">参考资料<a hidden class="anchor" aria-hidden="true" href="#参考资料">#</a></h1>
<ol>
<li><a href="https://www.zhihu.com/question/51345942/answer/145388196">知乎：java中子类有没有继承父类的私有变量？</a></li>
<li><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-">Java Language Specification : 8.2. Class Members</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html">Oracle Java Tutorial: Private Members in a Superclass</a></li>
<li><a href="https://stackoverflow.com/questions/4716040/do-subclasses-inherit-private-fields/4716335#4716335">Do subclasses inherit private fields?</a></li>
</ol>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://signalyu.github.io/tags/%E5%B7%A5%E7%A8%8B%E4%B8%8E%E6%8A%80%E6%9C%AF/">工程与技术</a></li>
      <li><a href="https://signalyu.github.io/tags/tech/">Tech</a></li>
      <li><a href="https://signalyu.github.io/tags/java/">Java</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://signalyu.github.io/posts/4-engineering-and-technology/tech/maven/1-maven-notes/">
    <span class="title">« 上一页</span>
    
    <br>
    <span>Maven 笔记</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://signalyu.github.io/">信一的博客</a></span> · 
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>

</body>
</html>
